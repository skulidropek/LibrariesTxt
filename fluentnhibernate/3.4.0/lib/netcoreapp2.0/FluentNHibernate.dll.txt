public class FluentNHibernate.AssemblyTypeSource : object {
    private Assembly source;
    public AssemblyTypeSource(Assembly source);
    public sealed virtual IEnumerable`1<Type> GetTypes();
    public sealed virtual void LogSource(IDiagnosticLogger logger);
    public sealed virtual string GetIdentifier();
    public virtual int GetHashCode();
}
public class FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration : object {
    [CompilerGeneratedAttribute]
private Assembly <overrideAssembly>P;
    public AutoMappingOverrideAlteration(Assembly overrideAssembly);
    public sealed virtual void Alter(AutoPersistenceModel model);
}
public interface FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration {
    public abstract virtual void Alter(AutoPersistenceModel model);
}
public interface FluentNHibernate.Automapping.Alterations.IAutoMappingOverride`1 {
    public abstract virtual void Override(AutoMapping`1<T> mapping);
}
public class FluentNHibernate.Automapping.AutoJoinedSubClassPart`1 : JoinedSubClassPart`1<T> {
    private MappingProviderStore providers;
    private List`1<Member> mappedMembers;
    public AutoJoinedSubClassPart`1(string keyColumn);
    private AutoJoinedSubClassPart`1(string keyColumn, MappingProviderStore providers);
    public object GetMapping();
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.DiscriminateSubClassesOnColumn(string column);
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.AlterModel(ClassMappingBase mapping);
    internal virtual void OnMemberMapped(Member member);
    public void JoinedSubClass(string keyColumn, Action`1<AutoJoinedSubClassPart`1<TSubclass>> action);
    public sealed virtual IAutoClasslike JoinedSubClass(Type type, string keyColumn);
    public void SubClass(string discriminatorValue, Action`1<AutoSubClassPart`1<TSubclass>> action);
    public sealed virtual IAutoClasslike SubClass(Type type, string discriminatorValue);
    public sealed virtual ClassMapping GetClassMapping();
    public sealed virtual HibernateMapping GetHibernateMapping();
    public sealed virtual IEnumerable`1<Member> GetIgnoredProperties();
}
public class FluentNHibernate.Automapping.AutoJoinPart`1 : JoinPart`1<T> {
    [CompilerGeneratedAttribute]
private IList`1<Member> <mappedMembers>P;
    public AutoJoinPart`1(IList`1<Member> mappedMembers, string tableName);
    internal virtual void OnMemberMapped(Member member);
}
public static class FluentNHibernate.Automapping.AutoMap : object {
    public static AutoPersistenceModel AssemblyOf();
    public static AutoPersistenceModel AssemblyOf(IAutomappingConfiguration cfg);
    public static AutoPersistenceModel Assembly(Assembly assembly);
    public static AutoPersistenceModel Assembly(Assembly assembly, IAutomappingConfiguration cfg);
    public static AutoPersistenceModel Assemblies(Assembly[] assemblies);
    public static AutoPersistenceModel Assemblies(IAutomappingConfiguration cfg, Assembly[] assemblies);
    public static AutoPersistenceModel Assemblies(IAutomappingConfiguration cfg, IEnumerable`1<Assembly> assemblies);
    public static AutoPersistenceModel Source(ITypeSource source);
    public static AutoPersistenceModel Source(ITypeSource source, IAutomappingConfiguration cfg);
    [ObsoleteAttribute("Depreciated overload. Use either chained Where method or ShouldMap(Type) in IAutomappingConfiguration.")]
public static AutoPersistenceModel Source(ITypeSource source, Func`2<Type, bool> where);
    [ObsoleteAttribute("Depreciated overload. Use either chained Where method or ShouldMap(Type) in IAutomappingConfiguration.")]
public static AutoPersistenceModel Assembly(Assembly assembly, Func`2<Type, bool> where);
    [ObsoleteAttribute("Depreciated overload. Use either chained Where method or ShouldMap(Type) in IAutomappingConfiguration.")]
public static AutoPersistenceModel AssemblyOf(Func`2<Type, bool> where);
}
public class FluentNHibernate.Automapping.AutomappedComponentResolver : object {
    [CompilerGeneratedAttribute]
private AutoMapper <mapper>P;
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    public AutomappedComponentResolver(AutoMapper mapper, IAutomappingConfiguration cfg);
    public sealed virtual ExternalComponentMapping Resolve(ComponentResolutionContext context, IEnumerable`1<IExternalComponentMappingProvider> componentProviders);
}
public class FluentNHibernate.Automapping.AutoMapper : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    [CompilerGeneratedAttribute]
private IConventionFinder <conventionFinder>P;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InlineOverride> <inlineOverrides>P;
    private List`1<AutoMapType> mappingTypes;
    public AutoMapper(IAutomappingConfiguration cfg, IConventionFinder conventionFinder, IEnumerable`1<InlineOverride> inlineOverrides);
    private void ApplyOverrides(Type classType, IList`1<Member> mappedMembers, ClassMappingBase mapping);
    public ClassMappingBase MergeMap(Type classType, ClassMappingBase mapping, IList`1<Member> mappedMembers);
    private void MapInheritanceTree(Type classType, ClassMappingBase mapping, IList`1<Member> mappedMembers);
    private static bool HasDiscriminator(ClassMappingBase mapping);
    private Dictionary`2<AutoMapType, AutoMapType> GetMappingTypesWithLogicalParents();
    private static AutoMapType GetLogicalParent(Type type, IDictionary`2<Type, AutoMapType> availableTypes);
    private void MapSubclass(IList`1<Member> mappedMembers, SubclassMapping subclass, AutoMapType inheritedClass);
    public virtual void ProcessClass(ClassMappingBase mapping, Type entityType, IList`1<Member> mappedMembers);
    private void TryMapProperty(ClassMappingBase mapping, Member member, IList`1<Member> mappedMembers);
    public ClassMapping Map(Type classType, List`1<AutoMapType> types);
    private static string GetDefaultTableName(Type type);
    public void FlagAsMapped(Type type);
    [CompilerGeneratedAttribute]
private bool <GetMappingTypesWithLogicalParents>b__9_0(AutoMapType x);
}
public class FluentNHibernate.Automapping.AutoMapping`1 : ClassMap`1<T> {
    private MappingProviderStore providers;
    private IList`1<Member> mappedMembers;
    public AutoMapping`1(IList`1<Member> mappedMembers);
    private AutoMapping`1(IList`1<Member> mappedMembers, AttributeStore attributes, MappingProviderStore providers);
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.DiscriminateSubClassesOnColumn(string column);
    private sealed virtual override IEnumerable`1<Member> FluentNHibernate.IMappingProvider.GetIgnoredProperties();
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.AlterModel(ClassMappingBase mapping);
    internal virtual void OnMemberMapped(Member member);
    public void IgnoreProperty(Expression`1<Func`2<T, object>> expression);
    private sealed virtual override IPropertyIgnorer FluentNHibernate.Automapping.IPropertyIgnorer.IgnoreProperty(string name);
    private sealed virtual override IPropertyIgnorer FluentNHibernate.Automapping.IPropertyIgnorer.IgnoreProperties(string first, String[] others);
    private sealed virtual override IPropertyIgnorer FluentNHibernate.Automapping.IPropertyIgnorer.IgnoreProperties(Func`2<Member, bool> predicate);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public AutoJoinedSubClassPart`1<TSubclass> JoinedSubClass(string keyColumn, Action`1<AutoJoinedSubClassPart`1<TSubclass>> action);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public sealed virtual IAutoClasslike JoinedSubClass(Type type, string keyColumn);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public AutoJoinedSubClassPart`1<TSubclass> JoinedSubClass(string keyColumn);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public AutoSubClassPart`1<TSubclass> SubClass(object discriminatorValue, Action`1<AutoSubClassPart`1<TSubclass>> action);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public AutoSubClassPart`1<TSubclass> SubClass(object discriminatorValue);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public sealed virtual IAutoClasslike SubClass(Type type, string discriminatorValue);
    private void Join(string table, Action`1<JoinPart`1<T>> action);
    public void Join(string table, Action`1<AutoJoinPart`1<T>> action);
    [ObsoleteAttribute("Imports aren't supported in overrides.", "True")]
public ImportPart ImportType();
    public void KeyColumn(string column);
    public void DiscriminatorValue(object discriminatorValue);
}
public class FluentNHibernate.Automapping.AutoMappingAlterationCollection : object {
    private List`1<IAutoMappingAlteration> alterations;
    private void Add(Type type);
    public AutoMappingAlterationCollection Add();
    public AutoMappingAlterationCollection Add(IAutoMappingAlteration alteration);
    public AutoMappingAlterationCollection AddFromAssembly(Assembly assembly);
    public AutoMappingAlterationCollection AddFromAssemblyOf();
    protected internal void Apply(AutoPersistenceModel model);
    public sealed virtual IEnumerator`1<IAutoMappingAlteration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class FluentNHibernate.Automapping.AutoMappingException : Exception {
    public AutoMappingException(string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected AutoMappingException(SerializationInfo info, StreamingContext context);
}
public class FluentNHibernate.Automapping.AutoMappingExpressions : object {
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override ShouldMap(Member)")]
public Func`2<Member, bool> FindMembers;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override IsId")]
public Func`2<Member, bool> FindIdentity;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override GetParentSideForManyToMany")]
public Func`3<Type, Type, Type> GetParentSideForManyToMany;
    [ObsoleteAttribute("Use IgnoreBase<T> or IgnoreBase(Type): AutoMap.AssemblyOf<Entity>().IgnoreBase(typeof(Parent<>))", "True")]
public Func`2<Type, bool> IsBaseType;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override IsConcreteBaseType")]
public Func`2<Type, bool> IsConcreteBaseType;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override IsComponent")]
public Func`2<Type, bool> IsComponentType;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override GetComponentColumnPrefix")]
public Func`2<Member, string> GetComponentColumnPrefix;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override IsDiscriminated")]
public Func`2<Type, bool> IsDiscriminated;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override GetDiscriminatorColumn")]
public Func`2<Type, string> DiscriminatorColumn;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override IsDiscriminated", "True")]
public Func`2<Type, SubclassStrategy> SubclassStrategy;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override AbstractClassIsLayerSupertype")]
public Func`2<Type, bool> AbstractClassIsLayerSupertype;
    [ObsoleteAttribute("Use an instance of IAutomappingConfiguration for configuration, and override SimpleTypeCollectionValueColumn")]
public Func`2<Member, string> SimpleTypeCollectionValueColumn;
}
public class FluentNHibernate.Automapping.AutoMapType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMapped>k__BackingField;
    public Type Type { get; public set; }
    public bool IsMapped { get; public set; }
    public AutoMapType(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMapped();
    [CompilerGeneratedAttribute]
public void set_IsMapped(bool value);
}
public class FluentNHibernate.Automapping.AutoPersistenceModel : PersistenceModel {
    private IAutomappingConfiguration cfg;
    private AutoMappingExpressions expressions;
    private AutoMapper autoMapper;
    private List`1<ITypeSource> sources;
    private Func`2<Type, bool> whereClause;
    private List`1<AutoMapType> mappingTypes;
    private bool autoMappingsCreated;
    private AutoMappingAlterationCollection alterations;
    private List`1<InlineOverride> inlineOverrides;
    private List`1<Type> ignoredTypes;
    private List`1<Type> includedTypes;
    public SetupConventionFinder`1<AutoPersistenceModel> Conventions { get; }
    private bool HasUserDefinedConfiguration { get; }
    public AutoPersistenceModel(IAutomappingConfiguration cfg);
    public AutoPersistenceModel AddMappingsFromAssemblyOf();
    public AutoPersistenceModel AddMappingsFromAssembly(Assembly assembly);
    public AutoPersistenceModel AddMappingsFromSource(ITypeSource source);
    public AutoPersistenceModel Alterations(Action`1<AutoMappingAlterationCollection> alterationDelegate);
    public AutoPersistenceModel UseOverridesFromAssemblyOf();
    public AutoPersistenceModel UseOverridesFromAssembly(Assembly assembly);
    public SetupConventionFinder`1<AutoPersistenceModel> get_Conventions();
    [ObsoleteAttribute("Depreciated in favour of supplying your own IAutomappingConfiguration instance to AutoMap: AutoMap.AssemblyOf<T>(your_configuration_instance)")]
public AutoPersistenceModel Setup(Action`1<AutoMappingExpressions> expressionsAction);
    public AutoPersistenceModel Where(Func`2<Type, bool> where);
    public virtual IEnumerable`1<HibernateMapping> BuildMappings();
    private void CompileMappings();
    private int InheritanceHierarchyDepth(Type type);
    public virtual void Configure(Configuration configuration);
    private void AddMapping(Type type);
    private Type GetTypeToMap(Type type);
    private bool ShouldMapParent(Type type);
    private bool ShouldMap(Type type);
    public IMappingProvider FindMapping();
    public IMappingProvider FindMapping(Type type);
    public AutoPersistenceModel AddEntityAssembly(Assembly assembly);
    public AutoPersistenceModel AddTypeSource(ITypeSource source);
    public AutoPersistenceModel AddFilter();
    internal void AddOverride(Type type, Action`1<object> action);
    public AutoPersistenceModel Override(Action`1<AutoMapping`1<T>> populateMap);
    private static bool IsAutomappingForType(object o, Type entityType);
    public void Override(Type overrideType);
    private void OverrideHelper(AutoMapping`1<T> x, IAutoMappingOverride`1<T> mappingOverride);
    public AutoPersistenceModel OverrideAll(Action`1<IPropertyIgnorer> alteration);
    public AutoPersistenceModel IgnoreBase();
    public AutoPersistenceModel IgnoreBase(Type baseType);
    public AutoPersistenceModel IncludeBase();
    public AutoPersistenceModel IncludeBase(Type baseType);
    protected virtual string GetMappingFileName();
    private bool get_HasUserDefinedConfiguration();
    [CompilerGeneratedAttribute]
private int <CompileMappings>b__24_1(Type x);
}
public class FluentNHibernate.Automapping.AutoSubClassPart`1 : SubClassPart`1<T> {
    private MappingProviderStore providers;
    private List`1<Member> mappedMembers;
    public AutoSubClassPart`1(DiscriminatorPart parent, string discriminatorValue);
    public AutoSubClassPart`1(DiscriminatorPart parent, object discriminatorValue);
    private AutoSubClassPart`1(DiscriminatorPart parent, object discriminatorValue, MappingProviderStore providers);
    public object GetMapping();
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.DiscriminateSubClassesOnColumn(string column);
    private sealed virtual override void FluentNHibernate.Automapping.IAutoClasslike.AlterModel(ClassMappingBase mapping);
    internal virtual void OnMemberMapped(Member member);
    public void JoinedSubClass(string keyColumn, Action`1<AutoJoinedSubClassPart`1<TSubclass>> action);
    public sealed virtual IAutoClasslike JoinedSubClass(Type type, string keyColumn);
    public void SubClass(string discriminatorValue, Action`1<AutoSubClassPart`1<TSubclass>> action);
    public sealed virtual IAutoClasslike SubClass(Type type, string discriminatorValue);
    public sealed virtual ClassMapping GetClassMapping();
    public sealed virtual HibernateMapping GetHibernateMapping();
    public sealed virtual IEnumerable`1<Member> GetIgnoredProperties();
}
public class FluentNHibernate.Automapping.DefaultAutomappingConfiguration : object {
    public virtual bool ShouldMap(Member member);
    public virtual bool ShouldMap(Type type);
    public virtual bool IsId(Member member);
    public virtual Access GetAccessStrategyForReadOnlyProperty(Member member);
    public virtual Type GetParentSideForManyToMany(Type left, Type right);
    public virtual bool IsConcreteBaseType(Type type);
    public virtual bool IsComponent(Type type);
    public virtual string GetComponentColumnPrefix(Member member);
    public virtual bool IsDiscriminated(Type type);
    public virtual string GetDiscriminatorColumn(Type type);
    [ObsoleteAttribute("Use IsDiscriminated instead.", "True")]
public sealed virtual SubclassStrategy GetSubclassStrategy(Type type);
    public virtual bool AbstractClassIsLayerSupertype(Type type);
    public virtual string SimpleTypeCollectionValueColumn(Member member);
    public virtual bool IsVersion(Member member);
    public virtual IEnumerable`1<IAutomappingStep> GetMappingSteps(AutoMapper mapper, IConventionFinder conventionFinder);
}
internal class FluentNHibernate.Automapping.ExpressionBasedAutomappingConfiguration : DefaultAutomappingConfiguration {
    [CompilerGeneratedAttribute]
private AutoMappingExpressions <expressions>P;
    public ExpressionBasedAutomappingConfiguration(AutoMappingExpressions expressions);
    public virtual bool ShouldMap(Member member);
    public virtual bool IsId(Member member);
    public virtual Type GetParentSideForManyToMany(Type left, Type right);
    public virtual bool IsConcreteBaseType(Type type);
    public virtual bool IsComponent(Type type);
    public virtual string GetComponentColumnPrefix(Member member);
    public virtual bool IsDiscriminated(Type type);
    public virtual string GetDiscriminatorColumn(Type type);
    public virtual bool AbstractClassIsLayerSupertype(Type type);
    public virtual string SimpleTypeCollectionValueColumn(Member member);
}
public interface FluentNHibernate.Automapping.IAutoClasslike {
    public abstract virtual void DiscriminateSubClassesOnColumn(string column);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public abstract virtual IAutoClasslike JoinedSubClass(Type type, string keyColumn);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public abstract virtual IAutoClasslike SubClass(Type type, string discriminatorValue);
    public abstract virtual void AlterModel(ClassMappingBase mapping);
}
public interface FluentNHibernate.Automapping.IAutomappingConfiguration {
    public abstract virtual bool ShouldMap(Type type);
    public abstract virtual bool ShouldMap(Member member);
    public abstract virtual bool IsId(Member member);
    public abstract virtual Access GetAccessStrategyForReadOnlyProperty(Member member);
    public abstract virtual Type GetParentSideForManyToMany(Type left, Type right);
    public abstract virtual bool IsConcreteBaseType(Type type);
    public abstract virtual bool IsComponent(Type type);
    public abstract virtual string GetComponentColumnPrefix(Member member);
    public abstract virtual bool IsDiscriminated(Type type);
    public abstract virtual string GetDiscriminatorColumn(Type type);
    [ObsoleteAttribute("Use IsDiscriminated instead.", "True")]
public abstract virtual SubclassStrategy GetSubclassStrategy(Type type);
    public abstract virtual bool AbstractClassIsLayerSupertype(Type type);
    public abstract virtual string SimpleTypeCollectionValueColumn(Member member);
    public abstract virtual bool IsVersion(Member member);
    public abstract virtual IEnumerable`1<IAutomappingStep> GetMappingSteps(AutoMapper mapper, IConventionFinder conventionFinder);
}
public class FluentNHibernate.Automapping.InlineOverride : object {
    [CompilerGeneratedAttribute]
private Type <type>P;
    [CompilerGeneratedAttribute]
private Action`1<object> <action>P;
    public InlineOverride(Type type, Action`1<object> action);
    public bool CanOverride(Type otherType);
    public void Apply(object mapping);
}
public interface FluentNHibernate.Automapping.IPropertyIgnorer {
    public abstract virtual IPropertyIgnorer IgnoreProperty(string name);
    public abstract virtual IPropertyIgnorer IgnoreProperties(string first, String[] others);
    public abstract virtual IPropertyIgnorer IgnoreProperties(Func`2<Member, bool> predicate);
}
[ObsoleteAttribute("Depreciated in favour of supplying your own IAutomappingConfiguration instance to AutoMap: AutoMap.AssemblyOf<T>(your_configuration_instance)")]
public class FluentNHibernate.Automapping.PrivateAutoPersistenceModel : AutoPersistenceModel {
    private static bool findMembers(Member member);
    private static bool findIdentity(Member member);
}
public class FluentNHibernate.Automapping.Steps.AutoKeyMapper : object {
    public void SetKey(Member property, ClassMappingBase classMap, CollectionMapping mapping);
}
public class FluentNHibernate.Automapping.Steps.CollectionStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    private AutoKeyMapper keys;
    public CollectionStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private void SetDefaultAccess(Member member, CollectionMapping mapping);
    private static void SetRelationship(Member property, ClassMappingBase classMap, CollectionMapping mapping);
}
public class FluentNHibernate.Automapping.Steps.ComponentStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    public ComponentStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
}
public class FluentNHibernate.Automapping.Steps.HasManyStep : object {
    private SimpleTypeCollectionStep simpleTypeCollectionStepStep;
    private CollectionStep collectionStep;
    public HasManyStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
}
public class FluentNHibernate.Automapping.Steps.HasManyToManyStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    public HasManyToManyStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    private static Member GetInverseProperty(Member member);
    private static CollectionMapping GetCollection(Member property);
    private void ConfigureModel(Member member, CollectionMapping mapping, ClassMappingBase classMap, Type parentSide);
    private void SetDefaultAccess(Member member, CollectionMapping mapping);
    private static ICollectionRelationshipMapping CreateManyToMany(Member property, Type child, Type parent);
    private static void SetKey(Member property, ClassMappingBase classMap, CollectionMapping mapping);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
}
public interface FluentNHibernate.Automapping.Steps.IAutomappingStep {
    public abstract virtual bool ShouldMap(Member member);
    public abstract virtual void Map(ClassMappingBase classMap, Member member);
}
public class FluentNHibernate.Automapping.Steps.IdentityStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    private List`1<Type> identityCompatibleTypes;
    public IdentityStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private void SetDefaultAccess(Member member, IdMapping mapping);
    private GeneratorMapping GetDefaultGenerator(Member property);
}
public class FluentNHibernate.Automapping.Steps.PropertyStep : object {
    [CompilerGeneratedAttribute]
private IConventionFinder <conventionFinder>P;
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    public PropertyStep(IConventionFinder conventionFinder, IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    private bool HasExplicitTypeConvention(Member property);
    private static bool IsMappableToColumnType(Member property);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private PropertyMapping GetPropertyMapping(Type type, Member property);
    private void SetDefaultAccess(Member member, PropertyMapping mapping);
    private static TypeReference GetDefaultType(Member property);
}
public class FluentNHibernate.Automapping.Steps.ReferenceStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    private Func`2<Member, bool> findPropertyconvention;
    public ReferenceStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private ManyToOneMapping CreateMapping(Member member);
    private void SetDefaultAccess(Member member, ManyToOneMapping mapping);
}
public class FluentNHibernate.Automapping.Steps.SimpleTypeCollectionStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    private AutoKeyMapper keys;
    public SimpleTypeCollectionStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private void SetDefaultAccess(Member member, CollectionMapping mapping);
    private void SetElement(Member property, ClassMappingBase classMap, CollectionMapping mapping);
}
public class FluentNHibernate.Automapping.Steps.VersionStep : object {
    [CompilerGeneratedAttribute]
private IAutomappingConfiguration <cfg>P;
    public VersionStep(IAutomappingConfiguration cfg);
    public sealed virtual bool ShouldMap(Member member);
    public sealed virtual void Map(ClassMappingBase classMap, Member member);
    private void SetDefaultAccess(Member member, VersionMapping mapping);
    private static bool IsSqlTimestamp(Member property);
    private static TypeReference GetDefaultType(Member property);
}
[ObsoleteAttribute("Use IsDiscriminated in IAutomappingConfiguration instead")]
public enum FluentNHibernate.Automapping.SubclassStrategy : Enum {
    public int value__;
    public static SubclassStrategy JoinedSubclass;
    public static SubclassStrategy Subclass;
}
public class FluentNHibernate.Cfg.AutoMappingsContainer : object {
    private List`1<AutoPersistenceModel> mappings;
    private string exportPath;
    private TextWriter exportTextWriter;
    [CompilerGeneratedAttribute]
private bool <WasUsed>k__BackingField;
    internal bool WasUsed { get; internal set; }
    public AutoMappingsContainer Add(Func`1<AutoPersistenceModel> model);
    public AutoMappingsContainer Add(AutoPersistenceModel model);
    public AutoMappingsContainer ExportTo(string path);
    public AutoMappingsContainer ExportTo(TextWriter textWriter);
    [CompilerGeneratedAttribute]
internal bool get_WasUsed();
    [CompilerGeneratedAttribute]
internal void set_WasUsed(bool value);
    internal void Apply(Configuration cfg, PersistenceModel model);
    public sealed virtual IEnumerator`1<AutoPersistenceModel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class FluentNHibernate.Cfg.Db.CacheSettingsBuilder : object {
    protected static string ProviderClassKey;
    protected static string CacheUseMininmalPutsKey;
    protected static string CacheUseQueryCacheKey;
    protected static string CacheUseSecondLevelCacheKey;
    protected static string CacheQueryCacheFactoryKey;
    protected static string CacheRegionPrefixKey;
    private IDictionary`2<string, string> settings;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public CacheSettingsBuilder Not { get; }
    internal bool IsDirty { get; internal set; }
    public CacheSettingsBuilder get_Not();
    public CacheSettingsBuilder ProviderClass(string providerclass);
    public CacheSettingsBuilder ProviderClass();
    public CacheSettingsBuilder UseMinimalPuts();
    public CacheSettingsBuilder UseQueryCache();
    public CacheSettingsBuilder UseSecondLevelCache();
    public CacheSettingsBuilder QueryCacheFactory(string factory);
    public CacheSettingsBuilder QueryCacheFactory();
    public CacheSettingsBuilder RegionPrefix(string prefix);
    protected internal IDictionary`2<string, string> Create();
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
internal void set_IsDirty(bool value);
}
public class FluentNHibernate.Cfg.Db.ConnectionStringBuilder : object {
    private string connectionString;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    protected internal bool IsDirty { get; protected internal set; }
    public ConnectionStringBuilder Is(string rawConnectionString);
    [CompilerGeneratedAttribute]
protected internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
protected internal void set_IsDirty(bool value);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.DB2400Configuration : PersistenceConfiguration`2<DB2400Configuration, DB2400ConnectionStringBuilder> {
    public static DB2400Configuration Standard { get; }
    public static DB2400Configuration get_Standard();
}
public class FluentNHibernate.Cfg.Db.DB2400ConnectionStringBuilder : ConnectionStringBuilder {
    private string _dataSource;
    private string _userID;
    private string _password;
    protected internal virtual string Create();
    public DB2400ConnectionStringBuilder Password(string password);
    public DB2400ConnectionStringBuilder UserID(string userID);
    public DB2400ConnectionStringBuilder DataSource(string datasource);
}
public class FluentNHibernate.Cfg.Db.DB2Configuration : PersistenceConfiguration`2<DB2Configuration, DB2ConnectionStringBuilder> {
    public static DB2Configuration Standard { get; }
    public static DB2Configuration Informix1150 { get; }
    public static DB2Configuration get_Standard();
    public static DB2Configuration get_Informix1150();
}
public class FluentNHibernate.Cfg.Db.DB2ConnectionStringBuilder : ConnectionStringBuilder {
    private string server;
    private string database;
    private string username;
    private string password;
    public DB2ConnectionStringBuilder Server(string server);
    public DB2ConnectionStringBuilder Database(string database);
    public DB2ConnectionStringBuilder Username(string username);
    public DB2ConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.FirebirdConfiguration : PersistenceConfiguration`1<FirebirdConfiguration> {
}
public class FluentNHibernate.Cfg.Db.IfxDRDAConfiguration : PersistenceConfiguration`2<IfxDRDAConfiguration, IfxDRDAConnectionStringBuilder> {
    public static IfxDRDAConfiguration Informix { get; }
    public static IfxDRDAConfiguration Informix0940 { get; }
    public static IfxDRDAConfiguration Informix1000 { get; }
    public static IfxDRDAConfiguration get_Informix();
    public static IfxDRDAConfiguration get_Informix0940();
    public static IfxDRDAConfiguration get_Informix1000();
}
public class FluentNHibernate.Cfg.Db.IfxDRDAConnectionStringBuilder : ConnectionStringBuilder {
    private string authentication;
    private string database;
    private string hostVarParameter;
    private string isolationLevel;
    private string maxPoolSize;
    private string minPoolSize;
    private string password;
    private string pooling;
    private string server;
    private string username;
    private string otherOptions;
    public IfxDRDAConnectionStringBuilder Authentication(string authentication);
    public IfxDRDAConnectionStringBuilder Database(string database);
    public IfxDRDAConnectionStringBuilder HostVarParameter(string hostVarParameter);
    public IfxDRDAConnectionStringBuilder IsolationLevel(string isolationLevel);
    public IfxDRDAConnectionStringBuilder MaxPoolSize(string maxPoolSize);
    public IfxDRDAConnectionStringBuilder MinPoolSize(string minPoolSize);
    public IfxDRDAConnectionStringBuilder Password(string password);
    public IfxDRDAConnectionStringBuilder Pooling(string pooling);
    public IfxDRDAConnectionStringBuilder Server(string server);
    public IfxDRDAConnectionStringBuilder Username(string username);
    public IfxDRDAConnectionStringBuilder OtherOptions(string otherOptions);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.IfxOdbcConfiguration : PersistenceConfiguration`2<IfxOdbcConfiguration, OdbcConnectionStringBuilder> {
    public static IfxOdbcConfiguration Informix { get; }
    public static IfxOdbcConfiguration Informix0940 { get; }
    public static IfxOdbcConfiguration Informix1000 { get; }
    public static IfxOdbcConfiguration get_Informix();
    public static IfxOdbcConfiguration get_Informix0940();
    public static IfxOdbcConfiguration get_Informix1000();
}
public class FluentNHibernate.Cfg.Db.IfxSQLIConfiguration : PersistenceConfiguration`2<IfxSQLIConfiguration, IfxSQLIConnectionStringBuilder> {
    public static IfxSQLIConfiguration Informix { get; }
    public static IfxSQLIConfiguration Informix0940 { get; }
    public static IfxSQLIConfiguration Informix1000 { get; }
    public static IfxSQLIConfiguration get_Informix();
    public static IfxSQLIConfiguration get_Informix0940();
    public static IfxSQLIConfiguration get_Informix1000();
}
public class FluentNHibernate.Cfg.Db.IfxSQLIConnectionStringBuilder : ConnectionStringBuilder {
    private string clientLocale;
    private string database;
    private string databaseLocale;
    private bool delimident;
    private string host;
    private string maxPoolSize;
    private string minPoolSize;
    private string password;
    private string pooling;
    private string server;
    private string service;
    private string username;
    private string otherOptions;
    public IfxSQLIConnectionStringBuilder ClientLocale(string clientLocale);
    public IfxSQLIConnectionStringBuilder Database(string database);
    public IfxSQLIConnectionStringBuilder DatabaseLocale(string databaseLocale);
    public IfxSQLIConnectionStringBuilder Delimident(bool delimident);
    public IfxSQLIConnectionStringBuilder Host(string host);
    public IfxSQLIConnectionStringBuilder MaxPoolSize(string maxPoolSize);
    public IfxSQLIConnectionStringBuilder MinPoolSize(string minPoolSize);
    public IfxSQLIConnectionStringBuilder Password(string password);
    public IfxSQLIConnectionStringBuilder Pooling(string pooling);
    public IfxSQLIConnectionStringBuilder Server(string server);
    public IfxSQLIConnectionStringBuilder Service(string service);
    public IfxSQLIConnectionStringBuilder Username(string username);
    public IfxSQLIConnectionStringBuilder OtherOptions(string otherOptions);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.IngresConfiguration : PersistenceConfiguration`2<IngresConfiguration, IngresConnectionStringBuilder> {
    public static IngresConfiguration Standard { get; }
    public static IngresConfiguration get_Standard();
}
public class FluentNHibernate.Cfg.Db.IngresConnectionStringBuilder : ConnectionStringBuilder {
    private string server;
    private string database;
    private string port;
    private string username;
    private string password;
    public IngresConnectionStringBuilder Server(string server);
    public IngresConnectionStringBuilder Database(string database);
    public IngresConnectionStringBuilder Port(string port);
    public IngresConnectionStringBuilder Username(string username);
    public IngresConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public interface FluentNHibernate.Cfg.Db.IPersistenceConfigurer {
    public abstract virtual Configuration ConfigureProperties(Configuration nhibernateConfig);
}
public class FluentNHibernate.Cfg.Db.JetDriverConfiguration : PersistenceConfiguration`2<JetDriverConfiguration, JetDriverConnectionStringBuilder> {
    public static JetDriverConfiguration Standard { get; }
    public static JetDriverConfiguration get_Standard();
}
public class FluentNHibernate.Cfg.Db.JetDriverConnectionStringBuilder : ConnectionStringBuilder {
    private string databaseFile;
    private string provider;
    private string username;
    private string password;
    public JetDriverConnectionStringBuilder Provider(string provider);
    public JetDriverConnectionStringBuilder DatabaseFile(string databaseFile);
    public JetDriverConnectionStringBuilder Username(string username);
    public JetDriverConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.MsSqlCeConfiguration : PersistenceConfiguration`1<MsSqlCeConfiguration> {
    public static MsSqlCeConfiguration Standard { get; }
    public static MsSqlCeConfiguration MsSqlCe40 { get; }
    public static MsSqlCeConfiguration get_Standard();
    public static MsSqlCeConfiguration get_MsSqlCe40();
}
public class FluentNHibernate.Cfg.Db.MsSqlConfiguration : PersistenceConfiguration`2<MsSqlConfiguration, MsSqlConnectionStringBuilder> {
    public static MsSqlConfiguration MsSql7 { get; }
    public static MsSqlConfiguration MsSql2000 { get; }
    public static MsSqlConfiguration MsSql2005 { get; }
    public static MsSqlConfiguration MsSql2008 { get; }
    public static MsSqlConfiguration MsSql2012 { get; }
    public static MsSqlConfiguration get_MsSql7();
    public static MsSqlConfiguration get_MsSql2000();
    public static MsSqlConfiguration get_MsSql2005();
    public static MsSqlConfiguration get_MsSql2008();
    public static MsSqlConfiguration get_MsSql2012();
}
public class FluentNHibernate.Cfg.Db.MsSqlConnectionStringBuilder : ConnectionStringBuilder {
    private string server;
    private string database;
    private string username;
    private string password;
    private bool trustedConnection;
    public MsSqlConnectionStringBuilder Server(string server);
    public MsSqlConnectionStringBuilder Database(string database);
    public MsSqlConnectionStringBuilder Username(string username);
    public MsSqlConnectionStringBuilder Password(string password);
    public MsSqlConnectionStringBuilder TrustedConnection();
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.MsSqliteConfiguration : PersistenceConfiguration`1<MsSqliteConfiguration> {
    public static MsSqliteConfiguration Standard { get; }
    public static MsSqliteConfiguration get_Standard();
    public MsSqliteConfiguration InMemory();
    public MsSqliteConfiguration UsingFile(string fileName);
}
public class FluentNHibernate.Cfg.Db.MySQLConfiguration : PersistenceConfiguration`2<MySQLConfiguration, MySQLConnectionStringBuilder> {
    public static MySQLConfiguration Standard { get; }
    public static MySQLConfiguration get_Standard();
}
public class FluentNHibernate.Cfg.Db.MySQLConnectionStringBuilder : ConnectionStringBuilder {
    private string server;
    private Nullable`1<int> port;
    private string database;
    private string username;
    private string password;
    public MySQLConnectionStringBuilder Server(string server);
    public MySQLConnectionStringBuilder Server(String[] servers);
    public MySQLConnectionStringBuilder Port(int port);
    public MySQLConnectionStringBuilder Database(string database);
    public MySQLConnectionStringBuilder Username(string username);
    public MySQLConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.OdbcConnectionStringBuilder : ConnectionStringBuilder {
    private string dsn;
    private string username;
    private string password;
    private string otherOptions;
    public OdbcConnectionStringBuilder Dsn(string dsn);
    public OdbcConnectionStringBuilder Username(string username);
    public OdbcConnectionStringBuilder Password(string password);
    public OdbcConnectionStringBuilder OtherOptions(string otherOptions);
    protected internal virtual string Create();
}
[ObsoleteAttribute("Use OracleManagedDataClientConfiguration or OracleDataClientConfiguration instead.")]
public class FluentNHibernate.Cfg.Db.OracleClientConfiguration : PersistenceConfiguration`2<OracleClientConfiguration, OracleConnectionStringBuilder> {
    public static OracleClientConfiguration Oracle9 { get; }
    public static OracleClientConfiguration Oracle10 { get; }
    public static OracleClientConfiguration get_Oracle9();
    public static OracleClientConfiguration get_Oracle10();
}
[ObsoleteAttribute("Replaced by OracleDataClientConfiguration. Also, for System.Data.OracleClient, use OracleClientConfiguration.")]
public class FluentNHibernate.Cfg.Db.OracleConfiguration : PersistenceConfiguration`2<OracleConfiguration, OracleConnectionStringBuilder> {
    public static OracleConfiguration Oracle8 { get; }
    public static OracleConfiguration Oracle9 { get; }
    public static OracleConfiguration Oracle10 { get; }
    public static OracleConfiguration get_Oracle8();
    public static OracleConfiguration get_Oracle9();
    public static OracleConfiguration get_Oracle10();
}
public class FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder : ConnectionStringBuilder {
    private string instance;
    private string otherOptions;
    private string password;
    private int port;
    private string server;
    private string username;
    private bool pooling;
    private string statementCacheSize;
    public OracleConnectionStringBuilder Server(string server);
    public OracleConnectionStringBuilder Instance(string instance);
    public OracleConnectionStringBuilder Username(string username);
    public OracleConnectionStringBuilder Password(string password);
    public OracleConnectionStringBuilder Port(int port);
    public OracleConnectionStringBuilder Pooling(bool pooling);
    public OracleConnectionStringBuilder StatementCacheSize(int cacheSize);
    public OracleConnectionStringBuilder OtherOptions(string otherOptions);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.OracleDataClientConfiguration : PersistenceConfiguration`2<OracleDataClientConfiguration, OracleConnectionStringBuilder> {
    public static OracleDataClientConfiguration Oracle9 { get; }
    public static OracleDataClientConfiguration Oracle10 { get; }
    public static OracleDataClientConfiguration get_Oracle9();
    public static OracleDataClientConfiguration get_Oracle10();
}
public class FluentNHibernate.Cfg.Db.OracleManagedDataClientConfiguration : PersistenceConfiguration`2<OracleManagedDataClientConfiguration, OracleConnectionStringBuilder> {
    public static OracleManagedDataClientConfiguration Oracle9 { get; }
    public static OracleManagedDataClientConfiguration Oracle10 { get; }
    public static OracleManagedDataClientConfiguration get_Oracle9();
    public static OracleManagedDataClientConfiguration get_Oracle10();
}
public abstract class FluentNHibernate.Cfg.Db.PersistenceConfiguration`1 : PersistenceConfiguration`2<TThisConfiguration, ConnectionStringBuilder> {
}
public abstract class FluentNHibernate.Cfg.Db.PersistenceConfiguration`2 : object {
    protected static string DialectKey;
    protected static string AltDialectKey;
    protected static string DefaultSchemaKey;
    protected static string UseOuterJoinKey;
    protected static string MaxFetchDepthKey;
    protected static string UseReflectionOptimizerKey;
    protected static string QuerySubstitutionsKey;
    protected static string ShowSqlKey;
    protected static string FormatSqlKey;
    protected static string CollectionTypeFactoryClassKey;
    protected static string ConnectionProviderKey;
    protected static string DefaultConnectionProviderClassName;
    protected static string DriverClassKey;
    protected static string ConnectionStringKey;
    protected static string IsolationLevelKey;
    protected static string AdoNetBatchSizeKey;
    protected static string CurrentSessionContextClassKey;
    private Dictionary`2<string, string> values;
    private bool nextBoolSettingValue;
    private TConnectionString connectionString;
    private CacheSettingsBuilder cache;
    public TThisConfiguration DoNot { get; }
    protected virtual IDictionary`2<string, string> CreateProperties();
    [IteratorStateMachineAttribute("FluentNHibernate.Cfg.Db.PersistenceConfiguration`2/<OverridenDefaults>d__23")]
private static IEnumerable`1<string> OverridenDefaults(IDictionary`2<string, string> settings);
    private static IEnumerable`1<string> KeysToPreserve(Configuration nhibernateConfig, IDictionary`2<string, string> settings);
    public sealed virtual Configuration ConfigureProperties(Configuration nhibernateConfig);
    public IDictionary`2<string, string> ToProperties();
    protected void ToggleBooleanSetting(string settingKey);
    public TThisConfiguration get_DoNot();
    public TThisConfiguration Dialect(string dialect);
    public TThisConfiguration Dialect();
    public TThisConfiguration DefaultSchema(string schema);
    public TThisConfiguration UseOuterJoin();
    public TThisConfiguration MaxFetchDepth(int maxFetchDepth);
    public TThisConfiguration UseReflectionOptimizer();
    public TThisConfiguration QuerySubstitutions(string substitutions);
    public TThisConfiguration ShowSql();
    public TThisConfiguration FormatSql();
    public TThisConfiguration Provider(string provider);
    public TThisConfiguration Provider();
    public TThisConfiguration Driver(string driverClass);
    public TThisConfiguration Driver();
    public TThisConfiguration ConnectionString(Action`1<TConnectionString> connectionStringExpression);
    public TThisConfiguration ConnectionString(string value);
    public TThisConfiguration Raw(string key, string value);
    public TThisConfiguration AdoNetBatchSize(int size);
    public TThisConfiguration IsolationLevel(IsolationLevel connectionIsolation);
    public TThisConfiguration IsolationLevel(string connectionIsolation);
}
public class FluentNHibernate.Cfg.Db.PostgreSQLConfiguration : PersistenceConfiguration`2<PostgreSQLConfiguration, PostgreSQLConnectionStringBuilder> {
    public static PostgreSQLConfiguration Standard { get; }
    public static PostgreSQLConfiguration PostgreSQL81 { get; }
    public static PostgreSQLConfiguration PostgreSQL82 { get; }
    public static PostgreSQLConfiguration PostgreSQL83 { get; }
    public static PostgreSQLConfiguration get_Standard();
    public static PostgreSQLConfiguration get_PostgreSQL81();
    public static PostgreSQLConfiguration get_PostgreSQL82();
    public static PostgreSQLConfiguration get_PostgreSQL83();
}
public class FluentNHibernate.Cfg.Db.PostgreSQLConnectionStringBuilder : ConnectionStringBuilder {
    private string host;
    private int port;
    private string database;
    private string username;
    private string password;
    public PostgreSQLConnectionStringBuilder Host(string host);
    public PostgreSQLConnectionStringBuilder Port(int port);
    public PostgreSQLConnectionStringBuilder Database(string database);
    public PostgreSQLConnectionStringBuilder Username(string username);
    public PostgreSQLConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.Db.SQLAnywhereConfiguration : PersistenceConfiguration`2<SQLAnywhereConfiguration, SybaseSQLAnywhereConnectionStringBuilder> {
    public static SQLAnywhereConfiguration SQLAnywhere9 { get; }
    public static SQLAnywhereConfiguration SQLAnywhere10 { get; }
    public static SQLAnywhereConfiguration SQLAnywhere11 { get; }
    public static SQLAnywhereConfiguration SQLAnywhere12 { get; }
    public static SQLAnywhereConfiguration SQLAnywhere17 { get; }
    public static SQLAnywhereConfiguration get_SQLAnywhere9();
    public static SQLAnywhereConfiguration get_SQLAnywhere10();
    public static SQLAnywhereConfiguration get_SQLAnywhere11();
    public static SQLAnywhereConfiguration get_SQLAnywhere12();
    public static SQLAnywhereConfiguration get_SQLAnywhere17();
}
public class FluentNHibernate.Cfg.Db.SQLiteConfiguration : PersistenceConfiguration`1<SQLiteConfiguration> {
    public static SQLiteConfiguration Standard { get; }
    public static SQLiteConfiguration get_Standard();
    public SQLiteConfiguration InMemory();
    public SQLiteConfiguration UsingFile(string fileName);
    public SQLiteConfiguration UsingFileWithPassword(string fileName, string password);
}
public class FluentNHibernate.Cfg.Db.SybaseSQLAnywhereConnectionStringBuilder : ConnectionStringBuilder {
    private string server;
    private string links;
    private string username;
    private string password;
    public SybaseSQLAnywhereConnectionStringBuilder Server(string server);
    public SybaseSQLAnywhereConnectionStringBuilder Links(string links);
    public SybaseSQLAnywhereConnectionStringBuilder Username(string username);
    public SybaseSQLAnywhereConnectionStringBuilder Password(string password);
    protected internal virtual string Create();
}
public class FluentNHibernate.Cfg.FluentConfiguration : object {
    private static string ExceptionMessage;
    private static string ExceptionDatabaseMessage;
    private static string ExceptionMappingMessage;
    private static string CollectionTypeFactoryClassKey;
    private static string ProxyFactoryFactoryClassKey;
    private static string DefaultProxyFactoryFactoryClassName;
    private static string CurrentSessionContextClassKey;
    private List`1<Action`1<Configuration>> configAlterations;
    private IDiagnosticMessageDispatcher dispatcher;
    private List`1<Action`1<MappingConfiguration>> mappingsBuilders;
    private bool dbSet;
    private bool mappingsSet;
    private IDiagnosticLogger logger;
    private CacheSettingsBuilder cache;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    internal Configuration Configuration { get; }
    internal FluentConfiguration(Configuration cfg);
    [CompilerGeneratedAttribute]
internal Configuration get_Configuration();
    public FluentConfiguration Diagnostics(Action`1<DiagnosticsConfiguration> diagnosticsSetup);
    public FluentConfiguration Database(Func`1<IPersistenceConfigurer> config);
    public FluentConfiguration Database(IPersistenceConfigurer config);
    public FluentConfiguration Cache(Action`1<CacheSettingsBuilder> cacheExpression);
    public FluentConfiguration CollectionTypeFactory(string collectionTypeFactoryClass);
    public FluentConfiguration CollectionTypeFactory(Type collectionTypeFactoryClass);
    public FluentConfiguration CollectionTypeFactory();
    public FluentConfiguration ProxyFactoryFactory(string proxyFactoryFactoryClass);
    public FluentConfiguration ProxyFactoryFactory(Type proxyFactoryFactory);
    public FluentConfiguration ProxyFactoryFactory();
    public FluentConfiguration CurrentSessionContext(string currentSessionContextClass);
    public FluentConfiguration CurrentSessionContext();
    public FluentConfiguration Mappings(Action`1<MappingConfiguration> mappings);
    public FluentConfiguration ExposeConfiguration(Action`1<Configuration> config);
    public ISessionFactory BuildSessionFactory();
    public Configuration BuildConfiguration();
    private FluentConfigurationException CreateConfigurationException(Exception innerException);
    [CompilerGeneratedAttribute]
private void <Diagnostics>b__19_0(IDiagnosticLogger new_logger);
}
public class FluentNHibernate.Cfg.FluentConfigurationException : Exception {
    [CompilerGeneratedAttribute]
private IList`1<string> <PotentialReasons>k__BackingField;
    public IList`1<string> PotentialReasons { get; }
    public string Message { get; }
    public FluentConfigurationException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected FluentConfigurationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IList`1<string> get_PotentialReasons();
    public virtual string get_Message();
    public virtual string ToString();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class FluentNHibernate.Cfg.Fluently : object {
    public FluentConfiguration BeginConfigure();
    public static FluentConfiguration Configure();
    public FluentConfiguration BeginConfigure(Configuration cfg);
    public static FluentConfiguration Configure(Configuration cfg);
}
public class FluentNHibernate.Cfg.FluentMappingsContainer : object {
    private List`1<Assembly> assemblies;
    private List`1<Type> types;
    private IConventionFinder conventionFinder;
    private string exportPath;
    private TextWriter exportTextWriter;
    private PairBiDirectionalManyToManySidesDelegate biDirectionalManyToManyPairer;
    [CompilerGeneratedAttribute]
private bool <WasUsed>k__BackingField;
    [ObsoleteAttribute("PersistenceModel is no longer available through FluentMappingsContainer. Use MappingConfiguration.UsePersistenceModel to supply a custom PersistenceModel", "True")]
public PersistenceModel PersistenceModel { get; }
    public SetupConventionFinder`1<FluentMappingsContainer> Conventions { get; }
    internal bool WasUsed { get; internal set; }
    public PersistenceModel get_PersistenceModel();
    public FluentMappingsContainer OverrideBiDirectionalManyToManyPairing(PairBiDirectionalManyToManySidesDelegate userControlledPairing);
    public FluentMappingsContainer AddFromAssemblyOf();
    public FluentMappingsContainer AddFromAssembly(Assembly assembly);
    public FluentMappingsContainer Add();
    public FluentMappingsContainer Add(Type type);
    public FluentMappingsContainer ExportTo(string path);
    public FluentMappingsContainer ExportTo(TextWriter textWriter);
    public SetupConventionFinder`1<FluentMappingsContainer> get_Conventions();
    [CompilerGeneratedAttribute]
internal bool get_WasUsed();
    [CompilerGeneratedAttribute]
internal void set_WasUsed(bool value);
    internal void Apply(PersistenceModel model);
}
public class FluentNHibernate.Cfg.HbmMappingsContainer : object {
    private List`1<Type> classes;
    private List`1<Assembly> assemblies;
    [CompilerGeneratedAttribute]
private bool <WasUsed>k__BackingField;
    internal bool WasUsed { get; internal set; }
    public HbmMappingsContainer AddClasses(Type[] types);
    public HbmMappingsContainer AddFromAssemblyOf();
    public HbmMappingsContainer AddFromAssembly(Assembly assembly);
    [CompilerGeneratedAttribute]
internal bool get_WasUsed();
    [CompilerGeneratedAttribute]
internal void set_WasUsed(bool value);
    internal void Apply(Configuration cfg);
}
public class FluentNHibernate.Cfg.MappingConfiguration : object {
    private bool mergeMappings;
    private IDiagnosticLogger logger;
    private PersistenceModel model;
    [CompilerGeneratedAttribute]
private FluentMappingsContainer <FluentMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoMappingsContainer <AutoMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private HbmMappingsContainer <HbmMappings>k__BackingField;
    public FluentMappingsContainer FluentMappings { get; }
    public AutoMappingsContainer AutoMappings { get; }
    public HbmMappingsContainer HbmMappings { get; }
    public bool WasUsed { get; }
    public MappingConfiguration(IDiagnosticLogger logger);
    public MappingConfiguration UsePersistenceModel(PersistenceModel persistenceModel);
    [CompilerGeneratedAttribute]
public FluentMappingsContainer get_FluentMappings();
    [CompilerGeneratedAttribute]
public AutoMappingsContainer get_AutoMappings();
    [CompilerGeneratedAttribute]
public HbmMappingsContainer get_HbmMappings();
    public bool get_WasUsed();
    public void Apply(Configuration cfg);
    public MappingConfiguration MergeMappings();
}
public class FluentNHibernate.Cfg.SetupConventionFinder`1 : object {
    [CompilerGeneratedAttribute]
private TReturn <container>P;
    [CompilerGeneratedAttribute]
private IConventionFinder <conventionFinder>P;
    private ConventionsCollection FluentNHibernate.Conventions.IConventionFinder.Conventions { get; }
    public SetupConventionFinder`1(TReturn container, IConventionFinder conventionFinder);
    private sealed virtual override ConventionsCollection FluentNHibernate.Conventions.IConventionFinder.get_Conventions();
    public TReturn AddSource(ITypeSource source);
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.AddSource(ITypeSource source);
    public TReturn AddAssembly(Assembly assembly);
    public TReturn AddFromAssemblyOf();
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.AddFromAssemblyOf();
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.AddAssembly(Assembly assembly);
    public TReturn Add();
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.Add();
    public sealed virtual void Add(Type type, object instance);
    public TReturn Add(T instance);
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.Add(Type type);
    public TReturn Add(Type type);
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.Add(T instance);
    public TReturn Add(IConvention[] instances);
    public TReturn Setup(Action`1<IConventionFinder> setupAction);
    public sealed virtual IEnumerable`1<T> Find();
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.SetLogger(IDiagnosticLogger logger);
    private sealed virtual override void FluentNHibernate.Conventions.IConventionFinder.Merge(IConventionFinder other);
}
public class FluentNHibernate.CombinedAssemblyTypeSource : object {
    private AssemblyTypeSource[] sources;
    public CombinedAssemblyTypeSource(IEnumerable`1<AssemblyTypeSource> sources);
    public CombinedAssemblyTypeSource(IEnumerable`1<Assembly> sources);
    public sealed virtual IEnumerable`1<Type> GetTypes();
    public sealed virtual void LogSource(IDiagnosticLogger logger);
    public sealed virtual string GetIdentifier();
}
[ExtensionAttribute]
public static class FluentNHibernate.ConfigurationHelper : object {
    [ExtensionAttribute]
public static Configuration AddMappingsFromAssembly(Configuration configuration, Assembly assembly);
    [ExtensionAttribute]
public static Configuration AddAutoMappings(Configuration configuration, AutoPersistenceModel model);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.AnyExpectation`1 : object {
    private List`1<IAcceptanceCriteria`1<TInspector>> subCriteria;
    public AnyExpectation`1(IEnumerable`1<IAcceptanceCriteria`1<TInspector>> subCriteria);
    public bool Matches(IInspector inspector);
    private sealed virtual override bool FluentNHibernate.Conventions.AcceptanceCriteria.IExpectation.Matches(IInspector inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.CollectionExpectation`2 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> <expression>P;
    [CompilerGeneratedAttribute]
private ICollectionAcceptanceCriterion`1<TCollectionItem> <criterion>P;
    public CollectionExpectation`2(Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> expression, ICollectionAcceptanceCriterion`1<TCollectionItem> criterion);
    public bool Matches(TInspector inspector);
    private sealed virtual override bool FluentNHibernate.Conventions.AcceptanceCriteria.IExpectation.Matches(IInspector inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.ConcreteAcceptanceCriteria`1 : object {
    private List`1<IExpectation> expectations;
    public IEnumerable`1<IExpectation> Expectations { get; }
    public sealed virtual IAcceptanceCriteria`1<TInspector> SameAs();
    public sealed virtual IAcceptanceCriteria`1<TInspector> OppositeOf();
    public virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, object>> propertyExpression, IAcceptanceCriterion value);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, string>> expression, IAcceptanceCriterion value);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Expect(Func`2<TInspector, bool> evaluation);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> property, ICollectionAcceptanceCriterion`1<TCollectionItem> value);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Any(Action`1[] criteriaAlterations);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Any(IAcceptanceCriteria`1[] subCriteria);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Either(Action`1<IAcceptanceCriteria`1<TInspector>> criteriaAlterationA, Action`1<IAcceptanceCriteria`1<TInspector>> criteriaAlterationB);
    public sealed virtual IAcceptanceCriteria`1<TInspector> Either(IAcceptanceCriteria`1<TInspector> subCriteriaA, IAcceptanceCriteria`1<TInspector> subCriteriaB);
    public sealed virtual IEnumerable`1<IExpectation> get_Expectations();
    public sealed virtual bool Matches(IInspector inspector);
    protected virtual IExpectation CreateExpectation(Expression`1<Func`2<TInspector, object>> expression, IAcceptanceCriterion value);
    protected virtual IExpectation CreateEvalExpectation(Func`2<TInspector, bool> expression);
    protected virtual IExpectation CreateCollectionExpectation(Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> property, ICollectionAcceptanceCriterion`1<TCollectionItem> value);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.EmptyCriterion : object {
    [CompilerGeneratedAttribute]
private bool <inverse>P;
    public EmptyCriterion(bool inverse);
    public sealed virtual bool IsSatisfiedBy(Expression`1<Func`2<T, object>> propertyExpression, T inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.EqualCriterion : object {
    [CompilerGeneratedAttribute]
private bool <inverse>P;
    [CompilerGeneratedAttribute]
private object <value>P;
    public EqualCriterion(bool inverse, object value);
    public sealed virtual bool IsSatisfiedBy(Expression`1<Func`2<T, object>> propertyExpression, T inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.EvalExpectation`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<TInspector, bool> <expression>P;
    public EvalExpectation`1(Func`2<TInspector, bool> expression);
    public bool Matches(TInspector inspector);
    private sealed virtual override bool FluentNHibernate.Conventions.AcceptanceCriteria.IExpectation.Matches(IInspector inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.Expectation`1 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TInspector, object>> <expression>P;
    [CompilerGeneratedAttribute]
private IAcceptanceCriterion <value>P;
    public Expectation`1(Expression`1<Func`2<TInspector, object>> expression, IAcceptanceCriterion value);
    public bool Matches(TInspector inspector);
    private sealed virtual override bool FluentNHibernate.Conventions.AcceptanceCriteria.IExpectation.Matches(IInspector inspector);
}
public interface FluentNHibernate.Conventions.AcceptanceCriteria.IAcceptanceCriteria`1 {
    public IEnumerable`1<IExpectation> Expectations { get; }
    public abstract virtual IAcceptanceCriteria`1<TInspector> SameAs();
    public abstract virtual IAcceptanceCriteria`1<TInspector> OppositeOf();
    public abstract virtual IAcceptanceCriteria`1<TInspector> Expect(Func`2<TInspector, bool> evaluation);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, object>> propertyExpression, IAcceptanceCriterion value);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, string>> propertyExpression, IAcceptanceCriterion value);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Expect(Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> property, ICollectionAcceptanceCriterion`1<TCollectionItem> value);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Any(Action`1[] criteriaAlterations);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Any(IAcceptanceCriteria`1[] subCriteria);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Either(Action`1<IAcceptanceCriteria`1<TInspector>> criteriaAlterationA, Action`1<IAcceptanceCriteria`1<TInspector>> criteriaAlterationB);
    public abstract virtual IAcceptanceCriteria`1<TInspector> Either(IAcceptanceCriteria`1<TInspector> subCriteriaA, IAcceptanceCriteria`1<TInspector> subCriteriaB);
    public abstract virtual IEnumerable`1<IExpectation> get_Expectations();
    public abstract virtual bool Matches(IInspector inspector);
}
public interface FluentNHibernate.Conventions.AcceptanceCriteria.IAcceptanceCriterion {
    public abstract virtual bool IsSatisfiedBy(Expression`1<Func`2<T, object>> propertyExpression, T inspector);
}
public interface FluentNHibernate.Conventions.AcceptanceCriteria.ICollectionAcceptanceCriterion`1 {
    public abstract virtual bool IsSatisfiedBy(Expression`1<Func`2<T, IEnumerable`1<TCollectionItem>>> propertyExpression, T inspector);
}
public interface FluentNHibernate.Conventions.AcceptanceCriteria.IExpectation {
    public abstract virtual bool Matches(IInspector inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.InverseIs : object {
    public IAcceptanceCriterion Set { get; }
    public IAcceptanceCriterion get_Set();
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.InvertedExpectation : object {
    [CompilerGeneratedAttribute]
private IExpectation <expectation>P;
    public InvertedExpectation(IExpectation expectation);
    public sealed virtual bool Matches(IInspector inspector);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.InverterAcceptanceCriteria`1 : ConcreteAcceptanceCriteria`1<TInspector> {
    protected virtual IExpectation CreateExpectation(Expression`1<Func`2<TInspector, object>> expression, IAcceptanceCriterion value);
    protected virtual IExpectation CreateEvalExpectation(Func`2<TInspector, bool> expression);
    protected virtual IExpectation CreateCollectionExpectation(Expression`1<Func`2<TInspector, IEnumerable`1<TCollectionItem>>> property, ICollectionAcceptanceCriterion`1<TCollectionItem> value);
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.Is : object {
    public static IAcceptanceCriterion Set { get; }
    [DebuggerBrowsableAttribute("0")]
public static InverseIs Not { get; }
    public static IAcceptanceCriterion get_Set();
    public static InverseIs get_Not();
}
public class FluentNHibernate.Conventions.AcceptanceCriteria.SetCriterion : object {
    [CompilerGeneratedAttribute]
private bool <inverse>P;
    public SetCriterion(bool inverse);
    public sealed virtual bool IsSatisfiedBy(Expression`1<Func`2<T, object>> expression, T inspector);
}
public abstract class FluentNHibernate.Conventions.AccessConvention : object {
    protected abstract virtual void Apply(Type owner, string name, IAccessInstance access);
    public virtual void Apply(IIdentityInstance instance);
    public virtual void Apply(ICompositeIdentityInstance instance);
    public virtual void Apply(IKeyPropertyInstance instance);
    public virtual void Apply(IKeyManyToOneInstance instance);
    public virtual void Apply(IVersionInstance instance);
    public virtual void Apply(IPropertyInstance instance);
    public virtual void Apply(IComponentInstance instance);
    public virtual void Apply(IDynamicComponentInstance instance);
    public virtual void Apply(IOneToOneInstance instance);
    public virtual void Apply(IManyToOneInstance instance);
    public virtual void Apply(ICollectionInstance instance);
    public virtual void Apply(IAnyInstance instance);
}
public abstract class FluentNHibernate.Conventions.AttributeCollectionConvention`1 : object {
    public sealed virtual void Accept(IAcceptanceCriteria`1<ICollectionInspector> criteria);
    public sealed virtual void Apply(ICollectionInstance instance);
    protected abstract virtual void Apply(T attribute, ICollectionInstance instance);
}
public abstract class FluentNHibernate.Conventions.AttributePropertyConvention`1 : object {
    public sealed virtual void Accept(IAcceptanceCriteria`1<IPropertyInspector> criteria);
    public sealed virtual void Apply(IPropertyInstance instance);
    protected abstract virtual void Apply(T attribute, IPropertyInstance instance);
}
[DefaultMemberAttribute("Item")]
public class FluentNHibernate.Conventions.ConventionsCollection : object {
    private List`1<AddedConvention> inner;
    private List`1<Type> types;
    public IEnumerable`1<object> Item { get; }
    public sealed virtual IEnumerator`1<Type> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Contains(Type type);
    public void Add(T instance);
    public void Add(Type type, object instance);
    public IEnumerable`1<object> get_Item(Type type);
    public void Merge(ConventionsCollection conventions);
}
public class FluentNHibernate.Conventions.DefaultConventionFinder : object {
    private IDiagnosticLogger log;
    [CompilerGeneratedAttribute]
private ConventionsCollection <Conventions>k__BackingField;
    public ConventionsCollection Conventions { get; }
    [IteratorStateMachineAttribute("FluentNHibernate.Conventions.DefaultConventionFinder/<Find>d__1`1")]
public sealed virtual IEnumerable`1<T> Find();
    public sealed virtual void SetLogger(IDiagnosticLogger logger);
    public sealed virtual void Merge(IConventionFinder conventionFinder);
    [CompilerGeneratedAttribute]
public sealed virtual ConventionsCollection get_Conventions();
    public sealed virtual void AddSource(ITypeSource source);
    public sealed virtual void AddAssembly(Assembly assembly);
    public sealed virtual void AddFromAssemblyOf();
    public sealed virtual void Add();
    public sealed virtual void Add(Type type);
    public sealed virtual void Add(Type type, object instance);
    public sealed virtual void Add(T instance);
    private void Add(Type type, MissingConstructor missingConstructor);
    private bool AllowMultiplesOf(Type type);
    private object Instantiate(Type type);
    private bool HasValidConstructor(Type type);
    private bool IsFinderConstructor(ConstructorInfo constructor);
    private bool IsParameterlessConstructor(ConstructorInfo constructor);
}
[ExtensionAttribute]
public static class FluentNHibernate.Conventions.EnumerableExtensionsForConventions : object {
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> collection, string expected);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> collection, Func`2<T, bool> prediate);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool IsNotEmpty(IEnumerable`1<T> collection);
}
public abstract class FluentNHibernate.Conventions.ForeignKeyConvention : object {
    protected abstract virtual string GetKeyName(Member property, Type type);
    public sealed virtual void Apply(IManyToOneInstance instance);
    public sealed virtual void Apply(IManyToManyCollectionInstance instance);
    public sealed virtual void Apply(IJoinedSubclassInstance instance);
    public sealed virtual void Apply(IJoinInstance instance);
    public sealed virtual void Apply(ICollectionInstance instance);
}
public static class FluentNHibernate.Conventions.Helpers.AutoImport : object {
    public static IHibernateMappingConvention Always();
    public static IHibernateMappingConvention Never();
}
[ObsoleteAttribute("Use CollectionConventionBuilder")]
public class FluentNHibernate.Conventions.Helpers.Builders.ArrayConventionBuilder : object {
    public sealed virtual IArrayConvention Always(Action`1<IArrayInstance> convention);
    public sealed virtual IArrayConvention When(Action`1<IAcceptanceCriteria`1<IArrayInspector>> expectations, Action`1<IArrayInstance> convention);
}
[ObsoleteAttribute("Use CollectionConventionBuilder")]
internal class FluentNHibernate.Conventions.Helpers.Builders.BagConventionBuilder : object {
    public sealed virtual IBagConvention Always(Action`1<IBagInstance> convention);
    public sealed virtual IBagConvention When(Action`1<IAcceptanceCriteria`1<IBagInspector>> expectations, Action`1<IBagInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.ClassConventionBuilder : object {
    public sealed virtual IClassConvention Always(Action`1<IClassInstance> convention);
    public sealed virtual IClassConvention When(Action`1<IAcceptanceCriteria`1<IClassInspector>> expectations, Action`1<IClassInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.CollectionConventionBuilder : object {
    public sealed virtual ICollectionConvention Always(Action`1<ICollectionInstance> convention);
    public sealed virtual ICollectionConvention When(Action`1<IAcceptanceCriteria`1<ICollectionInspector>> expectations, Action`1<ICollectionInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.ComponentConventionBuilder : object {
    public sealed virtual IComponentConvention Always(Action`1<IComponentInstance> convention);
    public sealed virtual IComponentConvention When(Action`1<IAcceptanceCriteria`1<IComponentInspector>> expectations, Action`1<IComponentInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.CompositeIdConventionBuilder : object {
    public sealed virtual ICompositeIdentityConvention Always(Action`1<ICompositeIdentityInstance> convention);
    public sealed virtual ICompositeIdentityConvention When(Action`1<IAcceptanceCriteria`1<ICompositeIdentityInspector>> expectations, Action`1<ICompositeIdentityInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.DynamicComponentConventionBuilder : object {
    public sealed virtual IDynamicComponentConvention Always(Action`1<IDynamicComponentInstance> convention);
    public sealed virtual IDynamicComponentConvention When(Action`1<IAcceptanceCriteria`1<IDynamicComponentInspector>> expectations, Action`1<IDynamicComponentInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Builders.HasManyConventionBuilder : object {
    public sealed virtual IHasManyConvention Always(Action`1<IOneToManyCollectionInstance> convention);
    public sealed virtual IHasManyConvention When(Action`1<IAcceptanceCriteria`1<IOneToManyCollectionInspector>> expectations, Action`1<IOneToManyCollectionInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Builders.HasManyToManyConventionBuilder : object {
    public sealed virtual IHasManyToManyConvention Always(Action`1<IManyToManyCollectionInstance> convention);
    public sealed virtual IHasManyToManyConvention When(Action`1<IAcceptanceCriteria`1<IManyToManyCollectionInspector>> expectations, Action`1<IManyToManyCollectionInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.HasOneConventionBuilder : object {
    public sealed virtual IHasOneConvention Always(Action`1<IOneToOneInstance> convention);
    public sealed virtual IHasOneConvention When(Action`1<IAcceptanceCriteria`1<IOneToOneInspector>> expectations, Action`1<IOneToOneInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.HibernateMappingConventionBuilder : object {
    public sealed virtual IHibernateMappingConvention Always(Action`1<IHibernateMappingInstance> convention);
    public sealed virtual IHibernateMappingConvention When(Action`1<IAcceptanceCriteria`1<IHibernateMappingInspector>> expectations, Action`1<IHibernateMappingInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.IdConventionBuilder : object {
    public sealed virtual IIdConvention Always(Action`1<IIdentityInstance> convention);
    public sealed virtual IIdConvention When(Action`1<IAcceptanceCriteria`1<IIdentityInspector>> expectations, Action`1<IIdentityInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.JoinConventionBuilder : object {
    public sealed virtual IJoinConvention Always(Action`1<IJoinInstance> convention);
    public sealed virtual IJoinConvention When(Action`1<IAcceptanceCriteria`1<IJoinInspector>> expectations, Action`1<IJoinInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.JoinedSubclassConventionBuilder : object {
    public sealed virtual IJoinedSubclassConvention Always(Action`1<IJoinedSubclassInstance> convention);
    public sealed virtual IJoinedSubclassConvention When(Action`1<IAcceptanceCriteria`1<IJoinedSubclassInspector>> expectations, Action`1<IJoinedSubclassInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.KeyManyToOneConventionBuilder : object {
    public sealed virtual IKeyManyToOneConvention Always(Action`1<IKeyManyToOneInstance> convention);
    public sealed virtual IKeyManyToOneConvention When(Action`1<IAcceptanceCriteria`1<IKeyManyToOneInspector>> expectations, Action`1<IKeyManyToOneInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.KeyPropertyConventionBuilder : object {
    public sealed virtual IKeyPropertyConvention Always(Action`1<IKeyPropertyInstance> convention);
    public sealed virtual IKeyPropertyConvention When(Action`1<IAcceptanceCriteria`1<IKeyPropertyInspector>> expectations, Action`1<IKeyPropertyInstance> convention);
}
[ObsoleteAttribute("Use CollectionConventionBuilder")]
internal class FluentNHibernate.Conventions.Helpers.Builders.ListConventionBuilder : object {
    public sealed virtual IListConvention Always(Action`1<IListInstance> convention);
    public sealed virtual IListConvention When(Action`1<IAcceptanceCriteria`1<IListInspector>> expectations, Action`1<IListInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.ManyToManyCollectionConventionBuilder : object {
    public sealed virtual IHasManyToManyConvention Always(Action`1<IManyToManyCollectionInstance> convention);
    public sealed virtual IHasManyToManyConvention When(Action`1<IAcceptanceCriteria`1<IManyToManyCollectionInspector>> expectations, Action`1<IManyToManyCollectionInstance> convention);
}
[ObsoleteAttribute("Use CollectionConventionBuilder")]
internal class FluentNHibernate.Conventions.Helpers.Builders.MapConventionBuilder : object {
    public sealed virtual IMapConvention Always(Action`1<IMapInstance> convention);
    public sealed virtual IMapConvention When(Action`1<IAcceptanceCriteria`1<IMapInspector>> expectations, Action`1<IMapInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.OneToManyCollectionConventionBuilder : object {
    public sealed virtual IHasManyConvention Always(Action`1<IOneToManyCollectionInstance> convention);
    public sealed virtual IHasManyConvention When(Action`1<IAcceptanceCriteria`1<IOneToManyCollectionInspector>> expectations, Action`1<IOneToManyCollectionInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.PropertyConventionBuilder : object {
    public sealed virtual IPropertyConvention Always(Action`1<IPropertyInstance> convention);
    public sealed virtual IPropertyConvention When(Action`1<IAcceptanceCriteria`1<IPropertyInspector>> expectations, Action`1<IPropertyInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.ReferenceConventionBuilder : object {
    public sealed virtual IReferenceConvention Always(Action`1<IManyToOneInstance> convention);
    public sealed virtual IReferenceConvention When(Action`1<IAcceptanceCriteria`1<IManyToOneInspector>> expectations, Action`1<IManyToOneInstance> convention);
}
[ObsoleteAttribute("Use CollectionConventionBuilder")]
internal class FluentNHibernate.Conventions.Helpers.Builders.SetConventionBuilder : object {
    public sealed virtual ISetConvention Always(Action`1<ISetInstance> convention);
    public sealed virtual ISetConvention When(Action`1<IAcceptanceCriteria`1<ISetInspector>> expectations, Action`1<ISetInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.SubclassConventionBuilder : object {
    public sealed virtual ISubclassConvention Always(Action`1<ISubclassInstance> convention);
    public sealed virtual ISubclassConvention When(Action`1<IAcceptanceCriteria`1<ISubclassInspector>> expectations, Action`1<ISubclassInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Builders.VersionConventionBuilder : object {
    public sealed virtual IVersionConvention Always(Action`1<IVersionInstance> convention);
    public sealed virtual IVersionConvention When(Action`1<IAcceptanceCriteria`1<IVersionInspector>> expectations, Action`1<IVersionInstance> convention);
}
public static class FluentNHibernate.Conventions.Helpers.Cache : object {
    public static IClassConvention Is(Action`1<ICacheInstance> cache);
}
public static class FluentNHibernate.Conventions.Helpers.ConventionBuilder : object {
    public static IConventionBuilder`3<IClassConvention, IClassInspector, IClassInstance> Class { get; }
    public static IConventionBuilder`3<IIdConvention, IIdentityInspector, IIdentityInstance> Id { get; }
    public static IConventionBuilder`3<IPropertyConvention, IPropertyInspector, IPropertyInstance> Property { get; }
    public static IConventionBuilder`3<IHasManyConvention, IOneToManyCollectionInspector, IOneToManyCollectionInstance> HasMany { get; }
    public static IConventionBuilder`3<IHasManyToManyConvention, IManyToManyCollectionInspector, IManyToManyCollectionInstance> HasManyToMany { get; }
    public static IConventionBuilder`3<IReferenceConvention, IManyToOneInspector, IManyToOneInstance> Reference { get; }
    public static IConventionBuilder`3<IClassConvention, IClassInspector, IClassInstance> get_Class();
    public static IConventionBuilder`3<IIdConvention, IIdentityInspector, IIdentityInstance> get_Id();
    public static IConventionBuilder`3<IPropertyConvention, IPropertyInspector, IPropertyInstance> get_Property();
    public static IConventionBuilder`3<IHasManyConvention, IOneToManyCollectionInspector, IOneToManyCollectionInstance> get_HasMany();
    public static IConventionBuilder`3<IHasManyToManyConvention, IManyToManyCollectionInspector, IManyToManyCollectionInstance> get_HasManyToMany();
    public static IConventionBuilder`3<IReferenceConvention, IManyToOneInspector, IManyToOneInstance> get_Reference();
}
public static class FluentNHibernate.Conventions.Helpers.DefaultAccess : object {
    public static IHibernateMappingConvention Field();
    public static IHibernateMappingConvention BackField();
    public static IHibernateMappingConvention Property();
    public static IHibernateMappingConvention ReadOnlyProperty();
    public static IHibernateMappingConvention NoOp();
    public static IHibernateMappingConvention None();
    public static IHibernateMappingConvention CamelCaseField();
    public static IHibernateMappingConvention CamelCaseField(CamelCasePrefix prefix);
    public static IHibernateMappingConvention LowerCaseField();
    public static IHibernateMappingConvention LowerCaseField(LowerCasePrefix prefix);
    public static IHibernateMappingConvention PascalCaseField(PascalCasePrefix prefix);
    public static IHibernateMappingConvention ReadOnlyPropertyThroughCamelCaseField();
    public static IHibernateMappingConvention ReadOnlyPropertyThroughCamelCaseField(CamelCasePrefix prefix);
    public static IHibernateMappingConvention ReadOnlyPropertyThroughLowerCaseField();
    public static IHibernateMappingConvention ReadOnlyPropertyThroughLowerCaseField(LowerCasePrefix prefix);
    public static IHibernateMappingConvention ReadOnlyPropertyThroughPascalCaseField(PascalCasePrefix prefix);
    public static IHibernateMappingConvention Using(string value);
    public static IHibernateMappingConvention Using(Type access);
    public static IHibernateMappingConvention Using();
}
public static class FluentNHibernate.Conventions.Helpers.DefaultCascade : object {
    public static IHibernateMappingConvention All();
    public static IHibernateMappingConvention None();
    public static IHibernateMappingConvention SaveUpdate();
    public static IHibernateMappingConvention Delete();
    public static IHibernateMappingConvention Merge();
}
public static class FluentNHibernate.Conventions.Helpers.DefaultLazy : object {
    public static IHibernateMappingConvention Always();
    public static IHibernateMappingConvention Never();
}
public static class FluentNHibernate.Conventions.Helpers.DynamicInsert : object {
    public static IClassConvention AlwaysTrue();
    public static IClassConvention AlwaysFalse();
}
public static class FluentNHibernate.Conventions.Helpers.DynamicUpdate : object {
    public static IClassConvention AlwaysTrue();
    public static IClassConvention AlwaysFalse();
}
public static class FluentNHibernate.Conventions.Helpers.ForeignKey : object {
    public static ForeignKeyConvention EndsWith(string suffix);
    public static ForeignKeyConvention Format(Func`3<Member, Type, string> format);
}
public interface FluentNHibernate.Conventions.Helpers.IConventionBuilder`3 {
    public abstract virtual TConvention Always(Action`1<TInstance> convention);
    public abstract virtual TConvention When(Action`1<IAcceptanceCriteria`1<TInspector>> expectations, Action`1<TInstance> convention);
}
public static class FluentNHibernate.Conventions.Helpers.LazyLoad : object {
    public static IClassConvention Always();
    public static IClassConvention Never();
}
public static class FluentNHibernate.Conventions.Helpers.OptimisticLock : object {
    public static IClassConvention Is(Action`1<IOptimisticLockInstance> locking);
}
[ObsoleteAttribute("Use BuiltCollectionConvention")]
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltArrayConvention : BuiltConventionBase`2<IArrayInspector, IArrayInstance> {
    public BuiltArrayConvention(Action`1<IAcceptanceCriteria`1<IArrayInspector>> accept, Action`1<IArrayInstance> convention);
}
[ObsoleteAttribute("Use BuiltCollectionConvention")]
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltBagConvention : BuiltConventionBase`2<IBagInspector, IBagInstance> {
    public BuiltBagConvention(Action`1<IAcceptanceCriteria`1<IBagInspector>> accept, Action`1<IBagInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltClassConvention : BuiltConventionBase`2<IClassInspector, IClassInstance> {
    public BuiltClassConvention(Action`1<IAcceptanceCriteria`1<IClassInspector>> accept, Action`1<IClassInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltCollectionConvention : BuiltConventionBase`2<ICollectionInspector, ICollectionInstance> {
    public BuiltCollectionConvention(Action`1<IAcceptanceCriteria`1<ICollectionInspector>> accept, Action`1<ICollectionInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltComponentConvention : BuiltConventionBase`2<IComponentInspector, IComponentInstance> {
    public BuiltComponentConvention(Action`1<IAcceptanceCriteria`1<IComponentInspector>> accept, Action`1<IComponentInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltCompositeIdConvention : BuiltConventionBase`2<ICompositeIdentityInspector, ICompositeIdentityInstance> {
    public BuiltCompositeIdConvention(Action`1<IAcceptanceCriteria`1<ICompositeIdentityInspector>> accept, Action`1<ICompositeIdentityInstance> convention);
}
[MultipleAttribute]
public abstract class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltConventionBase`2 : object {
    [CompilerGeneratedAttribute]
private Action`1<IAcceptanceCriteria`1<TInspector>> <accept>P;
    [CompilerGeneratedAttribute]
private Action`1<TInstance> <convention>P;
    protected BuiltConventionBase`2(Action`1<IAcceptanceCriteria`1<TInspector>> accept, Action`1<TInstance> convention);
    public sealed virtual void Accept(IAcceptanceCriteria`1<TInspector> acceptance);
    public sealed virtual void Apply(TInstance instance);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltDynamicComponentConvention : BuiltConventionBase`2<IDynamicComponentInspector, IDynamicComponentInstance> {
    public BuiltDynamicComponentConvention(Action`1<IAcceptanceCriteria`1<IDynamicComponentInspector>> accept, Action`1<IDynamicComponentInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltFuncForeignKeyConvention : ForeignKeyConvention {
    [CompilerGeneratedAttribute]
private Func`3<Member, Type, string> <format>P;
    public BuiltFuncForeignKeyConvention(Func`3<Member, Type, string> format);
    protected virtual string GetKeyName(Member property, Type type);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltHasManyConvention : BuiltConventionBase`2<IOneToManyCollectionInspector, IOneToManyCollectionInstance> {
    public BuiltHasManyConvention(Action`1<IAcceptanceCriteria`1<IOneToManyCollectionInspector>> accept, Action`1<IOneToManyCollectionInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltHasManyToManyConvention : BuiltConventionBase`2<IManyToManyCollectionInspector, IManyToManyCollectionInstance> {
    public BuiltHasManyToManyConvention(Action`1<IAcceptanceCriteria`1<IManyToManyCollectionInspector>> accept, Action`1<IManyToManyCollectionInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltHasOneConvention : BuiltConventionBase`2<IOneToOneInspector, IOneToOneInstance> {
    public BuiltHasOneConvention(Action`1<IAcceptanceCriteria`1<IOneToOneInspector>> accept, Action`1<IOneToOneInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltHibernateMappingConvention : BuiltConventionBase`2<IHibernateMappingInspector, IHibernateMappingInstance> {
    public BuiltHibernateMappingConvention(Action`1<IAcceptanceCriteria`1<IHibernateMappingInspector>> accept, Action`1<IHibernateMappingInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltIdConvention : BuiltConventionBase`2<IIdentityInspector, IIdentityInstance> {
    public BuiltIdConvention(Action`1<IAcceptanceCriteria`1<IIdentityInspector>> accept, Action`1<IIdentityInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltJoinConvention : BuiltConventionBase`2<IJoinInspector, IJoinInstance> {
    public BuiltJoinConvention(Action`1<IAcceptanceCriteria`1<IJoinInspector>> accept, Action`1<IJoinInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltJoinedSubclassConvention : BuiltConventionBase`2<IJoinedSubclassInspector, IJoinedSubclassInstance> {
    public BuiltJoinedSubclassConvention(Action`1<IAcceptanceCriteria`1<IJoinedSubclassInspector>> accept, Action`1<IJoinedSubclassInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltKeyManyToOneConvention : BuiltConventionBase`2<IKeyManyToOneInspector, IKeyManyToOneInstance> {
    public BuiltKeyManyToOneConvention(Action`1<IAcceptanceCriteria`1<IKeyManyToOneInspector>> accept, Action`1<IKeyManyToOneInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltKeyPropertyConvention : BuiltConventionBase`2<IKeyPropertyInspector, IKeyPropertyInstance> {
    public BuiltKeyPropertyConvention(Action`1<IAcceptanceCriteria`1<IKeyPropertyInspector>> accept, Action`1<IKeyPropertyInstance> convention);
}
[ObsoleteAttribute("Use BuiltCollectionConvention")]
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltListConvention : BuiltConventionBase`2<IListInspector, IListInstance> {
    public BuiltListConvention(Action`1<IAcceptanceCriteria`1<IListInspector>> accept, Action`1<IListInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltManyToManyCollectionConvention : BuiltConventionBase`2<IManyToManyCollectionInspector, IManyToManyCollectionInstance> {
    public BuiltManyToManyCollectionConvention(Action`1<IAcceptanceCriteria`1<IManyToManyCollectionInspector>> accept, Action`1<IManyToManyCollectionInstance> convention);
}
[ObsoleteAttribute("Use BuiltCollectionConvention")]
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltMapConvention : BuiltConventionBase`2<IMapInspector, IMapInstance> {
    public BuiltMapConvention(Action`1<IAcceptanceCriteria`1<IMapInspector>> accept, Action`1<IMapInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltOneToManyCollectionConvention : BuiltConventionBase`2<IOneToManyCollectionInspector, IOneToManyCollectionInstance> {
    public BuiltOneToManyCollectionConvention(Action`1<IAcceptanceCriteria`1<IOneToManyCollectionInspector>> accept, Action`1<IOneToManyCollectionInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltPropertyConvention : BuiltConventionBase`2<IPropertyInspector, IPropertyInstance> {
    public BuiltPropertyConvention(Action`1<IAcceptanceCriteria`1<IPropertyInspector>> accept, Action`1<IPropertyInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltProxyConvention : ProxyConvention {
    public BuiltProxyConvention(Type proxyType, Type persistentType);
    protected BuiltProxyConvention(Func`2<Type, Type> mapPersistentTypeToProxyInterfaceType, Func`2<Type, Type> mapProxyInterfaceTypeToPersistentType);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltReferenceConvention : BuiltConventionBase`2<IManyToOneInspector, IManyToOneInstance> {
    public BuiltReferenceConvention(Action`1<IAcceptanceCriteria`1<IManyToOneInspector>> accept, Action`1<IManyToOneInstance> convention);
}
[ObsoleteAttribute("Use BuiltCollectionConvention")]
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltSetConvention : BuiltConventionBase`2<ISetInspector, ISetInstance> {
    public BuiltSetConvention(Action`1<IAcceptanceCriteria`1<ISetInspector>> accept, Action`1<ISetInstance> convention);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltSubclassConvention : BuiltConventionBase`2<ISubclassInspector, ISubclassInstance> {
    public BuiltSubclassConvention(Action`1<IAcceptanceCriteria`1<ISubclassInspector>> accept, Action`1<ISubclassInstance> convention);
}
public class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltSuffixForeignKeyConvention : ForeignKeyConvention {
    [CompilerGeneratedAttribute]
private string <suffix>P;
    public BuiltSuffixForeignKeyConvention(string suffix);
    protected virtual string GetKeyName(Member property, Type type);
}
internal class FluentNHibernate.Conventions.Helpers.Prebuilt.BuiltVersionConvention : BuiltConventionBase`2<IVersionInspector, IVersionInstance> {
    public BuiltVersionConvention(Action`1<IAcceptanceCriteria`1<IVersionInspector>> accept, Action`1<IVersionInstance> convention);
}
public static class FluentNHibernate.Conventions.Helpers.PrimaryKey : object {
    public static PrimaryKeyNameBuilder Name { get; }
    public static PrimaryKeyNameBuilder get_Name();
}
public class FluentNHibernate.Conventions.Helpers.PrimaryKeyNameBuilder : object {
    public IIdConvention Is(Func`2<IIdentityInspector, string> nameFunc);
}
public class FluentNHibernate.Conventions.Helpers.Proxy`1 : object {
    public static ProxyConvention UsedForType();
}
public static class FluentNHibernate.Conventions.Helpers.Table : object {
    public static IClassConvention Is(Func`2<IClassInspector, string> tableName);
}
public interface FluentNHibernate.Conventions.IAnyConvention {
}
[ObsoleteAttribute("Use ICollectionConvention with an acceptance criteria")]
public interface FluentNHibernate.Conventions.IArrayConvention {
}
[ObsoleteAttribute("Use ICollectionConventionAcceptance")]
public interface FluentNHibernate.Conventions.IArrayConventionAcceptance {
}
[ObsoleteAttribute("Use ICollectionConvention with an acceptance criteria")]
public interface FluentNHibernate.Conventions.IBagConvention {
}
[ObsoleteAttribute("Use ICollectionConventionAcceptance")]
public interface FluentNHibernate.Conventions.IBagConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IClassConvention {
}
public interface FluentNHibernate.Conventions.IClassConventionAcceptance {
}
public interface FluentNHibernate.Conventions.ICollectionConvention {
}
public interface FluentNHibernate.Conventions.ICollectionConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IColumnConvention {
}
public interface FluentNHibernate.Conventions.IColumnConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IComponentConvention {
}
public interface FluentNHibernate.Conventions.IComponentConventionAcceptance {
}
public interface FluentNHibernate.Conventions.ICompositeIdentityConvention {
}
public interface FluentNHibernate.Conventions.ICompositeIdentityConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IConvention {
}
public interface FluentNHibernate.Conventions.IConvention`2 {
    public abstract virtual void Apply(TInstance instance);
}
public interface FluentNHibernate.Conventions.IConventionAcceptance`1 {
    public abstract virtual void Accept(IAcceptanceCriteria`1<TInspector> criteria);
}
public interface FluentNHibernate.Conventions.IConventionFinder {
    public ConventionsCollection Conventions { get; }
    public abstract virtual ConventionsCollection get_Conventions();
    public abstract virtual void AddSource(ITypeSource source);
    public abstract virtual void AddAssembly(Assembly assembly);
    public abstract virtual void AddFromAssemblyOf();
    public abstract virtual void Add();
    public abstract virtual void Add(Type type);
    public abstract virtual void Add(Type type, object instance);
    public abstract virtual void Add(T instance);
    public abstract virtual IEnumerable`1<T> Find();
    public abstract virtual void SetLogger(IDiagnosticLogger logger);
    public abstract virtual void Merge(IConventionFinder conventionFinder);
}
public interface FluentNHibernate.Conventions.IDynamicComponentConvention {
}
public interface FluentNHibernate.Conventions.IDynamicComponentConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IHasManyConvention {
}
public interface FluentNHibernate.Conventions.IHasManyConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IHasManyToManyConvention {
}
public interface FluentNHibernate.Conventions.IHasManyToManyConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IHasOneConvention {
}
public interface FluentNHibernate.Conventions.IHasOneConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IHibernateMappingConvention {
}
public interface FluentNHibernate.Conventions.IIdConvention {
}
public interface FluentNHibernate.Conventions.IIdConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IIndexConvention {
}
public interface FluentNHibernate.Conventions.IIndexConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IIndexManyToManyConvention {
}
public interface FluentNHibernate.Conventions.IIndexManyToManyConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IJoinConvention {
}
public interface FluentNHibernate.Conventions.IJoinConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IJoinedSubclassConvention {
}
public interface FluentNHibernate.Conventions.IJoinedSubclassConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IKeyManyToOneConvention {
}
public interface FluentNHibernate.Conventions.IKeyManyToOneConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IKeyPropertyConvention {
}
public interface FluentNHibernate.Conventions.IKeyPropertyConventionAcceptance {
}
[ObsoleteAttribute("Use ICollectionConvention with an acceptance criteria")]
public interface FluentNHibernate.Conventions.IListConvention {
}
[ObsoleteAttribute("Use ICollectionConventionAcceptance")]
public interface FluentNHibernate.Conventions.IListConventionAcceptance {
}
[ObsoleteAttribute("Use ICollectionConvention with an acceptance criteria")]
public interface FluentNHibernate.Conventions.IMapConvention {
}
[ObsoleteAttribute("Use ICollectionConventionAcceptance")]
public interface FluentNHibernate.Conventions.IMapConventionAcceptance {
}
public class FluentNHibernate.Conventions.Inspections.AnyInspector : object {
    private InspectorModelMapper`2<IAnyInspector, AnyMapping> propertyMappings;
    private AnyMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Access Access { get; }
    public Cascade Cascade { get; }
    public IEnumerable`1<IColumnInspector> IdentifierColumns { get; }
    public string IdType { get; }
    public bool Insert { get; }
    public TypeReference MetaType { get; }
    public IEnumerable`1<IMetaValueInspector> MetaValues { get; }
    public string Name { get; }
    public IEnumerable`1<IColumnInspector> TypeColumns { get; }
    public bool Update { get; }
    public bool LazyLoad { get; }
    public bool OptimisticLock { get; }
    public AnyInspector(AnyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Access get_Access();
    public sealed virtual Cascade get_Cascade();
    public sealed virtual IEnumerable`1<IColumnInspector> get_IdentifierColumns();
    public sealed virtual string get_IdType();
    public sealed virtual bool get_Insert();
    public sealed virtual TypeReference get_MetaType();
    public sealed virtual IEnumerable`1<IMetaValueInspector> get_MetaValues();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<IColumnInspector> get_TypeColumns();
    public sealed virtual bool get_Update();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual bool get_OptimisticLock();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_IdentifierColumns>b__13_0(ColumnMapping x);
    [CompilerGeneratedAttribute]
private ColumnInspector <get_TypeColumns>b__25_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.CacheInspector : object {
    [CompilerGeneratedAttribute]
private CacheMapping <mapping>P;
    private InspectorModelMapper`2<ICacheInspector, CacheMapping> propertyMappings;
    public string Usage { get; }
    public string Region { get; }
    public Include Include { get; }
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public CacheInspector(CacheMapping mapping);
    public sealed virtual string get_Usage();
    public sealed virtual string get_Region();
    public sealed virtual Include get_Include();
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
}
public class FluentNHibernate.Conventions.Inspections.CamelCasePrefix : Prefix {
    public static CamelCasePrefix None;
    public static CamelCasePrefix Underscore;
    protected CamelCasePrefix(string value);
    private static CamelCasePrefix();
}
public class FluentNHibernate.Conventions.Inspections.Cascade : object {
    public static Cascade Unset;
    public static Cascade All;
    public static Cascade AllDeleteOrphan;
    public static Cascade None;
    public static Cascade SaveUpdate;
    public static Cascade Delete;
    public static Cascade Merge;
    public static Cascade Replicate;
    private string value;
    private Cascade(string value);
    private static Cascade();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Cascade other);
    public virtual int GetHashCode();
    public static bool op_Equality(Cascade x, Cascade y);
    public static bool op_Inequality(Cascade x, Cascade y);
    public virtual string ToString();
    public static Cascade FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.ClassInspector : object {
    private ClassMapping mapping;
    private InspectorModelMapper`2<IClassInspector, ClassMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public bool LazyLoad { get; }
    public bool ReadOnly { get; }
    public string TableName { get; }
    private ICacheInspector FluentNHibernate.Conventions.Inspections.IClassInspector.Cache { get; }
    public ICacheInstance Cache { get; }
    public OptimisticLock OptimisticLock { get; }
    public SchemaAction SchemaAction { get; }
    public string Schema { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public int BatchSize { get; }
    public bool Abstract { get; }
    public IVersionInspector Version { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public string Check { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public IEnumerable`1<IJoinInspector> Joins { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public IEnumerable`1<ISubclassInspectorBase> Subclasses { get; }
    public IDiscriminatorInspector Discriminator { get; }
    public object DiscriminatorValue { get; }
    public string Name { get; }
    public string Persister { get; }
    public Polymorphism Polymorphism { get; }
    public string Proxy { get; }
    public string Where { get; }
    public string Subselect { get; }
    public bool SelectBeforeUpdate { get; }
    public IIdentityInspectorBase Id { get; }
    public ClassInspector(ClassMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual string get_TableName();
    private sealed virtual override ICacheInspector FluentNHibernate.Conventions.Inspections.IClassInspector.get_Cache();
    public sealed virtual ICacheInstance get_Cache();
    public sealed virtual OptimisticLock get_OptimisticLock();
    public sealed virtual SchemaAction get_SchemaAction();
    public sealed virtual string get_Schema();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual int get_BatchSize();
    public sealed virtual bool get_Abstract();
    public sealed virtual IVersionInspector get_Version();
    public sealed virtual IEnumerable`1<IAnyInspector> get_Anys();
    public sealed virtual string get_Check();
    public sealed virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public sealed virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public sealed virtual IEnumerable`1<IJoinInspector> get_Joins();
    public sealed virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
    public sealed virtual IEnumerable`1<ISubclassInspectorBase> get_Subclasses();
    public sealed virtual IDiscriminatorInspector get_Discriminator();
    public sealed virtual object get_DiscriminatorValue();
    public sealed virtual string get_Name();
    public sealed virtual string get_Persister();
    public sealed virtual Polymorphism get_Polymorphism();
    public sealed virtual string get_Proxy();
    public sealed virtual string get_Where();
    public sealed virtual string get_Subselect();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual IIdentityInspectorBase get_Id();
    public sealed virtual bool IsSet(Member property);
}
public class FluentNHibernate.Conventions.Inspections.CollectionInspector : object {
    private InspectorModelMapper`2<ICollectionInspector, CollectionMapping> propertyMappings;
    private CollectionMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    private Collection FluentNHibernate.Conventions.Inspections.ICollectionInspector.Collection { get; }
    public IKeyInspector Key { get; }
    public string TableName { get; }
    public bool IsMethodAccess { get; }
    public MemberInfo Member { get; }
    public IRelationshipInspector Relationship { get; }
    public Cascade Cascade { get; }
    public Fetch Fetch { get; }
    public bool OptimisticLock { get; }
    public bool Generic { get; }
    public bool Inverse { get; }
    public Access Access { get; }
    public int BatchSize { get; }
    public ICacheInspector Cache { get; }
    public string Check { get; }
    public Type ChildType { get; }
    public TypeReference CollectionType { get; }
    public ICompositeElementInspector CompositeElement { get; }
    public IElementInspector Element { get; }
    public Lazy LazyLoad { get; }
    public string Name { get; }
    public TypeReference Persister { get; }
    public string Schema { get; }
    public string Where { get; }
    public string OrderBy { get; }
    public string Sort { get; }
    public IIndexInspectorBase Index { get; }
    public CollectionInspector(CollectionMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    private sealed virtual override Collection FluentNHibernate.Conventions.Inspections.ICollectionInspector.get_Collection();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual IKeyInspector get_Key();
    public sealed virtual string get_TableName();
    public sealed virtual bool get_IsMethodAccess();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual IRelationshipInspector get_Relationship();
    public sealed virtual Cascade get_Cascade();
    public sealed virtual Fetch get_Fetch();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_Generic();
    public sealed virtual bool get_Inverse();
    public sealed virtual Access get_Access();
    public sealed virtual int get_BatchSize();
    public sealed virtual ICacheInspector get_Cache();
    public sealed virtual string get_Check();
    public sealed virtual Type get_ChildType();
    public sealed virtual TypeReference get_CollectionType();
    public sealed virtual ICompositeElementInspector get_CompositeElement();
    public sealed virtual IElementInspector get_Element();
    public sealed virtual Lazy get_LazyLoad();
    public sealed virtual string get_Name();
    public sealed virtual TypeReference get_Persister();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Where();
    public sealed virtual string get_OrderBy();
    public sealed virtual string get_Sort();
    public sealed virtual IIndexInspectorBase get_Index();
    public virtual void ExtraLazyLoad();
}
public abstract class FluentNHibernate.Conventions.Inspections.ColumnBasedInspector : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ColumnMapping> <columns>P;
    public int Length { get; }
    public bool Nullable { get; }
    public string SqlType { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string Index { get; }
    public string Check { get; }
    public string Default { get; }
    public int Precision { get; }
    public int Scale { get; }
    protected ColumnBasedInspector(IEnumerable`1<ColumnMapping> columns);
    private T GetValueFromColumns(Func`2<ColumnMapping, object> property);
    public sealed virtual int get_Length();
    public sealed virtual bool get_Nullable();
    public sealed virtual string get_SqlType();
    public sealed virtual bool get_Unique();
    public sealed virtual string get_UniqueKey();
    public sealed virtual string get_Index();
    public sealed virtual string get_Check();
    public sealed virtual string get_Default();
    public sealed virtual int get_Precision();
    public sealed virtual int get_Scale();
}
public class FluentNHibernate.Conventions.Inspections.ColumnInspector : object {
    [CompilerGeneratedAttribute]
private ColumnMapping <mapping>P;
    private InspectorModelMapper`2<IColumnInspector, ColumnMapping> propertyMappings;
    [CompilerGeneratedAttribute]
private Type <EntityType>k__BackingField;
    public Type EntityType { get; }
    public string Name { get; }
    public string Check { get; }
    public string Index { get; }
    public int Length { get; }
    public bool NotNull { get; }
    public string SqlType { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public int Precision { get; }
    public int Scale { get; }
    public string Default { get; }
    public string StringIdentifierForModel { get; }
    public ColumnInspector(Type containingEntityType, ColumnMapping mapping);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EntityType();
    public sealed virtual string get_Name();
    public sealed virtual string get_Check();
    public sealed virtual string get_Index();
    public sealed virtual int get_Length();
    public sealed virtual bool get_NotNull();
    public sealed virtual string get_SqlType();
    public sealed virtual bool get_Unique();
    public sealed virtual string get_UniqueKey();
    public sealed virtual int get_Precision();
    public sealed virtual int get_Scale();
    public sealed virtual string get_Default();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
}
public abstract class FluentNHibernate.Conventions.Inspections.ComponentBaseInspector : object {
    [CompilerGeneratedAttribute]
private IComponentMapping <mapping>P;
    public Access Access { get; }
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Member Property { get; }
    public IParentInspector Parent { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public string Name { get; }
    public bool OptimisticLock { get; }
    public bool Unique { get; }
    public TypeReference Class { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public Type Type { get; }
    protected ComponentBaseInspector(IComponentMapping mapping);
    public sealed virtual Access get_Access();
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public abstract virtual bool IsSet(Member property);
    public sealed virtual Member get_Property();
    public sealed virtual IParentInspector get_Parent();
    public sealed virtual bool get_Insert();
    public sealed virtual bool get_Update();
    public sealed virtual IEnumerable`1<IAnyInspector> get_Anys();
    public sealed virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public sealed virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public sealed virtual string get_Name();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual bool get_Unique();
    public sealed virtual TypeReference get_Class();
    public sealed virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
    public sealed virtual Type get_Type();
}
public class FluentNHibernate.Conventions.Inspections.ComponentInspector : ComponentBaseInspector {
    private InspectorModelMapper`2<IComponentInspector, ComponentMapping> mappedProperties;
    private IComponentMapping mapping;
    public bool LazyLoad { get; }
    public ComponentInspector(IComponentMapping mapping);
    public virtual bool IsSet(Member property);
    public sealed virtual bool get_LazyLoad();
}
public class FluentNHibernate.Conventions.Inspections.CompositeElementInspector : object {
    [CompilerGeneratedAttribute]
private CompositeElementMapping <mapping>P;
    private InspectorModelMapper`2<ICompositeElementInspector, CompositeElementMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public TypeReference Class { get; }
    public IParentInspector Parent { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public CompositeElementInspector(CompositeElementMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual TypeReference get_Class();
    public sealed virtual IParentInspector get_Parent();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
}
public class FluentNHibernate.Conventions.Inspections.CompositeIdentityInspector : object {
    [CompilerGeneratedAttribute]
private CompositeIdMapping <mapping>P;
    private InspectorModelMapper`2<ICompositeIdentityInspector, CompositeIdMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Access Access { get; }
    public TypeReference Class { get; }
    public IEnumerable`1<IKeyManyToOneInspector> KeyManyToOnes { get; }
    public IEnumerable`1<IKeyPropertyInspector> KeyProperties { get; }
    public bool Mapped { get; }
    public string Name { get; }
    public string UnsavedValue { get; }
    public CompositeIdentityInspector(CompositeIdMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Access get_Access();
    public sealed virtual TypeReference get_Class();
    public sealed virtual IEnumerable`1<IKeyManyToOneInspector> get_KeyManyToOnes();
    public sealed virtual IEnumerable`1<IKeyPropertyInspector> get_KeyProperties();
    public sealed virtual bool get_Mapped();
    public sealed virtual string get_Name();
    public sealed virtual string get_UnsavedValue();
}
public class FluentNHibernate.Conventions.Inspections.DiscriminatorInspector : ColumnBasedInspector {
    private InspectorModelMapper`2<IDiscriminatorInspector, DiscriminatorMapping> propertyMappings;
    private DiscriminatorMapping mapping;
    public bool Insert { get; }
    public bool Force { get; }
    public string Formula { get; }
    public TypeReference Type { get; }
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public DiscriminatorInspector(DiscriminatorMapping mapping);
    public sealed virtual bool get_Insert();
    public sealed virtual bool get_Force();
    public sealed virtual string get_Formula();
    public sealed virtual TypeReference get_Type();
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual bool IsSet(Member property);
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__16_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.DynamicComponentInspector : ComponentBaseInspector {
    private InspectorModelMapper`2<IDynamicComponentInspector, ComponentMapping> mappedProperties;
    private IComponentMapping mapping;
    public DynamicComponentInspector(IComponentMapping mapping);
    public virtual bool IsSet(Member property);
}
public class FluentNHibernate.Conventions.Inspections.ElementInspector : object {
    [CompilerGeneratedAttribute]
private ElementMapping <mapping>P;
    private InspectorModelMapper`2<IElementInspector, ElementMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public TypeReference Type { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public string Formula { get; }
    public int Length { get; }
    public ElementInspector(ElementMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual TypeReference get_Type();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual string get_Formula();
    public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__11_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.Fetch : object {
    public static Fetch Unset;
    public static Fetch Select;
    public static Fetch Join;
    public static Fetch Subselect;
    private string value;
    private Fetch(string value);
    private static Fetch();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Fetch other);
    public virtual int GetHashCode();
    public static bool op_Equality(Fetch x, Fetch y);
    public static bool op_Inequality(Fetch x, Fetch y);
    public virtual string ToString();
    public static Fetch FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.Generated : object {
    public static Generated Unset;
    public static Generated Never;
    public static Generated Insert;
    public static Generated Always;
    private string value;
    private Generated(string value);
    private static Generated();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Generated other);
    public virtual int GetHashCode();
    public static bool op_Equality(Generated x, Generated y);
    public static bool op_Inequality(Generated x, Generated y);
    public virtual string ToString();
    public static Generated FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.GeneratorInspector : object {
    [CompilerGeneratedAttribute]
private GeneratorMapping <mapping>P;
    private InspectorModelMapper`2<IGeneratorInspector, GeneratorMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public string Class { get; }
    public IDictionary`2<string, string> Params { get; }
    public GeneratorInspector(GeneratorMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual string get_Class();
    public sealed virtual IDictionary`2<string, string> get_Params();
}
public class FluentNHibernate.Conventions.Inspections.HibernateMappingInspector : object {
    [CompilerGeneratedAttribute]
private HibernateMapping <mapping>P;
    private InspectorModelMapper`2<IHibernateMappingInspector, HibernateMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public string Catalog { get; }
    public Access DefaultAccess { get; }
    public Cascade DefaultCascade { get; }
    public bool DefaultLazy { get; }
    public bool AutoImport { get; }
    public string Schema { get; }
    public HibernateMappingInspector(HibernateMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual string get_Catalog();
    public sealed virtual Access get_DefaultAccess();
    public sealed virtual Cascade get_DefaultCascade();
    public sealed virtual bool get_DefaultLazy();
    public sealed virtual bool get_AutoImport();
    public sealed virtual string get_Schema();
}
public interface FluentNHibernate.Conventions.Inspections.IAccessInspector {
    public Access Access { get; }
    public abstract virtual Access get_Access();
}
public interface FluentNHibernate.Conventions.Inspections.IAnyInspector {
    public Cascade Cascade { get; }
    public IEnumerable`1<IColumnInspector> IdentifierColumns { get; }
    public string IdType { get; }
    public bool Insert { get; }
    public TypeReference MetaType { get; }
    public IEnumerable`1<IMetaValueInspector> MetaValues { get; }
    public string Name { get; }
    public IEnumerable`1<IColumnInspector> TypeColumns { get; }
    public bool Update { get; }
    public bool LazyLoad { get; }
    public bool OptimisticLock { get; }
    public abstract virtual Cascade get_Cascade();
    public abstract virtual IEnumerable`1<IColumnInspector> get_IdentifierColumns();
    public abstract virtual string get_IdType();
    public abstract virtual bool get_Insert();
    public abstract virtual TypeReference get_MetaType();
    public abstract virtual IEnumerable`1<IMetaValueInspector> get_MetaValues();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<IColumnInspector> get_TypeColumns();
    public abstract virtual bool get_Update();
    public abstract virtual bool get_LazyLoad();
    public abstract virtual bool get_OptimisticLock();
}
public interface FluentNHibernate.Conventions.Inspections.IAnyInstance {
    public IAccessInstance Access { get; }
    public abstract virtual IAccessInstance get_Access();
}
[ObsoleteAttribute("Use ICollectionInspector")]
public interface FluentNHibernate.Conventions.Inspections.IArrayInspector {
}
[ObsoleteAttribute("Use ICollectionInspector")]
public interface FluentNHibernate.Conventions.Inspections.IBagInspector {
}
public interface FluentNHibernate.Conventions.Inspections.ICacheInspector {
    public string Usage { get; }
    public string Region { get; }
    public Include Include { get; }
    public abstract virtual string get_Usage();
    public abstract virtual string get_Region();
    public abstract virtual Include get_Include();
}
public interface FluentNHibernate.Conventions.Inspections.IClassInspector {
    public string TableName { get; }
    public OptimisticLock OptimisticLock { get; }
    public SchemaAction SchemaAction { get; }
    public string Schema { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public int BatchSize { get; }
    public bool Abstract { get; }
    public string Check { get; }
    public object DiscriminatorValue { get; }
    public string Name { get; }
    public string Persister { get; }
    public Polymorphism Polymorphism { get; }
    public string Proxy { get; }
    public string Where { get; }
    public string Subselect { get; }
    public bool SelectBeforeUpdate { get; }
    public IIdentityInspectorBase Id { get; }
    public ICacheInspector Cache { get; }
    public IDiscriminatorInspector Discriminator { get; }
    public IVersionInspector Version { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public IEnumerable`1<IJoinInspector> Joins { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public IEnumerable`1<ISubclassInspectorBase> Subclasses { get; }
    public abstract virtual string get_TableName();
    public abstract virtual OptimisticLock get_OptimisticLock();
    public abstract virtual SchemaAction get_SchemaAction();
    public abstract virtual string get_Schema();
    public abstract virtual bool get_DynamicUpdate();
    public abstract virtual bool get_DynamicInsert();
    public abstract virtual int get_BatchSize();
    public abstract virtual bool get_Abstract();
    public abstract virtual string get_Check();
    public abstract virtual object get_DiscriminatorValue();
    public abstract virtual string get_Name();
    public abstract virtual string get_Persister();
    public abstract virtual Polymorphism get_Polymorphism();
    public abstract virtual string get_Proxy();
    public abstract virtual string get_Where();
    public abstract virtual string get_Subselect();
    public abstract virtual bool get_SelectBeforeUpdate();
    public abstract virtual IIdentityInspectorBase get_Id();
    public abstract virtual ICacheInspector get_Cache();
    public abstract virtual IDiscriminatorInspector get_Discriminator();
    public abstract virtual IVersionInspector get_Version();
    public abstract virtual IEnumerable`1<IAnyInspector> get_Anys();
    public abstract virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public abstract virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public abstract virtual IEnumerable`1<IJoinInspector> get_Joins();
    public abstract virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public abstract virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public abstract virtual IEnumerable`1<IManyToOneInspector> get_References();
    public abstract virtual IEnumerable`1<ISubclassInspectorBase> get_Subclasses();
}
public interface FluentNHibernate.Conventions.Inspections.ICollectionInspector {
    public IKeyInspector Key { get; }
    public IIndexInspectorBase Index { get; }
    public string Sort { get; }
    public string TableName { get; }
    public bool IsMethodAccess { get; }
    public MemberInfo Member { get; }
    public IRelationshipInspector Relationship { get; }
    public Cascade Cascade { get; }
    public Fetch Fetch { get; }
    public bool OptimisticLock { get; }
    public bool Generic { get; }
    public bool Inverse { get; }
    public Access Access { get; }
    public int BatchSize { get; }
    public ICacheInspector Cache { get; }
    public string Check { get; }
    public Type ChildType { get; }
    public TypeReference CollectionType { get; }
    public ICompositeElementInspector CompositeElement { get; }
    public IElementInspector Element { get; }
    public Lazy LazyLoad { get; }
    public string Name { get; }
    public TypeReference Persister { get; }
    public string Schema { get; }
    public string Where { get; }
    public string OrderBy { get; }
    public Collection Collection { get; }
    public abstract virtual IKeyInspector get_Key();
    public abstract virtual IIndexInspectorBase get_Index();
    public abstract virtual string get_Sort();
    public abstract virtual string get_TableName();
    public abstract virtual bool get_IsMethodAccess();
    public abstract virtual MemberInfo get_Member();
    public abstract virtual IRelationshipInspector get_Relationship();
    public abstract virtual Cascade get_Cascade();
    public abstract virtual Fetch get_Fetch();
    public abstract virtual bool get_OptimisticLock();
    public abstract virtual bool get_Generic();
    public abstract virtual bool get_Inverse();
    public abstract virtual Access get_Access();
    public abstract virtual int get_BatchSize();
    public abstract virtual ICacheInspector get_Cache();
    public abstract virtual string get_Check();
    public abstract virtual Type get_ChildType();
    public abstract virtual TypeReference get_CollectionType();
    public abstract virtual ICompositeElementInspector get_CompositeElement();
    public abstract virtual IElementInspector get_Element();
    public abstract virtual Lazy get_LazyLoad();
    public abstract virtual string get_Name();
    public abstract virtual TypeReference get_Persister();
    public abstract virtual string get_Schema();
    public abstract virtual string get_Where();
    public abstract virtual string get_OrderBy();
    public abstract virtual Collection get_Collection();
}
public interface FluentNHibernate.Conventions.Inspections.IColumnInspector {
    public string Name { get; }
    public string Check { get; }
    public string Index { get; }
    public int Length { get; }
    public bool NotNull { get; }
    public string SqlType { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public int Precision { get; }
    public int Scale { get; }
    public string Default { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Check();
    public abstract virtual string get_Index();
    public abstract virtual int get_Length();
    public abstract virtual bool get_NotNull();
    public abstract virtual string get_SqlType();
    public abstract virtual bool get_Unique();
    public abstract virtual string get_UniqueKey();
    public abstract virtual int get_Precision();
    public abstract virtual int get_Scale();
    public abstract virtual string get_Default();
}
public interface FluentNHibernate.Conventions.Inspections.IComponentBaseInspector {
    public IParentInspector Parent { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public string Name { get; }
    public bool OptimisticLock { get; }
    public bool Unique { get; }
    public Type Type { get; }
    public TypeReference Class { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public abstract virtual IParentInspector get_Parent();
    public abstract virtual bool get_Insert();
    public abstract virtual bool get_Update();
    public abstract virtual IEnumerable`1<IAnyInspector> get_Anys();
    public abstract virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public abstract virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public abstract virtual string get_Name();
    public abstract virtual bool get_OptimisticLock();
    public abstract virtual bool get_Unique();
    public abstract virtual Type get_Type();
    public abstract virtual TypeReference get_Class();
    public abstract virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public abstract virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public abstract virtual IEnumerable`1<IManyToOneInspector> get_References();
}
public interface FluentNHibernate.Conventions.Inspections.IComponentInspector {
    public bool LazyLoad { get; }
    public abstract virtual bool get_LazyLoad();
}
public interface FluentNHibernate.Conventions.Inspections.ICompositeElementInspector {
    public TypeReference Class { get; }
    public IParentInspector Parent { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public abstract virtual TypeReference get_Class();
    public abstract virtual IParentInspector get_Parent();
    public abstract virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public abstract virtual IEnumerable`1<IManyToOneInspector> get_References();
}
public interface FluentNHibernate.Conventions.Inspections.ICompositeIdentityInspector {
    public TypeReference Class { get; }
    public IEnumerable`1<IKeyManyToOneInspector> KeyManyToOnes { get; }
    public IEnumerable`1<IKeyPropertyInspector> KeyProperties { get; }
    public bool Mapped { get; }
    public abstract virtual TypeReference get_Class();
    public abstract virtual IEnumerable`1<IKeyManyToOneInspector> get_KeyManyToOnes();
    public abstract virtual IEnumerable`1<IKeyPropertyInspector> get_KeyProperties();
    public abstract virtual bool get_Mapped();
}
public class FluentNHibernate.Conventions.Inspections.IdentityInspector : ColumnBasedInspector {
    private InspectorModelMapper`2<IIdentityInspector, IdMapping> propertyMappings;
    private IdMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Member Property { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public IGeneratorInspector Generator { get; }
    public string UnsavedValue { get; }
    public string Name { get; }
    public Access Access { get; }
    public TypeReference Type { get; }
    public IdentityInspector(IdMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Member get_Property();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual IGeneratorInspector get_Generator();
    public sealed virtual string get_UnsavedValue();
    public sealed virtual string get_Name();
    public sealed virtual Access get_Access();
    public sealed virtual TypeReference get_Type();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__11_0(ColumnMapping x);
}
public interface FluentNHibernate.Conventions.Inspections.IDiscriminatorInspector {
    public bool Insert { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public bool Force { get; }
    public string Formula { get; }
    public TypeReference Type { get; }
    public int Length { get; }
    public int Precision { get; }
    public int Scale { get; }
    public bool Nullable { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string SqlType { get; }
    public string Index { get; }
    public string Check { get; }
    public string Default { get; }
    public abstract virtual bool get_Insert();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual bool get_Force();
    public abstract virtual string get_Formula();
    public abstract virtual TypeReference get_Type();
    public abstract virtual int get_Length();
    public abstract virtual int get_Precision();
    public abstract virtual int get_Scale();
    public abstract virtual bool get_Nullable();
    public abstract virtual bool get_Unique();
    public abstract virtual string get_UniqueKey();
    public abstract virtual string get_SqlType();
    public abstract virtual string get_Index();
    public abstract virtual string get_Check();
    public abstract virtual string get_Default();
}
public interface FluentNHibernate.Conventions.Inspections.IDynamicComponentInspector {
}
public interface FluentNHibernate.Conventions.Inspections.IElementInspector {
    public TypeReference Type { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public string Formula { get; }
    public int Length { get; }
    public abstract virtual TypeReference get_Type();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual string get_Formula();
    public abstract virtual int get_Length();
}
public interface FluentNHibernate.Conventions.Inspections.IExposedThroughPropertyInspector {
    public Member Property { get; }
    public abstract virtual Member get_Property();
}
public interface FluentNHibernate.Conventions.Inspections.IGeneratorInspector {
    public string Class { get; }
    public IDictionary`2<string, string> Params { get; }
    public abstract virtual string get_Class();
    public abstract virtual IDictionary`2<string, string> get_Params();
}
public interface FluentNHibernate.Conventions.Inspections.IHibernateMappingInspector {
    public string Catalog { get; }
    public Access DefaultAccess { get; }
    public Cascade DefaultCascade { get; }
    public bool DefaultLazy { get; }
    public bool AutoImport { get; }
    public string Schema { get; }
    public abstract virtual string get_Catalog();
    public abstract virtual Access get_DefaultAccess();
    public abstract virtual Cascade get_DefaultCascade();
    public abstract virtual bool get_DefaultLazy();
    public abstract virtual bool get_AutoImport();
    public abstract virtual string get_Schema();
}
public interface FluentNHibernate.Conventions.Inspections.IIdentityInspector {
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public IGeneratorInspector Generator { get; }
    public TypeReference Type { get; }
    public int Length { get; }
    public int Precision { get; }
    public int Scale { get; }
    public bool Nullable { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string SqlType { get; }
    public string Index { get; }
    public string Check { get; }
    public string Default { get; }
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual IGeneratorInspector get_Generator();
    public abstract virtual TypeReference get_Type();
    public abstract virtual int get_Length();
    public abstract virtual int get_Precision();
    public abstract virtual int get_Scale();
    public abstract virtual bool get_Nullable();
    public abstract virtual bool get_Unique();
    public abstract virtual string get_UniqueKey();
    public abstract virtual string get_SqlType();
    public abstract virtual string get_Index();
    public abstract virtual string get_Check();
    public abstract virtual string get_Default();
}
public interface FluentNHibernate.Conventions.Inspections.IIdentityInspectorBase {
    public Access Access { get; }
    public string UnsavedValue { get; }
    public string Name { get; }
    public abstract virtual Access get_Access();
    public abstract virtual string get_UnsavedValue();
    public abstract virtual string get_Name();
}
public interface FluentNHibernate.Conventions.Inspections.IIndexInspector {
    public TypeReference Type { get; }
    public abstract virtual TypeReference get_Type();
}
public interface FluentNHibernate.Conventions.Inspections.IIndexInspectorBase {
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
}
public interface FluentNHibernate.Conventions.Inspections.IIndexManyToManyInspector {
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public abstract virtual TypeReference get_Class();
    public abstract virtual string get_ForeignKey();
}
public interface FluentNHibernate.Conventions.Inspections.IInspector {
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public abstract virtual Type get_EntityType();
    public abstract virtual string get_StringIdentifierForModel();
    public abstract virtual bool IsSet(Member property);
}
public interface FluentNHibernate.Conventions.Inspections.IJoinedSubclassInspector {
    public IKeyInspector Key { get; }
    public string Check { get; }
    public string Schema { get; }
    public string TableName { get; }
    public IEnumerable`1<IJoinedSubclassInspector> Subclasses { get; }
    public abstract virtual IKeyInspector get_Key();
    public abstract virtual string get_Check();
    public abstract virtual string get_Schema();
    public abstract virtual string get_TableName();
    public abstract virtual IEnumerable`1<IJoinedSubclassInspector> get_Subclasses();
}
public interface FluentNHibernate.Conventions.Inspections.IJoinInspector {
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public Fetch Fetch { get; }
    public bool Inverse { get; }
    public IKeyInspector Key { get; }
    public bool Optional { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public string Schema { get; }
    public string TableName { get; }
    public string Catalog { get; }
    public string Subselect { get; }
    public abstract virtual IEnumerable`1<IAnyInspector> get_Anys();
    public abstract virtual Fetch get_Fetch();
    public abstract virtual bool get_Inverse();
    public abstract virtual IKeyInspector get_Key();
    public abstract virtual bool get_Optional();
    public abstract virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public abstract virtual IEnumerable`1<IManyToOneInspector> get_References();
    public abstract virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public abstract virtual string get_Schema();
    public abstract virtual string get_TableName();
    public abstract virtual string get_Catalog();
    public abstract virtual string get_Subselect();
}
public interface FluentNHibernate.Conventions.Inspections.IKeyInspector {
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public string ForeignKey { get; }
    public OnDelete OnDelete { get; }
    public string PropertyRef { get; }
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual string get_ForeignKey();
    public abstract virtual OnDelete get_OnDelete();
    public abstract virtual string get_PropertyRef();
}
public interface FluentNHibernate.Conventions.Inspections.IKeyManyToOneInspector {
    public Access Access { get; }
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public bool LazyLoad { get; }
    public string Name { get; }
    public NotFound NotFound { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public abstract virtual Access get_Access();
    public abstract virtual TypeReference get_Class();
    public abstract virtual string get_ForeignKey();
    public abstract virtual bool get_LazyLoad();
    public abstract virtual string get_Name();
    public abstract virtual NotFound get_NotFound();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
}
public interface FluentNHibernate.Conventions.Inspections.IKeyPropertyInspector {
    public Access Access { get; }
    public string Name { get; }
    public TypeReference Type { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public int Length { get; }
    public abstract virtual Access get_Access();
    public abstract virtual string get_Name();
    public abstract virtual TypeReference get_Type();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual int get_Length();
}
public interface FluentNHibernate.Conventions.Inspections.ILazyLoadInspector {
    public bool LazyLoad { get; }
    public abstract virtual bool get_LazyLoad();
}
[ObsoleteAttribute("Use ICollectionInspector")]
public interface FluentNHibernate.Conventions.Inspections.IListInspector {
}
public interface FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector {
    public IManyToManyInspector Relationship { get; }
    public IManyToManyCollectionInspector OtherSide { get; }
    public abstract virtual IManyToManyInspector get_Relationship();
    public abstract virtual IManyToManyCollectionInspector get_OtherSide();
}
public interface FluentNHibernate.Conventions.Inspections.IManyToManyInspector {
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Type ChildType { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public bool LazyLoad { get; }
    public NotFound NotFound { get; }
    public Type ParentType { get; }
    public string Where { get; }
    public string OrderBy { get; }
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual Type get_ChildType();
    public abstract virtual Fetch get_Fetch();
    public abstract virtual string get_ForeignKey();
    public abstract virtual bool get_LazyLoad();
    public abstract virtual NotFound get_NotFound();
    public abstract virtual Type get_ParentType();
    public abstract virtual string get_Where();
    public abstract virtual string get_OrderBy();
}
public interface FluentNHibernate.Conventions.Inspections.IManyToOneInspector {
    public string Name { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Cascade Cascade { get; }
    public TypeReference Class { get; }
    public string Formula { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public bool Insert { get; }
    public Laziness LazyLoad { get; }
    public NotFound NotFound { get; }
    public string PropertyRef { get; }
    public bool Update { get; }
    public bool Nullable { get; }
    public bool OptimisticLock { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual Cascade get_Cascade();
    public abstract virtual TypeReference get_Class();
    public abstract virtual string get_Formula();
    public abstract virtual Fetch get_Fetch();
    public abstract virtual string get_ForeignKey();
    public abstract virtual bool get_Insert();
    public abstract virtual Laziness get_LazyLoad();
    public abstract virtual NotFound get_NotFound();
    public abstract virtual string get_PropertyRef();
    public abstract virtual bool get_Update();
    public abstract virtual bool get_Nullable();
    public abstract virtual bool get_OptimisticLock();
}
[ObsoleteAttribute("Use ICollectionInspector")]
public interface FluentNHibernate.Conventions.Inspections.IMapInspector {
}
public interface FluentNHibernate.Conventions.Inspections.IMetaValueInspector {
    public TypeReference Class { get; }
    public string Value { get; }
    public abstract virtual TypeReference get_Class();
    public abstract virtual string get_Value();
}
public class FluentNHibernate.Conventions.Inspections.Include : object {
    public static Include Unset;
    public static Include All;
    public static Include NonLazy;
    private string value;
    private Include(string value);
    private static Include();
    public static Include Custom(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Include other);
    public virtual int GetHashCode();
    public static bool op_Equality(Include x, Include y);
    public static bool op_Inequality(Include x, Include y);
    public virtual string ToString();
    public static Include FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.IndexInspector : object {
    [CompilerGeneratedAttribute]
private IndexMapping <mapping>P;
    private InspectorModelMapper`2<IIndexInspector, IndexMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public TypeReference Type { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public IndexInspector(IndexMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual TypeReference get_Type();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__11_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.IndexManyToManyInspector : object {
    [CompilerGeneratedAttribute]
private IndexManyToManyMapping <mapping>P;
    private InspectorModelMapper`2<IIndexManyToManyInspector, IndexManyToManyMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public IndexManyToManyInspector(IndexManyToManyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual TypeReference get_Class();
    public sealed virtual string get_ForeignKey();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__13_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.InspectorModelMapper`2 : object {
    private Dictionary`2<string, string> mappings;
    public void Map(Expression`1<Func`2<TInspector, object>> inspectorProperty, Expression`1<Func`2<TMapping, object>> mappingProperty);
    public void Map(Expression`1<Func`2<TInspector, object>> inspectorProperty, string mappingProperty);
    private void Map(Member inspectorProperty, Expression`1<Func`2<TMapping, object>> mappingProperty);
    public string Get(Member property);
}
public interface FluentNHibernate.Conventions.Inspections.IOneToManyCollectionInspector {
    public IOneToManyInspector Relationship { get; }
    public IManyToOneInspector OtherSide { get; }
    public abstract virtual IOneToManyInspector get_Relationship();
    public abstract virtual IManyToOneInspector get_OtherSide();
}
public interface FluentNHibernate.Conventions.Inspections.IOneToManyInspector {
    public Type ChildType { get; }
    public NotFound NotFound { get; }
    public abstract virtual Type get_ChildType();
    public abstract virtual NotFound get_NotFound();
}
public interface FluentNHibernate.Conventions.Inspections.IOneToOneInspector {
    public Access Access { get; }
    public Cascade Cascade { get; }
    public TypeReference Class { get; }
    public bool Constrained { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public Laziness LazyLoad { get; }
    public string Name { get; }
    public string PropertyRef { get; }
    public abstract virtual Access get_Access();
    public abstract virtual Cascade get_Cascade();
    public abstract virtual TypeReference get_Class();
    public abstract virtual bool get_Constrained();
    public abstract virtual Fetch get_Fetch();
    public abstract virtual string get_ForeignKey();
    public abstract virtual Laziness get_LazyLoad();
    public abstract virtual string get_Name();
    public abstract virtual string get_PropertyRef();
}
public interface FluentNHibernate.Conventions.Inspections.IParentInspector {
    public string Name { get; }
    public Access Access { get; }
    public abstract virtual string get_Name();
    public abstract virtual Access get_Access();
}
public interface FluentNHibernate.Conventions.Inspections.IPropertyInspector {
    public bool Insert { get; }
    public bool Update { get; }
    public int Length { get; }
    public bool Nullable { get; }
    public string Formula { get; }
    public TypeReference Type { get; }
    public string SqlType { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string Name { get; }
    public bool OptimisticLock { get; }
    public Generated Generated { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public string Index { get; }
    public bool LazyLoad { get; }
    public string Check { get; }
    public string Default { get; }
    public int Precision { get; }
    public int Scale { get; }
    public abstract virtual bool get_Insert();
    public abstract virtual bool get_Update();
    public abstract virtual int get_Length();
    public abstract virtual bool get_Nullable();
    public abstract virtual string get_Formula();
    public abstract virtual TypeReference get_Type();
    public abstract virtual string get_SqlType();
    public abstract virtual bool get_Unique();
    public abstract virtual string get_UniqueKey();
    public abstract virtual string get_Name();
    public abstract virtual bool get_OptimisticLock();
    public abstract virtual Generated get_Generated();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual string get_Index();
    public abstract virtual bool get_LazyLoad();
    public abstract virtual string get_Check();
    public abstract virtual string get_Default();
    public abstract virtual int get_Precision();
    public abstract virtual int get_Scale();
}
public interface FluentNHibernate.Conventions.Inspections.IReadOnlyInspector {
    public bool ReadOnly { get; }
    public abstract virtual bool get_ReadOnly();
}
public interface FluentNHibernate.Conventions.Inspections.IRelationshipInspector {
    public TypeReference Class { get; }
    public abstract virtual TypeReference get_Class();
}
[ObsoleteAttribute("Use ICollectionInspector")]
public interface FluentNHibernate.Conventions.Inspections.ISetInspector {
}
public interface FluentNHibernate.Conventions.Inspections.ISubclassInspector {
    public object DiscriminatorValue { get; }
    public IEnumerable`1<ISubclassInspector> Subclasses { get; }
    public abstract virtual object get_DiscriminatorValue();
    public abstract virtual IEnumerable`1<ISubclassInspector> get_Subclasses();
}
public interface FluentNHibernate.Conventions.Inspections.ISubclassInspectorBase {
    public bool Abstract { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public IEnumerable`1<IJoinInspector> Joins { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public IEnumerable`1<ISubclassInspectorBase> Subclasses { get; }
    public bool DynamicInsert { get; }
    public bool DynamicUpdate { get; }
    public Type Extends { get; }
    public bool LazyLoad { get; }
    public string Name { get; }
    public string Proxy { get; }
    public bool SelectBeforeUpdate { get; }
    public Type Type { get; }
    public abstract virtual bool get_Abstract();
    public abstract virtual IEnumerable`1<IAnyInspector> get_Anys();
    public abstract virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public abstract virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public abstract virtual IEnumerable`1<IJoinInspector> get_Joins();
    public abstract virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public abstract virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public abstract virtual IEnumerable`1<IManyToOneInspector> get_References();
    public abstract virtual IEnumerable`1<ISubclassInspectorBase> get_Subclasses();
    public abstract virtual bool get_DynamicInsert();
    public abstract virtual bool get_DynamicUpdate();
    public abstract virtual Type get_Extends();
    public abstract virtual bool get_LazyLoad();
    public abstract virtual string get_Name();
    public abstract virtual string get_Proxy();
    public abstract virtual bool get_SelectBeforeUpdate();
    public abstract virtual Type get_Type();
}
public interface FluentNHibernate.Conventions.Inspections.IVersionInspector {
    public string Name { get; }
    public Access Access { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Generated Generated { get; }
    public string UnsavedValue { get; }
    public TypeReference Type { get; }
    public int Length { get; }
    public int Precision { get; }
    public int Scale { get; }
    public bool Nullable { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string SqlType { get; }
    public string Index { get; }
    public string Check { get; }
    public string Default { get; }
    public abstract virtual string get_Name();
    public abstract virtual Access get_Access();
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual Generated get_Generated();
    public abstract virtual string get_UnsavedValue();
    public abstract virtual TypeReference get_Type();
    public abstract virtual int get_Length();
    public abstract virtual int get_Precision();
    public abstract virtual int get_Scale();
    public abstract virtual bool get_Nullable();
    public abstract virtual bool get_Unique();
    public abstract virtual string get_UniqueKey();
    public abstract virtual string get_SqlType();
    public abstract virtual string get_Index();
    public abstract virtual string get_Check();
    public abstract virtual string get_Default();
}
public class FluentNHibernate.Conventions.Inspections.JoinedSubclassInspector : object {
    private InspectorModelMapper`2<IJoinedSubclassInspector, SubclassMapping> mappedProperties;
    private SubclassMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public bool Abstract { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IKeyInspector Key { get; }
    public string Check { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public bool DynamicInsert { get; }
    public bool DynamicUpdate { get; }
    public Type Extends { get; }
    public IEnumerable`1<IJoinInspector> Joins { get; }
    public bool LazyLoad { get; }
    public string Schema { get; }
    public string Name { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public string Proxy { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public bool SelectBeforeUpdate { get; }
    public IEnumerable`1<IJoinedSubclassInspector> Subclasses { get; }
    private IEnumerable`1<ISubclassInspectorBase> FluentNHibernate.Conventions.Inspections.ISubclassInspectorBase.Subclasses { get; }
    public string TableName { get; }
    public Type Type { get; }
    public JoinedSubclassInspector(SubclassMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual bool get_Abstract();
    public sealed virtual IEnumerable`1<IAnyInspector> get_Anys();
    public sealed virtual IKeyInspector get_Key();
    public sealed virtual string get_Check();
    public sealed virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public sealed virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual Type get_Extends();
    public sealed virtual IEnumerable`1<IJoinInspector> get_Joins();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual string get_Schema();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual string get_Proxy();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual IEnumerable`1<IJoinedSubclassInspector> get_Subclasses();
    private sealed virtual override IEnumerable`1<ISubclassInspectorBase> FluentNHibernate.Conventions.Inspections.ISubclassInspectorBase.get_Subclasses();
    public sealed virtual string get_TableName();
    public sealed virtual Type get_Type();
}
public class FluentNHibernate.Conventions.Inspections.JoinInspector : object {
    [CompilerGeneratedAttribute]
private JoinMapping <mapping>P;
    private InspectorModelMapper`2<IJoinInspector, JoinMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public Fetch Fetch { get; }
    public bool Inverse { get; }
    public IKeyInspector Key { get; }
    public bool Optional { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public string Schema { get; }
    public string TableName { get; }
    public string Catalog { get; }
    public string Subselect { get; }
    public JoinInspector(JoinMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual IEnumerable`1<IAnyInspector> get_Anys();
    public sealed virtual Fetch get_Fetch();
    public sealed virtual bool get_Inverse();
    public sealed virtual IKeyInspector get_Key();
    public sealed virtual bool get_Optional();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
    public sealed virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public sealed virtual string get_Schema();
    public sealed virtual string get_TableName();
    public sealed virtual string get_Catalog();
    public sealed virtual string get_Subselect();
}
public class FluentNHibernate.Conventions.Inspections.JoinInstance : JoinInspector {
    private JoinMapping mapping;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public IJoinInstance Not { get; }
    public IFetchInstance Fetch { get; }
    public IKeyInstance Key { get; }
    public JoinInstance(JoinMapping mapping);
    public sealed virtual IJoinInstance get_Not();
    public sealed virtual IFetchInstance get_Fetch();
    public sealed virtual void Inverse();
    public sealed virtual IKeyInstance get_Key();
    public sealed virtual void Optional();
    public sealed virtual void Schema(string schema);
    public sealed virtual void Table(string table);
    public sealed virtual void Catalog(string catalog);
    public sealed virtual void Subselect(string subselect);
    [CompilerGeneratedAttribute]
private void <get_Fetch>b__6_0(string value);
}
public class FluentNHibernate.Conventions.Inspections.KeyInspector : object {
    [CompilerGeneratedAttribute]
private KeyMapping <mapping>P;
    private InspectorModelMapper`2<IKeyInspector, KeyMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public string ForeignKey { get; }
    public OnDelete OnDelete { get; }
    public string PropertyRef { get; }
    public KeyInspector(KeyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual string get_ForeignKey();
    public sealed virtual OnDelete get_OnDelete();
    public sealed virtual string get_PropertyRef();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__9_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.KeyManyToOneInspector : object {
    private InspectorModelMapper`2<IKeyManyToOneInspector, KeyManyToOneMapping> mappedProperties;
    private KeyManyToOneMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Access Access { get; }
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public bool LazyLoad { get; }
    public string Name { get; }
    public NotFound NotFound { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public KeyManyToOneInspector(KeyManyToOneMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Access get_Access();
    public sealed virtual TypeReference get_Class();
    public sealed virtual string get_ForeignKey();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual string get_Name();
    public sealed virtual NotFound get_NotFound();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__21_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.KeyPropertyInspector : object {
    [CompilerGeneratedAttribute]
private KeyPropertyMapping <mapping>P;
    private InspectorModelMapper`2<IKeyPropertyInspector, KeyPropertyMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Access Access { get; }
    public string Name { get; }
    public TypeReference Type { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public int Length { get; }
    public KeyPropertyInspector(KeyPropertyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Access get_Access();
    public sealed virtual string get_Name();
    public sealed virtual TypeReference get_Type();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__15_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.LowerCasePrefix : Prefix {
    public static LowerCasePrefix None;
    public static LowerCasePrefix Underscore;
    protected LowerCasePrefix(string value);
    private static LowerCasePrefix();
}
public class FluentNHibernate.Conventions.Inspections.ManyToManyInspector : object {
    private InspectorModelMapper`2<IManyToManyInspector, ManyToManyMapping> mappedProperties;
    private ManyToManyMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Type ChildType { get; }
    public TypeReference Class { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public bool LazyLoad { get; }
    public NotFound NotFound { get; }
    public Type ParentType { get; }
    public string Where { get; }
    public string OrderBy { get; }
    public ManyToManyInspector(ManyToManyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual Type get_ChildType();
    public sealed virtual TypeReference get_Class();
    public sealed virtual Fetch get_Fetch();
    public sealed virtual string get_ForeignKey();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual NotFound get_NotFound();
    public sealed virtual Type get_ParentType();
    public sealed virtual string get_Where();
    public sealed virtual string get_OrderBy();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__9_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.ManyToOneInspector : object {
    private InspectorModelMapper`2<IManyToOneInspector, ManyToOneMapping> propertyMappings;
    private ManyToOneMapping mapping;
    public Access Access { get; }
    public NotFound NotFound { get; }
    public string PropertyRef { get; }
    public bool Update { get; }
    public bool Nullable { get; }
    public bool OptimisticLock { get; }
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Member Property { get; }
    public string Name { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Cascade Cascade { get; }
    public string Formula { get; }
    public TypeReference Class { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public bool Insert { get; }
    public Laziness LazyLoad { get; }
    public ManyToOneInspector(ManyToOneMapping mapping);
    public sealed virtual Access get_Access();
    public sealed virtual NotFound get_NotFound();
    public sealed virtual string get_PropertyRef();
    public sealed virtual bool get_Update();
    public sealed virtual bool get_Nullable();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Member get_Property();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual Cascade get_Cascade();
    public sealed virtual string get_Formula();
    public sealed virtual TypeReference get_Class();
    public sealed virtual Fetch get_Fetch();
    public sealed virtual string get_ForeignKey();
    public sealed virtual bool get_Insert();
    public sealed virtual Laziness get_LazyLoad();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__25_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.MetaValueInspector : object {
    [CompilerGeneratedAttribute]
private MetaValueMapping <mapping>P;
    private InspectorModelMapper`2<IMetaValueInspector, MetaValueMapping> propertyMappings;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public TypeReference Class { get; }
    public string Value { get; }
    public MetaValueInspector(MetaValueMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual TypeReference get_Class();
    public sealed virtual string get_Value();
}
public class FluentNHibernate.Conventions.Inspections.NotFound : object {
    public static NotFound Unset;
    public static NotFound Ignore;
    public static NotFound Exception;
    private string value;
    private NotFound(string value);
    private static NotFound();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NotFound other);
    public virtual int GetHashCode();
    public static bool op_Equality(NotFound x, NotFound y);
    public static bool op_Inequality(NotFound x, NotFound y);
    public virtual string ToString();
    public static NotFound FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.OnDelete : object {
    public static OnDelete Unset;
    public static OnDelete Cascade;
    public static OnDelete NoAction;
    private string value;
    private OnDelete(string value);
    private static OnDelete();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OnDelete other);
    public virtual int GetHashCode();
    public static bool op_Equality(OnDelete x, OnDelete y);
    public static bool op_Inequality(OnDelete x, OnDelete y);
    public virtual string ToString();
    public static OnDelete FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.OneToManyInspector : object {
    [CompilerGeneratedAttribute]
private OneToManyMapping <mapping>P;
    private InspectorModelMapper`2<IOneToManyInspector, OneToManyMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Type ChildType { get; }
    public TypeReference Class { get; }
    public NotFound NotFound { get; }
    public OneToManyInspector(OneToManyMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Type get_ChildType();
    public sealed virtual TypeReference get_Class();
    public sealed virtual NotFound get_NotFound();
}
public class FluentNHibernate.Conventions.Inspections.OneToOneInspector : object {
    private InspectorModelMapper`2<IOneToOneInspector, OneToOneMapping> propertyMappings;
    private OneToOneMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public Access Access { get; }
    public Cascade Cascade { get; }
    public TypeReference Class { get; }
    public bool Constrained { get; }
    public Fetch Fetch { get; }
    public string ForeignKey { get; }
    public Laziness LazyLoad { get; }
    public string Name { get; }
    public string PropertyRef { get; }
    public OneToOneInspector(OneToOneMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual Access get_Access();
    public sealed virtual Cascade get_Cascade();
    public sealed virtual TypeReference get_Class();
    public sealed virtual bool get_Constrained();
    public sealed virtual Fetch get_Fetch();
    public sealed virtual string get_ForeignKey();
    public sealed virtual Laziness get_LazyLoad();
    public sealed virtual string get_Name();
    public sealed virtual string get_PropertyRef();
}
public class FluentNHibernate.Conventions.Inspections.OptimisticLock : object {
    public static OptimisticLock Unset;
    public static OptimisticLock None;
    public static OptimisticLock Version;
    public static OptimisticLock Dirty;
    public static OptimisticLock All;
    private string value;
    private OptimisticLock(string value);
    private static OptimisticLock();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptimisticLock other);
    public virtual int GetHashCode();
    public static bool op_Equality(OptimisticLock x, OptimisticLock y);
    public static bool op_Inequality(OptimisticLock x, OptimisticLock y);
    public virtual string ToString();
    public static OptimisticLock FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.ParentInspector : object {
    [CompilerGeneratedAttribute]
private ParentMapping <mapping>P;
    private InspectorModelMapper`2<IPropertyInspector, ParentMapping> mappedProperties;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public string Name { get; }
    public Access Access { get; }
    public ParentInspector(ParentMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual string get_Name();
    public sealed virtual Access get_Access();
}
public class FluentNHibernate.Conventions.Inspections.PascalCasePrefix : Prefix {
    public static PascalCasePrefix M;
    public static PascalCasePrefix Underscore;
    public static PascalCasePrefix MUnderscore;
    protected PascalCasePrefix(string value);
    private static PascalCasePrefix();
}
public class FluentNHibernate.Conventions.Inspections.Polymorphism : object {
    public static Polymorphism Unset;
    public static Polymorphism Implicit;
    public static Polymorphism Explicit;
    private string value;
    private Polymorphism(string value);
    private static Polymorphism();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Polymorphism other);
    public virtual int GetHashCode();
    public static bool op_Equality(Polymorphism x, Polymorphism y);
    public static bool op_Inequality(Polymorphism x, Polymorphism y);
    public virtual string ToString();
    public static Polymorphism FromString(string value);
}
public class FluentNHibernate.Conventions.Inspections.Prefix : object {
    private string value;
    protected Prefix(string value);
    public virtual string ToString();
}
public class FluentNHibernate.Conventions.Inspections.PropertyInspector : ColumnBasedInspector {
    private InspectorModelMapper`2<IPropertyInspector, PropertyMapping> propertyMappings;
    private PropertyMapping mapping;
    public bool Insert { get; }
    public bool Update { get; }
    public string Formula { get; }
    public TypeReference Type { get; }
    public string Name { get; }
    public bool OptimisticLock { get; }
    public Generated Generated { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public bool LazyLoad { get; }
    public Access Access { get; }
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public bool ReadOnly { get; }
    public Member Property { get; }
    public PropertyInspector(PropertyMapping mapping);
    public sealed virtual bool get_Insert();
    public sealed virtual bool get_Update();
    public sealed virtual string get_Formula();
    public sealed virtual TypeReference get_Type();
    public sealed virtual string get_Name();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual Generated get_Generated();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual Access get_Access();
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool get_ReadOnly();
    public sealed virtual Member get_Property();
    public sealed virtual bool IsSet(Member property);
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__18_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Inspections.SchemaAction : object {
    public static SchemaAction Unset;
    public static SchemaAction Drop;
    public static SchemaAction Export;
    public static SchemaAction None;
    public static SchemaAction Update;
    public static SchemaAction Validate;
    public static SchemaAction All;
    private string value;
    private SchemaAction(string value);
    private static SchemaAction();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SchemaAction other);
    public virtual int GetHashCode();
    public static bool op_Equality(SchemaAction x, SchemaAction y);
    public static bool op_Inequality(SchemaAction x, SchemaAction y);
    public virtual string ToString();
    public static SchemaAction FromString(string value);
    public static SchemaAction Custom(string customValue);
}
public class FluentNHibernate.Conventions.Inspections.SubclassInspector : object {
    private InspectorModelMapper`2<ISubclassInspector, SubclassMapping> mappedProperties;
    private SubclassMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public bool Abstract { get; }
    public IEnumerable`1<IAnyInspector> Anys { get; }
    public IEnumerable`1<ICollectionInspector> Collections { get; }
    public IEnumerable`1<IComponentBaseInspector> Components { get; }
    public object DiscriminatorValue { get; }
    public bool DynamicInsert { get; }
    public bool DynamicUpdate { get; }
    public Type Extends { get; }
    public IEnumerable`1<IJoinInspector> Joins { get; }
    public bool LazyLoad { get; }
    public string Name { get; }
    public IEnumerable`1<IOneToOneInspector> OneToOnes { get; }
    public IEnumerable`1<IPropertyInspector> Properties { get; }
    public string Proxy { get; }
    public IEnumerable`1<IManyToOneInspector> References { get; }
    public bool SelectBeforeUpdate { get; }
    public IEnumerable`1<ISubclassInspector> Subclasses { get; }
    private IEnumerable`1<ISubclassInspectorBase> FluentNHibernate.Conventions.Inspections.ISubclassInspectorBase.Subclasses { get; }
    public Type Type { get; }
    public SubclassInspector(SubclassMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual bool get_Abstract();
    public sealed virtual IEnumerable`1<IAnyInspector> get_Anys();
    public sealed virtual IEnumerable`1<ICollectionInspector> get_Collections();
    public sealed virtual IEnumerable`1<IComponentBaseInspector> get_Components();
    public sealed virtual object get_DiscriminatorValue();
    public sealed virtual bool get_DynamicInsert();
    public sealed virtual bool get_DynamicUpdate();
    public sealed virtual Type get_Extends();
    public sealed virtual IEnumerable`1<IJoinInspector> get_Joins();
    public sealed virtual bool get_LazyLoad();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<IOneToOneInspector> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInspector> get_Properties();
    public sealed virtual string get_Proxy();
    public sealed virtual IEnumerable`1<IManyToOneInspector> get_References();
    public sealed virtual bool get_SelectBeforeUpdate();
    public sealed virtual IEnumerable`1<ISubclassInspector> get_Subclasses();
    private sealed virtual override IEnumerable`1<ISubclassInspectorBase> FluentNHibernate.Conventions.Inspections.ISubclassInspectorBase.get_Subclasses();
    public sealed virtual Type get_Type();
}
public class FluentNHibernate.Conventions.Inspections.UnmappedPropertyException : Exception {
    public UnmappedPropertyException(Type type, string name);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected UnmappedPropertyException(SerializationInfo info, StreamingContext context);
}
public class FluentNHibernate.Conventions.Inspections.VersionInspector : ColumnBasedInspector {
    private InspectorModelMapper`2<IVersionInspector, VersionMapping> propertyMappings;
    private VersionMapping mapping;
    public Type EntityType { get; }
    public string StringIdentifierForModel { get; }
    public string Name { get; }
    public Access Access { get; }
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public Generated Generated { get; }
    public string UnsavedValue { get; }
    public TypeReference Type { get; }
    public VersionInspector(VersionMapping mapping);
    public sealed virtual Type get_EntityType();
    public sealed virtual string get_StringIdentifierForModel();
    public sealed virtual bool IsSet(Member property);
    public sealed virtual string get_Name();
    public sealed virtual Access get_Access();
    public sealed virtual IEnumerable`1<IColumnInspector> get_Columns();
    public sealed virtual Generated get_Generated();
    public sealed virtual string get_UnsavedValue();
    public sealed virtual TypeReference get_Type();
    [CompilerGeneratedAttribute]
private ColumnInspector <get_Columns>b__13_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Instances.AccessInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public AccessInstance(Action`1<string> setter);
    public sealed virtual void Property();
    public sealed virtual void Field();
    public sealed virtual void BackField();
    public sealed virtual void CamelCaseField();
    public sealed virtual void CamelCaseField(CamelCasePrefix prefix);
    public sealed virtual void LowerCaseField();
    public sealed virtual void LowerCaseField(LowerCasePrefix prefix);
    public sealed virtual void PascalCaseField(PascalCasePrefix prefix);
    public sealed virtual void ReadOnlyProperty();
    public sealed virtual void ReadOnlyPropertyThroughCamelCaseField();
    public sealed virtual void ReadOnlyPropertyThroughCamelCaseField(CamelCasePrefix prefix);
    public sealed virtual void ReadOnlyPropertyThroughLowerCaseField();
    public sealed virtual void ReadOnlyPropertyThroughLowerCaseField(LowerCasePrefix prefix);
    public sealed virtual void ReadOnlyPropertyThroughPascalCaseField(PascalCasePrefix prefix);
    public sealed virtual void Using(string propertyAccessorAssemblyQualifiedClassName);
    public sealed virtual void Using(Type propertyAccessorClassType);
    public sealed virtual void Using();
    public sealed virtual void NoOp();
    public sealed virtual void None();
}
public class FluentNHibernate.Conventions.Instances.AnyInstance : AnyInspector {
    private AnyMapping mapping;
    public IAccessInstance Access { get; }
    public AnyInstance(AnyMapping mapping);
    public sealed virtual IAccessInstance get_Access();
    [CompilerGeneratedAttribute]
private void <get_Access>b__3_0(string value);
}
public class FluentNHibernate.Conventions.Instances.CacheInstance : CacheInspector {
    private static int layer;
    private CacheMapping mapping;
    public CacheInstance(CacheMapping mapping);
    public sealed virtual void ReadWrite();
    public sealed virtual void NonStrictReadWrite();
    public sealed virtual void ReadOnly();
    public sealed virtual void Transactional();
    public sealed virtual void IncludeAll();
    public sealed virtual void IncludeNonLazy();
    public sealed virtual void CustomInclude(string include);
    public sealed virtual void CustomUsage(string custom);
    public sealed virtual void Region(string name);
}
public class FluentNHibernate.Conventions.Instances.CascadeInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public CascadeInstance(Action`1<string> setter);
    public sealed virtual void All();
    public sealed virtual void None();
    public sealed virtual void SaveUpdate();
    public sealed virtual void Delete();
    public sealed virtual void Merge();
}
public class FluentNHibernate.Conventions.Instances.ClassInstance : ClassInspector {
    private ClassMapping mapping;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public IClassInstance Not { get; }
    public ISchemaActionInstance SchemaAction { get; }
    public IOptimisticLockInstance OptimisticLock { get; }
    public ClassInstance(ClassMapping mapping);
    public sealed virtual IClassInstance get_Not();
    public sealed virtual ISchemaActionInstance get_SchemaAction();
    public sealed virtual void Table(string tableName);
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void DynamicInsert();
    public sealed virtual void DynamicUpdate();
    public sealed virtual IOptimisticLockInstance get_OptimisticLock();
    public sealed virtual void BatchSize(int size);
    public sealed virtual void LazyLoad();
    public sealed virtual void ReadOnly();
    public sealed virtual void Schema(string schema);
    public sealed virtual void Where(string where);
    public sealed virtual void Subselect(string subselectSql);
    public sealed virtual void Proxy();
    public sealed virtual void Proxy(Type type);
    public sealed virtual void Proxy(string type);
    public sealed virtual void ApplyFilter(string name, string condition);
    public sealed virtual void ApplyFilter(string name);
    public sealed virtual void ApplyFilter(string condition);
    public sealed virtual void ApplyFilter();
    [CompilerGeneratedAttribute]
private void <get_SchemaAction>b__6_0(string value);
    [CompilerGeneratedAttribute]
private void <get_OptimisticLock>b__12_0(string value);
}
public class FluentNHibernate.Conventions.Instances.CollectionCascadeInstance : CascadeInstance {
    private Action`1<string> setter;
    public CollectionCascadeInstance(Action`1<string> setter);
    public sealed virtual void AllDeleteOrphan();
    public sealed virtual void DeleteOrphan();
}
public class FluentNHibernate.Conventions.Instances.CollectionInstance : CollectionInspector {
    private CollectionMapping mapping;
    protected bool nextBool;
    public IRelationshipInstance Relationship { get; }
    public ICollectionCascadeInstance Cascade { get; }
    public IFetchInstance Fetch { get; }
    public IIndexInstanceBase Index { get; }
    [DebuggerBrowsableAttribute("0")]
public ICollectionInstance Not { get; }
    public ICacheInstance Cache { get; }
    public IAccessInstance Access { get; }
    public IKeyInstance Key { get; }
    public IElementInstance Element { get; }
    public CollectionInstance(CollectionMapping mapping);
    public sealed virtual IRelationshipInstance get_Relationship();
    public sealed virtual ICollectionCascadeInstance get_Cascade();
    public sealed virtual IFetchInstance get_Fetch();
    public sealed virtual void OptimisticLock();
    public sealed virtual void Check(string constraint);
    public sealed virtual void CollectionType();
    public sealed virtual void CollectionType(string type);
    public sealed virtual void CollectionType(Type type);
    public sealed virtual void Generic();
    public sealed virtual void Inverse();
    public sealed virtual void Persister();
    public sealed virtual void Where(string whereClause);
    public sealed virtual IIndexInstanceBase get_Index();
    public sealed virtual void OrderBy(string orderBy);
    public sealed virtual void Sort(string sort);
    public sealed virtual void Subselect(string subselect);
    public sealed virtual void KeyNullable();
    public sealed virtual void KeyUpdate();
    public sealed virtual void Table(string tableName);
    public sealed virtual void Name(string name);
    public sealed virtual void Schema(string schema);
    public sealed virtual void LazyLoad();
    public virtual void ExtraLazyLoad();
    public sealed virtual void BatchSize(int batchSize);
    public sealed virtual void ReadOnly();
    private sealed virtual override void FluentNHibernate.Conventions.Instances.ICollectionInstance.AsArray();
    private sealed virtual override void FluentNHibernate.Conventions.Instances.ICollectionInstance.AsBag();
    private sealed virtual override void FluentNHibernate.Conventions.Instances.ICollectionInstance.AsList();
    private sealed virtual override void FluentNHibernate.Conventions.Instances.ICollectionInstance.AsMap();
    private sealed virtual override void FluentNHibernate.Conventions.Instances.ICollectionInstance.AsSet();
    public sealed virtual ICollectionInstance get_Not();
    public sealed virtual ICacheInstance get_Cache();
    public void SetOrderBy(string orderBy);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual IKeyInstance get_Key();
    public sealed virtual IElementInstance get_Element();
    public sealed virtual void ApplyFilter(string name, string condition);
    public sealed virtual void ApplyFilter(string name);
    public sealed virtual void ApplyFilter(string condition);
    public sealed virtual void ApplyFilter();
    [CompilerGeneratedAttribute]
private void <get_Cascade>b__6_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Fetch>b__8_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Access>b__43_0(string value);
}
public class FluentNHibernate.Conventions.Instances.ColumnInstance : ColumnInspector {
    private ColumnMapping mapping;
    public ColumnInstance(Type parentType, ColumnMapping mapping);
    public sealed virtual void Length(int length);
    public sealed virtual void Index(string indexname);
    public sealed virtual void Default(string defaultvalue);
}
public class FluentNHibernate.Conventions.Instances.ComponentInstance : ComponentInspector {
    [CompilerGeneratedAttribute]
private ComponentMapping <mapping>P;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public IComponentInstance Not { get; }
    public IAccessInstance Access { get; }
    public IEnumerable`1<IOneToOneInstance> OneToOnes { get; }
    public IEnumerable`1<IPropertyInstance> Properties { get; }
    public ComponentInstance(ComponentMapping mapping);
    public sealed virtual IComponentInstance get_Not();
    public sealed virtual void LazyLoad();
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void Update();
    public sealed virtual void Insert();
    public sealed virtual void Unique();
    public sealed virtual void OptimisticLock();
    public sealed virtual IEnumerable`1<IOneToOneInstance> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInstance> get_Properties();
    [CompilerGeneratedAttribute]
private void <get_Access>b__7_0(string value);
}
public class FluentNHibernate.Conventions.Instances.CompositeIdentityInstance : CompositeIdentityInspector {
    private CompositeIdMapping mapping;
    private bool nextBool;
    public IAccessInstance Access { get; }
    public ICompositeIdentityInstance Not { get; }
    public IEnumerable`1<IKeyPropertyInstance> KeyProperties { get; }
    public IEnumerable`1<IKeyManyToOneInstance> KeyManyToOnes { get; }
    public CompositeIdentityInstance(CompositeIdMapping mapping);
    public sealed virtual void UnsavedValue(string unsavedValue);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void Mapped();
    public sealed virtual ICompositeIdentityInstance get_Not();
    public sealed virtual IEnumerable`1<IKeyPropertyInstance> get_KeyProperties();
    public sealed virtual IEnumerable`1<IKeyManyToOneInstance> get_KeyManyToOnes();
    [CompilerGeneratedAttribute]
private void <get_Access>b__5_0(string value);
}
public class FluentNHibernate.Conventions.Instances.DynamicComponentInstance : DynamicComponentInspector {
    [CompilerGeneratedAttribute]
private ComponentMapping <mapping>P;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public IDynamicComponentInstance Not { get; }
    public IAccessInstance Access { get; }
    public IEnumerable`1<IOneToOneInstance> OneToOnes { get; }
    public IEnumerable`1<IPropertyInstance> Properties { get; }
    public DynamicComponentInstance(ComponentMapping mapping);
    public sealed virtual IDynamicComponentInstance get_Not();
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void Update();
    public sealed virtual void Insert();
    public sealed virtual void Unique();
    public sealed virtual void OptimisticLock();
    public sealed virtual IEnumerable`1<IOneToOneInstance> get_OneToOnes();
    public sealed virtual IEnumerable`1<IPropertyInstance> get_Properties();
    [CompilerGeneratedAttribute]
private void <get_Access>b__6_0(string value);
}
public class FluentNHibernate.Conventions.Instances.ElementInstance : ElementInspector {
    private ElementMapping mapping;
    public ElementInstance(ElementMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void Type();
    public sealed virtual void Type(string type);
    public sealed virtual void Type(Type type);
}
public class FluentNHibernate.Conventions.Instances.FetchInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public FetchInstance(Action`1<string> setter);
    public sealed virtual void Join();
    public sealed virtual void Select();
    public sealed virtual void Subselect();
}
public class FluentNHibernate.Conventions.Instances.GeneratedInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public GeneratedInstance(Action`1<string> setter);
    public sealed virtual void Never();
    public sealed virtual void Insert();
    public sealed virtual void Always();
}
public class FluentNHibernate.Conventions.Instances.GeneratorInstance : GeneratorInspector {
    private GeneratorBuilder builder;
    public GeneratorInstance(GeneratorMapping mapping, Type type);
    public sealed virtual void Increment();
    public sealed virtual void Increment(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Identity();
    public sealed virtual void Identity(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Sequence(string sequenceName);
    public sealed virtual void Sequence(string sequenceName, Action`1<ParamBuilder> paramValues);
    public sealed virtual void HiLo(string table, string column, string maxLo, string where);
    public sealed virtual void HiLo(string table, string column, string maxLo);
    public sealed virtual void HiLo(string table, string column, string maxLo, Action`1<ParamBuilder> paramValues);
    public sealed virtual void HiLo(string maxLo);
    public sealed virtual void HiLo(string maxLo, Action`1<ParamBuilder> paramValues);
    public sealed virtual void SeqHiLo(string sequence, string maxLo);
    public sealed virtual void SeqHiLo(string sequence, string maxLo, Action`1<ParamBuilder> paramValues);
    public sealed virtual void UuidHex(string format);
    public sealed virtual void UuidHex(string format, Action`1<ParamBuilder> paramValues);
    public sealed virtual void UuidString();
    public sealed virtual void UuidString(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Guid();
    public sealed virtual void Guid(Action`1<ParamBuilder> paramValues);
    public sealed virtual void GuidComb();
    public sealed virtual void GuidComb(Action`1<ParamBuilder> paramValues);
    public sealed virtual void GuidNative();
    public sealed virtual void GuidNative(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Select();
    public sealed virtual void Select(Action`1<ParamBuilder> paramValues);
    public sealed virtual void SequenceIdentity();
    public sealed virtual void SequenceIdentity(string sequence);
    public sealed virtual void SequenceIdentity(Action`1<ParamBuilder> paramValues);
    public sealed virtual void SequenceIdentity(string sequence, Action`1<ParamBuilder> paramValues);
    public sealed virtual void TriggerIdentity();
    public sealed virtual void TriggerIdentity(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Assigned();
    public sealed virtual void Assigned(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Native();
    public sealed virtual void Native(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Native(string sequenceName);
    public sealed virtual void Native(string sequenceName, Action`1<ParamBuilder> paramValues);
    public sealed virtual void Foreign(string property);
    public sealed virtual void Foreign(string property, Action`1<ParamBuilder> paramValues);
    public sealed virtual void Custom();
    public sealed virtual void Custom(Type generator);
    public sealed virtual void Custom(string generator);
    public sealed virtual void Custom(Action`1<ParamBuilder> paramValues);
    public sealed virtual void Custom(Type generator, Action`1<ParamBuilder> paramValues);
    public sealed virtual void Custom(string generator, Action`1<ParamBuilder> paramValues);
}
public class FluentNHibernate.Conventions.Instances.HibernateMappingInstance : HibernateMappingInspector {
    private HibernateMapping mapping;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public IHibernateMappingInstance Not { get; }
    public ICascadeInstance DefaultCascade { get; }
    public IAccessInstance DefaultAccess { get; }
    public HibernateMappingInstance(HibernateMapping mapping);
    public sealed virtual void Catalog(string catalog);
    public sealed virtual void Schema(string schema);
    public sealed virtual IHibernateMappingInstance get_Not();
    public sealed virtual void DefaultLazy();
    public sealed virtual void AutoImport();
    public sealed virtual ICascadeInstance get_DefaultCascade();
    public sealed virtual IAccessInstance get_DefaultAccess();
    [CompilerGeneratedAttribute]
private void <get_DefaultCascade>b__10_0(string value);
    [CompilerGeneratedAttribute]
private void <get_DefaultAccess>b__12_0(string value);
}
public interface FluentNHibernate.Conventions.Instances.IAccessInstance {
    public abstract virtual void Property();
    public abstract virtual void Field();
    public abstract virtual void BackField();
    public abstract virtual void CamelCaseField();
    public abstract virtual void CamelCaseField(CamelCasePrefix prefix);
    public abstract virtual void LowerCaseField();
    public abstract virtual void LowerCaseField(LowerCasePrefix prefix);
    public abstract virtual void PascalCaseField(PascalCasePrefix prefix);
    public abstract virtual void ReadOnlyProperty();
    public abstract virtual void ReadOnlyPropertyThroughCamelCaseField();
    public abstract virtual void ReadOnlyPropertyThroughCamelCaseField(CamelCasePrefix prefix);
    public abstract virtual void ReadOnlyPropertyThroughLowerCaseField();
    public abstract virtual void ReadOnlyPropertyThroughLowerCaseField(LowerCasePrefix prefix);
    public abstract virtual void ReadOnlyPropertyThroughPascalCaseField(PascalCasePrefix prefix);
    public abstract virtual void Using(string propertyAccessorAssemblyQualifiedClassName);
    public abstract virtual void Using(Type propertyAccessorClassType);
    public abstract virtual void Using();
    public abstract virtual void NoOp();
    public abstract virtual void None();
}
[ObsoleteAttribute("Use IConventionInstance")]
public interface FluentNHibernate.Conventions.Instances.IArrayInstance {
}
[ObsoleteAttribute("Use ICollectionInstance")]
public interface FluentNHibernate.Conventions.Instances.IBagInstance {
}
public interface FluentNHibernate.Conventions.Instances.ICacheInstance {
    public abstract virtual void ReadWrite();
    public abstract virtual void NonStrictReadWrite();
    public abstract virtual void ReadOnly();
    public abstract virtual void Transactional();
    public abstract virtual void IncludeAll();
    public abstract virtual void IncludeNonLazy();
    public abstract virtual void CustomInclude(string include);
    public abstract virtual void CustomUsage(string custom);
    public abstract virtual void Region(string name);
}
public interface FluentNHibernate.Conventions.Instances.ICascadeInstance {
    public abstract virtual void All();
    public abstract virtual void None();
    public abstract virtual void SaveUpdate();
    public abstract virtual void Delete();
    public abstract virtual void Merge();
}
public interface FluentNHibernate.Conventions.Instances.IClassInstance {
    [DebuggerBrowsableAttribute("0")]
public IClassInstance Not { get; }
    public IOptimisticLockInstance OptimisticLock { get; }
    public ICacheInstance Cache { get; }
    public ISchemaActionInstance SchemaAction { get; }
    public abstract virtual IClassInstance get_Not();
    public abstract virtual IOptimisticLockInstance get_OptimisticLock();
    public abstract virtual ICacheInstance get_Cache();
    public abstract virtual ISchemaActionInstance get_SchemaAction();
    public abstract virtual void Table(string tableName);
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void DynamicInsert();
    public abstract virtual void DynamicUpdate();
    public abstract virtual void BatchSize(int size);
    public abstract virtual void LazyLoad();
    public abstract virtual void ReadOnly();
    public abstract virtual void Schema(string schema);
    public abstract virtual void Where(string where);
    public abstract virtual void Subselect(string subselectSql);
    public abstract virtual void Proxy();
    public abstract virtual void Proxy(Type type);
    public abstract virtual void Proxy(string type);
    public abstract virtual void ApplyFilter(string name, string condition);
    public abstract virtual void ApplyFilter(string name);
    public abstract virtual void ApplyFilter(string condition);
    public abstract virtual void ApplyFilter();
}
public interface FluentNHibernate.Conventions.Instances.ICollectionCascadeInstance {
    public abstract virtual void AllDeleteOrphan();
    public abstract virtual void DeleteOrphan();
}
public interface FluentNHibernate.Conventions.Instances.ICollectionInstance {
    public IKeyInstance Key { get; }
    public IIndexInstanceBase Index { get; }
    public IElementInstance Element { get; }
    public IRelationshipInstance Relationship { get; }
    [DebuggerBrowsableAttribute("0")]
public ICollectionInstance Not { get; }
    public IAccessInstance Access { get; }
    public ICacheInstance Cache { get; }
    public ICollectionCascadeInstance Cascade { get; }
    public IFetchInstance Fetch { get; }
    public abstract virtual IKeyInstance get_Key();
    public abstract virtual IIndexInstanceBase get_Index();
    public abstract virtual IElementInstance get_Element();
    public abstract virtual IRelationshipInstance get_Relationship();
    public abstract virtual void Table(string tableName);
    public abstract virtual void Name(string name);
    public abstract virtual void Schema(string schema);
    public abstract virtual void LazyLoad();
    public abstract virtual void ExtraLazyLoad();
    public abstract virtual void BatchSize(int batchSize);
    public abstract virtual void ReadOnly();
    public abstract virtual void AsArray();
    public abstract virtual void AsBag();
    public abstract virtual void AsList();
    public abstract virtual void AsMap();
    public abstract virtual void AsSet();
    public abstract virtual ICollectionInstance get_Not();
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual ICacheInstance get_Cache();
    public abstract virtual ICollectionCascadeInstance get_Cascade();
    public abstract virtual IFetchInstance get_Fetch();
    public abstract virtual void OptimisticLock();
    public abstract virtual void Check(string constraint);
    public abstract virtual void CollectionType();
    public abstract virtual void CollectionType(string type);
    public abstract virtual void CollectionType(Type type);
    public abstract virtual void Generic();
    public abstract virtual void Inverse();
    public abstract virtual void Persister();
    public abstract virtual void Where(string whereClause);
    public abstract virtual void OrderBy(string orderBy);
    public abstract virtual void Sort(string sort);
    public abstract virtual void Subselect(string subselect);
    public abstract virtual void KeyNullable();
    public abstract virtual void KeyUpdate();
}
public interface FluentNHibernate.Conventions.Instances.IColumnInstance {
    public abstract virtual void Length(int length);
    public abstract virtual void Index(string indexname);
    public abstract virtual void Default(string defaultvalue);
}
public interface FluentNHibernate.Conventions.Instances.IComponentBaseInstance {
    public IAccessInstance Access { get; }
    public IEnumerable`1<IOneToOneInstance> OneToOnes { get; }
    public IEnumerable`1<IPropertyInstance> Properties { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual void Update();
    public abstract virtual void Insert();
    public abstract virtual void Unique();
    public abstract virtual void OptimisticLock();
    public abstract virtual IEnumerable`1<IOneToOneInstance> get_OneToOnes();
    public abstract virtual IEnumerable`1<IPropertyInstance> get_Properties();
}
public interface FluentNHibernate.Conventions.Instances.IComponentInstance {
    [DebuggerBrowsableAttribute("0")]
public IComponentInstance Not { get; }
    public abstract virtual IComponentInstance get_Not();
    public abstract virtual void LazyLoad();
}
public interface FluentNHibernate.Conventions.Instances.ICompositeIdentityInstance {
    public IAccessInstance Access { get; }
    [DebuggerBrowsableAttribute("0")]
public ICompositeIdentityInstance Not { get; }
    public IEnumerable`1<IKeyPropertyInstance> KeyProperties { get; }
    public IEnumerable`1<IKeyManyToOneInstance> KeyManyToOnes { get; }
    public abstract virtual void UnsavedValue(string unsavedValue);
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual void Mapped();
    public abstract virtual ICompositeIdentityInstance get_Not();
    public abstract virtual IEnumerable`1<IKeyPropertyInstance> get_KeyProperties();
    public abstract virtual IEnumerable`1<IKeyManyToOneInstance> get_KeyManyToOnes();
}
public class FluentNHibernate.Conventions.Instances.IdentityInstance : IdentityInspector {
    private IdMapping mapping;
    private bool nextBool;
    public IAccessInstance Access { get; }
    public IGeneratorInstance GeneratedBy { get; }
    [DebuggerBrowsableAttribute("0")]
public IIdentityInstance Not { get; }
    public IdentityInstance(IdMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void UnsavedValue(string unsavedValue);
    public sealed virtual void Length(int length);
    public sealed virtual void CustomType(string type);
    public sealed virtual void CustomType(Type type);
    public sealed virtual void CustomType();
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual IGeneratorInstance get_GeneratedBy();
    public sealed virtual IIdentityInstance get_Not();
    public sealed virtual void Precision(int precision);
    public sealed virtual void Scale(int scale);
    public sealed virtual void Nullable();
    public sealed virtual void Unique();
    public sealed virtual void UniqueKey(string columns);
    public sealed virtual void CustomSqlType(string sqlType);
    public sealed virtual void Index(string index);
    public sealed virtual void Check(string constraint);
    public sealed virtual void Default(object value);
    [CompilerGeneratedAttribute]
private void <get_Access>b__10_0(string value);
}
public interface FluentNHibernate.Conventions.Instances.IDynamicComponentInstance {
    [DebuggerBrowsableAttribute("0")]
public IDynamicComponentInstance Not { get; }
    public abstract virtual IDynamicComponentInstance get_Not();
}
public interface FluentNHibernate.Conventions.Instances.IElementInstance {
    public abstract virtual void Type();
    public abstract virtual void Type(string type);
    public abstract virtual void Type(Type type);
    public abstract virtual void Column(string name);
}
public interface FluentNHibernate.Conventions.Instances.IFetchInstance {
    public abstract virtual void Join();
    public abstract virtual void Select();
    public abstract virtual void Subselect();
}
public interface FluentNHibernate.Conventions.Instances.IGeneratedInstance {
    public abstract virtual void Never();
    public abstract virtual void Insert();
    public abstract virtual void Always();
}
public interface FluentNHibernate.Conventions.Instances.IGeneratorInstance {
    public abstract virtual void Increment();
    public abstract virtual void Increment(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Identity();
    public abstract virtual void Identity(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Sequence(string sequenceName);
    public abstract virtual void Sequence(string sequenceName, Action`1<ParamBuilder> paramValues);
    public abstract virtual void HiLo(string table, string column, string maxLo, string where);
    public abstract virtual void HiLo(string table, string column, string maxLo);
    public abstract virtual void HiLo(string table, string column, string maxLo, Action`1<ParamBuilder> paramValues);
    public abstract virtual void HiLo(string maxLo);
    public abstract virtual void HiLo(string maxLo, Action`1<ParamBuilder> paramValues);
    public abstract virtual void SeqHiLo(string sequence, string maxLo);
    public abstract virtual void SeqHiLo(string sequence, string maxLo, Action`1<ParamBuilder> paramValues);
    public abstract virtual void UuidHex(string format);
    public abstract virtual void UuidHex(string format, Action`1<ParamBuilder> paramValues);
    public abstract virtual void UuidString();
    public abstract virtual void UuidString(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Guid();
    public abstract virtual void Guid(Action`1<ParamBuilder> paramValues);
    public abstract virtual void GuidComb();
    public abstract virtual void GuidComb(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Assigned();
    public abstract virtual void Assigned(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Native();
    public abstract virtual void Native(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Native(string sequenceName);
    public abstract virtual void Native(string sequenceName, Action`1<ParamBuilder> paramValues);
    public abstract virtual void Foreign(string property);
    public abstract virtual void Foreign(string property, Action`1<ParamBuilder> paramValues);
    public abstract virtual void Custom();
    public abstract virtual void Custom(Type generator);
    public abstract virtual void Custom(string generator);
    public abstract virtual void Custom(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Custom(Type generator, Action`1<ParamBuilder> paramValues);
    public abstract virtual void Custom(string generator, Action`1<ParamBuilder> paramValues);
    public abstract virtual void GuidNative();
    public abstract virtual void GuidNative(Action`1<ParamBuilder> paramValues);
    public abstract virtual void Select();
    public abstract virtual void Select(Action`1<ParamBuilder> paramValues);
    public abstract virtual void SequenceIdentity();
    public abstract virtual void SequenceIdentity(string sequence);
    public abstract virtual void SequenceIdentity(Action`1<ParamBuilder> paramValues);
    public abstract virtual void SequenceIdentity(string sequence, Action`1<ParamBuilder> paramValues);
    public abstract virtual void TriggerIdentity();
    public abstract virtual void TriggerIdentity(Action`1<ParamBuilder> paramValues);
}
public interface FluentNHibernate.Conventions.Instances.IHibernateMappingInstance {
    [DebuggerBrowsableAttribute("0")]
public IHibernateMappingInstance Not { get; }
    public ICascadeInstance DefaultCascade { get; }
    public IAccessInstance DefaultAccess { get; }
    public abstract virtual void Catalog(string catalog);
    public abstract virtual void Schema(string schema);
    public abstract virtual IHibernateMappingInstance get_Not();
    public abstract virtual void DefaultLazy();
    public abstract virtual void AutoImport();
    public abstract virtual ICascadeInstance get_DefaultCascade();
    public abstract virtual IAccessInstance get_DefaultAccess();
}
public interface FluentNHibernate.Conventions.Instances.IIdentityInstance {
    public IAccessInstance Access { get; }
    public IGeneratorInstance GeneratedBy { get; }
    [DebuggerBrowsableAttribute("0")]
public IIdentityInstance Not { get; }
    public abstract virtual void Column(string column);
    public abstract virtual void UnsavedValue(string unsavedValue);
    public abstract virtual void Length(int length);
    public abstract virtual void CustomType(string type);
    public abstract virtual void CustomType(Type type);
    public abstract virtual void CustomType();
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual IGeneratorInstance get_GeneratedBy();
    public abstract virtual IIdentityInstance get_Not();
    public abstract virtual void Precision(int precision);
    public abstract virtual void Scale(int scale);
    public abstract virtual void Nullable();
    public abstract virtual void Unique();
    public abstract virtual void UniqueKey(string columns);
    public abstract virtual void CustomSqlType(string sqlType);
    public abstract virtual void Index(string index);
    public abstract virtual void Check(string constraint);
    public abstract virtual void Default(object value);
}
public interface FluentNHibernate.Conventions.Instances.IIndexInstance {
}
public interface FluentNHibernate.Conventions.Instances.IIndexInstanceBase {
    public abstract virtual void Column(string columnName);
}
public interface FluentNHibernate.Conventions.Instances.IIndexManyToManyInstance {
    public abstract virtual void ForeignKey(string foreignKey);
}
public interface FluentNHibernate.Conventions.Instances.IInsertInstance {
    public abstract virtual void Insert();
}
public interface FluentNHibernate.Conventions.Instances.IJoinedSubclassInstance {
    public IKeyInstance Key { get; }
    [DebuggerBrowsableAttribute("0")]
public IJoinedSubclassInstance Not { get; }
    public abstract virtual IKeyInstance get_Key();
    public abstract virtual IJoinedSubclassInstance get_Not();
    public abstract virtual void Abstract();
    public abstract virtual void Check(string constraint);
    public abstract virtual void DynamicInsert();
    public abstract virtual void DynamicUpdate();
    public abstract virtual void LazyLoad();
    public abstract virtual void Proxy(Type type);
    public abstract virtual void Proxy();
    public abstract virtual void Schema(string schema);
    public abstract virtual void SelectBeforeUpdate();
    public abstract virtual void Table(string tableName);
    public abstract virtual void Subselect(string subselect);
    public abstract virtual void Persister();
    public abstract virtual void Persister(Type type);
    public abstract virtual void Persister(string type);
    public abstract virtual void BatchSize(int batchSize);
}
public interface FluentNHibernate.Conventions.Instances.IJoinInstance {
    [DebuggerBrowsableAttribute("0")]
public IJoinInstance Not { get; }
    public IFetchInstance Fetch { get; }
    public IKeyInstance Key { get; }
    public abstract virtual IJoinInstance get_Not();
    public abstract virtual IFetchInstance get_Fetch();
    public abstract virtual void Inverse();
    public abstract virtual IKeyInstance get_Key();
    public abstract virtual void Optional();
    public abstract virtual void Schema(string schema);
    public abstract virtual void Table(string table);
    public abstract virtual void Catalog(string catalog);
    public abstract virtual void Subselect(string subselect);
}
public interface FluentNHibernate.Conventions.Instances.IKeyInstance {
    public IEnumerable`1<IColumnInspector> Columns { get; }
    public abstract virtual void Column(string columnName);
    public abstract virtual void ForeignKey(string constraint);
    public abstract virtual void PropertyRef(string property);
    public abstract virtual IEnumerable`1<IColumnInspector> get_Columns();
    public abstract virtual void CascadeOnDelete();
}
public interface FluentNHibernate.Conventions.Instances.IKeyManyToOneInstance {
    public IAccessInstance Access { get; }
    public INotFoundInstance NotFound { get; }
    [DebuggerBrowsableAttribute("0")]
public IKeyManyToOneInstance Not { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual void ForeignKey(string name);
    public abstract virtual void Lazy();
    public abstract virtual INotFoundInstance get_NotFound();
    public abstract virtual IKeyManyToOneInstance get_Not();
}
public interface FluentNHibernate.Conventions.Instances.IKeyPropertyInstance {
    public IAccessInstance Access { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual void Length(int length);
}
[ObsoleteAttribute("Use ICollectionInstance")]
public interface FluentNHibernate.Conventions.Instances.IListInstance {
}
public interface FluentNHibernate.Conventions.Instances.IManyToManyCollectionInstance {
    public IManyToManyInstance Relationship { get; }
    [DebuggerBrowsableAttribute("0")]
public IManyToManyCollectionInstance Not { get; }
    public IManyToManyCollectionInstance OtherSide { get; }
    public abstract virtual IManyToManyInstance get_Relationship();
    public abstract virtual IManyToManyCollectionInstance get_Not();
    public abstract virtual IManyToManyCollectionInstance get_OtherSide();
    public abstract virtual void ApplyFilter(string name, string condition);
    public abstract virtual void ApplyFilter(string name);
    public abstract virtual void ApplyFilter(string condition);
    public abstract virtual void ApplyFilter();
}
public interface FluentNHibernate.Conventions.Instances.IManyToManyInstance {
    public IEnumerable`1<IColumnInstance> Columns { get; }
    public abstract virtual void Column(string columnName);
    public abstract virtual IEnumerable`1<IColumnInstance> get_Columns();
    public abstract virtual void ForeignKey(string constraint);
    public abstract virtual void Where(string where);
    public abstract virtual void OrderBy(string orderBy);
}
public interface FluentNHibernate.Conventions.Instances.IManyToOneInstance {
    public IAccessInstance Access { get; }
    public ICascadeInstance Cascade { get; }
    public IFetchInstance Fetch { get; }
    [DebuggerBrowsableAttribute("0")]
public IManyToOneInstance Not { get; }
    public INotFoundInstance NotFound { get; }
    public abstract virtual void Column(string columnName);
    public abstract virtual void CustomClass();
    public abstract virtual void CustomClass(Type type);
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual ICascadeInstance get_Cascade();
    public abstract virtual IFetchInstance get_Fetch();
    public abstract virtual IManyToOneInstance get_Not();
    public abstract virtual INotFoundInstance get_NotFound();
    public abstract virtual void Index(string index);
    public abstract virtual void Insert();
    public abstract virtual void OptimisticLock();
    public abstract virtual void LazyLoad();
    public abstract virtual void LazyLoad(Laziness laziness);
    public abstract virtual void Nullable();
    public abstract virtual void PropertyRef(string property);
    public abstract virtual void ReadOnly();
    public abstract virtual void Unique();
    public abstract virtual void UniqueKey(string key);
    public abstract virtual void Update();
    public abstract virtual void ForeignKey(string key);
    public abstract virtual void Formula(string formula);
    public abstract virtual void OverrideInferredClass(Type type);
}
[ObsoleteAttribute("Use ICollectionInstance")]
public interface FluentNHibernate.Conventions.Instances.IMapInstance {
}
public class FluentNHibernate.Conventions.Instances.IndexInstance : IndexInspector {
    private IndexMapping mapping;
    public IndexInstance(IndexMapping mapping);
    public sealed virtual void Column(string columnName);
}
public class FluentNHibernate.Conventions.Instances.IndexManyToManyInstance : IndexManyToManyInspector {
    private IndexManyToManyMapping mapping;
    public IndexManyToManyInstance(IndexManyToManyMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void ForeignKey(string foreignKey);
}
public interface FluentNHibernate.Conventions.Instances.INotFoundInstance {
    public abstract virtual void Ignore();
    public abstract virtual void Exception();
}
public interface FluentNHibernate.Conventions.Instances.INullableInstance {
    public abstract virtual void Nullable();
}
public interface FluentNHibernate.Conventions.Instances.IOneToManyCollectionInstance {
    public IOneToManyInstance Relationship { get; }
    [DebuggerBrowsableAttribute("0")]
public IOneToManyCollectionInstance Not { get; }
    public IManyToOneInstance OtherSide { get; }
    public abstract virtual IOneToManyInstance get_Relationship();
    public abstract virtual IOneToManyCollectionInstance get_Not();
    public abstract virtual IManyToOneInstance get_OtherSide();
    public abstract virtual void ApplyFilter(string name, string condition);
    public abstract virtual void ApplyFilter(string name);
    public abstract virtual void ApplyFilter(string condition);
    public abstract virtual void ApplyFilter();
}
public interface FluentNHibernate.Conventions.Instances.IOneToManyInstance {
    public INotFoundInstance NotFound { get; }
    public abstract virtual INotFoundInstance get_NotFound();
}
public interface FluentNHibernate.Conventions.Instances.IOneToOneInstance {
    public IAccessInstance Access { get; }
    public ICascadeInstance Cascade { get; }
    [DebuggerBrowsableAttribute("0")]
public IOneToOneInstance Not { get; }
    public IFetchInstance Fetch { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual ICascadeInstance get_Cascade();
    public abstract virtual IOneToOneInstance get_Not();
    public abstract virtual IFetchInstance get_Fetch();
    public abstract virtual void Class();
    public abstract virtual void Class(Type type);
    public abstract virtual void Constrained();
    public abstract virtual void ForeignKey(string key);
    public abstract virtual void LazyLoad();
    public abstract virtual void LazyLoad(Laziness laziness);
    public abstract virtual void PropertyRef(string propertyName);
    public abstract virtual void OverrideInferredClass(Type type);
}
public interface FluentNHibernate.Conventions.Instances.IOptimisticLockInstance {
    public abstract virtual void None();
    public abstract virtual void Version();
    public abstract virtual void Dirty();
    public abstract virtual void All();
}
public interface FluentNHibernate.Conventions.Instances.IPropertyInstance {
    public IAccessInstance Access { get; }
    [DebuggerBrowsableAttribute("0")]
public IPropertyInstance Not { get; }
    public IGeneratedInstance Generated { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual IPropertyInstance get_Not();
    public abstract virtual void CustomType();
    public abstract virtual void CustomType(string columnPrefix);
    public abstract virtual void CustomType(TypeReference type);
    public abstract virtual void CustomType(TypeReference type, string columnPrefix);
    public abstract virtual void CustomType(Type type);
    public abstract virtual void CustomType(Type type, string columnPrefix);
    public abstract virtual void CustomType(string type);
    public abstract virtual void CustomType(string type, string columnPrefix);
    public abstract virtual void CustomSqlType(string sqlType);
    public abstract virtual void Precision(int precision);
    public abstract virtual void Scale(int scale);
    public abstract virtual void Default(string value);
    public abstract virtual void Unique();
    public abstract virtual void UniqueKey(string keyName);
    public abstract virtual void Column(string columnName);
    public abstract virtual void Formula(string formula);
    public abstract virtual IGeneratedInstance get_Generated();
    public abstract virtual void OptimisticLock();
    public abstract virtual void Length(int length);
    public abstract virtual void LazyLoad();
    public abstract virtual void Index(string value);
    public abstract virtual void Check(string constraint);
}
public interface FluentNHibernate.Conventions.Instances.IReadOnlyInstance {
    public abstract virtual void ReadOnly();
}
public interface FluentNHibernate.Conventions.Instances.IRelationshipInstance {
    public abstract virtual void CustomClass();
    public abstract virtual void CustomClass(Type type);
}
public interface FluentNHibernate.Conventions.Instances.ISchemaActionInstance {
    public abstract virtual void None();
    public abstract virtual void All();
    public abstract virtual void Drop();
    public abstract virtual void Update();
    public abstract virtual void Validate();
    public abstract virtual void Export();
    public abstract virtual void Custom(string customValue);
}
[ObsoleteAttribute("Use ICollectionInstance")]
public interface FluentNHibernate.Conventions.Instances.ISetInstance {
}
public interface FluentNHibernate.Conventions.Instances.ISubclassInstance {
    [DebuggerBrowsableAttribute("0")]
public ISubclassInstance Not { get; }
    public abstract virtual ISubclassInstance get_Not();
    public abstract virtual void DiscriminatorValue(object value);
    public abstract virtual void Abstract();
    public abstract virtual void DynamicInsert();
    public abstract virtual void DynamicUpdate();
    public abstract virtual void LazyLoad();
    public abstract virtual void Proxy(Type type);
    public abstract virtual void Proxy();
    public abstract virtual void SelectBeforeUpdate();
    public abstract virtual void Extends();
    public abstract virtual void Extends(Type type);
}
public interface FluentNHibernate.Conventions.Instances.IUpdateInstance {
    public abstract virtual void Update();
}
public interface FluentNHibernate.Conventions.Instances.IVersionInstance {
    public IAccessInstance Access { get; }
    public IGeneratedInstance Generated { get; }
    [DebuggerBrowsableAttribute("0")]
public IVersionInstance Not { get; }
    public abstract virtual IAccessInstance get_Access();
    public abstract virtual IGeneratedInstance get_Generated();
    public abstract virtual IVersionInstance get_Not();
    public abstract virtual void Column(string columnName);
    public abstract virtual void UnsavedValue(string unsavedValue);
    public abstract virtual void Length(int length);
    public abstract virtual void Precision(int precision);
    public abstract virtual void Scale(int scale);
    public abstract virtual void Nullable();
    public abstract virtual void Unique();
    public abstract virtual void UniqueKey(string keyColumns);
    public abstract virtual void CustomSqlType(string sqlType);
    public abstract virtual void Index(string index);
    public abstract virtual void Check(string constraint);
    public abstract virtual void Default(object value);
    public abstract virtual void CustomType();
    public abstract virtual void CustomType(Type type);
    public abstract virtual void CustomType(string type);
}
public class FluentNHibernate.Conventions.Instances.JoinedSubclassInstance : JoinedSubclassInspector {
    private SubclassMapping mapping;
    private bool nextBool;
    public IKeyInstance Key { get; }
    [DebuggerBrowsableAttribute("0")]
public IJoinedSubclassInstance Not { get; }
    public JoinedSubclassInstance(SubclassMapping mapping);
    public sealed virtual IKeyInstance get_Key();
    public sealed virtual IJoinedSubclassInstance get_Not();
    public sealed virtual void Abstract();
    public sealed virtual void Check(string constraint);
    public sealed virtual void DynamicInsert();
    public sealed virtual void DynamicUpdate();
    public sealed virtual void LazyLoad();
    public sealed virtual void Proxy(Type type);
    public sealed virtual void Proxy();
    public sealed virtual void Schema(string schema);
    public sealed virtual void SelectBeforeUpdate();
    public sealed virtual void Table(string tableName);
    public sealed virtual void Subselect(string subselect);
    public sealed virtual void Persister();
    public sealed virtual void Persister(Type type);
    public sealed virtual void Persister(string type);
    public sealed virtual void BatchSize(int batchSize);
}
public class FluentNHibernate.Conventions.Instances.KeyInstance : KeyInspector {
    private KeyMapping mapping;
    public IEnumerable`1<IColumnInstance> Columns { get; }
    public KeyInstance(KeyMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void ForeignKey(string constraint);
    public sealed virtual void PropertyRef(string property);
    public IEnumerable`1<IColumnInstance> get_Columns();
    public sealed virtual void CascadeOnDelete();
    [CompilerGeneratedAttribute]
private ColumnInstance <get_Columns>b__6_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Instances.KeyManyToOneInstance : KeyManyToOneInspector {
    private KeyManyToOneMapping mapping;
    private bool nextBool;
    public IAccessInstance Access { get; }
    public INotFoundInstance NotFound { get; }
    public IKeyManyToOneInstance Not { get; }
    public KeyManyToOneInstance(KeyManyToOneMapping mapping);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void ForeignKey(string name);
    public sealed virtual void Lazy();
    public sealed virtual INotFoundInstance get_NotFound();
    public sealed virtual IKeyManyToOneInstance get_Not();
    [CompilerGeneratedAttribute]
private void <get_Access>b__4_0(string value);
    [CompilerGeneratedAttribute]
private void <get_NotFound>b__8_0(string value);
}
public class FluentNHibernate.Conventions.Instances.KeyPropertyInstance : KeyPropertyInspector {
    private KeyPropertyMapping mapping;
    public IAccessInstance Access { get; }
    public KeyPropertyInstance(KeyPropertyMapping mapping);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void Length(int length);
    [CompilerGeneratedAttribute]
private void <get_Access>b__3_0(string value);
}
public class FluentNHibernate.Conventions.Instances.ManyToManyCollectionInstance : CollectionInstance {
    private CollectionMapping mapping;
    private IManyToManyInspector FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector.Relationship { get; }
    [DebuggerBrowsableAttribute("0")]
public IManyToManyCollectionInstance Not { get; }
    public IManyToManyCollectionInstance OtherSide { get; }
    public IManyToManyInstance Relationship { get; }
    public Type ChildType { get; }
    private IManyToManyCollectionInspector FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector.OtherSide { get; }
    public ManyToManyCollectionInstance(CollectionMapping mapping);
    private sealed virtual override IManyToManyInspector FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector.get_Relationship();
    public sealed virtual IManyToManyCollectionInstance get_Not();
    public sealed virtual IManyToManyCollectionInstance get_OtherSide();
    public sealed virtual IManyToManyInstance get_Relationship();
    public sealed virtual Type get_ChildType();
    private sealed virtual override IManyToManyCollectionInspector FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector.get_OtherSide();
}
public class FluentNHibernate.Conventions.Instances.ManyToManyInstance : ManyToManyInspector {
    private ManyToManyMapping mapping;
    public IEnumerable`1<IColumnInstance> Columns { get; }
    public ManyToManyInstance(ManyToManyMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual IEnumerable`1<IColumnInstance> get_Columns();
    public sealed virtual void CustomClass();
    public sealed virtual void CustomClass(Type type);
    public sealed virtual void ForeignKey(string constraint);
    public sealed virtual void Where(string where);
    public sealed virtual void OrderBy(string orderBy);
    [CompilerGeneratedAttribute]
private ColumnInstance <get_Columns>b__4_0(ColumnMapping x);
}
public class FluentNHibernate.Conventions.Instances.ManyToOneInstance : ManyToOneInspector {
    private ManyToOneMapping mapping;
    private bool nextBool;
    public IAccessInstance Access { get; }
    public ICascadeInstance Cascade { get; }
    public IFetchInstance Fetch { get; }
    [DebuggerBrowsableAttribute("0")]
public IManyToOneInstance Not { get; }
    public INotFoundInstance NotFound { get; }
    public ManyToOneInstance(ManyToOneMapping mapping);
    public sealed virtual void Column(string columnName);
    public sealed virtual void Formula(string formula);
    public sealed virtual void CustomClass();
    public sealed virtual void CustomClass(Type type);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual ICascadeInstance get_Cascade();
    public sealed virtual IFetchInstance get_Fetch();
    public sealed virtual IManyToOneInstance get_Not();
    public sealed virtual INotFoundInstance get_NotFound();
    public sealed virtual void Index(string index);
    public sealed virtual void Insert();
    public sealed virtual void OptimisticLock();
    public sealed virtual void LazyLoad();
    public sealed virtual void LazyLoad(Laziness laziness);
    public sealed virtual void Nullable();
    public sealed virtual void PropertyRef(string property);
    public sealed virtual void ReadOnly();
    public sealed virtual void Unique();
    public sealed virtual void UniqueKey(string key);
    public sealed virtual void Update();
    public sealed virtual void ForeignKey(string key);
    public sealed virtual void OverrideInferredClass(Type type);
    [CompilerGeneratedAttribute]
private void <get_Access>b__8_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Cascade>b__10_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Fetch>b__12_0(string value);
    [CompilerGeneratedAttribute]
private void <get_NotFound>b__16_0(string value);
}
public class FluentNHibernate.Conventions.Instances.NotFoundInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public NotFoundInstance(Action`1<string> setter);
    public sealed virtual void Ignore();
    public sealed virtual void Exception();
}
public class FluentNHibernate.Conventions.Instances.OneToManyCollectionInstance : CollectionInstance {
    private CollectionMapping mapping;
    private IOneToManyInspector FluentNHibernate.Conventions.Inspections.IOneToManyCollectionInspector.Relationship { get; }
    private IManyToOneInspector FluentNHibernate.Conventions.Inspections.IOneToManyCollectionInspector.OtherSide { get; }
    public IManyToOneInstance OtherSide { get; }
    [DebuggerBrowsableAttribute("0")]
public IOneToManyCollectionInstance Not { get; }
    public IOneToManyInstance Relationship { get; }
    public OneToManyCollectionInstance(CollectionMapping mapping);
    private sealed virtual override IOneToManyInspector FluentNHibernate.Conventions.Inspections.IOneToManyCollectionInspector.get_Relationship();
    private sealed virtual override IManyToOneInspector FluentNHibernate.Conventions.Inspections.IOneToManyCollectionInspector.get_OtherSide();
    public sealed virtual IManyToOneInstance get_OtherSide();
    public sealed virtual IOneToManyCollectionInstance get_Not();
    public sealed virtual IOneToManyInstance get_Relationship();
}
public class FluentNHibernate.Conventions.Instances.OneToManyInstance : OneToManyInspector {
    private OneToManyMapping mapping;
    public INotFoundInstance NotFound { get; }
    public OneToManyInstance(OneToManyMapping mapping);
    public sealed virtual INotFoundInstance get_NotFound();
    public sealed virtual void CustomClass();
    public sealed virtual void CustomClass(Type type);
    [CompilerGeneratedAttribute]
private void <get_NotFound>b__3_0(string value);
}
public class FluentNHibernate.Conventions.Instances.OneToOneInstance : OneToOneInspector {
    private OneToOneMapping mapping;
    private bool nextBool;
    public IAccessInstance Access { get; }
    public ICascadeInstance Cascade { get; }
    [DebuggerBrowsableAttribute("0")]
public IOneToOneInstance Not { get; }
    public IFetchInstance Fetch { get; }
    public OneToOneInstance(OneToOneMapping mapping);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual ICascadeInstance get_Cascade();
    public sealed virtual IOneToOneInstance get_Not();
    public sealed virtual IFetchInstance get_Fetch();
    public sealed virtual void Class();
    public sealed virtual void Class(Type type);
    public sealed virtual void Constrained();
    public sealed virtual void ForeignKey(string key);
    public sealed virtual void LazyLoad();
    public sealed virtual void LazyLoad(Laziness laziness);
    public sealed virtual void PropertyRef(string propertyName);
    public sealed virtual void OverrideInferredClass(Type type);
    [CompilerGeneratedAttribute]
private void <get_Access>b__4_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Cascade>b__6_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Fetch>b__10_0(string value);
}
public class FluentNHibernate.Conventions.Instances.OptimisticLockInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public OptimisticLockInstance(Action`1<string> setter);
    public sealed virtual void None();
    public sealed virtual void Version();
    public sealed virtual void Dirty();
    public sealed virtual void All();
}
public class FluentNHibernate.Conventions.Instances.PropertyInstance : PropertyInspector {
    private PropertyMapping mapping;
    private bool nextBool;
    private static int layer;
    public IAccessInstance Access { get; }
    [DebuggerBrowsableAttribute("0")]
public IPropertyInstance Not { get; }
    public IGeneratedInstance Generated { get; }
    public PropertyInstance(PropertyMapping mapping);
    public sealed virtual void Insert();
    public sealed virtual void Update();
    public sealed virtual void ReadOnly();
    public sealed virtual void Nullable();
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual void CustomType(TypeReference type);
    public sealed virtual void CustomType(TypeReference type, string columnPrefix);
    public sealed virtual void CustomType(string columnPrefix);
    public sealed virtual void CustomType();
    public sealed virtual void CustomType(Type type);
    public sealed virtual void CustomType(Type type, string columnPrefix);
    public sealed virtual void CustomType(string type);
    public sealed virtual void CustomType(string type, string columnPrefix);
    public sealed virtual void CustomSqlType(string sqlType);
    public sealed virtual void Precision(int precision);
    public sealed virtual void Scale(int scale);
    public sealed virtual void Default(string value);
    public sealed virtual void Unique();
    public sealed virtual void UniqueKey(string keyName);
    public sealed virtual IPropertyInstance get_Not();
    public sealed virtual void Column(string columnName);
    public sealed virtual void Formula(string formula);
    public sealed virtual IGeneratedInstance get_Generated();
    public sealed virtual void OptimisticLock();
    public sealed virtual void Length(int length);
    public sealed virtual void LazyLoad();
    public sealed virtual void Index(string value);
    public sealed virtual void Check(string constraint);
    private void AddColumnsForCompositeUserType(string columnPrefix);
    [CompilerGeneratedAttribute]
private void <get_Access>b__9_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Generated>b__29_0(string value);
}
public class FluentNHibernate.Conventions.Instances.SchemaActionInstance : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public SchemaActionInstance(Action`1<string> setter);
    public sealed virtual void None();
    public sealed virtual void All();
    public sealed virtual void Drop();
    public sealed virtual void Update();
    public sealed virtual void Validate();
    public sealed virtual void Export();
    public sealed virtual void Custom(string customValue);
}
public class FluentNHibernate.Conventions.Instances.SubclassInstance : SubclassInspector {
    private SubclassMapping mapping;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public ISubclassInstance Not { get; }
    public SubclassInstance(SubclassMapping mapping);
    public sealed virtual ISubclassInstance get_Not();
    public sealed virtual void DiscriminatorValue(object value);
    public sealed virtual void Abstract();
    public sealed virtual void DynamicInsert();
    public sealed virtual void DynamicUpdate();
    public sealed virtual void LazyLoad();
    public sealed virtual void Proxy(Type type);
    public sealed virtual void Proxy();
    public sealed virtual void SelectBeforeUpdate();
    public sealed virtual void Extends();
    public sealed virtual void Extends(Type type);
}
public class FluentNHibernate.Conventions.Instances.VersionInstance : VersionInspector {
    private VersionMapping mapping;
    private bool nextBool;
    private static int layer;
    public IAccessInstance Access { get; }
    public IGeneratedInstance Generated { get; }
    [DebuggerBrowsableAttribute("0")]
public IVersionInstance Not { get; }
    public VersionInstance(VersionMapping mapping);
    public sealed virtual IAccessInstance get_Access();
    public sealed virtual IGeneratedInstance get_Generated();
    public sealed virtual IVersionInstance get_Not();
    public sealed virtual void Column(string columnName);
    public sealed virtual void UnsavedValue(string unsavedValue);
    public sealed virtual void Length(int length);
    public sealed virtual void Precision(int precision);
    public sealed virtual void Scale(int scale);
    public sealed virtual void Nullable();
    public sealed virtual void Unique();
    public sealed virtual void UniqueKey(string columns);
    public sealed virtual void CustomSqlType(string sqlType);
    public sealed virtual void Index(string index);
    public sealed virtual void Check(string constraint);
    public sealed virtual void Default(object value);
    public sealed virtual void CustomType(string type);
    public sealed virtual void CustomType(Type type);
    public sealed virtual void CustomType();
    [CompilerGeneratedAttribute]
private void <get_Access>b__5_0(string value);
    [CompilerGeneratedAttribute]
private void <get_Generated>b__7_0(string value);
}
public interface FluentNHibernate.Conventions.IPropertyConvention {
}
public interface FluentNHibernate.Conventions.IPropertyConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IReferenceConvention {
}
public interface FluentNHibernate.Conventions.IReferenceConventionAcceptance {
}
[ObsoleteAttribute("Use ICollectionConvention with an acceptance criteria")]
public interface FluentNHibernate.Conventions.ISetConvention {
}
[ObsoleteAttribute("Use ICollectionConventionAcceptance")]
public interface FluentNHibernate.Conventions.ISetConventionAcceptance {
}
public interface FluentNHibernate.Conventions.ISubclassConvention {
}
public interface FluentNHibernate.Conventions.ISubclassConventionAcceptance {
}
public interface FluentNHibernate.Conventions.IUserTypeConvention {
}
public interface FluentNHibernate.Conventions.IVersionConvention {
}
public interface FluentNHibernate.Conventions.IVersionConventionAcceptance {
}
public abstract class FluentNHibernate.Conventions.ManyToManyTableNameConvention : object {
    public sealed virtual void Apply(IManyToManyCollectionInstance instance);
    protected abstract virtual string GetBiDirectionalTableName(IManyToManyCollectionInspector collection, IManyToManyCollectionInspector otherSide);
    protected abstract virtual string GetUniDirectionalTableName(IManyToManyCollectionInspector collection);
}
[AttributeUsageAttribute("4")]
public class FluentNHibernate.Conventions.MultipleAttribute : Attribute {
}
[ExtensionAttribute]
public static class FluentNHibernate.Conventions.ObjectExtensionsForConventions : object {
    [ExtensionAttribute]
public static bool IsAny(T target, T[] possibleValues);
    [ExtensionAttribute]
public static bool IsNotAny(T target, T[] possibleValues);
}
public class FluentNHibernate.Conventions.ProxyConvention : object {
    private Func`2<Type, Type> mapPersistentTypeToProxyInterfaceType;
    private Func`2<Type, Type> mapProxyInterfaceTypeToPersistentType;
    public ProxyConvention(Func`2<Type, Type> mapPersistentTypeToProxyInterfaceType, Func`2<Type, Type> mapProxyInterfaceTypeToPersistentType);
    public sealed virtual void Apply(IClassInstance instance);
    public sealed virtual void Apply(ISubclassInstance instance);
    public sealed virtual void Apply(IManyToOneInstance instance);
    public sealed virtual void Apply(ICollectionInstance instance);
    public sealed virtual void Apply(IOneToOneInstance instance);
    private Type GetProxyType(Type persistentType);
    private Type GetPersistentType(Type proxyType);
}
public abstract class FluentNHibernate.Conventions.UserTypeConvention`1 : object {
    public virtual void Accept(IAcceptanceCriteria`1<IPropertyInspector> criteria);
    public virtual void Apply(IPropertyInstance instance);
}
[ObsoleteAttribute("Please do not use this class and implement your own as this base class is problematic because it does not consider transient entities and a requirement to have immutable GetHashCode().")]
public abstract class FluentNHibernate.Data.Entity : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public long Id { get; public set; }
    [CompilerGeneratedAttribute]
public virtual long get_Id();
    [CompilerGeneratedAttribute]
public virtual void set_Id(long value);
    public virtual bool Equals(Entity obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Entity left, Entity right);
    public static bool op_Inequality(Entity left, Entity right);
}
public class FluentNHibernate.Diagnostics.AutomappingType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
}
public class FluentNHibernate.Diagnostics.ConsoleOutputListener : object {
    [CompilerGeneratedAttribute]
private IDiagnosticResultsFormatter <formatter>P;
    public ConsoleOutputListener(IDiagnosticResultsFormatter formatter);
    public sealed virtual void Receive(DiagnosticResults results);
}
public class FluentNHibernate.Diagnostics.DefaultDiagnosticLogger : object {
    [CompilerGeneratedAttribute]
private IDiagnosticMessageDispatcher <dispatcher>P;
    private List`1<ScannedSource> scannedSources;
    private List`1<Type> classMaps;
    private List`1<Type> conventions;
    private List`1<SkippedAutomappingType> automappingSkippedTypes;
    private List`1<Type> automappingCandidateTypes;
    private List`1<AutomappingType> automappingTypes;
    private bool isDirty;
    public DefaultDiagnosticLogger(IDiagnosticMessageDispatcher dispatcher);
    public sealed virtual void Flush();
    private DiagnosticResults BuildResults();
    public sealed virtual void FluentMappingDiscovered(Type type);
    public sealed virtual void ConventionDiscovered(Type type);
    public sealed virtual void LoadedFluentMappingsFromSource(ITypeSource source);
    public sealed virtual void LoadedConventionsFromSource(ITypeSource source);
    public sealed virtual void AutomappingSkippedType(Type type, string reason);
    public sealed virtual void AutomappingCandidateTypes(IEnumerable`1<Type> types);
    public sealed virtual void BeginAutomappingType(Type type);
}
public class FluentNHibernate.Diagnostics.DefaultDiagnosticMessageDispatcher : object {
    private List`1<IDiagnosticListener> listeners;
    public sealed virtual void RegisterListener(IDiagnosticListener listener);
    public sealed virtual void Publish(DiagnosticResults results);
}
public class FluentNHibernate.Diagnostics.DefaultOutputFormatter : object {
    public sealed virtual string Format(DiagnosticResults results);
    private void OutputAutomappings(StringBuilder sb, DiagnosticResults results);
    private void OutputConventions(StringBuilder sb, DiagnosticResults results);
    private void OutputFluentMappings(StringBuilder sb, DiagnosticResults results);
    private void Table(StringBuilder sb, IEnumerable`1[] columns);
    private void List(StringBuilder sb, IEnumerable`1<string> items);
    private void Title(StringBuilder sb, string title);
}
public class FluentNHibernate.Diagnostics.DiagnosticResults : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <FluentMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ScannedSource> <ScannedSources>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SkippedAutomappingType> <AutomappingSkippedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <AutomappingCandidateTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<AutomappingType> <AutomappedTypes>k__BackingField;
    public IEnumerable`1<Type> FluentMappings { get; }
    public IEnumerable`1<ScannedSource> ScannedSources { get; }
    public IEnumerable`1<Type> Conventions { get; }
    public IEnumerable`1<SkippedAutomappingType> AutomappingSkippedTypes { get; }
    public IEnumerable`1<Type> AutomappingCandidateTypes { get; }
    public IEnumerable`1<AutomappingType> AutomappedTypes { get; }
    public DiagnosticResults(IEnumerable`1<ScannedSource> scannedSources, IEnumerable`1<Type> fluentMappings, IEnumerable`1<Type> conventions, IEnumerable`1<SkippedAutomappingType> automappingSkippedTypes, IEnumerable`1<Type> automappingCandidateTypes, IEnumerable`1<AutomappingType> automappingTypes);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_FluentMappings();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ScannedSource> get_ScannedSources();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Conventions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SkippedAutomappingType> get_AutomappingSkippedTypes();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_AutomappingCandidateTypes();
    [CompilerGeneratedAttribute]
public IEnumerable`1<AutomappingType> get_AutomappedTypes();
}
public class FluentNHibernate.Diagnostics.DiagnosticsConfiguration : object {
    [CompilerGeneratedAttribute]
private IDiagnosticMessageDispatcher <dispatcher>P;
    [CompilerGeneratedAttribute]
private Action`1<IDiagnosticLogger> <setLogger>P;
    public DiagnosticsConfiguration(IDiagnosticMessageDispatcher dispatcher, Action`1<IDiagnosticLogger> setLogger);
    public DiagnosticsConfiguration Enable(bool enable);
    public DiagnosticsConfiguration Enable();
    public DiagnosticsConfiguration Disable();
    public DiagnosticsConfiguration RegisterListener(IDiagnosticListener listener);
    public DiagnosticsConfiguration OutputToConsole();
    public DiagnosticsConfiguration OutputToConsole(IDiagnosticResultsFormatter formatter);
    public DiagnosticsConfiguration OutputToFile(string path);
    public DiagnosticsConfiguration OutputToFile(IDiagnosticResultsFormatter formatter, string path);
}
public class FluentNHibernate.Diagnostics.FileOutputListener : object {
    [CompilerGeneratedAttribute]
private IDiagnosticResultsFormatter <formatter>P;
    [CompilerGeneratedAttribute]
private string <outputPath>P;
    public FileOutputListener(IDiagnosticResultsFormatter formatter, string outputPath);
    public FileOutputListener(string outputPath);
    public sealed virtual void Receive(DiagnosticResults results);
}
public interface FluentNHibernate.Diagnostics.IDiagnosticListener {
    public abstract virtual void Receive(DiagnosticResults results);
}
public interface FluentNHibernate.Diagnostics.IDiagnosticLogger {
    public abstract virtual void Flush();
    public abstract virtual void FluentMappingDiscovered(Type type);
    public abstract virtual void ConventionDiscovered(Type type);
    public abstract virtual void LoadedFluentMappingsFromSource(ITypeSource source);
    public abstract virtual void LoadedConventionsFromSource(ITypeSource source);
    public abstract virtual void AutomappingSkippedType(Type type, string reason);
    public abstract virtual void AutomappingCandidateTypes(IEnumerable`1<Type> types);
    public abstract virtual void BeginAutomappingType(Type type);
}
public interface FluentNHibernate.Diagnostics.IDiagnosticMessageDispatcher {
    public abstract virtual void RegisterListener(IDiagnosticListener listener);
    public abstract virtual void Publish(DiagnosticResults results);
}
public interface FluentNHibernate.Diagnostics.IDiagnosticResultsFormatter {
    public abstract virtual string Format(DiagnosticResults results);
}
public class FluentNHibernate.Diagnostics.NullDiagnosticsLogger : object {
    public sealed virtual void Flush();
    public sealed virtual void FluentMappingDiscovered(Type type);
    public sealed virtual void ConventionDiscovered(Type type);
    public sealed virtual void LoadedFluentMappingsFromSource(ITypeSource source);
    public sealed virtual void LoadedConventionsFromSource(ITypeSource source);
    public sealed virtual void AutomappingSkippedType(Type type, string reason);
    public sealed virtual void AutomappingCandidateTypes(IEnumerable`1<Type> types);
    public sealed virtual void BeginAutomappingType(Type type);
}
public class FluentNHibernate.Diagnostics.ScannedSource : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ScanPhase <Phase>k__BackingField;
    public string Identifier { get; public set; }
    public ScanPhase Phase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public ScanPhase get_Phase();
    [CompilerGeneratedAttribute]
public void set_Phase(ScanPhase value);
}
public enum FluentNHibernate.Diagnostics.ScanPhase : Enum {
    public int value__;
    public static ScanPhase FluentMappings;
    public static ScanPhase Conventions;
}
public class FluentNHibernate.Diagnostics.SkippedAutomappingType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public Type Type { get; public set; }
    public string Reason { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool Equals(SkippedAutomappingType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class FluentNHibernate.Diagnostics.StringLambdaOutputListener : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <raiseMessage>P;
    private IDiagnosticResultsFormatter outputFormatter;
    public StringLambdaOutputListener(Action`1<string> raiseMessage);
    public sealed virtual void Receive(DiagnosticResults results);
    public void SetFormatter(IDiagnosticResultsFormatter formatter);
}
public class FluentNHibernate.Dialects.MsSQLiteDialect : SQLiteDialect {
    public virtual IDataBaseSchema GetDataBaseSchema(DbConnection connection);
}
public class FluentNHibernate.Dialects.Schema.MsSQLiteDataBaseMetaData : SQLiteDataBaseMetaData {
    public bool IncludeDataTypesInReservedWords { get; }
    public MsSQLiteDataBaseMetaData(DbConnection connection, Dialect dialect);
    public virtual bool get_IncludeDataTypesInReservedWords();
}
public class FluentNHibernate.Driver.MsSQLiteDriver : ReflectionBasedDriver {
    public bool UseNamedPrefixInSql { get; }
    public bool UseNamedPrefixInParameter { get; }
    public string NamedPrefix { get; }
    public bool SupportsMultipleOpenReaders { get; }
    public bool SupportsMultipleQueries { get; }
    public bool SupportsNullEnlistment { get; }
    public bool HasDelayedDistributedTransactionCompletion { get; }
    public virtual DbConnection CreateConnection();
    private static void Connection_StateChange(object sender, StateChangeEventArgs e);
    public virtual IResultSetsCommand GetResultSetsCommand(ISessionImplementor session);
    public virtual bool get_UseNamedPrefixInSql();
    public virtual bool get_UseNamedPrefixInParameter();
    public virtual string get_NamedPrefix();
    public virtual bool get_SupportsMultipleOpenReaders();
    public virtual bool get_SupportsMultipleQueries();
    public virtual bool get_SupportsNullEnlistment();
    public virtual bool get_HasDelayedDistributedTransactionCompletion();
}
internal class FluentNHibernate.DummyMethodInfo : MethodInfo {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public DummyMethodInfo(string name, Type type);
    [CompilerGeneratedAttribute]
public virtual Type get_ReturnType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
public class FluentNHibernate.DummyPropertyInfo : PropertyInfo {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    public Module Module { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public DummyPropertyInfo(string name, Type type);
    public virtual Module get_Module();
    public virtual int get_MetadataToken();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
internal class FluentNHibernate.FieldMember : Member {
    [CompilerGeneratedAttribute]
private FieldInfo <member>P;
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanWrite { get; }
    public MemberInfo MemberInfo { get; }
    public Type DeclaringType { get; }
    public bool HasIndexParameters { get; }
    public bool IsMethod { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsAutoProperty { get; }
    public bool IsPrivate { get; }
    public bool IsProtected { get; }
    public bool IsPublic { get; }
    public bool IsInternal { get; }
    public FieldMember(FieldInfo member);
    public virtual void SetValue(object target, object value);
    public virtual object GetValue(object target);
    public virtual bool TryGetBackingField(Member& backingField);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual bool get_CanWrite();
    public virtual MemberInfo get_MemberInfo();
    public virtual Type get_DeclaringType();
    public virtual bool get_HasIndexParameters();
    public virtual bool get_IsMethod();
    public virtual bool get_IsField();
    public virtual bool get_IsProperty();
    public virtual bool get_IsAutoProperty();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsProtected();
    public virtual bool get_IsPublic();
    public virtual bool get_IsInternal();
    public virtual string ToString();
}
public interface FluentNHibernate.IMappingProvider {
    public abstract virtual ClassMapping GetClassMapping();
    public abstract virtual HibernateMapping GetHibernateMapping();
    public abstract virtual IEnumerable`1<Member> GetIgnoredProperties();
}
public class FluentNHibernate.Infrastructure.Container : object {
    private Dictionary`2<Type, Func`2<Container, object>> registeredTypes;
    public void Register(Func`2<Container, object> instantiateFunc);
    public object Resolve(Type type);
    public T Resolve();
}
public static class FluentNHibernate.Infrastructure.NetStandardSerialization : object {
}
public class FluentNHibernate.Infrastructure.ResolveException : Exception {
    public ResolveException(Type type);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected ResolveException(SerializationInfo info, StreamingContext context);
}
public static class FluentNHibernate.Infrastructure.Serialization : object {
}
public interface FluentNHibernate.ISessionSource {
    public Configuration Configuration { get; }
    public ISessionFactory SessionFactory { get; }
    public abstract virtual ISession CreateSession();
    public abstract virtual void BuildSchema();
    public abstract virtual Configuration get_Configuration();
    public abstract virtual ISessionFactory get_SessionFactory();
}
public interface FluentNHibernate.ITypeSource {
    public abstract virtual IEnumerable`1<Type> GetTypes();
    public abstract virtual void LogSource(IDiagnosticLogger logger);
    public abstract virtual string GetIdentifier();
}
public class FluentNHibernate.Mapping.Access : object {
    public static Access Unset;
    public static Access Field;
    public static Access BackField;
    public static Access Property;
    public static Access ReadOnlyProperty;
    public static Access NoOp;
    public static Access None;
    private string value;
    private Access(string value);
    private Access(string value, NamingStrategy strategy);
    private static Access();
    public static Access CamelCaseField();
    public static Access CamelCaseField(CamelCasePrefix prefix);
    public static Access LowerCaseField();
    public static Access LowerCaseField(LowerCasePrefix prefix);
    public static Access PascalCaseField(PascalCasePrefix prefix);
    public static Access ReadOnlyPropertyThroughCamelCaseField();
    public static Access ReadOnlyPropertyThroughCamelCaseField(CamelCasePrefix prefix);
    public static Access ReadOnlyPropertyThroughLowerCaseField();
    public static Access ReadOnlyPropertyThroughLowerCaseField(LowerCasePrefix prefix);
    public static Access ReadOnlyPropertyThroughPascalCaseField(PascalCasePrefix prefix);
    public static Access ReadOnlyPropertyWithField(NamingStrategy namingStrategy);
    public static Access Using(string value);
    public static Access Using(Type accessorType);
    public static Access Using();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Access other);
    public virtual int GetHashCode();
    public static bool op_Equality(Access x, Access y);
    public static bool op_Inequality(Access x, Access y);
    public virtual string ToString();
    public static Access FromString(string value);
}
public class FluentNHibernate.Mapping.AccessStrategyBuilder : object {
    private static string InvalidPrefixCamelCaseFieldM;
    private static string InvalidPrefixCamelCaseFieldMUnderscore;
    private static string InvalidPrefixLowerCaseFieldM;
    private static string InvalidPrefixLowerCaseFieldMUnderscore;
    private static string InvalidPrefixPascalCaseFieldNone;
    internal Action`1<string> setValue;
    protected AccessStrategyBuilder(Action`1<string> setter);
    public void Property();
    public void Field();
    public void BackingField();
    public void ReadOnly();
    public void CamelCaseField();
    public void CamelCaseField(Prefix prefix);
    public void LowerCaseField();
    public void LowerCaseField(Prefix prefix);
    public void PascalCaseField(Prefix prefix);
    public void ReadOnlyPropertyThroughCamelCaseField();
    public void ReadOnlyPropertyThroughCamelCaseField(Prefix prefix);
    public void ReadOnlyPropertyThroughLowerCaseField();
    public void ReadOnlyPropertyThroughLowerCaseField(Prefix prefix);
    public void ReadOnlyPropertyThroughPascalCaseField(Prefix prefix);
    public void Using(string propertyAccessorAssemblyQualifiedClassName);
    public void Using(Type propertyAccessorClassType);
    public void Using();
    public void NoOp();
    public void None();
}
public class FluentNHibernate.Mapping.AccessStrategyBuilder`1 : AccessStrategyBuilder {
    [CompilerGeneratedAttribute]
private T <parent>P;
    public AccessStrategyBuilder`1(T parent, Action`1<string> setter);
    public T Property();
    public T Field();
    public T BackingField();
    public T ReadOnly();
    public T CamelCaseField();
    public T CamelCaseField(Prefix prefix);
    public T LowerCaseField();
    public T LowerCaseField(Prefix prefix);
    public T PascalCaseField(Prefix prefix);
    public T ReadOnlyPropertyThroughCamelCaseField();
    public T ReadOnlyPropertyThroughCamelCaseField(Prefix prefix);
    public T ReadOnlyPropertyThroughLowerCaseField();
    public T ReadOnlyPropertyThroughLowerCaseField(Prefix prefix);
    public T ReadOnlyPropertyThroughPascalCaseField(Prefix prefix);
    public T Using(string propertyAccessorAssemblyQualifiedClassName);
    public T Using(Type propertyAccessorClassType);
    public T Using();
    public T NoOp();
    public T None();
}
public class FluentNHibernate.Mapping.AnyPart`1 : object {
    private AttributeStore attributes;
    private Type entity;
    private Member member;
    private List`1<string> typeColumns;
    private List`1<string> identifierColumns;
    private List`1<MetaValueMapping> metaValues;
    private bool nextBool;
    private bool idTypeSet;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<AnyPart`1<T>> <Access>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeExpression`1<AnyPart`1<T>> <Cascade>k__BackingField;
    public AccessStrategyBuilder`1<AnyPart`1<T>> Access { get; }
    public CascadeExpression`1<AnyPart`1<T>> Cascade { get; }
    [DebuggerBrowsableAttribute("0")]
public AnyPart`1<T> Not { get; }
    public AnyPart`1(Type entity, Member member);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<AnyPart`1<T>> get_Access();
    [CompilerGeneratedAttribute]
public CascadeExpression`1<AnyPart`1<T>> get_Cascade();
    public AnyPart`1<T> IdentityType(Expression`1<Func`2<T, object>> expression);
    public AnyPart`1<T> IdentityType();
    public AnyPart`1<T> IdentityType(Type type);
    public AnyPart`1<T> EntityTypeColumn(string columnName);
    public AnyPart`1<T> EntityIdentifierColumn(string columnName);
    public AnyPart`1<T> AddMetaValue(string valueMap);
    public AnyPart`1<T> AddMetaValue(Type class, string valueMap);
    public AnyPart`1<T> Insert();
    public AnyPart`1<T> Update();
    public AnyPart`1<T> ReadOnly();
    public AnyPart`1<T> LazyLoad();
    public AnyPart`1<T> OptimisticLock();
    public AnyPart`1<T> get_Not();
    private sealed virtual override AnyMapping FluentNHibernate.Mapping.Providers.IAnyMappingProvider.GetAnyMapping();
    public AnyPart`1<T> MetaType();
    public AnyPart`1<T> MetaType(string metaType);
    public AnyPart`1<T> MetaType(Type metaType);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(string value);
}
public class FluentNHibernate.Mapping.Attributes : Dictionary`2<string, string> {
}
public class FluentNHibernate.Mapping.CachePart : object {
    [CompilerGeneratedAttribute]
private Type <entityType>P;
    private AttributeStore attributes;
    internal bool IsDirty { get; }
    public CachePart(Type entityType);
    public CachePart ReadWrite();
    public CachePart NonStrictReadWrite();
    public CachePart ReadOnly();
    public CachePart Transactional();
    public CachePart Never();
    public CachePart CustomUsage(string custom);
    public CachePart Region(string name);
    public CachePart IncludeAll();
    public CachePart IncludeNonLazy();
    public CachePart CustomInclude(string custom);
    internal bool get_IsDirty();
    private sealed virtual override CacheMapping FluentNHibernate.Mapping.Providers.ICacheMappingProvider.GetCacheMapping();
}
public class FluentNHibernate.Mapping.CascadeExpression`1 : object {
    private protected TParent parent;
    private protected Action`1<string> setter;
    public CascadeExpression`1(TParent parent, Action`1<string> setter);
    public TParent All();
    public TParent None();
    public TParent SaveUpdate();
    public TParent Delete();
    public TParent AllDeleteOrphan();
    public TParent Merge();
    public TParent Replicate();
    public TParent Refresh();
    [ObsoleteAttribute("Please use DeleteOrphan instead")]
public TParent DeleteOrphans();
    public TParent DeleteOrphan();
    public TParent Evict();
    public TParent Lock();
    public TParent Persist();
}
public class FluentNHibernate.Mapping.CheckTypeExpression`1 : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    private TParent parent;
    public CheckTypeExpression`1(TParent parent, Action`1<string> setter);
    public void None();
    public void RowCount();
}
public abstract class FluentNHibernate.Mapping.ClasslikeMapBase`1 : object {
    [CompilerGeneratedAttribute]
private MappingProviderStore <providers>P;
    internal IEnumerable`1<IPropertyMappingProvider> Properties { get; }
    internal IEnumerable`1<IComponentMappingProvider> Components { get; }
    internal Type EntityType { get; }
    protected ClasslikeMapBase`1(MappingProviderStore providers);
    internal virtual void OnMemberMapped(Member member);
    public PropertyPart Map(Expression`1<Func`2<T, object>> memberExpression);
    public PropertyPart Map(Expression`1<Func`2<T, object>> memberExpression, string columnName);
    private PropertyPart Map(Member member, string columnName);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, TOther>> memberExpression);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, TOther>> memberExpression, string columnName);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, object>> memberExpression);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, object>> memberExpression, string columnName);
    private ManyToOnePart`1<TOther> References(Member member, string columnName);
    public AnyPart`1<TOther> ReferencesAny(Expression`1<Func`2<T, TOther>> memberExpression);
    private AnyPart`1<TOther> ReferencesAny(Member member);
    public OneToOnePart`1<TOther> HasOne(Expression`1<Func`2<T, object>> memberExpression);
    public OneToOnePart`1<TOther> HasOne(Expression`1<Func`2<T, TOther>> memberExpression);
    private OneToOnePart`1<TOther> HasOne(Member member);
    public DynamicComponentPart`1<IDictionary> DynamicComponent(Expression`1<Func`2<T, IDictionary>> memberExpression, Action`1<DynamicComponentPart`1<IDictionary>> dynamicComponentAction);
    private DynamicComponentPart`1<IDictionary> DynamicComponent(Member member, Action`1<DynamicComponentPart`1<IDictionary>> dynamicComponentAction);
    public virtual ReferenceComponentPart`1<TComponent> Component(Expression`1<Func`2<T, TComponent>> member);
    private ReferenceComponentPart`1<TComponent> Component(Member member);
    public ComponentPart`1<TComponent> Component(Expression`1<Func`2<T, TComponent>> expression, Action`1<ComponentPart`1<TComponent>> action);
    public ComponentPart`1<TComponent> Component(Expression`1<Func`2<T, object>> expression, Action`1<ComponentPart`1<TComponent>> action);
    private ComponentPart`1<TComponent> Component(Member member, Action`1<ComponentPart`1<TComponent>> action);
    public void Component(IComponentMappingProvider componentProvider);
    private OneToManyPart`1<TChild> MapHasMany(Expression`1<Func`2<T, TReturn>> expression);
    private OneToManyPart`1<TChild> HasMany(Member member);
    public OneToManyPart`1<TChild> HasMany(Expression`1<Func`2<T, IEnumerable`1<TChild>>> memberExpression);
    public OneToManyPart`1<TChild> HasMany(Expression`1<Func`2<T, IDictionary`2<TKey, TChild>>> memberExpression);
    public OneToManyPart`1<TChild> HasMany(Expression`1<Func`2<T, object>> memberExpression);
    private ManyToManyPart`1<TChild> MapHasManyToMany(Expression`1<Func`2<T, TReturn>> expression);
    private ManyToManyPart`1<TChild> HasManyToMany(Member member);
    public ManyToManyPart`1<TChild> HasManyToMany(Expression`1<Func`2<T, IEnumerable`1<TChild>>> memberExpression);
    public ManyToManyPart`1<TChild> HasManyToMany(Expression`1<Func`2<T, object>> memberExpression);
    public StoredProcedurePart SqlInsert(string innerText);
    public StoredProcedurePart SqlUpdate(string innerText);
    public StoredProcedurePart SqlDelete(string innerText);
    public StoredProcedurePart SqlDeleteAll(string innerText);
    protected StoredProcedurePart StoredProcedure(string element, string innerText);
    internal IEnumerable`1<IPropertyMappingProvider> get_Properties();
    internal IEnumerable`1<IComponentMappingProvider> get_Components();
    internal Type get_EntityType();
}
public class FluentNHibernate.Mapping.ClassMap`1 : ClasslikeMapBase`1<T> {
    protected AttributeStore attributes;
    private MappingProviderStore providers;
    private List`1<ImportPart> imports;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private CachePart <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private HibernateMappingPart <HibernateMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private OptimisticLockBuilder`1<ClassMap`1<T>> <OptimisticLock>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismBuilder`1<ClassMap`1<T>> <Polymorphism>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaActionBuilder`1<ClassMap`1<T>> <SchemaAction>k__BackingField;
    public CachePart Cache { get; }
    public HibernateMappingPart HibernateMapping { get; }
    [DebuggerBrowsableAttribute("0")]
public ClassMap`1<T> Not { get; }
    public OptimisticLockBuilder`1<ClassMap`1<T>> OptimisticLock { get; }
    public PolymorphismBuilder`1<ClassMap`1<T>> Polymorphism { get; }
    public SchemaActionBuilder`1<ClassMap`1<T>> SchemaAction { get; }
    protected ClassMap`1(AttributeStore attributes, MappingProviderStore providers);
    [CompilerGeneratedAttribute]
public CachePart get_Cache();
    [CompilerGeneratedAttribute]
public HibernateMappingPart get_HibernateMapping();
    public IdentityPart Id(Expression`1<Func`2<T, object>> memberExpression);
    public IdentityPart Id(Expression`1<Func`2<T, object>> memberExpression, string column);
    public IdentityPart Id();
    public IdentityPart Id();
    public IdentityPart Id(string column);
    public NaturalIdPart`1<T> NaturalId();
    public CompositeIdentityPart`1<T> CompositeId();
    public CompositeIdentityPart`1<TId> CompositeId(Expression`1<Func`2<T, TId>> memberExpression);
    public VersionPart Version(Expression`1<Func`2<T, object>> memberExpression);
    private VersionPart Version(Member member);
    public DiscriminatorPart DiscriminateSubClassesOnColumn(string columnName, TDiscriminator baseClassDiscriminator);
    public DiscriminatorPart DiscriminateSubClassesOnColumn(string columnName);
    public DiscriminatorPart DiscriminateSubClassesOnColumn(string columnName);
    public void UseUnionSubclassForInheritanceMapping();
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public void JoinedSubClass(string keyColumn, Action`1<JoinedSubClassPart`1<TSubclass>> action);
    public void Schema(string schema);
    public void Table(string tableName);
    public ClassMap`1<T> get_Not();
    public void LazyLoad();
    public void Join(string tableName, Action`1<JoinPart`1<T>> action);
    public ImportPart ImportType();
    public void ReadOnly();
    public void DynamicUpdate();
    public void DynamicInsert();
    public ClassMap`1<T> BatchSize(int size);
    [CompilerGeneratedAttribute]
public OptimisticLockBuilder`1<ClassMap`1<T>> get_OptimisticLock();
    [CompilerGeneratedAttribute]
public PolymorphismBuilder`1<ClassMap`1<T>> get_Polymorphism();
    [CompilerGeneratedAttribute]
public SchemaActionBuilder`1<ClassMap`1<T>> get_SchemaAction();
    public void CheckConstraint(string constraint);
    public void Persister();
    private void Persister(Type type);
    public void Persister(string type);
    public void Proxy();
    public void Proxy(Type type);
    public void Proxy(string type);
    public void SelectBeforeUpdate();
    public void Where(string where);
    public void Subselect(string subselectSql);
    public void EntityName(string entityName);
    public ClassMap`1<T> ApplyFilter(string name, string condition);
    public ClassMap`1<T> ApplyFilter(string name);
    public ClassMap`1<T> ApplyFilter(string condition);
    public ClassMap`1<T> ApplyFilter();
    public TuplizerPart Tuplizer(TuplizerMode mode, Type tuplizerType);
    private sealed virtual override ClassMapping FluentNHibernate.IMappingProvider.GetClassMapping();
    private sealed virtual override HibernateMapping FluentNHibernate.IMappingProvider.GetHibernateMapping();
    private string GetDefaultTableName();
    private sealed virtual override IEnumerable`1<Member> FluentNHibernate.IMappingProvider.GetIgnoredProperties();
}
public class FluentNHibernate.Mapping.CollectionCascadeExpression`1 : CascadeExpression`1<TParent> {
    public CollectionCascadeExpression`1(TParent parent, Action`1<string> setter);
    public TParent AllDeleteOrphan();
    public TParent DeleteOrphan();
}
public static class FluentNHibernate.Mapping.CollectionTypeResolver : object {
    public static Collection Resolve(Member member);
    private static bool IsSet(Member member);
    private static bool IsEnumerable(Member member);
}
public class FluentNHibernate.Mapping.ColumnMappingCollection`1 : object {
    [CompilerGeneratedAttribute]
private TParent <parent>P;
    private List`1<ColumnMapping> columns;
    public int Count { get; }
    public ColumnMappingCollection`1(TParent parent);
    public TParent Add(string name);
    public TParent Add(String[] names);
    public TParent Add(string columnName, Action`1<ColumnPart> customColumnMapping);
    public TParent Add(ColumnMapping column);
    public TParent Clear();
    public int get_Count();
    public sealed virtual IEnumerator`1<ColumnMapping> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class FluentNHibernate.Mapping.ColumnPart : object {
    [CompilerGeneratedAttribute]
private ColumnMapping <columnMapping>P;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public ColumnPart Not { get; }
    public ColumnPart(ColumnMapping columnMapping);
    public ColumnPart get_Not();
    public ColumnPart Name(string columnName);
    public ColumnPart Length(int length);
    public ColumnPart Nullable();
    public ColumnPart Unique();
    public ColumnPart UniqueKey(string key);
    public ColumnPart SqlType(string sqlType);
    public ColumnPart Index(string index);
}
public class FluentNHibernate.Mapping.ComponentMap`1 : ComponentPartBase`2<T, ComponentMap`1<T>> {
    private AttributeStore attributes;
    private Type FluentNHibernate.Mapping.Providers.IExternalComponentMappingProvider.Type { get; }
    internal ComponentMap`1(AttributeStore attributes);
    public virtual ReferenceComponentPart`1<TComponent> Component(Expression`1<Func`2<T, TComponent>> member);
    protected virtual ComponentMapping CreateComponentMappingRoot(AttributeStore store);
    private sealed virtual override ExternalComponentMapping FluentNHibernate.Mapping.Providers.IExternalComponentMappingProvider.GetComponentMapping();
    private sealed virtual override Type FluentNHibernate.Mapping.Providers.IExternalComponentMappingProvider.get_Type();
}
public class FluentNHibernate.Mapping.ComponentPart`1 : ComponentPartBase`2<T, ComponentPart`1<T>> {
    private Type entity;
    private AttributeStore attributes;
    private string columnPrefix;
    public ComponentPart`1(Type entity, Member property);
    private ComponentPart`1(Type entity, Member property, AttributeStore attributes);
    public void ColumnPrefix(string prefix);
    public ComponentPart`1<T> LazyLoad();
    private sealed virtual override IComponentMapping FluentNHibernate.Mapping.Providers.IComponentMappingProvider.GetComponentMapping();
    protected virtual ComponentMapping CreateComponentMappingRoot(AttributeStore store);
}
public abstract class FluentNHibernate.Mapping.ComponentPartBase`2 : ClasslikeMapBase`1<TEntity> {
    protected Member member;
    private MappingProviderStore providers;
    private AttributeStore attributes;
    protected bool nextBool;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<TBuilder> <Access>k__BackingField;
    public AccessStrategyBuilder`1<TBuilder> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public TBuilder Not { get; }
    protected ComponentPartBase`2(AttributeStore attributes, Member member);
    protected ComponentPartBase`2(AttributeStore attributes, Member member, MappingProviderStore providers);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<TBuilder> get_Access();
    public TBuilder ParentReference(Expression`1<Func`2<TEntity, object>> expression);
    public TBuilder ParentReference(Expression`1<Func`2<TEntity, object>> expression, Action`1<ParentPropertyPart> customMapping);
    private TBuilder ParentReference(Member property, Action`1<ParentPropertyPart> customMapping);
    public TBuilder get_Not();
    public TBuilder ReadOnly();
    public TBuilder Insert();
    public TBuilder Update();
    public TBuilder Unique();
    public TBuilder OptimisticLock();
    protected abstract virtual ComponentMapping CreateComponentMappingRoot(AttributeStore store);
    protected ComponentMapping CreateComponentMapping();
}
public class FluentNHibernate.Mapping.CompositeElementPart`1 : object {
    [CompilerGeneratedAttribute]
private Type <entity>P;
    private protected Member member;
    private List`1<IPropertyMappingProvider> properties;
    private List`1<IManyToOneMappingProvider> references;
    private List`1<INestedCompositeElementMappingProvider> components;
    private protected AttributeStore attributes;
    public CompositeElementPart`1(Type entity);
    public CompositeElementPart`1(Type entity, Member member);
    public PropertyPart Map(Expression`1<Func`2<T, object>> expression);
    public PropertyPart Map(Expression`1<Func`2<T, object>> expression, string columnName);
    protected virtual PropertyPart Map(Member property, string columnName);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, TOther>> expression);
    public ManyToOnePart`1<TOther> References(Expression`1<Func`2<T, TOther>> expression, string columnName);
    protected virtual ManyToOnePart`1<TOther> References(Member property, string columnName);
    public void ParentReference(Expression`1<Func`2<T, object>> expression);
    public void ParentReference(Expression`1<Func`2<T, object>> expression, Action`1<ParentPropertyPart> customMapping);
    private void ParentReference(Member property, Action`1<ParentPropertyPart> customMapping);
    public void Component(Expression`1<Func`2<T, TChild>> property, Action`1<NestedCompositeElementPart`1<TChild>> nestedCompositeElementAction);
    private void PopulateMapping(CompositeElementMapping mapping);
    private sealed virtual override CompositeElementMapping FluentNHibernate.Mapping.Providers.ICompositeElementMappingProvider.GetCompositeElementMapping();
    private sealed virtual override NestedCompositeElementMapping FluentNHibernate.Mapping.Providers.INestedCompositeElementMappingProvider.GetCompositeElementMapping();
}
public class FluentNHibernate.Mapping.CompositeIdentityPart`1 : object {
    private Action`1<Member> onMemberMapped;
    private AttributeStore attributes;
    private List`1<ICompositeIdKeyMapping> keys;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<CompositeIdentityPart`1<T>> <Access>k__BackingField;
    public AccessStrategyBuilder`1<CompositeIdentityPart`1<T>> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public CompositeIdentityPart`1<T> Not { get; }
    public CompositeIdentityPart`1(Action`1<Member> onMemberMapped);
    public CompositeIdentityPart`1(string name, Action`1<Member> onMemberMapped);
    public CompositeIdentityPart`1<T> KeyProperty(Expression`1<Func`2<T, object>> expression);
    public CompositeIdentityPart`1<T> KeyProperty(Expression`1<Func`2<T, object>> expression, string columnName);
    public CompositeIdentityPart`1<T> KeyProperty(Expression`1<Func`2<T, object>> expression, Action`1<KeyPropertyPart> keyPropertyAction);
    protected virtual CompositeIdentityPart`1<T> KeyProperty(Member member, string columnName, Action`1<KeyPropertyPart> customMapping);
    public CompositeIdentityPart`1<T> KeyReference(Expression`1<Func`2<T, object>> expression);
    public CompositeIdentityPart`1<T> KeyReference(Expression`1<Func`2<T, object>> expression, String[] columnNames);
    public CompositeIdentityPart`1<T> KeyReference(Expression`1<Func`2<T, object>> expression, Action`1<KeyManyToOnePart> customMapping, String[] columnNames);
    protected virtual CompositeIdentityPart`1<T> KeyReference(Member member, IEnumerable`1<string> columnNames, Action`1<KeyManyToOnePart> customMapping);
    public virtual CompositeIdentityPart`1<T> CustomType();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<CompositeIdentityPart`1<T>> get_Access();
    public CompositeIdentityPart`1<T> get_Not();
    public CompositeIdentityPart`1<T> Mapped();
    public CompositeIdentityPart`1<T> UnsavedValue(string value);
    public CompositeIdentityPart`1<T> ComponentCompositeIdentifier(Expression`1<Func`2<T, TComponentType>> expression);
    private sealed virtual override CompositeIdMapping FluentNHibernate.Mapping.Providers.ICompositeIdMappingProvider.GetCompositeIdMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(string value);
}
public class FluentNHibernate.Mapping.DiscriminatorPart : object {
    [CompilerGeneratedAttribute]
private string <columnName>P;
    [CompilerGeneratedAttribute]
private Type <entity>P;
    [CompilerGeneratedAttribute]
private Action`2<Type, ISubclassMappingProvider> <setter>P;
    [CompilerGeneratedAttribute]
private TypeReference <discriminatorValueType>P;
    private AttributeStore attributes;
    private AttributeStore columnAttributes;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public DiscriminatorPart Not { get; }
    public DiscriminatorPart(string columnName, Type entity, Action`2<Type, ISubclassMappingProvider> setter, TypeReference discriminatorValueType);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public DiscriminatorPart SubClass(object discriminatorValue, Action`1<SubClassPart`1<TSubClass>> action);
    [ObsoleteAttribute("Inline definitions of subclasses are depreciated. Please create a derived class from SubclassMap in the same way you do with ClassMap.")]
public DiscriminatorPart SubClass(Action`1<SubClassPart`1<TSubClass>> action);
    public DiscriminatorPart get_Not();
    public DiscriminatorPart AlwaysSelectWithValue();
    public DiscriminatorPart ReadOnly();
    public DiscriminatorPart Formula(string sql);
    public DiscriminatorPart Precision(int precision);
    public DiscriminatorPart Scale(int scale);
    public DiscriminatorPart Length(int length);
    public DiscriminatorPart Nullable();
    public DiscriminatorPart Unique();
    public DiscriminatorPart UniqueKey(string keyColumns);
    public DiscriminatorPart Index(string index);
    public DiscriminatorPart Check(string constraint);
    public DiscriminatorPart Default(object value);
    public DiscriminatorPart CustomType();
    public DiscriminatorPart CustomType(Type type);
    public DiscriminatorPart CustomType(string type);
    public DiscriminatorPart SqlType(string type);
    private sealed virtual override DiscriminatorMapping FluentNHibernate.Mapping.Providers.IDiscriminatorMappingProvider.GetDiscriminatorMapping();
}
public class FluentNHibernate.Mapping.DiscriminatorValue : object {
    public static DiscriminatorValue Null;
    public static DiscriminatorValue NotNull;
    private string outputValue;
    private DiscriminatorValue(string outputValue);
    private static DiscriminatorValue();
    public virtual string ToString();
}
public class FluentNHibernate.Mapping.DynamicComponentPart`1 : ComponentPartBase`2<T, DynamicComponentPart`1<T>> {
    private Type entity;
    private MappingProviderStore providers;
    public DynamicComponentPart`1(Type entity, Member member);
    private DynamicComponentPart`1(Type entity, Member member, AttributeStore underlyingStore, MappingProviderStore providers);
    protected virtual ComponentMapping CreateComponentMappingRoot(AttributeStore store);
    public PropertyPart Map(string key);
    public PropertyPart Map(string key);
    private sealed virtual override IComponentMapping FluentNHibernate.Mapping.Providers.IComponentMappingProvider.GetComponentMapping();
}
public class FluentNHibernate.Mapping.ElementPart : object {
    private Type entity;
    private AttributeStore attributes;
    private AttributeStore columnAttributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<ElementPart> <Columns>k__BackingField;
    public ColumnMappingCollection`1<ElementPart> Columns { get; }
    [DebuggerBrowsableAttribute("0")]
public ElementPart Not { get; }
    public ElementPart(Type entity);
    public ElementPart Column(string elementColumnName);
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<ElementPart> get_Columns();
    public ElementPart Type();
    public ElementPart Length(int length);
    public ElementPart Formula(string formula);
    public ElementPart Nullable();
    public ElementPart get_Not();
    private sealed virtual override ElementMapping FluentNHibernate.Mapping.Providers.IElementMappingProvider.GetElementMapping();
}
public class FluentNHibernate.Mapping.FetchTypeExpression`1 : object {
    [CompilerGeneratedAttribute]
private TParent <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public FetchTypeExpression`1(TParent parent, Action`1<string> setter);
    public TParent Join();
    public TParent Select();
    public TParent Subselect();
}
public abstract class FluentNHibernate.Mapping.FilterDefinition : object {
    private string filterCondition;
    private IDictionary`2<string, IType> parameters;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public IEnumerable`1<KeyValuePair`2<string, IType>> Parameters { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public IEnumerable`1<KeyValuePair`2<string, IType>> get_Parameters();
    public FilterDefinition WithName(string name);
    public FilterDefinition WithCondition(string condition);
    public FilterDefinition AddParameter(string name, IType type);
    private sealed virtual override FilterDefinitionMapping FluentNHibernate.Mapping.IFilterDefinition.GetFilterMapping();
    private sealed virtual override HibernateMapping FluentNHibernate.Mapping.IFilterDefinition.GetHibernateMapping();
}
public class FluentNHibernate.Mapping.FilterPart : object {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Condition { get; }
    public string Name { get; }
    public FilterPart(string name, string condition);
    public FilterPart(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Condition();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public virtual bool Equals(object obj);
    private sealed virtual override FilterMapping FluentNHibernate.Mapping.Providers.IFilterMappingProvider.GetFilterMapping();
    public sealed virtual bool Equals(FilterPart other);
    public virtual int GetHashCode();
}
internal class FluentNHibernate.Mapping.GeneratorBuilder : object {
    [CompilerGeneratedAttribute]
private GeneratorMapping <mapping>P;
    [CompilerGeneratedAttribute]
private Type <identityType>P;
    [CompilerGeneratedAttribute]
private int <layer>P;
    public GeneratorBuilder(GeneratorMapping mapping, Type identityType, int layer);
    private void SetGenerator(string generator);
    private void AddGeneratorParam(string name, string value);
    private void EnsureIntegralIdenityType();
    private void EnsureGuidIdentityType();
    private void EnsureStringIdentityType();
    private static bool IsIntegralType(Type t);
    public void Increment();
    public void Increment(Action`1<ParamBuilder> paramValues);
    public void Identity();
    public void Identity(Action`1<ParamBuilder> paramValues);
    public void Sequence(string sequenceName);
    public void Sequence(string sequenceName, Action`1<ParamBuilder> paramValues);
    public void HiLo(string table, string column, string maxLo, string where);
    public void HiLo(string table, string column, string maxLo);
    public void HiLo(string table, string column, string maxLo, Action`1<ParamBuilder> paramValues);
    public void HiLo(string maxLo);
    public void HiLo(string maxLo, Action`1<ParamBuilder> paramValues);
    public void SeqHiLo(string sequence, string maxLo);
    public void SeqHiLo(string sequence, string maxLo, Action`1<ParamBuilder> paramValues);
    public void UuidHex(string format);
    public void UuidHex(string format, Action`1<ParamBuilder> paramValues);
    public void UuidString();
    public void UuidString(Action`1<ParamBuilder> paramValues);
    public void Guid();
    public void Guid(Action`1<ParamBuilder> paramValues);
    public void GuidComb();
    public void GuidComb(Action`1<ParamBuilder> paramValues);
    public void GuidNative();
    public void GuidNative(Action`1<ParamBuilder> paramValues);
    public void Select();
    public void Select(Action`1<ParamBuilder> paramValues);
    public void SequenceIdentity();
    public void SequenceIdentity(string sequence);
    public void SequenceIdentity(Action`1<ParamBuilder> paramValues);
    public void SequenceIdentity(string sequence, Action`1<ParamBuilder> paramValues);
    public void TriggerIdentity();
    public void TriggerIdentity(Action`1<ParamBuilder> paramValues);
    public void Assigned();
    public void Assigned(Action`1<ParamBuilder> paramValues);
    public void Native();
    public void Native(Action`1<ParamBuilder> paramValues);
    public void Native(string sequenceName);
    public void Native(string sequenceName, Action`1<ParamBuilder> paramValues);
    public void Foreign(string property);
    public void Foreign(string property, Action`1<ParamBuilder> paramValues);
    public void Custom();
    public void Custom(Type generator);
    public void Custom(string generator);
    public void Custom(Action`1<ParamBuilder> paramValues);
    public void Custom(Type generator, Action`1<ParamBuilder> paramValues);
    public void Custom(string generator, Action`1<ParamBuilder> paramValues);
}
[ObsoleteAttribute("Please use EnumStringType<T> instead")]
public class FluentNHibernate.Mapping.GenericEnumMapper`1 : EnumStringType {
}
public class FluentNHibernate.Mapping.HibernateMappingPart : object {
    private AttributeStore attributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private CascadeExpression`1<HibernateMappingPart> <DefaultCascade>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<HibernateMappingPart> <DefaultAccess>k__BackingField;
    public CascadeExpression`1<HibernateMappingPart> DefaultCascade { get; }
    public AccessStrategyBuilder`1<HibernateMappingPart> DefaultAccess { get; }
    [DebuggerBrowsableAttribute("0")]
public HibernateMappingPart Not { get; }
    public HibernateMappingPart Schema(string schema);
    [CompilerGeneratedAttribute]
public CascadeExpression`1<HibernateMappingPart> get_DefaultCascade();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<HibernateMappingPart> get_DefaultAccess();
    public HibernateMappingPart AutoImport();
    public HibernateMappingPart DefaultLazy();
    public HibernateMappingPart get_Not();
    public HibernateMappingPart Catalog(string catalog);
    public HibernateMappingPart Namespace(string ns);
    public HibernateMappingPart Assembly(string assembly);
    private sealed virtual override HibernateMapping FluentNHibernate.Mapping.Providers.IHibernateMappingProvider.GetHibernateMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(string value);
}
public class FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1 : object {
    private TParent parent;
    private Type entity;
    private GeneratorMapping mapping;
    private GeneratorBuilder builder;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    internal bool IsDirty { get; private set; }
    public IdentityGenerationStrategyBuilder`1(TParent parent, Type identityType, Type entity);
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
private void set_IsDirty(bool value);
    public GeneratorMapping GetGeneratorMapping();
    public TParent Increment();
    public TParent Increment(Action`1<ParamBuilder> paramValues);
    public TParent Identity();
    public TParent Identity(Action`1<ParamBuilder> paramValues);
    public TParent Sequence(string sequenceName);
    public TParent Sequence(string sequenceName, Action`1<ParamBuilder> paramValues);
    public TParent HiLo(string table, string column, string maxLo, string where);
    public TParent HiLo(string table, string column, string maxLo);
    public TParent HiLo(string table, string column, string maxLo, Action`1<ParamBuilder> paramValues);
    public TParent HiLo(string maxLo);
    public TParent HiLo(string maxLo, Action`1<ParamBuilder> paramValues);
    public TParent SeqHiLo(string sequence, string maxLo);
    public TParent SeqHiLo(string sequence, string maxLo, Action`1<ParamBuilder> paramValues);
    public TParent UuidHex(string format);
    public TParent UuidHex(string format, Action`1<ParamBuilder> paramValues);
    public TParent UuidString();
    public TParent UuidString(Action`1<ParamBuilder> paramValues);
    public TParent Guid();
    public TParent Guid(Action`1<ParamBuilder> paramValues);
    public TParent GuidComb();
    public TParent GuidComb(Action`1<ParamBuilder> paramValues);
    public TParent Assigned();
    public TParent Assigned(Action`1<ParamBuilder> paramValues);
    public TParent Native();
    public TParent Native(Action`1<ParamBuilder> paramValues);
    public TParent Native(string sequenceName);
    public TParent Native(string sequenceName, Action`1<ParamBuilder> paramValues);
    public TParent Foreign(string property);
    public TParent Foreign(string property, Action`1<ParamBuilder> paramValues);
    public TParent Custom();
    public TParent Custom(Type generator);
    public TParent Custom(string generator);
    public TParent Custom(Action`1<ParamBuilder> paramValues);
    public TParent Custom(Type generator, Action`1<ParamBuilder> paramValues);
    public TParent Custom(string generator, Action`1<ParamBuilder> paramValues);
    public TParent GuidNative();
    public TParent GuidNative(Action`1<ParamBuilder> paramValues);
    public TParent Select();
    public TParent Select(Action`1<ParamBuilder> paramValues);
    public TParent SequenceIdentity();
    public TParent SequenceIdentity(string sequence);
    public TParent SequenceIdentity(Action`1<ParamBuilder> paramValues);
    public TParent SequenceIdentity(string sequence, Action`1<ParamBuilder> paramValues);
    public TParent TriggerIdentity();
    public TParent TriggerIdentity(Action`1<ParamBuilder> paramValues);
}
public class FluentNHibernate.Mapping.IdentityPart : object {
    private AttributeStore columnAttributes;
    private List`1<string> columns;
    private Member member;
    private Type entityType;
    private AttributeStore attributes;
    private Type identityType;
    private bool nextBool;
    private string name;
    [CompilerGeneratedAttribute]
private IdentityGenerationStrategyBuilder`1<IdentityPart> <GeneratedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<IdentityPart> <Access>k__BackingField;
    public IdentityGenerationStrategyBuilder`1<IdentityPart> GeneratedBy { get; }
    public AccessStrategyBuilder`1<IdentityPart> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public IdentityPart Not { get; }
    private bool HasNameSpecified { get; }
    public IdentityPart(Type entity, Member member);
    public IdentityPart(Type entity, Type identityType);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public IdentityGenerationStrategyBuilder`1<IdentityPart> get_GeneratedBy();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<IdentityPart> get_Access();
    public IdentityPart get_Not();
    public IdentityPart UnsavedValue(object unsavedValue);
    public IdentityPart Column(string columnName);
    public IdentityPart Length(int length);
    public IdentityPart Precision(int precision);
    public IdentityPart Scale(int scale);
    public IdentityPart Nullable();
    public IdentityPart Unique();
    public IdentityPart UniqueKey(string keyColumns);
    public IdentityPart CustomSqlType(string sqlType);
    public IdentityPart Index(string key);
    public IdentityPart Check(string constraint);
    public IdentityPart Default(object value);
    public IdentityPart CustomType();
    public IdentityPart CustomType(Type type);
    public IdentityPart CustomType(string type);
    internal void SetName(string newName);
    private bool get_HasNameSpecified();
    private void SetDefaultGenerator();
    private sealed virtual override IdMapping FluentNHibernate.Mapping.Providers.IIdentityMappingProvider.GetIdentityMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(string value);
}
public interface FluentNHibernate.Mapping.IFilter {
    public string Condition { get; }
    public string Name { get; }
    public abstract virtual string get_Condition();
    public abstract virtual string get_Name();
}
public interface FluentNHibernate.Mapping.IFilterDefinition {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual FilterDefinitionMapping GetFilterMapping();
    public abstract virtual HibernateMapping GetHibernateMapping();
}
public class FluentNHibernate.Mapping.ImportPart : object {
    private AttributeStore attributes;
    public ImportPart(Type importType);
    public void As(string alternativeName);
    internal ImportMapping GetImportMapping();
}
public class FluentNHibernate.Mapping.IndexManyToManyPart : object {
    [CompilerGeneratedAttribute]
private Type <entity>P;
    private List`1<string> columns;
    private AttributeStore attributes;
    public IndexManyToManyPart(Type entity);
    public IndexManyToManyPart Column(string indexColumnName);
    public IndexManyToManyPart Type();
    public IndexManyToManyPart Type(Type indexType);
    public IndexManyToManyPart EntityName(string entityName);
    [ObsoleteAttribute("Do not call this method. Implementation detail mistakenly made public. Will be made private in next version.")]
public IndexManyToManyMapping GetIndexMapping();
}
public class FluentNHibernate.Mapping.IndexPart : object {
    [CompilerGeneratedAttribute]
private Type <entity>P;
    private List`1<string> columns;
    private AttributeStore attributes;
    public IndexPart(Type entity);
    public IndexPart Column(string indexColumnName);
    public IndexPart Type();
    public IndexPart Type(Type type);
    [ObsoleteAttribute("Do not call this method. Implementation detail mistakenly made public. Will be made private in next version.")]
public IndexMapping GetIndexMapping();
}
public class FluentNHibernate.Mapping.InvalidPrefixException : Exception {
    public InvalidPrefixException(string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected InvalidPrefixException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("REMOVE ME")]
public class FluentNHibernate.Mapping.JoinedSubClassPart`1 : ClasslikeMapBase`1<TSubclass> {
    private MappingProviderStore providers;
    private List`1<SubclassMapping> subclassMappings;
    private AttributeStore attributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<JoinedSubClassPart`1<TSubclass>> <KeyColumns>k__BackingField;
    public ColumnMappingCollection`1<JoinedSubClassPart`1<TSubclass>> KeyColumns { get; }
    [DebuggerBrowsableAttribute("0")]
public JoinedSubClassPart`1<TSubclass> Not { get; }
    public JoinedSubClassPart`1(string keyColumn);
    protected JoinedSubClassPart`1(string keyColumn, AttributeStore attributes, MappingProviderStore providers);
    public virtual void JoinedSubClass(string keyColumn, Action`1<JoinedSubClassPart`1<TNextSubclass>> action);
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<JoinedSubClassPart`1<TSubclass>> get_KeyColumns();
    public JoinedSubClassPart`1<TSubclass> Table(string tableName);
    public JoinedSubClassPart`1<TSubclass> Schema(string schema);
    public JoinedSubClassPart`1<TSubclass> CheckConstraint(string constraintName);
    public JoinedSubClassPart`1<TSubclass> Proxy(Type type);
    public JoinedSubClassPart`1<TSubclass> Proxy();
    public JoinedSubClassPart`1<TSubclass> LazyLoad();
    public JoinedSubClassPart`1<TSubclass> DynamicUpdate();
    public JoinedSubClassPart`1<TSubclass> DynamicInsert();
    public JoinedSubClassPart`1<TSubclass> SelectBeforeUpdate();
    public JoinedSubClassPart`1<TSubclass> Abstract();
    public JoinedSubClassPart`1<TSubclass> EntityName(string entityName);
    public JoinedSubClassPart`1<TSubclass> get_Not();
    private sealed virtual override SubclassMapping FluentNHibernate.Mapping.Providers.ISubclassMappingProvider.GetSubclassMapping();
}
public class FluentNHibernate.Mapping.JoinPart`1 : ClasslikeMapBase`1<T> {
    private MappingProviderStore providers;
    private List`1<string> columns;
    private AttributeStore attributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private FetchTypeExpression`1<JoinPart`1<T>> <Fetch>k__BackingField;
    public FetchTypeExpression`1<JoinPart`1<T>> Fetch { get; }
    [DebuggerBrowsableAttribute("0")]
public JoinPart`1<T> Not { get; }
    public JoinPart`1(string tableName);
    protected JoinPart`1(string tableName, MappingProviderStore providers);
    public JoinPart`1<T> KeyColumn(string column);
    public JoinPart`1<T> KeyColumn(String[] columnNames);
    public JoinPart`1<T> Schema(string schema);
    [CompilerGeneratedAttribute]
public FetchTypeExpression`1<JoinPart`1<T>> get_Fetch();
    public JoinPart`1<T> Inverse();
    public JoinPart`1<T> Optional();
    public JoinPart`1<T> Catalog(string catalog);
    public JoinPart`1<T> Subselect(string subselect);
    public JoinPart`1<T> get_Not();
    public JoinPart`1<T> Table(string tableName);
    private sealed virtual override JoinMapping FluentNHibernate.Mapping.Providers.IJoinMappingProvider.GetJoinMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(string value);
}
public class FluentNHibernate.Mapping.KeyManyToOnePart : object {
    private KeyManyToOneMapping mapping;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<KeyManyToOnePart> <Access>k__BackingField;
    [CompilerGeneratedAttribute]
private NotFoundExpression`1<KeyManyToOnePart> <NotFound>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public KeyManyToOnePart Not { get; }
    public AccessStrategyBuilder`1<KeyManyToOnePart> Access { get; }
    public NotFoundExpression`1<KeyManyToOnePart> NotFound { get; }
    public KeyManyToOnePart(KeyManyToOneMapping mapping);
    public KeyManyToOnePart get_Not();
    public KeyManyToOnePart ForeignKey(string foreignKey);
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<KeyManyToOnePart> get_Access();
    [CompilerGeneratedAttribute]
public NotFoundExpression`1<KeyManyToOnePart> get_NotFound();
    public KeyManyToOnePart Lazy();
    public KeyManyToOnePart Name(string name);
    public KeyManyToOnePart EntityName(string entityName);
    public KeyManyToOnePart Class();
    public KeyManyToOnePart Class(Type type);
}
public class FluentNHibernate.Mapping.KeyPropertyPart : object {
    private KeyPropertyMapping mapping;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<KeyPropertyPart> <Access>k__BackingField;
    public AccessStrategyBuilder`1<KeyPropertyPart> Access { get; }
    public KeyPropertyPart(KeyPropertyMapping mapping);
    public KeyPropertyPart ColumnName(string columnName);
    public KeyPropertyPart Type(Type type);
    public KeyPropertyPart Type(string type);
    public KeyPropertyPart Length(int length);
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<KeyPropertyPart> get_Access();
}
public class FluentNHibernate.Mapping.Laziness : object {
    public static Laziness False;
    public static Laziness Proxy;
    public static Laziness NoProxy;
    private string value;
    public Laziness(string value);
    private static Laziness();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Laziness other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class FluentNHibernate.Mapping.ListIndexPart : object {
    [CompilerGeneratedAttribute]
private IndexMapping <mapping>P;
    private AttributeStore sharedColumnAttributes;
    public ListIndexPart(IndexMapping mapping);
    public void Offset(int offset);
    public void Column(string indexColumnName);
    public void Type();
    public void Type(Type type);
    public void Type(string type);
}
public class FluentNHibernate.Mapping.ManyToManyPart`1 : ToManyBase`2<ManyToManyPart`1<TChild>, TChild> {
    private List`1<IFilterMappingProvider> childFilters;
    private IndexManyToManyPart manyToManyIndex;
    private IndexPart index;
    private Type childType;
    private Type valueType;
    private bool isTernary;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<ManyToManyPart`1<TChild>> <ChildKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<ManyToManyPart`1<TChild>> <ParentKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private FetchTypeExpression`1<ManyToManyPart`1<TChild>> <FetchType>k__BackingField;
    [CompilerGeneratedAttribute]
private NotFoundExpression`1<ManyToManyPart`1<TChild>> <NotFound>k__BackingField;
    public ColumnMappingCollection`1<ManyToManyPart`1<TChild>> ChildKeyColumns { get; }
    public ColumnMappingCollection`1<ManyToManyPart`1<TChild>> ParentKeyColumns { get; }
    public FetchTypeExpression`1<ManyToManyPart`1<TChild>> FetchType { get; }
    public Type ChildType { get; }
    public NotFoundExpression`1<ManyToManyPart`1<TChild>> NotFound { get; }
    public ManyToManyPart`1(Type entity, Member property);
    protected ManyToManyPart`1(Type entity, Member member, Type collectionType);
    public ManyToManyPart`1<TChild> ChildKeyColumn(string childKeyColumn);
    public ManyToManyPart`1<TChild> ParentKeyColumn(string parentKeyColumn);
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<ManyToManyPart`1<TChild>> get_ChildKeyColumns();
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<ManyToManyPart`1<TChild>> get_ParentKeyColumns();
    public ManyToManyPart`1<TChild> ForeignKeyConstraintNames(string parentForeignKeyName, string childForeignKeyName);
    public ManyToManyPart`1<TChild> ChildPropertyRef(string childPropertyRef);
    [CompilerGeneratedAttribute]
public FetchTypeExpression`1<ManyToManyPart`1<TChild>> get_FetchType();
    private void EnsureDictionary();
    private void EnsureGenericDictionary();
    public ManyToManyPart`1<TChild> AsTernaryAssociation();
    public ManyToManyPart`1<TChild> AsTernaryAssociation(string indexColumn, string valueColumn);
    public ManyToManyPart`1<TChild> AsTernaryAssociation(string indexColumn, string valueColumn, Action`1<IndexManyToManyPart> indexAction);
    public ManyToManyPart`1<TChild> AsTernaryAssociation(Type indexType, Type typeOfValue);
    public ManyToManyPart`1<TChild> AsTernaryAssociation(Type indexType, string indexColumn, Type typeOfValue, string valueColumn);
    public ManyToManyPart`1<TChild> AsTernaryAssociation(Type indexType, string indexColumn, Type typeOfValue, string valueColumn, Action`1<IndexManyToManyPart> indexAction);
    public ManyToManyPart`1<TChild> AsSimpleAssociation();
    public ManyToManyPart`1<TChild> AsSimpleAssociation(string indexColumn, string valueColumn);
    public ManyToManyPart`1<TChild> AsEntityMap();
    public ManyToManyPart`1<TChild> AsEntityMap(string indexColumn, string valueColumn);
    public Type get_ChildType();
    [CompilerGeneratedAttribute]
public NotFoundExpression`1<ManyToManyPart`1<TChild>> get_NotFound();
    protected virtual ICollectionRelationshipMapping GetRelationship();
    public ManyToManyPart`1<TChild> OrderBy(Expression`1<Func`2<TChild, object>> orderBy);
    public ManyToManyPart`1<TChild> OrderBy(string orderBy);
    public ManyToManyPart`1<TChild> ChildOrderBy(Expression`1<Func`2<TChild, object>> orderBy);
    public ManyToManyPart`1<TChild> ChildOrderBy(string orderBy);
    public ManyToManyPart`1<TChild> ReadOnly();
    public ManyToManyPart`1<TChild> Subselect(string subselect);
    public ManyToManyPart`1<TChild> ApplyChildFilter(string name, string condition);
    public ManyToManyPart`1<TChild> ApplyChildFilter(string name);
    public ManyToManyPart`1<TChild> ApplyChildFilter(string condition);
    public ManyToManyPart`1<TChild> ApplyChildFilter();
    public ManyToManyPart`1<TChild> ChildWhere(string where);
    public ManyToManyPart`1<TChild> ChildWhere(Expression`1<Func`2<TChild, bool>> where);
    protected virtual CollectionMapping GetCollectionMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1(string value);
}
public class FluentNHibernate.Mapping.ManyToOnePart`1 : object {
    private List`1<string> columns;
    private bool nextBool;
    private AttributeStore attributes;
    private AttributeStore columnAttributes;
    private Type entity;
    private Member member;
    [CompilerGeneratedAttribute]
private FetchTypeExpression`1<ManyToOnePart`1<TOther>> <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private NotFoundExpression`1<ManyToOnePart`1<TOther>> <NotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeExpression`1<ManyToOnePart`1<TOther>> <Cascade>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<ManyToOnePart`1<TOther>> <Access>k__BackingField;
    public FetchTypeExpression`1<ManyToOnePart`1<TOther>> Fetch { get; }
    public NotFoundExpression`1<ManyToOnePart`1<TOther>> NotFound { get; }
    public CascadeExpression`1<ManyToOnePart`1<TOther>> Cascade { get; }
    public AccessStrategyBuilder`1<ManyToOnePart`1<TOther>> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public ManyToOnePart`1<TOther> Not { get; }
    public ManyToOnePart`1(Type entity, Member member);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public FetchTypeExpression`1<ManyToOnePart`1<TOther>> get_Fetch();
    [CompilerGeneratedAttribute]
public NotFoundExpression`1<ManyToOnePart`1<TOther>> get_NotFound();
    public ManyToOnePart`1<TOther> Unique();
    public ManyToOnePart`1<TOther> UniqueKey(string keyName);
    public ManyToOnePart`1<TOther> Index(string indexName);
    public ManyToOnePart`1<TOther> Class();
    public ManyToOnePart`1<TOther> Class(Type type);
    public ManyToOnePart`1<TOther> ReadOnly();
    public ManyToOnePart`1<TOther> LazyLoad();
    public ManyToOnePart`1<TOther> LazyLoad(Laziness laziness);
    public ManyToOnePart`1<TOther> ForeignKey();
    public ManyToOnePart`1<TOther> ForeignKey(string foreignKeyName);
    public ManyToOnePart`1<TOther> Insert();
    public ManyToOnePart`1<TOther> Update();
    public ManyToOnePart`1<TOther> Column(string name);
    public ManyToOnePart`1<TOther> Columns(String[] newColumns);
    public ManyToOnePart`1<TOther> Columns(Expression`1[] newColumns);
    public ManyToOnePart`1<TOther> Formula(string formula);
    [CompilerGeneratedAttribute]
public CascadeExpression`1<ManyToOnePart`1<TOther>> get_Cascade();
    public ManyToOnePart`1<TOther> PropertyRef(Expression`1<Func`2<TOther, object>> expression);
    public ManyToOnePart`1<TOther> PropertyRef(string property);
    public ManyToOnePart`1<TOther> Nullable();
    public ManyToOnePart`1<TOther> EntityName(string entityName);
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<ManyToOnePart`1<TOther>> get_Access();
    public ManyToOnePart`1<TOther> get_Not();
    private sealed virtual override ManyToOneMapping FluentNHibernate.Mapping.Providers.IManyToOneMappingProvider.GetManyToOneMapping();
    private ColumnMapping CreateColumn(string column);
    public ManyToOnePart`1<TOther> OptimisticLock();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_3(string value);
}
public class FluentNHibernate.Mapping.MappingProviderStore : object {
    [CompilerGeneratedAttribute]
private IList`1<IPropertyMappingProvider> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IComponentMappingProvider> <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IOneToOneMappingProvider> <OneToOnes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Type, ISubclassMappingProvider> <Subclasses>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICollectionMappingProvider> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IManyToOneMappingProvider> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAnyMappingProvider> <Anys>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFilterMappingProvider> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IStoredProcedureMappingProvider> <StoredProcedures>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IJoinMappingProvider> <Joins>k__BackingField;
    private IIdentityMappingProvider _id;
    private ICompositeIdMappingProvider _compositeId;
    private INaturalIdMappingProvider _naturalId;
    private IVersionMappingProvider _version;
    private IDiscriminatorMappingProvider _discriminator;
    private TuplizerMapping _tupilizerMapping;
    private IList`1<Tuple`2<ProviderType, object>> _orderedProviders;
    public IList`1<IPropertyMappingProvider> Properties { get; public set; }
    public IList`1<IComponentMappingProvider> Components { get; public set; }
    public IList`1<IOneToOneMappingProvider> OneToOnes { get; public set; }
    public IDictionary`2<Type, ISubclassMappingProvider> Subclasses { get; public set; }
    public IList`1<ICollectionMappingProvider> Collections { get; public set; }
    public IList`1<IManyToOneMappingProvider> References { get; public set; }
    public IList`1<IAnyMappingProvider> Anys { get; public set; }
    public IList`1<IFilterMappingProvider> Filters { get; public set; }
    public IList`1<IStoredProcedureMappingProvider> StoredProcedures { get; public set; }
    public IList`1<IJoinMappingProvider> Joins { get; public set; }
    public IIdentityMappingProvider Id { get; public set; }
    public ICompositeIdMappingProvider CompositeId { get; public set; }
    public INaturalIdMappingProvider NaturalId { get; public set; }
    public IVersionMappingProvider Version { get; public set; }
    public IDiscriminatorMappingProvider Discriminator { get; public set; }
    public TuplizerMapping TuplizerMapping { get; public set; }
    public IEnumerable`1<Tuple`2<ProviderType, object>> OrderedProviders { get; }
    [CompilerGeneratedAttribute]
public IList`1<IPropertyMappingProvider> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IList`1<IPropertyMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IComponentMappingProvider> get_Components();
    [CompilerGeneratedAttribute]
public void set_Components(IList`1<IComponentMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IOneToOneMappingProvider> get_OneToOnes();
    [CompilerGeneratedAttribute]
public void set_OneToOnes(IList`1<IOneToOneMappingProvider> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Type, ISubclassMappingProvider> get_Subclasses();
    [CompilerGeneratedAttribute]
public void set_Subclasses(IDictionary`2<Type, ISubclassMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<ICollectionMappingProvider> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(IList`1<ICollectionMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IManyToOneMappingProvider> get_References();
    [CompilerGeneratedAttribute]
public void set_References(IList`1<IManyToOneMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IAnyMappingProvider> get_Anys();
    [CompilerGeneratedAttribute]
public void set_Anys(IList`1<IAnyMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IFilterMappingProvider> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(IList`1<IFilterMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IStoredProcedureMappingProvider> get_StoredProcedures();
    [CompilerGeneratedAttribute]
public void set_StoredProcedures(IList`1<IStoredProcedureMappingProvider> value);
    [CompilerGeneratedAttribute]
public IList`1<IJoinMappingProvider> get_Joins();
    [CompilerGeneratedAttribute]
public void set_Joins(IList`1<IJoinMappingProvider> value);
    public IIdentityMappingProvider get_Id();
    public void set_Id(IIdentityMappingProvider value);
    public ICompositeIdMappingProvider get_CompositeId();
    public void set_CompositeId(ICompositeIdMappingProvider value);
    public INaturalIdMappingProvider get_NaturalId();
    public void set_NaturalId(INaturalIdMappingProvider value);
    public IVersionMappingProvider get_Version();
    public void set_Version(IVersionMappingProvider value);
    public IDiscriminatorMappingProvider get_Discriminator();
    public void set_Discriminator(IDiscriminatorMappingProvider value);
    public TuplizerMapping get_TuplizerMapping();
    public void set_TuplizerMapping(TuplizerMapping value);
    public IEnumerable`1<Tuple`2<ProviderType, object>> get_OrderedProviders();
    private IList`1<T> NewObservedList();
    private IDictionary`2<TKey, TVal> NewObservedDictionary();
    private void ReplaceOrAddProvider(ProviderType type, object oldObj, object newObj);
    [CompilerGeneratedAttribute]
private ProviderType <NewObservedList>g__TypeSelector|69_0(object mappingStoreCollection);
    [CompilerGeneratedAttribute]
private void <NewObservedList>b__69_1(object sender, NotifyCollectionChangedEventArgs args);
    [CompilerGeneratedAttribute]
private void <NewObservedDictionary>b__70_0(object sender, NotifyCollectionChangedEventArgs args);
}
public static class FluentNHibernate.Mapping.MemberAccessResolver : object {
    public static Access Resolve(Member member);
}
public static class FluentNHibernate.Mapping.Naming : object {
    private static List`1<string> Invalids;
    private static Naming();
    public static NamingStrategy Determine(string name);
    private static string GuessNamingStrategy(string name);
}
public class FluentNHibernate.Mapping.NamingStrategy : object {
    public static NamingStrategy LowerCase;
    public static NamingStrategy LowerCaseUnderscore;
    public static NamingStrategy PascalCase;
    public static NamingStrategy PascalCaseM;
    public static NamingStrategy PascalCaseMUnderscore;
    public static NamingStrategy PascalCaseUnderscore;
    public static NamingStrategy CamelCase;
    public static NamingStrategy CamelCaseUnderscore;
    public static NamingStrategy Unknown;
    private string strategy;
    private NamingStrategy(string strategy);
    private static NamingStrategy();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamingStrategy other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static NamingStrategy FromString(string strategy);
}
public class FluentNHibernate.Mapping.NaturalIdPart`1 : object {
    private AttributeStore attributes;
    private List`1<PropertyPart> properties;
    private List`1<ManyToOneMapping> manyToOnes;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public NaturalIdPart`1<T> Not { get; }
    public NaturalIdPart`1<T> Property(Expression`1<Func`2<T, object>> expression);
    public NaturalIdPart`1<T> Property(Expression`1<Func`2<T, object>> expression, string columnName);
    protected virtual NaturalIdPart`1<T> Property(Member member, string columnName);
    public NaturalIdPart`1<T> Reference(Expression`1<Func`2<T, object>> expression);
    public NaturalIdPart`1<T> Reference(Expression`1<Func`2<T, object>> expression, string columnName);
    protected virtual NaturalIdPart`1<T> Reference(Member member, string columnName);
    public NaturalIdPart`1<T> ReadOnly();
    public NaturalIdPart`1<T> get_Not();
    private sealed virtual override NaturalIdMapping FluentNHibernate.Mapping.Providers.INaturalIdMappingProvider.GetNaturalIdMapping();
}
public class FluentNHibernate.Mapping.NestedCompositeElementPart`1 : CompositeElementPart`1<T> {
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<NestedCompositeElementPart`1<T>> <Access>k__BackingField;
    public AccessStrategyBuilder`1<NestedCompositeElementPart`1<T>> Access { get; }
    public NestedCompositeElementPart`1(Type entity, Member member);
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<NestedCompositeElementPart`1<T>> get_Access();
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0(string value);
}
public class FluentNHibernate.Mapping.NotFoundExpression`1 : object {
    [CompilerGeneratedAttribute]
private TParent <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public NotFoundExpression`1(TParent parent, Action`1<string> setter);
    public TParent Ignore();
    public TParent Exception();
}
public class FluentNHibernate.Mapping.OneToManyPart`1 : ToManyBase`2<OneToManyPart`1<TChild>, TChild> {
    private Type entity;
    private IndexManyToManyPart manyToManyIndex;
    private Type childType;
    private Type valueType;
    private bool isTernary;
    [CompilerGeneratedAttribute]
private NotFoundExpression`1<OneToManyPart`1<TChild>> <NotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<OneToManyPart`1<TChild>> <KeyColumns>k__BackingField;
    public NotFoundExpression`1<OneToManyPart`1<TChild>> NotFound { get; }
    public CollectionCascadeExpression`1<OneToManyPart`1<TChild>> Cascade { get; }
    public ColumnMappingCollection`1<OneToManyPart`1<TChild>> KeyColumns { get; }
    public OneToManyPart`1(Type entity, Member property);
    protected OneToManyPart`1(Type entity, Member member, Type collectionType);
    [CompilerGeneratedAttribute]
public NotFoundExpression`1<OneToManyPart`1<TChild>> get_NotFound();
    public CollectionCascadeExpression`1<OneToManyPart`1<TChild>> get_Cascade();
    public OneToManyPart`1<TChild> AsTernaryAssociation();
    public OneToManyPart`1<TChild> AsTernaryAssociation(string indexColumnName);
    public OneToManyPart`1<TChild> AsEntityMap();
    public OneToManyPart`1<TChild> AsEntityMap(string indexColumnName);
    public OneToManyPart`1<TChild> KeyColumn(string columnName);
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<OneToManyPart`1<TChild>> get_KeyColumns();
    public OneToManyPart`1<TChild> ForeignKeyConstraintName(string foreignKeyName);
    public OneToManyPart`1<TChild> OrderBy(string orderBy);
    public OneToManyPart`1<TChild> OrderBy(Expression`1<Func`2<TChild, object>> orderBy);
    public OneToManyPart`1<TChild> ReadOnly();
    public OneToManyPart`1<TChild> Subselect(string subselect);
    public OneToManyPart`1<TChild> KeyUpdate();
    public OneToManyPart`1<TChild> KeyNullable();
    protected virtual CollectionMapping GetCollectionMapping();
    protected virtual ICollectionRelationshipMapping GetRelationship();
    private void EnsureGenericDictionary();
    public OneToManyPart`1<TChild> Where(Expression`1<Func`2<TChild, bool>> where);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(string value);
}
public class FluentNHibernate.Mapping.OneToOnePart`1 : object {
    private Type entity;
    private Member member;
    private AttributeStore attributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private FetchTypeExpression`1<OneToOnePart`1<TOther>> <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeExpression`1<OneToOnePart`1<TOther>> <Cascade>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<OneToOnePart`1<TOther>> <Access>k__BackingField;
    public FetchTypeExpression`1<OneToOnePart`1<TOther>> Fetch { get; }
    public CascadeExpression`1<OneToOnePart`1<TOther>> Cascade { get; }
    public AccessStrategyBuilder`1<OneToOnePart`1<TOther>> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public OneToOnePart`1<TOther> Not { get; }
    public OneToOnePart`1(Type entity, Member member);
    private void SetDefaultAccess();
    public OneToOnePart`1<TOther> Class();
    public OneToOnePart`1<TOther> Class(Type type);
    [CompilerGeneratedAttribute]
public FetchTypeExpression`1<OneToOnePart`1<TOther>> get_Fetch();
    public OneToOnePart`1<TOther> ForeignKey();
    public OneToOnePart`1<TOther> ForeignKey(string foreignKeyName);
    public OneToOnePart`1<TOther> PropertyRef(Expression`1<Func`2<TOther, object>> expression);
    public OneToOnePart`1<TOther> PropertyRef(string propertyName);
    public OneToOnePart`1<TOther> Constrained();
    [CompilerGeneratedAttribute]
public CascadeExpression`1<OneToOnePart`1<TOther>> get_Cascade();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<OneToOnePart`1<TOther>> get_Access();
    public OneToOnePart`1<TOther> LazyLoad();
    public OneToOnePart`1<TOther> LazyLoad(Laziness laziness);
    public OneToOnePart`1<TOther> EntityName(string entityName);
    public OneToOnePart`1<TOther> get_Not();
    private sealed virtual override OneToOneMapping FluentNHibernate.Mapping.Providers.IOneToOneMappingProvider.GetOneToOneMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_2(string value);
}
public class FluentNHibernate.Mapping.OptimisticLockBuilder : object {
    private Action`1<string> setter;
    protected OptimisticLockBuilder(Action`1<string> setter);
    public void None();
    public void Version();
    public void Dirty();
    public void All();
}
public class FluentNHibernate.Mapping.OptimisticLockBuilder`1 : OptimisticLockBuilder {
    [CompilerGeneratedAttribute]
private TParent <parent>P;
    public OptimisticLockBuilder`1(TParent parent, Action`1<string> setter);
    public TParent None();
    public TParent Version();
    public TParent Dirty();
    public TParent All();
}
public class FluentNHibernate.Mapping.ParamBuilder : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <parameters>P;
    public ParamBuilder(IDictionary`2<string, string> parameters);
    public ParamBuilder AddParam(string name, string value);
}
public class FluentNHibernate.Mapping.ParentPropertyPart : object {
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<ParentPropertyPart> <Access>k__BackingField;
    public AccessStrategyBuilder`1<ParentPropertyPart> Access { get; }
    public ParentPropertyPart(ParentMapping mapping);
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<ParentPropertyPart> get_Access();
}
public class FluentNHibernate.Mapping.PolymorphismBuilder`1 : object {
    [CompilerGeneratedAttribute]
private T <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public PolymorphismBuilder`1(T parent, Action`1<string> setter);
    public T Implicit();
    public T Explicit();
}
public class FluentNHibernate.Mapping.Prefix : object {
    public static Prefix None;
    public static Prefix Underscore;
    public static Prefix m;
    public static Prefix mUnderscore;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private Prefix(string value);
    private static Prefix();
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class FluentNHibernate.Mapping.PropertyGeneratedBuilder : object {
    [CompilerGeneratedAttribute]
private PropertyPart <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public PropertyGeneratedBuilder(PropertyPart parent, Action`1<string> setter);
    public PropertyPart Never();
    public PropertyPart Insert();
    public PropertyPart Always();
}
public class FluentNHibernate.Mapping.PropertyPart : object {
    private Member member;
    private Type parentType;
    private AttributeStore attributes;
    private AttributeStore columnAttributes;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private PropertyGeneratedBuilder <Generated>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnMappingCollection`1<PropertyPart> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<PropertyPart> <Access>k__BackingField;
    public PropertyGeneratedBuilder Generated { get; }
    public ColumnMappingCollection`1<PropertyPart> Columns { get; }
    public AccessStrategyBuilder`1<PropertyPart> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public PropertyPart Not { get; }
    public PropertyPart(Member member, Type parentType);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public PropertyGeneratedBuilder get_Generated();
    public PropertyPart Column(string columnName);
    [CompilerGeneratedAttribute]
public ColumnMappingCollection`1<PropertyPart> get_Columns();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<PropertyPart> get_Access();
    public PropertyPart Insert();
    public PropertyPart Update();
    public PropertyPart Length(int length);
    public PropertyPart Nullable();
    public PropertyPart ReadOnly();
    public PropertyPart Formula(string formula);
    public PropertyPart LazyLoad();
    public PropertyPart Index(string index);
    public PropertyPart CustomType();
    public PropertyPart CustomType(Type type);
    public PropertyPart CustomType(string type);
    public PropertyPart CustomType(Func`2<Type, Type> typeFunc);
    private void AddColumnsFromCompositeUserType(Type compositeUserType);
    public PropertyPart CustomSqlType(string sqlType);
    public PropertyPart Unique();
    public PropertyPart Precision(int precision);
    public PropertyPart Scale(int scale);
    public PropertyPart Default(string value);
    public PropertyPart UniqueKey(string keyName);
    public PropertyPart OptimisticLock();
    public PropertyPart get_Not();
    public PropertyPart Check(string constraint);
    private sealed virtual override PropertyMapping FluentNHibernate.Mapping.Providers.IPropertyMappingProvider.GetPropertyMapping();
    private TypeReference GetDefaultType();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_1(string value);
}
public interface FluentNHibernate.Mapping.Providers.IAnyMappingProvider {
    public abstract virtual AnyMapping GetAnyMapping();
}
public interface FluentNHibernate.Mapping.Providers.ICacheMappingProvider {
    public abstract virtual CacheMapping GetCacheMapping();
}
public interface FluentNHibernate.Mapping.Providers.ICollectionMappingProvider {
    public abstract virtual CollectionMapping GetCollectionMapping();
}
public interface FluentNHibernate.Mapping.Providers.IComponentMappingProvider {
    public abstract virtual IComponentMapping GetComponentMapping();
}
public interface FluentNHibernate.Mapping.Providers.ICompositeElementMappingProvider {
    public abstract virtual CompositeElementMapping GetCompositeElementMapping();
}
public interface FluentNHibernate.Mapping.Providers.ICompositeIdMappingProvider {
    public abstract virtual CompositeIdMapping GetCompositeIdMapping();
}
public interface FluentNHibernate.Mapping.Providers.IDiscriminatorMappingProvider {
    public abstract virtual DiscriminatorMapping GetDiscriminatorMapping();
}
public interface FluentNHibernate.Mapping.Providers.IElementMappingProvider {
    public abstract virtual ElementMapping GetElementMapping();
}
public interface FluentNHibernate.Mapping.Providers.IExternalComponentMappingProvider {
    public Type Type { get; }
    public abstract virtual Type get_Type();
    public abstract virtual ExternalComponentMapping GetComponentMapping();
}
public interface FluentNHibernate.Mapping.Providers.IFilterMappingProvider {
    public abstract virtual FilterMapping GetFilterMapping();
}
public interface FluentNHibernate.Mapping.Providers.IHibernateMappingProvider {
    public abstract virtual HibernateMapping GetHibernateMapping();
}
public interface FluentNHibernate.Mapping.Providers.IIdentityMappingProvider {
    public abstract virtual IdMapping GetIdentityMapping();
}
public interface FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider {
    public Type EntityType { get; }
    public Type Extends { get; }
    public abstract virtual SubclassMapping GetSubclassMapping(SubclassType type);
    public abstract virtual Type get_EntityType();
    public abstract virtual Type get_Extends();
}
public interface FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProviderCollection {
    public abstract virtual void Add(IIndeterminateSubclassMappingProvider item);
    public abstract virtual bool IsTypeMapped(Type type);
}
public interface FluentNHibernate.Mapping.Providers.IJoinMappingProvider {
    public abstract virtual JoinMapping GetJoinMapping();
}
public interface FluentNHibernate.Mapping.Providers.IManyToOneMappingProvider {
    public abstract virtual ManyToOneMapping GetManyToOneMapping();
}
public interface FluentNHibernate.Mapping.Providers.INaturalIdMappingProvider {
    public abstract virtual NaturalIdMapping GetNaturalIdMapping();
}
public class FluentNHibernate.Mapping.Providers.IndeterminateSubclassMappingProviderCollection : object {
    private List`1<IIndeterminateSubclassMappingProvider> providers;
    private HashSet`1<Type> mappedTypes;
    public sealed virtual IEnumerator`1<IIndeterminateSubclassMappingProvider> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(IIndeterminateSubclassMappingProvider item);
    public sealed virtual bool IsTypeMapped(Type type);
}
public interface FluentNHibernate.Mapping.Providers.INestedCompositeElementMappingProvider {
    public abstract virtual NestedCompositeElementMapping GetCompositeElementMapping();
}
public interface FluentNHibernate.Mapping.Providers.IOneToOneMappingProvider {
    public abstract virtual OneToOneMapping GetOneToOneMapping();
}
public interface FluentNHibernate.Mapping.Providers.IPropertyMappingProvider {
    public abstract virtual PropertyMapping GetPropertyMapping();
}
public interface FluentNHibernate.Mapping.Providers.IReferenceComponentMappingProvider {
    public Type Type { get; }
    public abstract virtual Type get_Type();
}
public interface FluentNHibernate.Mapping.Providers.IStoredProcedureMappingProvider {
    public abstract virtual StoredProcedureMapping GetStoredProcedureMapping();
}
public interface FluentNHibernate.Mapping.Providers.ISubclassMappingProvider {
    public abstract virtual SubclassMapping GetSubclassMapping();
}
public interface FluentNHibernate.Mapping.Providers.IVersionMappingProvider {
    public abstract virtual VersionMapping GetVersionMapping();
}
public class FluentNHibernate.Mapping.ReferenceComponentPart`1 : object {
    [CompilerGeneratedAttribute]
private Member <property>P;
    [CompilerGeneratedAttribute]
private Type <containingEntityType>P;
    private string columnPrefix;
    private Type FluentNHibernate.Mapping.Providers.IReferenceComponentMappingProvider.Type { get; }
    public ReferenceComponentPart`1(Member property, Type containingEntityType);
    public void ColumnPrefix(string prefix);
    private sealed virtual override IComponentMapping FluentNHibernate.Mapping.Providers.IComponentMappingProvider.GetComponentMapping();
    private sealed virtual override Type FluentNHibernate.Mapping.Providers.IReferenceComponentMappingProvider.get_Type();
}
public class FluentNHibernate.Mapping.SchemaActionBuilder`1 : object {
    [CompilerGeneratedAttribute]
private T <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public SchemaActionBuilder`1(T parent, Action`1<string> setter);
    public T All();
    public T None();
    public T Drop();
    public T Update();
    public T Export();
    public T Validate();
    public T Custom(string customValue);
}
public class FluentNHibernate.Mapping.StoredProcedurePart : object {
    private StoredProcedureMapping mapping;
    public CheckTypeExpression`1<StoredProcedurePart> Check { get; }
    public StoredProcedurePart(string element, string innerText);
    public CheckTypeExpression`1<StoredProcedurePart> get_Check();
    private sealed virtual override StoredProcedureMapping FluentNHibernate.Mapping.Providers.IStoredProcedureMappingProvider.GetStoredProcedureMapping();
    [CompilerGeneratedAttribute]
private void <get_Check>b__3_0(string value);
}
public class FluentNHibernate.Mapping.SubclassMap`1 : ClasslikeMapBase`1<T> {
    private MappingProviderStore providers;
    private AttributeStore attributes;
    private IDictionary`2<Type, IIndeterminateSubclassMappingProvider> indetermineateSubclasses;
    private bool nextBool;
    private List`1<JoinMapping> joins;
    [DebuggerBrowsableAttribute("0")]
public SubclassMap`1<T> Not { get; }
    private Type FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider.EntityType { get; }
    private Type FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider.Extends { get; }
    protected SubclassMap`1(MappingProviderStore providers);
    public SubclassMap`1<T> get_Not();
    public void Abstract();
    public void DynamicInsert();
    public void DynamicUpdate();
    public void LazyLoad();
    public void Proxy();
    public void Proxy(Type proxyType);
    public void SelectBeforeUpdate();
    [ObsoleteAttribute("Use a new SubclassMap")]
public void Subclass(Action`1<SubclassMap`1<TSubclass>> subclassDefinition);
    public void DiscriminatorValue(object discriminatorValue);
    public void Table(string table);
    public void Schema(string schema);
    public void Check(string constraint);
    public void KeyColumn(string column);
    public void Subselect(string subselect);
    public void Persister();
    public void Persister(Type type);
    public void Persister(string type);
    public void BatchSize(int batchSize);
    public void EntityName(string entityname);
    public void Join(string tableName, Action`1<JoinPart`1<T>> action);
    public void Extends();
    public void Extends(Type type);
    private sealed virtual override SubclassMapping FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider.GetSubclassMapping(SubclassType type);
    private sealed virtual override Type FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider.get_EntityType();
    private sealed virtual override Type FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider.get_Extends();
    private void GenerateNestedSubclasses(SubclassMapping mapping);
    private string GetDefaultTableName();
}
[ObsoleteAttribute("REMOVE ME")]
public class FluentNHibernate.Mapping.SubClassPart`1 : ClasslikeMapBase`1<TSubclass> {
    private DiscriminatorPart parent;
    private object discriminatorValue;
    private MappingProviderStore providers;
    private AttributeStore attributes;
    private List`1<SubclassMapping> subclassMappings;
    private bool nextBool;
    [DebuggerBrowsableAttribute("0")]
public SubClassPart`1<TSubclass> Not { get; }
    public SubClassPart`1(DiscriminatorPart parent, object discriminatorValue);
    protected SubClassPart`1(DiscriminatorPart parent, object discriminatorValue, MappingProviderStore providers);
    private sealed virtual override SubclassMapping FluentNHibernate.Mapping.Providers.ISubclassMappingProvider.GetSubclassMapping();
    public DiscriminatorPart SubClass(object value, Action`1<SubClassPart`1<TChild>> action);
    public DiscriminatorPart SubClass(Action`1<SubClassPart`1<TChild>> action);
    public SubClassPart`1<TSubclass> LazyLoad();
    public SubClassPart`1<TSubclass> Proxy(Type type);
    public SubClassPart`1<TSubclass> Proxy();
    public SubClassPart`1<TSubclass> DynamicUpdate();
    public SubClassPart`1<TSubclass> DynamicInsert();
    public SubClassPart`1<TSubclass> SelectBeforeUpdate();
    public SubClassPart`1<TSubclass> Abstract();
    public void EntityName(string entityName);
    public SubClassPart`1<TSubclass> get_Not();
}
public abstract class FluentNHibernate.Mapping.ToManyBase`2 : object {
    protected ElementPart elementPart;
    protected ICompositeElementMappingProvider componentMapping;
    protected bool nextBool;
    protected AttributeStore collectionAttributes;
    protected KeyMapping keyMapping;
    protected AttributeStore relationshipAttributes;
    private Func`2<AttributeStore, CollectionMapping> collectionBuilder;
    private IndexMapping indexMapping;
    protected Member member;
    private List`1<IFilterMappingProvider> filters;
    [CompilerGeneratedAttribute]
private Type <EntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private CachePart <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionCascadeExpression`1<T> <Cascade>k__BackingField;
    [CompilerGeneratedAttribute]
private FetchTypeExpression`1<T> <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<T> <Access>k__BackingField;
    public Type EntityType { get; }
    public CachePart Cache { get; }
    public CollectionCascadeExpression`1<T> Cascade { get; }
    public FetchTypeExpression`1<T> Fetch { get; }
    public AccessStrategyBuilder`1<T> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public T Not { get; }
    protected IList`1<IFilterMappingProvider> Filters { get; }
    protected ToManyBase`2(Type entity, Member member, Type type);
    [CompilerGeneratedAttribute]
public Type get_EntityType();
    public T PropertyRef(string propertyRef);
    [CompilerGeneratedAttribute]
public CachePart get_Cache();
    public T LazyLoad();
    public T ExtraLazyLoad();
    public T Inverse();
    [CompilerGeneratedAttribute]
public CollectionCascadeExpression`1<T> get_Cascade();
    public T AsSet();
    public T AsSet(SortType sort);
    public T AsSet();
    public T AsBag();
    public T AsList();
    public T AsList(Action`1<ListIndexPart> customIndexMapping);
    public T AsMap(Expression`1<Func`2<TChild, TIndex>> indexSelector);
    public T AsMap(Expression`1<Func`2<TChild, TIndex>> indexSelector, SortType sort);
    public T AsMap(string indexColumnName);
    public T AsMap(string indexColumnName, SortType sort);
    public T AsMap(string indexColumnName);
    public T AsMap(string indexColumnName, SortType sort);
    public T AsMap(string indexColumnName);
    public T AsMap(Expression`1<Func`2<TChild, TIndex>> indexSelector, Action`1<IndexPart> customIndexMapping);
    public T AsMap(Expression`1<Func`2<TChild, TIndex>> indexSelector, Action`1<IndexPart> customIndexMapping, SortType sort);
    public T AsMap(Action`1<IndexPart> customIndexMapping, Action`1<ElementPart> customElementMapping);
    public T AsArray(Expression`1<Func`2<TChild, TIndex>> indexSelector);
    public T AsArray(Expression`1<Func`2<TChild, TIndex>> indexSelector, Action`1<IndexPart> customIndexMapping);
    public T AsIndexedCollection(Expression`1<Func`2<TChild, TIndex>> indexSelector, Action`1<IndexPart> customIndexMapping);
    public T AsIndexedCollection(string indexColumn, Action`1<IndexPart> customIndexMapping);
    private void CreateIndexMapping(Action`1<IndexPart> customIndex);
    private void CreateListIndexMapping(Action`1<ListIndexPart> customIndex);
    public T Element(string columnName);
    public T Element(string columnName, Action`1<ElementPart> customElementMapping);
    public T Component(Action`1<CompositeElementPart`1<TChild>> action);
    public T Table(string name);
    public T ForeignKeyCascadeOnDelete();
    [CompilerGeneratedAttribute]
public FetchTypeExpression`1<T> get_Fetch();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<T> get_Access();
    public T OptimisticLock();
    public T Persister();
    public T Check(string constraintName);
    public T Generic();
    public T Where(string where);
    public T BatchSize(int size);
    public T get_Not();
    public T CollectionType();
    public T CollectionType(Type type);
    public T CollectionType(string type);
    public T CollectionType(TypeReference type);
    public T Schema(string schema);
    public T EntityName(string entityName);
    public T ApplyFilter(string name, string condition);
    public T ApplyFilter(string name);
    public T ApplyFilter(string condition);
    public T ApplyFilter();
    protected IList`1<IFilterMappingProvider> get_Filters();
    private void SetDefaultCollectionType();
    private void SetDefaultAccess();
    private void SetCustomCollectionType(Type type);
    private sealed virtual override CollectionMapping FluentNHibernate.Mapping.Providers.ICollectionMappingProvider.GetCollectionMapping();
    protected virtual CollectionMapping GetCollectionMapping();
    private string GetDefaultName();
    protected abstract virtual ICollectionRelationshipMapping GetRelationship();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_2(string value);
}
public class FluentNHibernate.Mapping.TuplizerPart : object {
    [CompilerGeneratedAttribute]
private TuplizerMapping <mapping>P;
    public TuplizerPart(TuplizerMapping mapping);
    public TuplizerPart Type(Type type);
    public TuplizerPart Type(string type);
    public TuplizerPart Type();
    public TuplizerPart Mode(TuplizerMode mode);
    public TuplizerPart EntityName(string entityName);
}
public static class FluentNHibernate.Mapping.TypeMapping : object {
    public static string GetTypeString(Type type);
}
public class FluentNHibernate.Mapping.VersionGeneratedBuilder`1 : object {
    [CompilerGeneratedAttribute]
private TParent <parent>P;
    [CompilerGeneratedAttribute]
private Action`1<string> <setter>P;
    public VersionGeneratedBuilder`1(TParent parent, Action`1<string> setter);
    public TParent Always();
    public TParent Never();
}
public class FluentNHibernate.Mapping.VersionPart : object {
    private Type entity;
    private Member member;
    private AttributeStore attributes;
    private AttributeStore columnAttributes;
    private List`1<string> columns;
    private bool nextBool;
    [CompilerGeneratedAttribute]
private VersionGeneratedBuilder`1<VersionPart> <Generated>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessStrategyBuilder`1<VersionPart> <Access>k__BackingField;
    public VersionGeneratedBuilder`1<VersionPart> Generated { get; }
    public AccessStrategyBuilder`1<VersionPart> Access { get; }
    [DebuggerBrowsableAttribute("0")]
public VersionPart Not { get; }
    public VersionPart(Type entity, Member member);
    private void SetDefaultAccess();
    [CompilerGeneratedAttribute]
public VersionGeneratedBuilder`1<VersionPart> get_Generated();
    [CompilerGeneratedAttribute]
public AccessStrategyBuilder`1<VersionPart> get_Access();
    public VersionPart get_Not();
    public VersionPart Column(string name);
    public VersionPart UnsavedValue(string value);
    public VersionPart Length(int length);
    public VersionPart Precision(int precision);
    public VersionPart Scale(int scale);
    public VersionPart Nullable();
    public VersionPart Unique();
    public VersionPart UniqueKey(string keyColumns);
    public VersionPart Index(string index);
    public VersionPart Check(string constraint);
    public VersionPart Default(object value);
    public VersionPart CustomType();
    public VersionPart CustomType(Type type);
    public VersionPart CustomType(string type);
    public VersionPart CustomSqlType(string sqlType);
    private sealed virtual override VersionMapping FluentNHibernate.Mapping.Providers.IVersionMappingProvider.GetVersionMapping();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1(string value);
}
public class FluentNHibernate.MappingModel.AnyMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns typeColumns;
    private LayeredColumns identifierColumns;
    private List`1<MetaValueMapping> metaValues;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Name { get; }
    public string IdType { get; }
    public TypeReference MetaType { get; }
    public string Access { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public string Cascade { get; }
    public bool Lazy { get; }
    public bool OptimisticLock { get; }
    public IEnumerable`1<ColumnMapping> TypeColumns { get; }
    public IEnumerable`1<ColumnMapping> IdentifierColumns { get; }
    public IEnumerable`1<MetaValueMapping> MetaValues { get; }
    public Type ContainingEntityType { get; public set; }
    public AnyMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Name();
    public string get_IdType();
    public TypeReference get_MetaType();
    public string get_Access();
    public bool get_Insert();
    public bool get_Update();
    public string get_Cascade();
    public bool get_Lazy();
    public bool get_OptimisticLock();
    public IEnumerable`1<ColumnMapping> get_TypeColumns();
    public IEnumerable`1<ColumnMapping> get_IdentifierColumns();
    public IEnumerable`1<MetaValueMapping> get_MetaValues();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void AddTypeColumn(int layer, ColumnMapping column);
    public void AddIdentifierColumn(int layer, ColumnMapping column);
    public void AddMetaValue(MetaValueMapping metaValue);
    public sealed virtual bool Equals(AnyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<AnyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.AttributeStore : object {
    private AttributeLayeredValues layeredValues;
    public object Get(string property);
    public void Set(string attribute, int layer, object value);
    public bool IsSpecified(string attribute);
    public void CopyTo(AttributeStore theirStore);
    public AttributeStore Clone();
    public sealed virtual bool Equals(AttributeStore other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Merge(AttributeStore columnAttributes);
}
[ExtensionAttribute]
public static class FluentNHibernate.MappingModel.AttributeStoreExtensions : object {
    [ExtensionAttribute]
public static T GetOrDefault(AttributeStore store, string attribute);
}
public class FluentNHibernate.MappingModel.CacheMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainedEntityType>k__BackingField;
    public string Region { get; }
    public string Usage { get; }
    public string Include { get; }
    public Type ContainedEntityType { get; public set; }
    public CacheMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Region();
    public string get_Usage();
    public string get_Include();
    [CompilerGeneratedAttribute]
public Type get_ContainedEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainedEntityType(Type value);
    public sealed virtual bool Equals(CacheMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<CacheMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.ClassBased.ClassMapping : ClassMappingBase {
    private AttributeStore attributes;
    public IIdentityMapping Id { get; }
    public NaturalIdMapping NaturalId { get; }
    public string Name { get; }
    public Type Type { get; }
    public CacheMapping Cache { get; }
    public VersionMapping Version { get; }
    public DiscriminatorMapping Discriminator { get; }
    public bool IsUnionSubclass { get; }
    public TuplizerMapping Tuplizer { get; }
    public string TableName { get; }
    public int BatchSize { get; }
    public object DiscriminatorValue { get; }
    public string Schema { get; }
    public bool Lazy { get; }
    public bool Mutable { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public string OptimisticLock { get; }
    public string Polymorphism { get; }
    public string Persister { get; }
    public string Where { get; }
    public string Check { get; }
    public string Proxy { get; }
    public bool SelectBeforeUpdate { get; }
    public bool Abstract { get; }
    public string Subselect { get; }
    public string SchemaAction { get; }
    public string EntityName { get; }
    public ClassMapping(AttributeStore attributes);
    public IIdentityMapping get_Id();
    public NaturalIdMapping get_NaturalId();
    public virtual string get_Name();
    public virtual Type get_Type();
    public CacheMapping get_Cache();
    public VersionMapping get_Version();
    public DiscriminatorMapping get_Discriminator();
    public bool get_IsUnionSubclass();
    public TuplizerMapping get_Tuplizer();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_TableName();
    public int get_BatchSize();
    public object get_DiscriminatorValue();
    public string get_Schema();
    public bool get_Lazy();
    public bool get_Mutable();
    public bool get_DynamicUpdate();
    public bool get_DynamicInsert();
    public string get_OptimisticLock();
    public string get_Polymorphism();
    public string get_Persister();
    public string get_Where();
    public string get_Check();
    public string get_Proxy();
    public bool get_SelectBeforeUpdate();
    public bool get_Abstract();
    public string get_Subselect();
    public string get_SchemaAction();
    public string get_EntityName();
    public sealed virtual bool Equals(ClassMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ClassMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public abstract class FluentNHibernate.MappingModel.ClassBased.ClassMappingBase : MappingBase {
    private AttributeStore attributes;
    private MappedMembers mappedMembers;
    private List`1<SubclassMapping> subclasses;
    public string Name { get; }
    public Type Type { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<OneToOneMapping> OneToOnes { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public IEnumerable`1<JoinMapping> Joins { get; }
    public IEnumerable`1<FilterMapping> Filters { get; }
    public IEnumerable`1<SubclassMapping> Subclasses { get; }
    public IEnumerable`1<StoredProcedureMapping> StoredProcedures { get; }
    protected ClassMappingBase(AttributeStore attributes);
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual IEnumerable`1<ManyToOneMapping> get_References();
    public sealed virtual IEnumerable`1<CollectionMapping> get_Collections();
    public sealed virtual IEnumerable`1<PropertyMapping> get_Properties();
    public sealed virtual IEnumerable`1<IComponentMapping> get_Components();
    public sealed virtual IEnumerable`1<OneToOneMapping> get_OneToOnes();
    public sealed virtual IEnumerable`1<AnyMapping> get_Anys();
    public IEnumerable`1<JoinMapping> get_Joins();
    public sealed virtual IEnumerable`1<FilterMapping> get_Filters();
    public IEnumerable`1<SubclassMapping> get_Subclasses();
    public IEnumerable`1<StoredProcedureMapping> get_StoredProcedures();
    public sealed virtual void AddProperty(PropertyMapping property);
    public void AddOrReplaceProperty(PropertyMapping mapping);
    public sealed virtual void AddCollection(CollectionMapping collection);
    public void AddOrReplaceCollection(CollectionMapping mapping);
    public sealed virtual void AddReference(ManyToOneMapping manyToOne);
    public void AddOrReplaceReference(ManyToOneMapping manyToOne);
    public sealed virtual void AddComponent(IComponentMapping componentMapping);
    public void AddOrReplaceComponent(IComponentMapping mapping);
    public sealed virtual void AddOneToOne(OneToOneMapping mapping);
    public void AddOrReplaceOneToOne(OneToOneMapping mapping);
    public sealed virtual void AddAny(AnyMapping mapping);
    public void AddOrReplaceAny(AnyMapping mapping);
    public void AddJoin(JoinMapping mapping);
    public void AddOrReplaceJoin(JoinMapping mapping);
    public sealed virtual void AddFilter(FilterMapping mapping);
    public void AddOrReplaceFilter(FilterMapping mapping);
    public void AddSubclass(SubclassMapping subclass);
    public void AddStoredProcedure(StoredProcedureMapping mapping);
    public virtual string ToString();
    public bool Equals(ClassMappingBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void MergeAttributes(AttributeStore clone);
}
public class FluentNHibernate.MappingModel.ClassBased.ComponentMapping : ComponentMappingBase {
    [CompilerGeneratedAttribute]
private ComponentType <ComponentType>k__BackingField;
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private string <ColumnPrefix>k__BackingField;
    public ComponentType ComponentType { get; public set; }
    public bool HasColumnPrefix { get; }
    public string ColumnPrefix { get; public set; }
    public string Name { get; }
    public Type Type { get; }
    public TypeReference Class { get; }
    public bool Lazy { get; }
    public ComponentMapping(ComponentType componentType);
    public ComponentMapping(ComponentType componentType, AttributeStore attributes, Member member);
    [CompilerGeneratedAttribute]
public sealed virtual ComponentType get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(ComponentType value);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool get_HasColumnPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnPrefix();
    [CompilerGeneratedAttribute]
public void set_ColumnPrefix(string value);
    public virtual string get_Name();
    public virtual Type get_Type();
    public sealed virtual TypeReference get_Class();
    public sealed virtual bool get_Lazy();
    public sealed virtual bool Equals(ComponentMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ComponentMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public abstract class FluentNHibernate.MappingModel.ClassBased.ComponentMappingBase : ClassMappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public Member Member { get; public set; }
    public ParentMapping Parent { get; }
    public bool Unique { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    protected ComponentMappingBase(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public sealed virtual ParentMapping get_Parent();
    public sealed virtual bool get_Unique();
    public sealed virtual bool get_Insert();
    public sealed virtual bool get_Update();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public bool Equals(ComponentMappingBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class FluentNHibernate.MappingModel.ClassBased.ComponentType : object {
    public static ComponentType Component;
    public static ComponentType DynamicComponent;
    private string elementName;
    private ComponentType(string elementName);
    private static ComponentType();
    public string GetElementName();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(ComponentType other);
    public virtual int GetHashCode();
    public static bool op_Equality(ComponentType left, ComponentType right);
    public static bool op_Inequality(ComponentType left, ComponentType right);
}
public class FluentNHibernate.MappingModel.ClassBased.ExternalComponentMapping : ComponentMapping {
    public ExternalComponentMapping(ComponentType componentType, AttributeStore underlyingStore, Member member);
    public ExternalComponentMapping(ComponentType componentType);
}
public interface FluentNHibernate.MappingModel.ClassBased.IComponentMapping {
    public bool HasColumnPrefix { get; }
    public string ColumnPrefix { get; }
    public ParentMapping Parent { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public string Access { get; }
    public Type ContainingEntityType { get; }
    public string Name { get; }
    public Member Member { get; }
    public Type Type { get; }
    public bool OptimisticLock { get; }
    public bool Unique { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<OneToOneMapping> OneToOnes { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public ComponentType ComponentType { get; }
    public TypeReference Class { get; }
    public bool Lazy { get; }
    public abstract virtual bool get_HasColumnPrefix();
    public abstract virtual string get_ColumnPrefix();
    public abstract virtual ParentMapping get_Parent();
    public abstract virtual bool get_Insert();
    public abstract virtual bool get_Update();
    public abstract virtual string get_Access();
    public abstract virtual Type get_ContainingEntityType();
    public abstract virtual string get_Name();
    public abstract virtual Member get_Member();
    public abstract virtual Type get_Type();
    public abstract virtual bool get_OptimisticLock();
    public abstract virtual bool get_Unique();
    public abstract virtual IEnumerable`1<ManyToOneMapping> get_References();
    public abstract virtual IEnumerable`1<CollectionMapping> get_Collections();
    public abstract virtual IEnumerable`1<PropertyMapping> get_Properties();
    public abstract virtual IEnumerable`1<IComponentMapping> get_Components();
    public abstract virtual IEnumerable`1<OneToOneMapping> get_OneToOnes();
    public abstract virtual IEnumerable`1<AnyMapping> get_Anys();
    public abstract virtual ComponentType get_ComponentType();
    public abstract virtual TypeReference get_Class();
    public abstract virtual bool get_Lazy();
    public abstract virtual void AddProperty(PropertyMapping mapping);
    public abstract virtual void AddComponent(IComponentMapping mapping);
    public abstract virtual void AddOneToOne(OneToOneMapping mapping);
    public abstract virtual void AddCollection(CollectionMapping mapping);
    public abstract virtual void AddReference(ManyToOneMapping mapping);
    public abstract virtual void AddAny(AnyMapping mapping);
}
public class FluentNHibernate.MappingModel.ClassBased.ReferenceComponentMapping : object {
    [CompilerGeneratedAttribute]
private ComponentType <ComponentType>k__BackingField;
    private Member property;
    private Type componentType;
    private ExternalComponentMapping mergedComponent;
    private Type containingEntityType;
    [CompilerGeneratedAttribute]
private string <ColumnPrefix>k__BackingField;
    public ComponentType ComponentType { get; public set; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<OneToOneMapping> OneToOnes { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public Type ContainingEntityType { get; public set; }
    public Member Member { get; }
    public ParentMapping Parent { get; }
    public bool Unique { get; }
    public bool HasColumnPrefix { get; }
    public string ColumnPrefix { get; public set; }
    public bool Insert { get; }
    public bool Update { get; }
    public string Access { get; }
    public bool OptimisticLock { get; }
    public string Name { get; }
    public Type Type { get; }
    public TypeReference Class { get; }
    public bool Lazy { get; }
    public bool IsAssociated { get; }
    public ComponentMapping MergedModel { get; }
    public ReferenceComponentMapping(ComponentType componentType, Member property, Type componentEntityType, Type containingEntityType, string columnPrefix);
    [CompilerGeneratedAttribute]
public sealed virtual ComponentType get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(ComponentType value);
    public sealed virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool IsSpecified(string name);
    public sealed virtual void Set(string attribute, int layer, object value);
    public virtual void AssociateExternalMapping(ExternalComponentMapping mapping);
    public sealed virtual IEnumerable`1<ManyToOneMapping> get_References();
    public sealed virtual IEnumerable`1<CollectionMapping> get_Collections();
    public sealed virtual IEnumerable`1<PropertyMapping> get_Properties();
    public sealed virtual IEnumerable`1<IComponentMapping> get_Components();
    public sealed virtual IEnumerable`1<OneToOneMapping> get_OneToOnes();
    public sealed virtual IEnumerable`1<AnyMapping> get_Anys();
    public sealed virtual void AddProperty(PropertyMapping property);
    public sealed virtual void AddCollection(CollectionMapping collection);
    public sealed virtual void AddReference(ManyToOneMapping manyToOne);
    public sealed virtual void AddComponent(IComponentMapping componentMapping);
    public sealed virtual void AddOneToOne(OneToOneMapping mapping);
    public sealed virtual void AddAny(AnyMapping mapping);
    public sealed virtual Type get_ContainingEntityType();
    public void set_ContainingEntityType(Type value);
    public sealed virtual Member get_Member();
    public sealed virtual ParentMapping get_Parent();
    public sealed virtual bool get_Unique();
    public sealed virtual bool get_HasColumnPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnPrefix();
    [CompilerGeneratedAttribute]
public void set_ColumnPrefix(string value);
    public sealed virtual bool get_Insert();
    public sealed virtual bool get_Update();
    public sealed virtual string get_Access();
    public sealed virtual bool get_OptimisticLock();
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public sealed virtual TypeReference get_Class();
    public sealed virtual bool get_Lazy();
    public bool get_IsAssociated();
    public ComponentMapping get_MergedModel();
    public sealed virtual bool Equals(ReferenceComponentMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class FluentNHibernate.MappingModel.ClassBased.SubclassMapping : ClassMappingBase {
    [CompilerGeneratedAttribute]
private SubclassType <SubclassType>k__BackingField;
    private AttributeStore attributes;
    public SubclassType SubclassType { get; }
    public Type Extends { get; }
    public string Name { get; }
    public Type Type { get; }
    public object DiscriminatorValue { get; }
    public bool Lazy { get; }
    public string Proxy { get; }
    public bool DynamicUpdate { get; }
    public bool DynamicInsert { get; }
    public bool SelectBeforeUpdate { get; }
    public bool Abstract { get; }
    public string EntityName { get; }
    public string TableName { get; }
    public KeyMapping Key { get; }
    public string Check { get; }
    public string Schema { get; }
    public string Subselect { get; }
    public TypeReference Persister { get; }
    public int BatchSize { get; }
    public SubclassMapping(SubclassType subclassType, AttributeStore attributes);
    public SubclassMapping(SubclassType subclassType);
    [CompilerGeneratedAttribute]
public SubclassType get_SubclassType();
    public Type get_Extends();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public virtual string get_Name();
    public virtual Type get_Type();
    public object get_DiscriminatorValue();
    public bool get_Lazy();
    public string get_Proxy();
    public bool get_DynamicUpdate();
    public bool get_DynamicInsert();
    public bool get_SelectBeforeUpdate();
    public bool get_Abstract();
    public string get_EntityName();
    public string get_TableName();
    public KeyMapping get_Key();
    public string get_Check();
    public string get_Schema();
    public string get_Subselect();
    public TypeReference get_Persister();
    public int get_BatchSize();
    public void OverrideAttributes(AttributeStore store);
    public sealed virtual bool Equals(SubclassMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void Set(Expression`1<Func`2<SubclassMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.ClassBased.SubclassType : object {
    public static SubclassType Subclass;
    public static SubclassType JoinedSubclass;
    public static SubclassType UnionSubclass;
    private string elementName;
    private SubclassType(string elementName);
    private static SubclassType();
    public string GetElementName();
    public sealed virtual bool Equals(SubclassType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(SubclassType left, SubclassType right);
    public static bool op_Inequality(SubclassType left, SubclassType right);
}
[DefaultMemberAttribute("Item")]
public class FluentNHibernate.MappingModel.Collections.AttributeLayeredValues : object {
    private Dictionary`2<string, LayeredValues> inner;
    public LayeredValues Item { get; }
    public AttributeLayeredValues(SerializationInfo info, StreamingContext context);
    public LayeredValues get_Item(string attribute);
    private void EnsureValueExists(string attribute);
    public bool ContainsKey(string attribute);
    public void CopyTo(AttributeLayeredValues other);
    public bool ContentEquals(AttributeLayeredValues other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AttributeLayeredValues other);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
private bool <ContentEquals>b__8_0(string key);
}
public enum FluentNHibernate.MappingModel.Collections.Collection : Enum {
    public int value__;
    public static Collection Array;
    public static Collection Bag;
    public static Collection Map;
    public static Collection List;
    public static Collection Set;
}
public class FluentNHibernate.MappingModel.Collections.CollectionMapping : MappingBase {
    private AttributeStore attributes;
    private List`1<FilterMapping> filters;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private IRelationship <OtherSide>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection <Collection>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public Member Member { get; public set; }
    public IEnumerable`1<FilterMapping> Filters { get; }
    public Type ChildType { get; }
    public IRelationship OtherSide { get; public set; }
    public KeyMapping Key { get; }
    public ElementMapping Element { get; }
    public CompositeElementMapping CompositeElement { get; }
    public CacheMapping Cache { get; }
    public ICollectionRelationshipMapping Relationship { get; }
    public bool Generic { get; }
    public Lazy Lazy { get; }
    public bool Inverse { get; }
    public string Name { get; }
    public string Access { get; }
    public string TableName { get; }
    public string Schema { get; }
    public string Fetch { get; }
    public string Cascade { get; }
    public string Where { get; }
    public bool Mutable { get; }
    public string Subselect { get; }
    public TypeReference Persister { get; }
    public int BatchSize { get; }
    public string Check { get; }
    public TypeReference CollectionType { get; }
    public bool OptimisticLock { get; }
    public string OrderBy { get; }
    public Collection Collection { get; public set; }
    public string Sort { get; }
    public IIndexMapping Index { get; }
    private CollectionMapping(AttributeStore attributes);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    [CompilerGeneratedAttribute]
public Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public IEnumerable`1<FilterMapping> get_Filters();
    public void AddFilter(FilterMapping mapping);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public Type get_ChildType();
    [CompilerGeneratedAttribute]
public sealed virtual IRelationship get_OtherSide();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OtherSide(IRelationship value);
    public KeyMapping get_Key();
    public ElementMapping get_Element();
    public CompositeElementMapping get_CompositeElement();
    public CacheMapping get_Cache();
    public ICollectionRelationshipMapping get_Relationship();
    public bool get_Generic();
    public Lazy get_Lazy();
    public bool get_Inverse();
    public string get_Name();
    public string get_Access();
    public string get_TableName();
    public string get_Schema();
    public string get_Fetch();
    public string get_Cascade();
    public string get_Where();
    public bool get_Mutable();
    public string get_Subselect();
    public TypeReference get_Persister();
    public int get_BatchSize();
    public string get_Check();
    public TypeReference get_CollectionType();
    public bool get_OptimisticLock();
    public string get_OrderBy();
    [CompilerGeneratedAttribute]
public Collection get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(Collection value);
    public string get_Sort();
    public IIndexMapping get_Index();
    public sealed virtual bool Equals(CollectionMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<CollectionMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
    public static CollectionMapping Array();
    public static CollectionMapping Array(AttributeStore underlyingStore);
    public static CollectionMapping Bag();
    public static CollectionMapping Bag(AttributeStore underlyingStore);
    public static CollectionMapping List();
    public static CollectionMapping List(AttributeStore underlyingStore);
    public static CollectionMapping Map();
    public static CollectionMapping Map(AttributeStore underlyingStore);
    public static CollectionMapping Set();
    public static CollectionMapping Set(AttributeStore underlyingStore);
    public static CollectionMapping For(Collection collectionType);
    public static CollectionMapping For(Collection collectionType, AttributeStore underlyingStore);
}
public class FluentNHibernate.MappingModel.Collections.CompositeElementMapping : MappingBase {
    private MappedMembers mappedMembers;
    private List`1<NestedCompositeElementMapping> compositeElements;
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public TypeReference Class { get; }
    public ParentMapping Parent { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<NestedCompositeElementMapping> CompositeElements { get; }
    public Type ContainingEntityType { get; public set; }
    public CompositeElementMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public TypeReference get_Class();
    public ParentMapping get_Parent();
    public IEnumerable`1<PropertyMapping> get_Properties();
    public void AddProperty(PropertyMapping property);
    public IEnumerable`1<ManyToOneMapping> get_References();
    public IEnumerable`1<NestedCompositeElementMapping> get_CompositeElements();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void AddReference(ManyToOneMapping manyToOne);
    public void AddCompositeElement(NestedCompositeElementMapping compositeElement);
    public sealed virtual bool Equals(CompositeElementMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<CompositeElementMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Collections.ElementMapping : MappingBase {
    private LayeredColumns columns;
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public TypeReference Type { get; }
    public string Formula { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public Type ContainingEntityType { get; public set; }
    public ElementMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public TypeReference get_Type();
    public string get_Formula();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(ElementMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ElementMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public interface FluentNHibernate.MappingModel.Collections.ICollectionRelationshipMapping {
    public Type ChildType { get; }
    public TypeReference Class { get; }
    public string NotFound { get; }
    public string EntityName { get; }
    public abstract virtual Type get_ChildType();
    public abstract virtual TypeReference get_Class();
    public abstract virtual string get_NotFound();
    public abstract virtual string get_EntityName();
}
public interface FluentNHibernate.MappingModel.Collections.IIndexMapping {
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public abstract virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public abstract virtual IEnumerable`1<ColumnMapping> get_Columns();
}
public class FluentNHibernate.MappingModel.Collections.IndexManyToManyMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public TypeReference Class { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public string ForeignKey { get; }
    public string EntityName { get; }
    public IndexManyToManyMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public TypeReference get_Class();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public string get_ForeignKey();
    public string get_EntityName();
    public sealed virtual bool Equals(IndexManyToManyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<IndexManyToManyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Collections.IndexMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public TypeReference Type { get; }
    public int Offset { get; }
    public Type ContainingEntityType { get; public set; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public IndexMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public TypeReference get_Type();
    public int get_Offset();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public sealed virtual bool Equals(IndexMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<IndexMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Collections.LayeredColumns : object {
    private LayeredValues layeredValues;
    public IEnumerable`1<ColumnMapping> Columns { get; }
    [IteratorStateMachineAttribute("FluentNHibernate.MappingModel.Collections.LayeredColumns/<get_Columns>d__2")]
public IEnumerable`1<ColumnMapping> get_Columns();
    public void AddColumn(int layer, ColumnMapping mapping);
    public void MakeColumnsEmpty(int layer);
    public bool ContentEquals(LayeredColumns columns);
}
public class FluentNHibernate.MappingModel.Collections.LayeredValues : Dictionary`2<int, object> {
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected LayeredValues(SerializationInfo info, StreamingContext context);
}
public enum FluentNHibernate.MappingModel.Collections.Lazy : Enum {
    public int value__;
    public static Lazy False;
    public static Lazy True;
    public static Lazy Extra;
}
public class FluentNHibernate.MappingModel.Collections.ManyToManyMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns columns;
    private List`1<FilterMapping> childFilters;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public IList`1<FilterMapping> ChildFilters { get; }
    public Type ChildType { get; }
    public Type ParentType { get; }
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public string Fetch { get; }
    public string NotFound { get; }
    public string Where { get; }
    public bool Lazy { get; }
    public string EntityName { get; }
    public string OrderBy { get; }
    public string ChildPropertyRef { get; }
    public Type ContainingEntityType { get; public set; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public ManyToManyMapping(AttributeStore attributes);
    public IList`1<FilterMapping> get_ChildFilters();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual Type get_ChildType();
    public Type get_ParentType();
    public sealed virtual TypeReference get_Class();
    public string get_ForeignKey();
    public string get_Fetch();
    public sealed virtual string get_NotFound();
    public string get_Where();
    public bool get_Lazy();
    public sealed virtual string get_EntityName();
    public string get_OrderBy();
    public string get_ChildPropertyRef();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public sealed virtual bool Equals(ManyToManyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ManyToManyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Collections.NestedCompositeElementMapping : CompositeElementMapping {
    private AttributeStore attributes;
    public string Name { get; }
    public string Access { get; }
    public NestedCompositeElementMapping(AttributeStore attributes);
    public string get_Name();
    public string get_Access();
    public void Set(Expression`1<Func`2<NestedCompositeElementMapping, T>> expression, int layer, T value);
}
public class FluentNHibernate.MappingModel.Collections.OneToManyMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public Type ChildType { get; }
    public TypeReference Class { get; }
    public string NotFound { get; }
    public string EntityName { get; }
    public Type ContainingEntityType { get; public set; }
    public OneToManyMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual Type get_ChildType();
    public sealed virtual TypeReference get_Class();
    public sealed virtual string get_NotFound();
    public sealed virtual string get_EntityName();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(OneToManyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<OneToManyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public enum FluentNHibernate.MappingModel.Collections.SortType : Enum {
    public int value__;
    public static SortType Unsorted;
    public static SortType Natural;
}
public abstract class FluentNHibernate.MappingModel.ColumnBasedMappingBase : MappingBase {
    private LayeredColumns columns;
    protected AttributeStore attributes;
    public IEnumerable`1<ColumnMapping> Columns { get; }
    protected ColumnBasedMappingBase(AttributeStore underlyingStore);
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public bool Equals(ColumnBasedMappingBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class FluentNHibernate.MappingModel.ColumnMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    public Member Member { get; public set; }
    public string Name { get; }
    public int Length { get; }
    public bool NotNull { get; }
    public bool Nullable { get; }
    public bool Unique { get; }
    public string UniqueKey { get; }
    public string SqlType { get; }
    public string Index { get; }
    public string Check { get; }
    public int Precision { get; }
    public int Scale { get; }
    public string Default { get; }
    public ColumnMapping(AttributeStore attributes);
    public ColumnMapping(string defaultColumnName);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public string get_Name();
    public int get_Length();
    public bool get_NotNull();
    public bool get_Nullable();
    public bool get_Unique();
    public string get_UniqueKey();
    public string get_SqlType();
    public string get_Index();
    public string get_Check();
    public int get_Precision();
    public int get_Scale();
    public string get_Default();
    public ColumnMapping Clone();
    public sealed virtual bool Equals(ColumnMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ColumnMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
    public void MergeAttributes(AttributeStore columnAttributes);
}
public class FluentNHibernate.MappingModel.Conventions.ConventionException : Exception {
    [CompilerGeneratedAttribute]
private object <ConventionTarget>k__BackingField;
    public object ConventionTarget { get; }
    public ConventionException(string message, object conventionTarget);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected ConventionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_ConventionTarget();
}
public class FluentNHibernate.MappingModel.DiscriminatorMapping : ColumnBasedMappingBase {
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public bool Force { get; }
    public bool Insert { get; }
    public string Formula { get; }
    public TypeReference Type { get; }
    public Type ContainingEntityType { get; public set; }
    public DiscriminatorMapping(AttributeStore underlyingStore);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public bool get_Force();
    public bool get_Insert();
    public string get_Formula();
    public TypeReference get_Type();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(DiscriminatorMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<DiscriminatorMapping, object>> expression, int layer, object value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
[ExtensionAttribute]
public static class FluentNHibernate.MappingModel.EqualityExtensions : object {
    [ExtensionAttribute]
public static bool ContentEquals(IDictionary`2<TKey, TValue> left, IDictionary`2<TKey, TValue> right);
    [ExtensionAttribute]
public static bool ContentEquals(IEnumerable`1<T> left, IEnumerable`1<T> right);
}
public class FluentNHibernate.MappingModel.FilterDefinitionMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IType> <Parameters>k__BackingField;
    public IDictionary`2<string, IType> Parameters { get; }
    public string Name { get; }
    public string Condition { get; }
    public FilterDefinitionMapping(AttributeStore attributes);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IType> get_Parameters();
    public string get_Name();
    public string get_Condition();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool Equals(FilterDefinitionMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<FilterDefinitionMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.FilterMapping : object {
    private AttributeStore attributes;
    public string Name { get; }
    public string Condition { get; }
    public FilterMapping(AttributeStore attributes);
    public string get_Name();
    public string get_Condition();
    public sealed virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool IsSpecified(string property);
    public sealed virtual bool Equals(FilterMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<FilterMapping, T>> expression, int layer, T value);
    public sealed virtual void Set(string attribute, int layer, object value);
}
public class FluentNHibernate.MappingModel.HibernateMapping : MappingBase {
    private List`1<ClassMapping> classes;
    private List`1<FilterDefinitionMapping> filters;
    private List`1<ImportMapping> imports;
    private AttributeStore attributes;
    public IEnumerable`1<ClassMapping> Classes { get; }
    public IEnumerable`1<FilterDefinitionMapping> Filters { get; }
    public IEnumerable`1<ImportMapping> Imports { get; }
    public string Catalog { get; }
    public string DefaultAccess { get; }
    public string DefaultCascade { get; }
    public bool AutoImport { get; }
    public string Schema { get; }
    public bool DefaultLazy { get; }
    public string Namespace { get; }
    public string Assembly { get; }
    public HibernateMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public IEnumerable`1<ClassMapping> get_Classes();
    public IEnumerable`1<FilterDefinitionMapping> get_Filters();
    public IEnumerable`1<ImportMapping> get_Imports();
    public void AddClass(ClassMapping classMapping);
    public void AddFilter(FilterDefinitionMapping filterMapping);
    public void AddImport(ImportMapping importMapping);
    public string get_Catalog();
    public string get_DefaultAccess();
    public string get_DefaultCascade();
    public bool get_AutoImport();
    public string get_Schema();
    public bool get_DefaultLazy();
    public string get_Namespace();
    public string get_Assembly();
    public sealed virtual bool Equals(HibernateMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<HibernateMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Identity.CompositeIdMapping : MappingBase {
    private AttributeStore attributes;
    private List`1<ICompositeIdKeyMapping> keys;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Name { get; }
    public string Access { get; }
    public bool Mapped { get; }
    public TypeReference Class { get; }
    public string UnsavedValue { get; }
    public IEnumerable`1<ICompositeIdKeyMapping> Keys { get; }
    public Type ContainingEntityType { get; public set; }
    public CompositeIdMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Name();
    public string get_Access();
    public bool get_Mapped();
    public TypeReference get_Class();
    public string get_UnsavedValue();
    public IEnumerable`1<ICompositeIdKeyMapping> get_Keys();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void AddKey(ICompositeIdKeyMapping mapping);
    public sealed virtual bool Equals(CompositeIdMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<CompositeIdMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Identity.GeneratorMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Class { get; }
    public IDictionary`2<string, string> Params { get; }
    public Type ContainingEntityType { get; public set; }
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Class();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Params();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(GeneratorMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<GeneratorMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public interface FluentNHibernate.MappingModel.Identity.ICompositeIdKeyMapping {
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public string Name { get; }
    public string Access { get; }
    public abstract virtual IEnumerable`1<ColumnMapping> get_Columns();
    public abstract virtual string get_Name();
    public abstract virtual string get_Access();
}
public class FluentNHibernate.MappingModel.Identity.IdMapping : ColumnBasedMappingBase {
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public Member Member { get; public set; }
    public GeneratorMapping Generator { get; }
    public string Name { get; }
    public string Access { get; }
    public TypeReference Type { get; }
    public string UnsavedValue { get; }
    public Type ContainingEntityType { get; public set; }
    public IdMapping(AttributeStore underlyingStore);
    [CompilerGeneratedAttribute]
public Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public GeneratorMapping get_Generator();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Name();
    public string get_Access();
    public TypeReference get_Type();
    public string get_UnsavedValue();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void Set(Expression`1<Func`2<IdMapping, object>> expression, int layer, object value);
    protected virtual void Set(string attribute, int layer, object value);
    public sealed virtual bool Equals(IdMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsSpecified(string attribute);
}
public interface FluentNHibernate.MappingModel.Identity.IIdentityMapping {
}
public class FluentNHibernate.MappingModel.Identity.KeyManyToOneMapping : MappingBase {
    private AttributeStore attributes;
    private List`1<ColumnMapping> columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Access { get; }
    public string Name { get; }
    public TypeReference Class { get; }
    public string ForeignKey { get; }
    public bool Lazy { get; }
    public string NotFound { get; }
    public string EntityName { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public Type ContainingEntityType { get; public set; }
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual string get_Access();
    public sealed virtual string get_Name();
    public TypeReference get_Class();
    public string get_ForeignKey();
    public bool get_Lazy();
    public string get_NotFound();
    public string get_EntityName();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void AddColumn(ColumnMapping mapping);
    public sealed virtual bool Equals(KeyManyToOneMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<KeyManyToOneMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.Identity.KeyPropertyMapping : MappingBase {
    private AttributeStore attributes;
    private List`1<ColumnMapping> columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Name { get; }
    public string Access { get; }
    public TypeReference Type { get; }
    public int Length { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public Type ContainingEntityType { get; public set; }
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual string get_Name();
    public sealed virtual string get_Access();
    public TypeReference get_Type();
    public int get_Length();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public void AddColumn(ColumnMapping mapping);
    public sealed virtual bool Equals(KeyPropertyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<KeyPropertyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public interface FluentNHibernate.MappingModel.IHasColumnMappings {
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public abstract virtual IEnumerable`1<ColumnMapping> get_Columns();
    public abstract virtual void AddColumn(int layer, ColumnMapping column);
    public abstract virtual void MakeColumnsEmpty(int layer);
}
public interface FluentNHibernate.MappingModel.IHasMappedMembers {
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<OneToOneMapping> OneToOnes { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public IEnumerable`1<FilterMapping> Filters { get; }
    public abstract virtual IEnumerable`1<PropertyMapping> get_Properties();
    public abstract virtual IEnumerable`1<CollectionMapping> get_Collections();
    public abstract virtual IEnumerable`1<ManyToOneMapping> get_References();
    public abstract virtual IEnumerable`1<IComponentMapping> get_Components();
    public abstract virtual IEnumerable`1<OneToOneMapping> get_OneToOnes();
    public abstract virtual IEnumerable`1<AnyMapping> get_Anys();
    public abstract virtual IEnumerable`1<FilterMapping> get_Filters();
    public abstract virtual void AddProperty(PropertyMapping property);
    public abstract virtual void AddCollection(CollectionMapping collection);
    public abstract virtual void AddReference(ManyToOneMapping manyToOne);
    public abstract virtual void AddComponent(IComponentMapping component);
    public abstract virtual void AddOneToOne(OneToOneMapping mapping);
    public abstract virtual void AddAny(AnyMapping mapping);
    public abstract virtual void AddFilter(FilterMapping mapping);
}
public interface FluentNHibernate.MappingModel.IMapping {
    public abstract virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public abstract virtual bool IsSpecified(string attribute);
    public abstract virtual void Set(string attribute, int layer, object value);
}
public class FluentNHibernate.MappingModel.ImportMapping : MappingBase {
    private AttributeStore attributes;
    public string Rename { get; }
    public TypeReference Class { get; }
    public ImportMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Rename();
    public TypeReference get_Class();
    public sealed virtual bool Equals(ImportMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsSpecified(string attribute);
    protected virtual void Set(string attribute, int layer, object value);
}
public interface FluentNHibernate.MappingModel.IRelationship {
    public IRelationship OtherSide { get; public set; }
    public abstract virtual IRelationship get_OtherSide();
    public abstract virtual void set_OtherSide(IRelationship value);
}
public class FluentNHibernate.MappingModel.JoinMapping : object {
    private AttributeStore attributes;
    private MappedMembers mappedMembers;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public KeyMapping Key { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public string TableName { get; }
    public string Schema { get; }
    public string Catalog { get; }
    public string Subselect { get; }
    public string Fetch { get; }
    public bool Inverse { get; }
    public bool Optional { get; }
    public Type ContainingEntityType { get; public set; }
    public JoinMapping(AttributeStore attributes);
    public KeyMapping get_Key();
    public IEnumerable`1<PropertyMapping> get_Properties();
    public IEnumerable`1<ManyToOneMapping> get_References();
    public IEnumerable`1<IComponentMapping> get_Components();
    public IEnumerable`1<AnyMapping> get_Anys();
    public IEnumerable`1<CollectionMapping> get_Collections();
    public void AddProperty(PropertyMapping property);
    public void AddReference(ManyToOneMapping manyToOne);
    public void AddComponent(IComponentMapping componentMapping);
    public void AddAny(AnyMapping mapping);
    public void AddCollection(CollectionMapping collectionMapping);
    public void AddStoredProcedure(StoredProcedureMapping storedProcedureMapping);
    public string get_TableName();
    public string get_Schema();
    public string get_Catalog();
    public string get_Subselect();
    public string get_Fetch();
    public bool get_Inverse();
    public bool get_Optional();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool Equals(JoinMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<JoinMapping, T>> expression, int layer, T value);
    public sealed virtual void Set(string attribute, int layer, object value);
    public sealed virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.KeyMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public string ForeignKey { get; }
    public string PropertyRef { get; }
    public string OnDelete { get; }
    public bool NotNull { get; }
    public bool Update { get; }
    public bool Unique { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public KeyMapping(AttributeStore attributes);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_ForeignKey();
    public string get_PropertyRef();
    public string get_OnDelete();
    public bool get_NotNull();
    public bool get_Update();
    public bool get_Unique();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public sealed virtual bool Equals(KeyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<KeyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public static class FluentNHibernate.MappingModel.Layer : object {
    public static int Defaults;
    public static int Conventions;
    public static int UserSupplied;
}
public class FluentNHibernate.MappingModel.ManyToOneMapping : MappingBase {
    private AttributeStore attributes;
    private LayeredColumns columns;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private IRelationship <OtherSide>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public Member Member { get; public set; }
    public string Name { get; }
    public string Access { get; }
    public TypeReference Class { get; }
    public string Cascade { get; }
    public string Fetch { get; }
    public bool Update { get; }
    public bool Insert { get; }
    public string Formula { get; }
    public string ForeignKey { get; }
    public string PropertyRef { get; }
    public string NotFound { get; }
    public string Lazy { get; }
    public string EntityName { get; }
    public bool OptimisticLock { get; }
    public IEnumerable`1<ColumnMapping> Columns { get; }
    public IRelationship OtherSide { get; public set; }
    public ManyToOneMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    [CompilerGeneratedAttribute]
public Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public string get_Name();
    public string get_Access();
    public TypeReference get_Class();
    public string get_Cascade();
    public string get_Fetch();
    public bool get_Update();
    public bool get_Insert();
    public string get_Formula();
    public string get_ForeignKey();
    public string get_PropertyRef();
    public string get_NotFound();
    public string get_Lazy();
    public string get_EntityName();
    public bool get_OptimisticLock();
    public sealed virtual IEnumerable`1<ColumnMapping> get_Columns();
    public sealed virtual void AddColumn(int layer, ColumnMapping mapping);
    public sealed virtual void MakeColumnsEmpty(int layer);
    public void Set(Expression`1<Func`2<ManyToOneMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public sealed virtual bool Equals(ManyToOneMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual IRelationship get_OtherSide();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OtherSide(IRelationship value);
    public virtual bool IsSpecified(string attribute);
}
internal class FluentNHibernate.MappingModel.MappedMembers : object {
    private List`1<Tuple`2<MappingType, IMapping>> orderedMappings;
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<CollectionMapping> Collections { get; }
    public IEnumerable`1<ManyToOneMapping> References { get; }
    public IEnumerable`1<IComponentMapping> Components { get; }
    public IEnumerable`1<OneToOneMapping> OneToOnes { get; }
    public IEnumerable`1<AnyMapping> Anys { get; }
    public IEnumerable`1<JoinMapping> Joins { get; }
    public IEnumerable`1<FilterMapping> Filters { get; }
    public IEnumerable`1<StoredProcedureMapping> StoredProcedures { get; }
    public sealed virtual IEnumerable`1<PropertyMapping> get_Properties();
    public sealed virtual IEnumerable`1<CollectionMapping> get_Collections();
    public sealed virtual IEnumerable`1<ManyToOneMapping> get_References();
    public sealed virtual IEnumerable`1<IComponentMapping> get_Components();
    public sealed virtual IEnumerable`1<OneToOneMapping> get_OneToOnes();
    public sealed virtual IEnumerable`1<AnyMapping> get_Anys();
    public IEnumerable`1<JoinMapping> get_Joins();
    public sealed virtual IEnumerable`1<FilterMapping> get_Filters();
    public IEnumerable`1<StoredProcedureMapping> get_StoredProcedures();
    public void AddOrReplaceFilter(FilterMapping mapping);
    public sealed virtual void AddProperty(PropertyMapping property);
    public void AddOrReplaceProperty(PropertyMapping mapping);
    public sealed virtual void AddCollection(CollectionMapping collection);
    public void AddOrReplaceCollection(CollectionMapping mapping);
    public sealed virtual void AddReference(ManyToOneMapping manyToOne);
    public void AddOrReplaceReference(ManyToOneMapping manyToOne);
    public sealed virtual void AddComponent(IComponentMapping componentMapping);
    public void AddOrReplaceComponent(IComponentMapping componentMapping);
    public sealed virtual void AddOneToOne(OneToOneMapping mapping);
    public void AddOrReplaceOneToOne(OneToOneMapping mapping);
    public sealed virtual void AddAny(AnyMapping mapping);
    public void AddOrReplaceAny(AnyMapping mapping);
    public void AddJoin(JoinMapping mapping);
    public void AddOrReplaceJoin(JoinMapping mapping);
    public sealed virtual void AddFilter(FilterMapping mapping);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public sealed virtual bool IsSpecified(string property);
    public sealed virtual void Set(string attribute, int layer, object value);
    public void AddStoredProcedure(StoredProcedureMapping mapping);
    public sealed virtual bool Equals(MappedMembers other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private void AddMapping(TMapping mapping, MappingType mappingType);
    private void AddOrReplaceMapping(TMapping mapping, MappingType mappingType, Predicate`1<TMapping> matchPredicate);
}
public abstract class FluentNHibernate.MappingModel.MappingBase : object {
    public abstract virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public abstract virtual bool IsSpecified(string attribute);
    protected abstract virtual void Set(string attribute, int layer, object value);
    private sealed virtual override void FluentNHibernate.MappingModel.IMapping.Set(string attribute, int layer, object value);
}
public class FluentNHibernate.MappingModel.MetaValueMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Value { get; }
    public TypeReference Class { get; }
    public Type ContainingEntityType { get; public set; }
    protected MetaValueMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Value();
    public TypeReference get_Class();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(MetaValueMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<MetaValueMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.NaturalIdMapping : MappingBase {
    private AttributeStore attributes;
    private List`1<PropertyMapping> properties;
    private List`1<ManyToOneMapping> manyToOnes;
    public bool Mutable { get; }
    public IEnumerable`1<PropertyMapping> Properties { get; }
    public IEnumerable`1<ManyToOneMapping> ManyToOnes { get; }
    public NaturalIdMapping(AttributeStore attributes);
    public bool get_Mutable();
    public IEnumerable`1<PropertyMapping> get_Properties();
    public IEnumerable`1<ManyToOneMapping> get_ManyToOnes();
    public void AddProperty(PropertyMapping mapping);
    public void AddReference(ManyToOneMapping mapping);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public virtual bool IsSpecified(string attribute);
    protected virtual void Set(string attribute, int layer, object value);
}
public class FluentNHibernate.MappingModel.OneToOneMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Name { get; }
    public string Access { get; }
    public TypeReference Class { get; }
    public string Cascade { get; }
    public bool Constrained { get; }
    public string Fetch { get; }
    public string ForeignKey { get; }
    public string PropertyRef { get; }
    public string Lazy { get; }
    public string EntityName { get; }
    public Type ContainingEntityType { get; public set; }
    public OneToOneMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Name();
    public string get_Access();
    public TypeReference get_Class();
    public string get_Cascade();
    public bool get_Constrained();
    public string get_Fetch();
    public string get_ForeignKey();
    public string get_PropertyRef();
    public string get_Lazy();
    public string get_EntityName();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public sealed virtual bool Equals(OneToOneMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<OneToOneMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public abstract class FluentNHibernate.MappingModel.Output.BaseXmlCollectionWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    protected XmlDocument document;
    protected BaseXmlCollectionWriter(IXmlWriterServiceLocator serviceLocator);
    public virtual void Visit(KeyMapping mapping);
    public virtual void Visit(CacheMapping mapping);
    public virtual void Visit(ICollectionRelationshipMapping mapping);
    public virtual void Visit(CompositeElementMapping mapping);
    public virtual void Visit(ElementMapping mapping);
    public virtual void Visit(FilterMapping filterMapping);
    protected void WriteBaseCollectionAttributes(XmlElement element, CollectionMapping mapping);
}
public abstract class FluentNHibernate.MappingModel.Output.BaseXmlComponentWriter : XmlClassWriterBase {
    private IXmlWriterServiceLocator serviceLocator;
    protected BaseXmlComponentWriter(IXmlWriterServiceLocator serviceLocator);
    protected XmlDocument WriteComponent(string element, IComponentMapping mapping);
    public virtual void Visit(IComponentMapping componentMapping);
    public virtual void Visit(ParentMapping parentMapping);
}
public interface FluentNHibernate.MappingModel.Output.IXmlWriter`1 {
    public abstract virtual XmlDocument Write(T mappingModel);
}
public interface FluentNHibernate.MappingModel.Output.IXmlWriterServiceLocator {
    public abstract virtual IXmlWriter`1<T> GetWriter();
}
public class FluentNHibernate.MappingModel.Output.MappingXmlSerializer : object {
    public XmlDocument Serialize(HibernateMapping mapping);
    private static XmlDocument BuildXml(HibernateMapping rootMapping);
}
public abstract class FluentNHibernate.MappingModel.Output.Sorting.BaseXmlNodeSorter : object {
    protected static int First;
    protected static int Anywhere;
    protected static int Last;
    public XmlNode Sort(XmlNode node);
    protected abstract virtual IDictionary`2<string, SortValue> GetSorting();
    protected abstract virtual void SortChildren(XmlNode node);
}
public class FluentNHibernate.MappingModel.Output.Sorting.SortValue : object {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public int Position { get; public set; }
    public int Level { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
}
public class FluentNHibernate.MappingModel.Output.Sorting.XmlClasslikeNodeSorter : BaseXmlNodeSorter {
    protected virtual IDictionary`2<string, SortValue> GetSorting();
    protected virtual void SortChildren(XmlNode node);
    private bool IsCollection(string name);
}
public class FluentNHibernate.MappingModel.Output.Sorting.XmlCollectionNodeSorter : BaseXmlNodeSorter {
    protected virtual IDictionary`2<string, SortValue> GetSorting();
    protected virtual void SortChildren(XmlNode node);
}
public class FluentNHibernate.MappingModel.Output.Sorting.XmlIdNodeSorter : BaseXmlNodeSorter {
    protected virtual IDictionary`2<string, SortValue> GetSorting();
    protected virtual void SortChildren(XmlNode node);
}
public class FluentNHibernate.MappingModel.Output.Sorting.XmlNodeSorter : object {
    public static XmlNode SortClassChildren(XmlNode node);
}
public class FluentNHibernate.MappingModel.Output.XmlAnyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlAnyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(AnyMapping mappingModel);
    public virtual void ProcessAny(AnyMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
    public virtual void Visit(MetaValueMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlArrayWriter : BaseXmlCollectionWriter {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlArrayWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
    public virtual void Visit(IIndexMapping indexMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlBagWriter : BaseXmlCollectionWriter {
    public XmlBagWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlCacheWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(CacheMapping mappingModel);
    public virtual void ProcessCache(CacheMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlClassWriter : XmlClassWriterBase {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlClassWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ClassMapping mapping);
    public virtual void ProcessClass(ClassMapping classMapping);
    public virtual void Visit(DiscriminatorMapping discriminatorMapping);
    public virtual void Visit(SubclassMapping subclassMapping);
    public virtual void Visit(IComponentMapping componentMapping);
    public virtual void Visit(JoinMapping joinMapping);
    public virtual void Visit(IIdentityMapping mapping);
    public virtual void Visit(NaturalIdMapping naturalIdMapping);
    public virtual void Visit(CacheMapping mapping);
    public virtual void Visit(ManyToOneMapping manyToOneMapping);
    public virtual void Visit(FilterMapping filterMapping);
    public virtual void Visit(TuplizerMapping mapping);
}
public abstract class FluentNHibernate.MappingModel.Output.XmlClassWriterBase : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    protected XmlDocument document;
    protected XmlClassWriterBase(IXmlWriterServiceLocator serviceLocator);
    public virtual void Visit(PropertyMapping propertyMapping);
    public virtual void Visit(VersionMapping versionMapping);
    public virtual void Visit(OneToOneMapping mapping);
    public virtual void Visit(ManyToOneMapping mapping);
    public virtual void Visit(AnyMapping mapping);
    public virtual void Visit(CollectionMapping collectionMapping);
    public virtual void Visit(StoredProcedureMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlCollectionRelationshipWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlCollectionRelationshipWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ICollectionRelationshipMapping mappingModel);
    public virtual void ProcessOneToMany(OneToManyMapping mapping);
    public virtual void ProcessManyToMany(ManyToManyMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlCollectionWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    private Collection collection;
    public XmlCollectionWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlColumnWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(ColumnMapping mappingModel);
    public virtual void ProcessColumn(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlComponentWriter : BaseXmlComponentWriter {
    public XmlComponentWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IComponentMapping mappingModel);
    public virtual void ProcessComponent(ComponentMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlCompositeElementWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    protected XmlDocument document;
    public XmlCompositeElementWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CompositeElementMapping compositeElement);
    public virtual void ProcessCompositeElement(CompositeElementMapping mapping);
    public virtual void Visit(CompositeElementMapping compositeElementMapping);
    public virtual void Visit(PropertyMapping propertyMapping);
    public virtual void Visit(ManyToOneMapping mapping);
    public virtual void Visit(ParentMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlCompositeIdWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlCompositeIdWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CompositeIdMapping mappingModel);
    public virtual void ProcessCompositeId(CompositeIdMapping mapping);
    public virtual void Visit(KeyPropertyMapping mapping);
    public virtual void Visit(KeyManyToOneMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlDiscriminatorWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlDiscriminatorWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(DiscriminatorMapping mappingModel);
    public virtual void ProcessDiscriminator(DiscriminatorMapping discriminatorMapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlElementWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlElementWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ElementMapping mappingModel);
    public virtual void ProcessElement(ElementMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlFilterDefinitionWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(FilterDefinitionMapping mappingModel);
    public virtual void ProcessFilterDefinition(FilterDefinitionMapping filterDefinitionMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlFilterWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(FilterMapping mappingModel);
    public virtual void ProcessFilter(FilterMapping filterDefinitionMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlGeneratorWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(GeneratorMapping mappingModel);
    public virtual void ProcessGenerator(GeneratorMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlHibernateMappingWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlHibernateMappingWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(HibernateMapping mapping);
    public virtual void ProcessHibernateMapping(HibernateMapping mapping);
    public virtual void Visit(ImportMapping importMapping);
    public virtual void Visit(ClassMapping classMapping);
    public virtual void Visit(FilterDefinitionMapping filterDefinitionMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlIdentityBasedWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlIdentityBasedWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IIdentityMapping mappingModel);
    public virtual void ProcessId(IdMapping mapping);
    public virtual void ProcessCompositeId(CompositeIdMapping idMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlIdWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlIdWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IdMapping mappingModel);
    public virtual void ProcessId(IdMapping mapping);
    public virtual void Visit(GeneratorMapping mapping);
    public virtual void Visit(ColumnMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlIIndexWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlIIndexWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IIndexMapping mappingModel);
    public virtual void ProcessIndex(IndexMapping mapping);
    public virtual void ProcessIndex(IndexManyToManyMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlImportWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(ImportMapping mappingModel);
    public virtual void ProcessImport(ImportMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlIndexManyToManyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlIndexManyToManyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IndexManyToManyMapping mappingModel);
    public virtual void ProcessIndex(IndexManyToManyMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlIndexWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlIndexWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(IndexMapping mappingModel);
    public virtual void ProcessIndex(IndexMapping mapping);
    private void WriteIndex(IndexMapping mapping);
    private void WriteListIndex(IndexMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlJoinWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlJoinWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(JoinMapping mappingModel);
    public virtual void ProcessJoin(JoinMapping mapping);
    public virtual void Visit(PropertyMapping mapping);
    public virtual void Visit(KeyMapping mapping);
    public virtual void Visit(ManyToOneMapping mapping);
    public virtual void Visit(IComponentMapping mapping);
    public virtual void Visit(AnyMapping mapping);
    public virtual void Visit(CollectionMapping mapping);
    public virtual void Visit(StoredProcedureMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlKeyManyToOneWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlKeyManyToOneWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(KeyManyToOneMapping mappingModel);
    public virtual void ProcessKeyManyToOne(KeyManyToOneMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlKeyPropertyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlKeyPropertyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(KeyPropertyMapping mappingModel);
    public virtual void ProcessKeyProperty(KeyPropertyMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlKeyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlKeyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(KeyMapping mappingModel);
    public virtual void ProcessKey(KeyMapping mapping);
    public virtual void Visit(ColumnMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlListWriter : BaseXmlCollectionWriter {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlListWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
    public virtual void Visit(IIndexMapping indexMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlManyToManyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlManyToManyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ManyToManyMapping mappingModel);
    public virtual void ProcessManyToMany(ManyToManyMapping mapping);
    public virtual void Visit(ColumnMapping mapping);
    public virtual void Visit(FilterMapping filterMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlManyToOneWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlManyToOneWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ManyToOneMapping mappingModel);
    public virtual void ProcessManyToOne(ManyToOneMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlMapWriter : BaseXmlCollectionWriter {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlMapWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
    public virtual void Visit(IIndexMapping indexMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlMetaValueWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(MetaValueMapping mappingModel);
    public virtual void ProcessMetaValue(MetaValueMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlNaturalIdWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlNaturalIdWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(NaturalIdMapping mappingModel);
    public virtual void ProcessNaturalId(NaturalIdMapping mapping);
    public virtual void Visit(PropertyMapping mapping);
    public virtual void Visit(ManyToOneMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlOneToManyWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(OneToManyMapping mappingModel);
    public virtual void ProcessOneToMany(OneToManyMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlOneToOneWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(OneToOneMapping mappingModel);
    public virtual void ProcessOneToOne(OneToOneMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlParentWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(ParentMapping mappingModel);
    public virtual void ProcessParent(ParentMapping parentMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlPropertyWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlPropertyWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(PropertyMapping property);
    public virtual void ProcessProperty(PropertyMapping propertyMapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlReferenceComponentWriter : BaseXmlComponentWriter {
    private IXmlWriter`1<IComponentMapping> innerWriter;
    public XmlReferenceComponentWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(ReferenceComponentMapping mappingModel);
}
public class FluentNHibernate.MappingModel.Output.XmlSetWriter : BaseXmlCollectionWriter {
    public XmlSetWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(CollectionMapping mappingModel);
    public virtual void ProcessCollection(CollectionMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlStoredProcedureWriter : XmlClassWriterBase {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlStoredProcedureWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(StoredProcedureMapping mappingModel);
    public virtual void ProcessStoredProcedure(StoredProcedureMapping mapping);
    public virtual void Visit(StoredProcedureMapping mapping);
}
public class FluentNHibernate.MappingModel.Output.XmlSubclassWriter : XmlClassWriterBase {
    private IXmlWriterServiceLocator serviceLocator;
    public XmlSubclassWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(SubclassMapping mappingModel);
    public virtual void ProcessSubclass(SubclassMapping mapping);
    public virtual void Visit(KeyMapping keyMapping);
    public virtual void Visit(SubclassMapping subclassMapping);
    public virtual void Visit(IComponentMapping componentMapping);
    public virtual void Visit(JoinMapping joinMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlTuplizerWriter : NullMappingModelVisitor {
    private XmlDocument document;
    public sealed virtual XmlDocument Write(TuplizerMapping mappingModel);
    public virtual void ProcessTuplizer(TuplizerMapping tuplizerMapping);
    private static string GetModeString(TuplizerMode mode);
}
public class FluentNHibernate.MappingModel.Output.XmlVersionWriter : NullMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IXmlWriterServiceLocator <serviceLocator>P;
    private XmlDocument document;
    public XmlVersionWriter(IXmlWriterServiceLocator serviceLocator);
    public sealed virtual XmlDocument Write(VersionMapping mappingModel);
    public virtual void ProcessVersion(VersionMapping mapping);
    public virtual void Visit(ColumnMapping columnMapping);
}
public class FluentNHibernate.MappingModel.Output.XmlWriterContainer : Container {
    private void RegisterIdWriters();
    private void RegisterComponentWriters();
    private void RegisterWriter(Func`2<Container, object> instantiate);
    [CompilerGeneratedAttribute]
private object <.ctor>b__0_0(Container c);
}
public static class FluentNHibernate.MappingModel.Output.XmlWriterFactory : object {
    private static Container Container;
    private static XmlWriterFactory();
    public static IXmlWriter`1<HibernateMapping> CreateHibernateMappingWriter();
}
public class FluentNHibernate.MappingModel.Output.XmlWriterServiceLocator : object {
    [CompilerGeneratedAttribute]
private Container <container>P;
    public XmlWriterServiceLocator(Container container);
    public sealed virtual IXmlWriter`1<T> GetWriter();
}
public class FluentNHibernate.MappingModel.ParentMapping : MappingBase {
    private AttributeStore attributes;
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public string Name { get; }
    public string Access { get; }
    protected ParentMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public string get_Name();
    public string get_Access();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParentMapping other);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<ParentMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.PropertyMapping : ColumnBasedMappingBase {
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <Member>k__BackingField;
    public Type ContainingEntityType { get; public set; }
    public string Name { get; }
    public string Access { get; }
    public bool Insert { get; }
    public bool Update { get; }
    public string Formula { get; }
    public bool Lazy { get; }
    public bool OptimisticLock { get; }
    public string Generated { get; }
    public TypeReference Type { get; }
    public Member Member { get; public set; }
    public PropertyMapping(AttributeStore underlyingStore);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public string get_Name();
    public string get_Access();
    public bool get_Insert();
    public bool get_Update();
    public string get_Formula();
    public bool get_Lazy();
    public bool get_OptimisticLock();
    public string get_Generated();
    public TypeReference get_Type();
    [CompilerGeneratedAttribute]
public Member get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(Member value);
    public sealed virtual bool Equals(PropertyMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<PropertyMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public class FluentNHibernate.MappingModel.StoredProcedureMapping : MappingBase {
    private AttributeStore attributes;
    public string Name { get; }
    public Type Type { get; }
    public string Check { get; }
    public string SPType { get; }
    public string Query { get; }
    public StoredProcedureMapping(AttributeStore attributes);
    public StoredProcedureMapping(string spType, string innerText);
    public StoredProcedureMapping(string spType, string innerText, AttributeStore attributes);
    public string get_Name();
    public Type get_Type();
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public virtual bool IsSpecified(string attribute);
    public string get_Check();
    public string get_SPType();
    public string get_Query();
    public sealed virtual bool Equals(StoredProcedureMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<StoredProcedureMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
}
public class FluentNHibernate.MappingModel.TuplizerMapping : MappingBase {
    private AttributeStore attributes;
    public TuplizerMode Mode { get; }
    public string EntityName { get; }
    public TypeReference Type { get; }
    public TuplizerMapping(AttributeStore attributes);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public virtual bool IsSpecified(string attribute);
    public TuplizerMode get_Mode();
    public string get_EntityName();
    public TypeReference get_Type();
    public sealed virtual bool Equals(TuplizerMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<TuplizerMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
}
public enum FluentNHibernate.MappingModel.TuplizerMode : Enum {
    public int value__;
    public static TuplizerMode Poco;
    public static TuplizerMode Xml;
    public static TuplizerMode DynamicMap;
}
public class FluentNHibernate.MappingModel.TypeReference : object {
    public static TypeReference Empty;
    private Type innerType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public bool IsEnum { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Type GenericTypeDefinition { get; }
    public bool IsNullable { get; }
    public IEnumerable`1<Type> GenericArguments { get; }
    public TypeReference(string name);
    public TypeReference(Type type);
    private static TypeReference();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsEnum();
    public bool get_IsGenericType();
    public bool get_IsGenericTypeDefinition();
    public Type GetGenericTypeDefinition();
    public Type get_GenericTypeDefinition();
    public bool get_IsNullable();
    public Type[] GetGenericArguments();
    public IEnumerable`1<Type> get_GenericArguments();
    public virtual string ToString();
    public sealed virtual bool Equals(TypeReference other);
    public bool Equals(Type other);
    public bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Type GetUnderlyingSystemType();
    public static bool op_Equality(TypeReference original, Type type);
    public static bool op_Inequality(TypeReference original, Type type);
    public static bool op_Equality(Type original, TypeReference type);
    public static bool op_Inequality(Type original, TypeReference type);
    public static bool op_Equality(TypeReference original, TypeReference other);
    public static bool op_Inequality(TypeReference original, TypeReference other);
}
public class FluentNHibernate.MappingModel.VersionMapping : ColumnBasedMappingBase {
    [CompilerGeneratedAttribute]
private Type <ContainingEntityType>k__BackingField;
    public string Name { get; }
    public string Access { get; }
    public TypeReference Type { get; }
    public string UnsavedValue { get; }
    public string Generated { get; }
    public Type ContainingEntityType { get; public set; }
    public VersionMapping(AttributeStore underlyingStore);
    public virtual void AcceptVisitor(IMappingModelVisitor visitor);
    public string get_Name();
    public string get_Access();
    public TypeReference get_Type();
    public string get_UnsavedValue();
    public string get_Generated();
    [CompilerGeneratedAttribute]
public Type get_ContainingEntityType();
    [CompilerGeneratedAttribute]
public void set_ContainingEntityType(Type value);
    public bool Equals(VersionMapping other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Set(Expression`1<Func`2<VersionMapping, T>> expression, int layer, T value);
    protected virtual void Set(string attribute, int layer, object value);
    public virtual bool IsSpecified(string attribute);
}
public abstract class FluentNHibernate.Member : object {
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanWrite { get; }
    public MemberInfo MemberInfo { get; }
    public Type DeclaringType { get; }
    public bool HasIndexParameters { get; }
    public bool IsMethod { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsAutoProperty { get; }
    public bool IsPrivate { get; }
    public bool IsProtected { get; }
    public bool IsPublic { get; }
    public bool IsInternal { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_PropertyType();
    public abstract virtual bool get_CanWrite();
    public abstract virtual MemberInfo get_MemberInfo();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual bool get_HasIndexParameters();
    public abstract virtual bool get_IsMethod();
    public abstract virtual bool get_IsField();
    public abstract virtual bool get_IsProperty();
    public abstract virtual bool get_IsAutoProperty();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsProtected();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsInternal();
    public sealed virtual bool Equals(Member other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Member left, Member right);
    public static bool op_Inequality(Member left, Member right);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
    public abstract virtual bool TryGetBackingField(Member& backingField);
}
public class FluentNHibernate.MemberEqualityComparer : object {
    public sealed virtual bool Equals(Member x, Member y);
    public sealed virtual int GetHashCode(Member obj);
}
[ExtensionAttribute]
public static class FluentNHibernate.MemberExtensions : object {
    [ExtensionAttribute]
public static Member ToMember(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static Member ToMember(MethodInfo methodInfo);
    [ExtensionAttribute]
public static Member ToMember(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static Member ToMember(MemberInfo memberInfo);
    [IteratorStateMachineAttribute("FluentNHibernate.MemberExtensions/<GetInstanceFields>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<Member> GetInstanceFields(Type type);
    [IteratorStateMachineAttribute("FluentNHibernate.MemberExtensions/<GetInstanceMethods>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<Member> GetInstanceMethods(Type type);
    [IteratorStateMachineAttribute("FluentNHibernate.MemberExtensions/<GetInstanceProperties>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<Member> GetInstanceProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Member> GetInstanceMembers(Type type);
}
internal class FluentNHibernate.MethodMember : Member {
    [CompilerGeneratedAttribute]
private MethodInfo <member>P;
    private Member backingField;
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanWrite { get; }
    public MemberInfo MemberInfo { get; }
    public Type DeclaringType { get; }
    public bool HasIndexParameters { get; }
    public bool IsMethod { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsAutoProperty { get; }
    public bool IsPrivate { get; }
    public bool IsProtected { get; }
    public bool IsPublic { get; }
    public bool IsInternal { get; }
    public bool IsCompilerGenerated { get; }
    public MethodMember(MethodInfo member);
    public virtual void SetValue(object target, object value);
    public virtual object GetValue(object target);
    public virtual bool TryGetBackingField(Member& field);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual bool get_CanWrite();
    public virtual MemberInfo get_MemberInfo();
    public virtual Type get_DeclaringType();
    public virtual bool get_HasIndexParameters();
    public virtual bool get_IsMethod();
    public virtual bool get_IsField();
    public virtual bool get_IsProperty();
    public virtual bool get_IsAutoProperty();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsProtected();
    public virtual bool get_IsPublic();
    public virtual bool get_IsInternal();
    public bool get_IsCompilerGenerated();
    public virtual string ToString();
}
public class FluentNHibernate.MissingConstructorException : Exception {
    public MissingConstructorException(Type type);
    public MissingConstructorException(Type type, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected MissingConstructorException(SerializationInfo info, StreamingContext context);
}
public class FluentNHibernate.PassThroughMappingProvider : object {
    [CompilerGeneratedAttribute]
private ClassMapping <mapping>P;
    public PassThroughMappingProvider(ClassMapping mapping);
    public sealed virtual ClassMapping GetClassMapping();
    public sealed virtual HibernateMapping GetHibernateMapping();
    public sealed virtual IEnumerable`1<Member> GetIgnoredProperties();
}
public class FluentNHibernate.PersistenceModel : object {
    protected IList`1<IMappingProvider> classProviders;
    protected IList`1<IFilterDefinition> filterDefinitions;
    protected IIndeterminateSubclassMappingProviderCollection subclassProviders;
    protected IList`1<IExternalComponentMappingProvider> componentProviders;
    protected IList`1<IComponentReferenceResolver> componentResolvers;
    private IList`1<IMappingModelVisitor> visitors;
    [CompilerGeneratedAttribute]
private IConventionFinder <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeMappings>k__BackingField;
    private IEnumerable`1<HibernateMapping> compiledMappings;
    private ValidationVisitor validationVisitor;
    [CompilerGeneratedAttribute]
private PairBiDirectionalManyToManySidesDelegate <BiDirectionalManyToManyPairer>k__BackingField;
    private IDiagnosticMessageDispatcher diagnosticDispatcher;
    protected IDiagnosticLogger log;
    public IConventionFinder Conventions { get; }
    public bool MergeMappings { get; public set; }
    public PairBiDirectionalManyToManySidesDelegate BiDirectionalManyToManyPairer { get; public set; }
    public bool ValidationEnabled { get; public set; }
    public PersistenceModel(IConventionFinder conventionFinder);
    [CompilerGeneratedAttribute]
public IConventionFinder get_Conventions();
    [CompilerGeneratedAttribute]
public bool get_MergeMappings();
    [CompilerGeneratedAttribute]
public void set_MergeMappings(bool value);
    [CompilerGeneratedAttribute]
public PairBiDirectionalManyToManySidesDelegate get_BiDirectionalManyToManyPairer();
    [CompilerGeneratedAttribute]
public void set_BiDirectionalManyToManyPairer(PairBiDirectionalManyToManySidesDelegate value);
    public void SetLogger(IDiagnosticLogger logger);
    protected void AddMappingsFromThisAssembly();
    public void AddMappingsFromAssembly(Assembly assembly);
    public void AddMappingsFromSource(ITypeSource source);
    private static Assembly FindTheCallingAssembly();
    public void Add(IMappingProvider provider);
    public void Add(IIndeterminateSubclassMappingProvider provider);
    public void Add(IFilterDefinition definition);
    public void Add(IExternalComponentMappingProvider provider);
    public void Add(Type type);
    private bool IsMappingOf(Type type);
    public virtual IEnumerable`1<HibernateMapping> BuildMappings();
    private void BuildSeparateMappings(Action`1<HibernateMapping> add);
    private void BuildSingleMapping(Action`1<HibernateMapping> add);
    private void ApplyVisitors(IEnumerable`1<HibernateMapping> mappings);
    private void EnsureMappingsBuilt();
    protected virtual string GetMappingFileName();
    private string DetermineMappingFileName(HibernateMapping mapping);
    public void WriteMappingsTo(string folder);
    public void WriteMappingsTo(TextWriter writer);
    private void WriteMappingsTo(Func`2<HibernateMapping, XmlTextWriter> writerBuilder, bool shouldDispose);
    public virtual void Configure(Configuration cfg);
    public bool ContainsMapping(Type type);
    public bool get_ValidationEnabled();
    public void set_ValidationEnabled(bool value);
    internal void ImportProviders(PersistenceModel model);
    [CompilerGeneratedAttribute]
private bool <AddMappingsFromSource>b__26_0(Type x);
}
internal class FluentNHibernate.PropertyMember : Member {
    private PropertyInfo member;
    private Member backingField;
    [CompilerGeneratedAttribute]
private MethodMember <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodMember <Set>k__BackingField;
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanWrite { get; }
    public MemberInfo MemberInfo { get; }
    public Type DeclaringType { get; }
    public bool HasIndexParameters { get; }
    public bool IsMethod { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsAutoProperty { get; }
    public bool IsPrivate { get; }
    public bool IsProtected { get; }
    public bool IsPublic { get; }
    public bool IsInternal { get; }
    public MethodMember Get { get; }
    public MethodMember Set { get; }
    public PropertyMember(PropertyInfo member);
    private MethodMember GetMember(MethodInfo method);
    public virtual void SetValue(object target, object value);
    public virtual object GetValue(object target);
    public virtual bool TryGetBackingField(Member& field);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual bool get_CanWrite();
    public virtual MemberInfo get_MemberInfo();
    public virtual Type get_DeclaringType();
    public virtual bool get_HasIndexParameters();
    public virtual bool get_IsMethod();
    public virtual bool get_IsField();
    public virtual bool get_IsProperty();
    public virtual bool get_IsAutoProperty();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsProtected();
    public virtual bool get_IsPublic();
    public virtual bool get_IsInternal();
    [CompilerGeneratedAttribute]
public MethodMember get_Get();
    [CompilerGeneratedAttribute]
public MethodMember get_Set();
    public virtual string ToString();
}
public static class FluentNHibernate.Reveal : object {
    [ObsoleteAttribute("Use Reveal.Member")]
public static Expression`1<Func`2<TEntity, object>> Property(string propertyName);
    [ObsoleteAttribute("Use Reveal.Member")]
public static Expression`1<Func`2<TEntity, TReturn>> Property(string propertyName);
    public static Expression`1<Func`2<TEntity, object>> Member(string name);
    public static Expression`1<Func`2<TEntity, TReturn>> Member(string name);
    private static Expression`1<Func`2<TEntity, TReturn>> CreateExpression(string propertyName);
}
public class FluentNHibernate.SessionSource : object {
    private Dialect dialect;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ISessionFactory <SessionFactory>k__BackingField;
    public Configuration Configuration { get; private set; }
    public ISessionFactory SessionFactory { get; private set; }
    public SessionSource(PersistenceModel model);
    public SessionSource(IDictionary`2<string, string> properties, PersistenceModel model);
    public SessionSource(FluentConfiguration config);
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    [CompilerGeneratedAttribute]
public sealed virtual ISessionFactory get_SessionFactory();
    [CompilerGeneratedAttribute]
private void set_SessionFactory(ISessionFactory value);
    protected void Initialize(Configuration nhibernateConfig, PersistenceModel model);
    public virtual ISession CreateSession();
    public virtual void BuildSchema();
    public virtual void BuildSchema(bool script);
    public void BuildSchema(ISession session);
    public void BuildSchema(ISession session, bool script);
}
public class FluentNHibernate.Testing.PersistenceSpecification`1 : object {
    protected List`1<Property`1<T>> allProperties;
    private ISession currentSession;
    private IEqualityComparer entityEqualityComparer;
    private bool hasExistingTransaction;
    public PersistenceSpecification`1(ISessionSource source);
    public PersistenceSpecification`1(ISessionSource source, IEqualityComparer entityEqualityComparer);
    public PersistenceSpecification`1(ISession session);
    public PersistenceSpecification`1(ISession session, IEqualityComparer entityEqualityComparer);
    public T VerifyTheMappings();
    public T VerifyTheMappings(T first);
    public void TransactionalSave(object propertyValue);
    public PersistenceSpecification`1<T> RegisterCheckedProperty(Property`1<T> property);
    public PersistenceSpecification`1<T> RegisterCheckedPropertyWithoutTransactionalSave(Property`1<T> property, IEqualityComparer equalityComparer);
    public PersistenceSpecification`1<T> RegisterCheckedProperty(Property`1<T> property, IEqualityComparer equalityComparer);
}
[ExtensionAttribute]
public static class FluentNHibernate.Testing.PersistenceSpecificationExtensions : object {
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, object propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, object propertyValue, IEqualityComparer propertyComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, Array>> expression, IEnumerable`1<TListElement> propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, Array>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, TProperty>> expression, TProperty propertyValue, Action`2<T, TProperty> propertySetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckProperty(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, TProperty>> expression, TProperty propertyValue, IEqualityComparer propertyComparer, Action`2<T, TProperty> propertySetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckReference(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, object propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckReference(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, object propertyValue, IEqualityComparer propertyComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckReference(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, TReference propertyValue, Func`2[] propertiesToCompare);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckReference(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, TProperty>> expression, TProperty propertyValue, Action`2<T, TProperty> propertySetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckReference(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, TProperty>> expression, TProperty propertyValue, IEqualityComparer propertyComparer, Action`2<T, TProperty> propertySetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Func`2[] propertiesToCompare);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Func`2[] propertiesToCompare);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Func`2[] propertiesToCompare);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckInverseBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Func`2[] propertiesToCompare);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckBag(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, IEnumerable`1<TListElement> propertyValue);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, object>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, TListElement> listItemSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
public static PersistenceSpecification`1<T> CheckComponentList(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TListElement>>> expression, IEnumerable`1<TListElement> propertyValue, IEqualityComparer elementComparer, Action`2<T, IEnumerable`1<TListElement>> listSetter);
    [ExtensionAttribute]
[ObsoleteAttribute("CheckEnumerable has been replaced with CheckList")]
public static PersistenceSpecification`1<T> CheckEnumerable(PersistenceSpecification`1<T> spec, Expression`1<Func`2<T, IEnumerable`1<TItem>>> expression, Action`2<T, TItem> addAction, IEnumerable`1<TItem> itemsToAdd);
}
public class FluentNHibernate.Testing.SingleConnectionSessionSourceForSQLiteInMemoryTesting : SessionSource {
    private ISession session;
    public SingleConnectionSessionSourceForSQLiteInMemoryTesting(IDictionary`2<string, string> properties, PersistenceModel model);
    public SingleConnectionSessionSourceForSQLiteInMemoryTesting(FluentConfiguration config);
    protected void EnsureCurrentSession();
    public virtual ISession CreateSession();
    public virtual void BuildSchema();
    public virtual void BuildSchema(bool script);
}
public class FluentNHibernate.Testing.Values.List`2 : Property`2<T, IEnumerable`1<TListElement>> {
    private Action`3<T, Accessor, IEnumerable`1<TListElement>> _valueSetter;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TListElement> <Expected>k__BackingField;
    public Action`3<T, Accessor, IEnumerable`1<TListElement>> ValueSetter { get; public set; }
    protected IEnumerable`1<TListElement> Expected { get; }
    public List`2(Accessor property, IEnumerable`1<TListElement> value);
    public virtual Action`3<T, Accessor, IEnumerable`1<TListElement>> get_ValueSetter();
    public virtual void set_ValueSetter(Action`3<T, Accessor, IEnumerable`1<TListElement>> value);
    [CompilerGeneratedAttribute]
protected IEnumerable`1<TListElement> get_Expected();
    public virtual void CheckValue(object target);
    private void AssertGenericListMatches(IEnumerable`1<TListElement> actualEnumerable, IEnumerable`1<TListElement> expectedEnumerable);
    private IEnumerable`1<TListElement> CreateCollection(Type type);
    [CompilerGeneratedAttribute]
private void <get_ValueSetter>b__3_0(T target, Accessor propertyAccessor, IEnumerable`1<TListElement> value);
}
public abstract class FluentNHibernate.Testing.Values.Property`1 : object {
    [CompilerGeneratedAttribute]
private IEqualityComparer <EntityEqualityComparer>k__BackingField;
    public IEqualityComparer EntityEqualityComparer { get; public set; }
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EntityEqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EntityEqualityComparer(IEqualityComparer value);
    public abstract virtual void SetValue(T target);
    public abstract virtual void CheckValue(object target);
    public virtual void HasRegistered(PersistenceSpecification`1<T> specification);
}
public class FluentNHibernate.Testing.Values.Property`2 : Property`1<T> {
    private static Action`3<T, Accessor, TProperty> DefaultValueSetter;
    private Action`3<T, Accessor, TProperty> _valueSetter;
    [CompilerGeneratedAttribute]
private Accessor <PropertyAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <Value>k__BackingField;
    public Action`3<T, Accessor, TProperty> ValueSetter { get; public set; }
    protected Accessor PropertyAccessor { get; }
    protected TProperty Value { get; }
    public Property`2(Accessor property, TProperty value);
    private static Property`2();
    public virtual Action`3<T, Accessor, TProperty> get_ValueSetter();
    public virtual void set_ValueSetter(Action`3<T, Accessor, TProperty> value);
    [CompilerGeneratedAttribute]
protected Accessor get_PropertyAccessor();
    [CompilerGeneratedAttribute]
protected TProperty get_Value();
    public virtual void SetValue(T target);
    public virtual void CheckValue(object target);
    private string GetInequalityComparisonMessage(object actual);
}
public class FluentNHibernate.Testing.Values.ReferenceBag`2 : ReferenceList`2<T, TListElement> {
    public ReferenceBag`2(Accessor property, IEnumerable`1<TListElement> value);
    public virtual void CheckValue(object target);
    private void AssertGenericListMatches(IEnumerable`1<TListElement> actualEnumerable, IEnumerable`1<TListElement> expectedEnumerable);
}
public class FluentNHibernate.Testing.Values.ReferenceList`2 : List`2<T, TListElement> {
    public ReferenceList`2(Accessor property, IEnumerable`1<TListElement> value);
    public virtual void HasRegistered(PersistenceSpecification`1<T> specification);
}
public class FluentNHibernate.Testing.Values.ReferenceProperty`2 : Property`2<T, TProperty> {
    public ReferenceProperty`2(Accessor property, TProperty propertyValue);
    public virtual void HasRegistered(PersistenceSpecification`1<T> specification);
}
public class FluentNHibernate.UnknownPropertyException : Exception {
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Property { get; }
    public Type Type { get; }
    public UnknownPropertyException(Type classType, string propertyName);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
protected UnknownPropertyException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization and will be removed in a future version")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface FluentNHibernate.Utils.Accessor {
    public string FieldName { get; }
    public Type PropertyType { get; }
    public Member InnerMember { get; }
    public string Name { get; }
    public abstract virtual string get_FieldName();
    public abstract virtual Type get_PropertyType();
    public abstract virtual Member get_InnerMember();
    public abstract virtual void SetValue(object target, object propertyValue);
    public abstract virtual object GetValue(object target);
    public abstract virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public abstract virtual string get_Name();
}
[ExtensionAttribute]
[ObsoleteAttribute("This class is not used and will be removed in a future version")]
public static class FluentNHibernate.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("This method is not used and will be removed in a future version")]
public static void Each(IEnumerable`1<T> enumerable, Action`1<T> each);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("This method is not used and will be removed in a future version")]
public static IEnumerable`1<T> Except(IEnumerable`1<T> enumerable, T[] singles);
}
public class FluentNHibernate.Utils.ExpressionToSql : object {
    public static string Convert(Expression`1<Func`2<T, object>> expression);
    public static string Convert(Expression`1<Func`2<T, bool>> expression);
    private static string Convert(Expression`1<Func`2<T, object>> expression, MemberExpression body);
    private static string Convert(MethodCallExpression body);
    private static string Convert(Expression`1<Func`2<T, object>> expression, UnaryExpression body);
    private static string Convert(ConstantExpression expression);
    private static Expression`1<Func`2<T, object>> CreateExpression(Expression body);
    private static string Convert(BinaryExpression expression);
    private static string Convert(object value);
}
[ExtensionAttribute]
public static class FluentNHibernate.Utils.Extensions : object {
    [ExtensionAttribute]
public static bool In(T instance, T[] expected);
    [ExtensionAttribute]
public static string ToLowerInvariantString(object value);
    [ExtensionAttribute]
public static bool Closes(Type type, Type openGenericType);
    [ExtensionAttribute]
public static bool ClosesInterface(Type type, Type openGenericInterface);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use IsNullableType(Type type)")]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static T InstantiateUsingParameterlessConstructor(Type type);
    [ExtensionAttribute]
public static object InstantiateUsingParameterlessConstructor(Type type);
    [ExtensionAttribute]
public static bool HasInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
[ObsoleteAttribute("Please do not use this method. It will be removed in a future version.")]
public static T DeepClone(T obj);
    [ExtensionAttribute]
public static bool IsAutoMappingOverrideType(Type type);
}
[DefaultMemberAttribute("Item")]
public class FluentNHibernate.Utils.ObservableDictionary`2 : object {
    private static string CountString;
    private static string IndexerName;
    private static string KeysName;
    private static string ValuesName;
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    protected IDictionary`2<TKey, TValue> Dictionary { get; private set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ObservableDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public ObservableDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ObservableDictionary`2(int capacity);
    public ObservableDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public ObservableDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    [CompilerGeneratedAttribute]
protected IDictionary`2<TKey, TValue> get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(IDictionary`2<TKey, TValue> value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public void AddRange(IDictionary`2<TKey, TValue> items);
    private void Insert(TKey key, TValue value, bool add);
    private void OnPropertyChanged();
    protected virtual void OnPropertyChanged(string propertyName);
    private void OnCollectionChanged();
    private void OnCollectionChanged(NotifyCollectionChangedAction action, KeyValuePair`2<TKey, TValue> changedItem);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, KeyValuePair`2<TKey, TValue> newItem, KeyValuePair`2<TKey, TValue> oldItem);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, IList newItems);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__42_0(TKey k);
}
public class FluentNHibernate.Utils.PropertyChain : object {
    private Member[] _chain;
    private SingleMember innerMember;
    public string FieldName { get; }
    public Type PropertyType { get; }
    public Member InnerMember { get; }
    public string Name { get; }
    public PropertyChain(Member[] members);
    public sealed virtual void SetValue(object target, object propertyValue);
    public sealed virtual object GetValue(object target);
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    public sealed virtual Member get_InnerMember();
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual string get_Name();
    private object findInnerMostTarget(object target);
}
public class FluentNHibernate.Utils.Reflection.ExpressionBuilder : object {
    public static Expression`1<Func`2<T, object>> Create(Member member);
    public static Expression`1<Func`2<T, object>> Create(PropertyInfo property);
    public static object Create(PropertyInfo property, Type type);
}
public static class FluentNHibernate.Utils.Reflection.ReflectionHelper : object {
    public static Type AutomappingTypeForEntityType(Type entityType);
    public static Member GetMember(Expression`1<Func`2<TModel, TReturn>> expression);
    public static Member GetMember(Expression`1<Func`2<TModel, object>> expression);
    public static Accessor GetAccessor(Expression`1<Func`2<MODEL, object>> expression);
    public static Accessor GetAccessor(Expression`1<Func`2<MODEL, T>> expression);
    private static bool IsIndexedPropertyAccess(Expression expression);
    private static bool IsMethodExpression(Expression expression);
    private static Member GetMember(Expression expression);
    private static PropertyInfo GetDynamicComponentProperty(Expression expression);
    private static MemberExpression GetMemberExpression(Expression expression);
    private static MemberExpression GetMemberExpression(Expression expression, bool enforceCheck);
    private static Accessor getAccessor(MemberExpression memberExpression);
}
[ExtensionAttribute]
public static class FluentNHibernate.Utils.ReflectionExtensions : object {
    [ExtensionAttribute]
public static Member ToMember(Expression`1<Func`2<TMapping, TReturn>> propertyExpression);
}
public class FluentNHibernate.Utils.SingleMember : object {
    [CompilerGeneratedAttribute]
private Member <InnerMember>k__BackingField;
    public string FieldName { get; }
    public Type PropertyType { get; }
    public Member InnerMember { get; }
    public string Name { get; }
    public SingleMember(Member member);
    public sealed virtual string get_FieldName();
    public sealed virtual Type get_PropertyType();
    [CompilerGeneratedAttribute]
public sealed virtual Member get_InnerMember();
    public sealed virtual Accessor GetChildAccessor(Expression`1<Func`2<T, object>> expression);
    public sealed virtual string get_Name();
    public sealed virtual void SetValue(object target, object propertyValue);
    public sealed virtual object GetValue(object target);
    public static SingleMember Build(Expression`1<Func`2<T, object>> expression);
    public static SingleMember Build(string propertyName);
}
public static class FluentNHibernate.Utils.StringLikeness : object {
    public static int EditDistance(string x, string y);
}
[ExtensionAttribute]
internal static class FluentNHibernate.Utils.XmlExtensions : object {
    [ExtensionAttribute]
public static XmlElement AddElement(XmlDocument document, string name);
    [ExtensionAttribute]
public static XmlElement AddElement(XmlNode element, string name);
    [ExtensionAttribute]
public static XmlElement WithAtt(XmlElement element, string key, bool value);
    [ExtensionAttribute]
public static XmlElement WithAtt(XmlElement element, string key, int value);
    [ExtensionAttribute]
public static XmlElement WithAtt(XmlElement element, string key, TypeReference value);
    [ExtensionAttribute]
public static XmlElement WithAtt(XmlElement element, string key, string attValue);
    [ExtensionAttribute]
public static void SetAttributeOnChild(XmlElement element, string childName, string attName, string attValue);
    [ExtensionAttribute]
public static XmlElement WithProperties(XmlElement element, Dictionary`2<string, string> properties);
    [ExtensionAttribute]
public static XmlElement SetColumnProperty(XmlElement element, string name, string value);
    [ExtensionAttribute]
public static void ImportAndAppendChild(XmlDocument document, XmlDocument toImport);
}
public class FluentNHibernate.Visitors.AmbiguousComponentReferenceException : Exception {
    [CompilerGeneratedAttribute]
private Type <ReferencedComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <SourceMember>k__BackingField;
    public Type ReferencedComponentType { get; }
    public Type SourceType { get; }
    public Member SourceMember { get; }
    public AmbiguousComponentReferenceException(Type referencedComponentType, Type sourceType, Member sourceMember);
    [CompilerGeneratedAttribute]
public Type get_ReferencedComponentType();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Member get_SourceMember();
}
public class FluentNHibernate.Visitors.ComponentColumnPrefixVisitor : DefaultMappingModelVisitor {
    private Stack`1<string> prefixes;
    public virtual void Visit(IComponentMapping mapping);
    public virtual void ProcessColumn(ColumnMapping columnMapping);
    private string GetPrefix();
    private void StorePrefix(IComponentMapping mapping);
    private void ResetPrefix();
}
public class FluentNHibernate.Visitors.ComponentMapComponentReferenceResolver : object {
    public sealed virtual ExternalComponentMapping Resolve(ComponentResolutionContext context, IEnumerable`1<IExternalComponentMappingProvider> componentProviders);
}
public class FluentNHibernate.Visitors.ComponentReferenceResolutionVisitor : DefaultMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IComponentReferenceResolver> <resolvers>P;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IExternalComponentMappingProvider> <componentProviders>P;
    public ComponentReferenceResolutionVisitor(IEnumerable`1<IComponentReferenceResolver> resolvers, IEnumerable`1<IExternalComponentMappingProvider> componentProviders);
    public virtual void ProcessComponent(ReferenceComponentMapping mapping);
}
public class FluentNHibernate.Visitors.ComponentResolutionContext : object {
    [CompilerGeneratedAttribute]
private Type <ComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <ComponentMember>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EntityType>k__BackingField;
    public Type ComponentType { get; public set; }
    public Member ComponentMember { get; public set; }
    public Type EntityType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(Type value);
    [CompilerGeneratedAttribute]
public Member get_ComponentMember();
    [CompilerGeneratedAttribute]
public void set_ComponentMember(Member value);
    [CompilerGeneratedAttribute]
public Type get_EntityType();
    [CompilerGeneratedAttribute]
public void set_EntityType(Type value);
}
public class FluentNHibernate.Visitors.ConventionVisitor : DefaultMappingModelVisitor {
    private Dictionary`2<Collection, Action`1<CollectionMapping>> collections;
    private IConventionFinder finder;
    private Type currentType;
    public ConventionVisitor(IConventionFinder finder);
    public virtual void ProcessHibernateMapping(HibernateMapping hibernateMapping);
    public virtual void ProcessId(IdMapping idMapping);
    public virtual void ProcessCompositeId(CompositeIdMapping idMapping);
    public virtual void ProcessClass(ClassMapping classMapping);
    public virtual void ProcessProperty(PropertyMapping propertyMapping);
    public virtual void ProcessColumn(ColumnMapping columnMapping);
    public virtual void ProcessCollection(CollectionMapping mapping);
    private void ProcessArray(CollectionMapping mapping);
    private void ProcessBag(CollectionMapping mapping);
    private void ProcessList(CollectionMapping mapping);
    private void ProcessMap(CollectionMapping mapping);
    private void ProcessSet(CollectionMapping mapping);
    public virtual void ProcessManyToOne(ManyToOneMapping mapping);
    public virtual void ProcessVersion(VersionMapping mapping);
    public virtual void ProcessOneToOne(OneToOneMapping mapping);
    public virtual void ProcessSubclass(SubclassMapping subclassMapping);
    public virtual void ProcessComponent(ComponentMapping mapping);
    public virtual void ProcessIndex(IndexMapping indexMapping);
    public virtual void ProcessIndex(IndexManyToManyMapping indexMapping);
    public virtual void ProcessJoin(JoinMapping joinMapping);
    public virtual void ProcessKeyProperty(KeyPropertyMapping mapping);
    public virtual void ProcessKeyManyToOne(KeyManyToOneMapping mapping);
    public virtual void ProcessAny(AnyMapping mapping);
    private static void Apply(IEnumerable`1<IConvention`2<TInspector, TInstance>> conventions, TInstance instance);
}
public abstract class FluentNHibernate.Visitors.DefaultMappingModelVisitor : NullMappingModelVisitor {
    public virtual void ProcessIndex(IndexManyToManyMapping indexMapping);
    public virtual void ProcessIndex(IndexMapping indexMapping);
    protected virtual void ProcessCollectionContents(ICollectionRelationshipMapping relationshipMapping);
    public virtual void ProcessOneToMany(OneToManyMapping oneToManyMapping);
    protected virtual void ProcessIdentity(IIdentityMapping idMapping);
    public virtual void ProcessId(IdMapping idMapping);
    public virtual void ProcessCompositeId(CompositeIdMapping idMapping);
    protected virtual void ProcessClassBase(ClassMappingBase classMapping);
    public virtual void ProcessClass(ClassMapping classMapping);
    public virtual void ProcessSubclass(SubclassMapping subclassMapping);
    public virtual void Visit(IEnumerable`1<HibernateMapping> mappings);
    public virtual void Visit(AnyMapping mapping);
    public virtual void Visit(NaturalIdMapping mapping);
    public virtual void Visit(ClassMapping classMapping);
    public virtual void Visit(IIdentityMapping identityMapping);
    public virtual void Visit(CollectionMapping collectionMapping);
    public virtual void Visit(PropertyMapping propertyMapping);
    public virtual void Visit(ManyToOneMapping manyToOneMapping);
    public virtual void Visit(KeyMapping keyMapping);
    public virtual void Visit(ICollectionRelationshipMapping relationshipMapping);
    public virtual void Visit(GeneratorMapping generatorMapping);
    public virtual void Visit(ColumnMapping columnMapping);
    public virtual void Visit(SubclassMapping subclassMapping);
    public virtual void Visit(DiscriminatorMapping discriminatorMapping);
    public virtual void Visit(IComponentMapping componentMapping);
    public virtual void Visit(JoinMapping joinMapping);
    public virtual void Visit(CompositeElementMapping compositeElementMapping);
    public virtual void Visit(VersionMapping versionMapping);
    public virtual void Visit(OneToOneMapping mapping);
    public virtual void Visit(IIndexMapping indexMapping);
    public virtual void Visit(KeyPropertyMapping mapping);
    public virtual void Visit(KeyManyToOneMapping mapping);
}
public interface FluentNHibernate.Visitors.IComponentReferenceResolver {
    public abstract virtual ExternalComponentMapping Resolve(ComponentResolutionContext context, IEnumerable`1<IExternalComponentMappingProvider> componentProviders);
}
public interface FluentNHibernate.Visitors.IMappingModelVisitor {
    public abstract virtual void ProcessId(IdMapping idMapping);
    public abstract virtual void ProcessNaturalId(NaturalIdMapping naturalIdMapping);
    public abstract virtual void ProcessCache(CacheMapping mapping);
    public abstract virtual void ProcessCompositeId(CompositeIdMapping idMapping);
    public abstract virtual void ProcessClass(ClassMapping classMapping);
    public abstract virtual void ProcessImport(ImportMapping importMapping);
    public abstract virtual void ProcessHibernateMapping(HibernateMapping hibernateMapping);
    public abstract virtual void ProcessProperty(PropertyMapping propertyMapping);
    public abstract virtual void ProcessManyToOne(ManyToOneMapping manyToOneMapping);
    public abstract virtual void ProcessKey(KeyMapping keyMapping);
    public abstract virtual void ProcessGenerator(GeneratorMapping generatorMapping);
    public abstract virtual void ProcessColumn(ColumnMapping columnMapping);
    public abstract virtual void ProcessOneToMany(OneToManyMapping oneToManyMapping);
    public abstract virtual void ProcessManyToMany(ManyToManyMapping manyToManyMapping);
    public abstract virtual void ProcessSubclass(SubclassMapping subclassMapping);
    public abstract virtual void ProcessDiscriminator(DiscriminatorMapping discriminatorMapping);
    public abstract virtual void ProcessComponent(ComponentMapping mapping);
    public abstract virtual void ProcessComponent(ReferenceComponentMapping componentMapping);
    public abstract virtual void ProcessIndex(IIndexMapping indexMapping);
    public abstract virtual void ProcessIndex(IndexMapping indexMapping);
    public abstract virtual void ProcessIndex(IndexManyToManyMapping indexMapping);
    public abstract virtual void ProcessParent(ParentMapping parentMapping);
    public abstract virtual void ProcessJoin(JoinMapping joinMapping);
    public abstract virtual void ProcessCompositeElement(CompositeElementMapping compositeElementMapping);
    public abstract virtual void ProcessVersion(VersionMapping mapping);
    public abstract virtual void ProcessOneToOne(OneToOneMapping mapping);
    public abstract virtual void ProcessAny(AnyMapping mapping);
    public abstract virtual void ProcessMetaValue(MetaValueMapping mapping);
    public abstract virtual void ProcessKeyProperty(KeyPropertyMapping mapping);
    public abstract virtual void ProcessKeyManyToOne(KeyManyToOneMapping mapping);
    public abstract virtual void ProcessElement(ElementMapping mapping);
    public abstract virtual void ProcessFilter(FilterMapping mapping);
    public abstract virtual void ProcessFilterDefinition(FilterDefinitionMapping mapping);
    public abstract virtual void ProcessStoredProcedure(StoredProcedureMapping mapping);
    public abstract virtual void ProcessTuplizer(TuplizerMapping mapping);
    public abstract virtual void ProcessCollection(CollectionMapping mapping);
    public abstract virtual void Visit(IEnumerable`1<HibernateMapping> mappings);
    public abstract virtual void Visit(IdMapping mapping);
    public abstract virtual void Visit(NaturalIdMapping naturalIdMapping);
    public abstract virtual void Visit(ClassMapping classMapping);
    public abstract virtual void Visit(CacheMapping mapping);
    public abstract virtual void Visit(ImportMapping importMapping);
    public abstract virtual void Visit(IIdentityMapping identityMapping);
    public abstract virtual void Visit(CollectionMapping collectionMapping);
    public abstract virtual void Visit(PropertyMapping propertyMapping);
    public abstract virtual void Visit(ManyToOneMapping manyToOneMapping);
    public abstract virtual void Visit(KeyMapping keyMapping);
    public abstract virtual void Visit(ICollectionRelationshipMapping relationshipMapping);
    public abstract virtual void Visit(GeneratorMapping generatorMapping);
    public abstract virtual void Visit(ColumnMapping columnMapping);
    public abstract virtual void Visit(SubclassMapping subclassMapping);
    public abstract virtual void Visit(DiscriminatorMapping discriminatorMapping);
    public abstract virtual void Visit(IComponentMapping componentMapping);
    public abstract virtual void Visit(IIndexMapping indexMapping);
    public abstract virtual void Visit(ParentMapping parentMapping);
    public abstract virtual void Visit(JoinMapping joinMapping);
    public abstract virtual void Visit(CompositeElementMapping compositeElementMapping);
    public abstract virtual void Visit(VersionMapping versionMapping);
    public abstract virtual void Visit(OneToOneMapping mapping);
    public abstract virtual void Visit(OneToManyMapping mapping);
    public abstract virtual void Visit(ManyToManyMapping mapping);
    public abstract virtual void Visit(AnyMapping mapping);
    public abstract virtual void Visit(MetaValueMapping mapping);
    public abstract virtual void Visit(KeyPropertyMapping mapping);
    public abstract virtual void Visit(KeyManyToOneMapping mapping);
    public abstract virtual void Visit(ElementMapping mapping);
    public abstract virtual void Visit(FilterMapping mapping);
    public abstract virtual void Visit(FilterDefinitionMapping mapping);
    public abstract virtual void Visit(StoredProcedureMapping mapping);
    public abstract virtual void Visit(TuplizerMapping mapping);
}
public class FluentNHibernate.Visitors.ManyToManyTableNameVisitor : DefaultMappingModelVisitor {
    public virtual void ProcessCollection(CollectionMapping mapping);
}
public class FluentNHibernate.Visitors.MissingExternalComponentException : Exception {
    [CompilerGeneratedAttribute]
private Type <ReferencedComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <SourceMember>k__BackingField;
    public Type ReferencedComponentType { get; }
    public Type SourceType { get; }
    public Member SourceMember { get; }
    public MissingExternalComponentException(Type referencedComponentType, Type sourceType, Member sourceMember);
    [CompilerGeneratedAttribute]
public Type get_ReferencedComponentType();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Member get_SourceMember();
}
public abstract class FluentNHibernate.Visitors.NullMappingModelVisitor : object {
    public virtual void ProcessId(IdMapping idMapping);
    public virtual void ProcessNaturalId(NaturalIdMapping naturalIdMapping);
    public virtual void ProcessCache(CacheMapping mapping);
    public virtual void ProcessCompositeId(CompositeIdMapping idMapping);
    public virtual void ProcessClass(ClassMapping classMapping);
    public virtual void ProcessImport(ImportMapping importMapping);
    public virtual void ProcessHibernateMapping(HibernateMapping hibernateMapping);
    public virtual void ProcessProperty(PropertyMapping propertyMapping);
    public virtual void ProcessManyToOne(ManyToOneMapping manyToOneMapping);
    public virtual void ProcessKey(KeyMapping keyMapping);
    public virtual void ProcessGenerator(GeneratorMapping generatorMapping);
    public virtual void ProcessColumn(ColumnMapping columnMapping);
    public virtual void ProcessOneToMany(OneToManyMapping oneToManyMapping);
    public virtual void ProcessManyToMany(ManyToManyMapping manyToManyMapping);
    public virtual void ProcessSubclass(SubclassMapping subclassMapping);
    public virtual void ProcessDiscriminator(DiscriminatorMapping discriminatorMapping);
    public virtual void ProcessComponent(ComponentMapping mapping);
    public virtual void ProcessComponent(ReferenceComponentMapping componentMapping);
    public virtual void ProcessJoin(JoinMapping joinMapping);
    public virtual void ProcessCompositeElement(CompositeElementMapping compositeElementMapping);
    public virtual void ProcessVersion(VersionMapping mapping);
    public virtual void ProcessOneToOne(OneToOneMapping mapping);
    public virtual void ProcessAny(AnyMapping mapping);
    public virtual void ProcessMetaValue(MetaValueMapping mapping);
    public virtual void ProcessKeyProperty(KeyPropertyMapping mapping);
    public virtual void ProcessKeyManyToOne(KeyManyToOneMapping mapping);
    public virtual void ProcessElement(ElementMapping mapping);
    public virtual void ProcessFilter(FilterMapping mapping);
    public virtual void ProcessFilterDefinition(FilterDefinitionMapping mapping);
    public virtual void ProcessStoredProcedure(StoredProcedureMapping mapping);
    public virtual void ProcessIndex(IIndexMapping indexMapping);
    public virtual void ProcessIndex(IndexMapping indexMapping);
    public virtual void ProcessIndex(IndexManyToManyMapping indexMapping);
    public virtual void ProcessParent(ParentMapping parentMapping);
    public virtual void ProcessTuplizer(TuplizerMapping tuplizerMapping);
    public virtual void ProcessCollection(CollectionMapping mapping);
    public virtual void Visit(IEnumerable`1<HibernateMapping> mappings);
    public virtual void Visit(IdMapping mapping);
    public virtual void Visit(NaturalIdMapping naturalIdMapping);
    public virtual void Visit(ClassMapping classMapping);
    public virtual void Visit(CacheMapping mapping);
    public virtual void Visit(ImportMapping importMapping);
    public virtual void Visit(IIdentityMapping identityMapping);
    public virtual void Visit(CollectionMapping collectionMapping);
    public virtual void Visit(PropertyMapping propertyMapping);
    public virtual void Visit(ManyToOneMapping manyToOneMapping);
    public virtual void Visit(KeyMapping keyMapping);
    public virtual void Visit(ICollectionRelationshipMapping relationshipMapping);
    public virtual void Visit(GeneratorMapping generatorMapping);
    public virtual void Visit(ColumnMapping columnMapping);
    public virtual void Visit(SubclassMapping subclassMapping);
    public virtual void Visit(DiscriminatorMapping discriminatorMapping);
    public virtual void Visit(IComponentMapping componentMapping);
    public virtual void Visit(IIndexMapping indexMapping);
    public virtual void Visit(ParentMapping parentMapping);
    public virtual void Visit(JoinMapping joinMapping);
    public virtual void Visit(CompositeElementMapping compositeElementMapping);
    public virtual void Visit(VersionMapping versionMapping);
    public virtual void Visit(OneToOneMapping mapping);
    public virtual void Visit(OneToManyMapping mapping);
    public virtual void Visit(ManyToManyMapping mapping);
    public virtual void Visit(AnyMapping mapping);
    public virtual void Visit(MetaValueMapping mapping);
    public virtual void Visit(KeyPropertyMapping mapping);
    public virtual void Visit(KeyManyToOneMapping mapping);
    public virtual void Visit(ElementMapping mapping);
    public virtual void Visit(FilterMapping mapping);
    public virtual void Visit(FilterDefinitionMapping mapping);
    public virtual void Visit(StoredProcedureMapping mapping);
    public virtual void Visit(TuplizerMapping mapping);
}
public class FluentNHibernate.Visitors.PairBiDirectionalManyToManySidesDelegate : MulticastDelegate {
    public PairBiDirectionalManyToManySidesDelegate(object object, IntPtr method);
    public virtual void Invoke(CollectionMapping current, IEnumerable`1<CollectionMapping> possibles, bool wasResolved);
    public virtual IAsyncResult BeginInvoke(CollectionMapping current, IEnumerable`1<CollectionMapping> possibles, bool wasResolved, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FluentNHibernate.Visitors.RelationshipKeyPairingVisitor : DefaultMappingModelVisitor {
    public virtual void ProcessManyToOne(ManyToOneMapping thisSide);
}
public class FluentNHibernate.Visitors.RelationshipPairingVisitor : DefaultMappingModelVisitor {
    [CompilerGeneratedAttribute]
private PairBiDirectionalManyToManySidesDelegate <userControlledPair>P;
    private List`1<CollectionMapping> manyToManys;
    private List`1<CollectionMapping> oneToManys;
    private List`1<ManyToOneMapping> references;
    public RelationshipPairingVisitor(PairBiDirectionalManyToManySidesDelegate userControlledPair);
    public virtual void Visit(IEnumerable`1<HibernateMapping> mappings);
    public virtual void ProcessCollection(CollectionMapping mapping);
    public virtual void ProcessManyToOne(ManyToOneMapping manyToOneMapping);
    private static void PairOneToManys(IEnumerable`1<CollectionMapping> collections, IEnumerable`1<ManyToOneMapping> refs);
    private void PairManyToManys(IEnumerable`1<CollectionMapping> rs);
    private static string GetMemberName(Member member);
    private static LikenessContainer GetLikeness(CollectionMapping currentMapping, CollectionMapping mapping);
    private static bool both_collections_point_to_each_others_types(CollectionMapping left, CollectionMapping right);
    private static bool self_referenced_relation_does_not_point_to_itself(CollectionMapping left, CollectionMapping right);
    private static bool likeness_within_threshold(LikenessContainer current);
    private static CollectionMapping PairFuzzyMatches(IEnumerable`1<CollectionMapping> rs, CollectionMapping current, IEnumerable`1<CollectionMapping> potentialOtherSides);
    private static CollectionMapping PairExactMatches(IEnumerable`1<CollectionMapping> rs, CollectionMapping current, IEnumerable`1<CollectionMapping> potentialOtherSides);
    private static CollectionMapping FindAlternative(IEnumerable`1<CollectionMapping> rs, CollectionMapping current, CollectionMapping otherSide);
    private static bool AnyHaveSameLikeness(IEnumerable`1<LikenessContainer> likenesses, LikenessContainer current);
}
public class FluentNHibernate.Visitors.SeparateSubclassVisitor : DefaultMappingModelVisitor {
    [CompilerGeneratedAttribute]
private IIndeterminateSubclassMappingProviderCollection <subclassProviders>P;
    public SeparateSubclassVisitor(IIndeterminateSubclassMappingProviderCollection subclassProviders);
    public virtual void ProcessClass(ClassMapping mapping);
    public virtual void ProcessSubclass(SubclassMapping mapping);
    private IEnumerable`1<IIndeterminateSubclassMappingProvider> FindClosestSubclasses(Type type);
    private SubclassType GetSubclassType(ClassMapping mapping);
    private bool IsMapped(Type type, IIndeterminateSubclassMappingProviderCollection providers);
    private IDictionary`2<int, IList`1<IIndeterminateSubclassMappingProvider>> SortByDistanceFrom(Type parentType, IEnumerable`1<IIndeterminateSubclassMappingProvider> subProviders);
    private bool DistanceFromParentInterface(Type parentType, Type evalType, Int32& level);
    private bool DistanceFromParentBase(Type parentType, Type evalType, Int32& level);
}
public class FluentNHibernate.Visitors.UnresolvedComponentReferenceVisitedException : Exception {
    [CompilerGeneratedAttribute]
private Type <ReferencedComponentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Member <SourceMember>k__BackingField;
    public Type ReferencedComponentType { get; }
    public Type SourceType { get; }
    public Member SourceMember { get; }
    public UnresolvedComponentReferenceVisitedException(Type referencedComponentType, Type sourceType, Member sourceMember);
    [CompilerGeneratedAttribute]
public Type get_ReferencedComponentType();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Member get_SourceMember();
}
public class FluentNHibernate.Visitors.ValidationException : Exception {
    [CompilerGeneratedAttribute]
private Type <RelatedEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resolution>k__BackingField;
    public Type RelatedEntity { get; }
    public string Resolution { get; }
    public ValidationException(string message, string resolution, Type relatedEntity);
    [CompilerGeneratedAttribute]
public Type get_RelatedEntity();
    [CompilerGeneratedAttribute]
public string get_Resolution();
}
public class FluentNHibernate.Visitors.ValidationVisitor : DefaultMappingModelVisitor {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; public set; }
    public virtual void ProcessClass(ClassMapping classMapping);
    public virtual void ProcessCollection(CollectionMapping mapping);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
