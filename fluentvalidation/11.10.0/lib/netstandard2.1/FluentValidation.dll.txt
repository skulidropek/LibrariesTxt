public abstract class FluentValidation.AbstractValidator`1 : object {
    [CompilerGeneratedAttribute]
private TrackingCollection`1<IValidationRuleInternal`1<T>> <Rules>k__BackingField;
    private Func`1<CascadeMode> _classLevelCascadeMode;
    private Func`1<CascadeMode> _ruleLevelCascadeMode;
    internal TrackingCollection`1<IValidationRuleInternal`1<T>> Rules { get; }
    [ObsoleteAttribute("Use ClassLevelCascadeMode and/or RuleLevelCascadeMode instead. CascadeMode will be removed in a future release. For more details, see https://docs.fluentvalidation.net/en/latest/cascade.html")]
public CascadeMode CascadeMode { get; public set; }
    public CascadeMode ClassLevelCascadeMode { get; public set; }
    public CascadeMode RuleLevelCascadeMode { get; public set; }
    [CompilerGeneratedAttribute]
internal TrackingCollection`1<IValidationRuleInternal`1<T>> get_Rules();
    public CascadeMode get_CascadeMode();
    public void set_CascadeMode(CascadeMode value);
    public CascadeMode get_ClassLevelCascadeMode();
    public void set_ClassLevelCascadeMode(CascadeMode value);
    public CascadeMode get_RuleLevelCascadeMode();
    public void set_RuleLevelCascadeMode(CascadeMode value);
    private sealed virtual override ValidationResult FluentValidation.IValidator.Validate(IValidationContext context);
    private sealed virtual override Task`1<ValidationResult> FluentValidation.IValidator.ValidateAsync(IValidationContext context, CancellationToken cancellation);
    public sealed virtual ValidationResult Validate(T instance);
    public sealed virtual Task`1<ValidationResult> ValidateAsync(T instance, CancellationToken cancellation);
    public virtual ValidationResult Validate(ValidationContext`1<T> context);
    [AsyncStateMachineAttribute("FluentValidation.AbstractValidator`1/<ValidateAsync>d__19")]
public virtual Task`1<ValidationResult> ValidateAsync(ValidationContext`1<T> context, CancellationToken cancellation);
    [AsyncStateMachineAttribute("FluentValidation.AbstractValidator`1/<ValidateInternalAsync>d__20")]
private ValueTask`1<ValidationResult> ValidateInternalAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    private void SetExecutedRuleSets(ValidationResult result, ValidationContext`1<T> context);
    public virtual IValidatorDescriptor CreateDescriptor();
    private sealed virtual override bool FluentValidation.IValidator.CanValidateInstancesOfType(Type type);
    public IRuleBuilderInitial`2<T, TProperty> RuleFor(Expression`1<Func`2<T, TProperty>> expression);
    [ObsoleteAttribute("The Transform method is deprecated and will be removed in FluentValidation 12. We recommend using a computed property on your model instead. For details see https://github.com/FluentValidation/FluentValidation/issues/2072")]
public IRuleBuilderInitial`2<T, TTransformed> Transform(Expression`1<Func`2<T, TProperty>> from, Func`2<TProperty, TTransformed> to);
    [ObsoleteAttribute("The Transform method is deprecated and will be removed in FluentValidation 12. We recommend using a computed property on your model instead. For details see https://github.com/FluentValidation/FluentValidation/issues/2072")]
public IRuleBuilderInitial`2<T, TTransformed> Transform(Expression`1<Func`2<T, TProperty>> from, Func`3<T, TProperty, TTransformed> to);
    public IRuleBuilderInitialCollection`2<T, TElement> RuleForEach(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression);
    [ObsoleteAttribute("The TransformForEach method is deprecated and will be removed in FluentValidation 12. We recommend using a computed property on your model instead. For details see https://github.com/FluentValidation/FluentValidation/issues/2072")]
public IRuleBuilderInitialCollection`2<T, TTransformed> TransformForEach(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, Func`2<TElement, TTransformed> to);
    [ObsoleteAttribute("The TransformForEach method is deprecated and will be removed in FluentValidation 12. We recommend using a computed property on your model instead. For details see https://github.com/FluentValidation/FluentValidation/issues/2072")]
public IRuleBuilderInitialCollection`2<T, TTransformed> TransformForEach(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, Func`3<T, TElement, TTransformed> to);
    public void RuleSet(string ruleSetName, Action action);
    public IConditionBuilder When(Func`2<T, bool> predicate, Action action);
    public IConditionBuilder When(Func`3<T, ValidationContext`1<T>, bool> predicate, Action action);
    public IConditionBuilder Unless(Func`2<T, bool> predicate, Action action);
    public IConditionBuilder Unless(Func`3<T, ValidationContext`1<T>, bool> predicate, Action action);
    public IConditionBuilder WhenAsync(Func`3<T, CancellationToken, Task`1<bool>> predicate, Action action);
    public IConditionBuilder WhenAsync(Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, Action action);
    public IConditionBuilder UnlessAsync(Func`3<T, CancellationToken, Task`1<bool>> predicate, Action action);
    public IConditionBuilder UnlessAsync(Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, Action action);
    public void Include(IValidator`1<T> rulesToInclude);
    public void Include(Func`2<T, TValidator> rulesToInclude);
    public sealed virtual IEnumerator`1<IValidationRule> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ObsoleteAttribute("Overriding the EnsureInstanceNotNull method to prevent FluentValidation for throwing an exception for null root models is no longer supported or recommended. The ability to override this method will be removed in FluentValidation 12. For details, see https://github.com/FluentValidation/FluentValidation/issues/2069")]
protected virtual void EnsureInstanceNotNull(object instanceToValidate);
    protected virtual bool PreValidate(ValidationContext`1<T> context, ValidationResult result);
    protected virtual void RaiseValidationException(ValidationContext`1<T> context, ValidationResult result);
    protected virtual void OnRuleAdded(IValidationRule`1<T> rule);
    [CompilerGeneratedAttribute]
private CascadeMode <RuleFor>b__24_0();
    [CompilerGeneratedAttribute]
private CascadeMode <Transform>b__25_0();
    [CompilerGeneratedAttribute]
private CascadeMode <Transform>b__26_0();
    [CompilerGeneratedAttribute]
private CascadeMode <RuleForEach>b__27_0();
    [CompilerGeneratedAttribute]
private CascadeMode <TransformForEach>b__28_0();
    [CompilerGeneratedAttribute]
private CascadeMode <TransformForEach>b__29_0();
    [CompilerGeneratedAttribute]
private CascadeMode <Include>b__39_0();
    [CompilerGeneratedAttribute]
private CascadeMode <Include>b__40_0();
}
public enum FluentValidation.ApplyConditionTo : Enum {
    public int value__;
    public static ApplyConditionTo AllValidators;
    public static ApplyConditionTo CurrentValidator;
}
public class FluentValidation.AssemblyScanner : object {
    private IEnumerable`1<Type> _types;
    public AssemblyScanner(IEnumerable`1<Type> types);
    public static AssemblyScanner FindValidatorsInAssembly(Assembly assembly, bool includeInternalTypes);
    public static AssemblyScanner FindValidatorsInAssemblies(IEnumerable`1<Assembly> assemblies, bool includeInternalTypes);
    public static AssemblyScanner FindValidatorsInAssemblyContaining();
    public static AssemblyScanner FindValidatorsInAssemblyContaining(Type type);
    private IEnumerable`1<AssemblyScanResult> Execute();
    public void ForEach(Action`1<AssemblyScanResult> action);
    public sealed virtual IEnumerator`1<AssemblyScanResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class FluentValidation.AsyncValidatorInvokedSynchronouslyException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private Type <ValidatorType>k__BackingField;
    public Type ValidatorType { get; }
    internal AsyncValidatorInvokedSynchronouslyException(Type validatorType, bool wasInvokedByAspNet);
    internal AsyncValidatorInvokedSynchronouslyException(string message);
    [CompilerGeneratedAttribute]
public Type get_ValidatorType();
    private static string BuildMessage(Type validatorType, bool wasInvokedByMvc);
}
public enum FluentValidation.CascadeMode : Enum {
    public int value__;
    public static CascadeMode Continue;
    [ObsoleteAttribute("The behaviour of StopOnFirstFailure has been replaced by use of the separate validator-level properties ClassLevelCascadeMode and RuleLevelCascadeMode, and their global default equivalents. StopOnFirstFailure will be removed in a later release. For more details, see https://docs.fluentvalidation.net/en/latest/cascade.html .")]
public static CascadeMode StopOnFirstFailure;
    public static CascadeMode Stop;
}
[ExtensionAttribute]
public static class FluentValidation.DefaultValidatorExtensions : object {
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> SetValidator(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, IPropertyValidator`2<T, TProperty> validator);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> SetAsyncValidator(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, IAsyncPropertyValidator`2<T, TProperty> validator);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> NotNull(IRuleBuilder`2<T, TProperty> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Null(IRuleBuilder`2<T, TProperty> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> NotEmpty(IRuleBuilder`2<T, TProperty> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Empty(IRuleBuilder`2<T, TProperty> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Length(IRuleBuilder`2<T, string> ruleBuilder, int min, int max);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Length(IRuleBuilder`2<T, string> ruleBuilder, Func`2<T, int> min, Func`2<T, int> max);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Length(IRuleBuilder`2<T, string> ruleBuilder, int exactLength);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Length(IRuleBuilder`2<T, string> ruleBuilder, Func`2<T, int> exactLength);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, string expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> MaximumLength(IRuleBuilder`2<T, string> ruleBuilder, int maximumLength);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> MinimumLength(IRuleBuilder`2<T, string> ruleBuilder, int minimumLength);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, Func`2<T, string> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, Regex regex);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, Func`2<T, Regex> regex);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, string expression, RegexOptions options);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Matches(IRuleBuilder`2<T, string> ruleBuilder, Func`2<T, string> expression, RegexOptions options);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> EmailAddress(IRuleBuilder`2<T, string> ruleBuilder, EmailValidationMode mode);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> NotEqual(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty toCompare, IEqualityComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> NotEqual(IRuleBuilder`2<T, string> ruleBuilder, string toCompare, IEqualityComparer`1<string> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> NotEqual(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression, IEqualityComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> NotEqual(IRuleBuilder`2<T, string> ruleBuilder, Expression`1<Func`2<T, string>> expression, IEqualityComparer`1<string> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Equal(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty toCompare, IEqualityComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Equal(IRuleBuilder`2<T, string> ruleBuilder, string toCompare, IEqualityComparer`1<string> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Equal(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression, IEqualityComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> Equal(IRuleBuilder`2<T, string> ruleBuilder, Expression`1<Func`2<T, string>> expression, IEqualityComparer`1<string> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Must(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`2<TProperty, bool> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Must(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`3<T, TProperty, bool> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Must(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`4<T, TProperty, ValidationContext`1<T>, bool> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> MustAsync(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`3<TProperty, CancellationToken, Task`1<bool>> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> MustAsync(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`4<T, TProperty, CancellationToken, Task`1<bool>> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> MustAsync(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`5<T, TProperty, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThan(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThan(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThan(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThan(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> LessThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> LessThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThan(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThan(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThan(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> expression);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, TProperty>> valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> GreaterThanOrEqualTo(IRuleBuilder`2<T, TProperty> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, Nullable`1<TProperty>>> valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> GreaterThanOrEqualTo(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, Expression`1<Func`2<T, TProperty>> valueToCompare);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> InclusiveBetween(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty from, TProperty to);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> InclusiveBetween(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty from, TProperty to, IComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> InclusiveBetween(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty from, TProperty to);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> ExclusiveBetween(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty from, TProperty to);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> ExclusiveBetween(IRuleBuilder`2<T, TProperty> ruleBuilder, TProperty from, TProperty to, IComparer`1<TProperty> comparer);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<TProperty>> ExclusiveBetween(IRuleBuilder`2<T, Nullable`1<TProperty>> ruleBuilder, TProperty from, TProperty to);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> CreditCard(IRuleBuilder`2<T, string> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> IsInEnum(IRuleBuilder`2<T, TProperty> ruleBuilder);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the PrecisionScale method instead, which takes precision as the first parameter and scale as the second. See https://github.com/FluentValidation/FluentValidation/issues/2030 for further details")]
public static IRuleBuilderOptions`2<T, decimal> ScalePrecision(IRuleBuilder`2<T, decimal> ruleBuilder, int scale, int precision, bool ignoreTrailingZeros);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the PrecisionScale method instead, which takes precision as the first parameter and scale as the second. See https://github.com/FluentValidation/FluentValidation/issues/2030 for further details")]
public static IRuleBuilderOptions`2<T, Nullable`1<decimal>> ScalePrecision(IRuleBuilder`2<T, Nullable`1<decimal>> ruleBuilder, int scale, int precision, bool ignoreTrailingZeros);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, decimal> PrecisionScale(IRuleBuilder`2<T, decimal> ruleBuilder, int precision, int scale, bool ignoreTrailingZeros);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, Nullable`1<decimal>> PrecisionScale(IRuleBuilder`2<T, Nullable`1<decimal>> ruleBuilder, int precision, int scale, bool ignoreTrailingZeros);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> Custom(IRuleBuilder`2<T, TProperty> ruleBuilder, Action`2<TProperty, ValidationContext`1<T>> action);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> CustomAsync(IRuleBuilder`2<T, TProperty> ruleBuilder, Func`4<TProperty, ValidationContext`1<T>, CancellationToken, Task> action);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, IEnumerable`1<TElement>> ForEach(IRuleBuilder`2<T, IEnumerable`1<TElement>> ruleBuilder, Action`1<IRuleBuilderInitialCollection`2<IEnumerable`1<TElement>, TElement>> action);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, string> IsEnumName(IRuleBuilder`2<T, string> ruleBuilder, Type enumType, bool caseSensitive);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> ChildRules(IRuleBuilder`2<T, TProperty> ruleBuilder, Action`1<InlineValidator`1<TProperty>> action);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> SetInheritanceValidator(IRuleBuilder`2<T, TProperty> ruleBuilder, Action`1<PolymorphicValidator`2<T, TProperty>> validatorConfiguration);
    private static string GetDisplayName(MemberInfo member, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
public static ValidationResult Validate(IValidator`1<T> validator, T instance, Action`1<ValidationStrategy`1<T>> options);
    [ExtensionAttribute]
public static Task`1<ValidationResult> ValidateAsync(IValidator`1<T> validator, T instance, Action`1<ValidationStrategy`1<T>> options, CancellationToken cancellation);
    [ExtensionAttribute]
public static void ValidateAndThrow(IValidator`1<T> validator, T instance);
    [AsyncStateMachineAttribute("FluentValidation.DefaultValidatorExtensions/<ValidateAndThrowAsync>d__79`1")]
[ExtensionAttribute]
public static Task ValidateAndThrowAsync(IValidator`1<T> validator, T instance, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class FluentValidation.DefaultValidatorOptions : object {
    [ExtensionAttribute]
public static IRuleBuilderInitial`2<T, TProperty> Configure(IRuleBuilderInitial`2<T, TProperty> ruleBuilder, Action`1<IValidationRule`2<T, TProperty>> configurator);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Configure(IRuleBuilderOptions`2<T, TProperty> ruleBuilder, Action`1<IValidationRule`2<T, TProperty>> configurator);
    [ExtensionAttribute]
public static IRuleBuilderInitialCollection`2<T, TElement> Configure(IRuleBuilderInitialCollection`2<T, TElement> ruleBuilder, Action`1<ICollectionRule`2<T, TElement>> configurator);
    public static IValidationRule`2<T, TProperty> Configurable(IRuleBuilder`2<T, TProperty> ruleBuilder);
    public static ICollectionRule`2<T, TCollectionElement> Configurable(IRuleBuilderInitialCollection`2<T, TCollectionElement> ruleBuilder);
    [ExtensionAttribute]
public static IRuleBuilderInitial`2<T, TProperty> Cascade(IRuleBuilderInitial`2<T, TProperty> ruleBuilder, CascadeMode cascadeMode);
    [ExtensionAttribute]
public static IRuleBuilderInitialCollection`2<T, TProperty> Cascade(IRuleBuilderInitialCollection`2<T, TProperty> ruleBuilder, CascadeMode cascadeMode);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithMessage(IRuleBuilderOptions`2<T, TProperty> rule, string errorMessage);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithMessage(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, string> messageProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithMessage(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, TProperty, string> messageProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithErrorCode(IRuleBuilderOptions`2<T, TProperty> rule, string errorCode);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> When(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> When(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`2<T, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> When(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> When(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`3<T, ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Unless(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> Unless(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`2<T, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> Unless(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> Unless(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`3<T, ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WhenAsync(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> WhenAsync(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`3<T, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WhenAsync(IRuleBuilderOptions`2<T, TProperty> rule, Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> WhenAsync(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> UnlessAsync(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> UnlessAsync(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`3<T, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> UnlessAsync(IRuleBuilderOptions`2<T, TProperty> rule, Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderOptionsConditions`2<T, TProperty> UnlessAsync(IRuleBuilderOptionsConditions`2<T, TProperty> rule, Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    [ExtensionAttribute]
public static IRuleBuilderInitialCollection`2<T, TCollectionElement> Where(IRuleBuilderInitialCollection`2<T, TCollectionElement> rule, Func`2<TCollectionElement, bool> predicate);
    [ExtensionAttribute]
public static IRuleBuilderInitialCollection`2<T, TCollectionElement> WhereAsync(IRuleBuilderInitialCollection`2<T, TCollectionElement> rule, Func`2<TCollectionElement, Task`1<bool>> predicate);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithName(IRuleBuilderOptions`2<T, TProperty> rule, string overridePropertyName);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithName(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, string> nameProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> OverridePropertyName(IRuleBuilderOptions`2<T, TProperty> rule, string propertyName);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> OverridePropertyName(IRuleBuilderOptions`2<T, TProperty> rule, Expression`1<Func`2<T, object>> expr);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithState(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, object> stateProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithState(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, TProperty, object> stateProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithSeverity(IRuleBuilderOptions`2<T, TProperty> rule, Severity severity);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithSeverity(IRuleBuilderOptions`2<T, TProperty> rule, Func`2<T, Severity> severityProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithSeverity(IRuleBuilderOptions`2<T, TProperty> rule, Func`3<T, TProperty, Severity> severityProvider);
    [ExtensionAttribute]
public static IRuleBuilderOptions`2<T, TProperty> WithSeverity(IRuleBuilderOptions`2<T, TProperty> rule, Func`4<T, TProperty, ValidationContext`1<T>, Severity> severityProvider);
    [ExtensionAttribute]
public static IRuleBuilderInitialCollection`2<T, TCollectionElement> OverrideIndexer(IRuleBuilderInitialCollection`2<T, TCollectionElement> rule, Func`5<T, IEnumerable`1<TCollectionElement>, TCollectionElement, int, string> callback);
}
public interface FluentValidation.ICollectionRule`2 {
    public Func`2<TElement, bool> Filter { get; public set; }
    public Func`5<T, IEnumerable`1<TElement>, TElement, int, string> IndexBuilder { get; public set; }
    public abstract virtual Func`2<TElement, bool> get_Filter();
    public abstract virtual void set_Filter(Func`2<TElement, bool> value);
    public abstract virtual Func`5<T, IEnumerable`1<TElement>, TElement, int, string> get_IndexBuilder();
    public abstract virtual void set_IndexBuilder(Func`5<T, IEnumerable`1<TElement>, TElement, int, string> value);
}
public interface FluentValidation.IConditionBuilder {
    public abstract virtual void Otherwise(Action action);
}
internal interface FluentValidation.IHasFailures {
    public List`1<ValidationFailure> Failures { get; }
    public abstract virtual List`1<ValidationFailure> get_Failures();
}
public class FluentValidation.InlineValidator`1 : AbstractValidator`1<T> {
    public void Add(Func`2<InlineValidator`1<T>, IRuleBuilderOptions`2<T, TProperty>> ruleCreator);
}
public static class FluentValidation.Internal.AccessorCache`1 : object {
    private static ConcurrentDictionary`2<Key<T>, Delegate> _cache;
    private static AccessorCache`1();
    public static Func`2<T, TProperty> GetCachedAccessor(MemberInfo member, Expression`1<Func`2<T, TProperty>> expression, bool bypassCache, string cachePrefix);
    public static void Clear();
}
internal class FluentValidation.Internal.AsyncConditionBuilder`1 : object {
    private TrackingCollection`1<IValidationRuleInternal`1<T>> _rules;
    public AsyncConditionBuilder`1(TrackingCollection`1<IValidationRuleInternal`1<T>> rules);
    public IConditionBuilder WhenAsync(Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, Action action);
    public IConditionBuilder UnlessAsync(Func`4<T, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, Action action);
}
internal class FluentValidation.Internal.AsyncConditionOtherwiseBuilder`1 : object {
    private TrackingCollection`1<IValidationRuleInternal`1<T>> _rules;
    private Func`3<IValidationContext, CancellationToken, Task`1<bool>> _condition;
    public AsyncConditionOtherwiseBuilder`1(TrackingCollection`1<IValidationRuleInternal`1<T>> rules, Func`3<IValidationContext, CancellationToken, Task`1<bool>> condition);
    public virtual void Otherwise(Action action);
    [AsyncStateMachineAttribute("FluentValidation.Internal.AsyncConditionOtherwiseBuilder`1/<<Otherwise>b__3_0>d")]
[CompilerGeneratedAttribute]
private Task`1<bool> <Otherwise>b__3_0(ValidationContext`1<T> ctx, CancellationToken ct);
}
internal class FluentValidation.Internal.ChildRulesContainer`1 : InlineValidator`1<T> {
    internal String[] RuleSetsToApplyToChildRules;
}
internal class FluentValidation.Internal.CollectionPropertyRule`2 : RuleBase`3<T, IEnumerable`1<TElement>, TElement> {
    [CompilerGeneratedAttribute]
private Func`2<TElement, bool> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TElement, Task`1<bool>> <AsyncFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`5<T, IEnumerable`1<TElement>, TElement, int, string> <IndexBuilder>k__BackingField;
    public Func`2<TElement, bool> Filter { get; public set; }
    public Func`2<TElement, Task`1<bool>> AsyncFilter { get; public set; }
    public Func`5<T, IEnumerable`1<TElement>, TElement, int, string> IndexBuilder { get; public set; }
    public CollectionPropertyRule`2(MemberInfo member, Func`2<T, IEnumerable`1<TElement>> propertyFunc, LambdaExpression expression, Func`1<CascadeMode> cascadeModeThunk, Type typeToValidate);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<TElement, bool> get_Filter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Filter(Func`2<TElement, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<TElement, Task`1<bool>> get_AsyncFilter();
    [CompilerGeneratedAttribute]
public void set_AsyncFilter(Func`2<TElement, Task`1<bool>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`5<T, IEnumerable`1<TElement>, TElement, int, string> get_IndexBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexBuilder(Func`5<T, IEnumerable`1<TElement>, TElement, int, string> value);
    public static CollectionPropertyRule`2<T, TElement> Create(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    internal static CollectionPropertyRule`2<T, TElement> CreateTransformed(Expression`1<Func`2<T, IEnumerable`1<TOriginal>>> expression, Func`2<TOriginal, TElement> transformer, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    internal static CollectionPropertyRule`2<T, TElement> CreateTransformed(Expression`1<Func`2<T, IEnumerable`1<TOriginal>>> expression, Func`3<T, TOriginal, TElement> transformer, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    [AsyncStateMachineAttribute("FluentValidation.Internal.CollectionPropertyRule`2/<FluentValidation-IValidationRuleInternal<T>-ValidateAsync>d__16")]
private sealed virtual override ValueTask FluentValidation.IValidationRuleInternal<T>.ValidateAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    private sealed virtual override void FluentValidation.IValidationRuleInternal<T>.AddDependentRules(IEnumerable`1<IValidationRuleInternal`1<T>> rules);
    [AsyncStateMachineAttribute("FluentValidation.Internal.CollectionPropertyRule`2/<GetValidatorsToExecuteAsync>d__18")]
private ValueTask`1<List`1<RuleComponent`2<T, TElement>>> GetValidatorsToExecuteAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    private static string InferPropertyName(LambdaExpression expression);
}
internal class FluentValidation.Internal.CompositeValidatorSelector : object {
    private IEnumerable`1<IValidatorSelector> _selectors;
    public CompositeValidatorSelector(IEnumerable`1<IValidatorSelector> selectors);
    public sealed virtual bool CanExecute(IValidationRule rule, string propertyPath, IValidationContext context);
}
internal class FluentValidation.Internal.ConditionBuilder`1 : object {
    private TrackingCollection`1<IValidationRuleInternal`1<T>> _rules;
    public ConditionBuilder`1(TrackingCollection`1<IValidationRuleInternal`1<T>> rules);
    public IConditionBuilder When(Func`3<T, ValidationContext`1<T>, bool> predicate, Action action);
    public IConditionBuilder Unless(Func`3<T, ValidationContext`1<T>, bool> predicate, Action action);
}
internal class FluentValidation.Internal.ConditionOtherwiseBuilder`1 : object {
    private TrackingCollection`1<IValidationRuleInternal`1<T>> _rules;
    private Func`2<IValidationContext, bool> _condition;
    public ConditionOtherwiseBuilder`1(TrackingCollection`1<IValidationRuleInternal`1<T>> rules, Func`2<IValidationContext, bool> condition);
    public virtual void Otherwise(Action action);
    [CompilerGeneratedAttribute]
private bool <Otherwise>b__3_0(ValidationContext`1<T> ctx);
}
public class FluentValidation.Internal.DefaultValidatorSelector : object {
    public sealed virtual bool CanExecute(IValidationRule rule, string propertyPath, IValidationContext context);
}
[ExtensionAttribute]
public static class FluentValidation.Internal.Extensions : object {
    [ExtensionAttribute]
public static MemberInfo GetMember(Expression`1<Func`2<T, TProperty>> expression);
    private static Expression RemoveUnary(Expression toUnwrap);
}
[ExtensionAttribute]
internal static class FluentValidation.Internal.ExtensionsInternal : object {
    [ExtensionAttribute]
internal static void Guard(object obj, string message, string paramName);
    [ExtensionAttribute]
internal static void Guard(string str, string message, string paramName);
    [ExtensionAttribute]
internal static bool IsParameterExpression(LambdaExpression expression);
    [ExtensionAttribute]
internal static string SplitPascalCase(string input);
    [ExtensionAttribute]
internal static T GetOrAdd(IDictionary`2<string, object> dict, string key, Func`1<T> value);
    [ExtensionAttribute]
internal static string ResolveErrorMessageUsingErrorCode(ILanguageManager languageManager, string errorCode, string fallbackKey);
}
public interface FluentValidation.Internal.IIncludeRule {
}
public interface FluentValidation.Internal.IMessageBuilderContext`2 {
    public IRuleComponent`2<T, TProperty> Component { get; }
    public IPropertyValidator PropertyValidator { get; }
    public ValidationContext`1<T> ParentContext { get; }
    public string PropertyName { get; }
    public string DisplayName { get; }
    public MessageFormatter MessageFormatter { get; }
    public T InstanceToValidate { get; }
    public TProperty PropertyValue { get; }
    public abstract virtual IRuleComponent`2<T, TProperty> get_Component();
    public abstract virtual IPropertyValidator get_PropertyValidator();
    public abstract virtual ValidationContext`1<T> get_ParentContext();
    public abstract virtual string get_PropertyName();
    public abstract virtual string get_DisplayName();
    public abstract virtual MessageFormatter get_MessageFormatter();
    public abstract virtual T get_InstanceToValidate();
    public abstract virtual TProperty get_PropertyValue();
    public abstract virtual string GetDefaultMessage();
}
internal class FluentValidation.Internal.IncludeRule`1 : PropertyRule`2<T, T> {
    public IncludeRule`1(IValidator`1<T> validator, Func`1<CascadeMode> cascadeModeThunk, Type typeToValidate);
    public IncludeRule`1(Func`3<ValidationContext`1<T>, T, IValidator`1<T>> func, Func`1<CascadeMode> cascadeModeThunk, Type typeToValidate, Type validatorType);
    public static IncludeRule`1<T> Create(IValidator`1<T> validator, Func`1<CascadeMode> cascadeModeThunk);
    public static IncludeRule`1<T> Create(Func`2<T, TValidator> func, Func`1<CascadeMode> cascadeModeThunk);
    [AsyncStateMachineAttribute("FluentValidation.Internal.IncludeRule`1/<ValidateAsync>d__4")]
public virtual ValueTask ValidateAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
}
public interface FluentValidation.Internal.IRuleComponent {
    public bool HasCondition { get; }
    public bool HasAsyncCondition { get; }
    public IPropertyValidator Validator { get; }
    public string ErrorCode { get; }
    public abstract virtual bool get_HasCondition();
    public abstract virtual bool get_HasAsyncCondition();
    public abstract virtual IPropertyValidator get_Validator();
    public abstract virtual string GetUnformattedErrorMessage();
    public abstract virtual string get_ErrorCode();
}
public interface FluentValidation.Internal.IRuleComponent`2 {
    public string ErrorCode { get; public set; }
    unknown Func`3<ValidationContext`1<T>, TProperty, object> CustomStateProvider {public set; }
    unknown Func`3<ValidationContext`1<T>, TProperty, Severity> SeverityProvider {public set; }
    public abstract virtual string get_ErrorCode();
    public abstract virtual void set_ErrorCode(string value);
    public abstract virtual void set_CustomStateProvider(Func`3<ValidationContext`1<T>, TProperty, object> value);
    public abstract virtual void set_SeverityProvider(Func`3<ValidationContext`1<T>, TProperty, Severity> value);
    public abstract virtual void ApplyCondition(Func`2<ValidationContext`1<T>, bool> condition);
    public abstract virtual void ApplyAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> condition);
    public abstract virtual void SetErrorMessage(Func`3<ValidationContext`1<T>, TProperty, string> errorFactory);
    public abstract virtual void SetErrorMessage(string errorMessage);
}
public interface FluentValidation.Internal.IValidatorSelector {
    public abstract virtual bool CanExecute(IValidationRule rule, string propertyPath, IValidationContext context);
}
public class FluentValidation.Internal.MemberNameValidatorSelector : object {
    internal static string DisableCascadeKey;
    private IEnumerable`1<string> _memberNames;
    private static Regex _collectionIndexNormalizer;
    public IEnumerable`1<string> MemberNames { get; }
    public MemberNameValidatorSelector(IEnumerable`1<string> memberNames);
    private static MemberNameValidatorSelector();
    public IEnumerable`1<string> get_MemberNames();
    public sealed virtual bool CanExecute(IValidationRule rule, string propertyPath, IValidationContext context);
    public static String[] MemberNamesFromExpressions(Expression`1[] propertyExpressions);
    private static string MemberFromExpression(Expression`1<Func`2<T, object>> expression);
}
public class FluentValidation.Internal.MessageBuilderContext`2 : object {
    private ValidationContext`1<T> _innerContext;
    private TProperty _value;
    [CompilerGeneratedAttribute]
private RuleComponent`2<T, TProperty> <Component>k__BackingField;
    public RuleComponent`2<T, TProperty> Component { get; }
    private IRuleComponent`2<T, TProperty> FluentValidation.Internal.IMessageBuilderContext<T,TProperty>.Component { get; }
    public IPropertyValidator PropertyValidator { get; }
    public ValidationContext`1<T> ParentContext { get; }
    public string PropertyName { get; }
    public string DisplayName { get; }
    public MessageFormatter MessageFormatter { get; }
    public T InstanceToValidate { get; }
    public TProperty PropertyValue { get; }
    public MessageBuilderContext`2(ValidationContext`1<T> innerContext, TProperty value, RuleComponent`2<T, TProperty> component);
    [CompilerGeneratedAttribute]
public RuleComponent`2<T, TProperty> get_Component();
    private sealed virtual override IRuleComponent`2<T, TProperty> FluentValidation.Internal.IMessageBuilderContext<T,TProperty>.get_Component();
    public sealed virtual IPropertyValidator get_PropertyValidator();
    public sealed virtual ValidationContext`1<T> get_ParentContext();
    public sealed virtual string get_PropertyName();
    public sealed virtual string get_DisplayName();
    public sealed virtual MessageFormatter get_MessageFormatter();
    public sealed virtual T get_InstanceToValidate();
    public sealed virtual TProperty get_PropertyValue();
    public sealed virtual string GetDefaultMessage();
}
public class FluentValidation.Internal.MessageFormatter : object {
    private Dictionary`2<string, object> _placeholderValues;
    private static Regex _keyRegex;
    public static string PropertyName;
    public static string PropertyValue;
    public Dictionary`2<string, object> PlaceholderValues { get; }
    private static MessageFormatter();
    public MessageFormatter AppendArgument(string name, object value);
    public MessageFormatter AppendPropertyName(string name);
    public MessageFormatter AppendPropertyValue(object value);
    public virtual string BuildMessage(string messageTemplate);
    public Dictionary`2<string, object> get_PlaceholderValues();
    internal void Reset();
    [CompilerGeneratedAttribute]
private string <BuildMessage>b__7_0(Match m);
}
public class FluentValidation.Internal.PropertyChain : object {
    private List`1<string> _memberNames;
    public int Count { get; }
    public PropertyChain(PropertyChain parent);
    public PropertyChain(IEnumerable`1<string> memberNames);
    public static PropertyChain FromExpression(LambdaExpression expression);
    public void Add(MemberInfo member);
    public void Add(string propertyName);
    public void AddIndexer(object indexer, bool surroundWithBrackets);
    public virtual string ToString();
    public bool IsChildChainOf(PropertyChain parentChain);
    [ObsoleteAttribute("BuildPropertyName is deprecated due to its misleading name. Use BuildPropertyPath instead which does the same thing.")]
public string BuildPropertyName(string propertyName);
    public string BuildPropertyPath(string propertyName);
    public int get_Count();
}
internal class FluentValidation.Internal.PropertyRule`2 : RuleBase`3<T, TProperty, TProperty> {
    public PropertyRule`2(MemberInfo member, Func`2<T, TProperty> propertyFunc, LambdaExpression expression, Func`1<CascadeMode> cascadeModeThunk, Type typeToValidate);
    public static PropertyRule`2<T, TProperty> Create(Expression`1<Func`2<T, TProperty>> expression, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    internal static PropertyRule`2<T, TProperty> Create(Expression`1<Func`2<T, TOld>> expression, Func`2<TOld, TProperty> transformer, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    internal static PropertyRule`2<T, TProperty> Create(Expression`1<Func`2<T, TOld>> expression, Func`3<T, TOld, TProperty> transformer, Func`1<CascadeMode> cascadeModeThunk, bool bypassCache);
    [AsyncStateMachineAttribute("FluentValidation.Internal.PropertyRule`2/<ValidateAsync>d__4")]
public virtual ValueTask ValidateAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    private sealed virtual override void FluentValidation.IValidationRuleInternal<T>.AddDependentRules(IEnumerable`1<IValidationRuleInternal`1<T>> rules);
}
internal abstract class FluentValidation.Internal.RuleBase`3 : object {
    private List`1<RuleComponent`2<T, TValue>> _components;
    private Func`1<CascadeMode> _cascadeModeThunk;
    private string _propertyDisplayName;
    private string _propertyName;
    private Func`2<ValidationContext`1<T>, bool> _condition;
    private Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> _asyncCondition;
    private string _displayName;
    private Func`2<ValidationContext`1<T>, string> _displayNameFactory;
    protected Func`2<ValidationContext`1<T>, string> _displayNameFunc;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, TProperty> <PropertyFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RuleSets>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeToValidate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IMessageBuilderContext`2<T, TValue>, string> <MessageBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IValidationRuleInternal`1<T>> <DependentRules>k__BackingField;
    public List`1<RuleComponent`2<T, TValue>> Components { get; }
    private IEnumerable`1<IRuleComponent> FluentValidation.IValidationRule.Components { get; }
    internal Func`2<ValidationContext`1<T>, bool> Condition { get; }
    internal Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> AsyncCondition { get; }
    public MemberInfo Member { get; }
    public Func`2<T, TProperty> PropertyFunc { get; }
    public LambdaExpression Expression { get; }
    public String[] RuleSets { get; public set; }
    public IRuleComponent`2<T, TValue> Current { get; }
    public Type TypeToValidate { get; }
    public bool HasCondition { get; }
    public bool HasAsyncCondition { get; }
    public CascadeMode CascadeMode { get; public set; }
    public string PropertyName { get; public set; }
    public Func`2<IMessageBuilderContext`2<T, TValue>, string> MessageBuilder { get; public set; }
    internal List`1<IValidationRuleInternal`1<T>> DependentRules { get; private protected set; }
    private IEnumerable`1<IValidationRule> FluentValidation.IValidationRule.DependentRules { get; }
    public RuleBase`3(MemberInfo member, Func`2<T, TProperty> propertyFunc, LambdaExpression expression, Func`1<CascadeMode> cascadeModeThunk, Type typeToValidate);
    public sealed virtual List`1<RuleComponent`2<T, TValue>> get_Components();
    private sealed virtual override IEnumerable`1<IRuleComponent> FluentValidation.IValidationRule.get_Components();
    internal Func`2<ValidationContext`1<T>, bool> get_Condition();
    internal Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> get_AsyncCondition();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Func`2<T, TProperty> get_PropertyFunc();
    [CompilerGeneratedAttribute]
public sealed virtual LambdaExpression get_Expression();
    public sealed virtual void SetDisplayName(string name);
    public sealed virtual void SetDisplayName(Func`2<ValidationContext`1<T>, string> factory);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_RuleSets();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RuleSets(String[] value);
    public sealed virtual IRuleComponent`2<T, TValue> get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TypeToValidate();
    public sealed virtual bool get_HasCondition();
    public sealed virtual bool get_HasAsyncCondition();
    public sealed virtual CascadeMode get_CascadeMode();
    public sealed virtual void set_CascadeMode(CascadeMode value);
    public sealed virtual void AddValidator(IPropertyValidator`2<T, TValue> validator);
    public sealed virtual void AddAsyncValidator(IAsyncPropertyValidator`2<T, TValue> asyncValidator, IPropertyValidator`2<T, TValue> fallback);
    public void ClearValidators();
    public sealed virtual string get_PropertyName();
    public sealed virtual void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Func`2<IMessageBuilderContext`2<T, TValue>, string> get_MessageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageBuilder(Func`2<IMessageBuilderContext`2<T, TValue>, string> value);
    [CompilerGeneratedAttribute]
internal List`1<IValidationRuleInternal`1<T>> get_DependentRules();
    [CompilerGeneratedAttribute]
private protected void set_DependentRules(List`1<IValidationRuleInternal`1<T>> value);
    private sealed virtual override IEnumerable`1<IValidationRule> FluentValidation.IValidationRule.get_DependentRules();
    private sealed virtual override string FluentValidation.IValidationRule.GetDisplayName(IValidationContext context);
    public string GetDisplayName(ValidationContext`1<T> context);
    public sealed virtual void ApplyCondition(Func`2<ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    public sealed virtual void ApplyAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    public sealed virtual void ApplySharedCondition(Func`2<ValidationContext`1<T>, bool> condition);
    public sealed virtual void ApplySharedAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> condition);
    private sealed virtual override object FluentValidation.IValidationRule<T>.GetPropertyValue(T instance);
    protected void PrepareMessageFormatterForValidationError(ValidationContext`1<T> context, TValue value);
    protected ValidationFailure CreateValidationError(ValidationContext`1<T> context, TValue value, RuleComponent`2<T, TValue> component);
}
internal class FluentValidation.Internal.RuleBuilder`2 : object {
    [CompilerGeneratedAttribute]
private IValidationRuleInternal`2<T, TProperty> <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private AbstractValidator`1<T> <ParentValidator>k__BackingField;
    public IValidationRuleInternal`2<T, TProperty> Rule { get; }
    private IValidationRule`2<T, TProperty> FluentValidation.IRuleBuilderInternal<T,TProperty>.Rule { get; }
    public AbstractValidator`1<T> ParentValidator { get; }
    public RuleBuilder`2(IValidationRuleInternal`2<T, TProperty> rule, AbstractValidator`1<T> parent);
    [CompilerGeneratedAttribute]
public IValidationRuleInternal`2<T, TProperty> get_Rule();
    private sealed virtual override IValidationRule`2<T, TProperty> FluentValidation.IRuleBuilderInternal<T,TProperty>.get_Rule();
    [CompilerGeneratedAttribute]
public sealed virtual AbstractValidator`1<T> get_ParentValidator();
    public sealed virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(IPropertyValidator`2<T, TProperty> validator);
    public sealed virtual IRuleBuilderOptions`2<T, TProperty> SetAsyncValidator(IAsyncPropertyValidator`2<T, TProperty> validator);
    public sealed virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(IValidator`1<TProperty> validator, String[] ruleSets);
    public sealed virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(Func`2<T, TValidator> validatorProvider, String[] ruleSets);
    public sealed virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(Func`3<T, TProperty, TValidator> validatorProvider, String[] ruleSets);
    private sealed virtual override IRuleBuilderOptions`2<T, TProperty> FluentValidation.IRuleBuilderOptions<T,TProperty>.DependentRules(Action action);
    public void AddComponent(RuleComponent`2<T, TProperty> component);
}
public class FluentValidation.Internal.RuleComponent`2 : object {
    private string _errorMessage;
    private Func`3<ValidationContext`1<T>, TProperty, string> _errorMessageFactory;
    private Func`2<ValidationContext`1<T>, bool> _condition;
    private Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> _asyncCondition;
    private IPropertyValidator`2<T, TProperty> _propertyValidator;
    private IAsyncPropertyValidator`2<T, TProperty> _asyncPropertyValidator;
    [CompilerGeneratedAttribute]
private Func`3<ValidationContext`1<T>, TProperty, object> <CustomStateProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<ValidationContext`1<T>, TProperty, Severity> <SeverityProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    public bool HasCondition { get; }
    public bool HasAsyncCondition { get; }
    public IPropertyValidator Validator { get; }
    private protected bool SupportsAsynchronousValidation { get; }
    private protected bool SupportsSynchronousValidation { get; }
    public Func`3<ValidationContext`1<T>, TProperty, object> CustomStateProvider { get; public set; }
    public Func`3<ValidationContext`1<T>, TProperty, Severity> SeverityProvider { get; public set; }
    public string ErrorCode { get; public set; }
    internal RuleComponent`2(IPropertyValidator`2<T, TProperty> propertyValidator);
    internal RuleComponent`2(IAsyncPropertyValidator`2<T, TProperty> asyncPropertyValidator, IPropertyValidator`2<T, TProperty> propertyValidator);
    public sealed virtual bool get_HasCondition();
    public sealed virtual bool get_HasAsyncCondition();
    public virtual IPropertyValidator get_Validator();
    private protected virtual bool get_SupportsAsynchronousValidation();
    private protected virtual bool get_SupportsSynchronousValidation();
    [AsyncStateMachineAttribute("FluentValidation.Internal.RuleComponent`2/<ValidateAsync>d__18")]
internal ValueTask`1<bool> ValidateAsync(ValidationContext`1<T> context, TProperty value, bool useAsync, CancellationToken cancellation);
    private protected virtual bool InvokePropertyValidator(ValidationContext`1<T> context, TProperty value);
    private protected virtual Task`1<bool> InvokePropertyValidatorAsync(ValidationContext`1<T> context, TProperty value, CancellationToken cancellation);
    public sealed virtual void ApplyCondition(Func`2<ValidationContext`1<T>, bool> condition);
    public sealed virtual void ApplyAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> condition);
    internal bool InvokeCondition(ValidationContext`1<T> context);
    [AsyncStateMachineAttribute("FluentValidation.Internal.RuleComponent`2/<InvokeAsyncCondition>d__24")]
internal Task`1<bool> InvokeAsyncCondition(ValidationContext`1<T> context, CancellationToken token);
    [CompilerGeneratedAttribute]
public Func`3<ValidationContext`1<T>, TProperty, object> get_CustomStateProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CustomStateProvider(Func`3<ValidationContext`1<T>, TProperty, object> value);
    [CompilerGeneratedAttribute]
public Func`3<ValidationContext`1<T>, TProperty, Severity> get_SeverityProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SeverityProvider(Func`3<ValidationContext`1<T>, TProperty, Severity> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ErrorCode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ErrorCode(string value);
    public string GetErrorMessage(ValidationContext`1<T> context, TProperty value);
    public sealed virtual string GetUnformattedErrorMessage();
    public sealed virtual void SetErrorMessage(Func`3<ValidationContext`1<T>, TProperty, string> errorFactory);
    public sealed virtual void SetErrorMessage(string errorMessage);
}
internal class FluentValidation.Internal.RuleComponentForNullableStruct`2 : RuleComponent`2<T, Nullable`1<TProperty>> {
    private IPropertyValidator`2<T, TProperty> _propertyValidator;
    private IAsyncPropertyValidator`2<T, TProperty> _asyncPropertyValidator;
    public IPropertyValidator Validator { get; }
    private protected bool SupportsAsynchronousValidation { get; }
    private protected bool SupportsSynchronousValidation { get; }
    internal RuleComponentForNullableStruct`2(IPropertyValidator`2<T, TProperty> propertyValidator);
    internal RuleComponentForNullableStruct`2(IAsyncPropertyValidator`2<T, TProperty> asyncPropertyValidator, IPropertyValidator`2<T, TProperty> propertyValidator);
    public virtual IPropertyValidator get_Validator();
    private protected virtual bool get_SupportsAsynchronousValidation();
    private protected virtual bool get_SupportsSynchronousValidation();
    private protected virtual bool InvokePropertyValidator(ValidationContext`1<T> context, Nullable`1<TProperty> value);
    [AsyncStateMachineAttribute("FluentValidation.Internal.RuleComponentForNullableStruct`2/<InvokePropertyValidatorAsync>d__11")]
private protected virtual Task`1<bool> InvokePropertyValidatorAsync(ValidationContext`1<T> context, Nullable`1<TProperty> value, CancellationToken cancellation);
}
public class FluentValidation.Internal.RulesetValidatorSelector : object {
    private IEnumerable`1<string> _rulesetsToExecute;
    public static string DefaultRuleSetName;
    public static string WildcardRuleSetName;
    internal static String[] DefaultRuleSetNameInArray;
    public IEnumerable`1<string> RuleSets { get; }
    public RulesetValidatorSelector(IEnumerable`1<string> rulesetsToExecute);
    private static RulesetValidatorSelector();
    public IEnumerable`1<string> get_RuleSets();
    public virtual bool CanExecute(IValidationRule rule, string propertyPath, IValidationContext context);
    protected bool IsIncludeRule(IValidationRule rule);
    internal static String[] LegacyRulesetSplit(string ruleSet);
}
[DefaultMemberAttribute("Item")]
internal class FluentValidation.Internal.TrackingCollection`1 : object {
    private List`1<T> _innerCollection;
    [CompilerGeneratedAttribute]
private Action`1<T> ItemAdded;
    private Action`1<T> _capture;
    public int Count { get; }
    public T Item { get; }
    [CompilerGeneratedAttribute]
public void add_ItemAdded(Action`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ItemAdded(Action`1<T> value);
    public void Add(T item);
    public int get_Count();
    public T get_Item(int index);
    public void Remove(T item);
    public IDisposable OnItemAdded(Action`1<T> onItemAdded);
    internal IDisposable Capture(Action`1<T> onItemAdded);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class FluentValidation.Internal.ValidationStrategy`1 : object {
    private List`1<string> _properties;
    private List`1<string> _ruleSets;
    private bool _throw;
    private IValidatorSelector _customSelector;
    public ValidationStrategy`1<T> IncludeProperties(String[] properties);
    public ValidationStrategy`1<T> IncludeProperties(Expression`1[] propertyExpressions);
    public ValidationStrategy`1<T> IncludeRulesNotInRuleSet();
    public ValidationStrategy`1<T> IncludeAllRuleSets();
    public ValidationStrategy`1<T> IncludeRuleSets(String[] ruleSets);
    public ValidationStrategy`1<T> UseCustomSelector(IValidatorSelector selector);
    public ValidationStrategy`1<T> ThrowOnFailures();
    private IValidatorSelector GetSelector();
    internal ValidationContext`1<T> BuildContext(T instance);
}
public interface FluentValidation.IRuleBuilder`2 {
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(IPropertyValidator`2<T, TProperty> validator);
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> SetAsyncValidator(IAsyncPropertyValidator`2<T, TProperty> validator);
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(IValidator`1<TProperty> validator, String[] ruleSets);
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(Func`2<T, TValidator> validatorProvider, String[] ruleSets);
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> SetValidator(Func`3<T, TProperty, TValidator> validatorProvider, String[] ruleSets);
}
public interface FluentValidation.IRuleBuilderInitial`2 {
}
public interface FluentValidation.IRuleBuilderInitialCollection`2 {
}
internal interface FluentValidation.IRuleBuilderInternal`1 {
    public AbstractValidator`1<T> ParentValidator { get; }
    public abstract virtual AbstractValidator`1<T> get_ParentValidator();
}
internal interface FluentValidation.IRuleBuilderInternal`2 {
    public IValidationRule`2<T, TProperty> Rule { get; }
    public abstract virtual IValidationRule`2<T, TProperty> get_Rule();
}
public interface FluentValidation.IRuleBuilderOptions`2 {
    public abstract virtual IRuleBuilderOptions`2<T, TProperty> DependentRules(Action action);
}
public interface FluentValidation.IRuleBuilderOptionsConditions`2 {
}
public interface FluentValidation.IValidationContext {
    public object InstanceToValidate { get; }
    public IDictionary`2<string, object> RootContextData { get; }
    public PropertyChain PropertyChain { get; }
    public IValidatorSelector Selector { get; }
    public bool IsChildContext { get; }
    public bool IsChildCollectionContext { get; }
    public IValidationContext ParentContext { get; }
    public bool IsAsync { get; }
    public bool ThrowOnFailures { get; }
    public abstract virtual object get_InstanceToValidate();
    public abstract virtual IDictionary`2<string, object> get_RootContextData();
    public abstract virtual PropertyChain get_PropertyChain();
    public abstract virtual IValidatorSelector get_Selector();
    public abstract virtual bool get_IsChildContext();
    public abstract virtual bool get_IsChildCollectionContext();
    public abstract virtual IValidationContext get_ParentContext();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_ThrowOnFailures();
}
public interface FluentValidation.IValidationRule {
    public IEnumerable`1<IRuleComponent> Components { get; }
    public String[] RuleSets { get; public set; }
    public string PropertyName { get; public set; }
    public MemberInfo Member { get; }
    public Type TypeToValidate { get; }
    public bool HasCondition { get; }
    public bool HasAsyncCondition { get; }
    public LambdaExpression Expression { get; }
    public IEnumerable`1<IValidationRule> DependentRules { get; }
    public abstract virtual IEnumerable`1<IRuleComponent> get_Components();
    public abstract virtual String[] get_RuleSets();
    public abstract virtual void set_RuleSets(String[] value);
    public abstract virtual string GetDisplayName(IValidationContext context);
    public abstract virtual string get_PropertyName();
    public abstract virtual void set_PropertyName(string value);
    public abstract virtual MemberInfo get_Member();
    public abstract virtual Type get_TypeToValidate();
    public abstract virtual bool get_HasCondition();
    public abstract virtual bool get_HasAsyncCondition();
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual IEnumerable`1<IValidationRule> get_DependentRules();
}
public interface FluentValidation.IValidationRule`1 {
    public abstract virtual void ApplyCondition(Func`2<ValidationContext`1<T>, bool> predicate, ApplyConditionTo applyConditionTo);
    public abstract virtual void ApplyAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate, ApplyConditionTo applyConditionTo);
    public abstract virtual void ApplySharedCondition(Func`2<ValidationContext`1<T>, bool> condition);
    public abstract virtual void ApplySharedAsyncCondition(Func`3<ValidationContext`1<T>, CancellationToken, Task`1<bool>> condition);
    public abstract virtual object GetPropertyValue(T instance);
}
public interface FluentValidation.IValidationRule`2 {
    public CascadeMode CascadeMode { get; public set; }
    public IRuleComponent`2<T, TProperty> Current { get; }
    unknown Func`2<IMessageBuilderContext`2<T, TProperty>, string> MessageBuilder {public set; }
    public abstract virtual CascadeMode get_CascadeMode();
    public abstract virtual void set_CascadeMode(CascadeMode value);
    public abstract virtual void SetDisplayName(string name);
    public abstract virtual void SetDisplayName(Func`2<ValidationContext`1<T>, string> factory);
    public abstract virtual void AddValidator(IPropertyValidator`2<T, TProperty> validator);
    public abstract virtual void AddAsyncValidator(IAsyncPropertyValidator`2<T, TProperty> asyncValidator, IPropertyValidator`2<T, TProperty> fallback);
    public abstract virtual IRuleComponent`2<T, TProperty> get_Current();
    public abstract virtual void set_MessageBuilder(Func`2<IMessageBuilderContext`2<T, TProperty>, string> value);
}
internal interface FluentValidation.IValidationRuleInternal`1 {
    public abstract virtual ValueTask ValidateAsync(ValidationContext`1<T> context, bool useAsync, CancellationToken cancellation);
    public abstract virtual void AddDependentRules(IEnumerable`1<IValidationRuleInternal`1<T>> rules);
}
internal interface FluentValidation.IValidationRuleInternal`2 {
    public List`1<RuleComponent`2<T, TProperty>> Components { get; }
    public abstract virtual List`1<RuleComponent`2<T, TProperty>> get_Components();
}
public interface FluentValidation.IValidator {
    public abstract virtual ValidationResult Validate(IValidationContext context);
    public abstract virtual Task`1<ValidationResult> ValidateAsync(IValidationContext context, CancellationToken cancellation);
    public abstract virtual IValidatorDescriptor CreateDescriptor();
    public abstract virtual bool CanValidateInstancesOfType(Type type);
}
public interface FluentValidation.IValidator`1 {
    public abstract virtual ValidationResult Validate(T instance);
    public abstract virtual Task`1<ValidationResult> ValidateAsync(T instance, CancellationToken cancellation);
}
public interface FluentValidation.IValidatorDescriptor {
    public IEnumerable`1<IValidationRule> Rules { get; }
    public abstract virtual IEnumerable`1<IValidationRule> get_Rules();
    public abstract virtual string GetName(string property);
    public abstract virtual ILookup`2<string, ValueTuple`2<IPropertyValidator, IRuleComponent>> GetMembersWithValidators();
    public abstract virtual IEnumerable`1<ValueTuple`2<IPropertyValidator, IRuleComponent>> GetValidatorsForMember(string name);
    public abstract virtual IEnumerable`1<IValidationRule> GetRulesForMember(string name);
}
[ObsoleteAttribute("IValidatorFactory and its implementors are deprecated and will be removed in a future release. Please use the Service Provider directly (or a DI container). For details see https://github.com/FluentValidation/FluentValidation/issues/1961")]
public interface FluentValidation.IValidatorFactory {
    public abstract virtual IValidator`1<T> GetValidator();
    public abstract virtual IValidator GetValidator(Type type);
}
internal class FluentValidation.Resources.AlbanianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.ArabicLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.AzerbaijaneseLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.BengaliLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.BosnianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.BulgarianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.CatalanLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.ChineseSimplifiedLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.ChineseTraditionalLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.CroatianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.CzechLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.DanishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.DutchLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.EnglishLanguage : object {
    public static string Culture;
    public static string AmericanCulture;
    public static string BritishCulture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.EstonianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.FinnishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.FrenchLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.GeorgianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.GermanLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.GreekLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.HebrewLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.HindiLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.HungarianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.IcelandicLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
public interface FluentValidation.Resources.ILanguageManager {
    public bool Enabled { get; public set; }
    public CultureInfo Culture { get; public set; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual void set_Culture(CultureInfo value);
    public abstract virtual string GetString(string key, CultureInfo culture);
}
internal class FluentValidation.Resources.IndonesianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.ItalianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.JapaneseLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.KazakhLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.KhmerLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.KoreanLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
public class FluentValidation.Resources.LanguageManager : object {
    private ConcurrentDictionary`2<string, string> _languages;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public bool Enabled { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static string GetTranslation(string culture, string key);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Enabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Culture(CultureInfo value);
    public void Clear();
    public virtual string GetString(string key, CultureInfo culture);
    public void AddTranslation(string language, string key, string message);
}
internal class FluentValidation.Resources.LatvianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.MacedonianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.NorwegianBokmalLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.NorwegianNynorskLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.PersianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.PolishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.PortugueseBrazilLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.PortugueseLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.RomanianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.RomanshLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.RussianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.SerbianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.SlovakLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.SlovenianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.SpanishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.SwedishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.TajikLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.ThaiLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.TurkishLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.UkrainianLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.UzbekCyrillicLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.UzbekLatinLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.VietnameseLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
internal class FluentValidation.Resources.WelshLanguage : object {
    public static string Culture;
    public static string GetTranslation(string key);
}
public class FluentValidation.Results.ValidationFailure : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AttemptedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CustomState>k__BackingField;
    [CompilerGeneratedAttribute]
private Severity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <FormattedMessagePlaceholderValues>k__BackingField;
    public string PropertyName { get; public set; }
    public string ErrorMessage { get; public set; }
    public object AttemptedValue { get; public set; }
    public object CustomState { get; public set; }
    public Severity Severity { get; public set; }
    public string ErrorCode { get; public set; }
    public Dictionary`2<string, object> FormattedMessagePlaceholderValues { get; public set; }
    public ValidationFailure(string propertyName, string errorMessage);
    public ValidationFailure(string propertyName, string errorMessage, object attemptedValue);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public object get_AttemptedValue();
    [CompilerGeneratedAttribute]
public void set_AttemptedValue(object value);
    [CompilerGeneratedAttribute]
public object get_CustomState();
    [CompilerGeneratedAttribute]
public void set_CustomState(object value);
    [CompilerGeneratedAttribute]
public Severity get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(Severity value);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_FormattedMessagePlaceholderValues();
    [CompilerGeneratedAttribute]
public void set_FormattedMessagePlaceholderValues(Dictionary`2<string, object> value);
    public virtual string ToString();
}
public class FluentValidation.Results.ValidationResult : object {
    private List`1<ValidationFailure> _errors;
    [CompilerGeneratedAttribute]
private String[] <RuleSetsExecuted>k__BackingField;
    public bool IsValid { get; }
    public List`1<ValidationFailure> Errors { get; public set; }
    public String[] RuleSetsExecuted { get; public set; }
    public ValidationResult(IEnumerable`1<ValidationFailure> failures);
    public ValidationResult(IEnumerable`1<ValidationResult> otherResults);
    internal ValidationResult(List`1<ValidationFailure> errors);
    public virtual bool get_IsValid();
    public List`1<ValidationFailure> get_Errors();
    public void set_Errors(List`1<ValidationFailure> value);
    [CompilerGeneratedAttribute]
public String[] get_RuleSetsExecuted();
    [CompilerGeneratedAttribute]
public void set_RuleSetsExecuted(String[] value);
    public virtual string ToString();
    public string ToString(string separator);
    public IDictionary`2<string, String[]> ToDictionary();
}
public enum FluentValidation.Severity : Enum {
    public int value__;
    public static Severity Error;
    public static Severity Warning;
    public static Severity Info;
}
public interface FluentValidation.TestHelper.ITestValidationContinuation {
    public IEnumerable`1<ValidationFailure> UnmatchedFailures { get; }
    public abstract virtual IEnumerable`1<ValidationFailure> get_UnmatchedFailures();
}
public interface FluentValidation.TestHelper.ITestValidationWith {
}
internal class FluentValidation.TestHelper.TestValidationContinuation : object {
    private IEnumerable`1<ValidationFailure> _allFailures;
    private List`1<Func`2<ValidationFailure, bool>> _predicates;
    [CompilerGeneratedAttribute]
private ITestValidationContinuation <Parent>k__BackingField;
    public ITestValidationContinuation Parent { get; }
    public IEnumerable`1<ValidationFailure> MatchedFailures { get; }
    public IEnumerable`1<ValidationFailure> UnmatchedFailures { get; }
    public TestValidationContinuation(IEnumerable`1<ValidationFailure> failures, ITestValidationContinuation parent);
    [CompilerGeneratedAttribute]
public ITestValidationContinuation get_Parent();
    public void ApplyPredicate(Func`2<ValidationFailure, bool> failurePredicate);
    public sealed virtual IEnumerator`1<ValidationFailure> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<ValidationFailure> get_MatchedFailures();
    [IteratorStateMachineAttribute("FluentValidation.TestHelper.TestValidationContinuation/<get_UnmatchedFailures>d__12")]
public sealed virtual IEnumerable`1<ValidationFailure> get_UnmatchedFailures();
}
public class FluentValidation.TestHelper.TestValidationResult`1 : ValidationResult {
    public TestValidationResult`1(ValidationResult validationResult);
    public ITestValidationWith ShouldHaveValidationErrorFor(Expression`1<Func`2<T, TProperty>> memberAccessor);
    public void ShouldNotHaveValidationErrorFor(Expression`1<Func`2<T, TProperty>> memberAccessor);
    public ITestValidationWith ShouldHaveValidationErrorFor(string propertyName);
    public void ShouldNotHaveValidationErrorFor(string propertyName);
    internal ITestValidationWith ShouldHaveValidationError(string propertyName, bool shouldNormalizePropertyName);
    internal void ShouldNotHaveValidationError(string propertyName, bool shouldNormalizePropertyName);
    private static string NormalizePropertyName(string propertyName);
}
public class FluentValidation.TestHelper.ValidationTestException : Exception {
    [CompilerGeneratedAttribute]
private List`1<ValidationFailure> <Errors>k__BackingField;
    public List`1<ValidationFailure> Errors { get; }
    public ValidationTestException(string message);
    public ValidationTestException(string message, List`1<ValidationFailure> errors);
    [CompilerGeneratedAttribute]
public List`1<ValidationFailure> get_Errors();
}
[ExtensionAttribute]
public static class FluentValidation.TestHelper.ValidationTestExtension : object {
    internal static string MatchAnyFailure;
    [ExtensionAttribute]
public static void ShouldHaveChildValidator(IValidator`1<T> validator, Expression`1<Func`2<T, TProperty>> expression, Type childValidatorType);
    private static IEnumerable`1<IPropertyValidator> GetDependentRules(string expressionMemberName, Expression`1<Func`2<T, TProperty>> expression, IValidatorDescriptor descriptor);
    private static IPropertyValidator[] GetModelLevelValidators(IValidatorDescriptor descriptor);
    [ExtensionAttribute]
public static TestValidationResult`1<T> TestValidate(IValidator`1<T> validator, T objectToTest, Action`1<ValidationStrategy`1<T>> options);
    [ExtensionAttribute]
public static TestValidationResult`1<T> TestValidate(IValidator`1<T> validator, ValidationContext`1<T> context);
    [ExtensionAttribute]
public static Task`1<TestValidationResult`1<T>> TestValidateAsync(IValidator`1<T> validator, T objectToTest, Action`1<ValidationStrategy`1<T>> options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("FluentValidation.TestHelper.ValidationTestExtension/<TestValidateAsync>d__7`1")]
[ExtensionAttribute]
public static Task`1<TestValidationResult`1<T>> TestValidateAsync(IValidator`1<T> validator, ValidationContext`1<T> context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITestValidationContinuation ShouldHaveAnyValidationError(TestValidationResult`1<T> testValidationResult);
    [ExtensionAttribute]
public static void ShouldNotHaveAnyValidationErrors(TestValidationResult`1<T> testValidationResult);
    private static string BuildErrorMessage(ValidationFailure failure, string exceptionMessage, string defaultMessage);
    [ExtensionAttribute]
public static ITestValidationWith When(ITestValidationContinuation failures, Func`2<ValidationFailure, bool> failurePredicate, string exceptionMessage);
    [ExtensionAttribute]
public static ITestValidationContinuation WhenAll(ITestValidationContinuation failures, Func`2<ValidationFailure, bool> failurePredicate, string exceptionMessage);
    [ExtensionAttribute]
public static ITestValidationWith WithSeverity(ITestValidationContinuation failures, Severity expectedSeverity);
    [ExtensionAttribute]
public static ITestValidationWith WithCustomState(ITestValidationContinuation failures, object expectedCustomState, IEqualityComparer comparer);
    [ExtensionAttribute]
public static ITestValidationWith WithMessageArgument(ITestValidationContinuation failures, string argumentKey, T argumentValue);
    [ExtensionAttribute]
public static ITestValidationWith WithErrorMessage(ITestValidationContinuation failures, string expectedErrorMessage);
    [ExtensionAttribute]
public static ITestValidationWith WithErrorCode(ITestValidationContinuation failures, string expectedErrorCode);
    [ExtensionAttribute]
public static ITestValidationContinuation WithoutSeverity(ITestValidationContinuation failures, Severity unexpectedSeverity);
    [ExtensionAttribute]
public static ITestValidationContinuation WithoutCustomState(ITestValidationContinuation failures, object unexpectedCustomState);
    [ExtensionAttribute]
public static ITestValidationContinuation WithoutErrorMessage(ITestValidationContinuation failures, string unexpectedErrorMessage);
    [ExtensionAttribute]
public static ITestValidationContinuation WithoutErrorCode(ITestValidationContinuation failures, string unexpectedErrorCode);
    [ExtensionAttribute]
public static ITestValidationWith Only(ITestValidationWith failures);
}
public class FluentValidation.ValidationContext`1 : object {
    private IValidationContext _parentContext;
    [CompilerGeneratedAttribute]
private List`1<ValidationFailure> <Failures>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageFormatter <MessageFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private T <InstanceToValidate>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <RootContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChain <PropertyChain>k__BackingField;
    [CompilerGeneratedAttribute]
private IValidatorSelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChildContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChildCollectionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnFailures>k__BackingField;
    private Dictionary`2<string, Dictionary`2<T, bool>> _sharedConditionCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<ValueTuple`5<bool, bool, IValidationContext, PropertyChain, Dictionary`2<string, Dictionary`2<T, bool>>>> _state;
    private Func`2<ValidationContext`1<T>, string> _displayNameFunc;
    [CompilerGeneratedAttribute]
private string <PropertyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawPropertyName>k__BackingField;
    private List`1<ValidationFailure> FluentValidation.IHasFailures.Failures { get; }
    internal List`1<ValidationFailure> Failures { get; }
    public MessageFormatter MessageFormatter { get; }
    public T InstanceToValidate { get; private set; }
    public IDictionary`2<string, object> RootContextData { get; private protected set; }
    public PropertyChain PropertyChain { get; private set; }
    private object FluentValidation.IValidationContext.InstanceToValidate { get; }
    public IValidatorSelector Selector { get; private set; }
    public bool IsChildContext { get; internal set; }
    public bool IsChildCollectionContext { get; internal set; }
    private IValidationContext FluentValidation.IValidationContext.ParentContext { get; }
    public bool IsAsync { get; internal set; }
    public bool ThrowOnFailures { get; internal set; }
    internal Dictionary`2<string, Dictionary`2<T, bool>> SharedConditionCache { get; }
    public string DisplayName { get; }
    public string PropertyPath { get; private set; }
    [ObsoleteAttribute("This property has been deprecated due to its misleading name. Use the PropertyPath property instead, which returns the same value.")]
public string PropertyName { get; }
    internal string RawPropertyName { get; private set; }
    public ValidationContext`1(T instanceToValidate);
    public ValidationContext`1(T instanceToValidate, PropertyChain propertyChain, IValidatorSelector validatorSelector);
    internal ValidationContext`1(T instanceToValidate, PropertyChain propertyChain, IValidatorSelector validatorSelector, List`1<ValidationFailure> failures, MessageFormatter messageFormatter);
    private sealed virtual override List`1<ValidationFailure> FluentValidation.IHasFailures.get_Failures();
    [CompilerGeneratedAttribute]
internal List`1<ValidationFailure> get_Failures();
    [CompilerGeneratedAttribute]
public MessageFormatter get_MessageFormatter();
    public static ValidationContext`1<T> CreateWithOptions(T instanceToValidate, Action`1<ValidationStrategy`1<T>> options);
    [CompilerGeneratedAttribute]
public T get_InstanceToValidate();
    [CompilerGeneratedAttribute]
private void set_InstanceToValidate(T value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_RootContextData();
    [CompilerGeneratedAttribute]
private protected void set_RootContextData(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual PropertyChain get_PropertyChain();
    [CompilerGeneratedAttribute]
private void set_PropertyChain(PropertyChain value);
    private sealed virtual override object FluentValidation.IValidationContext.get_InstanceToValidate();
    [CompilerGeneratedAttribute]
public sealed virtual IValidatorSelector get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(IValidatorSelector value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsChildContext();
    [CompilerGeneratedAttribute]
internal virtual void set_IsChildContext(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsChildCollectionContext();
    [CompilerGeneratedAttribute]
internal virtual void set_IsChildCollectionContext(bool value);
    private sealed virtual override IValidationContext FluentValidation.IValidationContext.get_ParentContext();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
internal void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ThrowOnFailures();
    [CompilerGeneratedAttribute]
internal void set_ThrowOnFailures(bool value);
    internal Dictionary`2<string, Dictionary`2<T, bool>> get_SharedConditionCache();
    public static ValidationContext`1<T> GetFromNonGenericContext(IValidationContext context);
    public ValidationContext`1<TChild> CloneForChildValidator(TChild instanceToValidate, bool preserveParentContext, IValidatorSelector selector);
    internal void PrepareForChildCollectionValidator();
    internal void RestoreState();
    public void AddFailure(ValidationFailure failure);
    public void AddFailure(string propertyName, string errorMessage);
    public void AddFailure(string errorMessage);
    public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_PropertyPath();
    [CompilerGeneratedAttribute]
private void set_PropertyPath(string value);
    public string get_PropertyName();
    [CompilerGeneratedAttribute]
internal string get_RawPropertyName();
    [CompilerGeneratedAttribute]
private void set_RawPropertyName(string value);
    internal void InitializeForPropertyValidator(string propertyPath, Func`2<ValidationContext`1<T>, string> displayNameFunc, string rawPropertyName);
}
public class FluentValidation.ValidationException : Exception {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ValidationFailure> <Errors>k__BackingField;
    public IEnumerable`1<ValidationFailure> Errors { get; private set; }
    public ValidationException(string message);
    public ValidationException(string message, IEnumerable`1<ValidationFailure> errors);
    public ValidationException(string message, IEnumerable`1<ValidationFailure> errors, bool appendDefaultMessage);
    public ValidationException(IEnumerable`1<ValidationFailure> errors);
    public ValidationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ValidationFailure> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IEnumerable`1<ValidationFailure> value);
    private static string BuildErrorMessage(IEnumerable`1<ValidationFailure> errors);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class FluentValidation.ValidatorConfiguration : object {
    private Func`4<Type, MemberInfo, LambdaExpression, string> _propertyNameResolver;
    private Func`4<Type, MemberInfo, LambdaExpression, string> _displayNameResolver;
    private Func`1<MessageFormatter> _messageFormatterFactory;
    private Func`2<IPropertyValidator, string> _errorCodeResolver;
    private ILanguageManager _languageManager;
    private CascadeMode _defaultClassLevelCascadeMode;
    private CascadeMode _defaultRuleLevelCascadeMode;
    [CompilerGeneratedAttribute]
private Severity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyChainSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidatorSelectorOptions <ValidatorSelectors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAccessorCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`6<ValidationFailure, IValidationContext, object, IValidationRule, IRuleComponent, ValidationFailure> <OnFailureCreated>k__BackingField;
    [ObsoleteAttribute("Use DefaultClassLevelCascadeMode and/or DefaultRuleLevelCascadeMode instead. CascadeMode will be removed in a future release. For more details, see https://docs.fluentvalidation.net/en/latest/cascade.html")]
public CascadeMode CascadeMode { get; public set; }
    public CascadeMode DefaultClassLevelCascadeMode { get; public set; }
    public CascadeMode DefaultRuleLevelCascadeMode { get; public set; }
    public Severity Severity { get; public set; }
    public string PropertyChainSeparator { get; public set; }
    public ILanguageManager LanguageManager { get; public set; }
    public ValidatorSelectorOptions ValidatorSelectors { get; }
    public Func`1<MessageFormatter> MessageFormatterFactory { get; public set; }
    public Func`4<Type, MemberInfo, LambdaExpression, string> PropertyNameResolver { get; public set; }
    public Func`4<Type, MemberInfo, LambdaExpression, string> DisplayNameResolver { get; public set; }
    public bool DisableAccessorCache { get; public set; }
    public Func`2<IPropertyValidator, string> ErrorCodeResolver { get; public set; }
    public Func`6<ValidationFailure, IValidationContext, object, IValidationRule, IRuleComponent, ValidationFailure> OnFailureCreated { get; public set; }
    public CascadeMode get_CascadeMode();
    public void set_CascadeMode(CascadeMode value);
    public CascadeMode get_DefaultClassLevelCascadeMode();
    public void set_DefaultClassLevelCascadeMode(CascadeMode value);
    public CascadeMode get_DefaultRuleLevelCascadeMode();
    public void set_DefaultRuleLevelCascadeMode(CascadeMode value);
    [CompilerGeneratedAttribute]
public Severity get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(Severity value);
    [CompilerGeneratedAttribute]
public string get_PropertyChainSeparator();
    [CompilerGeneratedAttribute]
public void set_PropertyChainSeparator(string value);
    public ILanguageManager get_LanguageManager();
    public void set_LanguageManager(ILanguageManager value);
    [CompilerGeneratedAttribute]
public ValidatorSelectorOptions get_ValidatorSelectors();
    public Func`1<MessageFormatter> get_MessageFormatterFactory();
    public void set_MessageFormatterFactory(Func`1<MessageFormatter> value);
    public Func`4<Type, MemberInfo, LambdaExpression, string> get_PropertyNameResolver();
    public void set_PropertyNameResolver(Func`4<Type, MemberInfo, LambdaExpression, string> value);
    public Func`4<Type, MemberInfo, LambdaExpression, string> get_DisplayNameResolver();
    public void set_DisplayNameResolver(Func`4<Type, MemberInfo, LambdaExpression, string> value);
    [CompilerGeneratedAttribute]
public bool get_DisableAccessorCache();
    [CompilerGeneratedAttribute]
public void set_DisableAccessorCache(bool value);
    public Func`2<IPropertyValidator, string> get_ErrorCodeResolver();
    public void set_ErrorCodeResolver(Func`2<IPropertyValidator, string> value);
    [CompilerGeneratedAttribute]
public Func`6<ValidationFailure, IValidationContext, object, IValidationRule, IRuleComponent, ValidationFailure> get_OnFailureCreated();
    [CompilerGeneratedAttribute]
public void set_OnFailureCreated(Func`6<ValidationFailure, IValidationContext, object, IValidationRule, IRuleComponent, ValidationFailure> value);
    private static string DefaultPropertyNameResolver(Type type, MemberInfo memberInfo, LambdaExpression expression);
    private static string DefaultDisplayNameResolver(Type type, MemberInfo memberInfo, LambdaExpression expression);
    private static string DefaultErrorCodeResolver(IPropertyValidator validator);
}
public class FluentValidation.ValidatorDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IValidationRule> <Rules>k__BackingField;
    public IEnumerable`1<IValidationRule> Rules { get; }
    public ValidatorDescriptor`1(IEnumerable`1<IValidationRule> rules);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IValidationRule> get_Rules();
    public virtual string GetName(string property);
    public virtual ILookup`2<string, ValueTuple`2<IPropertyValidator, IRuleComponent>> GetMembersWithValidators();
    public sealed virtual IEnumerable`1<ValueTuple`2<IPropertyValidator, IRuleComponent>> GetValidatorsForMember(string name);
    public sealed virtual IEnumerable`1<IValidationRule> GetRulesForMember(string name);
    public virtual string GetName(Expression`1<Func`2<T, object>> propertyExpression);
    public IEnumerable`1<RulesetMetadata<T>> GetRulesByRuleset();
}
[ObsoleteAttribute("IValidatorFactory and its implementors are deprecated and will be removed in a future release. Please use the Service Provider directly (or a DI container). For details see https://github.com/FluentValidation/FluentValidation/issues/1961")]
public abstract class FluentValidation.ValidatorFactoryBase : object {
    public sealed virtual IValidator`1<T> GetValidator();
    public sealed virtual IValidator GetValidator(Type type);
    public abstract virtual IValidator CreateInstance(Type validatorType);
}
public static class FluentValidation.ValidatorOptions : object {
    [CompilerGeneratedAttribute]
private static ValidatorConfiguration <Global>k__BackingField;
    public static ValidatorConfiguration Global { get; }
    private static ValidatorOptions();
    [CompilerGeneratedAttribute]
public static ValidatorConfiguration get_Global();
}
public abstract class FluentValidation.Validators.AbstractComparisonValidator`2 : PropertyValidator`2<T, TProperty> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, ValueTuple`2<bool, TProperty>> _valueToCompareFuncForNullables;
    private Func`2<T, TProperty> _valueToCompareFunc;
    private string _comparisonMemberDisplayName;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <ValueToCompare>k__BackingField;
    public Comparison Comparison { get; }
    public MemberInfo MemberToCompare { get; private set; }
    public TProperty ValueToCompare { get; }
    private object FluentValidation.Validators.IComparisonValidator.ValueToCompare { get; }
    protected AbstractComparisonValidator`2(TProperty value);
    protected AbstractComparisonValidator`2(Func`2<T, ValueTuple`2<bool, TProperty>> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    protected AbstractComparisonValidator`2(Func`2<T, TProperty> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public sealed virtual bool IsValid(ValidationContext`1<T> context, TProperty propertyValue);
    public ValueTuple`2<bool, TProperty> GetComparisonValue(ValidationContext`1<T> context);
    public abstract virtual bool IsValid(TProperty value, TProperty valueToCompare);
    public abstract virtual Comparison get_Comparison();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_MemberToCompare();
    [CompilerGeneratedAttribute]
private void set_MemberToCompare(MemberInfo value);
    [CompilerGeneratedAttribute]
public TProperty get_ValueToCompare();
    private sealed virtual override object FluentValidation.Validators.IComparisonValidator.get_ValueToCompare();
}
public class FluentValidation.Validators.AspNetCoreCompatibleEmailValidator`1 : PropertyValidator`2<T, string> {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.AsyncPredicateValidator`2 : AsyncPropertyValidator`2<T, TProperty> {
    private Func`5<T, TProperty, ValidationContext`1<T>, CancellationToken, Task`1<bool>> _predicate;
    public string Name { get; }
    public AsyncPredicateValidator`2(Func`5<T, TProperty, ValidationContext`1<T>, CancellationToken, Task`1<bool>> predicate);
    public virtual string get_Name();
    public virtual Task`1<bool> IsValidAsync(ValidationContext`1<T> context, TProperty value, CancellationToken cancellation);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public abstract class FluentValidation.Validators.AsyncPropertyValidator`2 : object {
    public string Name { get; }
    private sealed virtual override string FluentValidation.Validators.IPropertyValidator.GetDefaultMessageTemplate(string errorCode);
    public abstract virtual string get_Name();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    public abstract virtual Task`1<bool> IsValidAsync(ValidationContext`1<T> context, TProperty value, CancellationToken cancellation);
    protected string Localized(string errorCode, string fallbackKey);
}
public class FluentValidation.Validators.ChildValidatorAdaptor`2 : NoopPropertyValidator`2<T, TProperty> {
    private Func`3<ValidationContext`1<T>, TProperty, IValidator`1<TProperty>> _validatorProvider;
    private IValidator`1<TProperty> _validator;
    [CompilerGeneratedAttribute]
private Type <ValidatorType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RuleSets>k__BackingField;
    public string Name { get; }
    public Type ValidatorType { get; }
    public String[] RuleSets { get; public set; }
    public ChildValidatorAdaptor`2(IValidator`1<TProperty> validator, Type validatorType);
    public ChildValidatorAdaptor`2(Func`3<ValidationContext`1<T>, TProperty, IValidator`1<TProperty>> validatorProvider, Type validatorType);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ValidatorType();
    [CompilerGeneratedAttribute]
public String[] get_RuleSets();
    [CompilerGeneratedAttribute]
public void set_RuleSets(String[] value);
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    [AsyncStateMachineAttribute("FluentValidation.Validators.ChildValidatorAdaptor`2/<IsValidAsync>d__14")]
public virtual Task`1<bool> IsValidAsync(ValidationContext`1<T> context, TProperty value, CancellationToken cancellation);
    public virtual IValidator GetValidator(ValidationContext`1<T> context, TProperty value);
    protected virtual IValidationContext CreateNewValidationContextForChildValidator(ValidationContext`1<T> context, TProperty value);
    private protected virtual IValidatorSelector GetSelector(ValidationContext`1<T> context, TProperty value);
    private void HandleCollectionIndex(ValidationContext`1<T> context, Object& originalIndex, Object& index);
    private void ResetCollectionIndex(ValidationContext`1<T> context, object originalIndex, object index);
}
internal class FluentValidation.Validators.ComparableComparer`1 : object {
    [CompilerGeneratedAttribute]
private static ComparableComparer`1<T> <Instance>k__BackingField;
    internal static ComparableComparer`1<T> Instance { get; }
    private static ComparableComparer`1();
    [CompilerGeneratedAttribute]
internal static ComparableComparer`1<T> get_Instance();
    public sealed virtual int Compare(T x, T y);
}
public enum FluentValidation.Validators.Comparison : Enum {
    public int value__;
    public static Comparison Equal;
    public static Comparison NotEqual;
    public static Comparison LessThan;
    public static Comparison GreaterThan;
    public static Comparison GreaterThanOrEqual;
    public static Comparison LessThanOrEqual;
}
public class FluentValidation.Validators.CreditCardValidator`1 : PropertyValidator`2<T, string> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
}
public enum FluentValidation.Validators.EmailValidationMode : Enum {
    public int value__;
    [ObsoleteAttribute("Regex-based email validation is not recommended and is no longer supported.")]
public static EmailValidationMode Net4xRegex;
    public static EmailValidationMode AspNetCoreCompatible;
}
[ObsoleteAttribute("Regex-based email validation is not recommended and is no longer supported.")]
public class FluentValidation.Validators.EmailValidator`1 : PropertyValidator`2<T, string> {
    private static Regex _regex;
    private static string _expression;
    public string Name { get; }
    public string Expression { get; }
    private static EmailValidator`1();
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
    public sealed virtual string get_Expression();
    private static Regex CreateRegEx();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.EmptyValidator`2 : PropertyValidator`2<T, TProperty> {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    private static bool IsEmpty(IEnumerable enumerable);
}
public class FluentValidation.Validators.EnumValidator`2 : PropertyValidator`2<T, TProperty> {
    private Type _enumType;
    public Type EnumType { get; }
    public string Name { get; }
    public sealed virtual Type get_EnumType();
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    private static bool IsFlagsEnumDefined(Type enumType, object value);
    private static bool EvaluateFlagEnumValues(long value, Type enumType);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.EqualValidator`2 : PropertyValidator`2<T, TProperty> {
    private Func`2<T, TProperty> _func;
    private string _memberDisplayName;
    private IEqualityComparer`1<TProperty> _comparer;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <ValueToCompare>k__BackingField;
    public string Name { get; }
    public Comparison Comparison { get; }
    public MemberInfo MemberToCompare { get; private set; }
    public TProperty ValueToCompare { get; private set; }
    private object FluentValidation.Validators.IComparisonValidator.ValueToCompare { get; }
    public EqualValidator`2(TProperty valueToCompare, IEqualityComparer`1<TProperty> comparer);
    public EqualValidator`2(Func`2<T, TProperty> comparisonProperty, MemberInfo member, string memberDisplayName, IEqualityComparer`1<TProperty> comparer);
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    private TProperty GetComparisonValue(ValidationContext`1<T> context);
    public sealed virtual Comparison get_Comparison();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_MemberToCompare();
    [CompilerGeneratedAttribute]
private void set_MemberToCompare(MemberInfo value);
    [CompilerGeneratedAttribute]
public TProperty get_ValueToCompare();
    [CompilerGeneratedAttribute]
private void set_ValueToCompare(TProperty value);
    private sealed virtual override object FluentValidation.Validators.IComparisonValidator.get_ValueToCompare();
    protected bool Compare(TProperty comparisonValue, TProperty propertyValue);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.ExactLengthValidator`1 : LengthValidator`1<T> {
    public string Name { get; }
    public ExactLengthValidator`1(int length);
    public ExactLengthValidator`1(Func`2<T, int> length);
    public virtual string get_Name();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.ExclusiveBetweenValidator`2 : RangeValidator`2<T, TProperty> {
    public string Name { get; }
    public ExclusiveBetweenValidator`2(TProperty from, TProperty to, IComparer`1<TProperty> comparer);
    public virtual string get_Name();
    protected virtual bool HasError(TProperty value);
}
public class FluentValidation.Validators.GreaterThanOrEqualValidator`2 : AbstractComparisonValidator`2<T, TProperty> {
    public string Name { get; }
    public Comparison Comparison { get; }
    public GreaterThanOrEqualValidator`2(TProperty value);
    public GreaterThanOrEqualValidator`2(Func`2<T, TProperty> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public GreaterThanOrEqualValidator`2(Func`2<T, ValueTuple`2<bool, TProperty>> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public virtual string get_Name();
    public virtual bool IsValid(TProperty value, TProperty valueToCompare);
    public virtual Comparison get_Comparison();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.GreaterThanValidator`2 : AbstractComparisonValidator`2<T, TProperty> {
    public string Name { get; }
    public Comparison Comparison { get; }
    public GreaterThanValidator`2(TProperty value);
    public GreaterThanValidator`2(Func`2<T, TProperty> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public GreaterThanValidator`2(Func`2<T, ValueTuple`2<bool, TProperty>> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public virtual string get_Name();
    public virtual bool IsValid(TProperty value, TProperty valueToCompare);
    public virtual Comparison get_Comparison();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public interface FluentValidation.Validators.IAsyncPropertyValidator`2 {
    public abstract virtual Task`1<bool> IsValidAsync(ValidationContext`1<T> context, TProperty value, CancellationToken cancellation);
}
public interface FluentValidation.Validators.IBetweenValidator {
    public object From { get; }
    public object To { get; }
    public abstract virtual object get_From();
    public abstract virtual object get_To();
}
public interface FluentValidation.Validators.IChildValidatorAdaptor {
    public Type ValidatorType { get; }
    public abstract virtual Type get_ValidatorType();
}
public interface FluentValidation.Validators.IComparisonValidator {
    public Comparison Comparison { get; }
    public MemberInfo MemberToCompare { get; }
    public object ValueToCompare { get; }
    public abstract virtual Comparison get_Comparison();
    public abstract virtual MemberInfo get_MemberToCompare();
    public abstract virtual object get_ValueToCompare();
}
public interface FluentValidation.Validators.ICreditCardValidator {
}
public interface FluentValidation.Validators.IEmailValidator {
}
public interface FluentValidation.Validators.IEnumValidator {
    public Type EnumType { get; }
    public abstract virtual Type get_EnumType();
}
public interface FluentValidation.Validators.IEqualValidator {
}
public interface FluentValidation.Validators.IExactLengthValidator {
}
public interface FluentValidation.Validators.IGreaterThanOrEqualValidator {
}
public interface FluentValidation.Validators.IInclusiveBetweenValidator {
}
public interface FluentValidation.Validators.ILengthValidator {
    public int Min { get; }
    public int Max { get; }
    public abstract virtual int get_Min();
    public abstract virtual int get_Max();
}
public interface FluentValidation.Validators.ILessThanOrEqualValidator {
}
public interface FluentValidation.Validators.IMaximumLengthValidator {
}
public interface FluentValidation.Validators.IMinimumLengthValidator {
}
public class FluentValidation.Validators.InclusiveBetweenValidator`2 : RangeValidator`2<T, TProperty> {
    public string Name { get; }
    public InclusiveBetweenValidator`2(TProperty from, TProperty to, IComparer`1<TProperty> comparer);
    public virtual string get_Name();
    protected virtual bool HasError(TProperty value);
}
public interface FluentValidation.Validators.INotEmptyValidator {
}
public interface FluentValidation.Validators.INotNullValidator {
}
public interface FluentValidation.Validators.INullValidator {
}
public interface FluentValidation.Validators.IPredicateValidator {
}
public interface FluentValidation.Validators.IPropertyValidator {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual string GetDefaultMessageTemplate(string errorCode);
}
public interface FluentValidation.Validators.IPropertyValidator`2 {
    public abstract virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
}
public interface FluentValidation.Validators.IRegularExpressionValidator {
    public string Expression { get; }
    public abstract virtual string get_Expression();
}
public class FluentValidation.Validators.LengthValidator`1 : PropertyValidator`2<T, string> {
    [CompilerGeneratedAttribute]
private int <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, int> <MinFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<T, int> <MaxFunc>k__BackingField;
    public string Name { get; }
    public int Min { get; }
    public int Max { get; }
    public Func`2<T, int> MinFunc { get; public set; }
    public Func`2<T, int> MaxFunc { get; public set; }
    public LengthValidator`1(int min, int max);
    public LengthValidator`1(Func`2<T, int> min, Func`2<T, int> max);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Min();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Max();
    [CompilerGeneratedAttribute]
public Func`2<T, int> get_MinFunc();
    [CompilerGeneratedAttribute]
public void set_MinFunc(Func`2<T, int> value);
    [CompilerGeneratedAttribute]
public Func`2<T, int> get_MaxFunc();
    [CompilerGeneratedAttribute]
public void set_MaxFunc(Func`2<T, int> value);
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.LessThanOrEqualValidator`2 : AbstractComparisonValidator`2<T, TProperty> {
    public string Name { get; }
    public Comparison Comparison { get; }
    public LessThanOrEqualValidator`2(TProperty value);
    public LessThanOrEqualValidator`2(Func`2<T, TProperty> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public LessThanOrEqualValidator`2(Func`2<T, ValueTuple`2<bool, TProperty>> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public virtual string get_Name();
    public virtual bool IsValid(TProperty value, TProperty valueToCompare);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    public virtual Comparison get_Comparison();
}
public class FluentValidation.Validators.LessThanValidator`2 : AbstractComparisonValidator`2<T, TProperty> {
    public string Name { get; }
    public Comparison Comparison { get; }
    public LessThanValidator`2(TProperty value);
    public LessThanValidator`2(Func`2<T, TProperty> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public LessThanValidator`2(Func`2<T, ValueTuple`2<bool, TProperty>> valueToCompareFunc, MemberInfo member, string memberDisplayName);
    public virtual string get_Name();
    public virtual bool IsValid(TProperty value, TProperty valueToCompare);
    public virtual Comparison get_Comparison();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.MaximumLengthValidator`1 : LengthValidator`1<T> {
    public string Name { get; }
    public MaximumLengthValidator`1(int max);
    public MaximumLengthValidator`1(Func`2<T, int> max);
    public virtual string get_Name();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.MinimumLengthValidator`1 : LengthValidator`1<T> {
    public string Name { get; }
    public MinimumLengthValidator`1(int min);
    public MinimumLengthValidator`1(Func`2<T, int> min);
    public virtual string get_Name();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public abstract class FluentValidation.Validators.NoopPropertyValidator`2 : PropertyValidator`2<T, TProperty> {
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
}
public class FluentValidation.Validators.NotEmptyValidator`2 : PropertyValidator`2<T, TProperty> {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    private static bool IsEmpty(IEnumerable enumerable);
}
public class FluentValidation.Validators.NotEqualValidator`2 : PropertyValidator`2<T, TProperty> {
    private IEqualityComparer`1<TProperty> _comparer;
    private Func`2<T, TProperty> _func;
    private string _memberDisplayName;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <ValueToCompare>k__BackingField;
    public string Name { get; }
    public Comparison Comparison { get; }
    public MemberInfo MemberToCompare { get; private set; }
    public TProperty ValueToCompare { get; private set; }
    private object FluentValidation.Validators.IComparisonValidator.ValueToCompare { get; }
    public NotEqualValidator`2(Func`2<T, TProperty> func, MemberInfo memberToCompare, string memberDisplayName, IEqualityComparer`1<TProperty> equalityComparer);
    public NotEqualValidator`2(TProperty comparisonValue, IEqualityComparer`1<TProperty> equalityComparer);
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    private TProperty GetComparisonValue(ValidationContext`1<T> context);
    public sealed virtual Comparison get_Comparison();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_MemberToCompare();
    [CompilerGeneratedAttribute]
private void set_MemberToCompare(MemberInfo value);
    [CompilerGeneratedAttribute]
public TProperty get_ValueToCompare();
    [CompilerGeneratedAttribute]
private void set_ValueToCompare(TProperty value);
    private sealed virtual override object FluentValidation.Validators.IComparisonValidator.get_ValueToCompare();
    protected bool Compare(TProperty comparisonValue, TProperty propertyValue);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.NotNullValidator`2 : PropertyValidator`2<T, TProperty> {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.NullValidator`2 : PropertyValidator`2<T, TProperty> {
    public string Name { get; }
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.PolymorphicValidator`2 : ChildValidatorAdaptor`2<T, TProperty> {
    private Dictionary`2<Type, DerivedValidatorFactory<T, TProperty>> _derivedValidators;
    public PolymorphicValidator`2<T, TProperty> Add(IValidator`1<TDerived> derivedValidator, String[] ruleSets);
    public PolymorphicValidator`2<T, TProperty> Add(Func`2<T, IValidator`1<TDerived>> validatorFactory, String[] ruleSets);
    public PolymorphicValidator`2<T, TProperty> Add(Func`3<T, TDerived, IValidator`1<TDerived>> validatorFactory, String[] ruleSets);
    protected PolymorphicValidator`2<T, TProperty> Add(Type subclassType, IValidator validator, String[] ruleSets);
    public virtual IValidator GetValidator(ValidationContext`1<T> context, TProperty value);
    private protected virtual IValidatorSelector GetSelector(ValidationContext`1<T> context, TProperty value);
}
public class FluentValidation.Validators.PredicateValidator`2 : PropertyValidator`2<T, TProperty> {
    private Predicate<T, TProperty> _predicate;
    public string Name { get; }
    public PredicateValidator`2(Predicate<T, TProperty> predicate);
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public abstract class FluentValidation.Validators.PropertyValidator`2 : object {
    public string Name { get; }
    private sealed virtual override string FluentValidation.Validators.IPropertyValidator.GetDefaultMessageTemplate(string errorCode);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
    public abstract virtual string get_Name();
    protected string Localized(string errorCode, string fallbackKey);
    public abstract virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
}
public abstract class FluentValidation.Validators.RangeValidator`2 : PropertyValidator`2<T, TProperty> {
    private IComparer`1<TProperty> _explicitComparer;
    [CompilerGeneratedAttribute]
private TProperty <From>k__BackingField;
    [CompilerGeneratedAttribute]
private TProperty <To>k__BackingField;
    public TProperty From { get; }
    public TProperty To { get; }
    private object FluentValidation.Validators.IBetweenValidator.From { get; }
    private object FluentValidation.Validators.IBetweenValidator.To { get; }
    public RangeValidator`2(TProperty from, TProperty to, IComparer`1<TProperty> comparer);
    [CompilerGeneratedAttribute]
public TProperty get_From();
    [CompilerGeneratedAttribute]
public TProperty get_To();
    private sealed virtual override object FluentValidation.Validators.IBetweenValidator.get_From();
    private sealed virtual override object FluentValidation.Validators.IBetweenValidator.get_To();
    protected abstract virtual bool HasError(TProperty value);
    public virtual bool IsValid(ValidationContext`1<T> context, TProperty value);
    protected int Compare(TProperty a, TProperty b);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public static class FluentValidation.Validators.RangeValidatorFactory : object {
    public static ExclusiveBetweenValidator`2<T, TProperty> CreateExclusiveBetween(TProperty from, TProperty to);
    public static InclusiveBetweenValidator`2<T, TProperty> CreateInclusiveBetween(TProperty from, TProperty to);
}
public class FluentValidation.Validators.RegularExpressionValidator`1 : PropertyValidator`2<T, string> {
    private Func`2<T, Regex> _regexFunc;
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    public string Name { get; }
    public string Expression { get; }
    public RegularExpressionValidator`1(string expression);
    public RegularExpressionValidator`1(Regex regex);
    public RegularExpressionValidator`1(string expression, RegexOptions options);
    public RegularExpressionValidator`1(Func`2<T, string> expressionFunc);
    public RegularExpressionValidator`1(Func`2<T, Regex> regexFunc);
    public RegularExpressionValidator`1(Func`2<T, string> expression, RegexOptions options);
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
    private static Regex CreateRegex(string expression, RegexOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Expression();
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.ScalePrecisionValidator`1 : PropertyValidator`2<T, decimal> {
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreTrailingZeros>k__BackingField;
    public string Name { get; }
    public int Scale { get; public set; }
    public int Precision { get; public set; }
    public bool IgnoreTrailingZeros { get; public set; }
    public ScalePrecisionValidator`1(int scale, int precision);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(int value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreTrailingZeros();
    [CompilerGeneratedAttribute]
public void set_IgnoreTrailingZeros(bool value);
    public virtual bool IsValid(ValidationContext`1<T> context, decimal decimalValue);
    private void Init(int scale, int precision);
    private static UInt32[] GetBits(decimal Decimal);
    private static decimal GetMantissa(decimal Decimal);
    private static UInt32 GetUnsignedScale(decimal Decimal);
    private int GetScale(decimal Decimal);
    private static UInt32 NumTrailingZeros(decimal Decimal);
    private int GetPrecision(decimal Decimal);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.Validators.StringEnumValidator`1 : PropertyValidator`2<T, string> {
    private bool _caseSensitive;
    private String[] _enumNames;
    public string Name { get; }
    public StringEnumValidator`1(Type enumType, bool caseSensitive);
    public virtual string get_Name();
    public virtual bool IsValid(ValidationContext`1<T> context, string value);
    private void CheckTypeIsEnum(Type enumType);
    protected virtual string GetDefaultMessageTemplate(string errorCode);
}
public class FluentValidation.ValidatorSelectorOptions : object {
    private static IValidatorSelector DefaultSelector;
    private Func`1<IValidatorSelector> _defaultValidatorSelector;
    private Func`2<IEnumerable`1<string>, IValidatorSelector> _memberNameValidatorSelector;
    private Func`2<IEnumerable`1<string>, IValidatorSelector> _rulesetValidatorSelector;
    private Func`2<IEnumerable`1<IValidatorSelector>, IValidatorSelector> _compositeValidatorSelectorFactory;
    public Func`1<IValidatorSelector> DefaultValidatorSelectorFactory { get; public set; }
    public Func`2<IEnumerable`1<string>, IValidatorSelector> MemberNameValidatorSelectorFactory { get; public set; }
    public Func`2<IEnumerable`1<string>, IValidatorSelector> RulesetValidatorSelectorFactory { get; public set; }
    public Func`2<IEnumerable`1<IValidatorSelector>, IValidatorSelector> CompositeValidatorSelectorFactory { get; public set; }
    private static ValidatorSelectorOptions();
    public Func`1<IValidatorSelector> get_DefaultValidatorSelectorFactory();
    public void set_DefaultValidatorSelectorFactory(Func`1<IValidatorSelector> value);
    public Func`2<IEnumerable`1<string>, IValidatorSelector> get_MemberNameValidatorSelectorFactory();
    public void set_MemberNameValidatorSelectorFactory(Func`2<IEnumerable`1<string>, IValidatorSelector> value);
    public Func`2<IEnumerable`1<string>, IValidatorSelector> get_RulesetValidatorSelectorFactory();
    public void set_RulesetValidatorSelectorFactory(Func`2<IEnumerable`1<string>, IValidatorSelector> value);
    public Func`2<IEnumerable`1<IValidatorSelector>, IValidatorSelector> get_CompositeValidatorSelectorFactory();
    public void set_CompositeValidatorSelectorFactory(Func`2<IEnumerable`1<IValidatorSelector>, IValidatorSelector> value);
}
