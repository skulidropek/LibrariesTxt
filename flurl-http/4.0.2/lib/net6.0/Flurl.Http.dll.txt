public class Flurl.Http.Configuration.DefaultFlurlClientFactory : object {
    public virtual HttpClient CreateHttpClient(HttpMessageHandler handler);
    public virtual HttpMessageHandler CreateInnerHandler();
}
public class Flurl.Http.Configuration.DefaultJsonSerializer : object {
    private JsonSerializerOptions _options;
    public DefaultJsonSerializer(JsonSerializerOptions options);
    public sealed virtual string Serialize(object obj);
    public sealed virtual T Deserialize(string s);
    public sealed virtual T Deserialize(Stream stream);
}
public class Flurl.Http.Configuration.DefaultUrlEncodedSerializer : object {
    public sealed virtual string Serialize(object obj);
    public sealed virtual T Deserialize(string s);
    public sealed virtual T Deserialize(Stream stream);
}
public class Flurl.Http.Configuration.FlurlClientBuilder : object {
    private IFlurlClientFactory _factory;
    private string _baseUrl;
    private List`1<Func`1<DelegatingHandler>> _addMiddleware;
    private List`1<Action`1<HttpClient>> _clientConfigs;
    private List`1<Action`1<HttpMessageHandler>> _handlerConfigs;
    [CompilerGeneratedAttribute]
private FlurlHttpSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> <EventHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueList`1<string> <Headers>k__BackingField;
    public FlurlHttpSettings Settings { get; }
    public IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> EventHandlers { get; }
    public INameValueList`1<string> Headers { get; }
    public FlurlClientBuilder(string baseUrl);
    [CompilerGeneratedAttribute]
public sealed virtual FlurlHttpSettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> get_EventHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual INameValueList`1<string> get_Headers();
    public sealed virtual IFlurlClientBuilder AddMiddleware(Func`1<DelegatingHandler> create);
    public sealed virtual IFlurlClientBuilder ConfigureHttpClient(Action`1<HttpClient> configure);
    public sealed virtual IFlurlClientBuilder ConfigureInnerHandler(Action`1<HttpClientHandler> configure);
    public sealed virtual IFlurlClientBuilder UseSocketsHttpHandler(Action`1<SocketsHttpHandler> configure);
    public sealed virtual IFlurlClient Build();
}
public class Flurl.Http.Configuration.FlurlClientCache : object {
    private ConcurrentDictionary`2<string, Lazy`1<IFlurlClient>> _clients;
    private List`1<Action`1<IFlurlClientBuilder>> _defaultConfigs;
    public sealed virtual IFlurlClientCache Add(string name, string baseUrl, Action`1<IFlurlClientBuilder> configure);
    public virtual IFlurlClient Get(string name);
    public sealed virtual IFlurlClient GetOrAdd(string name, string baseUrl, Action`1<IFlurlClientBuilder> configure);
    public sealed virtual IFlurlClientCache WithDefaults(Action`1<IFlurlClientBuilder> configure);
    public sealed virtual IFlurlClientCache Remove(string name);
    public sealed virtual IFlurlClientCache Clear();
    private IFlurlClientBuilder CreateBuilder(string baseUrl);
}
[ExtensionAttribute]
public static class Flurl.Http.Configuration.FlurlClientFactoryExtensions : object {
    [ExtensionAttribute]
public static HttpClient CreateHttpClient(IFlurlClientFactory fac);
}
public class Flurl.Http.Configuration.FlurlHttpSettings : object {
    private static FlurlHttpSettings Defaults;
    private IDictionary`2<string, object> _vals;
    [CompilerGeneratedAttribute]
private FlurlHttpSettings <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private RedirectSettings <Redirects>k__BackingField;
    internal FlurlHttpSettings Parent { get; internal set; }
    public Nullable`1<TimeSpan> Timeout { get; public set; }
    public string HttpVersion { get; public set; }
    public string AllowedHttpStatusRange { get; public set; }
    public ISerializer JsonSerializer { get; public set; }
    public ISerializer UrlEncodedSerializer { get; public set; }
    public RedirectSettings Redirects { get; }
    private static FlurlHttpSettings();
    [CompilerGeneratedAttribute]
internal FlurlHttpSettings get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(FlurlHttpSettings value);
    public Nullable`1<TimeSpan> get_Timeout();
    public void set_Timeout(Nullable`1<TimeSpan> value);
    public string get_HttpVersion();
    public void set_HttpVersion(string value);
    public string get_AllowedHttpStatusRange();
    public void set_AllowedHttpStatusRange(string value);
    public ISerializer get_JsonSerializer();
    public void set_JsonSerializer(ISerializer value);
    public ISerializer get_UrlEncodedSerializer();
    public void set_UrlEncodedSerializer(ISerializer value);
    [CompilerGeneratedAttribute]
public RedirectSettings get_Redirects();
    public void ResetDefaults();
    internal T Get(string propName);
    internal void Set(T value, string propName);
    [IteratorStateMachineAttribute("Flurl.Http.Configuration.FlurlHttpSettings/<<Get>g__prioritize|26_0>d`1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<FlurlHttpSettings> <Get>g__prioritize|26_0();
}
public interface Flurl.Http.Configuration.IFlurlClientBuilder {
    public abstract virtual IFlurlClientBuilder ConfigureHttpClient(Action`1<HttpClient> configure);
    public abstract virtual IFlurlClientBuilder ConfigureInnerHandler(Action`1<HttpClientHandler> configure);
    [UnsupportedOSPlatformAttribute("browser")]
public abstract virtual IFlurlClientBuilder UseSocketsHttpHandler(Action`1<SocketsHttpHandler> configure);
    public abstract virtual IFlurlClientBuilder AddMiddleware(Func`1<DelegatingHandler> create);
    public abstract virtual IFlurlClient Build();
}
public interface Flurl.Http.Configuration.IFlurlClientCache {
    public abstract virtual IFlurlClientCache Add(string name, string baseUrl, Action`1<IFlurlClientBuilder> configure);
    public abstract virtual IFlurlClient Get(string name);
    public abstract virtual IFlurlClient GetOrAdd(string name, string baseUrl, Action`1<IFlurlClientBuilder> configure);
    public abstract virtual IFlurlClientCache WithDefaults(Action`1<IFlurlClientBuilder> configure);
    public abstract virtual IFlurlClientCache Remove(string name);
    public abstract virtual IFlurlClientCache Clear();
}
public interface Flurl.Http.Configuration.IFlurlClientFactory {
    public abstract virtual HttpClient CreateHttpClient(HttpMessageHandler handler);
    public abstract virtual HttpMessageHandler CreateInnerHandler();
}
public interface Flurl.Http.Configuration.ISerializer {
    public abstract virtual string Serialize(object obj);
    public abstract virtual T Deserialize(string s);
    public abstract virtual T Deserialize(Stream stream);
}
public class Flurl.Http.Configuration.RedirectSettings : object {
    private FlurlHttpSettings _settings;
    public bool Enabled { get; public set; }
    public bool AllowSecureToInsecure { get; public set; }
    public bool ForwardHeaders { get; public set; }
    public bool ForwardAuthorizationHeader { get; public set; }
    public int MaxAutoRedirects { get; public set; }
    public RedirectSettings(FlurlHttpSettings settings);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public bool get_AllowSecureToInsecure();
    public void set_AllowSecureToInsecure(bool value);
    public bool get_ForwardHeaders();
    public void set_ForwardHeaders(bool value);
    public bool get_ForwardAuthorizationHeader();
    public void set_ForwardAuthorizationHeader(bool value);
    public int get_MaxAutoRedirects();
    public void set_MaxAutoRedirects(int value);
}
public class Flurl.Http.Configuration.SocketsHandlerFlurlClientFactory : DefaultFlurlClientFactory {
    public virtual HttpMessageHandler CreateInnerHandler();
}
public class Flurl.Http.Content.CapturedJsonContent : CapturedStringContent {
    public CapturedJsonContent(string json);
}
public class Flurl.Http.Content.CapturedMultipartContent : MultipartContent {
    private FlurlHttpSettings _settings;
    private List`1<HttpContent> _capturedParts;
    public IReadOnlyList`1<HttpContent> Parts { get; }
    public CapturedMultipartContent(FlurlHttpSettings settings);
    public CapturedMultipartContent(string subtype, FlurlHttpSettings settings);
    public CapturedMultipartContent(string subtype, string boundary, FlurlHttpSettings settings);
    public IReadOnlyList`1<HttpContent> get_Parts();
    public CapturedMultipartContent Add(string name, HttpContent content);
    public CapturedMultipartContent AddString(string name, string value, string contentType);
    public CapturedMultipartContent AddStringParts(object data, string contentType);
    public CapturedMultipartContent AddJson(string name, object data);
    public CapturedMultipartContent AddUrlEncoded(string name, object data);
    public CapturedMultipartContent AddFile(string name, Stream stream, string fileName, string contentType, int bufferSize);
    public CapturedMultipartContent AddFile(string name, string path, string contentType, int bufferSize, string fileName);
    private CapturedMultipartContent AddInternal(string name, HttpContent content, string fileName);
}
public class Flurl.Http.Content.CapturedStringContent : StringContent {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; }
    public CapturedStringContent(string content);
    public CapturedStringContent(string content, string contentType);
    [CompilerGeneratedAttribute]
public string get_Content();
}
public class Flurl.Http.Content.CapturedUrlEncodedContent : CapturedStringContent {
    public CapturedUrlEncodedContent(string data);
}
public class Flurl.Http.Content.FileContent : HttpContent {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    private int _bufferSize;
    public string Path { get; }
    public FileContent(string path, int bufferSize);
    [CompilerGeneratedAttribute]
public string get_Path();
    [AsyncStateMachineAttribute("Flurl.Http.Content.FileContent/<SerializeToStreamAsync>d__5")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
[ExtensionAttribute]
public static class Flurl.Http.CookieCutter : object {
    [IteratorStateMachineAttribute("Flurl.Http.CookieCutter/<ParseRequestHeader>d__0")]
public static IEnumerable`1<ValueTuple`2<string, string>> ParseRequestHeader(string headerValue);
    public static FlurlCookie ParseResponseHeader(string headerValue, string url, Nullable`1<DateTimeOffset> dateReceived);
    private static IEnumerable`1<ValueTuple`2<string, string>> GetPairs(string list);
    public static string BuildRequestHeader(IEnumerable`1<ValueTuple`2<string, string>> cookies);
    public static string BuildResponseHeader(FlurlCookie cookie);
    [ExtensionAttribute]
public static bool IsValid(FlurlCookie cookie, String& reason);
    [ExtensionAttribute]
public static bool IsExpired(FlurlCookie cookie, String& reason);
    [ExtensionAttribute]
public static bool ShouldSendTo(FlurlCookie cookie, Url requestUrl, String& reason);
    [ExtensionAttribute]
private static bool IsDomainMatch(FlurlCookie cookie, Url requestUrl, String& reason);
    [ExtensionAttribute]
private static bool IsPathMatch(FlurlCookie cookie, Url requestUrl, String& reason);
    [CompilerGeneratedAttribute]
internal static string <IsPathMatch>g__GetDefaultPath|9_0(<>c__DisplayClass9_0& );
}
[ExtensionAttribute]
public static class Flurl.Http.CookieExtensions : object {
    [ExtensionAttribute]
public static IFlurlRequest WithCookie(IFlurlRequest request, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(IFlurlRequest request, object values);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(IFlurlRequest request, CookieJar cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(IFlurlRequest request, CookieJar& cookieJar);
}
public class Flurl.Http.CookieJar : object {
    private ConcurrentDictionary`2<string, FlurlCookie> _dict;
    public int Count { get; }
    public CookieJar AddOrReplace(string name, object value, string originUrl, Nullable`1<DateTimeOffset> dateReceived);
    public CookieJar AddOrReplace(FlurlCookie cookie);
    public bool TryAddOrReplace(FlurlCookie cookie, String& reason);
    public CookieJar Remove(Func`2<FlurlCookie, bool> predicate);
    public CookieJar Clear();
    public void WriteTo(TextWriter writer);
    public static CookieJar LoadFrom(TextReader reader);
    public virtual string ToString();
    public static CookieJar LoadFromString(string s);
    public sealed virtual IEnumerator`1<FlurlCookie> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class Flurl.Http.CookieSession : object {
    private string _baseUrl;
    private IFlurlClient _client;
    [CompilerGeneratedAttribute]
private CookieJar <Cookies>k__BackingField;
    public CookieJar Cookies { get; }
    public CookieSession(string baseUrl);
    public CookieSession(IFlurlClient client);
    [CompilerGeneratedAttribute]
public CookieJar get_Cookies();
    public IFlurlRequest Request(Object[] urlSegments);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Flurl.Http.DownloadExtensions : object {
    [AsyncStateMachineAttribute("Flurl.Http.DownloadExtensions/<DownloadFileAsync>d__0")]
[ExtensionAttribute]
public static Task`1<string> DownloadFileAsync(IFlurlRequest request, string localFolderPath, string localFileName, int bufferSize, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    private static string GetFileNameFromHeaders(HttpResponseMessage resp);
    private static string GetFileNameFromPath(IFlurlRequest req);
}
[ExtensionAttribute]
public static class Flurl.Http.EventHandlerContainerExtensions : object {
    [ExtensionAttribute]
public static T BeforeCall(T obj, Action`1<FlurlCall> act);
    [ExtensionAttribute]
public static T BeforeCall(T obj, Func`2<FlurlCall, Task> act);
    [ExtensionAttribute]
public static T AfterCall(T obj, Action`1<FlurlCall> act);
    [ExtensionAttribute]
public static T AfterCall(T obj, Func`2<FlurlCall, Task> act);
    [ExtensionAttribute]
public static T OnError(T obj, Action`1<FlurlCall> act);
    [ExtensionAttribute]
public static T OnError(T obj, Func`2<FlurlCall, Task> act);
    [ExtensionAttribute]
public static T OnRedirect(T obj, Action`1<FlurlCall> act);
    [ExtensionAttribute]
public static T OnRedirect(T obj, Func`2<FlurlCall, Task> act);
    private static T AddHandler(T obj, FlurlEventType eventType, Action`1<FlurlCall> act);
    private static T AddHandler(T obj, FlurlEventType eventType, Func`2<FlurlCall, Task> act);
}
internal static class Flurl.Http.FileUtil : object {
    internal static string GetFileName(string path);
    internal static string CombinePath(String[] paths);
    internal static Task`1<Stream> OpenReadAsync(string path, int bufferSize);
    internal static Task`1<Stream> OpenWriteAsync(string folderPath, string fileName, int bufferSize);
    internal static string MakeValidName(string s);
}
public class Flurl.Http.FlurlCall : object {
    [CompilerGeneratedAttribute]
private IFlurlClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlurlRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <HttpRequestMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IFlurlResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private FlurlRedirect <Redirect>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <HttpResponseMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionHandled>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <EndedUtc>k__BackingField;
    public IFlurlClient Client { get; public set; }
    public IFlurlRequest Request { get; public set; }
    public HttpRequestMessage HttpRequestMessage { get; public set; }
    public string RequestBody { get; }
    public IFlurlResponse Response { get; public set; }
    public FlurlRedirect Redirect { get; public set; }
    public HttpResponseMessage HttpResponseMessage { get; public set; }
    public Exception Exception { get; public set; }
    public bool ExceptionHandled { get; public set; }
    public DateTime StartedUtc { get; public set; }
    public Nullable`1<DateTime> EndedUtc { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; }
    public bool Completed { get; }
    public bool Succeeded { get; }
    [CompilerGeneratedAttribute]
public IFlurlClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(IFlurlClient value);
    [CompilerGeneratedAttribute]
public IFlurlRequest get_Request();
    [CompilerGeneratedAttribute]
public void set_Request(IFlurlRequest value);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequestMessage();
    [CompilerGeneratedAttribute]
public void set_HttpRequestMessage(HttpRequestMessage value);
    public string get_RequestBody();
    [CompilerGeneratedAttribute]
public IFlurlResponse get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(IFlurlResponse value);
    [CompilerGeneratedAttribute]
public FlurlRedirect get_Redirect();
    [CompilerGeneratedAttribute]
public void set_Redirect(FlurlRedirect value);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_HttpResponseMessage();
    [CompilerGeneratedAttribute]
public void set_HttpResponseMessage(HttpResponseMessage value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public bool get_ExceptionHandled();
    [CompilerGeneratedAttribute]
public void set_ExceptionHandled(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_StartedUtc();
    [CompilerGeneratedAttribute]
public void set_StartedUtc(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_EndedUtc();
    [CompilerGeneratedAttribute]
public void set_EndedUtc(Nullable`1<DateTime> value);
    public Nullable`1<TimeSpan> get_Duration();
    public bool get_Completed();
    public bool get_Succeeded();
    public virtual string ToString();
}
public class Flurl.Http.FlurlClient : object {
    private static Lazy`1<IFlurlClientFactory> _defaultFactory;
    private static IDictionary`2<string, PropertyInfo> _reqHeaderProps;
    [CompilerGeneratedAttribute]
private string <BaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private FlurlHttpSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> <EventHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueList`1<string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public string BaseUrl { get; public set; }
    public FlurlHttpSettings Settings { get; }
    public IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> EventHandlers { get; }
    public INameValueList`1<string> Headers { get; }
    public HttpClient HttpClient { get; }
    public bool IsDisposed { get; private set; }
    public FlurlClient(string baseUrl);
    public FlurlClient(HttpClient httpClient, string baseUrl);
    internal FlurlClient(HttpClient httpClient, string baseUrl, FlurlHttpSettings settings, INameValueList`1<string> headers, IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> eventHandlers);
    private static FlurlClient();
    [IteratorStateMachineAttribute("Flurl.Http.FlurlClient/<GetHeadersFromHttpClient>d__5")]
private static IEnumerable`1<ValueTuple`2<string, string>> GetHeadersFromHttpClient(HttpClient httpClient);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BaseUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BaseUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual FlurlHttpSettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> get_EventHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual INameValueList`1<string> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual HttpClient get_HttpClient();
    public sealed virtual IFlurlRequest Request(Object[] urlSegments);
    [AsyncStateMachineAttribute("Flurl.Http.FlurlClient/<SendAsync>d__23")]
public sealed virtual Task`1<IFlurlResponse> SendAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    private void SyncHeaders(IFlurlRequest req, HttpRequestMessage reqMsg);
    [AsyncStateMachineAttribute("Flurl.Http.FlurlClient/<ProcessRedirectAsync>d__25")]
private Task`1<IFlurlResponse> ProcessRedirectAsync(FlurlCall call, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    private static FlurlRedirect GetRedirect(FlurlCall call);
    [AsyncStateMachineAttribute("Flurl.Http.FlurlClient/<RaiseEventAsync>d__27")]
internal static Task RaiseEventAsync(FlurlEventType eventType, FlurlCall call);
    [AsyncStateMachineAttribute("Flurl.Http.FlurlClient/<HandleExceptionAsync>d__28")]
internal static Task`1<IFlurlResponse> HandleExceptionAsync(FlurlCall call, Exception ex, CancellationToken token);
    private static CancellationToken GetCancellationTokenWithTimeout(CancellationToken original, Nullable`1<TimeSpan> timeout, CancellationTokenSource& timeoutTokenSource);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static bool <GetRedirect>g__ChangeVerbToGetOn|26_0(int statusCode, HttpMethod verb);
}
public class Flurl.Http.FlurlConfigurationException : Exception {
    public FlurlConfigurationException(string message);
}
public class Flurl.Http.FlurlCookie : object {
    private string _value;
    private Nullable`1<DateTimeOffset> _expires;
    private Nullable`1<int> _maxAge;
    private string _domain;
    private string _path;
    private bool _secure;
    private bool _httpOnly;
    private Nullable`1<SameSite> _sameSite;
    private bool _locked;
    [CompilerGeneratedAttribute]
private Url <OriginUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <DateReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Url OriginUrl { get; }
    public DateTimeOffset DateReceived { get; }
    public string Name { get; }
    public string Value { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<int> MaxAge { get; public set; }
    public string Domain { get; public set; }
    public string Path { get; public set; }
    public bool Secure { get; public set; }
    public bool HttpOnly { get; public set; }
    public Nullable`1<SameSite> SameSite { get; public set; }
    public FlurlCookie(string name, string value, string originUrl, Nullable`1<DateTimeOffset> dateReceived);
    [CompilerGeneratedAttribute]
public Url get_OriginUrl();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_DateReceived();
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_MaxAge();
    public void set_MaxAge(Nullable`1<int> value);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Path();
    public void set_Path(string value);
    public bool get_Secure();
    public void set_Secure(bool value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public Nullable`1<SameSite> get_SameSite();
    public void set_SameSite(Nullable`1<SameSite> value);
    public string GetKey();
    public void WriteTo(TextWriter writer);
    public static FlurlCookie LoadFrom(TextReader reader);
    public virtual string ToString();
    public static FlurlCookie LoadFromString(string s);
    internal void Lock();
    private void Update(T& field, T newVal, string propName);
}
public class Flurl.Http.FlurlEventHandler : object {
    public virtual void Handle(FlurlEventType eventType, FlurlCall call);
    public virtual Task HandleAsync(FlurlEventType eventType, FlurlCall call);
}
public enum Flurl.Http.FlurlEventType : Enum {
    public int value__;
    public static FlurlEventType BeforeCall;
    public static FlurlEventType AfterCall;
    public static FlurlEventType OnError;
    public static FlurlEventType OnRedirect;
}
public static class Flurl.Http.FlurlHttp : object {
    private static Func`2<IFlurlRequest, string> _cachingStrategy;
    [CompilerGeneratedAttribute]
private static IFlurlClientCache <Clients>k__BackingField;
    public static IFlurlClientCache Clients { get; }
    private static FlurlHttp();
    [CompilerGeneratedAttribute]
public static IFlurlClientCache get_Clients();
    public static IFlurlClientBuilder ConfigureClientForUrl(string url);
    public static IFlurlClient GetClientForRequest(IFlurlRequest req);
    public static void UseClientCachingStrategy(Func`2<IFlurlRequest, string> buildClientName);
    public static void UseClientPerHostStrategy();
    public static string BuildClientNameByHost(IFlurlRequest req);
}
public class Flurl.Http.FlurlHttpException : Exception {
    [CompilerGeneratedAttribute]
private FlurlCall <Call>k__BackingField;
    public FlurlCall Call { get; }
    public Nullable`1<int> StatusCode { get; }
    public FlurlHttpException(FlurlCall call, string message, Exception inner);
    public FlurlHttpException(FlurlCall call, Exception inner);
    public FlurlHttpException(FlurlCall call);
    [CompilerGeneratedAttribute]
public FlurlCall get_Call();
    private static string BuildMessage(FlurlCall call, Exception inner);
    public Nullable`1<int> get_StatusCode();
    public Task`1<string> GetResponseStringAsync();
    public Task`1<T> GetResponseJsonAsync();
}
public class Flurl.Http.FlurlHttpTimeoutException : FlurlHttpException {
    public FlurlHttpTimeoutException(FlurlCall call, Exception inner);
    private static string BuildMessage(FlurlCall call);
}
public class Flurl.Http.FlurlParsingException : FlurlHttpException {
    [CompilerGeneratedAttribute]
private string <ExpectedFormat>k__BackingField;
    public string ExpectedFormat { get; }
    public FlurlParsingException(FlurlCall call, string expectedFormat, Exception inner);
    [CompilerGeneratedAttribute]
public string get_ExpectedFormat();
    private static string BuildMessage(FlurlCall call, string expectedFormat);
}
public class Flurl.Http.FlurlRedirect : object {
    [CompilerGeneratedAttribute]
private Url <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Follow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChangeVerbToGet>k__BackingField;
    public Url Url { get; public set; }
    public int Count { get; public set; }
    public bool Follow { get; public set; }
    public bool ChangeVerbToGet { get; public set; }
    [CompilerGeneratedAttribute]
public Url get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Url value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public bool get_Follow();
    [CompilerGeneratedAttribute]
public void set_Follow(bool value);
    [CompilerGeneratedAttribute]
public bool get_ChangeVerbToGet();
    [CompilerGeneratedAttribute]
public void set_ChangeVerbToGet(bool value);
}
public class Flurl.Http.FlurlRequest : object {
    private IFlurlClient _client;
    private CookieJar _jar;
    [CompilerGeneratedAttribute]
private FlurlHttpSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> <EventHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMethod <Verb>k__BackingField;
    [CompilerGeneratedAttribute]
private Url <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpContent <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private FlurlCall <RedirectedFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueList`1<string> <Headers>k__BackingField;
    public FlurlHttpSettings Settings { get; }
    public IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> EventHandlers { get; }
    public IFlurlClient Client { get; public set; }
    public HttpMethod Verb { get; public set; }
    public Url Url { get; public set; }
    public HttpContent Content { get; public set; }
    public FlurlCall RedirectedFrom { get; public set; }
    public INameValueList`1<string> Headers { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<string, string>> Cookies { get; }
    public CookieJar CookieJar { get; public set; }
    public FlurlRequest(Url url);
    internal FlurlRequest(IFlurlClient client, Object[] urlSegments);
    internal FlurlRequest(string baseUrl, Object[] urlSegments);
    [CompilerGeneratedAttribute]
public sealed virtual FlurlHttpSettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> get_EventHandlers();
    public sealed virtual IFlurlClient get_Client();
    public sealed virtual void set_Client(IFlurlClient value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpMethod get_Verb();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verb(HttpMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual Url get_Url();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Url(Url value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpContent get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Content(HttpContent value);
    [CompilerGeneratedAttribute]
public sealed virtual FlurlCall get_RedirectedFrom();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RedirectedFrom(FlurlCall value);
    [CompilerGeneratedAttribute]
public sealed virtual INameValueList`1<string> get_Headers();
    public sealed virtual IEnumerable`1<ValueTuple`2<string, string>> get_Cookies();
    public sealed virtual CookieJar get_CookieJar();
    public sealed virtual void set_CookieJar(CookieJar value);
    public sealed virtual IFlurlClient EnsureClient();
    public sealed virtual Task`1<IFlurlResponse> SendAsync(HttpMethod verb, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    internal static void SyncHeaders(IFlurlClient client, IFlurlRequest request);
    private static void SyncBaseUrl(IFlurlClient client, IFlurlRequest request);
    private void ApplyCookieJar(CookieJar jar);
    [CompilerGeneratedAttribute]
private bool <ApplyCookieJar>b__42_0(FlurlCookie c);
}
public class Flurl.Http.FlurlResponse : object {
    private FlurlCall _call;
    private Lazy`1<IReadOnlyNameValueList`1<string>> _headers;
    private Lazy`1<IReadOnlyList`1<FlurlCookie>> _cookies;
    private object _capturedBody;
    private bool _streamRead;
    private ISerializer _serializer;
    public IReadOnlyNameValueList`1<string> Headers { get; }
    public IReadOnlyList`1<FlurlCookie> Cookies { get; }
    public HttpResponseMessage ResponseMessage { get; }
    public int StatusCode { get; }
    public FlurlResponse(FlurlCall call, CookieJar cookieJar);
    public sealed virtual IReadOnlyNameValueList`1<string> get_Headers();
    public sealed virtual IReadOnlyList`1<FlurlCookie> get_Cookies();
    public sealed virtual HttpResponseMessage get_ResponseMessage();
    public sealed virtual int get_StatusCode();
    private IReadOnlyNameValueList`1<string> LoadHeaders();
    private IReadOnlyList`1<FlurlCookie> LoadCookies();
    private void LoadCookieJar(CookieJar jar);
    [AsyncStateMachineAttribute("Flurl.Http.FlurlResponse/<GetJsonAsync>d__18`1")]
public sealed virtual Task`1<T> GetJsonAsync();
    [AsyncStateMachineAttribute("Flurl.Http.FlurlResponse/<GetStringAsync>d__19")]
public sealed virtual Task`1<string> GetStringAsync();
    public sealed virtual Task`1<Stream> GetStreamAsync();
    [AsyncStateMachineAttribute("Flurl.Http.FlurlResponse/<GetBytesAsync>d__21")]
public sealed virtual Task`1<Byte[]> GetBytesAsync();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Flurl.Http.GeneratedExtensions : object {
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendJsonAsync(IFlurlRequest request, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendStringAsync(IFlurlRequest request, HttpMethod verb, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendUrlEncodedAsync(IFlurlRequest request, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> GetAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> GetJsonAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> GetStringAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Byte[]> GetBytesAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostAsync(IFlurlRequest request, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostJsonAsync(IFlurlRequest request, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostStringAsync(IFlurlRequest request, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostUrlEncodedAsync(IFlurlRequest request, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> HeadAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutAsync(IFlurlRequest request, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutJsonAsync(IFlurlRequest request, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutStringAsync(IFlurlRequest request, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> DeleteAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchAsync(IFlurlRequest request, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchJsonAsync(IFlurlRequest request, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchStringAsync(IFlurlRequest request, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> OptionsAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendAsync(Url url, HttpMethod verb, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendJsonAsync(Url url, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendStringAsync(Url url, HttpMethod verb, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendUrlEncodedAsync(Url url, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> GetAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> GetJsonAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> GetStringAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Byte[]> GetBytesAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostAsync(Url url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostJsonAsync(Url url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostStringAsync(Url url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostUrlEncodedAsync(Url url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> HeadAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutAsync(Url url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutJsonAsync(Url url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutStringAsync(Url url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> DeleteAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchAsync(Url url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchJsonAsync(Url url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchStringAsync(Url url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> OptionsAsync(Url url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> DownloadFileAsync(Url url, string localFolderPath, string localFileName, int bufferSize, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostMultipartAsync(Url url, Action`1<CapturedMultipartContent> buildContent, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFlurlRequest WithHeader(Url url, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithHeaders(Url url, object headers, bool replaceUnderscoreWithHyphen);
    [ExtensionAttribute]
public static IFlurlRequest WithBasicAuth(Url url, string username, string password);
    [ExtensionAttribute]
public static IFlurlRequest WithOAuthBearerToken(Url url, string token);
    [ExtensionAttribute]
public static IFlurlRequest WithCookie(Url url, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Url url, object values);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Url url, CookieJar cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Url url, CookieJar& cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithSettings(Url url, Action`1<FlurlHttpSettings> action);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(Url url, TimeSpan timespan);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(Url url, int seconds);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(Url url, string pattern);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(Url url, Int32[] statusCodes);
    [ExtensionAttribute]
public static IFlurlRequest AllowAnyHttpStatus(Url url);
    [ExtensionAttribute]
public static IFlurlRequest WithAutoRedirect(Url url, bool enabled);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(Url url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(Url url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(Url url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(Url url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(Url url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(Url url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(Url url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(Url url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendAsync(string url, HttpMethod verb, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendJsonAsync(string url, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendStringAsync(string url, HttpMethod verb, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendUrlEncodedAsync(string url, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> GetAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> GetJsonAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> GetStringAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Byte[]> GetBytesAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostAsync(string url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostJsonAsync(string url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostStringAsync(string url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostUrlEncodedAsync(string url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> HeadAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutAsync(string url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutJsonAsync(string url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutStringAsync(string url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> DeleteAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchAsync(string url, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchJsonAsync(string url, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchStringAsync(string url, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> OptionsAsync(string url, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> DownloadFileAsync(string url, string localFolderPath, string localFileName, int bufferSize, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostMultipartAsync(string url, Action`1<CapturedMultipartContent> buildContent, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFlurlRequest WithHeader(string url, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithHeaders(string url, object headers, bool replaceUnderscoreWithHyphen);
    [ExtensionAttribute]
public static IFlurlRequest WithBasicAuth(string url, string username, string password);
    [ExtensionAttribute]
public static IFlurlRequest WithOAuthBearerToken(string url, string token);
    [ExtensionAttribute]
public static IFlurlRequest WithCookie(string url, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(string url, object values);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(string url, CookieJar cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(string url, CookieJar& cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithSettings(string url, Action`1<FlurlHttpSettings> action);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(string url, TimeSpan timespan);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(string url, int seconds);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(string url, string pattern);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(string url, Int32[] statusCodes);
    [ExtensionAttribute]
public static IFlurlRequest AllowAnyHttpStatus(string url);
    [ExtensionAttribute]
public static IFlurlRequest WithAutoRedirect(string url, bool enabled);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(string url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(string url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(string url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(string url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(string url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(string url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(string url, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(string url, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendAsync(Uri uri, HttpMethod verb, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendJsonAsync(Uri uri, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendStringAsync(Uri uri, HttpMethod verb, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> SendUrlEncodedAsync(Uri uri, HttpMethod verb, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> GetAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> GetJsonAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> GetStringAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Stream> GetStreamAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Byte[]> GetBytesAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostAsync(Uri uri, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostJsonAsync(Uri uri, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostStringAsync(Uri uri, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostUrlEncodedAsync(Uri uri, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> HeadAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutAsync(Uri uri, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutJsonAsync(Uri uri, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PutStringAsync(Uri uri, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> DeleteAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchAsync(Uri uri, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchJsonAsync(Uri uri, object body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PatchStringAsync(Uri uri, string body, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> OptionsAsync(Uri uri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<string> DownloadFileAsync(Uri uri, string localFolderPath, string localFileName, int bufferSize, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostMultipartAsync(Uri uri, Action`1<CapturedMultipartContent> buildContent, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFlurlRequest WithHeader(Uri uri, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithHeaders(Uri uri, object headers, bool replaceUnderscoreWithHyphen);
    [ExtensionAttribute]
public static IFlurlRequest WithBasicAuth(Uri uri, string username, string password);
    [ExtensionAttribute]
public static IFlurlRequest WithOAuthBearerToken(Uri uri, string token);
    [ExtensionAttribute]
public static IFlurlRequest WithCookie(Uri uri, string name, object value);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Uri uri, object values);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Uri uri, CookieJar cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithCookies(Uri uri, CookieJar& cookieJar);
    [ExtensionAttribute]
public static IFlurlRequest WithSettings(Uri uri, Action`1<FlurlHttpSettings> action);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(Uri uri, TimeSpan timespan);
    [ExtensionAttribute]
public static IFlurlRequest WithTimeout(Uri uri, int seconds);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(Uri uri, string pattern);
    [ExtensionAttribute]
public static IFlurlRequest AllowHttpStatus(Uri uri, Int32[] statusCodes);
    [ExtensionAttribute]
public static IFlurlRequest AllowAnyHttpStatus(Uri uri);
    [ExtensionAttribute]
public static IFlurlRequest WithAutoRedirect(Uri uri, bool enabled);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(Uri uri, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest BeforeCall(Uri uri, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(Uri uri, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest AfterCall(Uri uri, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(Uri uri, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnError(Uri uri, Func`2<FlurlCall, Task> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(Uri uri, Action`1<FlurlCall> action);
    [ExtensionAttribute]
public static IFlurlRequest OnRedirect(Uri uri, Func`2<FlurlCall, Task> action);
}
[ExtensionAttribute]
public static class Flurl.Http.HeaderExtensions : object {
    [ExtensionAttribute]
public static T WithHeader(T obj, string name, object value);
    [ExtensionAttribute]
public static T WithHeaders(T obj, object headers, bool replaceUnderscoreWithHyphen);
    [ExtensionAttribute]
public static T WithBasicAuth(T obj, string username, string password);
    [ExtensionAttribute]
public static T WithOAuthBearerToken(T obj, string token);
}
[ExtensionAttribute]
public static class Flurl.Http.HttpMessageExtensions : object {
    [ExtensionAttribute]
public static void SetHeader(HttpRequestMessage request, string name, object value, bool createContentIfNecessary);
    [ExtensionAttribute]
public static void SetHeader(HttpResponseMessage response, string name, object value, bool createContentIfNecessary);
    [ExtensionAttribute]
private static void SetHeader(HttpMessage msg, string name, object value, bool createContentIfNecessary);
}
public static class Flurl.Http.HttpStatusRangeParser : object {
    public static bool IsMatch(string pattern, HttpStatusCode value);
    public static bool IsMatch(string pattern, int value);
}
public interface Flurl.Http.IEventHandlerContainer {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> EventHandlers { get; }
    public abstract virtual IList`1<ValueTuple`2<FlurlEventType, IFlurlEventHandler>> get_EventHandlers();
}
public interface Flurl.Http.IFlurlClient {
    public HttpClient HttpClient { get; }
    public string BaseUrl { get; public set; }
    public bool IsDisposed { get; }
    public abstract virtual HttpClient get_HttpClient();
    public abstract virtual string get_BaseUrl();
    public abstract virtual void set_BaseUrl(string value);
    public abstract virtual IFlurlRequest Request(Object[] urlSegments);
    public abstract virtual bool get_IsDisposed();
    public abstract virtual Task`1<IFlurlResponse> SendAsync(IFlurlRequest request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
}
public interface Flurl.Http.IFlurlEventHandler {
    public abstract virtual void Handle(FlurlEventType eventType, FlurlCall call);
    public abstract virtual Task HandleAsync(FlurlEventType eventType, FlurlCall call);
}
public interface Flurl.Http.IFlurlRequest {
    public IFlurlClient Client { get; public set; }
    public HttpMethod Verb { get; public set; }
    public Url Url { get; public set; }
    public HttpContent Content { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<string, string>> Cookies { get; }
    public CookieJar CookieJar { get; public set; }
    public FlurlCall RedirectedFrom { get; public set; }
    public abstract virtual IFlurlClient get_Client();
    public abstract virtual void set_Client(IFlurlClient value);
    public abstract virtual HttpMethod get_Verb();
    public abstract virtual void set_Verb(HttpMethod value);
    public abstract virtual Url get_Url();
    public abstract virtual void set_Url(Url value);
    public abstract virtual HttpContent get_Content();
    public abstract virtual void set_Content(HttpContent value);
    public abstract virtual IEnumerable`1<ValueTuple`2<string, string>> get_Cookies();
    public abstract virtual CookieJar get_CookieJar();
    public abstract virtual void set_CookieJar(CookieJar value);
    public abstract virtual FlurlCall get_RedirectedFrom();
    public abstract virtual void set_RedirectedFrom(FlurlCall value);
    public abstract virtual IFlurlClient EnsureClient();
    public abstract virtual Task`1<IFlurlResponse> SendAsync(HttpMethod verb, HttpContent content, HttpCompletionOption completionOption, CancellationToken cancellationToken);
}
public interface Flurl.Http.IFlurlResponse {
    public IReadOnlyNameValueList`1<string> Headers { get; }
    public IReadOnlyList`1<FlurlCookie> Cookies { get; }
    public HttpResponseMessage ResponseMessage { get; }
    public int StatusCode { get; }
    public abstract virtual IReadOnlyNameValueList`1<string> get_Headers();
    public abstract virtual IReadOnlyList`1<FlurlCookie> get_Cookies();
    public abstract virtual HttpResponseMessage get_ResponseMessage();
    public abstract virtual int get_StatusCode();
    public abstract virtual Task`1<T> GetJsonAsync();
    public abstract virtual Task`1<string> GetStringAsync();
    public abstract virtual Task`1<Stream> GetStreamAsync();
    public abstract virtual Task`1<Byte[]> GetBytesAsync();
}
public interface Flurl.Http.IHeadersContainer {
    public INameValueList`1<string> Headers { get; }
    public abstract virtual INameValueList`1<string> get_Headers();
}
public class Flurl.Http.InvalidCookieException : Exception {
    public InvalidCookieException(string reason);
}
public interface Flurl.Http.ISettingsContainer {
    public FlurlHttpSettings Settings { get; }
    public abstract virtual FlurlHttpSettings get_Settings();
}
[ExtensionAttribute]
public static class Flurl.Http.MultipartExtensions : object {
    [ExtensionAttribute]
public static Task`1<IFlurlResponse> PostMultipartAsync(IFlurlRequest request, Action`1<CapturedMultipartContent> buildContent, HttpCompletionOption completionOption, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Flurl.Http.ResponseExtensions : object {
    [AsyncStateMachineAttribute("Flurl.Http.ResponseExtensions/<ReceiveJson>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> ReceiveJson(Task`1<IFlurlResponse> response);
    [AsyncStateMachineAttribute("Flurl.Http.ResponseExtensions/<ReceiveString>d__1")]
[ExtensionAttribute]
public static Task`1<string> ReceiveString(Task`1<IFlurlResponse> response);
    [AsyncStateMachineAttribute("Flurl.Http.ResponseExtensions/<ReceiveStream>d__2")]
[ExtensionAttribute]
public static Task`1<Stream> ReceiveStream(Task`1<IFlurlResponse> response);
    [AsyncStateMachineAttribute("Flurl.Http.ResponseExtensions/<ReceiveBytes>d__3")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReceiveBytes(Task`1<IFlurlResponse> response);
}
public enum Flurl.Http.SameSite : Enum {
    public int value__;
    public static SameSite Strict;
    public static SameSite Lax;
    public static SameSite None;
}
[ExtensionAttribute]
public static class Flurl.Http.SettingsExtensions : object {
    [ExtensionAttribute]
public static T WithSettings(T obj, Action`1<FlurlHttpSettings> action);
    [ExtensionAttribute]
public static T WithTimeout(T obj, TimeSpan timespan);
    [ExtensionAttribute]
public static T WithTimeout(T obj, int seconds);
    [ExtensionAttribute]
public static T AllowHttpStatus(T obj, string pattern);
    [ExtensionAttribute]
public static T AllowHttpStatus(T obj, Int32[] statusCodes);
    [ExtensionAttribute]
public static T AllowAnyHttpStatus(T obj);
    [ExtensionAttribute]
public static T WithAutoRedirect(T obj, bool enabled);
}
public class Flurl.Http.Testing.FilteredHttpTestSetup : HttpTestSetup {
    private List`1<Func`2<FlurlCall, bool>> _filters;
    public FilteredHttpTestSetup(FlurlHttpSettings settings, String[] urlPatterns);
    internal bool IsMatch(FlurlCall call);
    public FilteredHttpTestSetup With(Func`2<FlurlCall, bool> condition);
    public FilteredHttpTestSetup Without(Func`2<FlurlCall, bool> condition);
    public FilteredHttpTestSetup WithVerb(HttpMethod[] verbs);
    public FilteredHttpTestSetup WithVerb(String[] verbs);
    public FilteredHttpTestSetup WithQueryParam(string name, object value);
    public FilteredHttpTestSetup WithoutQueryParam(string name, object value);
    public FilteredHttpTestSetup WithQueryParams(String[] names);
    public FilteredHttpTestSetup WithoutQueryParams(String[] names);
    public FilteredHttpTestSetup WithQueryParams(object values);
    public FilteredHttpTestSetup WithoutQueryParams(object values);
    public FilteredHttpTestSetup WithAnyQueryParam(String[] names);
    public FilteredHttpTestSetup WithHeader(string name, string valuePattern);
    public FilteredHttpTestSetup WithoutHeader(string name, string valuePattern);
    public FilteredHttpTestSetup WithRequestBody(string pattern);
    public FilteredHttpTestSetup WithRequestJson(object body);
}
public class Flurl.Http.Testing.HttpCallAssertion : object {
    private HttpTest _test;
    private bool _negate;
    private IList`1<string> _expectedConditions;
    private IList`1<FlurlCall> _calls;
    public HttpCallAssertion(HttpTest test, bool negate);
    public void Times(int expectedCount);
    public HttpCallAssertion With(Func`2<FlurlCall, bool> match, string descrip);
    public HttpCallAssertion Without(Func`2<FlurlCall, bool> match, string descrip);
    public HttpCallAssertion WithUrlPattern(string urlPattern);
    public HttpCallAssertion WithVerb(HttpMethod[] verbs);
    public HttpCallAssertion WithVerb(String[] verbs);
    public HttpCallAssertion WithRequestBody(string bodyPattern);
    public HttpCallAssertion WithRequestJson(object body);
    public HttpCallAssertion WithRequestUrlEncoded(object body);
    public HttpCallAssertion WithQueryParam(string name, object value);
    public HttpCallAssertion WithoutQueryParam(string name, object value);
    public HttpCallAssertion WithQueryParams(String[] names);
    public HttpCallAssertion WithoutQueryParams(String[] names);
    public HttpCallAssertion WithAnyQueryParam(String[] names);
    public HttpCallAssertion WithQueryParams(object values);
    public HttpCallAssertion WithoutQueryParams(object values);
    public HttpCallAssertion WithHeader(string name, object value);
    public HttpCallAssertion WithoutHeader(string name, object value);
    public HttpCallAssertion WithHeaders(String[] names);
    public HttpCallAssertion WithoutHeaders(String[] names);
    public HttpCallAssertion WithAnyHeader(String[] names);
    public HttpCallAssertion WithHeaders(object values);
    public HttpCallAssertion WithoutHeaders(object values);
    public HttpCallAssertion WithCookie(string name, object value);
    public HttpCallAssertion WithoutCookie(string name, object value);
    public HttpCallAssertion WithCookies(String[] names);
    public HttpCallAssertion WithoutCookies(String[] names);
    public HttpCallAssertion WithAnyCookie(String[] names);
    public HttpCallAssertion WithCookies(object values);
    public HttpCallAssertion WithoutCookies(object values);
    public HttpCallAssertion WithContentType(string contentType);
    public HttpCallAssertion WithOAuthBearerToken(string token);
    public HttpCallAssertion WithBasicAuth(string username, string password);
    private void Assert(Nullable`1<int> count);
    private string BuildDescrip(string label, string name, object value);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithQueryParams>b__16_0(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutQueryParams>b__17_1(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithQueryParams>b__19_0(ValueTuple`2<string, object> kv);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutQueryParams>b__20_0(ValueTuple`2<string, object> kv);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithHeaders>b__23_0(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutHeaders>b__24_1(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithHeaders>b__26_0(ValueTuple`2<string, object> kv);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutHeaders>b__27_0(ValueTuple`2<string, object> kv);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithCookies>b__30_0(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutCookies>b__31_1(string n);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithCookies>b__33_0(ValueTuple`2<string, object> kv);
    [CompilerGeneratedAttribute]
private HttpCallAssertion <WithoutCookies>b__34_0(ValueTuple`2<string, object> kv);
}
public class Flurl.Http.Testing.HttpTest : HttpTestSetup {
    private ConcurrentQueue`1<FlurlCall> _calls;
    private List`1<FilteredHttpTestSetup> _filteredSetups;
    private static AsyncLocal`1<HttpTest> _test;
    public static HttpTest Current { get; }
    public IReadOnlyList`1<FlurlCall> CallLog { get; }
    private static HttpTest();
    internal void LogCall(FlurlCall call);
    public static HttpTest get_Current();
    public IReadOnlyList`1<FlurlCall> get_CallLog();
    public FilteredHttpTestSetup ForCallsTo(String[] urlPatterns);
    internal HttpTestSetup FindSetup(FlurlCall call);
    public HttpCallAssertion ShouldHaveCalled(string urlPattern);
    public void ShouldNotHaveCalled(string urlPattern);
    public HttpCallAssertion ShouldHaveMadeACall();
    public void ShouldNotHaveMadeACall();
    public sealed virtual void Dispose();
    private static void SetCurrentTest(HttpTest test);
    private static HttpTest GetCurrentTest();
}
public class Flurl.Http.Testing.HttpTestException : Exception {
    public HttpTestException(IList`1<string> conditions, Nullable`1<int> expectedCalls, int actualCalls);
    private static string BuildMessage(IList`1<string> conditions, Nullable`1<int> expectedCalls, int actualCalls);
}
public abstract class Flurl.Http.Testing.HttpTestSetup : object {
    private List`1<Func`1<HttpResponseMessage>> _responses;
    private int _respIndex;
    private bool _allowRealHttp;
    [CompilerGeneratedAttribute]
private FlurlHttpSettings <Settings>k__BackingField;
    public FlurlHttpSettings Settings { get; }
    protected HttpTestSetup(FlurlHttpSettings settings);
    [CompilerGeneratedAttribute]
public sealed virtual FlurlHttpSettings get_Settings();
    internal HttpResponseMessage GetNextResponse();
    public HttpTestSetup RespondWith(string body, int status, object headers, object cookies, bool replaceUnderscoreWithHyphen);
    public HttpTestSetup RespondWithJson(object body, int status, object headers, object cookies, bool replaceUnderscoreWithHyphen);
    public HttpTestSetup RespondWith(Func`1<HttpContent> buildContent, int status, object headers, object cookies, bool replaceUnderscoreWithHyphen);
    public HttpTestSetup SimulateTimeout();
    public HttpTestSetup SimulateException(Exception exception);
    public void AllowRealHttp();
}
[ExtensionAttribute]
internal static class Flurl.Http.Testing.Util : object {
    [ExtensionAttribute]
internal static bool HasAnyVerb(FlurlCall call, HttpMethod[] verbs);
    [ExtensionAttribute]
internal static bool HasAnyVerb(FlurlCall call, String[] verbs);
    [ExtensionAttribute]
internal static bool HasQueryParam(FlurlCall call, string name, object value);
    [ExtensionAttribute]
internal static bool HasAllQueryParams(FlurlCall call, String[] names);
    [ExtensionAttribute]
internal static bool HasAnyQueryParam(FlurlCall call, String[] names);
    [ExtensionAttribute]
internal static bool HasQueryParams(FlurlCall call, object values);
    [ExtensionAttribute]
internal static bool HasHeader(FlurlCall call, string name, object value);
    [ExtensionAttribute]
internal static bool HasCookie(FlurlCall call, string name, object value);
    private static bool MatchesValueOrPattern(object valueToMatch, object value);
    internal static bool MatchesUrlPattern(string url, string pattern);
    internal static bool MatchesPattern(string textToCheck, string pattern);
}
[ExtensionAttribute]
public static class Flurl.Http.UrlBuilderExtensions : object {
    [ExtensionAttribute]
public static IFlurlRequest AppendPathSegment(IFlurlRequest request, object segment, bool fullyEncode);
    [ExtensionAttribute]
public static IFlurlRequest AppendPathSegments(IFlurlRequest request, Object[] segments);
    [ExtensionAttribute]
public static IFlurlRequest AppendPathSegments(IFlurlRequest request, IEnumerable`1<object> segments);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParam(IFlurlRequest request, string name, object value, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParam(IFlurlRequest request, string name, string value, bool isEncoded, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParam(IFlurlRequest request, string name);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParams(IFlurlRequest request, object values, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParams(IFlurlRequest request, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IFlurlRequest SetQueryParams(IFlurlRequest request, String[] names);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, string name, object value, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, string name, string value, bool isEncoded, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, string name);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, object values, NullValueHandling nullValueHandling);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IFlurlRequest AppendQueryParam(IFlurlRequest request, String[] names);
    [ExtensionAttribute]
public static IFlurlRequest RemoveQueryParam(IFlurlRequest request, string name);
    [ExtensionAttribute]
public static IFlurlRequest RemoveQueryParams(IFlurlRequest request, String[] names);
    [ExtensionAttribute]
public static IFlurlRequest RemoveQueryParams(IFlurlRequest request, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IFlurlRequest SetFragment(IFlurlRequest request, string fragment);
    [ExtensionAttribute]
public static IFlurlRequest RemoveFragment(IFlurlRequest request);
}
