internal static class ExceptionHelpers : object {
    public static Exception PrepareForRethrow(Exception exception);
}
[DebuggerDisplayAttribute("Id = {Id}, IsSet = {_set}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncAutoResetEvent/DebugView")]
public class Foundatio.AsyncEx.AsyncAutoResetEvent : object {
    private IAsyncWaitQueue`1<object> _queue;
    private bool _set;
    private int _id;
    private object _mutex;
    public int Id { get; }
    public bool IsSet { get; }
    internal AsyncAutoResetEvent(bool set, IAsyncWaitQueue`1<object> queue);
    public AsyncAutoResetEvent(bool set);
    public int get_Id();
    public bool get_IsSet();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task WaitAsync();
    public void Wait(CancellationToken cancellationToken);
    public void Wait();
    public void Set();
}
[DebuggerDisplayAttribute("Id = {Id}, AsyncLockId = {_asyncLock.Id}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncConditionVariable/DebugView")]
public class Foundatio.AsyncEx.AsyncConditionVariable : object {
    private AsyncLock _asyncLock;
    private IAsyncWaitQueue`1<object> _queue;
    private int _id;
    private object _mutex;
    public int Id { get; }
    internal AsyncConditionVariable(AsyncLock asyncLock, IAsyncWaitQueue`1<object> queue);
    public AsyncConditionVariable(AsyncLock asyncLock);
    public int get_Id();
    public void Notify();
    public void NotifyAll();
    public Task WaitAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.AsyncEx.AsyncConditionVariable/<WaitAndRetakeLockAsync>d__11")]
private static Task WaitAndRetakeLockAsync(Task task, AsyncLock asyncLock);
    public Task WaitAsync();
    public void Wait(CancellationToken cancellationToken);
    public void Wait();
}
[DebuggerDisplayAttribute("Id = {Id}, CurrentCount = {_count}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncCountdownEvent/DebugView")]
public class Foundatio.AsyncEx.AsyncCountdownEvent : object {
    private AsyncManualResetEvent _mre;
    private long _count;
    public int Id { get; }
    public long CurrentCount { get; }
    public AsyncCountdownEvent(long count);
    public int get_Id();
    public long get_CurrentCount();
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    private void ModifyCount(long difference, bool add);
    public void AddCount(long addCount);
    public void AddCount();
    public void Signal(long signalCount);
    public void Signal();
}
[DebuggerDisplayAttribute("Id = {Id}, State = {GetStateForDebugger}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncLazy`1/DebugView")]
public class Foundatio.AsyncEx.AsyncLazy`1 : object {
    private object _mutex;
    private Func`1<Task`1<T>> _factory;
    private Lazy`1<Task`1<T>> _instance;
    private int _id;
    [DebuggerNonUserCodeAttribute]
internal LazyState<T> GetStateForDebugger { get; }
    public int Id { get; }
    public bool IsStarted { get; }
    public Task`1<T> Task { get; }
    public AsyncLazy`1(Func`1<Task`1<T>> factory, AsyncLazyFlags flags);
    internal LazyState<T> get_GetStateForDebugger();
    public int get_Id();
    public bool get_IsStarted();
    public Task`1<T> get_Task();
    private Func`1<Task`1<T>> RetryOnFailure(Func`1<Task`1<T>> factory);
    private Func`1<Task`1<T>> RunOnThreadPool(Func`1<Task`1<T>> factory);
    [EditorBrowsableAttribute("1")]
public TaskAwaiter`1<T> GetAwaiter();
    [EditorBrowsableAttribute("1")]
public ConfiguredTaskAwaitable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public void Start();
}
[FlagsAttribute]
public enum Foundatio.AsyncEx.AsyncLazyFlags : Enum {
    public int value__;
    public static AsyncLazyFlags None;
    public static AsyncLazyFlags ExecuteOnCallingThread;
    public static AsyncLazyFlags RetryOnFailure;
}
[DebuggerDisplayAttribute("Id = {Id}, Taken = {_taken}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncLock/DebugView")]
public class Foundatio.AsyncEx.AsyncLock : object {
    private bool _taken;
    private IAsyncWaitQueue`1<IDisposable> _queue;
    private int _id;
    private object _mutex;
    public int Id { get; }
    internal AsyncLock(IAsyncWaitQueue`1<IDisposable> queue);
    public int get_Id();
    private Task`1<IDisposable> RequestLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> LockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> LockAsync();
    public IDisposable Lock(CancellationToken cancellationToken);
    public IDisposable Lock();
    internal void ReleaseLock();
}
[DebuggerDisplayAttribute("Id = {Id}, IsSet = {GetStateForDebugger}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncManualResetEvent/DebugView")]
public class Foundatio.AsyncEx.AsyncManualResetEvent : object {
    private object _mutex;
    private TaskCompletionSource`1<object> _tcs;
    private int _id;
    [DebuggerNonUserCodeAttribute]
private bool GetStateForDebugger { get; }
    public int Id { get; }
    public bool IsSet { get; }
    public AsyncManualResetEvent(bool set);
    private bool get_GetStateForDebugger();
    public int get_Id();
    public bool get_IsSet();
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public void Set();
    public void Reset();
}
[DebuggerDisplayAttribute("Id = {Id}, State = {GetStateForDebugger}, ReaderCount = {GetReaderCountForDebugger}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncReaderWriterLock/DebugView")]
public class Foundatio.AsyncEx.AsyncReaderWriterLock : object {
    private IAsyncWaitQueue`1<IDisposable> _writerQueue;
    private IAsyncWaitQueue`1<IDisposable> _readerQueue;
    private object _mutex;
    private int _id;
    private int _locksHeld;
    [DebuggerNonUserCodeAttribute]
internal State GetStateForDebugger { get; }
    [DebuggerNonUserCodeAttribute]
internal int GetReaderCountForDebugger { get; }
    public int Id { get; }
    internal AsyncReaderWriterLock(IAsyncWaitQueue`1<IDisposable> writerQueue, IAsyncWaitQueue`1<IDisposable> readerQueue);
    internal State get_GetStateForDebugger();
    internal int get_GetReaderCountForDebugger();
    public int get_Id();
    private void ReleaseWaitersWhenCanceled(Task task);
    private Task`1<IDisposable> RequestReaderLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> ReaderLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> ReaderLockAsync();
    public IDisposable ReaderLock(CancellationToken cancellationToken);
    public IDisposable ReaderLock();
    private Task`1<IDisposable> RequestWriterLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> WriterLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> WriterLockAsync();
    public IDisposable WriterLock(CancellationToken cancellationToken);
    public IDisposable WriterLock();
    private void ReleaseWaiters();
    internal void ReleaseReaderLock();
    internal void ReleaseWriterLock();
    [CompilerGeneratedAttribute]
private void <ReleaseWaitersWhenCanceled>b__14_0(Task t);
}
[DebuggerDisplayAttribute("Id = {Id}, CurrentCount = {_count}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.AsyncSemaphore/DebugView")]
public class Foundatio.AsyncEx.AsyncSemaphore : object {
    private IAsyncWaitQueue`1<object> _queue;
    private long _count;
    private int _id;
    private object _mutex;
    public int Id { get; }
    public long CurrentCount { get; }
    internal AsyncSemaphore(long initialCount, IAsyncWaitQueue`1<object> queue);
    public AsyncSemaphore(long initialCount);
    public int get_Id();
    public long get_CurrentCount();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task WaitAsync();
    public void Wait(CancellationToken cancellationToken);
    public void Wait();
    public void Release(long releaseCount);
    public void Release();
    [AsyncStateMachineAttribute("Foundatio.AsyncEx.AsyncSemaphore/<DoLockAsync>d__16")]
private Task`1<IDisposable> DoLockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> LockAsync(CancellationToken cancellationToken);
    public AwaitableDisposable`1<IDisposable> LockAsync();
    public IDisposable Lock(CancellationToken cancellationToken);
    public IDisposable Lock();
}
[ExtensionAttribute]
internal static class Foundatio.AsyncEx.AsyncWaitQueueExtensions : object {
    [ExtensionAttribute]
public static Task`1<T> Enqueue(IAsyncWaitQueue`1<T> this, object mutex, CancellationToken token);
}
public class Foundatio.AsyncEx.AwaitableDisposable`1 : ValueType {
    private Task`1<T> _task;
    public AwaitableDisposable`1(Task`1<T> task);
    public Task`1<T> AsTask();
    public static Task`1<T> op_Implicit(AwaitableDisposable`1<T> source);
    public TaskAwaiter`1<T> GetAwaiter();
    public ConfiguredTaskAwaitable`1<T> ConfigureAwait(bool continueOnCapturedContext);
}
public class Foundatio.AsyncEx.CancellationTokenTaskSource`1 : object {
    private IDisposable _registration;
    [CompilerGeneratedAttribute]
private Task`1<T> <Task>k__BackingField;
    public Task`1<T> Task { get; private set; }
    public CancellationTokenTaskSource`1(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Task`1<T> get_Task();
    [CompilerGeneratedAttribute]
private void set_Task(Task`1<T> value);
    public sealed virtual void Dispose();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Foundatio.AsyncEx.DefaultAsyncWaitQueue`1/DebugView")]
internal class Foundatio.AsyncEx.DefaultAsyncWaitQueue`1 : object {
    private Deque`1<TaskCompletionSource`1<T>> _queue;
    private int Count { get; }
    private bool Foundatio.AsyncEx.IAsyncWaitQueue<T>.IsEmpty { get; }
    private int get_Count();
    private sealed virtual override bool Foundatio.AsyncEx.IAsyncWaitQueue<T>.get_IsEmpty();
    private sealed virtual override Task`1<T> Foundatio.AsyncEx.IAsyncWaitQueue<T>.Enqueue();
    private sealed virtual override void Foundatio.AsyncEx.IAsyncWaitQueue<T>.Dequeue(T result);
    private sealed virtual override void Foundatio.AsyncEx.IAsyncWaitQueue<T>.DequeueAll(T result);
    private sealed virtual override bool Foundatio.AsyncEx.IAsyncWaitQueue<T>.TryCancel(Task task, CancellationToken cancellationToken);
    private sealed virtual override void Foundatio.AsyncEx.IAsyncWaitQueue<T>.CancelAll(CancellationToken cancellationToken);
}
internal interface Foundatio.AsyncEx.IAsyncWaitQueue`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual Task`1<T> Enqueue();
    public abstract virtual void Dequeue(T result);
    public abstract virtual void DequeueAll(T result);
    public abstract virtual bool TryCancel(Task task, CancellationToken cancellationToken);
    public abstract virtual void CancelAll(CancellationToken cancellationToken);
}
internal static class Foundatio.AsyncEx.IdManager`1 : object {
    private static int _lastId;
    public static int GetId(Int32& id);
}
[ExtensionAttribute]
public static class Foundatio.AsyncEx.Synchronous.TaskExtensions : object {
    [ExtensionAttribute]
public static void WaitAndUnwrapException(Task task);
    [ExtensionAttribute]
public static void WaitAndUnwrapException(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TResult WaitAndUnwrapException(Task`1<TResult> task);
    [ExtensionAttribute]
public static TResult WaitAndUnwrapException(Task`1<TResult> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WaitWithoutException(Task task);
    [ExtensionAttribute]
public static void WaitWithoutException(Task task, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Foundatio.AsyncEx.TaskCompletionSourceExtensions : object {
    [ExtensionAttribute]
public static bool TryCompleteFromCompletedTask(TaskCompletionSource`1<TResult> this, Task`1<TSourceResult> task);
    [ExtensionAttribute]
public static bool TryCompleteFromCompletedTask(TaskCompletionSource`1<TResult> this, Task task, Func`1<TResult> resultFunc);
    public static TaskCompletionSource`1<TResult> CreateAsyncTaskSource();
}
public static class Foundatio.AsyncEx.TaskConstants : object {
    private static Task`1<bool> booleanTrue;
    private static Task`1<int> intNegativeOne;
    public static Task`1<bool> BooleanTrue { get; }
    public static Task`1<bool> BooleanFalse { get; }
    public static Task`1<int> Int32Zero { get; }
    public static Task`1<int> Int32NegativeOne { get; }
    public static Task Completed { get; }
    public static Task Canceled { get; }
    private static TaskConstants();
    public static Task`1<bool> get_BooleanTrue();
    public static Task`1<bool> get_BooleanFalse();
    public static Task`1<int> get_Int32Zero();
    public static Task`1<int> get_Int32NegativeOne();
    public static Task get_Completed();
    public static Task get_Canceled();
}
public static class Foundatio.AsyncEx.TaskConstants`1 : object {
    private static Task`1<T> defaultValue;
    private static Task`1<T> canceled;
    public static Task`1<T> Default { get; }
    public static Task`1<T> Canceled { get; }
    private static TaskConstants`1();
    public static Task`1<T> get_Default();
    public static Task`1<T> get_Canceled();
}
[ExtensionAttribute]
public static class Foundatio.AsyncEx.TaskExtensions : object {
    [ExtensionAttribute]
public static Task WaitAsync(Task this, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.AsyncEx.TaskExtensions/<DoWaitAsync>d__1")]
private static Task DoWaitAsync(Task task, CancellationToken cancellationToken);
}
public class Foundatio.Builder`2 : MulticastDelegate {
    public Builder`2(object object, IntPtr method);
    public virtual TBuilder Invoke(TBuilder builder);
    public virtual IAsyncResult BeginInvoke(TBuilder builder, AsyncCallback callback, object object);
    public virtual TBuilder EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Foundatio.Caching.CacheClientExtensions : object {
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<GetAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> GetAsync(ICacheClient client, string key, T defaultValue);
    [ExtensionAttribute]
public static Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(ICacheClient client, String[] keys);
    [ExtensionAttribute]
public static Task`1<long> IncrementAsync(ICacheClient client, string key, long amount, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<double> IncrementAsync(ICacheClient client, string key, double amount, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<long> IncrementAsync(ICacheClient client, string key, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<long> DecrementAsync(ICacheClient client, string key, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<long> DecrementAsync(ICacheClient client, string key, long amount, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<long> DecrementAsync(ICacheClient client, string key, long amount, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<double> DecrementAsync(ICacheClient client, string key, double amount, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<bool> AddAsync(ICacheClient client, string key, T value, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<bool> SetAsync(ICacheClient client, string key, T value, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<bool> ReplaceAsync(ICacheClient client, string key, T value, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<bool> ReplaceIfEqualAsync(ICacheClient client, string key, T value, T expected, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task`1<int> SetAllAsync(ICacheClient client, IDictionary`2<string, object> values, Nullable`1<DateTime> expiresAtUtc);
    [ExtensionAttribute]
public static Task SetExpirationAsync(ICacheClient client, string key, DateTime expiresAtUtc);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<ListAddAsync>d__15`1")]
[ExtensionAttribute]
public static Task`1<bool> ListAddAsync(ICacheClient client, string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<ListRemoveAsync>d__16`1")]
[ExtensionAttribute]
public static Task`1<bool> ListRemoveAsync(ICacheClient client, string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<SetAddAsync>d__17`1")]
[ExtensionAttribute]
[ObsoleteAttribute("Use ListAddAsync instead")]
public static Task`1<bool> SetAddAsync(ICacheClient client, string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<SetRemoveAsync>d__18`1")]
[ExtensionAttribute]
[ObsoleteAttribute("Use ListRemoveAsync instead")]
public static Task`1<bool> SetRemoveAsync(ICacheClient client, string key, T value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ListAddAsync instead")]
public static Task`1<long> SetAddAsync(ICacheClient client, string key, IEnumerable`1<T> value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ListRemoveAsync instead")]
public static Task`1<long> SetRemoveAsync(ICacheClient client, string key, IEnumerable`1<T> value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ListAddAsync instead")]
public static Task`1<CacheValue`1<ICollection`1<T>>> GetSetAsync(ICacheClient client, string key);
    [ExtensionAttribute]
public static Task`1<long> SetIfHigherAsync(ICacheClient client, string key, DateTime value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<long> SetIfLowerAsync(ICacheClient client, string key, DateTime value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<GetUnixTimeMillisecondsAsync>d__24")]
[ExtensionAttribute]
public static Task`1<DateTime> GetUnixTimeMillisecondsAsync(ICacheClient client, string key, Nullable`1<DateTime> defaultValue);
    [ExtensionAttribute]
public static Task`1<bool> SetUnixTimeMillisecondsAsync(ICacheClient client, string key, DateTime value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<bool> SetUnixTimeMillisecondsAsync(ICacheClient client, string key, DateTime value, Nullable`1<DateTime> expiresAtUtc);
    [AsyncStateMachineAttribute("Foundatio.Caching.CacheClientExtensions/<GetUnixTimeSecondsAsync>d__27")]
[ExtensionAttribute]
public static Task`1<DateTimeOffset> GetUnixTimeSecondsAsync(ICacheClient client, string key, Nullable`1<DateTime> defaultValue);
    [ExtensionAttribute]
public static Task`1<bool> SetUnixTimeSecondsAsync(ICacheClient client, string key, DateTime value, Nullable`1<TimeSpan> expiresIn);
    [ExtensionAttribute]
public static Task`1<bool> SetUnixTimeSecondsAsync(ICacheClient client, string key, DateTime value, Nullable`1<DateTime> expiresAtUtc);
}
public class Foundatio.Caching.CacheValue`1 : object {
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private static CacheValue`1<T> <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private static CacheValue`1<T> <NoValue>k__BackingField;
    public bool HasValue { get; }
    public bool IsNull { get; }
    public T Value { get; }
    public static CacheValue`1<T> Null { get; }
    public static CacheValue`1<T> NoValue { get; }
    public CacheValue`1(T value, bool hasValue);
    private static CacheValue`1();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public static CacheValue`1<T> get_Null();
    [CompilerGeneratedAttribute]
public static CacheValue`1<T> get_NoValue();
    public virtual string ToString();
}
public class Foundatio.Caching.HybridCacheClient : object {
    protected ICacheClient _distributedCache;
    protected IMessageBus _messageBus;
    private string _cacheId;
    private InMemoryCacheClient _localCache;
    private ILogger _logger;
    private long _localCacheHits;
    private long _invalidateCacheCalls;
    public InMemoryCacheClient LocalCache { get; }
    public long LocalCacheHits { get; }
    public long InvalidateCacheCalls { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public HybridCacheClient(ICacheClient distributedCacheClient, IMessageBus messageBus, InMemoryCacheClientOptions localCacheOptions, ILoggerFactory loggerFactory);
    public InMemoryCacheClient get_LocalCache();
    public long get_LocalCacheHits();
    public long get_InvalidateCacheCalls();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    private Task OnLocalCacheItemExpiredAsync(object sender, ItemExpiredEventArgs args);
    private Task OnRemoteCacheItemExpiredAsync(InvalidateCache message);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<RemoveAsync>d__20")]
public sealed virtual Task`1<bool> RemoveAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<RemoveIfEqualAsync>d__21`1")]
public sealed virtual Task`1<bool> RemoveIfEqualAsync(string key, T expected);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<RemoveAllAsync>d__22")]
public sealed virtual Task`1<int> RemoveAllAsync(IEnumerable`1<string> keys);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<RemoveByPrefixAsync>d__23")]
public sealed virtual Task`1<int> RemoveByPrefixAsync(string prefix);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<GetAsync>d__24`1")]
public sealed virtual Task`1<CacheValue`1<T>> GetAsync(string key);
    public sealed virtual Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(IEnumerable`1<string> keys);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<AddAsync>d__26`1")]
public sealed virtual Task`1<bool> AddAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetAsync>d__27`1")]
public sealed virtual Task`1<bool> SetAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetAllAsync>d__28`1")]
public sealed virtual Task`1<int> SetAllAsync(IDictionary`2<string, T> values, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<ReplaceAsync>d__29`1")]
public sealed virtual Task`1<bool> ReplaceAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<ReplaceIfEqualAsync>d__30`1")]
public sealed virtual Task`1<bool> ReplaceIfEqualAsync(string key, T value, T expected, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<IncrementAsync>d__31")]
public sealed virtual Task`1<double> IncrementAsync(string key, double amount, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<IncrementAsync>d__32")]
public sealed virtual Task`1<long> IncrementAsync(string key, long amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ExistsAsync(string key);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> GetExpirationAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetExpirationAsync>d__35")]
public sealed virtual Task SetExpirationAsync(string key, TimeSpan expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetIfHigherAsync>d__36")]
public sealed virtual Task`1<double> SetIfHigherAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetIfHigherAsync>d__37")]
public sealed virtual Task`1<long> SetIfHigherAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetIfLowerAsync>d__38")]
public sealed virtual Task`1<double> SetIfLowerAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<SetIfLowerAsync>d__39")]
public sealed virtual Task`1<long> SetIfLowerAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<ListAddAsync>d__40`1")]
public sealed virtual Task`1<long> ListAddAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<ListRemoveAsync>d__41`1")]
public sealed virtual Task`1<long> ListRemoveAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.HybridCacheClient/<GetListAsync>d__42`1")]
public sealed virtual Task`1<CacheValue`1<ICollection`1<T>>> GetListAsync(string key, Nullable`1<int> page, int pageSize);
    public virtual void Dispose();
}
public interface Foundatio.Caching.ICacheClient {
    public abstract virtual Task`1<bool> RemoveAsync(string key);
    public abstract virtual Task`1<bool> RemoveIfEqualAsync(string key, T expected);
    public abstract virtual Task`1<int> RemoveAllAsync(IEnumerable`1<string> keys);
    public abstract virtual Task`1<int> RemoveByPrefixAsync(string prefix);
    public abstract virtual Task`1<CacheValue`1<T>> GetAsync(string key);
    public abstract virtual Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(IEnumerable`1<string> keys);
    public abstract virtual Task`1<bool> AddAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<bool> SetAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<int> SetAllAsync(IDictionary`2<string, T> values, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<bool> ReplaceAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<bool> ReplaceIfEqualAsync(string key, T value, T expected, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<double> IncrementAsync(string key, double amount, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<long> IncrementAsync(string key, long amount, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<bool> ExistsAsync(string key);
    public abstract virtual Task`1<Nullable`1<TimeSpan>> GetExpirationAsync(string key);
    public abstract virtual Task SetExpirationAsync(string key, TimeSpan expiresIn);
    public abstract virtual Task`1<double> SetIfHigherAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<long> SetIfHigherAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<double> SetIfLowerAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<long> SetIfLowerAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<long> ListAddAsync(string key, IEnumerable`1<T> value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<long> ListRemoveAsync(string key, IEnumerable`1<T> value, Nullable`1<TimeSpan> expiresIn);
    public abstract virtual Task`1<CacheValue`1<ICollection`1<T>>> GetListAsync(string key, Nullable`1<int> page, int pageSize);
}
public interface Foundatio.Caching.IHybridCacheClient {
}
public interface Foundatio.Caching.IMemoryCacheClient {
}
public class Foundatio.Caching.InMemoryCacheClient : object {
    private ConcurrentDictionary`2<string, CacheEntry> _memory;
    private bool _shouldClone;
    private bool _shouldThrowOnSerializationErrors;
    private Nullable`1<int> _maxItems;
    private long _writes;
    private long _hits;
    private long _misses;
    private TimeProvider _timeProvider;
    private ILogger _logger;
    private AsyncLock _lock;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<ItemExpiredEventArgs> <ItemExpired>k__BackingField;
    private DateTime _lastMaintenance;
    public int Count { get; }
    public Nullable`1<int> MaxItems { get; }
    public long Calls { get; }
    public long Writes { get; }
    public long Reads { get; }
    public long Hits { get; }
    public long Misses { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public AsyncEvent`1<ItemExpiredEventArgs> ItemExpired { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<KeyValuePair`2<string, object>> Items { get; }
    public InMemoryCacheClient(InMemoryCacheClientOptions options);
    public InMemoryCacheClient(Builder`2<InMemoryCacheClientOptionsBuilder, InMemoryCacheClientOptions> config);
    public int get_Count();
    public Nullable`1<int> get_MaxItems();
    public long get_Calls();
    public long get_Writes();
    public long get_Reads();
    public long get_Hits();
    public long get_Misses();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    public virtual string ToString();
    public void ResetStats();
    [CompilerGeneratedAttribute]
public AsyncEvent`1<ItemExpiredEventArgs> get_ItemExpired();
    private void OnItemExpired(string key, bool sendNotification);
    public ICollection`1<string> get_Keys();
    public ICollection`1<KeyValuePair`2<string, object>> get_Items();
    public sealed virtual Task`1<bool> RemoveAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<RemoveIfEqualAsync>d__42`1")]
public sealed virtual Task`1<bool> RemoveIfEqualAsync(string key, T expected);
    public sealed virtual Task`1<int> RemoveAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<int> RemoveByPrefixAsync(string prefix);
    internal void RemoveExpiredKey(string key, bool sendNotification);
    public sealed virtual Task`1<CacheValue`1<T>> GetAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<GetAllAsync>d__47`1")]
public sealed virtual Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<bool> AddAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> SetAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetIfHigherAsync>d__50")]
public sealed virtual Task`1<double> SetIfHigherAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetIfHigherAsync>d__51")]
public sealed virtual Task`1<long> SetIfHigherAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetIfLowerAsync>d__52")]
public sealed virtual Task`1<double> SetIfLowerAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetIfLowerAsync>d__53")]
public sealed virtual Task`1<long> SetIfLowerAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<ListAddAsync>d__54`1")]
public sealed virtual Task`1<long> ListAddAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> ListRemoveAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<GetListAsync>d__56`1")]
public sealed virtual Task`1<CacheValue`1<ICollection`1<T>>> GetListAsync(string key, Nullable`1<int> page, int pageSize);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetInternalAsync>d__57")]
private Task`1<bool> SetInternalAsync(string key, CacheEntry entry, bool addOnly);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetAllAsync>d__58`1")]
public sealed virtual Task`1<int> SetAllAsync(IDictionary`2<string, T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ReplaceAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<ReplaceIfEqualAsync>d__60`1")]
public sealed virtual Task`1<bool> ReplaceIfEqualAsync(string key, T value, T expected, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<IncrementAsync>d__61")]
public sealed virtual Task`1<double> IncrementAsync(string key, double amount, Nullable`1<TimeSpan> expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<IncrementAsync>d__62")]
public sealed virtual Task`1<long> IncrementAsync(string key, long amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ExistsAsync(string key);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> GetExpirationAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<SetExpirationAsync>d__65")]
public sealed virtual Task SetExpirationAsync(string key, TimeSpan expiresIn);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<StartMaintenanceAsync>d__67")]
private Task StartMaintenanceAsync(bool compactImmediately);
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<CompactAsync>d__68")]
private Task CompactAsync();
    [AsyncStateMachineAttribute("Foundatio.Caching.InMemoryCacheClient/<DoMaintenanceAsync>d__69")]
private Task DoMaintenanceAsync();
    public sealed virtual void Dispose();
}
public class Foundatio.Caching.InMemoryCacheClientOptions : SharedOptions {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloneValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldThrowOnSerializationError>k__BackingField;
    public Nullable`1<int> MaxItems { get; public set; }
    public bool CloneValues { get; public set; }
    public bool ShouldThrowOnSerializationError { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxItems();
    [CompilerGeneratedAttribute]
public void set_MaxItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_CloneValues();
    [CompilerGeneratedAttribute]
public void set_CloneValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldThrowOnSerializationError();
    [CompilerGeneratedAttribute]
public void set_ShouldThrowOnSerializationError(bool value);
}
public class Foundatio.Caching.InMemoryCacheClientOptionsBuilder : SharedOptionsBuilder`2<InMemoryCacheClientOptions, InMemoryCacheClientOptionsBuilder> {
    public InMemoryCacheClientOptionsBuilder MaxItems(Nullable`1<int> maxItems);
    public InMemoryCacheClientOptionsBuilder CloneValues(bool cloneValues);
    public InMemoryCacheClientOptionsBuilder ShouldThrowOnSerializationError(bool shouldThrow);
}
public class Foundatio.Caching.ItemExpiredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private InMemoryCacheClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendNotification>k__BackingField;
    public InMemoryCacheClient Client { get; public set; }
    public string Key { get; public set; }
    public bool SendNotification { get; public set; }
    [CompilerGeneratedAttribute]
public InMemoryCacheClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(InMemoryCacheClient value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public bool get_SendNotification();
    [CompilerGeneratedAttribute]
public void set_SendNotification(bool value);
}
public class Foundatio.Caching.NullCacheClient : object {
    public static NullCacheClient Instance;
    private long _writes;
    private long _reads;
    public long Calls { get; }
    public long Writes { get; }
    public long Reads { get; }
    private static NullCacheClient();
    public long get_Calls();
    public long get_Writes();
    public long get_Reads();
    public virtual string ToString();
    public void ResetStats();
    public sealed virtual Task`1<bool> RemoveAsync(string key);
    public sealed virtual Task`1<bool> RemoveIfEqualAsync(string key, T expected);
    public sealed virtual Task`1<int> RemoveAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<int> RemoveByPrefixAsync(string prefix);
    public sealed virtual Task`1<CacheValue`1<T>> GetAsync(string key);
    public sealed virtual Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<bool> AddAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> SetAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<int> SetAllAsync(IDictionary`2<string, T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ReplaceAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ReplaceIfEqualAsync(string key, T value, T expected, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<double> IncrementAsync(string key, double amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> IncrementAsync(string key, long amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ExistsAsync(string key);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> GetExpirationAsync(string key);
    public sealed virtual Task SetExpirationAsync(string key, TimeSpan expiresIn);
    public sealed virtual Task`1<double> SetIfHigherAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> SetIfHigherAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<double> SetIfLowerAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> SetIfLowerAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> ListAddAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> ListRemoveAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<CacheValue`1<ICollection`1<T>>> GetListAsync(string key, Nullable`1<int> page, int pageSize);
    public sealed virtual void Dispose();
}
public class Foundatio.Caching.ScopedCacheClient : object {
    private string _keyPrefix;
    private bool _isLocked;
    private object _lock;
    [CompilerGeneratedAttribute]
private ICacheClient <UnscopedCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    public ICacheClient UnscopedCache { get; private set; }
    public string Scope { get; private set; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public ScopedCacheClient(ICacheClient client, string scope);
    [CompilerGeneratedAttribute]
public ICacheClient get_UnscopedCache();
    [CompilerGeneratedAttribute]
private void set_UnscopedCache(ICacheClient value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(string value);
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    public void SetScope(string scope);
    protected string GetUnscopedCacheKey(string key);
    protected IEnumerable`1<string> GetUnscopedCacheKeys(IEnumerable`1<string> keys);
    protected string GetScopedCacheKey(string unscopedKey);
    public sealed virtual Task`1<bool> RemoveAsync(string key);
    public sealed virtual Task`1<bool> RemoveIfEqualAsync(string key, T expected);
    public sealed virtual Task`1<int> RemoveAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<int> RemoveByPrefixAsync(string prefix);
    public sealed virtual Task`1<CacheValue`1<T>> GetAsync(string key);
    [AsyncStateMachineAttribute("Foundatio.Caching.ScopedCacheClient/<GetAllAsync>d__25`1")]
public sealed virtual Task`1<IDictionary`2<string, CacheValue`1<T>>> GetAllAsync(IEnumerable`1<string> keys);
    public sealed virtual Task`1<bool> AddAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> SetAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<int> SetAllAsync(IDictionary`2<string, T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ReplaceAsync(string key, T value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ReplaceIfEqualAsync(string key, T value, T expected, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<double> IncrementAsync(string key, double amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> IncrementAsync(string key, long amount, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<bool> ExistsAsync(string key);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> GetExpirationAsync(string key);
    public sealed virtual Task SetExpirationAsync(string key, TimeSpan expiresIn);
    public sealed virtual Task`1<double> SetIfHigherAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> SetIfHigherAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<double> SetIfLowerAsync(string key, double value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> SetIfLowerAsync(string key, long value, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> ListAddAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<long> ListRemoveAsync(string key, IEnumerable`1<T> values, Nullable`1<TimeSpan> expiresIn);
    public sealed virtual Task`1<CacheValue`1<ICollection`1<T>>> GetListAsync(string key, Nullable`1<int> page, int pageSize);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private string <GetAllAsync>b__25_0(KeyValuePair`2<string, CacheValue`1<T>> kvp);
    [CompilerGeneratedAttribute]
private string <SetAllAsync>b__28_0(KeyValuePair`2<string, T> kvp);
}
public class Foundatio.Caching.ScopedHybridCacheClient : ScopedCacheClient {
    public ScopedHybridCacheClient(IHybridCacheClient client, string scope);
}
internal static class Foundatio.Collections.CollectionHelpers : object {
    public static IReadOnlyCollection`1<T> ReifyCollection(IEnumerable`1<T> source);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}, Capacity = {Capacity}")]
[DebuggerTypeProxyAttribute("Foundatio.Collections.Deque`1/DebugView")]
public class Foundatio.Collections.Deque`1 : object {
    private static int DefaultCapacity;
    private T[] _buffer;
    private int _offset;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public T Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool IsEmpty { get; }
    private bool IsFull { get; }
    private bool IsSplit { get; }
    public int Capacity { get; public set; }
    public int Count { get; private set; }
    public Deque`1(int capacity);
    public Deque`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private void CopyToArray(Array array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Foundatio.Collections.Deque`1/<GetEnumerator>d__19")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsT(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void CheckNewIndexArgument(int sourceLength, int index);
    private static void CheckExistingIndexArgument(int sourceLength, int index);
    private static void CheckRangeArguments(int sourceLength, int offset, int count);
    private bool get_IsEmpty();
    private bool get_IsFull();
    private bool get_IsSplit();
    public int get_Capacity();
    public void set_Capacity(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    private int DequeIndexToBufferIndex(int index);
    private T DoGetItem(int index);
    private void DoSetItem(int index, T item);
    private void DoInsert(int index, T item);
    private void DoRemoveAt(int index);
    private int PostIncrement(int value);
    private int PreDecrement(int value);
    private void DoAddToBack(T value);
    private void DoAddToFront(T value);
    private T DoRemoveFromBack();
    private T DoRemoveFromFront();
    private void DoInsertRange(int index, IReadOnlyCollection`1<T> collection);
    private void DoRemoveRange(int index, int collectionCount);
    private void EnsureCapacityForOneElement();
    public void AddToBack(T value);
    public void AddToFront(T value);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public void RemoveRange(int offset, int count);
    public T RemoveFromBack();
    public T RemoveFromFront();
    public sealed virtual void Clear();
    public T[] ToArray();
}
public class Foundatio.Disposables.AnonymousDisposable : SingleDisposable`1<Action> {
    public AnonymousDisposable(Action dispose);
    protected virtual void Dispose(Action context);
    public void Add(Action dispose);
    public static AnonymousDisposable Create(Action dispose);
}
public class Foundatio.Disposables.Internals.BoundActionField`1 : object {
    private BoundAction<T> _field;
    public bool IsEmpty { get; }
    public BoundActionField`1(Action`1<T> action, T context);
    public bool get_IsEmpty();
    public IBoundAction<T> TryGetAndUnset();
    public bool TryUpdateContext(Func`2<T, T> contextUpdater);
}
public abstract class Foundatio.Disposables.SingleDisposable`1 : object {
    private BoundActionField`1<T> _context;
    private TaskCompletionSource`1<object> _tcs;
    public bool IsDisposeStarted { get; }
    public bool IsDisposed { get; }
    public bool IsDisposing { get; }
    protected SingleDisposable`1(T context);
    public bool get_IsDisposeStarted();
    public bool get_IsDisposed();
    public bool get_IsDisposing();
    protected abstract virtual void Dispose(T context);
    public sealed virtual void Dispose();
    protected bool TryUpdateContext(Func`2<T, T> contextUpdater);
}
[ExtensionAttribute]
internal static class Foundatio.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string NormalizePath(string path);
}
[ExtensionAttribute]
internal static class Foundatio.Force.DeepCloner.DeepClonerExtensions : object {
    private static DeepClonerExtensions();
    [ExtensionAttribute]
public static T DeepClone(T obj);
    [ExtensionAttribute]
public static TTo DeepCloneTo(TFrom objFrom, TTo objTo);
    [ExtensionAttribute]
public static TTo ShallowCloneTo(TFrom objFrom, TTo objTo);
    [ExtensionAttribute]
public static T ShallowClone(T obj);
    private static bool PermissionCheck();
}
internal static class Foundatio.Force.DeepCloner.Helpers.ClonerToExprGenerator : object {
    internal static object GenerateClonerInternal(Type realType, bool isDeepClone);
    private static object GenerateProcessMethod(Type type, bool isDeepClone);
    private static object GenerateProcessArrayMethod(Type type, bool isDeep);
    internal static T[] ShallowClone1DimArraySafeInternal(T[] objFrom, T[] objTo);
    internal static T[] Clone1DimArraySafeInternal(T[] objFrom, T[] objTo, DeepCloneState state);
    internal static T[] Clone1DimArrayStructInternal(T[] objFrom, T[] objTo, DeepCloneState state);
    internal static T[] Clone1DimArrayClassInternal(T[] objFrom, T[] objTo, DeepCloneState state);
    internal static T[0...,0...] Clone2DimArrayInternal(T[0...,0...] objFrom, T[0...,0...] objTo, DeepCloneState state, bool isDeep);
    internal static Array CloneAbstractArrayInternal(Array objFrom, Array objTo, DeepCloneState state, bool isDeep);
}
internal static class Foundatio.Force.DeepCloner.Helpers.DeepClonerCache : object {
    private static ConcurrentDictionary`2<Type, object> _typeCache;
    private static ConcurrentDictionary`2<Type, object> _typeCacheDeepTo;
    private static ConcurrentDictionary`2<Type, object> _typeCacheShallowTo;
    private static ConcurrentDictionary`2<Type, object> _structAsObjectCache;
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, object> _typeConvertCache;
    private static DeepClonerCache();
    public static object GetOrAddClass(Type type, Func`2<Type, T> adder);
    public static object GetOrAddDeepClassTo(Type type, Func`2<Type, T> adder);
    public static object GetOrAddShallowClassTo(Type type, Func`2<Type, T> adder);
    public static object GetOrAddStructAsObject(Type type, Func`2<Type, T> adder);
    public static T GetOrAddConvertor(Type from, Type to, Func`3<Type, Type, T> adder);
    public static void ClearCache();
}
internal static class Foundatio.Force.DeepCloner.Helpers.DeepClonerExprGenerator : object {
    private static ConcurrentDictionary`2<FieldInfo, bool> _readonlyFields;
    private static bool _canFastCopyReadonlyFields;
    private static MethodInfo _fieldSetMethod;
    private static FieldInfo _attributesFieldInfo;
    private static DeepClonerExprGenerator();
    internal static object GenerateClonerInternal(Type realType, bool asObject);
    internal static void ForceSetField(FieldInfo field, object obj, object value);
    private static object GenerateProcessMethod(Type type, bool unboxStruct);
    private static object GenerateProcessArrayMethod(Type type);
    private static object GenerateProcessTupleMethod(Type type);
}
internal static class Foundatio.Force.DeepCloner.Helpers.DeepClonerGenerator : object {
    public static T CloneObject(T obj);
    private static object CloneClassRoot(object obj);
    internal static object CloneClassInternal(object obj, DeepCloneState state);
    private static T CloneStructInternal(T obj, DeepCloneState state);
    internal static T[] Clone1DimArraySafeInternal(T[] obj, DeepCloneState state);
    internal static T[] Clone1DimArrayStructInternal(T[] obj, DeepCloneState state);
    internal static T[] Clone1DimArrayClassInternal(T[] obj, DeepCloneState state);
    internal static T[0...,0...] Clone2DimArrayInternal(T[0...,0...] obj, DeepCloneState state);
    internal static Array CloneAbstractArrayInternal(Array obj, DeepCloneState state);
    internal static Func`3<T, DeepCloneState, T> GetClonerForValueType();
    private static object GenerateCloner(Type t, bool asObject);
    public static object CloneObjectTo(object objFrom, object objTo, bool isDeep);
}
internal static class Foundatio.Force.DeepCloner.Helpers.DeepClonerSafeTypes : object {
    internal static ConcurrentDictionary`2<Type, bool> KnownTypes;
    private static DeepClonerSafeTypes();
    private static bool CanReturnSameType(Type type, HashSet`1<Type> processingTypes);
    public static bool CanReturnSameObject(Type type);
}
internal class Foundatio.Force.DeepCloner.Helpers.DeepCloneState : object {
    private MiniDictionary _loops;
    private Object[] _baseFromTo;
    private int _idx;
    public object GetKnownRef(object from);
    public void AddKnownRef(object from, object to);
}
[ExtensionAttribute]
internal static class Foundatio.Force.DeepCloner.Helpers.ReflectionHelper : object {
    [ExtensionAttribute]
public static bool IsEnum(Type t);
    [ExtensionAttribute]
public static bool IsValueType(Type t);
    [ExtensionAttribute]
public static bool IsClass(Type t);
    [ExtensionAttribute]
public static Type BaseType(Type t);
    [ExtensionAttribute]
public static FieldInfo[] GetAllFields(Type t);
    [ExtensionAttribute]
public static PropertyInfo[] GetPublicProperties(Type t);
    [ExtensionAttribute]
public static FieldInfo[] GetDeclaredFields(Type t);
    [ExtensionAttribute]
public static ConstructorInfo[] GetPrivateConstructors(Type t);
    [ExtensionAttribute]
public static ConstructorInfo[] GetPublicConstructors(Type t);
    [ExtensionAttribute]
public static MethodInfo GetPrivateMethod(Type t, string methodName);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type t, string methodName);
    [ExtensionAttribute]
public static MethodInfo GetPrivateStaticMethod(Type t, string methodName);
    [ExtensionAttribute]
public static FieldInfo GetPrivateField(Type t, string fieldName);
    [ExtensionAttribute]
public static FieldInfo GetPrivateStaticField(Type t, string fieldName);
    [ExtensionAttribute]
public static bool IsSubclassOfTypeByName(Type t, string typeName);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type from, Type to);
    [ExtensionAttribute]
public static bool IsInstanceOfType(Type from, object to);
    [ExtensionAttribute]
public static Type[] GenericArguments(Type t);
}
internal static class Foundatio.Force.DeepCloner.Helpers.ShallowClonerGenerator : object {
    public static T CloneObject(T obj);
}
internal abstract class Foundatio.Force.DeepCloner.Helpers.ShallowObjectCloner : object {
    private static ShallowObjectCloner _unsafeInstance;
    private static ShallowObjectCloner _instance;
    private static ShallowObjectCloner();
    protected abstract virtual object DoCloneObject(object obj);
    public static object CloneObject(object obj);
    internal static bool IsSafeVariant();
    internal static void SwitchTo(bool isSafe);
}
public static class Foundatio.FoundatioDiagnostics : object {
    internal static AssemblyName AssemblyName;
    internal static string AssemblyVersion;
    public static ActivitySource ActivitySource;
    public static Meter Meter;
    private static FoundatioDiagnostics();
}
public interface Foundatio.IOptionsBuilder {
    public object Target { get; }
    public abstract virtual object get_Target();
}
public interface Foundatio.IOptionsBuilder`1 {
    public abstract virtual T Build();
}
public class Foundatio.Jobs.DelegateWorkItemHandler : WorkItemHandlerBase {
    private Func`2<WorkItemContext, Task> _handler;
    private Action`3<IQueueEntry`1<WorkItemData>, Type, object> _logProcessingWorkItem;
    private Action`3<IQueueEntry`1<WorkItemData>, Type, object> _logAutoCompletedWorkItem;
    public DelegateWorkItemHandler(Func`2<WorkItemContext, Task> handler, ILogger logger, Action`3<IQueueEntry`1<WorkItemData>, Type, object> logProcessingWorkItem, Action`3<IQueueEntry`1<WorkItemData>, Type, object> logAutoCompletedWorkItem);
    public virtual Task HandleItemAsync(WorkItemContext context);
    public virtual void LogProcessingQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
    public virtual void LogAutoCompletedQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
}
public interface Foundatio.Jobs.IJob {
    public abstract virtual Task`1<JobResult> RunAsync(CancellationToken cancellationToken);
}
public interface Foundatio.Jobs.IQueueJob`1 {
    public IQueue`1<T> Queue { get; }
    public abstract virtual Task`1<JobResult> ProcessAsync(IQueueEntry`1<T> queueEntry, CancellationToken cancellationToken);
    public abstract virtual IQueue`1<T> get_Queue();
}
public interface Foundatio.Jobs.IWorkItemHandler {
    public bool AutoRenewLockOnProgress { get; public set; }
    public ILogger Log { get; public set; }
    public abstract virtual Task`1<ILock> GetWorkItemLockAsync(object workItem, CancellationToken cancellationToken);
    public abstract virtual Task HandleItemAsync(WorkItemContext context);
    public abstract virtual bool get_AutoRenewLockOnProgress();
    public abstract virtual void set_AutoRenewLockOnProgress(bool value);
    public abstract virtual ILogger get_Log();
    public abstract virtual void set_Log(ILogger value);
    public abstract virtual void LogProcessingQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
    public abstract virtual void LogAutoCompletedQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
}
[AttributeUsageAttribute("4")]
public class Foundatio.Jobs.JobAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsContinuous>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstanceCount>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public bool IsContinuous { get; public set; }
    public string Interval { get; public set; }
    public string InitialDelay { get; public set; }
    public int IterationLimit { get; public set; }
    public int InstanceCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsContinuous();
    [CompilerGeneratedAttribute]
public void set_IsContinuous(bool value);
    [CompilerGeneratedAttribute]
public string get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(string value);
    [CompilerGeneratedAttribute]
public string get_InitialDelay();
    [CompilerGeneratedAttribute]
public void set_InitialDelay(string value);
    [CompilerGeneratedAttribute]
public int get_IterationLimit();
    [CompilerGeneratedAttribute]
public void set_IterationLimit(int value);
    [CompilerGeneratedAttribute]
public int get_InstanceCount();
    [CompilerGeneratedAttribute]
public void set_InstanceCount(int value);
}
public abstract class Foundatio.Jobs.JobBase : object {
    protected TimeProvider _timeProvider;
    protected ILogger _logger;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    public string JobId { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public JobBase(ILoggerFactory loggerFactory);
    public JobBase(TimeProvider timeProvider, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
public string get_JobId();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    public virtual Task`1<JobResult> RunAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<JobResult> RunInternalAsync(JobContext context);
}
public class Foundatio.Jobs.JobContext : object {
    [CompilerGeneratedAttribute]
private ILock <Lock>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public ILock Lock { get; }
    public CancellationToken CancellationToken { get; }
    public JobContext(CancellationToken cancellationToken, ILock lck);
    [CompilerGeneratedAttribute]
public ILock get_Lock();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public virtual Task RenewLockAsync();
}
[ExtensionAttribute]
public static class Foundatio.Jobs.JobExtensions : object {
    [AsyncStateMachineAttribute("Foundatio.Jobs.JobExtensions/<TryRunAsync>d__0")]
[ExtensionAttribute]
public static Task`1<JobResult> TryRunAsync(IJob job, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Jobs.JobExtensions/<RunContinuousAsync>d__1")]
[ExtensionAttribute]
public static Task`1<int> RunContinuousAsync(IJob job, Nullable`1<TimeSpan> interval, int iterationLimit, CancellationToken cancellationToken, Func`1<Task`1<bool>> continuationCallback);
}
[ExtensionAttribute]
public static class Foundatio.Jobs.JobOptionExtensions : object {
    [ExtensionAttribute]
public static void ApplyDefaults(JobOptions jobOptions);
}
public class Foundatio.Jobs.JobOptions : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IServiceProvider, IJob> <JobFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunContinuous>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <InitialDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstanceCount>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public Func`2<IServiceProvider, IJob> JobFactory { get; public set; }
    public bool RunContinuous { get; public set; }
    public Nullable`1<TimeSpan> Interval { get; public set; }
    public Nullable`1<TimeSpan> InitialDelay { get; public set; }
    public int IterationLimit { get; public set; }
    public int InstanceCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Func`2<IServiceProvider, IJob> get_JobFactory();
    [CompilerGeneratedAttribute]
public void set_JobFactory(Func`2<IServiceProvider, IJob> value);
    [CompilerGeneratedAttribute]
public bool get_RunContinuous();
    [CompilerGeneratedAttribute]
public void set_RunContinuous(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_InitialDelay();
    [CompilerGeneratedAttribute]
public void set_InitialDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_IterationLimit();
    [CompilerGeneratedAttribute]
public void set_IterationLimit(int value);
    [CompilerGeneratedAttribute]
public int get_InstanceCount();
    [CompilerGeneratedAttribute]
public void set_InstanceCount(int value);
    public static JobOptions GetDefaults(Type jobType);
    public static void ApplyDefaults(JobOptions jobOptions, Type jobType);
    public static JobOptions GetDefaults();
    public static JobOptions GetDefaults(IJob instance);
    public static JobOptions GetDefaults(IJob instance);
    public static JobOptions GetDefaults(Type jobType, Func`2<IServiceProvider, IJob> jobFactory);
    public static JobOptions GetDefaults(Func`2<IServiceProvider, IJob> jobFactory);
}
public class Foundatio.Jobs.JobResult : object {
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public static JobResult None;
    public static JobResult Cancelled;
    public static JobResult Success;
    public bool IsCancelled { get; public set; }
    public Exception Error { get; public set; }
    public string Message { get; public set; }
    public bool IsSuccess { get; public set; }
    private static JobResult();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public void set_IsCancelled(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
public void set_IsSuccess(bool value);
    public static JobResult FromException(Exception exception, string message);
    public static JobResult CancelledWithMessage(string message);
    public static JobResult SuccessWithMessage(string message);
    public static JobResult FailedWithMessage(string message);
}
[ExtensionAttribute]
public static class Foundatio.Jobs.JobResultExtensions : object {
    [ExtensionAttribute]
public static void LogJobResult(ILogger logger, JobResult result, string jobName);
}
public class Foundatio.Jobs.JobRunner : object {
    private TimeProvider _timeProvider;
    private ILogger _logger;
    private string _jobName;
    private JobOptions _options;
    private IServiceProvider _serviceProvider;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    private static CancellationTokenSource _jobShutdownCancellationTokenSource;
    private static object _lock;
    public CancellationTokenSource CancellationTokenSource { get; private set; }
    public JobRunner(JobOptions options, IServiceProvider serviceProvider, ILoggerFactory loggerFactory);
    public JobRunner(IJob instance, IServiceProvider serviceProvider, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> initialDelay, int instanceCount, bool runContinuous, int iterationLimit, Nullable`1<TimeSpan> interval);
    public JobRunner(Func`2<IServiceProvider, IJob> jobFactory, IServiceProvider serviceProvider, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> initialDelay, int instanceCount, bool runContinuous, int iterationLimit, Nullable`1<TimeSpan> interval);
    private static JobRunner();
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_CancellationTokenSource();
    [CompilerGeneratedAttribute]
private void set_CancellationTokenSource(CancellationTokenSource value);
    [AsyncStateMachineAttribute("Foundatio.Jobs.JobRunner/<RunInConsoleAsync>d__12")]
public Task`1<int> RunInConsoleAsync();
    public void RunInBackground(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Jobs.JobRunner/<RunAsync>d__14")]
public Task`1<bool> RunAsync(CancellationToken cancellationToken);
    public static CancellationToken GetShutdownCancellationToken(ILogger logger);
}
public abstract class Foundatio.Jobs.JobWithLockBase : object {
    protected ILogger _logger;
    private TimeProvider _timeProvider;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    public string JobId { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public JobWithLockBase(ILoggerFactory loggerFactory);
    public JobWithLockBase(TimeProvider timeProvider, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
public string get_JobId();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    [AsyncStateMachineAttribute("Foundatio.Jobs.JobWithLockBase/<RunAsync>d__11")]
public virtual Task`1<JobResult> RunAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<JobResult> RunInternalAsync(JobContext context);
    protected abstract virtual Task`1<ILock> GetLockAsync(CancellationToken cancellationToken);
}
public class Foundatio.Jobs.QueueEntryContext`1 : JobContext {
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <QueueEntry>k__BackingField;
    public IQueueEntry`1<T> QueueEntry { get; private set; }
    public QueueEntryContext`1(IQueueEntry`1<T> queueEntry, ILock queueEntryLock, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_QueueEntry();
    [CompilerGeneratedAttribute]
private void set_QueueEntry(IQueueEntry`1<T> value);
    [AsyncStateMachineAttribute("Foundatio.Jobs.QueueEntryContext`1/<RenewLockAsync>d__5")]
public virtual Task RenewLockAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public abstract class Foundatio.Jobs.QueueJobBase`1 : object {
    protected ILogger _logger;
    protected Lazy`1<IQueue`1<T>> _queue;
    protected TimeProvider _timeProvider;
    protected string _queueEntryName;
    [CompilerGeneratedAttribute]
private bool <AutoComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    protected bool AutoComplete { get; protected set; }
    public string JobId { get; }
    private IQueue`1<T> Foundatio.Jobs.IQueueJob<T>.Queue { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public QueueJobBase`1(Lazy`1<IQueue`1<T>> queue, TimeProvider timeProvider, ILoggerFactory loggerFactory);
    public QueueJobBase`1(IQueue`1<T> queue, TimeProvider timeProvider, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
protected bool get_AutoComplete();
    [CompilerGeneratedAttribute]
protected void set_AutoComplete(bool value);
    [CompilerGeneratedAttribute]
public string get_JobId();
    private sealed virtual override IQueue`1<T> Foundatio.Jobs.IQueueJob<T>.get_Queue();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    [AsyncStateMachineAttribute("Foundatio.Jobs.QueueJobBase`1/<RunAsync>d__19")]
public virtual Task`1<JobResult> RunAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Jobs.QueueJobBase`1/<ProcessAsync>d__20")]
public sealed virtual Task`1<JobResult> ProcessAsync(IQueueEntry`1<T> queueEntry, CancellationToken cancellationToken);
    protected virtual Activity StartProcessQueueEntryActivity(IQueueEntry`1<T> entry);
    protected virtual void EnrichProcessQueueEntryActivity(Activity activity, IQueueEntry`1<T> entry);
    protected virtual void LogProcessingQueueEntry(IQueueEntry`1<T> queueEntry);
    protected virtual void LogAutoCompletedQueueEntry(IQueueEntry`1<T> queueEntry);
    protected abstract virtual Task`1<JobResult> ProcessQueueEntryAsync(QueueEntryContext`1<T> context);
    protected virtual Task`1<ILock> GetQueueEntryLockAsync(IQueueEntry`1<T> queueEntry, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Foundatio.Jobs.QueueJobExtensions : object {
    [AsyncStateMachineAttribute("Foundatio.Jobs.QueueJobExtensions/<RunUntilEmptyAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<int> RunUntilEmptyAsync(IQueueJob`1<T> job, TimeSpan waitTimeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> RunUntilEmptyAsync(IQueueJob`1<T> job, CancellationToken cancellationToken);
}
public class Foundatio.Jobs.WorkItemContext : object {
    private Func`3<int, string, Task> _progressCallback;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private ILock <WorkItemLock>k__BackingField;
    [CompilerGeneratedAttribute]
private JobResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public object Data { get; private set; }
    public string JobId { get; private set; }
    public ILock WorkItemLock { get; private set; }
    public JobResult Result { get; public set; }
    public CancellationToken CancellationToken { get; private set; }
    public WorkItemContext(object data, string jobId, ILock workItemLock, CancellationToken cancellationToken, Func`3<int, string, Task> progressCallback);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(object value);
    [CompilerGeneratedAttribute]
public string get_JobId();
    [CompilerGeneratedAttribute]
private void set_JobId(string value);
    [CompilerGeneratedAttribute]
public ILock get_WorkItemLock();
    [CompilerGeneratedAttribute]
private void set_WorkItemLock(ILock value);
    [CompilerGeneratedAttribute]
public JobResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(JobResult value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
private void set_CancellationToken(CancellationToken value);
    public Task ReportProgressAsync(int progress, string message);
    public Task RenewLockAsync();
    public T GetData();
}
public class Foundatio.Jobs.WorkItemData : object {
    [CompilerGeneratedAttribute]
private string <WorkItemId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendProgressReports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubMetricName>k__BackingField;
    public string WorkItemId { get; public set; }
    public string Type { get; public set; }
    public Byte[] Data { get; public set; }
    public bool SendProgressReports { get; public set; }
    public string UniqueIdentifier { get; public set; }
    public string SubMetricName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WorkItemId();
    [CompilerGeneratedAttribute]
public void set_WorkItemId(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_SendProgressReports();
    [CompilerGeneratedAttribute]
public void set_SendProgressReports(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UniqueIdentifier();
    [CompilerGeneratedAttribute]
public void set_UniqueIdentifier(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SubMetricName();
    [CompilerGeneratedAttribute]
public void set_SubMetricName(string value);
}
public abstract class Foundatio.Jobs.WorkItemHandlerBase : object {
    [CompilerGeneratedAttribute]
private bool <AutoRenewLockOnProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    public bool AutoRenewLockOnProgress { get; public set; }
    public ILogger Log { get; public set; }
    public WorkItemHandlerBase(ILoggerFactory loggerFactory);
    public WorkItemHandlerBase(ILogger logger);
    public virtual Task`1<ILock> GetWorkItemLockAsync(object workItem, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoRenewLockOnProgress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AutoRenewLockOnProgress(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Log(ILogger value);
    public virtual void LogProcessingQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
    public virtual void LogAutoCompletedQueueEntry(IQueueEntry`1<WorkItemData> queueEntry, Type workItemDataType, object workItem);
    public abstract virtual Task HandleItemAsync(WorkItemContext context);
    protected int CalculateProgress(long total, long completed, int startProgress, int endProgress);
}
public class Foundatio.Jobs.WorkItemHandlers : object {
    private ConcurrentDictionary`2<Type, Lazy`1<IWorkItemHandler>> _handlers;
    public void Register(IWorkItemHandler handler);
    public void Register(Func`1<IWorkItemHandler> handler);
    public void Register(Func`2<WorkItemContext, Task> handler, ILogger logger, Action`3<IQueueEntry`1<WorkItemData>, Type, object> logProcessingWorkItem, Action`3<IQueueEntry`1<WorkItemData>, Type, object> logAutoCompletedWorkItem);
    public IWorkItemHandler GetHandler(Type jobDataType);
}
[JobAttribute]
public class Foundatio.Jobs.WorkItemJob : object {
    protected IMessagePublisher _publisher;
    protected WorkItemHandlers _handlers;
    protected IQueue`1<WorkItemData> _queue;
    protected ILogger _logger;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    private ConcurrentDictionary`2<string, Type> _knownTypesCache;
    public string JobId { get; }
    private IQueue`1<WorkItemData> Foundatio.Jobs.IQueueJob<Foundatio.Jobs.WorkItemData>.Queue { get; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    public WorkItemJob(IQueue`1<WorkItemData> queue, IMessagePublisher publisher, WorkItemHandlers handlers, ILoggerFactory loggerFactory);
    [CompilerGeneratedAttribute]
public string get_JobId();
    private sealed virtual override IQueue`1<WorkItemData> Foundatio.Jobs.IQueueJob<Foundatio.Jobs.WorkItemData>.get_Queue();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    [AsyncStateMachineAttribute("Foundatio.Jobs.WorkItemJob/<RunAsync>d__12")]
public virtual Task`1<JobResult> RunAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Jobs.WorkItemJob/<ProcessAsync>d__13")]
public sealed virtual Task`1<JobResult> ProcessAsync(IQueueEntry`1<WorkItemData> queueEntry, CancellationToken cancellationToken);
    protected virtual Activity StartProcessWorkItemActivity(IQueueEntry`1<WorkItemData> entry, Type workItemDataType);
    protected virtual void EnrichProcessWorkItemActivity(Activity activity, IQueueEntry`1<WorkItemData> entry, Type workItemDataType);
    protected virtual Type GetWorkItemType(string workItemType);
    [AsyncStateMachineAttribute("Foundatio.Jobs.WorkItemJob/<ReportProgressAsync>d__18")]
protected Task ReportProgressAsync(IWorkItemHandler handler, IQueueEntry`1<WorkItemData> queueEntry, int progress, string message);
    [CompilerGeneratedAttribute]
private Type <GetWorkItemType>b__17_0(string type);
}
[ExtensionAttribute]
public static class Foundatio.Jobs.WorkItemQueueExtensions : object {
    [AsyncStateMachineAttribute("Foundatio.Jobs.WorkItemQueueExtensions/<EnqueueAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<string> EnqueueAsync(IQueue`1<WorkItemData> queue, T workItemData, bool includeProgressReporting);
    private static string GetDefaultSubMetricName(WorkItemData data);
    private static string GetTypeName(string assemblyQualifiedName);
}
public class Foundatio.Jobs.WorkItemStatus : object {
    [CompilerGeneratedAttribute]
private string <WorkItemId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string WorkItemId { get; public set; }
    public int Progress { get; public set; }
    public string Message { get; public set; }
    public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WorkItemId();
    [CompilerGeneratedAttribute]
public void set_WorkItemId(string value);
    [CompilerGeneratedAttribute]
public int get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(int value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
}
public class Foundatio.Lock.CacheLockProvider : object {
    private ICacheClient _cacheClient;
    private IMessageBus _messageBus;
    private TimeProvider _timeProvider;
    private ConcurrentDictionary`2<string, ResetEventWithRefCount> _autoResetEvents;
    private AsyncLock _lock;
    private bool _isSubscribed;
    private ILogger _logger;
    private Histogram`1<double> _lockWaitTimeHistogram;
    private Counter`1<int> _lockTimeoutCounter;
    private static string _allowedChars;
    private static Random _rng;
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public CacheLockProvider(ICacheClient cacheClient, IMessageBus messageBus, ILoggerFactory loggerFactory);
    public CacheLockProvider(ICacheClient cacheClient, IMessageBus messageBus, TimeProvider timeProvider, ILoggerFactory loggerFactory);
    private static CacheLockProvider();
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    [AsyncStateMachineAttribute("Foundatio.Lock.CacheLockProvider/<EnsureTopicSubscriptionAsync>d__15")]
private Task EnsureTopicSubscriptionAsync();
    private Task OnLockReleasedAsync(CacheLockReleased msg, CancellationToken cancellationToken);
    protected virtual Activity StartLockActivity(string resource);
    [AsyncStateMachineAttribute("Foundatio.Lock.CacheLockProvider/<AcquireAsync>d__18")]
public sealed virtual Task`1<ILock> AcquireAsync(string resource, Nullable`1<TimeSpan> timeUntilExpires, bool releaseOnDispose, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.CacheLockProvider/<IsLockedAsync>d__19")]
public sealed virtual Task`1<bool> IsLockedAsync(string resource);
    [AsyncStateMachineAttribute("Foundatio.Lock.CacheLockProvider/<ReleaseAsync>d__20")]
public sealed virtual Task ReleaseAsync(string resource, string lockId);
    public sealed virtual Task RenewAsync(string resource, string lockId, Nullable`1<TimeSpan> timeUntilExpires);
    private string GenerateNewLockId();
}
public class Foundatio.Lock.CacheLockReleased : object {
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockId>k__BackingField;
    public string Resource { get; public set; }
    public string LockId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_LockId();
    [CompilerGeneratedAttribute]
public void set_LockId(string value);
}
internal class Foundatio.Lock.DisposableLock : object {
    private ILockProvider _lockProvider;
    private ILogger _logger;
    private bool _isReleased;
    private int _renewalCount;
    private AsyncLock _lock;
    private Stopwatch _duration;
    private bool _shouldReleaseOnDispose;
    [CompilerGeneratedAttribute]
private string <LockId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AcquiredTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeWaitedForLock>k__BackingField;
    public string LockId { get; }
    public string Resource { get; }
    public DateTime AcquiredTimeUtc { get; }
    public TimeSpan TimeWaitedForLock { get; }
    public int RenewalCount { get; }
    public DisposableLock(string resource, string lockId, TimeSpan timeWaitedForLock, ILockProvider lockProvider, ILogger logger, bool shouldReleaseOnDispose);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LockId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Resource();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_AcquiredTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TimeWaitedForLock();
    public sealed virtual int get_RenewalCount();
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLock/<DisposeAsync>d__22")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLock/<RenewAsync>d__23")]
public sealed virtual Task RenewAsync(Nullable`1<TimeSpan> timeUntilExpires);
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLock/<ReleaseAsync>d__24")]
public sealed virtual Task ReleaseAsync();
}
internal class Foundatio.Lock.DisposableLockCollection : object {
    private List`1<ILock> _locks;
    private ILogger _logger;
    private bool _isReleased;
    private int _renewalCount;
    private AsyncLock _lock;
    private Stopwatch _duration;
    [CompilerGeneratedAttribute]
private string <LockId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AcquiredTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeWaitedForLock>k__BackingField;
    public IReadOnlyCollection`1<ILock> Locks { get; }
    public string LockId { get; }
    public string Resource { get; }
    public DateTime AcquiredTimeUtc { get; }
    public TimeSpan TimeWaitedForLock { get; }
    public int RenewalCount { get; }
    public DisposableLockCollection(IEnumerable`1<ILock> locks, string lockId, DateTime acquiredTimeUtc, TimeSpan timeWaitedForLock, ILogger logger);
    public IReadOnlyCollection`1<ILock> get_Locks();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LockId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Resource();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_AcquiredTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TimeWaitedForLock();
    public sealed virtual int get_RenewalCount();
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLockCollection/<RenewAsync>d__23")]
public sealed virtual Task RenewAsync(Nullable`1<TimeSpan> lockExtension);
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLockCollection/<ReleaseAsync>d__24")]
public sealed virtual Task ReleaseAsync();
    [AsyncStateMachineAttribute("Foundatio.Lock.DisposableLockCollection/<DisposeAsync>d__25")]
public sealed virtual ValueTask DisposeAsync();
}
public interface Foundatio.Lock.ILock {
    public string LockId { get; }
    public string Resource { get; }
    public DateTime AcquiredTimeUtc { get; }
    public TimeSpan TimeWaitedForLock { get; }
    public int RenewalCount { get; }
    public abstract virtual Task RenewAsync(Nullable`1<TimeSpan> timeUntilExpires);
    public abstract virtual Task ReleaseAsync();
    public abstract virtual string get_LockId();
    public abstract virtual string get_Resource();
    public abstract virtual DateTime get_AcquiredTimeUtc();
    public abstract virtual TimeSpan get_TimeWaitedForLock();
    public abstract virtual int get_RenewalCount();
}
public interface Foundatio.Lock.ILockProvider {
    public abstract virtual Task`1<ILock> AcquireAsync(string resource, Nullable`1<TimeSpan> timeUntilExpires, bool releaseOnDispose, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsLockedAsync(string resource);
    public abstract virtual Task ReleaseAsync(string resource, string lockId);
    public abstract virtual Task RenewAsync(string resource, string lockId, Nullable`1<TimeSpan> timeUntilExpires);
}
[ExtensionAttribute]
public static class Foundatio.Lock.LockProviderExtensions : object {
    [ExtensionAttribute]
public static Task ReleaseAsync(ILockProvider provider, ILock lock);
    [ExtensionAttribute]
public static Task RenewAsync(ILockProvider provider, ILock lock, Nullable`1<TimeSpan> timeUntilExpires);
    [ExtensionAttribute]
public static Task`1<ILock> AcquireAsync(ILockProvider provider, string resource, Nullable`1<TimeSpan> timeUntilExpires, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<AcquireAsync>d__3")]
[ExtensionAttribute]
public static Task`1<ILock> AcquireAsync(ILockProvider provider, string resource, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__4")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, string resource, Func`2<CancellationToken, Task> work, Nullable`1<TimeSpan> timeUntilExpires, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__5")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, string resource, Func`1<Task> work, Nullable`1<TimeSpan> timeUntilExpires, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__6")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, string resource, Func`2<CancellationToken, Task> work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__7")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, string resource, Func`1<Task> work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, string resource, Action work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<AcquireAsync>d__9")]
[ExtensionAttribute]
public static Task`1<ILock> AcquireAsync(ILockProvider provider, IEnumerable`1<string> resources, Nullable`1<TimeSpan> timeUntilExpires, bool releaseOnDispose, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<AcquireAsync>d__10")]
[ExtensionAttribute]
public static Task`1<ILock> AcquireAsync(ILockProvider provider, IEnumerable`1<string> resources, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<AcquireAsync>d__11")]
[ExtensionAttribute]
public static Task`1<ILock> AcquireAsync(ILockProvider provider, IEnumerable`1<string> resources, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout, bool releaseOnDispose);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__12")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, IEnumerable`1<string> resources, Func`2<CancellationToken, Task> work, Nullable`1<TimeSpan> timeUntilExpires, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__13")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, IEnumerable`1<string> resources, Func`1<Task> work, Nullable`1<TimeSpan> timeUntilExpires, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__14")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, IEnumerable`1<string> resources, Func`2<CancellationToken, Task> work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [AsyncStateMachineAttribute("Foundatio.Lock.LockProviderExtensions/<TryUsingAsync>d__15")]
[ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, IEnumerable`1<string> resources, Func`1<Task> work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
    [ExtensionAttribute]
public static Task`1<bool> TryUsingAsync(ILockProvider locker, IEnumerable`1<string> resources, Action work, Nullable`1<TimeSpan> timeUntilExpires, Nullable`1<TimeSpan> acquireTimeout);
}
public class Foundatio.Lock.ScopedLockProvider : object {
    private string _keyPrefix;
    private bool _isLocked;
    private object _lock;
    [CompilerGeneratedAttribute]
private ILockProvider <UnscopedLockProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    public ILockProvider UnscopedLockProvider { get; }
    public string Scope { get; private set; }
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    public ScopedLockProvider(ILockProvider lockProvider, string scope);
    [CompilerGeneratedAttribute]
public ILockProvider get_UnscopedLockProvider();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(string value);
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    public void SetScope(string scope);
    protected string GetScopedLockProviderKey(string key);
    public sealed virtual Task`1<ILock> AcquireAsync(string resource, Nullable`1<TimeSpan> timeUntilExpires, bool releaseOnDispose, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> IsLockedAsync(string resource);
    public sealed virtual Task ReleaseAsync(string resource, string lockId);
    public sealed virtual Task RenewAsync(string resource, string lockId, Nullable`1<TimeSpan> timeUntilExpires);
}
public class Foundatio.Lock.ThrottlingLockProvider : object {
    private ICacheClient _cacheClient;
    private TimeSpan _throttlingPeriod;
    private int _maxHitsPerPeriod;
    private ILogger _logger;
    private TimeProvider _timeProvider;
    private ILogger Foundatio.Utility.IHaveLogger.Logger { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public ThrottlingLockProvider(ICacheClient cacheClient, int maxHitsPerPeriod, Nullable`1<TimeSpan> throttlingPeriod, TimeProvider timeProvider, ILoggerFactory loggerFactory);
    private sealed virtual override ILogger Foundatio.Utility.IHaveLogger.get_Logger();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    [AsyncStateMachineAttribute("Foundatio.Lock.ThrottlingLockProvider/<AcquireAsync>d__10")]
public sealed virtual Task`1<ILock> AcquireAsync(string resource, Nullable`1<TimeSpan> timeUntilExpires, bool releaseOnDispose, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Lock.ThrottlingLockProvider/<IsLockedAsync>d__11")]
public sealed virtual Task`1<bool> IsLockedAsync(string resource);
    public sealed virtual Task ReleaseAsync(string resource, string lockId);
    public sealed virtual Task RenewAsync(string resource, string lockId, Nullable`1<TimeSpan> timeUntilExpires);
    private string GetCacheKey(string resource, DateTime now);
}
public interface Foundatio.Messaging.IMessage {
    public string UniqueId { get; }
    public string CorrelationId { get; }
    public string Type { get; }
    public Type ClrType { get; }
    public Byte[] Data { get; }
    public IDictionary`2<string, string> Properties { get; }
    public abstract virtual string get_UniqueId();
    public abstract virtual string get_CorrelationId();
    public abstract virtual string get_Type();
    public abstract virtual Type get_ClrType();
    public abstract virtual Byte[] get_Data();
    public abstract virtual object GetBody();
    public abstract virtual IDictionary`2<string, string> get_Properties();
}
public interface Foundatio.Messaging.IMessage`1 {
    public T Body { get; }
    public abstract virtual T get_Body();
}
public interface Foundatio.Messaging.IMessageBus {
}
public interface Foundatio.Messaging.IMessagePublisher {
    public abstract virtual Task PublishAsync(Type messageType, object message, MessageOptions options, CancellationToken cancellationToken);
}
public interface Foundatio.Messaging.IMessageSubscriber {
    public abstract virtual Task SubscribeAsync(Func`3<T, CancellationToken, Task> handler, CancellationToken cancellationToken);
}
public class Foundatio.Messaging.InMemoryMessageBus : MessageBusBase`1<InMemoryMessageBusOptions> {
    private ConcurrentDictionary`2<string, long> _messageCounts;
    private long _messagesSent;
    public long MessagesSent { get; }
    public InMemoryMessageBus(InMemoryMessageBusOptions options);
    public InMemoryMessageBus(Builder`2<InMemoryMessageBusOptionsBuilder, InMemoryMessageBusOptions> config);
    public long get_MessagesSent();
    public long GetMessagesSent(Type messageType);
    public long GetMessagesSent();
    public void ResetMessagesSent();
    [AsyncStateMachineAttribute("Foundatio.Messaging.InMemoryMessageBus/<PublishImplAsync>d__10")]
protected virtual Task PublishImplAsync(string messageType, object message, MessageOptions options, CancellationToken cancellationToken);
}
public class Foundatio.Messaging.InMemoryMessageBusOptions : SharedMessageBusOptions {
}
public class Foundatio.Messaging.InMemoryMessageBusOptionsBuilder : SharedMessageBusOptionsBuilder`2<InMemoryMessageBusOptions, InMemoryMessageBusOptionsBuilder> {
}
[DebuggerDisplayAttribute("Type: {Type}")]
public class Foundatio.Messaging.Message : object {
    private Func`2<IMessage, object> _getBody;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public string UniqueId { get; public set; }
    public string CorrelationId { get; public set; }
    public string Type { get; public set; }
    public Type ClrType { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    public Byte[] Data { get; public set; }
    public Message(Byte[] data, Func`2<IMessage, object> getBody);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ClrType();
    [CompilerGeneratedAttribute]
public void set_ClrType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    public sealed virtual object GetBody();
}
public class Foundatio.Messaging.Message`1 : object {
    private IMessage _message;
    public Byte[] Data { get; }
    public T Body { get; }
    public string UniqueId { get; }
    public string CorrelationId { get; }
    public string Type { get; }
    public Type ClrType { get; }
    public IDictionary`2<string, string> Properties { get; }
    public Message`1(IMessage message);
    public sealed virtual Byte[] get_Data();
    public sealed virtual T get_Body();
    public sealed virtual string get_UniqueId();
    public sealed virtual string get_CorrelationId();
    public sealed virtual string get_Type();
    public sealed virtual Type get_ClrType();
    public sealed virtual IDictionary`2<string, string> get_Properties();
    public sealed virtual object GetBody();
}
public abstract class Foundatio.Messaging.MessageBusBase`1 : object {
    private CancellationTokenSource _messageBusDisposedCancellationTokenSource;
    protected ConcurrentDictionary`2<string, Subscriber<TOptions>> _subscribers;
    protected TOptions _options;
    protected ILogger _logger;
    protected TimeProvider _timeProvider;
    protected ISerializer _serializer;
    private bool _isDisposed;
    private ConcurrentDictionary`2<Type, string> _mappedMessageTypesCache;
    private ConcurrentDictionary`2<string, Type> _knownMessageTypesCache;
    [CompilerGeneratedAttribute]
private string <MessageBusId>k__BackingField;
    public string MessageBusId { get; protected set; }
    public MessageBusBase`1(TOptions options);
    protected virtual Task EnsureTopicCreatedAsync(CancellationToken cancellationToken);
    protected abstract virtual Task PublishImplAsync(string messageType, object message, MessageOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Messaging.MessageBusBase`1/<PublishAsync>d__10")]
public sealed virtual Task PublishAsync(Type messageType, object message, MessageOptions options, CancellationToken cancellationToken);
    protected string GetMappedMessageType(Type messageType);
    protected virtual Type GetMappedMessageType(string messageType);
    protected virtual Task RemoveTopicSubscriptionAsync();
    protected virtual Task EnsureTopicSubscriptionAsync(CancellationToken cancellationToken);
    protected virtual Task SubscribeImplAsync(Func`3<T, CancellationToken, Task> handler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Messaging.MessageBusBase`1/<SubscribeAsync>d__18`1")]
public sealed virtual Task SubscribeAsync(Func`3<T, CancellationToken, Task> handler, CancellationToken cancellationToken);
    protected List`1<Subscriber<TOptions>> GetMessageSubscribers(IMessage message);
    protected virtual bool SubscriberHandlesMessage(Subscriber<TOptions> subscriber, IMessage message);
    protected virtual Byte[] SerializeMessageBody(string messageType, object body);
    protected virtual object DeserializeMessageBody(IMessage message);
    [AsyncStateMachineAttribute("Foundatio.Messaging.MessageBusBase`1/<SendMessageToSubscribersAsync>d__23")]
protected Task SendMessageToSubscribersAsync(IMessage message);
    protected virtual Activity StartHandleMessageActivity(IMessage message);
    protected virtual void EnrichHandleMessageActivity(Activity activity, IMessage message);
    protected Task AddDelayedMessageAsync(Type messageType, object message, TimeSpan delay);
    protected void SendDelayedMessage(Type messageType, object message, TimeSpan delay);
    [CompilerGeneratedAttribute]
public string get_MessageBusId();
    [CompilerGeneratedAttribute]
protected void set_MessageBusId(string value);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private Type <GetMappedMessageType>b__14_0(string type);
}
[ExtensionAttribute]
public static class Foundatio.Messaging.MessageBusExtensions : object {
    [ExtensionAttribute]
public static Task SubscribeAsync(IMessageSubscriber subscriber, Func`2<T, Task> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SubscribeAsync(IMessageSubscriber subscriber, Action`1<T> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SubscribeAsync(IMessageSubscriber subscriber, Func`3<IMessage, CancellationToken, Task> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SubscribeAsync(IMessageSubscriber subscriber, Func`2<IMessage, Task> handler, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SubscribeAsync(IMessageSubscriber subscriber, Action`1<IMessage> handler, CancellationToken cancellationToken);
}
public class Foundatio.Messaging.MessageOptions : object {
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <DeliveryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string UniqueId { get; public set; }
    public string CorrelationId { get; public set; }
    public Nullable`1<TimeSpan> DeliveryDelay { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_DeliveryDelay();
    [CompilerGeneratedAttribute]
public void set_DeliveryDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
}
[ExtensionAttribute]
public static class Foundatio.Messaging.MessagePublisherExtensions : object {
    [ExtensionAttribute]
public static Task PublishAsync(IMessagePublisher publisher, T message, MessageOptions options);
    [ExtensionAttribute]
public static Task PublishAsync(IMessagePublisher publisher, T message, TimeSpan delay, CancellationToken cancellationToken);
}
public class Foundatio.Messaging.NullMessageBus : object {
    public static NullMessageBus Instance;
    private static NullMessageBus();
    public sealed virtual Task PublishAsync(Type messageType, object message, MessageOptions options, CancellationToken cancellationToken);
    public sealed virtual Task SubscribeAsync(Func`3<T, CancellationToken, Task> handler, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class Foundatio.Messaging.SharedMessageBusOptions : SharedOptions {
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <MessageTypeMappings>k__BackingField;
    public string Topic { get; public set; }
    public Dictionary`2<string, Type> MessageTypeMappings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_MessageTypeMappings();
    [CompilerGeneratedAttribute]
public void set_MessageTypeMappings(Dictionary`2<string, Type> value);
}
public class Foundatio.Messaging.SharedMessageBusOptionsBuilder`2 : SharedOptionsBuilder`2<TOptions, TBuilder> {
    public TBuilder Topic(string topic);
    public TBuilder MapMessageType(string name);
    public TBuilder MapMessageTypeToClassName();
}
public interface Foundatio.Metrics.IHaveSubMetricName {
    public string SubMetricName { get; }
    public abstract virtual string get_SubMetricName();
}
public class Foundatio.OptionsBuilder`1 : object {
    [CompilerGeneratedAttribute]
private T <Target>k__BackingField;
    public T Target { get; }
    private object Foundatio.IOptionsBuilder.Target { get; }
    [CompilerGeneratedAttribute]
public T get_Target();
    private sealed virtual override object Foundatio.IOptionsBuilder.get_Target();
    public virtual T Build();
}
[ExtensionAttribute]
public static class Foundatio.OptionsBuilderExtensions : object {
    [ExtensionAttribute]
public static T Target(IOptionsBuilder builder);
}
public class Foundatio.Queues.AbandonedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <Entry>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public IQueueEntry`1<T> Entry { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(IQueueEntry`1<T> value);
}
public class Foundatio.Queues.CompletedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <Entry>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public IQueueEntry`1<T> Entry { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(IQueueEntry`1<T> value);
}
public class Foundatio.Queues.DequeuedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <Entry>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public IQueueEntry`1<T> Entry { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(IQueueEntry`1<T> value);
}
public class Foundatio.Queues.DuplicateDetectionQueueBehavior`1 : QueueBehaviorBase`1<T> {
    private ICacheClient _cacheClient;
    private ILoggerFactory _loggerFactory;
    private TimeSpan _detectionWindow;
    public DuplicateDetectionQueueBehavior`1(ICacheClient cacheClient, ILoggerFactory loggerFactory, Nullable`1<TimeSpan> detectionWindow);
    [AsyncStateMachineAttribute("Foundatio.Queues.DuplicateDetectionQueueBehavior`1/<OnEnqueuing>d__4")]
protected virtual Task OnEnqueuing(object sender, EnqueuingEventArgs`1<T> enqueuingEventArgs);
    [AsyncStateMachineAttribute("Foundatio.Queues.DuplicateDetectionQueueBehavior`1/<OnDequeued>d__5")]
protected virtual Task OnDequeued(object sender, DequeuedEventArgs`1<T> dequeuedEventArgs);
    private string GetUniqueIdentifier(T data);
}
public class Foundatio.Queues.EnqueuedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <Entry>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public IQueueEntry`1<T> Entry { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(IQueueEntry`1<T> value);
}
public class Foundatio.Queues.EnqueuingEventArgs`1 : CancelEventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueEntryOptions <Options>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public T Data { get; public set; }
    public QueueEntryOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public T get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(T value);
    [CompilerGeneratedAttribute]
public QueueEntryOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(QueueEntryOptions value);
}
public interface Foundatio.Queues.IHaveUniqueIdentifier {
    public string UniqueIdentifier { get; }
    public abstract virtual string get_UniqueIdentifier();
}
public class Foundatio.Queues.InMemoryQueue`1 : QueueBase`2<T, InMemoryQueueOptions`1<T>> {
    private ConcurrentQueue`1<QueueEntry`1<T>> _queue;
    private ConcurrentDictionary`2<string, QueueEntry`1<T>> _dequeued;
    private ConcurrentQueue`1<QueueEntry`1<T>> _deadletterQueue;
    private ConcurrentQueue`1<QueueEntry`1<T>> _completedQueue;
    private AsyncAutoResetEvent _autoResetEvent;
    private int _enqueuedCount;
    private int _dequeuedCount;
    private int _completedCount;
    private int _abandonedCount;
    private int _workerErrorCount;
    private int _workerItemTimeoutCount;
    private List`1<Task> _workers;
    public InMemoryQueue`1(InMemoryQueueOptions`1<T> options);
    public InMemoryQueue`1(Builder`2<InMemoryQueueOptionsBuilder`1<T>, InMemoryQueueOptions`1<T>> config);
    protected virtual Task EnsureQueueCreatedAsync(CancellationToken cancellationToken);
    protected virtual Task`1<QueueStats> GetQueueStatsImplAsync();
    protected virtual QueueStats GetMetricsQueueStats();
    public IReadOnlyCollection`1<QueueEntry`1<T>> GetEntries();
    public IReadOnlyCollection`1<QueueEntry`1<T>> GetDequeuedEntries();
    public IReadOnlyCollection`1<QueueEntry`1<T>> GetCompletedEntries();
    public IReadOnlyCollection`1<QueueEntry`1<T>> GetDeadletterEntries();
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<EnqueueImplAsync>d__21")]
protected virtual Task`1<string> EnqueueImplAsync(T data, QueueEntryOptions options);
    protected virtual void StartWorkingImpl(Func`3<IQueueEntry`1<T>, CancellationToken, Task> handler, bool autoComplete, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<DequeueImplAsync>d__24")]
protected virtual Task`1<IQueueEntry`1<T>> DequeueImplAsync(CancellationToken linkedCancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<RenewLockAsync>d__25")]
public virtual Task RenewLockAsync(IQueueEntry`1<T> queueEntry);
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<CompleteAsync>d__26")]
public virtual Task CompleteAsync(IQueueEntry`1<T> queueEntry);
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<AbandonAsync>d__27")]
public virtual Task AbandonAsync(IQueueEntry`1<T> queueEntry);
    private Task RetryAsync(QueueEntry`1<T> entry);
    private TimeSpan GetRetryDelay(int attempts);
    protected virtual Task`1<IEnumerable`1<T>> GetDeadletterItemsImplAsync(CancellationToken cancellationToken);
    public virtual Task DeleteQueueAsync();
    [AsyncStateMachineAttribute("Foundatio.Queues.InMemoryQueue`1/<DoMaintenanceAsync>d__32")]
protected virtual Task`1<Nullable`1<DateTime>> DoMaintenanceAsync();
    public virtual void Dispose();
}
public class Foundatio.Queues.InMemoryQueueOptions`1 : SharedQueueOptions`1<T> {
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompletedEntryRetentionLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <RetryMultipliers>k__BackingField;
    public TimeSpan RetryDelay { get; public set; }
    public int CompletedEntryRetentionLimit { get; public set; }
    public Int32[] RetryMultipliers { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_CompletedEntryRetentionLimit();
    [CompilerGeneratedAttribute]
public void set_CompletedEntryRetentionLimit(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_RetryMultipliers();
    [CompilerGeneratedAttribute]
public void set_RetryMultipliers(Int32[] value);
}
public class Foundatio.Queues.InMemoryQueueOptionsBuilder`1 : SharedQueueOptionsBuilder`3<T, InMemoryQueueOptions`1<T>, InMemoryQueueOptionsBuilder`1<T>> {
    public InMemoryQueueOptionsBuilder`1<T> RetryDelay(TimeSpan retryDelay);
    public InMemoryQueueOptionsBuilder`1<T> CompletedEntryRetentionLimit(int retentionCount);
    public InMemoryQueueOptionsBuilder`1<T> RetryMultipliers(Int32[] multipliers);
}
public interface Foundatio.Queues.IQueue {
    public string QueueId { get; }
    public abstract virtual Task`1<QueueStats> GetQueueStatsAsync();
    public abstract virtual Task DeleteQueueAsync();
    public abstract virtual string get_QueueId();
}
public interface Foundatio.Queues.IQueue`1 {
    public AsyncEvent`1<EnqueuingEventArgs`1<T>> Enqueuing { get; }
    public AsyncEvent`1<EnqueuedEventArgs`1<T>> Enqueued { get; }
    public AsyncEvent`1<DequeuedEventArgs`1<T>> Dequeued { get; }
    public AsyncEvent`1<LockRenewedEventArgs`1<T>> LockRenewed { get; }
    public AsyncEvent`1<CompletedEventArgs`1<T>> Completed { get; }
    public AsyncEvent`1<AbandonedEventArgs`1<T>> Abandoned { get; }
    public abstract virtual AsyncEvent`1<EnqueuingEventArgs`1<T>> get_Enqueuing();
    public abstract virtual AsyncEvent`1<EnqueuedEventArgs`1<T>> get_Enqueued();
    public abstract virtual AsyncEvent`1<DequeuedEventArgs`1<T>> get_Dequeued();
    public abstract virtual AsyncEvent`1<LockRenewedEventArgs`1<T>> get_LockRenewed();
    public abstract virtual AsyncEvent`1<CompletedEventArgs`1<T>> get_Completed();
    public abstract virtual AsyncEvent`1<AbandonedEventArgs`1<T>> get_Abandoned();
    public abstract virtual void AttachBehavior(IQueueBehavior`1<T> behavior);
    public abstract virtual Task`1<string> EnqueueAsync(T data, QueueEntryOptions options);
    public abstract virtual Task`1<IQueueEntry`1<T>> DequeueAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IQueueEntry`1<T>> DequeueAsync(Nullable`1<TimeSpan> timeout);
    public abstract virtual Task RenewLockAsync(IQueueEntry`1<T> queueEntry);
    public abstract virtual Task CompleteAsync(IQueueEntry`1<T> queueEntry);
    public abstract virtual Task AbandonAsync(IQueueEntry`1<T> queueEntry);
    public abstract virtual Task`1<IEnumerable`1<T>> GetDeadletterItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task StartWorkingAsync(Func`3<IQueueEntry`1<T>, CancellationToken, Task> handler, bool autoComplete, CancellationToken cancellationToken);
}
public interface Foundatio.Queues.IQueueActivity {
    public Nullable`1<DateTimeOffset> LastEnqueueActivity { get; }
    public Nullable`1<DateTimeOffset> LastDequeueActivity { get; }
    public abstract virtual Nullable`1<DateTimeOffset> get_LastEnqueueActivity();
    public abstract virtual Nullable`1<DateTimeOffset> get_LastDequeueActivity();
}
public interface Foundatio.Queues.IQueueBehavior`1 {
    public abstract virtual void Attach(IQueue`1<T> queue);
}
public interface Foundatio.Queues.IQueueEntry {
    public string Id { get; }
    public string CorrelationId { get; }
    public IDictionary`2<string, string> Properties { get; }
    public Type EntryType { get; }
    public bool IsCompleted { get; }
    public bool IsAbandoned { get; }
    public int Attempts { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_CorrelationId();
    public abstract virtual IDictionary`2<string, string> get_Properties();
    public abstract virtual Type get_EntryType();
    public abstract virtual object GetValue();
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool get_IsAbandoned();
    public abstract virtual int get_Attempts();
    public abstract virtual void MarkAbandoned();
    public abstract virtual void MarkCompleted();
    public abstract virtual Task RenewLockAsync();
    public abstract virtual Task AbandonAsync();
    public abstract virtual Task CompleteAsync();
    public abstract virtual ValueTask DisposeAsync();
}
public interface Foundatio.Queues.IQueueEntry`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
public interface Foundatio.Queues.IQueueEntryMetadata {
    public string Id { get; }
    public string CorrelationId { get; }
    public IDictionary`2<string, string> Properties { get; }
    public DateTime EnqueuedTimeUtc { get; }
    public DateTime RenewedTimeUtc { get; }
    public DateTime DequeuedTimeUtc { get; }
    public int Attempts { get; }
    public TimeSpan ProcessingTime { get; }
    public TimeSpan TotalTime { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_CorrelationId();
    public abstract virtual IDictionary`2<string, string> get_Properties();
    public abstract virtual DateTime get_EnqueuedTimeUtc();
    public abstract virtual DateTime get_RenewedTimeUtc();
    public abstract virtual DateTime get_DequeuedTimeUtc();
    public abstract virtual int get_Attempts();
    public abstract virtual TimeSpan get_ProcessingTime();
    public abstract virtual TimeSpan get_TotalTime();
}
public class Foundatio.Queues.LockRenewedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IQueue`1<T> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueEntry`1<T> <Entry>k__BackingField;
    public IQueue`1<T> Queue { get; public set; }
    public IQueueEntry`1<T> Entry { get; public set; }
    [CompilerGeneratedAttribute]
public IQueue`1<T> get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IQueue`1<T> value);
    [CompilerGeneratedAttribute]
public IQueueEntry`1<T> get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(IQueueEntry`1<T> value);
}
public abstract class Foundatio.Queues.QueueBase`2 : MaintenanceBase {
    protected TOptions _options;
    private string _metricsPrefix;
    protected ISerializer _serializer;
    private Counter`1<long> _enqueuedCounter;
    private Counter`1<long> _dequeuedCounter;
    private Histogram`1<double> _queueTimeHistogram;
    private Counter`1<long> _completedCounter;
    private Histogram`1<double> _processTimeHistogram;
    private Histogram`1<double> _totalTimeHistogram;
    private Counter`1<long> _abandonedCounter;
    private ObservableGauge`1<long> _countGauge;
    private ObservableGauge`1<long> _workingGauge;
    private ObservableGauge`1<long> _deadletterGauge;
    private TagList _emptyTags;
    private List`1<IQueueBehavior`1<T>> _behaviors;
    protected CancellationTokenSource _queueDisposedCancellationTokenSource;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private string <QueueId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastEnqueueActivity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastDequeueActivity>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<EnqueuingEventArgs`1<T>> <Enqueuing>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<EnqueuedEventArgs`1<T>> <Enqueued>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<DequeuedEventArgs`1<T>> <Dequeued>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<LockRenewedEventArgs`1<T>> <LockRenewed>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<CompletedEventArgs`1<T>> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncEvent`1<AbandonedEventArgs`1<T>> <Abandoned>k__BackingField;
    protected ConcurrentDictionary`2<string, Counter`1<long>> _counters;
    protected ConcurrentDictionary`2<string, Histogram`1<double>> _histograms;
    public string QueueId { get; protected set; }
    public Nullable`1<DateTimeOffset> LastEnqueueActivity { get; protected set; }
    public Nullable`1<DateTimeOffset> LastDequeueActivity { get; protected set; }
    private ISerializer Foundatio.Serializer.IHaveSerializer.Serializer { get; }
    private TimeProvider Foundatio.Utility.IHaveTimeProvider.TimeProvider { get; }
    public IReadOnlyCollection`1<IQueueBehavior`1<T>> Behaviors { get; }
    public AsyncEvent`1<EnqueuingEventArgs`1<T>> Enqueuing { get; }
    public AsyncEvent`1<EnqueuedEventArgs`1<T>> Enqueued { get; }
    public AsyncEvent`1<DequeuedEventArgs`1<T>> Dequeued { get; }
    public AsyncEvent`1<LockRenewedEventArgs`1<T>> LockRenewed { get; }
    public AsyncEvent`1<CompletedEventArgs`1<T>> Completed { get; }
    public AsyncEvent`1<AbandonedEventArgs`1<T>> Abandoned { get; }
    protected QueueBase`2(TOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual string get_QueueId();
    [CompilerGeneratedAttribute]
protected void set_QueueId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_LastEnqueueActivity();
    [CompilerGeneratedAttribute]
protected void set_LastEnqueueActivity(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_LastDequeueActivity();
    [CompilerGeneratedAttribute]
protected void set_LastDequeueActivity(Nullable`1<DateTimeOffset> value);
    private sealed virtual override ISerializer Foundatio.Serializer.IHaveSerializer.get_Serializer();
    private sealed virtual override TimeProvider Foundatio.Utility.IHaveTimeProvider.get_TimeProvider();
    public sealed virtual void AttachBehavior(IQueueBehavior`1<T> behavior);
    protected abstract virtual Task EnsureQueueCreatedAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<string> EnqueueImplAsync(T data, QueueEntryOptions options);
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<EnqueueAsync>d__37")]
public sealed virtual Task`1<string> EnqueueAsync(T data, QueueEntryOptions options);
    protected abstract virtual Task`1<IQueueEntry`1<T>> DequeueImplAsync(CancellationToken linkedCancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<DequeueAsync>d__39")]
public sealed virtual Task`1<IQueueEntry`1<T>> DequeueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<DequeueAsync>d__40")]
public virtual Task`1<IQueueEntry`1<T>> DequeueAsync(Nullable`1<TimeSpan> timeout);
    public abstract virtual Task RenewLockAsync(IQueueEntry`1<T> queueEntry);
    public abstract virtual Task CompleteAsync(IQueueEntry`1<T> queueEntry);
    public abstract virtual Task AbandonAsync(IQueueEntry`1<T> queueEntry);
    protected abstract virtual Task`1<IEnumerable`1<T>> GetDeadletterItemsImplAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<GetDeadletterItemsAsync>d__45")]
public sealed virtual Task`1<IEnumerable`1<T>> GetDeadletterItemsAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<QueueStats> GetQueueStatsImplAsync();
    public sealed virtual Task`1<QueueStats> GetQueueStatsAsync();
    protected virtual QueueStats GetMetricsQueueStats();
    public abstract virtual Task DeleteQueueAsync();
    protected abstract virtual void StartWorkingImpl(Func`3<IQueueEntry`1<T>, CancellationToken, Task> handler, bool autoComplete, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<StartWorkingAsync>d__51")]
public sealed virtual Task StartWorkingAsync(Func`3<IQueueEntry`1<T>, CancellationToken, Task> handler, bool autoComplete, CancellationToken cancellationToken);
    public IReadOnlyCollection`1<IQueueBehavior`1<T>> get_Behaviors();
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<EnqueuingEventArgs`1<T>> get_Enqueuing();
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<OnEnqueuingAsync>d__57")]
protected virtual Task`1<bool> OnEnqueuingAsync(T data, QueueEntryOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<EnqueuedEventArgs`1<T>> get_Enqueued();
    protected virtual Task OnEnqueuedAsync(IQueueEntry`1<T> entry);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<DequeuedEventArgs`1<T>> get_Dequeued();
    protected virtual Task OnDequeuedAsync(IQueueEntry`1<T> entry);
    protected virtual TagList GetQueueEntryTags(IQueueEntry`1<T> entry);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<LockRenewedEventArgs`1<T>> get_LockRenewed();
    protected virtual Task OnLockRenewedAsync(IQueueEntry`1<T> entry);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<CompletedEventArgs`1<T>> get_Completed();
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<OnCompletedAsync>d__74")]
protected virtual Task OnCompletedAsync(IQueueEntry`1<T> entry);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncEvent`1<AbandonedEventArgs`1<T>> get_Abandoned();
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueBase`2/<OnAbandonedAsync>d__78")]
protected virtual Task OnAbandonedAsync(IQueueEntry`1<T> entry);
    protected string GetSubMetricName(T data);
    private void IncrementSubCounter(T data, string name, TagList& tags);
    private void RecordSubHistogram(T data, string name, double value, TagList& tags);
    protected string GetFullMetricName(string name);
    protected string GetFullMetricName(string customMetricName, string name);
    protected CancellationTokenSource GetLinkedDisposableCancellationTokenSource(CancellationToken cancellationToken);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private ValueTuple`3<long, long, long> <.ctor>b__17_0();
}
public abstract class Foundatio.Queues.QueueBehaviorBase`1 : object {
    protected IQueue`1<T> _queue;
    private List`1<IDisposable> _disposables;
    public virtual void Attach(IQueue`1<T> queue);
    protected virtual Task OnEnqueuing(object sender, EnqueuingEventArgs`1<T> enqueuingEventArgs);
    protected virtual Task OnEnqueued(object sender, EnqueuedEventArgs`1<T> enqueuedEventArgs);
    protected virtual Task OnDequeued(object sender, DequeuedEventArgs`1<T> dequeuedEventArgs);
    protected virtual Task OnLockRenewed(object sender, LockRenewedEventArgs`1<T> dequeuedEventArgs);
    protected virtual Task OnCompleted(object sender, CompletedEventArgs`1<T> completedEventArgs);
    protected virtual Task OnAbandoned(object sender, AbandonedEventArgs`1<T> abandonedEventArgs);
    public virtual void Dispose();
}
public class Foundatio.Queues.QueueEntry`1 : object {
    private IQueue`1<T> _queue;
    private T _original;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EnqueuedTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <RenewedTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DequeuedTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Attempts>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ProcessingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TotalTime>k__BackingField;
    public string Id { get; }
    public string CorrelationId { get; }
    public IDictionary`2<string, string> Properties { get; }
    public bool IsCompleted { get; private set; }
    public bool IsAbandoned { get; private set; }
    public Type EntryType { get; }
    public T Value { get; public set; }
    public DateTime EnqueuedTimeUtc { get; public set; }
    public DateTime RenewedTimeUtc { get; public set; }
    public DateTime DequeuedTimeUtc { get; public set; }
    public int Attempts { get; public set; }
    public TimeSpan ProcessingTime { get; public set; }
    public TimeSpan TotalTime { get; public set; }
    public QueueEntry`1(string id, string correlationId, T value, IQueue`1<T> queue, DateTime enqueuedTimeUtc, int attempts);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAbandoned();
    [CompilerGeneratedAttribute]
private void set_IsAbandoned(bool value);
    public sealed virtual Type get_EntryType();
    public sealed virtual object GetValue();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_EnqueuedTimeUtc();
    [CompilerGeneratedAttribute]
public void set_EnqueuedTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_RenewedTimeUtc();
    [CompilerGeneratedAttribute]
public void set_RenewedTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_DequeuedTimeUtc();
    [CompilerGeneratedAttribute]
public void set_DequeuedTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Attempts();
    [CompilerGeneratedAttribute]
public void set_Attempts(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ProcessingTime();
    [CompilerGeneratedAttribute]
public void set_ProcessingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_TotalTime();
    [CompilerGeneratedAttribute]
public void set_TotalTime(TimeSpan value);
    private sealed virtual override void Foundatio.Queues.IQueueEntry.MarkCompleted();
    private sealed virtual override void Foundatio.Queues.IQueueEntry.MarkAbandoned();
    public sealed virtual Task RenewLockAsync();
    public sealed virtual Task CompleteAsync();
    public sealed virtual Task AbandonAsync();
    [AsyncStateMachineAttribute("Foundatio.Queues.QueueEntry`1/<DisposeAsync>d__56")]
public sealed virtual ValueTask DisposeAsync();
    internal void Reset();
}
public class Foundatio.Queues.QueueEntryOptions : object {
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <DeliveryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string UniqueId { get; public set; }
    public string CorrelationId { get; public set; }
    public Nullable`1<TimeSpan> DeliveryDelay { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_DeliveryDelay();
    [CompilerGeneratedAttribute]
public void set_DeliveryDelay(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
}
[ExtensionAttribute]
public static class Foundatio.Queues.QueueExtensions : object {
    [ExtensionAttribute]
public static Task StartWorkingAsync(IQueue`1<T> queue, Func`2<IQueueEntry`1<T>, Task> handler, bool autoComplete, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("Queued={Queued}, Working={Working}, Deadletter={Deadletter}, Enqueued={Enqueued}, Dequeued={Dequeued}, Completed={Completed}, Abandoned={Abandoned}, Errors={Errors}, Timeouts={Timeouts}")]
public class Foundatio.Queues.QueueStats : object {
    [CompilerGeneratedAttribute]
private long <Queued>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Working>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Deadletter>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Enqueued>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Dequeued>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Abandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timeouts>k__BackingField;
    public long Queued { get; public set; }
    public long Working { get; public set; }
    public long Deadletter { get; public set; }
    public long Enqueued { get; public set; }
    public long Dequeued { get; public set; }
    public long Completed { get; public set; }
    public long Abandoned { get; public set; }
    public long Errors { get; public set; }
    public long Timeouts { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Queued();
    [CompilerGeneratedAttribute]
public void set_Queued(long value);
    [CompilerGeneratedAttribute]
public long get_Working();
    [CompilerGeneratedAttribute]
public void set_Working(long value);
    [CompilerGeneratedAttribute]
public long get_Deadletter();
    [CompilerGeneratedAttribute]
public void set_Deadletter(long value);
    [CompilerGeneratedAttribute]
public long get_Enqueued();
    [CompilerGeneratedAttribute]
public void set_Enqueued(long value);
    [CompilerGeneratedAttribute]
public long get_Dequeued();
    [CompilerGeneratedAttribute]
public void set_Dequeued(long value);
    [CompilerGeneratedAttribute]
public long get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(long value);
    [CompilerGeneratedAttribute]
public long get_Abandoned();
    [CompilerGeneratedAttribute]
public void set_Abandoned(long value);
    [CompilerGeneratedAttribute]
public long get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(long value);
    [CompilerGeneratedAttribute]
public long get_Timeouts();
    [CompilerGeneratedAttribute]
public void set_Timeouts(long value);
}
public class Foundatio.Queues.SharedQueueOptions`1 : SharedOptions {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WorkItemTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IQueueBehavior`1<T>> <Behaviors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricsPrefix>k__BackingField;
    public string Name { get; public set; }
    public int Retries { get; public set; }
    public TimeSpan WorkItemTimeout { get; public set; }
    public ICollection`1<IQueueBehavior`1<T>> Behaviors { get; public set; }
    public string MetricsPrefix { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WorkItemTimeout();
    [CompilerGeneratedAttribute]
public void set_WorkItemTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public ICollection`1<IQueueBehavior`1<T>> get_Behaviors();
    [CompilerGeneratedAttribute]
public void set_Behaviors(ICollection`1<IQueueBehavior`1<T>> value);
    [CompilerGeneratedAttribute]
public string get_MetricsPrefix();
    [CompilerGeneratedAttribute]
public void set_MetricsPrefix(string value);
}
public class Foundatio.Queues.SharedQueueOptionsBuilder`3 : SharedOptionsBuilder`2<TOptions, TBuilder> {
    public TBuilder Name(string name);
    public TBuilder Retries(int retries);
    public TBuilder WorkItemTimeout(TimeSpan timeout);
    public TBuilder Behaviors(IQueueBehavior`1[] behaviors);
    public TBuilder AddBehavior(IQueueBehavior`1<T> behavior);
    public TBuilder MetricsPrefix(string prefix);
}
public static class Foundatio.Serializer.DefaultSerializer : object {
    [CompilerGeneratedAttribute]
private static ISerializer <Instance>k__BackingField;
    public static ISerializer Instance { get; public set; }
    private static DefaultSerializer();
    [CompilerGeneratedAttribute]
public static ISerializer get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(ISerializer value);
}
public interface Foundatio.Serializer.IHaveSerializer {
    public ISerializer Serializer { get; }
    public abstract virtual ISerializer get_Serializer();
}
public interface Foundatio.Serializer.ISerializer {
    public abstract virtual object Deserialize(Stream data, Type objectType);
    public abstract virtual void Serialize(object value, Stream output);
}
public interface Foundatio.Serializer.ITextSerializer {
}
public class Foundatio.Serializer.ObjectToInferredTypesConverter : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object objectToWrite, JsonSerializerOptions options);
}
[ExtensionAttribute]
public static class Foundatio.Serializer.SerializerExtensions : object {
    [ExtensionAttribute]
public static T Deserialize(ISerializer serializer, Stream data);
    [ExtensionAttribute]
public static T Deserialize(ISerializer serializer, Byte[] data);
    [ExtensionAttribute]
public static object Deserialize(ISerializer serializer, Byte[] data, Type objectType);
    [ExtensionAttribute]
public static T Deserialize(ISerializer serializer, string data);
    [ExtensionAttribute]
public static object Deserialize(ISerializer serializer, string data, Type objectType);
    [ExtensionAttribute]
public static string SerializeToString(ISerializer serializer, T value);
    [ExtensionAttribute]
public static Byte[] SerializeToBytes(ISerializer serializer, T value);
}
public class Foundatio.Serializer.SystemTextJsonSerializer : object {
    private JsonSerializerOptions _serializeOptions;
    private JsonSerializerOptions _deserializeOptions;
    public SystemTextJsonSerializer(JsonSerializerOptions serializeOptions, JsonSerializerOptions deserializeOptions);
    public sealed virtual void Serialize(object data, Stream outputStream);
    public sealed virtual object Deserialize(Stream inputStream, Type objectType);
}
public class Foundatio.SharedOptions : object {
    [CompilerGeneratedAttribute]
private TimeProvider <TimeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerFactory <LoggerFactory>k__BackingField;
    public TimeProvider TimeProvider { get; public set; }
    public ISerializer Serializer { get; public set; }
    public ILoggerFactory LoggerFactory { get; public set; }
    [CompilerGeneratedAttribute]
public TimeProvider get_TimeProvider();
    [CompilerGeneratedAttribute]
public void set_TimeProvider(TimeProvider value);
    [CompilerGeneratedAttribute]
public ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public void set_Serializer(ISerializer value);
    [CompilerGeneratedAttribute]
public ILoggerFactory get_LoggerFactory();
    [CompilerGeneratedAttribute]
public void set_LoggerFactory(ILoggerFactory value);
}
public class Foundatio.SharedOptionsBuilder`2 : OptionsBuilder`1<TOption> {
    public TBuilder TimeProvider(TimeProvider timeProvider);
    public TBuilder Serializer(ISerializer serializer);
    public TBuilder LoggerFactory(ILoggerFactory loggerFactory);
}
public class Foundatio.Storage.ActionableStream : Stream {
    private Action _disposeAction;
    private Stream _stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ActionableStream(Stream stream, Action disposeAction);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("Path = {Path}, Created = {Created}, Modified = {Modified}, Size = {Size} bytes")]
public class Foundatio.Storage.FileSpec : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Modified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    public string Path { get; public set; }
    public DateTime Created { get; public set; }
    public DateTime Modified { get; public set; }
    public long Size { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
public void set_Created(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Modified();
    [CompilerGeneratedAttribute]
public void set_Modified(DateTime value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
}
[ExtensionAttribute]
public static class Foundatio.Storage.FileStorageExtensions : object {
    [ExtensionAttribute]
public static Task`1<bool> SaveObjectAsync(IFileStorage storage, string path, T data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.FileStorageExtensions/<GetObjectAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<T> GetObjectAsync(IFileStorage storage, string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.FileStorageExtensions/<DeleteFilesAsync>d__2")]
[ExtensionAttribute]
public static Task DeleteFilesAsync(IFileStorage storage, IEnumerable`1<FileSpec> files);
    [AsyncStateMachineAttribute("Foundatio.Storage.FileStorageExtensions/<GetFileContentsAsync>d__3")]
[ExtensionAttribute]
public static Task`1<string> GetFileContentsAsync(IFileStorage storage, string path);
    [AsyncStateMachineAttribute("Foundatio.Storage.FileStorageExtensions/<GetFileContentsRawAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Byte[]> GetFileContentsRawAsync(IFileStorage storage, string path);
    [ExtensionAttribute]
public static Task`1<bool> SaveFileAsync(IFileStorage storage, string path, string contents);
    [AsyncStateMachineAttribute("Foundatio.Storage.FileStorageExtensions/<GetFileListAsync>d__6")]
[ExtensionAttribute]
public static Task`1<IReadOnlyCollection`1<FileSpec>> GetFileListAsync(IFileStorage storage, string searchPattern, Nullable`1<int> limit, CancellationToken cancellationToken);
}
public class Foundatio.Storage.FolderFileStorage : object {
    private AsyncLock _lock;
    private ISerializer _serializer;
    protected ILogger _logger;
    [CompilerGeneratedAttribute]
private string <Folder>k__BackingField;
    public string Folder { get; public set; }
    private ISerializer Foundatio.Serializer.IHaveSerializer.Serializer { get; }
    public FolderFileStorage(FolderFileStorageOptions options);
    public FolderFileStorage(Builder`2<FolderFileStorageOptionsBuilder, FolderFileStorageOptions> config);
    [CompilerGeneratedAttribute]
public string get_Folder();
    [CompilerGeneratedAttribute]
public void set_Folder(string value);
    private sealed virtual override ISerializer Foundatio.Serializer.IHaveSerializer.get_Serializer();
    [ObsoleteAttribute("Use GetFileStreamAsync with StreamMode instead to define read or write behaviour of stream")]
public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, StreamMode streamMode, CancellationToken cancellationToken);
    public sealed virtual Task`1<FileSpec> GetFileInfoAsync(string path);
    public sealed virtual Task`1<bool> ExistsAsync(string path);
    [AsyncStateMachineAttribute("Foundatio.Storage.FolderFileStorage/<SaveFileAsync>d__15")]
public sealed virtual Task`1<bool> SaveFileAsync(string path, Stream stream, CancellationToken cancellationToken);
    private void EnsureDirectory(string normalizedPath);
    [AsyncStateMachineAttribute("Foundatio.Storage.FolderFileStorage/<RenameFileAsync>d__17")]
public sealed virtual Task`1<bool> RenameFileAsync(string path, string newPath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.FolderFileStorage/<CopyFileAsync>d__18")]
public sealed virtual Task`1<bool> CopyFileAsync(string path, string targetPath, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> DeleteFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> DeleteFilesAsync(string searchPattern, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Foundatio.Storage.FolderFileStorage/<GetPagedFileListAsync>d__21")]
public sealed virtual Task`1<PagedFileListResult> GetPagedFileListAsync(int pageSize, string searchPattern, CancellationToken cancellationToken);
    private NextPageResult GetFiles(string searchPattern, int page, int pageSize);
    public sealed virtual void Dispose();
}
public class Foundatio.Storage.FolderFileStorageOptions : SharedOptions {
    [CompilerGeneratedAttribute]
private string <Folder>k__BackingField;
    public string Folder { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Folder();
    [CompilerGeneratedAttribute]
public void set_Folder(string value);
}
public class Foundatio.Storage.FolderFileStorageOptionsBuilder : SharedOptionsBuilder`2<FolderFileStorageOptions, FolderFileStorageOptionsBuilder> {
    public FolderFileStorageOptionsBuilder Folder(string folder);
}
public interface Foundatio.Storage.IFileStorage {
    [ObsoleteAttribute("Use GetFileStreamAsync with StreamMode instead to define read or write behaviour of stream")]
public abstract virtual Task`1<Stream> GetFileStreamAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetFileStreamAsync(string path, StreamMode streamMode, CancellationToken cancellationToken);
    public abstract virtual Task`1<FileSpec> GetFileInfoAsync(string path);
    public abstract virtual Task`1<bool> ExistsAsync(string path);
    public abstract virtual Task`1<bool> SaveFileAsync(string path, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> RenameFileAsync(string path, string newPath, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CopyFileAsync(string path, string targetPath, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> DeleteFileAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<int> DeleteFilesAsync(string searchPattern, CancellationToken cancellation);
    public abstract virtual Task`1<PagedFileListResult> GetPagedFileListAsync(int pageSize, string searchPattern, CancellationToken cancellationToken);
}
public interface Foundatio.Storage.IHasNextPageFunc {
    public Func`2<PagedFileListResult, Task`1<NextPageResult>> NextPageFunc { get; public set; }
    public abstract virtual Func`2<PagedFileListResult, Task`1<NextPageResult>> get_NextPageFunc();
    public abstract virtual void set_NextPageFunc(Func`2<PagedFileListResult, Task`1<NextPageResult>> value);
}
public class Foundatio.Storage.InMemoryFileStorage : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ValueTuple`2<FileSpec, Byte[]>> _storage;
    private ISerializer _serializer;
    protected ILogger _logger;
    private TimeProvider _timeProvider;
    [CompilerGeneratedAttribute]
private long <MaxFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxFiles>k__BackingField;
    public long MaxFileSize { get; public set; }
    public long MaxFiles { get; public set; }
    private ISerializer Foundatio.Serializer.IHaveSerializer.Serializer { get; }
    public InMemoryFileStorage(InMemoryFileStorageOptions options);
    public InMemoryFileStorage(Builder`2<InMemoryFileStorageOptionsBuilder, InMemoryFileStorageOptions> config);
    [CompilerGeneratedAttribute]
public long get_MaxFileSize();
    [CompilerGeneratedAttribute]
public void set_MaxFileSize(long value);
    [CompilerGeneratedAttribute]
public long get_MaxFiles();
    [CompilerGeneratedAttribute]
public void set_MaxFiles(long value);
    private sealed virtual override ISerializer Foundatio.Serializer.IHaveSerializer.get_Serializer();
    [ObsoleteAttribute("Use GetFileStreamAsync with StreamMode instead to define read or write behaviour of stream")]
public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, StreamMode streamMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.InMemoryFileStorage/<GetFileInfoAsync>d__19")]
public sealed virtual Task`1<FileSpec> GetFileInfoAsync(string path);
    public sealed virtual Task`1<bool> ExistsAsync(string path);
    private static Byte[] ReadBytes(Stream input);
    public sealed virtual Task`1<bool> SaveFileAsync(string path, Stream stream, CancellationToken cancellationToken);
    private void AddOrUpdate(string path, Byte[] contents);
    public sealed virtual Task`1<bool> RenameFileAsync(string path, string newPath, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> CopyFileAsync(string path, string targetPath, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> DeleteFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> DeleteFilesAsync(string searchPattern, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Foundatio.Storage.InMemoryFileStorage/<GetPagedFileListAsync>d__28")]
public sealed virtual Task`1<PagedFileListResult> GetPagedFileListAsync(int pageSize, string searchPattern, CancellationToken cancellationToken);
    private Task`1<NextPageResult> GetFilesAsync(string searchPattern, int page, int pageSize, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class Foundatio.Storage.InMemoryFileStorageOptions : SharedOptions {
    [CompilerGeneratedAttribute]
private long <MaxFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFiles>k__BackingField;
    public long MaxFileSize { get; public set; }
    public int MaxFiles { get; public set; }
    [CompilerGeneratedAttribute]
public long get_MaxFileSize();
    [CompilerGeneratedAttribute]
public void set_MaxFileSize(long value);
    [CompilerGeneratedAttribute]
public int get_MaxFiles();
    [CompilerGeneratedAttribute]
public void set_MaxFiles(int value);
}
public class Foundatio.Storage.InMemoryFileStorageOptionsBuilder : SharedOptionsBuilder`2<InMemoryFileStorageOptions, InMemoryFileStorageOptionsBuilder> {
    public InMemoryFileStorageOptionsBuilder MaxFileSize(long maxFileSize);
    public InMemoryFileStorageOptionsBuilder MaxFiles(int maxFiles);
}
public class Foundatio.Storage.NextPageResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMore>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FileSpec> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PagedFileListResult, Task`1<NextPageResult>> <NextPageFunc>k__BackingField;
    public bool Success { get; public set; }
    public bool HasMore { get; public set; }
    public IReadOnlyCollection`1<FileSpec> Files { get; public set; }
    public Func`2<PagedFileListResult, Task`1<NextPageResult>> NextPageFunc { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMore();
    [CompilerGeneratedAttribute]
public void set_HasMore(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FileSpec> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IReadOnlyCollection`1<FileSpec> value);
    [CompilerGeneratedAttribute]
public Func`2<PagedFileListResult, Task`1<NextPageResult>> get_NextPageFunc();
    [CompilerGeneratedAttribute]
public void set_NextPageFunc(Func`2<PagedFileListResult, Task`1<NextPageResult>> value);
}
public class Foundatio.Storage.PagedFileListResult : object {
    private static IReadOnlyCollection`1<FileSpec> _empty;
    public static PagedFileListResult Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FileSpec> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMore>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PagedFileListResult, Task`1<NextPageResult>> <Foundatio.Storage.IHasNextPageFunc.NextPageFunc>k__BackingField;
    public IReadOnlyCollection`1<FileSpec> Files { get; private set; }
    public bool HasMore { get; private set; }
    protected IDictionary`2<string, object> Data { get; }
    private Func`2<PagedFileListResult, Task`1<NextPageResult>> Foundatio.Storage.IHasNextPageFunc.NextPageFunc { get; private set; }
    public PagedFileListResult(IReadOnlyCollection`1<FileSpec> files);
    public PagedFileListResult(IReadOnlyCollection`1<FileSpec> files, bool hasMore, Func`2<PagedFileListResult, Task`1<NextPageResult>> nextPageFunc);
    public PagedFileListResult(Func`2<PagedFileListResult, Task`1<NextPageResult>> nextPageFunc);
    private static PagedFileListResult();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FileSpec> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(IReadOnlyCollection`1<FileSpec> value);
    [CompilerGeneratedAttribute]
public bool get_HasMore();
    [CompilerGeneratedAttribute]
private void set_HasMore(bool value);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
private sealed virtual override Func`2<PagedFileListResult, Task`1<NextPageResult>> Foundatio.Storage.IHasNextPageFunc.get_NextPageFunc();
    [CompilerGeneratedAttribute]
private sealed virtual override void Foundatio.Storage.IHasNextPageFunc.set_NextPageFunc(Func`2<PagedFileListResult, Task`1<NextPageResult>> value);
    [AsyncStateMachineAttribute("Foundatio.Storage.PagedFileListResult/<NextPageAsync>d__20")]
public Task`1<bool> NextPageAsync();
}
public class Foundatio.Storage.ScopedFileStorage : object {
    private string _pathPrefix;
    [CompilerGeneratedAttribute]
private IFileStorage <UnscopedStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    public IFileStorage UnscopedStorage { get; private set; }
    public string Scope { get; private set; }
    private ISerializer Foundatio.Serializer.IHaveSerializer.Serializer { get; }
    public ScopedFileStorage(IFileStorage storage, string scope);
    [CompilerGeneratedAttribute]
public IFileStorage get_UnscopedStorage();
    [CompilerGeneratedAttribute]
private void set_UnscopedStorage(IFileStorage value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(string value);
    private sealed virtual override ISerializer Foundatio.Serializer.IHaveSerializer.get_Serializer();
    [ObsoleteAttribute("Use GetFileStreamAsync with StreamMode instead to define read or write behaviour of stream")]
public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> GetFileStreamAsync(string path, StreamMode streamMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.ScopedFileStorage/<GetFileInfoAsync>d__14")]
public sealed virtual Task`1<FileSpec> GetFileInfoAsync(string path);
    public sealed virtual Task`1<bool> ExistsAsync(string path);
    public sealed virtual Task`1<bool> SaveFileAsync(string path, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> RenameFileAsync(string path, string newPath, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> CopyFileAsync(string path, string targetPath, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> DeleteFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual Task`1<int> DeleteFilesAsync(string searchPattern, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Foundatio.Storage.ScopedFileStorage/<GetPagedFileListAsync>d__21")]
public sealed virtual Task`1<PagedFileListResult> GetPagedFileListAsync(int pageSize, string searchPattern, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Foundatio.Storage.ScopedFileStorage/<NextPage>d__22")]
private Task`1<NextPageResult> NextPage(PagedFileListResult result);
    public sealed virtual void Dispose();
}
public enum Foundatio.Storage.StreamMode : Enum {
    public int value__;
    public static StreamMode Read;
    public static StreamMode Write;
}
public static class Foundatio.Utility.Async : object {
    [AsyncStateMachineAttribute("Foundatio.Utility.Async/<Using>d__0`2")]
public static Task`1<TReturn> Using(TResource resource, Func`2<TResource, Task`1<TReturn>> body);
    public static Task Using(TResource resource, Func`1<Task> body);
    public static Task Using(TResource resource, Action body);
    public static Task Using(TResource resource, Func`2<TResource, Task> body);
    public static Task`1<TReturn> Using(TResource resource, Func`1<Task`1<TReturn>> body);
}
public class Foundatio.Utility.AsyncEvent`1 : object {
    private List`1<Func`3<object, TEventArgs, Task>> _invocationList;
    private object _lockObject;
    private bool _parallelInvoke;
    public bool HasHandlers { get; }
    public AsyncEvent`1(bool parallelInvoke);
    public bool get_HasHandlers();
    public IDisposable AddHandler(Func`3<object, TEventArgs, Task> callback);
    public IDisposable AddSyncHandler(Action`2<object, TEventArgs> callback);
    public void RemoveHandler(Func`3<object, TEventArgs, Task> callback);
    [AsyncStateMachineAttribute("Foundatio.Utility.AsyncEvent`1/<InvokeAsync>d__9")]
public Task InvokeAsync(object sender, TEventArgs eventArgs);
    public sealed virtual IDisposable Subscribe(IObserver`1<TEventArgs> observer);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Foundatio.Utility.CollectionExtensions : object {
    [ExtensionAttribute]
public static ICollection`1<T> ReduceTimeSeries(ICollection`1<T> items, Func`2<T, DateTime> dateSelector, Func`3<ICollection`1<T>, DateTime, T> reducer, int dataPoints);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static bool TryUpdate(ConcurrentDictionary`2<TKey, TValue> concurrentDictionary, TKey key, Func`3<TKey, TValue, TValue> updateValueFactory);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static void Clear(ConcurrentQueue`1<T> queue);
}
[ExtensionAttribute]
public static class Foundatio.Utility.ConnectionStringParser : object {
    private static string ConnectionStringPattern;
    private static Regex _connectionStringRegex;
    private static ConnectionStringParser();
    private static Dictionary`2<string, string> Parse(string connectionString, IDictionary`2<string, string> synonyms);
    private static bool IsKeyNameValid(string keyName);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ParseConnectionString(string connectionString, IDictionary`2<string, string> synonyms);
    [ExtensionAttribute]
public static string BuildConnectionString(IDictionary`2<string, string> options, IEnumerable`1<string> excludedKeys);
}
public class Foundatio.Utility.DataDictionary : Dictionary`2<string, object> {
    public static DataDictionary Empty;
    public DataDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values);
    private static DataDictionary();
}
[ExtensionAttribute]
public static class Foundatio.Utility.DataDictionaryExtensions : object {
    [ExtensionAttribute]
public static object GetValueOrDefault(IDictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static object GetValueOrDefault(IDictionary`2<string, object> dictionary, string key, object defaultValue);
    [ExtensionAttribute]
public static object GetValueOrDefault(IDictionary`2<string, object> dictionary, string key, Func`1<object> defaultValueProvider);
    [ExtensionAttribute]
public static T GetValue(IDictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static T GetValueOrDefault(IDictionary`2<string, object> dictionary, string key, T defaultValue);
    [ExtensionAttribute]
public static string GetString(IDictionary`2<string, object> dictionary, string name);
    [ExtensionAttribute]
public static string GetString(IDictionary`2<string, object> dictionary, string name, string default);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.DateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTime Floor(DateTime date, TimeSpan interval);
    [ExtensionAttribute]
public static DateTime Ceiling(DateTime date, TimeSpan interval);
    [ExtensionAttribute]
public static long ToUnixTimeMilliseconds(DateTime date);
    [ExtensionAttribute]
public static DateTime FromUnixTimeMilliseconds(long timestamp);
    [ExtensionAttribute]
public static long ToUnixTimeSeconds(DateTime date);
    [ExtensionAttribute]
public static DateTimeOffset FromUnixTimeSeconds(long timestamp);
    [ExtensionAttribute]
public static DateTime SafeAdd(DateTime date, TimeSpan value);
}
public static class Foundatio.Utility.Disposable : object {
    public static IDisposable Empty;
    public static ILock EmptyLock;
    private static Disposable();
}
public class Foundatio.Utility.DisposableAction : object {
    private Action _exitAction;
    private bool _disposed;
    public DisposableAction(Action exitAction);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class Foundatio.Utility.EmptyDisposable : object {
    public sealed virtual void Dispose();
}
public class Foundatio.Utility.EmptyLock : object {
    public string LockId { get; }
    public string Resource { get; }
    public DateTime AcquiredTimeUtc { get; }
    public TimeSpan TimeWaitedForLock { get; }
    public int RenewalCount { get; }
    public sealed virtual string get_LockId();
    public sealed virtual string get_Resource();
    public sealed virtual DateTime get_AcquiredTimeUtc();
    public sealed virtual TimeSpan get_TimeWaitedForLock();
    public sealed virtual int get_RenewalCount();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task RenewAsync(Nullable`1<TimeSpan> lockExtension);
    public sealed virtual Task ReleaseAsync();
}
[ExtensionAttribute]
internal static class Foundatio.Utility.EnumerableExtensions : object {
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> list, IEnumerable`1<T> range);
}
internal static class Foundatio.Utility.EnumExtensions : object {
    public static bool TryEnumIsDefined(Type type, object value);
    public static bool TryEnumIsDefined(Type type, object value);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception GetInnermostException(Exception exception);
    [ExtensionAttribute]
public static string GetMessage(Exception exception);
}
[ExtensionAttribute]
public static class Foundatio.Utility.HaveDataExtensions : object {
    [ExtensionAttribute]
public static T GetDataOrDefault(IHaveData target, string key, T defaultValue, ISerializer serializer);
    [ExtensionAttribute]
public static bool TryGetData(IHaveData target, string key, T& value, ISerializer serializer);
}
public interface Foundatio.Utility.IAsyncLifetime {
    public abstract virtual Task InitializeAsync();
}
public interface Foundatio.Utility.IHaveData {
    public IDictionary`2<string, object> Data { get; }
    public abstract virtual IDictionary`2<string, object> get_Data();
}
public interface Foundatio.Utility.IHaveLogger {
    public ILogger Logger { get; }
    public abstract virtual ILogger get_Logger();
}
public interface Foundatio.Utility.IHaveTimeProvider {
    public TimeProvider TimeProvider { get; }
    public abstract virtual TimeProvider get_TimeProvider();
}
public class Foundatio.Utility.InstrumentsValues`3 : object {
    private object _lock;
    private int _readCount;
    private Nullable`1<T1> _value1;
    private Nullable`1<T2> _value2;
    private Nullable`1<T3> _value3;
    private Func`1<ValueTuple`3<T1, T2, T3>> _readValuesFunc;
    private ILogger _logger;
    public InstrumentsValues`3(Func`1<ValueTuple`3<T1, T2, T3>> readValuesFunc, ILogger logger);
    private void EnsureValues();
    public T1 GetValue1();
    public T2 GetValue2();
    public T3 GetValue3();
}
[ExtensionAttribute]
public static class Foundatio.Utility.LoggerExtensions : object {
    [ExtensionAttribute]
public static ILogger GetLogger(object target);
}
public class Foundatio.Utility.MaintenanceBase : object {
    private ScheduledTimer _maintenanceTimer;
    private ILoggerFactory _loggerFactory;
    protected TimeProvider _timeProvider;
    protected ILogger _logger;
    public MaintenanceBase(TimeProvider timeProvider, ILoggerFactory loggerFactory);
    protected void InitializeMaintenance(Nullable`1<TimeSpan> dueTime, Nullable`1<TimeSpan> intervalTime);
    protected void ScheduleNextMaintenance(DateTime utcDate);
    protected virtual Task`1<Nullable`1<DateTime>> DoMaintenanceAsync();
    public virtual void Dispose();
}
[ExtensionAttribute]
internal static class Foundatio.Utility.NumericExtensions : object {
    [ExtensionAttribute]
public static string ToFileSizeDisplay(int i);
    [ExtensionAttribute]
public static string ToFileSizeDisplay(int i, int decimals);
    [ExtensionAttribute]
public static string ToFileSizeDisplay(long i);
    [ExtensionAttribute]
public static string ToFileSizeDisplay(long i, int decimals);
    [ExtensionAttribute]
public static string ToOrdinal(int num);
}
[ExtensionAttribute]
public static class Foundatio.Utility.ObjectExtensions : object {
    [ExtensionAttribute]
public static T DeepClone(T original);
}
public static class Foundatio.Utility.PathHelper : object {
    private static string DATA_DIRECTORY;
    public static string ExpandPath(string path);
    public static string GetDataDirectory();
}
public static class Foundatio.Utility.Run : object {
    private static Int32[] _defaultBackoffIntervals;
    private static Run();
    public static Task DelayedAsync(TimeSpan delay, Func`1<Task> action, TimeProvider timeProvider, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use Parallel.ForEachAsync")]
public static Task InParallelAsync(int iterations, Func`2<int, Task> work);
    public static Task WithRetriesAsync(Func`1<Task> action, int maxAttempts, Nullable`1<TimeSpan> retryInterval, TimeProvider timeProvider, CancellationToken cancellationToken, ILogger logger);
    [AsyncStateMachineAttribute("Foundatio.Utility.Run/<WithRetriesAsync>d__3`1")]
public static Task`1<T> WithRetriesAsync(Func`1<Task`1<T>> action, int maxAttempts, Nullable`1<TimeSpan> retryInterval, TimeProvider timeProvider, CancellationToken cancellationToken, ILogger logger);
}
public class Foundatio.Utility.ScheduledTimer : object {
    private DateTime _next;
    private DateTime _last;
    private Timer _timer;
    private ILogger _logger;
    private Func`1<Task`1<Nullable`1<DateTime>>> _timerCallback;
    private TimeProvider _timeProvider;
    private TimeSpan _minimumInterval;
    private AsyncLock _lock;
    private bool _isRunning;
    private bool _shouldRunAgainImmediately;
    public ScheduledTimer(Func`1<Task`1<Nullable`1<DateTime>>> timerCallback, Nullable`1<TimeSpan> dueTime, Nullable`1<TimeSpan> minimumIntervalTime, TimeProvider timeProvider, ILoggerFactory loggerFactory);
    public void ScheduleNext(Nullable`1<DateTime> utcDate);
    [AsyncStateMachineAttribute("Foundatio.Utility.ScheduledTimer/<RunCallbackAsync>d__12")]
private Task RunCallbackAsync();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0(object s);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.TaskExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredTaskAwaitable`1<TResult> AnyContext(Task`1<TResult> task);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<TResult> AnyContext(IAsyncEnumerable`1<TResult> source);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredAsyncDisposable AnyContext(IAsyncDisposable source);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredTaskAwaitable AnyContext(Task task);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredValueTaskAwaitable AnyContext(ValueTask task);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static ConfiguredTaskAwaitable`1<TResult> AnyContext(AwaitableDisposable`1<TResult> task);
    [AsyncStateMachineAttribute("Foundatio.Utility.TaskExtensions/<SafeDelay>d__6")]
[ExtensionAttribute]
public static Task SafeDelay(TimeProvider timeProvider, TimeSpan delay, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Foundatio.Utility.TimeProviderExtensions : object {
    [ExtensionAttribute]
public static TimeProvider GetTimeProvider(object target);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static CancellationTokenSource ToCancellationTokenSource(TimeSpan timeout);
    [ExtensionAttribute]
public static CancellationTokenSource ToCancellationTokenSource(Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
public static CancellationTokenSource ToCancellationTokenSource(Nullable`1<TimeSpan> timeout, TimeSpan defaultTimeout);
    [ExtensionAttribute]
public static TimeSpan Min(TimeSpan source, TimeSpan other);
    [ExtensionAttribute]
public static TimeSpan Max(TimeSpan source, TimeSpan other);
}
public static class Foundatio.Utility.TimeUnit : object {
    public static TimeSpan Parse(string value);
    public static bool TryParse(string value, Nullable`1& time);
    private static Nullable`1<TimeSpan> ParseTime(string value);
}
[ExtensionAttribute]
internal static class Foundatio.Utility.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsNullableNumeric(Type type);
    [ExtensionAttribute]
public static T ToType(object value, ISerializer serializer);
}
public static class Foundatio.Utility.TypeHelper : object {
    public static Type ObjectType;
    public static Type StringType;
    public static Type CharType;
    public static Type NullableCharType;
    public static Type DateTimeType;
    public static Type NullableDateTimeType;
    public static Type BoolType;
    public static Type NullableBoolType;
    public static Type ByteArrayType;
    public static Type ByteType;
    public static Type SByteType;
    public static Type SingleType;
    public static Type DecimalType;
    public static Type Int16Type;
    public static Type UInt16Type;
    public static Type Int32Type;
    public static Type UInt32Type;
    public static Type Int64Type;
    public static Type UInt64Type;
    public static Type DoubleType;
    private static Dictionary`2<Type, string> _builtInTypeNames;
    private static TypeHelper();
    public static Type ResolveType(string fullTypeName, Type expectedBase, ILogger logger);
    public static string GetTypeDisplayName(Type type);
    public static IEnumerable`1<Type> GetDerivedTypes(IEnumerable`1<Assembly> assemblies);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Logging.LoggerExtensions : object {
    [ExtensionAttribute]
public static IDisposable BeginScope(ILogger logger, Func`2<LogState, LogState> stateBuilder);
    [ExtensionAttribute]
public static IDisposable BeginScope(ILogger logger, string property, object value);
    [ExtensionAttribute]
public static void LogDebug(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static void LogTrace(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static void LogInformation(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static void LogWarning(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static void LogError(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static void LogError(ILogger logger, Func`2<LogState, LogState> stateBuilder, Exception exception, string message, Object[] args);
    [ExtensionAttribute]
public static void LogCritical(ILogger logger, Func`2<LogState, LogState> stateBuilder, string message, Object[] args);
    [ExtensionAttribute]
public static LogState Critical(LogState builder, bool isCritical);
    [ExtensionAttribute]
public static LogState Tag(LogState builder, string tag);
    [ExtensionAttribute]
public static LogState Tag(LogState builder, IEnumerable`1<string> tags);
    [ExtensionAttribute]
public static LogState Properties(LogState builder, ICollection`1<KeyValuePair`2<string, string>> collection);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Extensions.Logging.LogState : object {
    private Dictionary`2<string, object> _state;
    public int Count { get; }
    public object Item { get; public set; }
    public int get_Count();
    public object get_Item(string property);
    public void set_Item(string property, object value);
    public LogState Property(string property, object value);
    public LogState PropertyIf(string property, object value, bool condition);
    public bool ContainsProperty(string property);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
