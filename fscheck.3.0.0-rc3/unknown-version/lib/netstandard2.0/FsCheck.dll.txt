[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class FsCheck.Arbitrary`1 : object {
    public Gen`1<T> Generator { get; }
    public abstract virtual Gen`1<T> get_Generator();
    public virtual IEnumerable`1<T> Shrinker(T _arg1);
    private virtual override Gen`1<object> FsCheck.IArbitrary.get_GeneratorObj();
    private virtual override IEnumerable`1<object> FsCheck.IArbitrary.ShrinkerObj(object o);
}
[CompilationMappingAttribute]
internal class FsCheck.ArbMap : object {
    internal TypeClass`1<Arbitrary`1<object>> finder;
    internal int init@20;
    internal TypeClass`1<Arbitrary`1<object>> ArbFinder { get; }
    internal Type[] MemoizedInstances { get; }
    public ArbMap(ArbMapInit init);
    public ArbMap(Type typ, FSharpOption`1<ArbMap> existingMap);
    internal TypeClass`1<Arbitrary`1<object>> get_ArbFinder();
    internal Type[] get_MemoizedInstances();
    private virtual override Arbitrary`1<object> FsCheck.IArbMap.ArbFor(Type t);
    private virtual override Arbitrary`1<TArb> FsCheck.IArbMap.ArbFor();
    private virtual override IArbMap FsCheck.IArbMap.MergeFactory(Func`2<a, Arbitrary`1<b>> factory);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal abstract class FsCheck.ArbMapInit : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFromTypeClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFromDiscover { get; }
    [CompilationMappingAttribute]
internal static ArbMapInit NewFromTypeClass(TypeClass`1<Arbitrary`1<object>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFromTypeClass();
    [CompilationMappingAttribute]
internal static ArbMapInit NewFromDiscover(Tuple`2<Type, FSharpOption`1<ArbMap>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFromDiscover();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ArbMapInit obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Check : object {
    public static void One(Config config, Testable property);
    public static void One(string name, Config config, Testable property);
    public static void Method(Config config, MethodInfo methodInfo, FSharpOption`1<object> target);
    public static void Quick(Testable property);
    public static void Quick(string name, Testable property);
    public static void QuickThrowOnFailure(Testable property);
    public static void Verbose(Testable property);
    public static void Verbose(string name, Testable property);
    public static void VerboseThrowOnFailure(Testable property);
    public static void All(Config config, Type test);
    public static void All(Config config);
    public static void QuickAll(Type test);
    public static void QuickThrowOnFailureAll(Type test);
    public static void QuickAll();
    public static void QuickThrowOnFailureAll();
    public static void VerboseAll(Type test);
    public static void VerboseAll();
    public static void VerboseThrowOnFailureAll(Type test);
    public static void VerboseThrowOnFailureAll();
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class FsCheck.CheckExtensions : object {
    [ExtensionAttribute]
public static void Check(Property property, Config config);
    [ExtensionAttribute]
public static void QuickCheck(Property property);
    [ExtensionAttribute]
public static void QuickCheck(Property property, string testName);
    [ExtensionAttribute]
public static void QuickCheckThrowOnFailure(Property property);
    [ExtensionAttribute]
public static void VerboseCheck(Property property);
    [ExtensionAttribute]
public static void VerboseCheck(Property property, string testName);
    [ExtensionAttribute]
public static void VerboseCheckThrowOnFailure(Property property);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Config : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal <>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal <>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> Item { get; }
    internal <>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> Values { get; }
    public int MaxTest { get; }
    public int MaxRejected { get; }
    public FSharpOption`1<Replay> Replay { get; }
    public string Name { get; }
    public int StartSize { get; }
    public int EndSize { get; }
    public bool QuietOnSuccess { get; }
    public FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>> Every { get; }
    public FSharpFunc`2<FSharpList`1<object>, string> EveryShrink { get; }
    public IArbMap ArbMap { get; }
    public IRunner Runner { get; }
    public FSharpOption`1<ParallelRunConfig> ParallelRunConfig { get; }
    public static Config Quick { get; }
    public static Config Verbose { get; }
    internal static IRunner throwingRunner { get; }
    public static Config QuickThrowOnFailure { get; }
    public static Config VerboseThrowOnFailure { get; }
    public static Config Default { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Config")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Config(<>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> item);
    [CompilationMappingAttribute]
internal static Config NewConfig(<>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal <>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal <>f__AnonymousType1744619496`12<IArbMap, int, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>>, FSharpFunc`2<FSharpList`1<object>, string>, int, int, string, FSharpOption`1<ParallelRunConfig>, bool, FSharpOption`1<Replay>, IRunner, int> get_Values();
    public int get_MaxTest();
    public int get_MaxRejected();
    public FSharpOption`1<Replay> get_Replay();
    public string get_Name();
    public int get_StartSize();
    public int get_EndSize();
    public bool get_QuietOnSuccess();
    public FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>> get_Every();
    public FSharpFunc`2<FSharpList`1<object>, string> get_EveryShrink();
    public IArbMap get_ArbMap();
    public IRunner get_Runner();
    public FSharpOption`1<ParallelRunConfig> get_ParallelRunConfig();
    public Config WithMaxTest(int maxTest);
    public Config WithMaxRejected(int maxRejected);
    public Config WithReplay(FSharpOption`1<Replay> replay);
    public Config WithName(string name);
    public Config WithStartSize(int startSize);
    public Config WithEndSize(int endSize);
    public Config WithQuietOnSuccess(bool quietOnSuccess);
    public Config WithEvery(FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>> every);
    public Config WithEveryShrink(FSharpFunc`2<FSharpList`1<object>, string> everyShrink);
    public Config WithArbitrary(IEnumerable`1<a> arbitrary);
    public Config WithRunner(IRunner runner);
    public Config WithParallelRunConfig(FSharpOption`1<ParallelRunConfig> config);
    public static Config get_Quick();
    public static Config get_Verbose();
    internal static IRunner get_throwingRunner();
    public static Config get_QuickThrowOnFailure();
    public static Config get_VerboseThrowOnFailure();
    public static Config get_Default();
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class FsCheck.ConfigExtensions : object {
    [ExtensionAttribute]
public static Config WithEvery(Config config, Func`3<int, Object[], string> every);
    [ExtensionAttribute]
public static Config WithEveryShrink(Config config, Func`2<Object[], string> everyShrink);
    [ExtensionAttribute]
public static Config WithReplay(Config config, ulong seed, ulong gamma, int size);
    [ExtensionAttribute]
public static Config WithReplay(Config config, ulong seed, ulong gamma);
    [ExtensionAttribute]
public static Config WithNoReplay(Config config);
    [ExtensionAttribute]
public static Config WithParallelRunConfig(Config config, ParallelRunConfig parallelRunConfig);
    [ExtensionAttribute]
public static Config WithNoParallelRunConfig(Config config);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.DoNotShrink`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal a item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.DoNotShrink`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DoNotShrink`1(a item);
    [CompilationMappingAttribute]
public static DoNotShrink`1<a> NewDoNotShrink(a item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DoNotShrink`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DoNotShrink`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.DoNotSize`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal a item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.DoNotSize`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DoNotSize`1(a item);
    [CompilationMappingAttribute]
public static DoNotSize`1<a> NewDoNotSize(a item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DoNotSize`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static a Unwrap(DoNotSize`1<a> _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DoNotSize`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.DisposeCall`1 : TearDown`1<Actual> {
    public virtual void Actual(Actual actual);
    public virtual string ToString();
}
[CompilationMappingAttribute]
public interface FsCheck.Experimental.IOperation {
    public ISet`1<IOperationResult> Needs { get; }
    public ISet`1<IOperationResult> Provides { get; }
    public abstract virtual void Gets(IOperationResult );
    public abstract virtual void Sets(IOperationResult );
    public abstract virtual ISet`1<IOperationResult> get_Needs();
    public abstract virtual ISet`1<IOperationResult> get_Provides();
    public abstract virtual void ClearDependencies();
}
[CompilationMappingAttribute]
public interface FsCheck.Experimental.IOperationResult {
    public abstract virtual void Reset();
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class FsCheck.Experimental.Machine`2 : object {
    internal int maxNumberOfCommands;
    public Arbitrary`1<Setup`2<Actual, Model>> Setup { get; }
    public int MaxNumberOfCommands { get; }
    public TearDown`1<Actual> TearDown { get; }
    public Machine`2(int maxNumberOfCommands);
    public abstract virtual Arbitrary`1<Setup`2<Actual, Model>> get_Setup();
    public abstract virtual Gen`1<Operation`2<Actual, Model>> Next(Model );
    public int get_MaxNumberOfCommands();
    public virtual TearDown`1<Actual> get_TearDown();
    public virtual IEnumerable`1<FSharpList`1<Operation`2<Actual, Model>>> ShrinkOperations(FSharpList`1<Operation`2<Actual, Model>> s);
}
[StructuredFormatDisplayAttribute("{StructuredToString}")]
[CompilationMappingAttribute]
public class FsCheck.Experimental.MachineRun`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Tuple`2<Model, Setup`2<Actual, Model>> Setup@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<Operation`2<Actual, Model>, Model>> Operations@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TearDown`1<Actual> TearDown@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int UsedSize@;
    [CompilationMappingAttribute]
public Tuple`2<Model, Setup`2<Actual, Model>> Setup { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Tuple`2<Operation`2<Actual, Model>, Model>> Operations { get; }
    [CompilationMappingAttribute]
public TearDown`1<Actual> TearDown { get; }
    [CompilationMappingAttribute]
public int UsedSize { get; }
    public string StructuredToString { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Experimental.MachineRun`2")]
public MachineRun`2(Tuple`2<Model, Setup`2<Actual, Model>> setup, FSharpList`1<Tuple`2<Operation`2<Actual, Model>, Model>> operations, TearDown`1<Actual> tearDown, int usedSize);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<Model, Setup`2<Actual, Model>> get_Setup();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Tuple`2<Operation`2<Actual, Model>, Model>> get_Operations();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TearDown`1<Actual> get_TearDown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_UsedSize();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string get_StructuredToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MachineRun`2<Actual, Model> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.MethodCall`1 : Operation`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>> {
    internal Object[] parameters;
    internal MethodInfo meth;
    internal string paramstring;
    public MethodCall`1(MethodInfo meth, Object[] parameters);
    public virtual Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string> Run(Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string> _arg1);
    public virtual Property Check(Actual actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string> _arg2);
    public virtual string ToString();
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.New`1 : Setup`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>> {
    internal Object[] parameters;
    internal ConstructorInfo ctor;
    internal string paramstring;
    public New`1(ConstructorInfo ctor, Object[] parameters);
    public virtual Actual Actual();
    public virtual Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string> Model();
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.ObjectMachine`1 : Machine`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>> {
    internal IArbMap arbMap;
    internal static FSharpSet`1<string> skipMethods;
    internal Gen`1<Setup`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>>> ctors;
    internal Gen`1<Operation`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>>> instanceMethods;
    internal static int init@166-1;
    public Arbitrary`1<Setup`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>>> Setup { get; }
    public TearDown`1<Actual> TearDown { get; }
    public ObjectMachine`1(IArbMap arbMap, FSharpOption`1<FSharpFunc`2<MethodInfo, bool>> methodFilter);
    private static ObjectMachine`1();
    public virtual Arbitrary`1<Setup`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>>> get_Setup();
    public virtual TearDown`1<Actual> get_TearDown();
    public virtual Gen`1<Operation`2<Actual, Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string>>> Next(Tuple`3<OperationResult`1<object>, OperationResult`1<object>, string> _arg1);
    [CompilerGeneratedAttribute]
internal Gen`1<Object[]> parameterGenerator(IEnumerable`1<ParameterInfo> parameters);
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class FsCheck.Experimental.Operation`2 : object {
    internal HashSet`1<IOperationResult> sets;
    internal HashSet`1<IOperationResult> gets;
    public abstract virtual Property Check(Actual , Model );
    public abstract virtual Model Run(Model );
    public virtual bool Pre(Model _arg1);
    private virtual override void FsCheck.Experimental.IOperation.Gets(IOperationResult opResult);
    private virtual override void FsCheck.Experimental.IOperation.Sets(IOperationResult opResult);
    private virtual override ISet`1<IOperationResult> FsCheck.Experimental.IOperation.get_Needs();
    private virtual override ISet`1<IOperationResult> FsCheck.Experimental.IOperation.get_Provides();
    private virtual override void FsCheck.Experimental.IOperation.ClearDependencies();
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.OperationResult`1 : object {
    internal static int resultCounter;
    internal string name@40;
    internal int counter;
    internal FSharpOption`1<a> result;
    internal static int init@37;
    public int Counter { get; }
    public a V { get; public set; }
    public OperationResult`1(FSharpOption`1<string> name);
    private static OperationResult`1();
    public int get_Counter();
    public a get_V(IOperation operation);
    public void set_V(IOperation operation, a v);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    private virtual override void FsCheck.Experimental.IOperationResult.Reset();
    [CompilerGeneratedAttribute]
internal static int nextCounter();
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class FsCheck.Experimental.Setup`2 : object {
    public abstract virtual Actual Actual();
    public abstract virtual Model Model();
    public virtual string ToString();
}
[CompilationMappingAttribute]
public static class FsCheck.Experimental.StateMachine : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("setup")]
public static Setup`2<a, b> Setup(FSharpFunc`2<Unit, a> actual, FSharpFunc`2<Unit, b> model);
    [CompilerMessageAttribute("This method is not intended for use from F#.", "10001")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("setupFunc")]
public static Setup`2<a, b> Setup(Func`1<a> actual, Func`1<b> model);
    [CompilationSourceNameAttribute("tearDown")]
public static TearDown`1<a> TearDown(FSharpFunc`2<a, Unit> run);
    [CompilerMessageAttribute("This method is not intended for use from F#.", "10001")]
[CompilationSourceNameAttribute("tearDownAction")]
public static TearDown`1<a> TearDown(Action`1<a> run);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("operationWithPrecondition")]
public static Operation`2<Actual, Model> Operation(string name, FSharpFunc`2<Model, bool> preCondition, FSharpFunc`2<Model, Model> runModel, FSharpFunc`2<Tuple`2<Actual, Model>, a> check);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("operation")]
public static Operation`2<Actual, Model> Operation(string name, FSharpFunc`2<Model, Model> runModel, FSharpFunc`2<Tuple`2<Actual, Model>, a> check);
    [CompilerMessageAttribute("This method is not intended for use from F#.", "10001")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("operationProp")]
public static Operation`2<Actual, Model> Operation(string name, Func`2<Model, Model> runModel, Func`3<Actual, Model, Property> check);
    [CompilerMessageAttribute("This method is not intended for use from F#.", "10001")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("operationBool")]
public static Operation`2<Actual, Model> Operation(string name, Func`2<Model, Model> runModel, Func`3<Actual, Model, bool> check);
    [CompilerMessageAttribute("This method is not intended for use from F#.", "10001")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("operationAction")]
public static Operation`2<Actual, Model> Operation(string name, Func`2<Model, Model> runModel, Action`2<Actual, Model> check);
    internal static Gen`1<Tuple`2<FSharpList`1<Model>, FSharpList`1<Operation`2<Actual, Model>>>> genCommandsS@247(Machine`2<Actual, Model> spec, Model state, int size);
    [CompilationSourceNameAttribute("generate")]
public static Gen`1<MachineRun`2<Actual, Model>> Generate(Machine`2<Actual, Model> spec);
    internal static FSharpFunc`2<IOperation, HashSet`1<IOperationResult>> addProvided@275(HashSet`1<IOperationResult> set);
    internal static FSharpFunc`2<HashSet`1<IOperationResult>, bool> hasNeeds@278(IOperation op);
    internal static IEnumerable`1<Tuple`2<Operation`2<Actual, Model>, Model>> runModels@274(Model initial, IEnumerable`1<Operation`2<Actual, Model>> operations);
    internal static FSharpFunc`2<IEnumerable`1<Operation`2<Actual, Model>>, FSharpOption`1<MachineRun`2<Actual, Model>>> chooseModels@294(MachineRun`2<Actual, Model> run, Tuple`2<Model, Setup`2<Actual, Model>> setup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("shrink")]
public static IEnumerable`1<MachineRun`2<Actual, Model>> Shrink(Machine`2<Actual, Model> spec, MachineRun`2<Actual, Model> run);
    internal static Property run@321(TearDown`1<Actual> teardown, Actual actual, FSharpList`1<Tuple`2<Operation`2<Actual, Model>, Model>> operations, Property property);
    [CompilationSourceNameAttribute("forOne")]
public static Property ForOne(MachineRun`2<Actual, Model> _arg1);
    [CompilationSourceNameAttribute("forAll")]
public static Property ForAll(Arbitrary`1<MachineRun`2<Actual, Model>> arb);
    [CompilationSourceNameAttribute("toProperty")]
public static Property ToProperty(Machine`2<Actual, Model> spec);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Experimental.StateMachineExtensions : object {
    [ExtensionAttribute]
public static Property ToProperty(Machine`2<Actual, Model> specification);
    [ExtensionAttribute]
public static Property ToProperty(Arbitrary`1<MachineRun`2<Actual, Model>> arbitraryRun);
    [ExtensionAttribute]
public static Property ToProperty(MachineRun`2<Actual, Model> run);
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.StopOperation`2 : Operation`2<Actual, Model> {
    public virtual Property Check(Actual _arg1, Model _arg2);
    public virtual Model Run(Model m);
    public virtual string ToString();
}
[CompilationMappingAttribute]
public class FsCheck.Experimental.TearDown`1 : object {
    public virtual void Actual(Actual _arg1);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.FixedLengthArray`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T[] item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T[] Item { get; }
    public T[] Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.FixedLengthArray`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FixedLengthArray`1(T[] item);
    [CompilationMappingAttribute]
public static FixedLengthArray`1<T> NewFixedLengthArray(T[] item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T[] get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FixedLengthArray`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public T[] get_Get();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FixedLengthArray`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ExtensionAttribute]
[SealedAttribute]
[AbstractClassAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Fluent.Arb : object {
    public static Arbitrary`1<Value> From(Gen`1<Value> gen);
    public static Arbitrary`1<Value> From(Gen`1<Value> gen, Func`2<Value, IEnumerable`1<Value>> shrinker);
    [ExtensionAttribute]
public static Arbitrary`1<T> ToArbitrary(Gen`1<T> generator);
    public static Arbitrary`1<Value> ToArbitrary(Gen`1<Value> gen, Func`2<Value, IEnumerable`1<Value>> shrinker);
    [ExtensionAttribute]
public static Arbitrary`1<U> Convert(Arbitrary`1<T> arb, Func`2<T, U> convertTo, Func`2<U, T> convertFrom);
    [ExtensionAttribute]
public static Arbitrary`1<T> Filter(Arbitrary`1<T> arb, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static Arbitrary`1<T> MapFilter(Arbitrary`1<T> arb, Func`2<T, T> map, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static Arbitrary`1<ValueTuple`2<T1, T2>> Zip(Arbitrary`1<T1> t1, Arbitrary`1<T2> t2);
    [ExtensionAttribute]
public static Arbitrary`1<T[]> Array(Arbitrary`1<T> elements);
    [ExtensionAttribute]
public static Arbitrary`1<Nullable`1<T>> Nullable(Arbitrary`1<T> value);
}
[ExtensionAttribute]
[SealedAttribute]
[AbstractClassAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Fluent.ArbMap : object {
    public static IArbMap Default { get; }
    public static IArbMap get_Default();
    [ExtensionAttribute]
public static IArbMap Merge(IArbMap map);
    [ExtensionAttribute]
public static IArbMap Merge(IArbMap map, Type instancesType);
    [ExtensionAttribute]
public static IArbMap MergeArb(IArbMap map, Arbitrary`1<T> arb);
    [ExtensionAttribute]
public static IArbMap MergeArbFactory(IArbMap map, Func`2<IArbMap, Arbitrary`1<T>> factory);
    [ExtensionAttribute]
public static IArbMap MergeArbFactory(IArbMap map, Func`2<Arbitrary`1<T>, Arbitrary`1<U>> factory);
    [ExtensionAttribute]
public static IArbMap MergeArbFactory(IArbMap map, Func`1<Arbitrary`1<T>> factory);
    [ExtensionAttribute]
public static Gen`1<T> GeneratorFor(IArbMap map);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Fluent.Gen : object {
    public static Gen`1<T> Constant(T value);
    public static Gen`1<Gen`1<T>> Fresh(Func`1<Gen`1<T>> create);
    public static Gen`1<T> Sized(Func`2<int, Gen`1<T>> createWithSize);
    public static Gen`1<int> Choose(int l, int h);
    public static Gen`1<T> Elements(IEnumerable`1<T> elements);
    public static Gen`1<T> Elements(T[] elements);
    public static Gen`1<T> GrowingElements(IEnumerable`1<T> elements);
    public static Gen`1<T> GrowingElements(T[] elements);
    public static Gen`1<T> OneOf(IEnumerable`1<Gen`1<T>> gens);
    public static Gen`1<T> OneOf(Gen`1[] gens);
    public static Gen`1<T> Frequency(IEnumerable`1<ValueTuple`2<int, Gen`1<T>>> dist);
    public static Gen`1<T> Frequency(ValueTuple`2[] dist);
    public static Gen`1<List`1<T>> CollectToList(IEnumerable`1<Gen`1<T>> source);
    public static Gen`1<List`1<U>> CollectToList(IEnumerable`1<T> source, Func`2<T, Gen`1<U>> createGen);
    public static Gen`1<T[]> CollectToArray(IEnumerable`1<Gen`1<T>> source);
    public static Gen`1<U[]> CollectToArray(IEnumerable`1<T> source, Func`2<T, Gen`1<U>> createGen);
    public static Gen`1<IEnumerable`1<T>> CollectToSequence(IEnumerable`1<Gen`1<T>> source);
    public static Gen`1<IEnumerable`1<U>> CollectToSequence(IEnumerable`1<T> source, Func`2<T, Gen`1<U>> createGen);
    public static Gen`1<T[]> Shuffle(IEnumerable`1<T> source);
    public static Gen`1<T[]> Shuffle(T[] source);
    public static Gen`1<Int32[]> Piles(int length, int sum);
    public static Gen`1<List`1<T>> SubListOf(IEnumerable`1<T> lst);
    public static Gen`1<List`1<T>> SubListOf(T[] source);
    [ExtensionAttribute]
public static Gen`1<T> Cast(Gen`1<T> gen);
    [ExtensionAttribute]
public static Gen`1<U> Select(Gen`1<T> source, Func`2<T, U> selector);
    [ExtensionAttribute]
public static Gen`1<U> SelectMany(Gen`1<T> source, Func`2<T, Gen`1<U>> selector);
    [ExtensionAttribute]
public static Gen`1<TResult> SelectMany(Gen`1<T> source, Func`2<T, Gen`1<U>> selector, Func`3<T, U, TResult> resultSelector);
    [ExtensionAttribute]
public static Gen`1<T> Resize(Gen`1<T> generator, int newSize);
    [ExtensionAttribute]
public static Gen`1<T> ScaleSize(Gen`1<T> generator, Func`2<int, int> scaleFunc);
    [ExtensionAttribute]
public static T[] Sample(Gen`1<T> generator, int numberOfSamples);
    [ExtensionAttribute]
public static T[] Sample(Gen`1<T> generator, int numberOfSamples, int size);
    [ExtensionAttribute]
public static T[] Sample(Gen`1<T> generator, int numberOfSamples, Rnd seed, int size);
    [ExtensionAttribute]
public static Gen`1<ValueTuple`2<T, T>> Two(Gen`1<T> g);
    [ExtensionAttribute]
public static Gen`1<ValueTuple`3<T, T, T>> Three(Gen`1<T> g);
    [ExtensionAttribute]
public static Gen`1<ValueTuple`4<T, T, T, T>> Four(Gen`1<T> g);
    [ExtensionAttribute]
public static Gen`1<ValueTuple`2<T1, T2>> Zip(Gen`1<T1> first, Gen`1<T2> second);
    [ExtensionAttribute]
public static Gen`1<TResult> Zip(Gen`1<T1> first, Gen`1<T2> second, Func`3<T1, T2, TResult> resultSelector);
    [ExtensionAttribute]
public static Gen`1<T> Where(Gen`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Gen`1<List`1<T>> ListOf(Gen`1<T> elementGen, int nbOfElements);
    [ExtensionAttribute]
public static Gen`1<List`1<T>> ListOf(Gen`1<T> elementGen);
    [ExtensionAttribute]
public static Gen`1<List`1<T>> NonEmptyListOf(Gen`1<T> elementGen);
    [ExtensionAttribute]
public static Gen`1<T[]> ArrayOf(Gen`1<T> elementGen, int length);
    [ExtensionAttribute]
public static Gen`1<T[]> ArrayOf(Gen`1<T> elementGen);
    [ExtensionAttribute]
public static Gen`1<T[0...,0...]> Array2DOf(Gen`1<T> elementGen, int rows, int cols);
    [ExtensionAttribute]
public static Gen`1<T[0...,0...]> Array2DOf(Gen`1<T> elementGen);
    [ExtensionAttribute]
public static Gen`1<T> Or(Gen`1<T> generator, Gen`1<T> other);
    [ExtensionAttribute]
public static Gen`1<T> OrNull(Gen`1<T> generator);
}
[ExtensionAttribute]
[SealedAttribute]
[AbstractClassAttribute]
[CompilationMappingAttribute]
public static class FsCheck.Fluent.Prop : object {
    public static Property ForAll(Arbitrary`1<Value> arb, Action`1<Value> body);
    public static Property ForAll(Arbitrary`1<Value> arb, Func`2<Value, bool> body);
    public static Property ForAll(Arbitrary`1<Value> arb, Func`2<Value, Property> body);
    public static Property ForAll(Arbitrary`1<Value> arb, Func`2<Value, Task> body);
    public static Property ForAll(Arbitrary`1<Value> arb, Func`2<Value, Task`1<bool>> body);
    public static Property ForAll(Arbitrary`1<Value> arb, Func`2<Value, Task`1<Property>> body);
    public static Property ForAll(Action`1<Value> body);
    public static Property ForAll(Func`2<Value, bool> body);
    public static Property ForAll(Func`2<Value, Property> body);
    public static Property ForAll(Func`2<Value, Task> body);
    public static Property ForAll(Func`2<Value, Task`1<bool>> body);
    public static Property ForAll(Func`2<Value, Task`1<Property>> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Action`2<V1, V2> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Func`3<V1, V2, bool> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Func`3<V1, V2, Property> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Func`3<V1, V2, Task> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Func`3<V1, V2, Task`1<bool>> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Func`3<V1, V2, Task`1<Property>> body);
    public static Property ForAll(Action`2<V1, V2> body);
    public static Property ForAll(Func`3<V1, V2, bool> body);
    public static Property ForAll(Func`3<V1, V2, Property> body);
    public static Property ForAll(Func`3<V1, V2, Task> body);
    public static Property ForAll(Func`3<V1, V2, Task`1<bool>> body);
    public static Property ForAll(Func`3<V1, V2, Task`1<Property>> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Action`3<V1, V2, V3> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Func`4<V1, V2, V3, bool> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Func`4<V1, V2, V3, Property> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Func`4<V1, V2, V3, Task> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Func`4<V1, V2, V3, Task`1<bool>> body);
    public static Property ForAll(Arbitrary`1<V1> arb1, Arbitrary`1<V2> arb2, Arbitrary`1<V3> arb3, Func`4<V1, V2, V3, Task`1<Property>> body);
    public static Property ForAll(Action`3<V1, V2, V3> body);
    public static Property ForAll(Func`4<V1, V2, V3, bool> body);
    public static Property ForAll(Func`4<V1, V2, V3, Property> body);
    public static Property ForAll(Func`4<V1, V2, V3, Task> body);
    public static Property ForAll(Func`4<V1, V2, V3, Func`1<bool>> body);
    public static Property ForAll(Func`4<V1, V2, V3, Func`1<Property>> body);
    [ExtensionAttribute]
public static Property ToProperty(bool testable);
    [ExtensionAttribute]
public static Property ToProperty(Action testable);
    [ExtensionAttribute]
public static Property ToProperty(Func`1<bool> testable);
    [ExtensionAttribute]
public static Property When(bool property, bool condition);
    [ExtensionAttribute]
public static Property When(Action property, bool condition);
    [ExtensionAttribute]
public static Property When(Func`1<bool> property, bool condition);
    [ExtensionAttribute]
public static Property When(Property property, bool condition);
    [ExtensionAttribute]
public static Property When(bool condition, Func`1<Testable> assertion);
    public static Property When(bool condition, Action assertion);
    [ExtensionAttribute]
public static Property Implies(bool condition, bool property);
    [ExtensionAttribute]
public static Property Implies(bool condition, Action property);
    [ExtensionAttribute]
public static Property Implies(bool condition, Func`1<bool> property);
    [ExtensionAttribute]
public static Property Implies(bool condition, Property property);
    [ExtensionAttribute]
public static Property Classify(Action property, bool cond, string name);
    [ExtensionAttribute]
public static Property Classify(bool property, bool cond, string name);
    [ExtensionAttribute]
public static Property Classify(Func`1<bool> property, bool cond, string name);
    [ExtensionAttribute]
public static Property Classify(Property property, bool cond, string name);
    [ExtensionAttribute]
public static Property Trivial(Action property, bool condition);
    [ExtensionAttribute]
public static Property Trivial(bool property, bool condition);
    [ExtensionAttribute]
public static Property Trivial(Func`1<bool> property, bool condition);
    [ExtensionAttribute]
public static Property Trivial(Property property, bool condition);
    [ExtensionAttribute]
public static Property Collect(Action property, CollectedValue v);
    [ExtensionAttribute]
public static Property Collect(bool property, CollectedValue v);
    [ExtensionAttribute]
public static Property Collect(Func`1<bool> property, CollectedValue v);
    [ExtensionAttribute]
public static Property Collect(Property property, CollectedValue v);
    [ExtensionAttribute]
public static Property Label(Action property, string label);
    [ExtensionAttribute]
public static Property Label(bool property, string label);
    [ExtensionAttribute]
public static Property Label(Func`1<bool> property, string label);
    [ExtensionAttribute]
public static Property Label(Property property, string label);
    public static a Discard();
    [ExtensionAttribute]
public static Property And(bool left, Action right);
    [ExtensionAttribute]
public static Property And(bool left, bool right);
    [ExtensionAttribute]
public static Property And(bool left, Func`1<bool> right);
    [ExtensionAttribute]
public static Property And(bool left, Property right);
    [ExtensionAttribute]
public static Property And(Property left, Action right);
    [ExtensionAttribute]
public static Property And(Property left, bool right);
    [ExtensionAttribute]
public static Property And(Property left, Func`1<bool> right);
    [ExtensionAttribute]
public static Property And(Property left, Property right);
    [ExtensionAttribute]
public static Property Or(bool left, Action right);
    [ExtensionAttribute]
public static Property Or(bool left, bool right);
    [ExtensionAttribute]
public static Property Or(bool left, Func`1<bool> right);
    [ExtensionAttribute]
public static Property Or(bool left, Property right);
    [ExtensionAttribute]
public static Property Or(Property left, Action right);
    [ExtensionAttribute]
public static Property Or(Property left, bool right);
    [ExtensionAttribute]
public static Property Or(Property left, Func`1<bool> right);
    [ExtensionAttribute]
public static Property Or(Property left, Property right);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.Arb : object {
    public static Gen`1<Value> toGen(Arbitrary`1<Value> arb);
    public static FSharpFunc`2<Value, IEnumerable`1<Value>> toShrink(Arbitrary`1<Value> arb);
    [CompilationSourceNameAttribute("fromGen")]
public static Arbitrary`1<Value> From(Gen`1<Value> gen);
    [CompilationSourceNameAttribute("fromGenShrink")]
public static Arbitrary`1<Value> From(Gen`1<Value> gen, FSharpFunc`2<Value, IEnumerable`1<Value>> shrinker);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("convert")]
public static Arbitrary`1<U> Convert(FSharpFunc`2<T, U> convertTo, FSharpFunc`2<U, T> convertFrom, Arbitrary`1<T> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static Arbitrary`1<T> Filter(FSharpFunc`2<T, bool> pred, Arbitrary`1<T> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapFilter")]
public static Arbitrary`1<T> MapFilter(FSharpFunc`2<T, T> mapper, FSharpFunc`2<T, bool> pred, Arbitrary`1<T> a);
    public static Arbitrary`1<Tuple`2<T1, T2>> zip(Arbitrary`1<T1> t1, Arbitrary`1<T2> t2);
    public static Arbitrary`1<T[]> array(Arbitrary`1<T> elements);
    public static Arbitrary`1<FSharpOption`1<T>> option(Arbitrary`1<T> value);
    public static Arbitrary`1<Nullable`1<T>> nullable(Arbitrary`1<T> value);
    public static Arbitrary`1<FSharpList`1<T>> list(Arbitrary`1<T> elements);
    public static Arbitrary`1<FSharpFunc`2<T, U>> pureFunction(Arbitrary`1<U> target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arbitrary`1<FSharpFunc`2<T, U>> throwingFunction(IEnumerable`1<Exception> exceptions, Arbitrary`1<U> target);
    public static Arbitrary`1<FSharpSet`1<T>> set(Arbitrary`1<T> elements);
    public static Arbitrary`1<FSharpMap`2<TKey, TValue>> mapKV(Arbitrary`1<TKey> keys, Arbitrary`1<TValue> values);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.ArbMap : object {
    [CompilationMappingAttribute]
public static IArbMap defaults { get; }
    public static IArbMap get_defaults();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArbMap mergeWithType(Type instancesType, IArbMap existingMap);
    public static IArbMap mergeWith(IArbMap existingMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArbMap mergeFactory(FSharpFunc`2<Unit, Arbitrary`1<b>> factory, IArbMap existingMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArbMap mergeArbFactory(FSharpFunc`2<Arbitrary`1<a>, Arbitrary`1<b>> factory, IArbMap existingMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArbMap mergeMapFactory(FSharpFunc`2<IArbMap, Arbitrary`1<b>> factory, IArbMap existingMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArbMap mergeArb(Arbitrary`1<a> arb, IArbMap existingMap);
    public static Arbitrary`1<T> arbitrary(IArbMap arbMap);
    public static Gen`1<T> generate(IArbMap arbMap);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.ArbPatterns : object {
    public static FSharpFunc`2<a, b> |Fun|(Function`2<a, b> f);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.Gen : object {
    [CompilationMappingAttribute]
internal static Gen`1<double> double { get; }
    [CompilationMappingAttribute]
internal static Gen`1<bool> bool { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a run(int size, Rnd rnd, Gen`1<a> _arg1);
    internal static Gen`1<U> promote(FSharpFunc`2<FSharpFunc`2<Gen`1<a>, a>, U> create);
    [CompilationSourceNameAttribute("constant")]
public static Gen`1<T> Constant(T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static Gen`1<U> Map(FSharpFunc`2<T, U> f, Gen`1<T> _arg1);
    [CompilationSourceNameAttribute("fresh")]
public static Gen`1<T> Fresh(FSharpFunc`2<Unit, T> create);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("apply")]
public static Gen`1<U> Apply(Gen`1<FSharpFunc`2<T, U>> _arg2, Gen`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("bind")]
public static Gen`1<U> Bind(FSharpFunc`2<T, Gen`1<U>> k, Gen`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static Gen`1<c> Map(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, Gen`1<a> _arg2, Gen`1<b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map3")]
public static Gen`1<d> Map(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> f, Gen`1<a> _arg3, Gen`1<b> _arg2, Gen`1<c> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map4")]
public static Gen`1<e> Map(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, e>>>> f, Gen`1<a> _arg4, Gen`1<b> _arg3, Gen`1<c> _arg2, Gen`1<d> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map5")]
public static Gen`1<f> Map(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, f>>>>> f, Gen`1<a> _arg5, Gen`1<b> _arg4, Gen`1<c> _arg3, Gen`1<d> _arg2, Gen`1<e> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map6")]
public static Gen`1<g> Map(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, g>>>>>> f, Gen`1<a> _arg6, Gen`1<b> _arg5, Gen`1<c> _arg4, Gen`1<d> _arg3, Gen`1<e> _arg2, Gen`1<f> _arg1);
    [CompilationSourceNameAttribute("sized")]
public static Gen`1<T> Sized(FSharpFunc`2<int, Gen`1<T>> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("resize")]
public static Gen`1<T> Resize(int newSize, Gen`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("scaleSize")]
public static Gen`1<T> ScaleSize(FSharpFunc`2<int, int> f, Gen`1<T> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sampleWithSeed")]
public static T[] Sample(Rnd seed, int size, int nbSamples, Gen`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sampleWithSize")]
public static T[] Sample(int size, int nbSamples, Gen`1<T> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("sample")]
public static T[] Sample(int nbSamples, Gen`1<T> gen);
    [CompilationSourceNameAttribute("choose")]
public static Gen`1<int> Choose(int l, int h);
    [CompilationSourceNameAttribute("choose64")]
public static Gen`1<long> Choose64(long l, long h);
    internal static Gen`1<double> get_double();
    [CompilationSourceNameAttribute("elements")]
public static Gen`1<T> Elements(IEnumerable`1<T> xs);
    [CompilationSourceNameAttribute("growingElements")]
public static Gen`1<T> GrowingElements(IEnumerable`1<T> xs);
    [CompilationSourceNameAttribute("oneof")]
public static Gen`1<T> OneOf(IEnumerable`1<Gen`1<T>> gens);
    internal static Gen`1<T> pick@246(ListAccessWrapper`1<Tuple`2<int, Gen`1<T>>> xs, int i, int n);
    [CompilationSourceNameAttribute("frequency")]
public static Gen`1<T> Frequency(IEnumerable`1<Tuple`2<int, Gen`1<T>>> dist);
    [CompilationSourceNameAttribute("two")]
public static Gen`1<Tuple`2<T, T>> Two(Gen`1<T> g);
    [CompilationSourceNameAttribute("three")]
public static Gen`1<Tuple`3<T, T, T>> Three(Gen`1<T> g);
    [CompilationSourceNameAttribute("four")]
public static Gen`1<Tuple`4<T, T, T, T>> Four(Gen`1<T> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip")]
public static Gen`1<Tuple`2<T1, T2>> Zip(Gen`1<T1> f, Gen`1<T2> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("zip3")]
public static Gen`1<Tuple`3<T1, T2, T3>> Zip(Gen`1<T1> f, Gen`1<T2> g, Gen`1<T3> h);
    internal static ValueTuple`2<FSharpList`1<a>, Rnd> go@284(FSharpList`1<Gen`1<a>> gs, FSharpList`1<a> acc, int size, Rnd r0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collectToList")]
public static Gen`1<FSharpList`1<U>> CollectToList(FSharpFunc`2<T, Gen`1<U>> f, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collectToArray")]
public static Gen`1<U[]> CollectToArray(FSharpFunc`2<T, Gen`1<U>> f, IEnumerable`1<T> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("collectToSeq")]
public static Gen`1<IEnumerable`1<U>> CollectToSeq(FSharpFunc`2<T, Gen`1<U>> f, IEnumerable`1<T> source);
    [CompilationSourceNameAttribute("sequenceToList")]
public static Gen`1<FSharpList`1<T>> SequenceToList(IEnumerable`1<Gen`1<T>> source);
    [CompilationSourceNameAttribute("sequenceToArray")]
public static Gen`1<T[]> SequenceToArray(IEnumerable`1<Gen`1<T>> source);
    [CompilationSourceNameAttribute("sequenceToSeq")]
public static Gen`1<IEnumerable`1<T>> SequenceToSeq(IEnumerable`1<Gen`1<T>> source);
    internal static Gen`1<FSharpOption`1<T>> tryValue@361(FSharpFunc`2<T, bool> predicate, Gen`1<T> generator, int k, int s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryWhere")]
public static Gen`1<FSharpOption`1<T>> TryWhere(FSharpFunc`2<T, bool> predicate, Gen`1<T> generator);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFilter")]
public static Gen`1<FSharpOption`1<T>> TryFilter(FSharpFunc`2<T, bool> predicate, Gen`1<T> generator);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("where")]
public static Gen`1<T> Where(FSharpFunc`2<T, bool> predicate, Gen`1<T> generator);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static Gen`1<T> Filter(FSharpFunc`2<T, bool> predicate, Gen`1<T> generator);
    internal static Gen`1<a[]> shuffleInPlace(a[] arr);
    [CompilationSourceNameAttribute("shuffle")]
public static Gen`1<T[]> Shuffle(IEnumerable`1<T> xs);
    internal static Gen`1<Int32[]> genSorted@427(int p, int n, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("piles")]
public static Gen`1<Int32[]> Piles(int length, int sum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("listOfLength")]
public static Gen`1<FSharpList`1<T>> ListOf(int length, Gen`1<T> gen);
    [CompilationSourceNameAttribute("listOf")]
public static Gen`1<FSharpList`1<T>> ListOf(Gen`1<T> gen);
    [CompilationSourceNameAttribute("nonEmptyListOf")]
public static Gen`1<FSharpList`1<T>> NonEmptyListOf(Gen`1<T> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("arrayOfLength")]
public static Gen`1<T[]> ArrayOf(int length, Gen`1<T> gen);
    [CompilationSourceNameAttribute("arrayOf")]
public static Gen`1<T[]> ArrayOf(Gen`1<T> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("array2DOfDim")]
public static Gen`1<T[0...,0...]> Array2DOf(int rows, int cols, Gen`1<T> gen);
    [CompilationSourceNameAttribute("array2DOf")]
public static Gen`1<T[0...,0...]> Array2DOf(Gen`1<T> gen);
    internal static Gen`1<bool> get_bool();
    [CompilationSourceNameAttribute("subListOf")]
public static Gen`1<FSharpList`1<T>> SubListOf(IEnumerable`1<T> lst);
    public static Gen`1<FSharpOption`1<T>> optionOf(Gen`1<T> g);
    [CompilerGeneratedAttribute]
internal static U action@1-3(T from, FSharpFunc`2<Unit, U> createTo, Dictionary`2<Key`1<T>, U> cache, Unit _arg1);
    internal static U getOrUpdate@535(T from, FSharpFunc`2<Unit, U> createTo, Dictionary`2<Key`1<T>, U> cache);
    internal static Gen`1<FSharpFunc`2<T, U>> pureFunction(Gen`1<U> _arg1);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.GenBuilder : object {
    [CompilationMappingAttribute]
internal static Gen`1<Unit> zero { get; }
    [CompilationMappingAttribute]
public static GenBuilder gen { get; }
    internal static Gen`1<Unit> get_zero();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<a> tryFinally(Gen`1<a> _arg1, FSharpFunc`2<Unit, Unit> handler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<a> tryWith(Gen`1<a> _arg1, FSharpFunc`2<Exception, Gen`1<a>> handler);
    internal static void dispose(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<b> using(a r, FSharpFunc`2<a, Gen`1<b>> f);
    internal static Gen`1<T> delay(FSharpFunc`2<Unit, Gen`1<T>> createGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<Unit> whileDo(FSharpFunc`2<Unit, bool> p, Gen`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<Unit> forDo(a s, FSharpFunc`2<b, Gen`1<c>> f);
    [CompilerGeneratedAttribute]
internal static Rnd go@24-2(FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> m, FSharpFunc`2<Unit, bool> pred, int size, Rnd rInit);
    [CompilerGeneratedAttribute]
internal static Rnd go@24-3(FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<U, Rnd>>> m, FSharpFunc`2<Unit, bool> pred, int size, Rnd rInit);
    [CompilerGeneratedAttribute]
internal static Gen`1<Unit> f@18(FSharpFunc`2<T, Gen`1<U>> f, IEnumerator`1<T> ie);
    public static GenBuilder get_gen();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.GenOperators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Gen`1<U> op_LessBangGreater(FSharpFunc`2<T, U> f, Gen`1<T> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Gen`1<U> op_LessMultiplyGreater(Gen`1<FSharpFunc`2<T, U>> f, Gen`1<T> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Gen`1<U> op_GreaterGreaterEquals(Gen`1<T> gen, FSharpFunc`2<T, Gen`1<U>> f);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.Prop : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forAll")]
public static Property ForAll(Arbitrary`1<Value> arb, FSharpFunc`2<Value, Testable> body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("given")]
public static Property Given(bool condition, TestableIfTrue iftrue, TestableIfFalse ifFalse);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Property filter(bool condition, Testable assertion);
    [CompilationSourceNameAttribute("throws")]
public static Property Throws(Lazy`1<Testable> p);
    internal static FSharpFunc`2<a, Property> stamp(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("classify")]
public static FSharpFunc`2<Testable, Property> Classify(bool b, string name);
    [CompilationSourceNameAttribute("trivial")]
public static FSharpFunc`2<Testable, Property> Trivial(bool b);
    [CompilationSourceNameAttribute("collect")]
public static FSharpFunc`2<Testable, Property> Collect(CollectedValue v);
    [CompilationSourceNameAttribute("label")]
public static FSharpFunc`2<Testable, Property> Label(string l);
    [CompilationSourceNameAttribute("ofTestable")]
public static Property OfTestable(Testable testable);
    [CompilationSourceNameAttribute("discard")]
public static a Discard();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FsCheck.FSharp.PropOperators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Property op_EqualsEqualsGreater(bool condition, Testable assertion);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Property op_DotAmpDot(LeftTestable l, RightTestable r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Property op_DotBarDot(LeftTestable l, RightTestable r);
}
[StructuredFormatDisplayAttribute("{StructuredDisplayAsTable}")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Function`2 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<a, b> item2;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> Item1 { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, b> Item2 { get; }
    public FSharpFunc`2<a, b> Value { get; }
    public FSharpList`1<Tuple`2<a, b>> Table { get; }
    public string StructuredDisplayAsTable { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Function`2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Function`2(FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> item1, FSharpFunc`2<a, b> item2);
    [CompilationMappingAttribute]
public static Function`2<a, b> NewF(FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> item1, FSharpFunc`2<a, b> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, b> get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    public FSharpFunc`2<a, b> get_Value();
    public FSharpList`1<Tuple`2<a, b>> get_Table();
    public string get_StructuredDisplayAsTable();
    public virtual string ToString();
    public static Function`2<a, b> From(FSharpFunc`2<a, b> f);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Gen`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Gen`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Gen`1(FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> item);
    [CompilationMappingAttribute]
internal static Gen`1<T> NewGen(FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<int, FSharpFunc`2<Rnd, ValueTuple`2<T, Rnd>>> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    private virtual override Gen`1<object> FsCheck.IGen.get_AsGenObject();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.HostName : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.HostName")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal HostName(string item);
    [CompilationMappingAttribute]
public static HostName NewHostName(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HostName obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HostName obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal interface FsCheck.IArbitrary {
    public Gen`1<object> GeneratorObj { get; }
    public abstract virtual Gen`1<object> get_GeneratorObj();
    public abstract virtual IEnumerable`1<object> ShrinkerObj(object );
}
[CompilationMappingAttribute]
public interface FsCheck.IArbMap {
    public abstract virtual Arbitrary`1<object> ArbFor(Type );
    public abstract virtual Arbitrary`1<T> ArbFor();
    public abstract virtual IArbMap MergeFactory(Func`2<a, Arbitrary`1<b>> );
}
[InterfaceAttribute]
[CompilationMappingAttribute]
internal interface FsCheck.IGen {
    public Gen`1<object> AsGenObject { get; }
    public abstract virtual Gen`1<object> get_AsGenObject();
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.Common : object {
    [CompilerGeneratedAttribute]
internal static b action@1(IDictionary`2<a, b> memo, FSharpFunc`2<a, b> f, a n, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b memoizeWith(IDictionary`2<a, b> memo, FSharpFunc`2<a, b> f, a n);
    internal static FSharpFunc`2<a, b> memoize(FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalsOn(FSharpFunc`2<T, a> f, T x, object yobj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hashOn(FSharpFunc`2<a, b> f, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compareOn(FSharpFunc`2<T, a> f, T x, object yobj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<b> |MapContains|_|(a key, FSharpMap`2<a, b> value);
    internal static IEnumerable`1<a> loop@50(FSharpFunc`2<a, bool> predicate, IEnumerator`1<a> en);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a> takeWhilePlusLast(FSharpFunc`2<a, bool> predicate, IEnumerable`1<a> s);
    internal static Tuple`2<a, b> ofValue(ValueTuple`2<a, b> _arg1);
    internal static bool isPowerOf2(a n);
    internal static bool isPowerOf2$W(FSharpFunc`2<Unit, b> get_One, FSharpFunc`2<Unit, a> get_Zero, FSharpFunc`2<a, FSharpFunc`2<a, a>> op_BitwiseAnd, FSharpFunc`2<a, FSharpFunc`2<b, a>> op_Subtraction, a n);
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.Data : object {
    [CompilationMappingAttribute]
internal static String[] topLevelDomains { get; }
    [CompilationMappingAttribute]
internal static String[] commonTopLevelDomains { get; }
    internal static String[] get_topLevelDomains();
    internal static String[] get_commonTopLevelDomains();
}
[SealedAttribute]
[AbstractClassAttribute]
[CompilationMappingAttribute]
internal static class FsCheck.Internals.Default : object {
    internal static Arbitrary`1<Unit> Unit@;
    internal static Arbitrary`1<bool> Bool@;
    internal static Arbitrary`1<byte> Byte@;
    internal static Arbitrary`1<sbyte> SByte@;
    internal static Arbitrary`1<short> Int16@;
    internal static Arbitrary`1<DoNotSize`1<short>> DoNotSizeInt16@;
    internal static Arbitrary`1<ushort> UInt16@;
    internal static Arbitrary`1<DoNotSize`1<ushort>> DoNotSizeUInt16@;
    internal static Arbitrary`1<int> Int32@;
    internal static Arbitrary`1<DoNotSize`1<int>> DoNotSizeInt32@;
    internal static Arbitrary`1<UInt32> UInt32@;
    internal static Arbitrary`1<DoNotSize`1<UInt32>> DoNotSizeUInt32@;
    internal static Arbitrary`1<long> Int64@;
    internal static Arbitrary`1<DoNotSize`1<long>> DoNotSizeInt64@;
    internal static Arbitrary`1<ulong> UInt64@;
    internal static Arbitrary`1<DoNotSize`1<ulong>> DoNotSizeUInt64@;
    internal static Arbitrary`1<NormalFloat> NormalFloat@;
    internal static Arbitrary`1<double> Float@;
    internal static Arbitrary`1<float> Float32@;
    internal static Arbitrary`1<decimal> Decimal@;
    internal static Arbitrary`1<DoNotSize`1<decimal>> DoNotSizeDecimal@;
    internal static Arbitrary`1<Complex> Complex@;
    internal static Arbitrary`1<char> Char@;
    internal static Arbitrary`1<string> String@;
    internal static Arbitrary`1<object> Object@;
    internal static Arbitrary`1<DateTime> DateTime@;
    internal static Arbitrary`1<DoNotSize`1<DateTime>> DoNotSizeDateTime@;
    internal static Arbitrary`1<TimeSpan> TimeSpan@;
    internal static Arbitrary`1<DateTimeOffset> DateTimeOffset@;
    internal static Arbitrary`1<NegativeInt> NegativeInt@;
    internal static Arbitrary`1<NonNegativeInt> NonNegativeInt@;
    internal static Arbitrary`1<PositiveInt> PositiveInt@;
    internal static Arbitrary`1<NonZeroInt> NonZeroInt@;
    internal static Arbitrary`1<IntWithMinMax> IntWithMinMax@;
    internal static Arbitrary`1<Interval> Interval@;
    internal static Arbitrary`1<StringNoNullChar> StringNoNullChar@;
    internal static Arbitrary`1<NonEmptyString> NonEmptyString@;
    internal static Arbitrary`1<NonWhiteSpaceString> NonWhiteSpaceString@;
    internal static Arbitrary`1<XmlEncodedString> XmlEncodedString@;
    internal static Arbitrary`1<UnicodeChar> UnicodeChar@;
    internal static Arbitrary`1<UnicodeString> UnicodeString@;
    internal static Arbitrary`1<CultureInfo> Culture@;
    internal static Arbitrary`1<Guid> Guid@;
    internal static Arbitrary`1<ConsoleKeyInfo> ConsoleKeyInfo@;
    internal static Arbitrary`1<IPv4Address> IPv4Address@;
    internal static Arbitrary`1<IPv6Address> IPv6Address@;
    internal static Arbitrary`1<IPAddress> IPAddress@;
    internal static Arbitrary`1<HostName> HostName@;
    internal static Arbitrary`1<MailAddress> MailAddress@;
    internal static Arbitrary`1<BigInteger> BigInt@;
    internal static int init@15;
    internal static Arbitrary`1<Unit> Unit { get; }
    internal static Arbitrary`1<bool> Bool { get; }
    internal static Arbitrary`1<byte> Byte { get; }
    internal static Arbitrary`1<sbyte> SByte { get; }
    internal static Arbitrary`1<short> Int16 { get; }
    internal static Arbitrary`1<DoNotSize`1<short>> DoNotSizeInt16 { get; }
    internal static Arbitrary`1<ushort> UInt16 { get; }
    internal static Arbitrary`1<DoNotSize`1<ushort>> DoNotSizeUInt16 { get; }
    internal static Arbitrary`1<int> Int32 { get; }
    internal static Arbitrary`1<DoNotSize`1<int>> DoNotSizeInt32 { get; }
    internal static Arbitrary`1<UInt32> UInt32 { get; }
    internal static Arbitrary`1<DoNotSize`1<UInt32>> DoNotSizeUInt32 { get; }
    internal static Arbitrary`1<long> Int64 { get; }
    internal static Arbitrary`1<DoNotSize`1<long>> DoNotSizeInt64 { get; }
    internal static Arbitrary`1<ulong> UInt64 { get; }
    internal static Arbitrary`1<DoNotSize`1<ulong>> DoNotSizeUInt64 { get; }
    internal static Arbitrary`1<NormalFloat> NormalFloat { get; }
    internal static Arbitrary`1<double> Float { get; }
    internal static Arbitrary`1<float> Float32 { get; }
    internal static Arbitrary`1<decimal> Decimal { get; }
    internal static Arbitrary`1<DoNotSize`1<decimal>> DoNotSizeDecimal { get; }
    internal static Arbitrary`1<Complex> Complex { get; }
    internal static Arbitrary`1<char> Char { get; }
    internal static Arbitrary`1<string> String { get; }
    internal static Arbitrary`1<object> Object { get; }
    internal static Arbitrary`1<DateTime> DateTime { get; }
    internal static Arbitrary`1<DoNotSize`1<DateTime>> DoNotSizeDateTime { get; }
    internal static Arbitrary`1<TimeSpan> TimeSpan { get; }
    internal static Arbitrary`1<DateTimeOffset> DateTimeOffset { get; }
    internal static Arbitrary`1<NegativeInt> NegativeInt { get; }
    internal static Arbitrary`1<NonNegativeInt> NonNegativeInt { get; }
    internal static Arbitrary`1<PositiveInt> PositiveInt { get; }
    internal static Arbitrary`1<NonZeroInt> NonZeroInt { get; }
    internal static Arbitrary`1<IntWithMinMax> IntWithMinMax { get; }
    internal static Arbitrary`1<Interval> Interval { get; }
    internal static Arbitrary`1<StringNoNullChar> StringNoNullChar { get; }
    internal static Arbitrary`1<NonEmptyString> NonEmptyString { get; }
    internal static Arbitrary`1<NonWhiteSpaceString> NonWhiteSpaceString { get; }
    internal static Arbitrary`1<XmlEncodedString> XmlEncodedString { get; }
    internal static Arbitrary`1<UnicodeChar> UnicodeChar { get; }
    internal static Arbitrary`1<UnicodeString> UnicodeString { get; }
    internal static Arbitrary`1<CultureInfo> Culture { get; }
    internal static Arbitrary`1<Guid> Guid { get; }
    internal static Arbitrary`1<ConsoleKeyInfo> ConsoleKeyInfo { get; }
    internal static Arbitrary`1<IPv4Address> IPv4Address { get; }
    internal static Arbitrary`1<IPv6Address> IPv6Address { get; }
    internal static Arbitrary`1<IPAddress> IPAddress { get; }
    internal static Arbitrary`1<HostName> HostName { get; }
    internal static Arbitrary`1<MailAddress> MailAddress { get; }
    internal static Arbitrary`1<BigInteger> BigInt { get; }
    private static Default();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<Unit> get_Unit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<bool> get_Bool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<byte> get_Byte();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<sbyte> get_SByte();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<short> get_Int16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<short>> get_DoNotSizeInt16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<ushort> get_UInt16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<ushort>> get_DoNotSizeUInt16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<int> get_Int32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<int>> get_DoNotSizeInt32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<UInt32> get_UInt32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<UInt32>> get_DoNotSizeUInt32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<long> get_Int64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<long>> get_DoNotSizeInt64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<ulong> get_UInt64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<ulong>> get_DoNotSizeUInt64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NormalFloat> get_NormalFloat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<double> get_Float();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<float> get_Float32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<decimal> get_Decimal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<decimal>> get_DoNotSizeDecimal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<Complex> get_Complex();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<char> get_Char();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<string> get_String();
    internal static Arbitrary`1<T[]> Array(Arbitrary`1<T> elements);
    internal static Arbitrary`1<FSharpOption`1<T>> Option(Arbitrary`1<T> value);
    internal static Arbitrary`1<NonNull`1<T>> NonNull(Arbitrary`1<T> value);
    internal static Arbitrary`1<Nullable`1<T>> Nullable(Arbitrary`1<T> value);
    internal static Arbitrary`1<FSharpList`1<T>> FsList(Arbitrary`1<T> elements);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<object> get_Object();
    internal static Arbitrary`1<T[0...,0...]> Array2D(Arbitrary`1<T> elements);
    [CompilationSourceNameAttribute("FSharpFunc")]
internal static Arbitrary`1<FSharpFunc`2<T, U>> FSharpFunc(Arbitrary`1<U> target);
    [CompilationSourceNameAttribute("ThrowingFSharpFunc")]
internal static Arbitrary`1<ThrowingFunction`2<T, U>> ThrowingFSharpFunc(Arbitrary`1<U> target);
    internal static Arbitrary`1<Function`2<T, U>> Function(Arbitrary`1<U> target);
    internal static Arbitrary`1<Func`1<U>> SystemFunc(Arbitrary`1<U> target);
    internal static Arbitrary`1<Func`2<l, U>> SystemFunc1(Arbitrary`1<U> target);
    internal static Arbitrary`1<Func`3<j, k, U>> SystemFunc2(Arbitrary`1<U> target);
    internal static Arbitrary`1<Func`4<g, h, i, U>> SystemFunc3(Arbitrary`1<U> target);
    internal static Arbitrary`1<Action> SystemAction();
    internal static Arbitrary`1<Action`1<f>> SystemAction1();
    internal static Arbitrary`1<Action`2<d, e>> SystemAction2();
    internal static Arbitrary`1<Action`3<a, b, c>> SystemAction3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DateTime> get_DateTime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DoNotSize`1<DateTime>> get_DoNotSizeDateTime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<TimeSpan> get_TimeSpan();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<DateTimeOffset> get_DateTimeOffset();
    internal static Arbitrary`1<KeyValuePair`2<K, V>> KeyValuePair(Arbitrary`1<K> key, Arbitrary`1<V> value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NegativeInt> get_NegativeInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NonNegativeInt> get_NonNegativeInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<PositiveInt> get_PositiveInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NonZeroInt> get_NonZeroInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<IntWithMinMax> get_IntWithMinMax();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<Interval> get_Interval();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<StringNoNullChar> get_StringNoNullChar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NonEmptyString> get_NonEmptyString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<NonWhiteSpaceString> get_NonWhiteSpaceString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<XmlEncodedString> get_XmlEncodedString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<UnicodeChar> get_UnicodeChar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<UnicodeString> get_UnicodeString();
    internal static Arbitrary`1<FSharpSet`1<T>> Set(Arbitrary`1<T> elements);
    internal static Arbitrary`1<FSharpMap`2<K, V>> Map(Arbitrary`1<K> keys, Arbitrary`1<V> values);
    internal static Arbitrary`1<NonEmptyArray`1<T>> NonEmptyArray(Arbitrary`1<T> elements);
    internal static Arbitrary`1<NonEmptySet`1<T>> NonEmptySet(Arbitrary`1<T> elements);
    internal static Arbitrary`1<FixedLengthArray`1<T>> FixedLengthArray(Arbitrary`1<T> elements);
    internal static Arbitrary`1<List`1<T>> List(Arbitrary`1<T> elements);
    internal static Arbitrary`1<IList`1<T>> IList(Arbitrary`1<T> elements);
    internal static Arbitrary`1<ICollection`1<T>> ICollection(Arbitrary`1<T> elements);
    internal static Arbitrary`1<Dictionary`2<K, V>> Dictionary(Arbitrary`1<K> keys, Arbitrary`1<V> values);
    internal static Arbitrary`1<IDictionary`2<K, V>> IDictionary(Arbitrary`1<K> keys, Arbitrary`1<V> values);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<CultureInfo> get_Culture();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<Guid> get_Guid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<ConsoleKeyInfo> get_ConsoleKeyInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<IPv4Address> get_IPv4Address();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<IPv6Address> get_IPv6Address();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<IPAddress> get_IPAddress();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<HostName> get_HostName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<MailAddress> get_MailAddress();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Arbitrary`1<BigInteger> get_BigInt();
    internal static Arbitrary`1<DoNotShrink`1<T>> DoNotShrink(Arbitrary`1<T> any);
    internal static Arbitrary`1<T> Derive(IArbMap arbMap);
}
[CompilationMappingAttribute]
public static class FsCheck.Internals.Numeric : object {
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.Reflect : object {
    internal static bool isRecordType(Type ty);
    internal static bool isUnionType(Type ty);
    internal static bool isTupleType(Type ty);
    internal static IEnumerable`1<ConstructorInfo> getPublicCtors(Type ty);
    internal static MethodInfo getPropertyMethod(PropertyInfo prop);
    internal static IEnumerable`1<PropertyInfo> getProperties(Type ty);
    internal static bool isInitOnlyProperty(PropertyInfo property);
    internal static bool isImmutableRecordLikeType(Type ty);
    internal static bool isCSharpRecordType(Type ty);
    internal static bool isImmutableCollectionType(Type ty);
    internal static Type[] getRecordFieldTypes(Type recordType);
    internal static FSharpFunc`2<Object[], object> getRecordConstructor(Type recordType);
    internal static FSharpFunc`2<object, Object[]> getRecordReader(Type recordType);
    internal static IEnumerable`1<Type> getImmutableRecordLikeTypeFields(Type recordType);
    internal static FSharpFunc`2<Object[], object> getImmutableRecordLikeTypeConstructor(Type t);
    internal static IEnumerable`1<Type> getCSharpRecordFields(Type recordType);
    [CompilerGeneratedAttribute]
internal static int mapping@1(String[] propNames, ParameterInfo ctorParam);
    internal static FSharpFunc`2<Object[], object> getCSharpRecordConstructor(Type t);
    internal static FSharpFunc`2<a, Object[]> getCSharpRecordReader(Type recordType);
    internal static FSharpList`1<Tuple`2<string, Tuple`4<int, FSharpList`1<Type>, FSharpFunc`2<Object[], object>, FSharpFunc`2<object, Object[]>>>> getUnionCases(Type unionType);
    internal static FSharpFunc`2<object, int> getUnionTagReader(Type unionType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void resolve(Dictionary`2<Type, Type> acc, Type a, Type f);
    internal static void action@1-2(Dictionary`2<Type, Type> typeMap, object a, ParameterInfo f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object invokeMethod(MethodInfo m, FSharpOption`1<a> target, Object[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, object> getImmutableCollection1Constructor(Type t, Type elementType);
    internal static FSharpFunc`2<a, object> getImmutableCollection1Reader(Type elementType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, object> getImmutableCollection2Constructor(Type t, Type[] genericArguments);
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.ReflectiveGenerator : object {
    [CompilerGeneratedAttribute]
internal static Gen`1<Enum> enumOfType$cont@41(Type t, FSharpList`1<object> elems, Type elementType, Unit unitVar);
    internal static Gen`1<Enum> enumOfType(Type t);
    internal static IEnumerable`1<Type> children@61(Type t);
    internal static bool isRecursive@60(Type fieldType, Type containingType, FSharpSet`1<string> seen);
    internal static Gen`1<a> productGen@78(FSharpFunc`2<Type, Gen`1<object>> getGenerator, IEnumerable`1<Type> ts, FSharpFunc`2<Object[], a> create);
    internal static int unionSize@104(Type t, FSharpList`1<Type> ts);
    internal static FSharpList`1<Gen`1<object>> small@111(FSharpList`1<Tuple`2<int, Lazy`1<Gen`1<object>>>> gs, int lowest, Unit unitVar0);
    internal static FSharpList`1<Gen`1<object>> large@112(FSharpList`1<Tuple`2<int, Lazy`1<Gen`1<object>>>> gs, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static object reflectObj$cont@130(FSharpFunc`2<Type, Gen`1<object>> getGenerator, Type t, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object reflectObj(FSharpFunc`2<Type, Gen`1<object>> getGenerator, Type t);
    internal static FSharpFunc`2<Type, Gen`1<object>> reflectGenObj(FSharpFunc`2<Type, Gen`1<object>> getGenerator);
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.ReflectiveShrinker : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<object, FSharpList`1<object>> children0(FSharpSet`1<string> seen, Type tFind, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<object, FSharpList`1<object>> children1(FSharpSet`1<string> seen, Type tFind, Type t);
    internal static IEnumerable`1<Tuple`3<FSharpList`1<c>, c, FSharpList`1<c>>> split3'@45(FSharpList`1<c> front, c m, FSharpList`1<c> back);
    internal static IEnumerable`1<Tuple`3<FSharpList`1<b>, b, FSharpList`1<b>>> split3@44(FSharpList`1<b> l);
    internal static IEnumerable`1<d> shrinkChildren@51(FSharpFunc`2<Type, FSharpFunc`2<object, IEnumerable`1<object>>> getShrink, FSharpTypeFunc split3, FSharpFunc`2<b, c> read, FSharpFunc`2<Object[], d> make, b o, IEnumerable`1<e> childrenTypes);
    internal static FSharpFunc`2<IEnumerable`1<Type>, int> unionSize@57-2(Type t);
    internal static FSharpFunc`2<FSharpList`1<b>, FSharpFunc`2<Tuple`2<c, Tuple`4<d, e, b, f>>, FSharpList`1<b>>> partitionCase@65(Type t);
    internal static FSharpList`1<object> size0Cases@69(Type t, Unit unitVar0);
    internal static FSharpFunc`2<b, Object[]> read@93-1();
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<object> reflectShrinkObj$cont@103(FSharpFunc`2<Type, FSharpFunc`2<object, IEnumerable`1<object>>> getShrink, a o, Type t, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<object> reflectShrinkObj$cont@150-2(FSharpList`1<object> elems, Type elementType, object n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<object> reflectShrinkObj$cont@131-1(a o, Type t, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<object> reflectShrinkObj(FSharpFunc`2<Type, FSharpFunc`2<object, IEnumerable`1<object>>> getShrink, a o, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<T> reflectShrink(FSharpFunc`2<Type, FSharpFunc`2<object, IEnumerable`1<object>>> getShrink, T a);
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.Shrink : object {
    internal static Shrink`1<a> ofValue(a x);
    internal static Shrink`1<a> ofLazy(Lazy`1<a> x);
    internal static Shrink`1<U> buildTree@23(FSharpFunc`2<T, a> shrink, FSharpFunc`2<T, U> f, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Shrink`1<U> ofShrinker(FSharpFunc`2<T, a> shrink, T x, FSharpFunc`2<T, U> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Shrink`1<U> map(FSharpFunc`2<T, U> f, Shrink`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Shrink`1<U> map2(FSharpFunc`2<T1, FSharpFunc`2<T2, U>> f, Shrink`1<T1> r1, Shrink`1<T2> r2);
    internal static Shrink`1<T> join(Shrink`1<Shrink`1<T>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Shrink`1<U> bind(Shrink`1<T> m, FSharpFunc`2<T, Shrink`1<U>> k);
    internal static Tuple`2<a, IEnumerable`1<Shrink`1<a>>> getValue(Shrink`1<a> _arg1);
    internal static IEnumerable`1<f> bisecIncreasing(a n);
    internal static IEnumerable`1<f> bisecIncreasing$W(FSharpFunc`2<Unit, c> get_One, FSharpFunc`2<Unit, d> get_One1, FSharpFunc`2<Unit, e> get_Zero, FSharpFunc`2<c, FSharpFunc`2<d, b>> op_Addition, FSharpFunc`2<a, FSharpFunc`2<b, e>> op_Division, FSharpFunc`2<e, FSharpFunc`2<b, e>> op_Division5, FSharpFunc`2<a, FSharpFunc`2<e, f>> op_Subtraction, a n);
    internal static IEnumerable`1<a> signedNumber(a n);
    internal static IEnumerable`1<a> signedNumber$W(FSharpFunc`2<a, FSharpFunc`2<MaxValue, a>> maxValue, FSharpFunc`2<a, FSharpFunc`2<MinValue, a>> minValue, FSharpFunc`2<Unit, c> get_One, FSharpFunc`2<Unit, d> get_One3, FSharpFunc`2<Unit, a> get_Zero, FSharpFunc`2<Unit, e> get_Zero5, FSharpFunc`2<c, FSharpFunc`2<d, b>> op_Addition, FSharpFunc`2<a, FSharpFunc`2<b, e>> op_Division, FSharpFunc`2<e, FSharpFunc`2<b, e>> op_Division8, FSharpFunc`2<a, FSharpFunc`2<e, a>> op_Subtraction, FSharpFunc`2<a, a> op_UnaryNegation, a n);
    internal static IEnumerable`1<f> unsignedNumber(a n);
    internal static IEnumerable`1<f> unsignedNumber$W(FSharpFunc`2<Unit, c> get_One, FSharpFunc`2<Unit, d> get_One1, FSharpFunc`2<Unit, a> get_Zero, FSharpFunc`2<Unit, e> get_Zero3, FSharpFunc`2<Unit, f> get_Zero4, FSharpFunc`2<c, FSharpFunc`2<d, b>> op_Addition, FSharpFunc`2<a, FSharpFunc`2<b, e>> op_Division, FSharpFunc`2<e, FSharpFunc`2<b, e>> op_Division7, FSharpFunc`2<a, FSharpFunc`2<e, f>> op_Subtraction, a n);
    internal static IEnumerable`1<DateTime> date(DateTime d);
    internal static IEnumerable`1<FSharpList`1<b>> shrinkList@104(FSharpList`1<b> l);
    internal static IEnumerable`1<FSharpList`1<a>> listShorten(FSharpList`1<a> l);
    internal static IEnumerable`1<FSharpList`1<T>> shrinkList@114-2(FSharpFunc`2<T, a> elementShrink, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<FSharpList`1<T>> listElements(FSharpFunc`2<T, a> elementShrink, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<FSharpList`1<T>> list(FSharpFunc`2<T, a> elementShrink, FSharpList`1<T> l);
    internal static a[] prepend@129(a x, a[] arr);
    internal static IEnumerable`1<T[]> shrinkArray@138(T[] arr);
    internal static IEnumerable`1<T[]> arrayShorten(T[] a);
    internal static IEnumerable`1<T[]> shrinkArray@149-2(FSharpFunc`2<T, a> elementShrink, T[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<T[]> arrayElements(FSharpFunc`2<T, a> elementShrink, T[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a[]> array(FSharpFunc`2<a, b> elementShrink, a[] arr);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Internals.Shrink`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Lazy`1<T> item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerable`1<Shrink`1<T>> item2;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Lazy`1<T> Item1 { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerable`1<Shrink`1<T>> Item2 { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Internals.Shrink`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Shrink`1(Lazy`1<T> item1, IEnumerable`1<Shrink`1<T>> item2);
    [CompilationMappingAttribute]
internal static Shrink`1<T> NewShrinkTree(Lazy`1<T> item1, IEnumerable`1<Shrink`1<T>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Lazy`1<T> get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerable`1<Shrink`1<T>> get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute]
internal static class FsCheck.Internals.TypeClass : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string CatchAllName;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Type[]> |GenericTypeDef|_|(Type p, Type t);
    internal static FSharpChoice`3<Unit, Unit, Unit> |IsArray|IsGeneric|IsOther|(Type x);
    internal static IEnumerable`1<MethodInfo> getMethods(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<InstanceKind, InvocationData>> toRegistryPair(Type typeClass, InvocationData inv);
    internal static bool isUsableMethodArgumentType@83(Type typeClass, a[] injectedConfigTypes, Type argumentType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpResult`2<Unit, ParameterErrors> validateParameters(Type typeClass, bool injectParameters, a[] injectedConfigTypes, MethodInfo meth);
    internal static bool filterInstanceOrStatic@109(FSharpOption`1<b> instance, MethodInfo meth);
    internal static bool filterVisibility@114(bool onlyPublic, MethodInfo meth);
    internal static bool filterParameters@118(Type typeClass, bool injectParameters, Type[] injectedConfigTypes, MethodInfo meth);
    internal static FSharpList`1<Tuple`2<InstanceKind, InvocationData>> addMethods@126(Type typeClass, bool onlyPublic, bool injectParameters, FSharpOption`1<b> instance, Type[] injectedConfigTypes, FSharpFunc`2<FSharpList`1<Tuple`2<InstanceKind, InvocationData>>, FSharpFunc`2<MethodInfo, FSharpList`1<Tuple`2<InstanceKind, InvocationData>>>> addMethod, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<InstanceKind, InvocationData>> findInstances(Type typeClass, bool onlyPublic, bool injectParameters, a[] injectedConfigs, Type instancesType, FSharpOption`1<b> instance);
    internal static string setToString@147(string pre, FSharpSet`1<a> s);
    internal static Tuple`2<InstanceKind, InvocationData> toRegistryPair'@226(TypeClass`1<TypeClass> this, InvocationData inv);
    internal static string formatParam@235(ParameterInfo pi);
    internal static a throwParameterError@231(ParameterErrors err);
    internal static object resolveParameter@264(TypeClass`1<TypeClass> x, ParameterInfo param);
    internal static object invoke@276(TypeClass`1<TypeClass> x, InvocationData inv);
    internal static Tuple`2[] binding@283(Type concrete, Type generic);
    [CompilerGeneratedAttribute]
internal static Type mapping@1-1(Tuple`2[] b, Type t);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Interval : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item2;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item1 { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item2 { get; }
    public int Left { get; }
    public int Right { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Interval")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Interval(int item1, int item2);
    [CompilationMappingAttribute]
public static Interval NewInterval(int item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Interval obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Left();
    public int get_Right();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Interval obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.IntWithMinMax : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    public int Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.IntWithMinMax")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IntWithMinMax(int item);
    [CompilationMappingAttribute]
public static IntWithMinMax NewIntWithMinMax(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(IntWithMinMax obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Get();
    public virtual string ToString();
    public static int op_Explicit(IntWithMinMax _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IntWithMinMax obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.IPv4Address : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IPAddress item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public IPAddress Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.IPv4Address")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IPv4Address(IPAddress item);
    [CompilationMappingAttribute]
public static IPv4Address NewIPv4Address(IPAddress item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public IPAddress get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IPv4Address obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.IPv6Address : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IPAddress item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public IPAddress Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.IPv6Address")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IPv6Address(IPAddress item);
    [CompilationMappingAttribute]
public static IPv6Address NewIPv6Address(IPAddress item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public IPAddress get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IPv6Address obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public interface FsCheck.IRunner {
    public abstract virtual void OnStartFixture(Type );
    public abstract virtual void OnArguments(int , FSharpList`1<object> , FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<object>, string>> );
    public abstract virtual void OnShrink(FSharpList`1<object> , FSharpFunc`2<FSharpList`1<object>, string> );
    public abstract virtual void OnFinished(string , TestResult );
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NegativeInt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    public int Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NegativeInt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NegativeInt(int item);
    [CompilationMappingAttribute]
public static NegativeInt NewNegativeInt(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NegativeInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Get();
    public virtual string ToString();
    public static int op_Explicit(NegativeInt _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NegativeInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonEmptyArray`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T[] item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T[] Item { get; }
    public T[] Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonEmptyArray`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonEmptyArray`1(T[] item);
    [CompilationMappingAttribute]
public static NonEmptyArray`1<T> NewNonEmptyArray(T[] item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T[] get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonEmptyArray`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public T[] get_Get();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonEmptyArray`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonEmptySet`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<T> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<T> Item { get; }
    public FSharpSet`1<T> Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonEmptySet`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonEmptySet`1(FSharpSet`1<T> item);
    [CompilationMappingAttribute]
public static NonEmptySet`1<T> NewNonEmptySet(FSharpSet`1<T> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<T> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonEmptySet`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public FSharpSet`1<T> get_Get();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonEmptySet`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonEmptyString : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    public string Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonEmptyString")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonEmptyString(string item);
    [CompilationMappingAttribute]
public static NonEmptyString NewNonEmptyString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonEmptyString obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Get();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonEmptyString obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonNegativeInt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    public int Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonNegativeInt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonNegativeInt(int item);
    [CompilationMappingAttribute]
public static NonNegativeInt NewNonNegativeInt(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonNegativeInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Get();
    public virtual string ToString();
    public static int op_Explicit(NonNegativeInt _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonNegativeInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonNull`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal a item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a Item { get; }
    public a Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonNull`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonNull`1(a item);
    [CompilationMappingAttribute]
public static NonNull`1<a> NewNonNull(a item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonNull`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public a get_Get();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonNull`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonWhiteSpaceString : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    public string Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonWhiteSpaceString")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonWhiteSpaceString(string item);
    [CompilationMappingAttribute]
public static NonWhiteSpaceString NewNonWhiteSpaceString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonWhiteSpaceString obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Get();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonWhiteSpaceString obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NonZeroInt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    public int Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NonZeroInt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NonZeroInt(int item);
    [CompilationMappingAttribute]
public static NonZeroInt NewNonZeroInt(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NonZeroInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Get();
    public virtual string ToString();
    public static int op_Explicit(NonZeroInt _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NonZeroInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.NormalFloat : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal double item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public double Item { get; }
    public double Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.NormalFloat")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NormalFloat(double item);
    [CompilationMappingAttribute]
public static NormalFloat NewNormalFloat(double item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public double get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NormalFloat obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public double get_Get();
    public virtual string ToString();
    public static double op_Explicit(NormalFloat _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NormalFloat obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FsCheck.Outcome : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Outcome _unique_Passed;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Outcome _unique_Rejected;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Outcome Passed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPassed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Outcome Rejected { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRejected { get; }
    internal bool Shrink { get; }
    private static Outcome();
    [CompilationMappingAttribute]
public static Outcome NewFailed(Exception item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailed();
    [CompilationMappingAttribute]
public static Outcome get_Passed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPassed();
    [CompilationMappingAttribute]
public static Outcome get_Rejected();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRejected();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal bool get_Shrink();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Outcome obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class FsCheck.ParallelRunConfig : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int MaxDegreeOfParallelism@;
    [CompilationMappingAttribute]
public int MaxDegreeOfParallelism { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.ParallelRunConfig")]
public ParallelRunConfig(int maxDegreeOfParallelism);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ParallelRunConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParallelRunConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.PositiveInt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    public int Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.PositiveInt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PositiveInt(int item);
    [CompilationMappingAttribute]
public static PositiveInt NewPositiveInt(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PositiveInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public int get_Get();
    public virtual string ToString();
    public static int op_Explicit(PositiveInt _arg1);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PositiveInt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.Property : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<IArbMap, Gen`1<Shrink`1<ResultContainer>>> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<IArbMap, Gen`1<Shrink`1<ResultContainer>>> Item { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Property")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Property(FSharpFunc`2<IArbMap, Gen`1<Shrink`1<ResultContainer>>> item);
    [CompilationMappingAttribute]
internal static Property NewProperty(FSharpFunc`2<IArbMap, Gen`1<Shrink`1<ResultContainer>>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<IArbMap, Gen`1<Shrink`1<ResultContainer>>> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<Shrink`1<ResultContainer>> GetGen(IArbMap arbMap, Property _arg1);
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute]
internal static class FsCheck.Random : object {
    internal static FSharpRef`1<ulong> defaultGen;
    internal static int init@81;
    internal static FSharpRef`1<ulong> DefaultGen { get; }
    private static Random();
    internal static FSharpRef`1<ulong> get_DefaultGen();
    internal static Rnd CreateWithSeed(ulong seed);
    internal static Rnd CreateWithSeedAndGamma(ulong seed, ulong gamma);
    internal static Rnd Create();
    internal static ulong NextUInt64(Rnd& s);
    internal static long NextInt64(Rnd& s);
    internal static int NextInt(Rnd& s);
    internal static double NextDouble(Rnd& s);
    internal static void Split(Rnd state, Rnd& left, Rnd& right);
    internal static long RangeInt64(long l, long h, Rnd s, Rnd& s');
    internal static int RangeInt(int l, int h, Rnd s, Rnd& s');
}
[CompilationMappingAttribute]
internal static class FsCheck.RandomConstants : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ulong GOLDEN_GAMMA;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static double DOUBLE_MULTIPLIER;
    private static RandomConstants();
}
[CompilationMappingAttribute]
public class FsCheck.Replay : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Rnd Rnd@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<int> Size@;
    [CompilationMappingAttribute]
public Rnd Rnd { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<int> Size { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Replay")]
public Replay(Rnd rnd, FSharpOption`1<int> size);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Rnd get_Rnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<int> get_Size();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Replay obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Replay obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class FsCheck.Res : object {
    [CompilationMappingAttribute]
internal static Result result { get; }
    [CompilationMappingAttribute]
internal static Result failedFalse { get; }
    [CompilationMappingAttribute]
internal static Result failedCancelled { get; }
    [CompilationMappingAttribute]
internal static Result passed { get; }
    [CompilationMappingAttribute]
internal static Result rejected { get; }
    internal static Result get_result();
    internal static Result failedException(Exception e);
    internal static Result get_failedFalse();
    internal static Result get_failedCancelled();
    internal static Result get_passed();
    internal static Result get_rejected();
    internal static Result ofBool(bool b);
}
[NoComparisonAttribute]
[CompilationMappingAttribute]
public class FsCheck.Result : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Outcome Outcome@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Stamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<string> Labels@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<object> Arguments@;
    [CompilationMappingAttribute]
public Outcome Outcome { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> Stamp { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<string> Labels { get; }
    [CompilationMappingAttribute]
public FSharpList`1<object> Arguments { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.Result")]
public Result(Outcome outcome, FSharpList`1<string> stamp, FSharpSet`1<string> labels, FSharpList`1<object> arguments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Outcome get_Outcome();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_Stamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> get_Labels();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<object> get_Arguments();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static Result ResAnd(Result l, Result r);
    internal static Result ResOr(Result l, Result r);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Result obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FsCheck.ResultContainer : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFuture { get; }
    [CompilationMappingAttribute]
public static ResultContainer NewValue(Result item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValue();
    [CompilationMappingAttribute]
public static ResultContainer NewFuture(Task`1<Result> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFuture();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static ResultContainer MapResult2(FSharpFunc`2<Tuple`2<Result, Result>, Result> f, ResultContainer l, ResultContainer r);
    public static ResultContainer op_BitwiseAnd(ResultContainer l, ResultContainer r);
    public static ResultContainer op_BitwiseOr(ResultContainer l, ResultContainer r);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResultContainer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[CompilationMappingAttribute]
public class FsCheck.Rnd : ValueType {
    internal ulong Seed@;
    internal ulong Gamma@;
    [CompilationMappingAttribute]
public ulong Seed { get; }
    [CompilationMappingAttribute]
public ulong Gamma { get; }
    public Rnd(ulong seed, ulong gamma);
    public Rnd(ulong seed);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ulong get_Seed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ulong get_Gamma();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Rnd obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal Rnd Next();
    internal static ulong Mix64(ulong z);
    internal static int Mix32Variant04(ulong z);
    internal static ulong Mix64vVriant13(ulong z);
    internal static ulong BitCount(ulong i);
    internal static ulong MixGamma(ulong z);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Rnd obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class FsCheck.Runner : object {
    [CompilationMappingAttribute]
internal static string newline { get; }
    [CompilationMappingAttribute]
public static IRunner consoleRunner { get; }
    [CompilationMappingAttribute]
internal static MethodInfo checkMethodInfo { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<TestStep> shrinkResultValue(Result result, IEnumerator`1<Shrink`1<Result>> shrinks);
    internal static FSharpAsync`1<IEnumerable`1<TestStep>> goNext@168(Result result, IEnumerator`1<Shrink`1<ResultContainer>> shrinks, IEnumerable`1<Shrink`1<ResultContainer>> s, Result r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Task`1<IEnumerable`1<TestStep>> shrinkResultTask(Result result, IEnumerator`1<Shrink`1<ResultContainer>> shrinks);
    internal static OutcomeSeqOrFuture iter@190(List`1<TestStep> xs, Result result, IEnumerator`1<Shrink`1<ResultContainer>> shrinks);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OutcomeSeqOrFuture shrinkResultTaskIter(Result result, IEnumerator`1<Shrink`1<ResultContainer>> shrinks);
    public static FSharpFunc`2<Tuple`2<a, Rnd>, IEnumerable`1<Tuple`2<a, Rnd>>> stepsSeq(FSharpFunc`2<a, a> resize);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<TestStep> testSingle(Gen`1<Shrink`1<Result>> generator, double newSize, Rnd seed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<TestStep> test(bool isReplay, double initSize, FSharpFunc`2<double, double> resize, Rnd rnd0, Gen`1<Shrink`1<ResultContainer>> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OutcomeSeqOrFuture outcomeSeq(Result result, IEnumerable`1<Shrink`1<ResultContainer>> shrinks, Rnd rnd, int usedSize);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OutcomeSeqOrFuture testStep(Rnd rnd, double size, Gen`1<Shrink`1<ResultContainer>> gen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outcomeSeqFutureCont(Task`1<IEnumerable`1<TestStep>> xs, object state);
    [CompilerGeneratedAttribute]
internal static void tpWorkerFun$cont@292(Tuple`6<Tuple`2[], FSharpRef`1<int>, int, Gen`1<Shrink`1<ResultContainer>>, IEnumerable`1[], CancellationToken> state, Unit unitVar);
    internal static void tpWorkerFun(object state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<TestStep> parallelTest(Config config, double initSize, FSharpFunc`2<double, double> resize, Rnd rnd0, Gen`1<Shrink`1<ResultContainer>> gen);
    internal static FSharpFunc`2<Tuple`2<int, a>, Tuple`2<int, a>> entry@393(int ntest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void testsDone(Config config, TestStep testStep, FSharpList`1<object> origArgs, int ntest, int nshrinks, Rnd originalSeed, Rnd lastSeed, int lastSize, IEnumerable`1<FSharpList`1<string>> stamps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void runner(Config config, a prop);
    internal static string get_newline();
    internal static string escapeControlChars@471(string s);
    public static string argumentsToString(FSharpList`1<a> args);
    public static string onStartFixtureToString(Type t);
    internal static string pluralize(int nb);
    internal static string labelsToString(IEnumerable`1<string> l);
    internal static string maybePrintLabels(FSharpSet`1<string> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string onFailureToString(string name, TestData data, FSharpList`1<a> originalArgs, FSharpList`1<b> args, c usedSeed, d lastSeed, int lastSize);
    internal static string display@511(FSharpList`1<string> l);
    internal static string entry@515-2(Tuple`2<a, IEnumerable`1<string>> tupledArg);
    internal static string stampsToString@516(FSharpTypeFunc entry, IEnumerable`1<Tuple`2<a, b>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string onFinishedToString(string name, TestResult testResult);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string onArgumentsToString(int n, FSharpList`1<a> args);
    public static string onShrinkToString(FSharpList`1<a> args);
    public static IRunner get_consoleRunner();
    internal static bool hasTestableReturnType(MethodInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void check(Config config, a p);
    internal static MethodInfo get_checkMethodInfo();
    internal static Type arrayToTupleType(Type[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Object[] tupleToArray(a[] types, object tvalue);
    internal static FSharpFunc`2<Object[], object> invokeAndThrowInner@588(FSharpOption`1<object> target, MethodInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkMethod(Config config, MethodInfo m, FSharpOption`1<object> target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkAll(Config config, Type t);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.StringNoNullChar : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    public string Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.StringNoNullChar")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal StringNoNullChar(string item);
    [CompilationMappingAttribute]
public static StringNoNullChar NewStringNoNullChar(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(StringNoNullChar obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Get();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringNoNullChar obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class FsCheck.Testable : object {
    [CompilationMappingAttribute]
internal static TypeClass`1<ITestable`1<object>> testableTC { get; }
    internal static TypeClass`1<ITestable`1<object>> get_testableTC();
    internal static Property property(a p);
    internal static Gen`1<Shrink`1<T>> promoteRose@151(Shrink`1<Gen`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<Shrink`1<c>> shrinking(FSharpFunc`2<a, b> shrink, a generatedValue, FSharpFunc`2<a, Gen`1<Shrink`1<c>>> propertyFun);
    internal static FSharpFunc`2<ResultContainer, ResultContainer> argument@160(c a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Gen`1<Shrink`1<ResultContainer>> evaluate(FSharpFunc`2<a, b> body, a a, IArbMap arbMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Property forAll(Arbitrary`1<a> arb, FSharpFunc`2<a, b> body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Property combine(FSharpFunc`2<ResultContainer, FSharpFunc`2<ResultContainer, ResultContainer>> f, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Property op_DotAmp(a l, b r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Property op_DotBar(a l, b r);
    [CompilerGeneratedAttribute]
internal static Shrink`1<a> create@33-1(Lazy`1<Gen`1<Shrink`1<a>>> m, FSharpFunc`2<Gen`1<Shrink`1<a>>, Shrink`1<a>> runner);
    internal static Gen`1<Shrink`1<a>> promoteLazy@215(Lazy`1<Gen`1<Shrink`1<a>>> m);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute]
public class FsCheck.TestData : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int NumberOfTests@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int NumberOfShrinks@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal IEnumerable`1<Tuple`2<int, FSharpList`1<string>>> Stamps@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<string> Labels@;
    [CompilationMappingAttribute]
public int NumberOfTests { get; }
    [CompilationMappingAttribute]
public int NumberOfShrinks { get; }
    [CompilationMappingAttribute]
public IEnumerable`1<Tuple`2<int, FSharpList`1<string>>> Stamps { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<string> Labels { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.TestData")]
public TestData(int numberOfTests, int numberOfShrinks, IEnumerable`1<Tuple`2<int, FSharpList`1<string>>> stamps, FSharpSet`1<string> labels);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_NumberOfTests();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_NumberOfShrinks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public IEnumerable`1<Tuple`2<int, FSharpList`1<string>>> get_Stamps();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> get_Labels();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FsCheck.TestResult : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPassed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExhausted { get; }
    [CompilationMappingAttribute]
public static TestResult NewPassed(TestData item1, bool item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPassed();
    [CompilationMappingAttribute]
public static TestResult NewFailed(TestData item1, FSharpList`1<object> item2, FSharpList`1<object> item3, Outcome item4, Rnd item5, Rnd item6, int item7);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailed();
    [CompilationMappingAttribute]
public static TestResult NewExhausted(TestData item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExhausted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.ThrowingFunction`2 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<a, b> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, b> Item { get; }
    public FSharpFunc`2<a, b> Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.ThrowingFunction`2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ThrowingFunction`2(FSharpFunc`2<a, b> item);
    [CompilationMappingAttribute]
public static ThrowingFunction`2<a, b> NewThrowingFunction(FSharpFunc`2<a, b> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, b> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public FSharpFunc`2<a, b> get_Get();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.UnicodeChar : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal char item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public char Item { get; }
    public char Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.UnicodeChar")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UnicodeChar(char item);
    [CompilationMappingAttribute]
public static UnicodeChar NewUnicodeChar(char item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public char get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UnicodeChar obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public char get_Get();
    public virtual string ToString();
    public static char op_Explicit(UnicodeChar source);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnicodeChar obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.UnicodeString : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    public string Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.UnicodeString")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UnicodeString(string item);
    [CompilationMappingAttribute]
public static UnicodeString NewUnicodeString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UnicodeString obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Get();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnicodeString obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FsCheck.XmlEncodedString : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    public string Get { get; }
    [DynamicDependencyAttribute("1632", "FsCheck.XmlEncodedString")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal XmlEncodedString(string item);
    [CompilationMappingAttribute]
public static XmlEncodedString NewXmlEncodedString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(XmlEncodedString obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Get();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(XmlEncodedString obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyProduct;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyDescription;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyKeyFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string InternalsVisibleTo;
}
[FlagsAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes All;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
}
[CompilerGeneratedAttribute]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private DynamicallyAccessedMemberTypes MemberType@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private Type Type@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes MemberType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes MemberType, Type Type);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes get_MemberType();
}
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
