[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ActivePatterns : object {
    internal static a |Singleton|(FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> |EmptyMap|_|(a result, FSharpMap`2<b, c> map);
    internal static FSharpOption`1<Tuple`2<a, b>> |SingletonMap|_|(FSharpMap`2<a, b> map);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.AssemblyResolver : object {
    [CompilationMappingAttribute]
internal static bool initialized { get; internal set; }
    internal static bool get_initialized();
    internal static void set_initialized(bool value);
    internal static void init();
}
[CompilationMappingAttribute]
public static class ProviderImplementation.ConversionsGenerator : object {
    [DebuggerBrowsableAttribute("0")]
internal static T99934_374Bytes@ field99935@;
    [DebuggerBrowsableAttribute("0")]
internal static T99936_389Bytes@ field99937@;
    [DebuggerBrowsableAttribute("0")]
internal static T99938_394Bytes@ field99939@;
    [DebuggerBrowsableAttribute("0")]
internal static T99940_392Bytes@ field99941@;
    [DebuggerBrowsableAttribute("0")]
internal static T99942_404Bytes@ field99943@;
    [DebuggerBrowsableAttribute("0")]
internal static T99944_378Bytes@ field99945@;
    [DebuggerBrowsableAttribute("0")]
internal static T99946_393Bytes@ field99947@;
    [DebuggerBrowsableAttribute("0")]
internal static T99948_399Bytes@ field99949@;
    [DebuggerBrowsableAttribute("0")]
internal static T99946_393Bytes@ field99950@;
    [DebuggerBrowsableAttribute("0")]
internal static T99951_375Bytes@ field99952@;
    [DebuggerBrowsableAttribute("0")]
internal static T99953_387Bytes@ field99954@;
    [DebuggerBrowsableAttribute("0")]
internal static T99940_392Bytes@ field99955@;
    [DebuggerBrowsableAttribute("0")]
internal static T99956_390Bytes@ field99957@;
    [DebuggerBrowsableAttribute("0")]
internal static T99958_402Bytes@ field99959@;
    [DebuggerBrowsableAttribute("0")]
internal static T99960_372Bytes@ field99961@;
    [DebuggerBrowsableAttribute("0")]
internal static T99938_394Bytes@ field99962@;
    [DebuggerBrowsableAttribute("0")]
internal static T99963_373Bytes@ field99964@;
    [DebuggerBrowsableAttribute("0")]
internal static T99965_391Bytes@ field99966@;
    [DebuggerBrowsableAttribute("0")]
internal static T99967_397Bytes@ field99968@;
    [DebuggerBrowsableAttribute("0")]
internal static T99965_391Bytes@ field99969@;
    [CompilerGeneratedAttribute]
internal static FSharpExpr getConversionQuotation$cont@23(string missingValuesStr, string cultureStr, Type typ, FSharpExpr`1<FSharpOption`1<string>> value, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpExpr getConversionQuotation(string missingValuesStr, string cultureStr, Type typ, FSharpExpr`1<FSharpOption`1<string>> value);
    [CompilerGeneratedAttribute]
internal static FSharpExpr`1<string> getBackConversionQuotation$cont@49(string missingValuesStr, string cultureStr, Type typ, FSharpExpr value, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpExpr`1<string> getBackConversionQuotation(string missingValuesStr, string cultureStr, Type typ, FSharpExpr value);
    internal static FSharpExpr convert@86(string missingValuesStr, string cultureStr, string fieldName, PrimitiveInferedValue field, FSharpExpr`1<FSharpOption`1<string>> value);
    internal static FSharpExpr convertBack@106(string missingValuesStr, string cultureStr, PrimitiveInferedValue field, FSharpExpr value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Type, Type, FSharpFunc`2<a, FSharpExpr>, FSharpFunc`2<b, FSharpExpr>> convertStringValue(string missingValuesStr, string cultureStr, PrimitiveInferedProperty field);
}
[TypeProviderAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.CsvProvider : DisposableTypeProviderForNamespaces {
    internal TypeProviderConfig cfg;
    internal FSharpRef`1<CsvProvider> this;
    internal Assembly asm;
    internal string ns;
    internal int init@25-18;
    public CsvProvider(TypeProviderConfig cfg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ProvidedTypeDefinition buildTypes(string typeName, Object[] args);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.CsvTypeBuilder : object {
    [DebuggerBrowsableAttribute("0")]
internal static T100124_365Bytes@ field100125@;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ProvidedTypeDefinition, Type, ProvidedTypeDefinition, FSharpExpr, FSharpExpr> generateTypes(Assembly asm, string ns, string typeName, string missingValuesStr, string cultureStr, FSharpList`1<PrimitiveInferedProperty> inferredFields);
}
[CompilationMappingAttribute]
public class ProviderImplementation.DisposableTypeProviderForNamespaces : TypeProviderForNamespaces {
    internal FSharpRef`1<DisposableTypeProviderForNamespaces> x;
    internal object lockObj;
    internal List`1<FSharpFunc`2<FSharpOption`1<string>, bool>> disposeActions;
    internal static int idCount;
    internal int id;
    internal Dictionary`2<string, string> filesToWatch;
    internal static int init@80-15;
    internal int init@80-14;
    public int Id { get; }
    public DisposableTypeProviderForNamespaces(TypeProviderConfig config, FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> assemblyReplacementMap);
    private static DisposableTypeProviderForNamespaces();
    public int get_Id();
    public void SetFileToWatch(string fullTypeName, string path);
    public FSharpOption`1<string> GetFileToWath(string fullTypeName);
    public void AddDisposeAction(FSharpFunc`2<FSharpOption`1<string>, bool> action);
    public void InvalidateOneType(string typeName);
    [CompilerGeneratedAttribute]
internal void dispose(FSharpOption`1<string> typeNameOpt);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.HtmlGenerator : object {
    [DebuggerBrowsableAttribute("0")]
internal static T100189_367Bytes@ field100190@;
    [DebuggerBrowsableAttribute("0")]
internal static T100199_328Bytes@ field100200@;
    [DebuggerBrowsableAttribute("0")]
internal static T100199_328Bytes@ field100201@;
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, string> getPropertyName { get; }
    private static HtmlGenerator();
    internal static FSharpFunc`2<string, string> get_getPropertyName();
    internal static FSharpFunc`2<string, string> typeNameGenerator();
    internal static FSharpExpr create@109(HtmlTable table, Type tableErasedWithRowErasedType, FSharpExpr rowConverter, FSharpExpr htmlDoc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<a, FSharpExpr>, ProvidedTypeDefinition> createTableType(FSharpFunc`2<string, string> getTableTypeName, Parameters inferenceParameters, string missingValuesStr, string cultureStr, HtmlTable table);
    internal static FSharpExpr create@167-1(HtmlList list, Type listTypeWithErasedType, FSharpExpr rowConverter, FSharpExpr htmlDoc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<a, FSharpExpr>, ProvidedTypeDefinition> createListType(FSharpFunc`2<string, string> getListTypeName, Parameters inferenceParameters, string missingValuesStr, string cultureStr, HtmlList list);
    internal static FSharpExpr create@229-2(HtmlDefinitionList definitionList, a index, Type listTypeWithErasedType, FSharpExpr rowConverter, b doc);
    internal static FSharpFunc`2<a, FSharpFunc`2<HtmlList, Tuple`2<ProvidedProperty, ProvidedTypeDefinition>>> createListType@193-1(string missingValuesStr, Parameters inferenceParameters, string cultureStr, HtmlDefinitionList definitionList, FSharpFunc`2<string, string> getListTypeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProvidedTypeDefinition createDefinitionListType(FSharpFunc`2<string, string> getDefinitionListTypeName, Parameters inferenceParameters, string missingValuesStr, string cultureStr, HtmlDefinitionList definitionList);
    internal static ProvidedTypeDefinition getOrCreateContainer@283(ProvidedTypeDefinition htmlType, Dictionary`2<string, ProvidedTypeDefinition> containerTypes, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProvidedTypeDefinition generateTypes(Assembly asm, string ns, string typeName, Parameters parameters_0, string parameters_1, string parameters_2, IEnumerable`1<HtmlObjectDescription> htmlObjects);
}
[TypeProviderAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.HtmlProvider : DisposableTypeProviderForNamespaces {
    internal TypeProviderConfig cfg;
    internal FSharpRef`1<HtmlProvider> this;
    internal Assembly asm;
    internal string ns;
    internal int init@19-20;
    public HtmlProvider(TypeProviderConfig cfg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ProvidedTypeDefinition buildTypes(string typeName, Object[] args);
}
[CompilationMappingAttribute]
public static class ProviderImplementation.JsonConversionsGenerator : object {
    [DebuggerBrowsableAttribute("0")]
internal static T99970_371Bytes@ field99971@;
    [DebuggerBrowsableAttribute("0")]
internal static T99972_372Bytes@ field99973@;
    [DebuggerBrowsableAttribute("0")]
internal static T99974_377Bytes@ field99975@;
    [DebuggerBrowsableAttribute("0")]
internal static T99976_375Bytes@ field99977@;
    [DebuggerBrowsableAttribute("0")]
internal static T99978_387Bytes@ field99979@;
    [DebuggerBrowsableAttribute("0")]
internal static T99980_361Bytes@ field99981@;
    [DebuggerBrowsableAttribute("0")]
internal static T99982_382Bytes@ field99983@;
    [DebuggerBrowsableAttribute("0")]
internal static T99984_376Bytes@ field99985@;
    [DebuggerBrowsableAttribute("0")]
internal static T99984_376Bytes@ field99986@;
    [DebuggerBrowsableAttribute("0")]
internal static T99987_358Bytes@ field99988@;
    [DebuggerBrowsableAttribute("0")]
internal static T99989_311Bytes@ field99990@;
    [DebuggerBrowsableAttribute("0")]
internal static T99991_314Bytes@ field99992@;
    [DebuggerBrowsableAttribute("0")]
internal static T99991_314Bytes@ field99993@;
    [DebuggerBrowsableAttribute("0")]
internal static T99994_318Bytes@ field99995@;
    [DebuggerBrowsableAttribute("0")]
internal static T99996_348Bytes@ field99997@;
    [DebuggerBrowsableAttribute("0")]
internal static T99996_348Bytes@ field99998@;
    [DebuggerBrowsableAttribute("0")]
internal static T99999_306Bytes@ field100000@;
    [DebuggerBrowsableAttribute("0")]
internal static T99996_348Bytes@ field100001@;
    [DebuggerBrowsableAttribute("0")]
internal static T99999_306Bytes@ field100002@;
    [DebuggerBrowsableAttribute("0")]
internal static T99996_348Bytes@ field100003@;
    [CompilerGeneratedAttribute]
internal static FSharpExpr getConversionQuotation$cont@25-1(string missingValuesStr, string cultureStr, Type typ, FSharpExpr`1<FSharpOption`1<JsonValue>> value, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpExpr getConversionQuotation(string missingValuesStr, string cultureStr, Type typ, FSharpExpr`1<FSharpOption`1<JsonValue>> value);
    internal static FSharpExpr wrapInLetIfNeeded@65(FSharpExpr value, FSharpFunc`2<FSharpExpr`1<T>, FSharpExpr> getBody);
    internal static FSharpExpr convert@75-1(string missingValuesStr, string cultureStr, bool canPassAllConversionCallingTypes, PrimitiveInferedValue field, FSharpExpr value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Type, FSharpFunc`2<a, FSharpExpr>, JsonConversionCallingType> convertJsonValue(string missingValuesStr, string cultureStr, bool canPassAllConversionCallingTypes, PrimitiveInferedValue field);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.JsonGenerationContext : object {
    [DebuggerBrowsableAttribute("0")]
internal string CultureStr@;
    [DebuggerBrowsableAttribute("0")]
internal ProvidedTypeDefinition TypeProviderType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, string> UniqueNiceName@;
    [DebuggerBrowsableAttribute("0")]
internal Type IJsonDocumentType@;
    [DebuggerBrowsableAttribute("0")]
internal Type JsonValueType@;
    [DebuggerBrowsableAttribute("0")]
internal Type JsonRuntimeType@;
    [DebuggerBrowsableAttribute("0")]
internal Dictionary`2<InferedType, ProvidedTypeDefinition> TypeCache@;
    [DebuggerBrowsableAttribute("0")]
internal bool PreferDictionaries@;
    [DebuggerBrowsableAttribute("0")]
internal bool GenerateConstructors@;
    [DebuggerBrowsableAttribute("0")]
internal InferenceMode' InferenceMode@;
    [DebuggerBrowsableAttribute("0")]
internal IUnitsOfMeasureProvider UnitsOfMeasureProvider@;
    [CompilationMappingAttribute]
internal string CultureStr { get; }
    [CompilationMappingAttribute]
internal ProvidedTypeDefinition TypeProviderType { get; }
    [CompilationMappingAttribute]
internal FSharpFunc`2<string, string> UniqueNiceName { get; }
    [CompilationMappingAttribute]
internal Type IJsonDocumentType { get; }
    [CompilationMappingAttribute]
internal Type JsonValueType { get; }
    [CompilationMappingAttribute]
internal Type JsonRuntimeType { get; }
    [CompilationMappingAttribute]
internal Dictionary`2<InferedType, ProvidedTypeDefinition> TypeCache { get; }
    [CompilationMappingAttribute]
internal bool PreferDictionaries { get; }
    [CompilationMappingAttribute]
internal bool GenerateConstructors { get; }
    [CompilationMappingAttribute]
internal InferenceMode' InferenceMode { get; }
    [CompilationMappingAttribute]
internal IUnitsOfMeasureProvider UnitsOfMeasureProvider { get; }
    internal JsonGenerationContext(string cultureStr, ProvidedTypeDefinition typeProviderType, FSharpFunc`2<string, string> uniqueNiceName, Type iJsonDocumentType, Type jsonValueType, Type jsonRuntimeType, Dictionary`2<InferedType, ProvidedTypeDefinition> typeCache, bool preferDictionaries, bool generateConstructors, InferenceMode' inferenceMode, IUnitsOfMeasureProvider unitsOfMeasureProvider);
    internal string get_CultureStr();
    internal ProvidedTypeDefinition get_TypeProviderType();
    internal FSharpFunc`2<string, string> get_UniqueNiceName();
    internal Type get_IJsonDocumentType();
    internal Type get_JsonValueType();
    internal Type get_JsonRuntimeType();
    internal Dictionary`2<InferedType, ProvidedTypeDefinition> get_TypeCache();
    internal bool get_PreferDictionaries();
    internal bool get_GenerateConstructors();
    internal InferenceMode' get_InferenceMode();
    internal IUnitsOfMeasureProvider get_UnitsOfMeasureProvider();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static JsonGenerationContext Create(string cultureStr, ProvidedTypeDefinition tpType, IUnitsOfMeasureProvider unitsOfMeasureProvider, InferenceMode' inferenceMode, FSharpOption`1<FSharpFunc`2<string, string>> uniqueNiceName, FSharpOption`1<Dictionary`2<InferedType, ProvidedTypeDefinition>> typeCache, FSharpOption`1<bool> preferDictionaries);
    internal static JsonGenerationContext Create(string cultureStr, ProvidedTypeDefinition tpType, FSharpFunc`2<string, string> uniqueNiceName, Dictionary`2<InferedType, ProvidedTypeDefinition> typeCache, bool preferDictionaries, bool generateConstructors, InferenceMode' inferenceMode, IUnitsOfMeasureProvider unitsOfMeasureProvider);
    internal Type MakeOptionType(Type typ);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.JsonGenerationResult : object {
    [DebuggerBrowsableAttribute("0")]
internal Type ConvertedType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpFunc`2<FSharpExpr, FSharpExpr>> OptionalConverter@;
    [DebuggerBrowsableAttribute("0")]
internal JsonConversionCallingType ConversionCallingType@;
    [CompilationMappingAttribute]
internal Type ConvertedType { get; }
    [CompilationMappingAttribute]
internal FSharpOption`1<FSharpFunc`2<FSharpExpr, FSharpExpr>> OptionalConverter { get; }
    [CompilationMappingAttribute]
internal JsonConversionCallingType ConversionCallingType { get; }
    internal FSharpFunc`2<FSharpExpr, FSharpExpr> Convert { get; }
    internal JsonGenerationResult(Type convertedType, FSharpOption`1<FSharpFunc`2<FSharpExpr, FSharpExpr>> optionalConverter, JsonConversionCallingType conversionCallingType);
    internal Type get_ConvertedType();
    internal FSharpOption`1<FSharpFunc`2<FSharpExpr, FSharpExpr>> get_OptionalConverter();
    internal JsonConversionCallingType get_ConversionCallingType();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal FSharpFunc`2<FSharpExpr, FSharpExpr> get_Convert();
    internal FSharpExpr ConverterFunc(JsonGenerationContext ctx);
    internal Type ConvertedTypeErased(JsonGenerationContext ctx);
}
[TypeProviderAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.JsonProvider : DisposableTypeProviderForNamespaces {
    internal TypeProviderConfig cfg;
    internal FSharpRef`1<JsonProvider> this;
    internal Assembly asm;
    internal string ns;
    internal int init@21-16;
    public JsonProvider(TypeProviderConfig cfg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ProvidedTypeDefinition buildTypes(string typeName, Object[] args);
}
[CompilationMappingAttribute]
public static class ProviderImplementation.JsonTypeBuilder : object {
    [DebuggerBrowsableAttribute("0")]
internal static T100008_352Bytes@ field100009@;
    [DebuggerBrowsableAttribute("0")]
internal static T100010_342Bytes@ field100011@;
    [DebuggerBrowsableAttribute("0")]
internal static T100012_345Bytes@ field100013@;
    [DebuggerBrowsableAttribute("0")]
internal static T100014_341Bytes@ field100015@;
    [DebuggerBrowsableAttribute("0")]
internal static T100024_381Bytes@ field100025@;
    [DebuggerBrowsableAttribute("0")]
internal static T100026_424Bytes@ field100027@;
    [DebuggerBrowsableAttribute("0")]
internal static T100035_361Bytes@ field100036@;
    [DebuggerBrowsableAttribute("0")]
internal static T100037_362Bytes@ field100038@;
    [DebuggerBrowsableAttribute("0")]
internal static T100039_357Bytes@ field100040@;
    [DebuggerBrowsableAttribute("0")]
internal static T100044_351Bytes@ field100045@;
    [DebuggerBrowsableAttribute("0")]
internal static T100012_345Bytes@ field100046@;
    [DebuggerBrowsableAttribute("0")]
internal static T100047_377Bytes@ field100048@;
    [DebuggerBrowsableAttribute("0")]
internal static T100014_341Bytes@ field100049@;
    [DebuggerBrowsableAttribute("0")]
internal static T100053_364Bytes@ field100054@;
    public static FSharpFunc`2<Type, FSharpFunc`2<string, FSharpFunc`2<a, FSharpFunc`2<b, FSharpExpr>>>> op_Dynamic();
    internal static InferedType normalize@116(bool topLevel, InferedType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonGenerationResult getOrCreateType(JsonGenerationContext ctx, InferedType inferedType, FSharpFunc`2<Unit, ProvidedTypeDefinition> createType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type replaceJDocWithJValue(JsonGenerationContext ctx, Type typ);
    internal static string getTypeName@202(InferedTypeTag tag, InferedMultiplicity multiplicity, InferedType inferedType);
    internal static FSharpFunc`2<a, FSharpExpr> ctorCode@298-2(string cultureStr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProvidedTypeDefinition generateMultipleChoiceType(JsonGenerationContext ctx, IEnumerable`1<KeyValuePair`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>>> types, bool forCollection, string nameOverride, FSharpFunc`2<InferedMultiplicity, FSharpFunc`2<JsonGenerationResult, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>>>> codeGenerator);
    internal static InferedType dropRecordName@404(InferedType infType);
    internal static InferedTypeTag dropTagName@409(InferedTypeTag tag);
    internal static InferedType dropRecordsNames@402(InferedType infType);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> itemsGetter@475(JsonGenerationContext ctx, JsonGenerationResult keyResult, JsonGenerationResult valueResult, Type valueConvertedTypeErased);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> keysGetter@480(JsonGenerationContext ctx, JsonGenerationResult keyResult);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> valuesGetter@485(JsonGenerationContext ctx, JsonGenerationResult valueResult, Type valueConvertedTypeErased);
    internal static Tuple`2<a, a> |Doubleton|@490(FSharpList`1<a> _arg7);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> itemGetter@495(JsonGenerationContext ctx, JsonGenerationResult keyResult, JsonGenerationResult valueResult, Type valueConvertedTypeErased);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> tryFindCode@500(JsonGenerationContext ctx, JsonGenerationResult keyResult, JsonGenerationResult valueResult, Type valueConvertedTypeErased);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpExpr> containsKeyCode@505(JsonGenerationContext ctx, JsonGenerationResult keyResult);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonGenerationResult generateJsonType(JsonGenerationContext ctx, bool canPassAllConversionCallingTypes, bool optionalityHandledByParent, string nameOverride, InferedType inferedType);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.PrimitiveInferedValueExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type PrimitiveInferedValue.get_TypeWithMeasure(PrimitiveInferedValue );
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.AssemblyReader : object {
    internal static char convDigit@2138(int digit);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2490(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2490-1(IComparer comp, ILConst this, ILConst objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@2490-1(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@3139(IEqualityComparer comp, ILAssemblyManifest this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3139-2(ILAssemblyManifest this, ILAssemblyManifest that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3139-3(ILAssemblyManifest this, ILAssemblyManifest obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@3167-1(IEqualityComparer comp, ILModuleDef this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3167-5(ILModuleDef this, ILModuleDef that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3167-4(ILModuleDef this, ILModuleDef that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3167-7(ILModuleDef this, ILModuleDef obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3167-6(ILModuleDef this, ILModuleDef obj, Unit unitVar);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.ConstructorSymbol : ConstructorInfo {
    internal ITypeBuilder typeBuilder;
    internal ConstructorInfo inp;
    internal Type declTy;
    internal Tuple`2<Type[], Type[]> gps;
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public ConstructorSymbol(Type declTy, ConstructorInfo inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual MethodAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual ParameterInfo[] GetParameters();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual object Invoke(BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Object[] GetCustomAttributes(bool inherited);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherited);
    public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo Make(ITypeBuilder typeBuilder, Type declTy, ConstructorInfo md);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.EventSymbol : EventInfo {
    internal ITypeBuilder typeBuilder;
    internal EventInfo inp;
    internal Type declTy;
    internal Type[] gps;
    public string Name { get; }
    public EventAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type EventHandlerType { get; }
    public int MetadataToken { get; }
    public Type ReflectedType { get; }
    public EventSymbol(Type declTy, EventInfo inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual EventAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_EventHandlerType();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual MethodInfo GetRaiseMethod(bool _nonPublic);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherited);
    public virtual Object[] GetCustomAttributes(Type _attributeType, bool _inherited);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EventInfo Make(ITypeBuilder typeBuilder, Type declTy, EventInfo md);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.FieldSymbol : FieldInfo {
    internal ITypeBuilder typeBuilder;
    internal FieldInfo inp;
    internal Type declTy;
    internal Type[] gps;
    public string Name { get; }
    public FieldAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type FieldType { get; }
    public int MetadataToken { get; }
    public Type ReflectedType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldSymbol(Type declTy, FieldInfo inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual FieldAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_FieldType();
    public virtual object GetRawConstantValue();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherited);
    public virtual Object[] GetCustomAttributes(Type _attributeType, bool _inherited);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual void SetValue(object _obj, object _value, BindingFlags _invokeAttr, Binder _binder, CultureInfo _culture);
    public virtual object GetValue(object _obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo Make(ITypeBuilder typeBuilder, Type declTy, FieldInfo md);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.ImplementationUtils : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object Object.GetProperty(object x, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object Object.GetField(object x, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Object.HasProperty(object x, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Object.HasField(object x, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<object> Object.GetElements(object );
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.MethodSymbol : MethodInfo {
    internal ITypeBuilder typeBuilder;
    internal MethodInfo inp;
    internal Type declTy;
    internal Type[] gps2;
    internal Tuple`2<Type[], Type[]> gps;
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    public MethodSymbol(Type declTy, MethodInfo inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual MethodAttributes get_Attributes();
    public virtual ParameterInfo[] GetParameters();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_ReturnType();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual MethodInfo MakeGenericMethod(Type[] args);
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherited);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherited);
    public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo Make(ITypeBuilder typeBuilder, Type declTy, MethodInfo md);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.MethodSymbol2 : MethodInfo {
    internal ITypeBuilder typeBuilder;
    internal MethodInfo gmd;
    internal Type[] gargs;
    internal Type dty;
    internal Type[] dinst;
    public MethodAttributes Attributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public bool IsGenericMethod { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    public MethodSymbol2(MethodInfo gmd, Type[] gargs, ITypeBuilder typeBuilder);
    public virtual MethodAttributes get_Attributes();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo[] GetParameters();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_ReturnType();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual int get_MetadataToken();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherited);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherited);
    public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.Misc : object {
    internal static CustomAttributeData mkParamArrayCustomAttributeData();
    internal static CustomAttributeData mkEditorHideMethodsCustomAttributeData();
    internal static CustomAttributeData mkAllowNullLiteralCustomAttributeData(a value);
    internal static CustomAttributeData mkXmlDocCustomAttributeDataLazy(Lazy`1<string> lazyText);
    internal static CustomAttributeData mkXmlDocCustomAttributeData(string s);
    internal static CustomAttributeData mkDefinitionLocationAttributeCustomAttributeData(int line, int column, string filePath);
    internal static CustomAttributeData mkObsoleteAttributeCustomAttributeData(string message, bool isError);
    internal static CustomAttributeData mkReflectedDefinitionCustomAttributeData();
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.PropertySymbol : PropertyInfo {
    internal ITypeBuilder typeBuilder;
    internal PropertyInfo inp;
    internal Type declTy;
    internal Tuple`2<Type[], Type[]> gps;
    public string Name { get; }
    public PropertyAttributes Attributes { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type PropertyType { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int MetadataToken { get; }
    public Type ReflectedType { get; }
    public PropertySymbol(Type declTy, PropertyInfo inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual PropertyAttributes get_Attributes();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual object GetValue(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _index, CultureInfo _culture);
    public virtual void SetValue(object _obj, object _value, BindingFlags _invokeAttr, Binder _binder, Object[] _index, CultureInfo _culture);
    public virtual MethodInfo[] GetAccessors(bool _nonPublic);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherited);
    public virtual Object[] GetCustomAttributes(Type _attributeType, bool _inherited);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyInfo Make(ITypeBuilder typeBuilder, Type declTy, PropertyInfo md);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.ProvidedAssembly : Assembly {
    internal bool isTgt;
    internal AssemblyName assemblyName;
    internal string assemblyFileName;
    internal CustomAttributesImpl customAttributesImpl;
    internal List`1<Tuple`2<ProvidedTypeDefinition[], FSharpOption`1<FSharpList`1<string>>>> theTypes;
    internal Lazy`1<Type[]> theTypesArray;
    public string FullName { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    internal bool BelongsToTargetModel { get; }
    public ProvidedAssembly(bool isTgt, AssemblyName assemblyName, string assemblyFileName, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedAssembly(AssemblyName assemblyName, string assemblyFileName);
    internal void AddCustomAttribute(CustomAttributeData attribute);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual AssemblyName GetName();
    public virtual string get_FullName();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual Type[] GetTypes();
    public virtual string ToString();
    public virtual Type GetType(string nm);
    internal bool get_BelongsToTargetModel();
    internal void AddNestedTypes(FSharpList`1<ProvidedTypeDefinition> types, FSharpList`1<string> enclosingGeneratedTypeNames);
    internal void AddTypes(FSharpList`1<ProvidedTypeDefinition> types);
    internal void AddTheTypes(ProvidedTypeDefinition[] types, FSharpOption`1<FSharpList`1<string>> enclosingGeneratedTypeNames);
    internal Tuple`2[] GetTheTypes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [CompilerGeneratedAttribute]
internal void addTypes(ProvidedTypeDefinition[] ptds, FSharpOption`1<FSharpList`1<string>> enclosingTypeNames);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedConstructor : ConstructorInfo {
    internal ProvidedParameter[] parameters;
    internal bool isTgt;
    internal FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> invokeCode;
    internal ParameterInfo[] parameterInfos;
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>>> baseCall@996;
    internal FSharpOption`1<ProvidedTypeDefinition> declaringType;
    internal bool isImplicitCtor@998;
    internal MethodAttributes attrs@999;
    internal CustomAttributesImpl customAttributesImpl;
    public bool IsTypeInitializer { get; public set; }
    unknown FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> BaseConstructorCall {public set; }
    public bool IsImplicitConstructor { get; public set; }
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>>> BaseCall { get; }
    internal ProvidedParameter[] Parameters { get; }
    internal bool BelongsToTargetModel { get; }
    internal FSharpOption`1<ProvidedTypeDefinition> DeclaringProvidedType { get; }
    internal bool IsErased { get; }
    public MethodAttributes Attributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    internal ProvidedConstructor(bool isTgt, MethodAttributes attrs, ProvidedParameter[] parameters, FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> invokeCode, FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>>> baseCall, bool isImplicitCtor, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedConstructor(FSharpList`1<ProvidedParameter> parameters, FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> invokeCode);
    public bool get_IsTypeInitializer();
    public void set_IsTypeInitializer(bool v);
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddObsoleteAttribute(string message, FSharpOption`1<bool> isError);
    public void AddDefinitionLocation(int line, int column, string filePath);
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public void set_BaseConstructorCall(FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> d);
    public bool get_IsImplicitConstructor();
    public void set_IsImplicitConstructor(bool v);
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>>> get_BaseCall();
    internal ProvidedParameter[] get_Parameters();
    internal FSharpExpr GetInvokeCode(FSharpList`1<FSharpExpr> args);
    internal bool get_BelongsToTargetModel();
    internal FSharpOption`1<ProvidedTypeDefinition> get_DeclaringProvidedType();
    internal bool get_IsErased();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual object Invoke(BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [CompilerGeneratedAttribute]
internal bool isStatic();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedEvent : EventInfo {
    internal FSharpFunc`2<Unit, MethodInfo> remover;
    internal bool isTgt;
    internal bool isStatic;
    internal string eventName;
    internal Type eventHandlerType;
    internal EventAttributes attrs;
    internal FSharpFunc`2<Unit, MethodInfo> adder;
    internal FSharpOption`1<ProvidedTypeDefinition> declaringType;
    internal CustomAttributesImpl customAttributesImpl;
    public bool IsStatic { get; }
    internal MethodInfo Adder { get; }
    internal MethodInfo Remover { get; }
    internal bool BelongsToTargetModel { get; }
    public Type EventHandlerType { get; }
    public EventAttributes Attributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    internal ProvidedEvent(bool isTgt, string eventName, EventAttributes attrs, Type eventHandlerType, bool isStatic, FSharpFunc`2<Unit, MethodInfo> adder, FSharpFunc`2<Unit, MethodInfo> remover, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedEvent(string eventName, Type eventHandlerType, FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> adderCode, FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> removerCode, FSharpOption`1<bool> isStatic);
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddDefinitionLocation(int line, int column, string filePath);
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public bool get_IsStatic();
    internal MethodInfo get_Adder();
    internal MethodInfo get_Remover();
    internal bool get_BelongsToTargetModel();
    public virtual Type get_EventHandlerType();
    public virtual MethodInfo GetAddMethod(bool _nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool _nonPublic);
    public virtual EventAttributes get_Attributes();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual MethodInfo GetRaiseMethod(bool _nonPublic);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedField : FieldInfo {
    internal object rawConstantValue;
    internal bool isTgt;
    internal Type fieldType;
    internal string fieldName;
    internal FSharpOption`1<ProvidedTypeDefinition> declaringType;
    internal CustomAttributesImpl customAttributesImpl;
    internal FieldAttributes attrs@1272;
    internal bool BelongsToTargetModel { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    internal ProvidedField(bool isTgt, string fieldName, FieldAttributes attrs, Type fieldType, object rawConstantValue, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedField(string fieldName, Type fieldType);
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddObsoleteAttribute(string message, FSharpOption`1<bool> isError);
    public void AddDefinitionLocation(int line, int column, string filePath);
    public void SetFieldAttributes(FieldAttributes attributes);
    internal bool get_BelongsToTargetModel();
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public void AddCustomAttribute(CustomAttributeData attribute);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type get_FieldType();
    public virtual object GetRawConstantValue();
    public virtual FieldAttributes get_Attributes();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual void SetValue(object _obj, object _value, BindingFlags _invokeAttr, Binder _binder, CultureInfo _culture);
    public virtual object GetValue(object _obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public static ProvidedField Literal(string fieldName, Type fieldType, object literalValue);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedMeasureBuilder : object {
    internal static FSharpSet`1<string> unitNamesTypeAbbreviations;
    internal static FSharpSet`1<string> unitSymbolsTypeAbbreviations;
    internal static int init@1310-3;
    public static Type One { get; }
    private static ProvidedMeasureBuilder();
    public static Type get_One();
    public static Type Product(Type measure1, Type measure2);
    public static Type Inverse(Type denominator);
    public static Type Ratio(Type numerator, Type denominator);
    public static Type Square(Type measure);
    public static Type SI(string unitName);
    public static Type AnnotateType(Type basic, FSharpList`1<Type> argument);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedMethod : MethodInfo {
    internal Type returnType;
    internal ProvidedParameter[] parameters;
    internal string methodName;
    internal bool isTgt;
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> invokeCode;
    internal ParameterInfo[] parameterInfos;
    internal FSharpOption`1<ProvidedTypeDefinition> declaringType;
    internal MethodAttributes attrs@1055;
    internal FSharpList`1<ProvidedStaticParameter> staticParams@1056;
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedMethod>>> staticParamsApply@1057;
    internal CustomAttributesImpl customAttributesImpl;
    internal FSharpOption`1<Type> returnTypeFixCache;
    internal ProvidedParameter[] Parameters { get; }
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> GetInvokeCode { get; }
    internal FSharpList`1<ProvidedStaticParameter> StaticParams { get; }
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedMethod>>> StaticParamsApply { get; }
    internal bool BelongsToTargetModel { get; }
    internal FSharpOption`1<ProvidedTypeDefinition> DeclaringProvidedType { get; }
    internal bool IsErased { get; }
    public MethodAttributes Attributes { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    internal ProvidedMethod(bool isTgt, string methodName, MethodAttributes attrs, ProvidedParameter[] parameters, Type returnType, FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> invokeCode, FSharpList`1<ProvidedStaticParameter> staticParams, FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedMethod>>> staticParamsApply, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedMethod(string methodName, FSharpList`1<ProvidedParameter> parameters, Type returnType, FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> invokeCode, FSharpOption`1<bool> isStatic);
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddObsoleteAttribute(string message, FSharpOption`1<bool> isError);
    public void AddDefinitionLocation(int line, int column, string filePath);
    public void AddCustomAttribute(CustomAttributeData attribute);
    public void SetMethodAttrs(MethodAttributes attributes);
    public void AddMethodAttrs(MethodAttributes attributes);
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public void DefineStaticParameters(FSharpList`1<ProvidedStaticParameter> parameters, FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedMethod>> instantiationFunction);
    internal ParameterInfo[] GetStaticParametersInternal();
    internal ProvidedMethod ApplyStaticArguments(string mangledName, Object[] args);
    internal ProvidedParameter[] get_Parameters();
    internal FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> get_GetInvokeCode();
    internal FSharpList`1<ProvidedStaticParameter> get_StaticParams();
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedMethod>>> get_StaticParamsApply();
    internal bool get_BelongsToTargetModel();
    internal FSharpOption`1<ProvidedTypeDefinition> get_DeclaringProvidedType();
    internal bool get_IsErased();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual MemberTypes get_MemberType();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual string ToString();
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedParameter : ParameterInfo {
    internal Type parameterType;
    internal string parameterName;
    internal FSharpOption`1<object> optionalValue;
    internal bool isTgt;
    internal ParameterAttributes attrs;
    internal CustomAttributesImpl customAttributesImpl;
    unknown bool IsParamArray {public set; }
    unknown bool IsReflectedDefinition {public set; }
    internal FSharpOption`1<object> OptionalValue { get; }
    public bool HasDefaultParameterValue { get; }
    internal bool BelongsToTargetModel { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public ParameterAttributes Attributes { get; }
    public object RawDefaultValue { get; }
    internal ProvidedParameter(bool isTgt, string parameterName, ParameterAttributes attrs, Type parameterType, FSharpOption`1<object> optionalValue, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedParameter(string parameterName, Type parameterType, FSharpOption`1<bool> isOut, FSharpOption`1<object> optionalValue);
    internal ProvidedParameter(bool _isTgt, string parameterName, Type parameterType, FSharpOption`1<bool> isOut, FSharpOption`1<object> optionalValue);
    public void set_IsParamArray(bool v);
    public void set_IsReflectedDefinition(bool v);
    internal FSharpOption`1<object> get_OptionalValue();
    public bool get_HasDefaultParameterValue();
    internal bool get_BelongsToTargetModel();
    public void AddCustomAttribute(CustomAttributeData attribute);
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual ParameterAttributes get_Attributes();
    public virtual object get_RawDefaultValue();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedProperty : PropertyInfo {
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> setter;
    internal Type propertyType;
    internal string propertyName;
    internal bool isTgt;
    internal bool isStatic;
    internal ProvidedParameter[] indexParameters;
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> getter;
    internal PropertyAttributes attrs;
    internal FSharpOption`1<ProvidedTypeDefinition> declaringType;
    internal CustomAttributesImpl customAttributesImpl;
    public bool IsStatic { get; }
    internal ProvidedParameter[] IndexParameters { get; }
    internal bool BelongsToTargetModel { get; }
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> Getter { get; }
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> Setter { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    internal ProvidedProperty(bool isTgt, string propertyName, PropertyAttributes attrs, Type propertyType, bool isStatic, FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> getter, FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> setter, ProvidedParameter[] indexParameters, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedProperty(string propertyName, Type propertyType, FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> getterCode, FSharpOption`1<FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr>> setterCode, FSharpOption`1<bool> isStatic, FSharpOption`1<FSharpList`1<ProvidedParameter>> indexParameters);
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddObsoleteAttribute(string message, FSharpOption`1<bool> isError);
    public void AddDefinitionLocation(int line, int column, string filePath);
    public void AddCustomAttribute(CustomAttributeData attribute);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public bool get_IsStatic();
    internal ProvidedParameter[] get_IndexParameters();
    internal bool get_BelongsToTargetModel();
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> get_Getter();
    internal FSharpOption`1<FSharpFunc`2<Unit, MethodInfo>> get_Setter();
    public virtual Type get_PropertyType();
    public virtual void SetValue(object _obj, object _value, BindingFlags _invokeAttr, Binder _binder, Object[] _index, CultureInfo _culture);
    public virtual MethodInfo[] GetAccessors(bool _nonPublic);
    public virtual MethodInfo GetGetMethod(bool _nonPublic);
    public virtual MethodInfo GetSetMethod(bool _nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object GetValue(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _index, CultureInfo _culture);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedStaticParameter : ParameterInfo {
    internal Type parameterType;
    internal string parameterName;
    internal FSharpOption`1<object> parameterDefaultValue;
    internal bool isTgt;
    internal CustomAttributesImpl customAttributesImpl;
    internal FSharpOption`1<object> ParameterDefaultValue { get; }
    internal bool BelongsToTargetModel { get; }
    public object RawDefaultValue { get; }
    public ParameterAttributes Attributes { get; }
    public int Position { get; }
    public Type ParameterType { get; }
    public string Name { get; }
    internal ProvidedStaticParameter(bool isTgt, string parameterName, Type parameterType, FSharpOption`1<object> parameterDefaultValue, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData);
    public ProvidedStaticParameter(string parameterName, Type parameterType, FSharpOption`1<object> parameterDefaultValue);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    internal void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    internal FSharpOption`1<object> get_ParameterDefaultValue();
    internal bool get_BelongsToTargetModel();
    public virtual object get_RawDefaultValue();
    public virtual ParameterAttributes get_Attributes();
    public virtual int get_Position();
    public virtual Type get_ParameterType();
    public virtual string get_Name();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.ProvidedSymbolMethod : MethodInfo {
    internal ITypeBuilder typeBuilder;
    internal Type[] parameters;
    internal MethodInfo genericMethodDefinition;
    public bool IsGenericMethod { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public MemberTypes MemberType { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Type ReflectedType { get; }
    public ProvidedSymbolMethod(MethodInfo genericMethodDefinition, Type[] parameters, ITypeBuilder typeBuilder);
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual Type get_DeclaringType();
    public virtual string ToString();
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MemberTypes get_MemberType();
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(object _obj, BindingFlags _invokeAttr, Binder _binder, Object[] _parameters, CultureInfo _culture);
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    [CompilerGeneratedAttribute]
internal ParameterInfo convParam(ParameterInfo p);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedTypeBuilder : object {
    internal static String[] tupleNames;
    internal static int init@8430-11;
    internal static ITypeBuilder typeBuilder { get; }
    private static ProvidedTypeBuilder();
    public static Type MakeGenericType(Type genericTypeDefinition, FSharpList`1<Type> genericArguments);
    public static MethodInfo MakeGenericMethod(MethodInfo genericMethodDefinition, FSharpList`1<Type> genericArguments);
    public static Type MakeTupleType(FSharpList`1<Type> types, bool isStruct);
    public static Type MakeTupleType(FSharpList`1<Type> types);
    internal static ITypeBuilder get_typeBuilder();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition : TypeDelegator {
    internal ITypeBuilder typeBuilder;
    internal bool isTgt;
    internal string className;
    internal FSharpOption`1<Tuple`4<FSharpFunc`2<Unit, bool>, FSharpFunc`2<Unit, MemberInfo[]>, FSharpFunc`2<Unit, Type[]>, FSharpFunc`2<Unit, Tuple`2[]>>> backingDataSource;
    internal FSharpRef`1<ProvidedTypeDefinition> this;
    internal TypeAttributes attrs@1382;
    internal Lazy`1<FSharpOption`1<Type>> enumUnderlyingType;
    internal Lazy`1<FSharpOption`1<Type>> baseType;
    internal List`1<MemberInfo> members;
    internal List`1<FSharpFunc`2<Unit, MemberInfo[]>> membersQueue;
    internal bool staticParamsDefined;
    internal Lazy`1<FSharpList`1<ProvidedStaticParameter>> staticParams;
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedTypeDefinition>>> staticParamsApply@1394;
    internal TypeContainer container@1395;
    internal List`1<Type> interfaceImpls;
    internal List`1<FSharpFunc`2<Unit, Type[]>> interfacesQueue;
    internal List`1<Tuple`2<ProvidedMethod, MethodInfo>> methodOverrides;
    internal List`1<FSharpFunc`2<Unit, Tuple`2[]>> methodOverridesQueue;
    internal Dictionary`2<int, object> bindings;
    internal CustomAttributesImpl customAttributesImpl;
    internal int init@1366-2;
    public Type UnderlyingSystemType { get; }
    public Assembly Assembly { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsEnum { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public string AssemblyQualifiedName { get; }
    internal bool BelongsToTargetModel { get; }
    internal TypeAttributes AttributesRaw { get; }
    internal TypeContainer Container { get; }
    internal FSharpList`1<ProvidedStaticParameter> StaticParams { get; }
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedTypeDefinition>>> StaticParamsApply { get; }
    internal Type ErasedBaseType { get; }
    public bool HideObjectMethods { get; internal set; }
    public bool NonNullable { get; internal set; }
    public bool IsErased { get; internal set; }
    [ExperimentalAttribute("SuppressRelocation is a workaround and likely to be removed")]
public bool SuppressRelocation { get; public set; }
    public static FSharpRef`1<FSharpOption`1<FSharpFunc`2<string, Unit>>> Logger { get; }
    internal ProvidedTypeDefinition(bool isTgt, TypeContainer container, string className, FSharpFunc`2<Unit, FSharpOption`1<Type>> getBaseType, TypeAttributes attrs, FSharpFunc`2<Unit, FSharpOption`1<Type>> getEnumUnderlyingType, FSharpFunc`2<Unit, FSharpList`1<ProvidedStaticParameter>> getStaticParams, FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedTypeDefinition>>> staticParamsApply, FSharpOption`1<Tuple`4<FSharpFunc`2<Unit, bool>, FSharpFunc`2<Unit, MemberInfo[]>, FSharpFunc`2<Unit, Type[]>, FSharpFunc`2<Unit, Tuple`2[]>>> backingDataSource, FSharpFunc`2<Unit, CustomAttributeData[]> customAttributesData, bool nonNullable, bool hideObjectMethods, ITypeBuilder typeBuilder);
    public ProvidedTypeDefinition(Assembly assembly, string namespaceName, string className, FSharpOption`1<Type> baseType, FSharpOption`1<bool> hideObjectMethods, FSharpOption`1<bool> nonNullable, FSharpOption`1<bool> isErased, FSharpOption`1<bool> isSealed, FSharpOption`1<bool> isInterface, FSharpOption`1<bool> isAbstract);
    public ProvidedTypeDefinition(string className, FSharpOption`1<Type> baseType, FSharpOption`1<bool> hideObjectMethods, FSharpOption`1<bool> nonNullable, FSharpOption`1<bool> isErased, FSharpOption`1<bool> isSealed, FSharpOption`1<bool> isInterface, FSharpOption`1<bool> isAbstract);
    private static ProvidedTypeDefinition();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type get_UnderlyingSystemType();
    public virtual Assembly get_Assembly();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingFlags);
    public virtual EventInfo[] GetEvents(BindingFlags bindingFlags);
    public virtual Type[] GetNestedTypes(BindingFlags bindingFlags);
    public virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingFlags, Binder _binder, CallingConventions _callConventions, Type[] _types, ParameterModifier[] _modifiers);
    public virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingFlags, Binder _binderBinder, CallingConventions _callConvention, Type[] _types, ParameterModifier[] _modifiers);
    public virtual FieldInfo GetField(string name, BindingFlags bindingFlags);
    public virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingFlags, Binder _binder, Type _returnType, Type[] _types, ParameterModifier[] _modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingFlags);
    public virtual Type GetNestedType(string name, BindingFlags bindingFlags);
    public virtual Type GetInterface(string _name, bool _ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int arg);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual MemberInfo[] GetMembers(BindingFlags bindingFlags);
    public virtual MemberInfo[] GetMember(string name, MemberTypes mt, BindingFlags _bindingFlags);
    public virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool IsValueTypeImpl();
    public virtual bool get_IsEnum();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsArrayImpl();
    public virtual bool IsByRefImpl();
    public virtual bool IsPointerImpl();
    public virtual bool IsPrimitiveImpl();
    public virtual bool IsCOMObjectImpl();
    public virtual bool HasElementTypeImpl();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual int GetHashCode();
    public virtual bool Equals(object that);
    public virtual bool Equals(Type that);
    public virtual bool IsAssignableFrom(Type otherTy);
    public virtual bool IsSubclassOf(Type otherTy);
    public virtual Type[] GetGenericArguments();
    public virtual string ToString();
    public virtual Module get_Module();
    public virtual Guid get_GUID();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual Type GetElementType();
    public virtual object InvokeMember(string _name, BindingFlags _invokeAttr, Binder _binder, object _target, Object[] _args, ParameterModifier[] _modifiers, CultureInfo _culture, String[] _namedParameters);
    public virtual string get_AssemblyQualifiedName();
    public virtual EventInfo[] GetEvents();
    internal bool get_BelongsToTargetModel();
    internal TypeAttributes get_AttributesRaw();
    internal FSharpOption`1<Type> EnumUnderlyingTypeRaw();
    internal TypeContainer get_Container();
    internal FSharpOption`1<Type> BaseTypeRaw();
    internal FSharpList`1<ProvidedStaticParameter> get_StaticParams();
    internal FSharpOption`1<FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedTypeDefinition>>> get_StaticParamsApply();
    internal int CountMembersFromCursor(int idx);
    internal Tuple`2<MemberInfo[], int> GetMembersFromCursor(int idx);
    internal Tuple`2<Type[], int> GetInterfaceImplsFromCursor(int idx);
    internal Tuple`2<Tuple`2[], int> GetMethodOverridesFromCursor(int idx);
    internal Tuple`2[] GetMethodOverrides();
    internal Type get_ErasedBaseType();
    public void AddXmlDocComputed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDocDelayed(FSharpFunc`2<Unit, string> xmlDocFunction);
    public void AddXmlDoc(string xmlDoc);
    public void AddObsoleteAttribute(string message, FSharpOption`1<bool> isError);
    public void AddDefinitionLocation(int line, int column, string filePath);
    public bool get_HideObjectMethods();
    internal void set_HideObjectMethods(bool v);
    public bool get_NonNullable();
    internal void set_NonNullable(bool v);
    public void AddCustomAttribute(CustomAttributeData attribute);
    public void SetEnumUnderlyingType(Type ty);
    public void SetBaseType(Type t);
    public void SetBaseTypeDelayed(FSharpFunc`2<Unit, Type> baseTypeFunction);
    internal void AddAttributes(TypeAttributes x);
    public void SetAttributes(TypeAttributes x);
    public void AddMembers(FSharpList`1<?> memberInfos);
    public void AddMember(MemberInfo memberInfo);
    public void AddMembersDelayed(FSharpFunc`2<Unit, FSharpList`1<?>> membersFunction);
    public void AddMemberDelayed(FSharpFunc`2<Unit, ?> memberFunction);
    public void AddAssemblyTypesAsNestedTypesDelayed(FSharpFunc`2<Unit, Assembly> assemblyFunction);
    public void DefineStaticParameters(FSharpList`1<ProvidedStaticParameter> parameters, FSharpFunc`2<string, FSharpFunc`2<Object[], ProvidedTypeDefinition>> instantiationFunction);
    internal ParameterInfo[] GetStaticParametersInternal();
    public ProvidedTypeDefinition ApplyStaticArguments(string name, Object[] args);
    internal void PatchDeclaringType(ProvidedTypeDefinition x);
    public bool get_IsErased();
    internal void set_IsErased(bool v);
    public bool get_SuppressRelocation();
    public void set_SuppressRelocation(bool v);
    public void AddInterfaceImplementation(Type interfaceType);
    public void AddInterfaceImplementationsDelayed(FSharpFunc`2<Unit, FSharpList`1<Type>> interfacesFunction);
    internal void SetAssemblyInternal(FSharpFunc`2<Unit, Assembly> assembly);
    public void DefineMethodOverride(ProvidedMethod methodInfoBody, MethodInfo methodInfoDeclaration);
    public void DefineMethodOverridesDelayed(FSharpFunc`2<Unit, FSharpList`1<Tuple`2<ProvidedMethod, MethodInfo>>> f);
    public static Type EraseType(Type typ);
    internal void PatchDeclaringTypeOfMember(MemberInfo m);
    public static FSharpRef`1<FSharpOption`1<FSharpFunc`2<string, Unit>>> get_Logger();
    [CompilerGeneratedAttribute]
internal static TypeAttributes defaultAttributes(bool isErased, bool isSealed, bool isInterface, bool isAbstract);
    [CompilerGeneratedAttribute]
internal bool checkFreshMembers();
    [CompilerGeneratedAttribute]
internal bool moreMembers();
    [CompilerGeneratedAttribute]
internal void evalMembers();
    [CompilerGeneratedAttribute]
internal MemberInfo[] getMembers();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal T save(BindingFlags key, FSharpFunc`2<Unit, T> f);
    [CompilerGeneratedAttribute]
internal void evalInterfaces();
    [CompilerGeneratedAttribute]
internal Type[] getInterfaces();
    [CompilerGeneratedAttribute]
internal void evalMethodOverrides();
    [CompilerGeneratedAttribute]
internal Tuple`2[] getFreshMethodOverrides();
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedTypesContext : object {
    internal FSharpList`1<Tuple`2<string, string>> assemblyReplacementMap;
    internal FSharpRef`1<ProvidedTypesContext> this;
    internal Lazy`1<Version> fsharpCoreRefVersion;
    internal Lazy`1<ILGlobals> ilGlobals;
    internal ConcurrentDictionary`2<string, FSharpChoice`2<Assembly, Exception>> targetAssembliesTable_;
    internal List`1<Assembly> targetAssemblies_;
    internal List`1<FSharpFunc`2<Unit, Unit>> targetAssembliesQueue;
    internal Lazy`1<Unit> registerAdditionalTargetAssembliesOnce;
    internal ConcurrentDictionary`2<string, Assembly> sourceAssembliesTable_;
    internal List`1<Assembly> sourceAssemblies_;
    internal List`1<FSharpFunc`2<Unit, Assembly[]>> sourceAssembliesQueue;
    internal Dictionary`2<FSharpVar, FSharpVar> varTableFwd;
    internal Dictionary`2<FSharpVar, FSharpVar> varTableBwd;
    internal Dictionary`2<Assembly, Assembly> assemblyTableFwd;
    internal Dictionary`2<Type, Type> typeTableFwd;
    internal Dictionary`2<Type, Type> typeTableBwd;
    internal ITypeBuilder typeBuilder;
    internal int init@8946-12;
    internal ILGlobals ILGlobals { get; }
    public Version FSharpCoreAssemblyVersion { get; }
    internal ProvidedTypesContext(TypeProviderConfig config, FSharpList`1<Tuple`2<string, string>> assemblyReplacementMap, FSharpList`1<Assembly> sourceAssemblies);
    internal MethodInfo ConvertSourceMethodRefToTarget(MethodInfo t);
    internal ConstructorInfo ConvertSourceConstructorRefToTarget(ConstructorInfo t);
    public Type ConvertSourceTypeToTarget(Type t);
    public Type ConvertTargetTypeToSource(Type t);
    public FSharpExpr ConvertSourceExprToTarget(FSharpExpr e);
    internal IProvidedNamespace ConvertSourceNamespaceToTarget(IProvidedNamespace ns);
    internal ProvidedTypeDefinition ConvertSourceProvidedTypeDefinitionToTarget(ProvidedTypeDefinition ptd);
    internal FSharpChoice`2<Assembly, Exception> TryBindILAssemblyRefToTgt(ILAssemblyRef aref);
    public FSharpChoice`2<Assembly, Exception> TryBindAssemblyNameToTarget(AssemblyName aref);
    public FSharpChoice`2<Assembly, Exception> TryBindSimpleAssemblyNameToTarget(string assemblyName);
    internal ILGlobals get_ILGlobals();
    public Assembly[] GetTargetAssemblies();
    public Assembly[] GetSourceAssemblies();
    public Version get_FSharpCoreAssemblyVersion();
    public Assembly ReadRelatedAssembly(string fileName);
    public Assembly ReadRelatedAssembly(Byte[] bytes);
    public void AddSourceAssembly(Assembly asm);
    internal void AddTargetAssembly(AssemblyName asmName, Assembly asm);
    internal static ProvidedTypesContext Create(TypeProviderConfig config, FSharpList`1<Tuple`2<string, string>> assemblyReplacementMap, FSharpList`1<Assembly> sourceAssemblies);
    [CompilerGeneratedAttribute]
internal FSharpChoice`2<Assembly, Exception> mkReader(string ref);
    [CompilerGeneratedAttribute]
internal void registerTargetAssemblyPaths(String[] targetAssemblyPaths);
    [CompilerGeneratedAttribute]
internal void flushTargetAssemblies();
    [CompilerGeneratedAttribute]
internal List`1<Assembly> getTargetAssemblies();
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, FSharpChoice`2<Assembly, Exception>> getTargetAssembliesTable();
    [CompilerGeneratedAttribute]
internal FSharpChoice`2<Assembly, Exception> tryBindTargetAssemblySimple(string simpleName);
    [CompilerGeneratedAttribute]
internal void enqueueReferencedAssemblies(Assembly asm);
    [CompilerGeneratedAttribute]
internal List`1<Assembly> getSourceAssemblies();
    [CompilerGeneratedAttribute]
internal string fixName(string fullName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<Type, bool>> tryGetTypeFromAssembly(a toTgt, string originalAssemblyName, string fullName, Assembly asm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Type convTypeRef(bool toTgt, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Type convType(bool toTgt, Type t);
    [CompilerGeneratedAttribute]
internal Type convTypeToTgt(Type ty);
    [CompilerGeneratedAttribute]
internal Type convTypeToSrc(Type ty);
    [CompilerGeneratedAttribute]
internal PropertyInfo convPropertyRefToTgt(PropertyInfo p);
    [CompilerGeneratedAttribute]
internal FieldInfo convFieldRefToTgt(FieldInfo f);
    [CompilerGeneratedAttribute]
internal MethodInfo convMethodRefToTgt(MethodInfo m);
    [CompilerGeneratedAttribute]
internal FSharpChoice`2<string, ConstructorInfo> tryConvConstructorRefToTgt(ConstructorInfo cons);
    [CompilerGeneratedAttribute]
internal ConstructorInfo convConstructorRefToTgt(ConstructorInfo cons);
    [CompilerGeneratedAttribute]
internal FSharpVar convVarToSrc(FSharpVar v);
    [CompilerGeneratedAttribute]
internal FSharpExpr convVarExprToSrc(FSharpExpr quotation);
    [CompilerGeneratedAttribute]
internal FSharpVar convVarToTgt(FSharpVar v);
    [CompilerGeneratedAttribute]
internal FSharpExpr convExprToTgt(FSharpExpr quotation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpExpr convCodeToTgt(FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> codeFun, bool isStatic, bool isCtor, ProvidedParameter[] parameters, bool isGenerated, FSharpList`1<a> argsT);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>> convBaseCallToTgt(FSharpFunc`2<FSharpList`1<FSharpExpr>, Tuple`2<ConstructorInfo, FSharpList`1<FSharpExpr>>> codeFun, bool isGenerated, FSharpList`1<b> argsT);
    [CompilerGeneratedAttribute]
internal MemberInfo convMemberRefToTgt(MemberInfo x);
    [CompilerGeneratedAttribute]
internal CustomAttributeTypedArgument convCustomAttributesTypedArg(CustomAttributeTypedArgument x);
    [CompilerGeneratedAttribute]
internal CustomAttributeNamedArgument convCustomAttributesNamedArg(CustomAttributeNamedArgument x);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<CustomAttributeData> tryConvCustomAttributeDataToTgt(CustomAttributeData x);
    [CompilerGeneratedAttribute]
internal CustomAttributeData[] convCustomAttributesDataToTgt(IList`1<CustomAttributeData> cattrs);
    [CompilerGeneratedAttribute]
internal ProvidedTypeDefinition convProvidedTypeDefToTgt(ProvidedTypeDefinition x);
    [CompilerGeneratedAttribute]
internal Type convTypeDefToTgt(Type x);
    [CompilerGeneratedAttribute]
internal ProvidedParameter convParameterDefToTgt(ProvidedParameter x);
    [CompilerGeneratedAttribute]
internal ProvidedStaticParameter convStaticParameterDefToTgt(ProvidedStaticParameter x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal MemberInfo convMemberDefToTgt(ProvidedTypeDefinition declTyT, MemberInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ProvidedMethod convProvidedMethodDefToTgt(ProvidedTypeDefinition declTyT, ProvidedMethod x);
    [CompilerGeneratedAttribute]
internal Assembly convProvidedAssembly(ProvidedAssembly assembly);
    [CompilerGeneratedAttribute]
internal IProvidedNamespace convNamespaceToTgt(IProvidedNamespace x);
}
[ClassAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.ProvidedTypeSymbol : TypeDelegator {
    internal ITypeBuilder typeBuilder;
    internal ProvidedTypeSymbolKind kind;
    internal FSharpRef`1<ProvidedTypeSymbol> this;
    internal Type[] typeArgs@582;
    internal int init@580-1;
    public string FullName { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type BaseType { get; }
    public bool IsGenericType { get; }
    public Assembly Assembly { get; }
    public string Namespace { get; }
    public Module Module { get; }
    internal ProvidedTypeSymbolKind Kind { get; }
    internal Type[] Args { get; }
    public bool IsFSharpTypeAbbreviation { get; }
    public bool IsFSharpUnitAnnotated { get; }
    public Type UnderlyingSystemType { get; }
    public MemberTypes MemberType { get; }
    public Guid GUID { get; }
    public string AssemblyQualifiedName { get; }
    public int MetadataToken { get; }
    internal ProvidedTypeSymbol(ProvidedTypeSymbolKind kind, FSharpList`1<Type> typeArgs, ITypeBuilder typeBuilder);
    public virtual string get_FullName();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_BaseType();
    public virtual int GetArrayRank();
    public virtual bool IsValueTypeImpl();
    public virtual bool IsArrayImpl();
    public virtual bool IsByRefImpl();
    public virtual bool IsPointerImpl();
    public virtual bool IsPrimitiveImpl();
    public virtual bool get_IsGenericType();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool IsCOMObjectImpl();
    public virtual bool HasElementTypeImpl();
    public virtual Type GetElementType();
    public virtual Assembly get_Assembly();
    public virtual string get_Namespace();
    public virtual Module get_Module();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public virtual bool Equals(Type otherTy);
    public virtual bool IsAssignableFrom(Type otherTy);
    public virtual bool IsSubclassOf(Type otherTy);
    internal ProvidedTypeSymbolKind get_Kind();
    internal Type[] get_Args();
    public bool get_IsFSharpTypeAbbreviation();
    public bool get_IsFSharpUnitAnnotated();
    public virtual ConstructorInfo GetConstructorImpl(BindingFlags _bindingFlags, Binder _binder, CallingConventions _callConventions, Type[] _types, ParameterModifier[] _modifiers);
    public virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingFlags, Binder _binderBinder, CallingConventions _callConvention, Type[] _types, ParameterModifier[] _modifiers);
    public virtual FieldInfo GetField(string _name, BindingFlags _bindingFlags);
    public virtual PropertyInfo GetPropertyImpl(string _name, BindingFlags _bindingFlags, Binder _binder, Type _returnType, Type[] _types, ParameterModifier[] _modifiers);
    public virtual EventInfo GetEvent(string _name, BindingFlags _bindingFlags);
    public virtual Type GetNestedType(string _name, BindingFlags _bindingFlags);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags _bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags _bindingFlags);
    public virtual FieldInfo[] GetFields(BindingFlags _bindingFlags);
    public virtual PropertyInfo[] GetProperties(BindingFlags _bindingFlags);
    public virtual EventInfo[] GetEvents(BindingFlags _bindingFlags);
    public virtual Type[] GetNestedTypes(BindingFlags _bindingFlags);
    public virtual MemberInfo[] GetMembers(BindingFlags _bindingFlags);
    public virtual Type GetInterface(string _name, bool _ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual MemberInfo[] GetMember(string _name, MemberTypes _mt, BindingFlags _bindingFlags);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string _name, BindingFlags _invokeAttr, Binder _binder, object _target, Object[] _args, ParameterModifier[] _modifiers, CultureInfo _culture, String[] _namedParameters);
    public virtual string get_AssemblyQualifiedName();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int arg);
    public virtual int get_MetadataToken();
    public virtual EventInfo[] GetEvents();
    public virtual string ToString();
}
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.ProvidedTypeSymbolKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProvidedTypeSymbolKind _unique_SDArray;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProvidedTypeSymbolKind _unique_Pointer;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProvidedTypeSymbolKind _unique_ByRef;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ProvidedTypeSymbolKind SDArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSDArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ProvidedTypeSymbolKind Pointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ProvidedTypeSymbolKind ByRef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsByRef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsGeneric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFSharpTypeAbbreviation { get; }
    private static ProvidedTypeSymbolKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ProvidedTypeSymbolKind(int _tag);
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind get_SDArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSDArray();
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind NewArray(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsArray();
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind get_Pointer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPointer();
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind get_ByRef();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsByRef();
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind NewGeneric(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsGeneric();
    [CompilationMappingAttribute]
internal static ProvidedTypeSymbolKind NewFSharpTypeAbbreviation(Tuple`3<Assembly, string, String[]> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFSharpTypeAbbreviation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProvidedTypeSymbolKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.QuotationSimplifier : object {
    public QuotationSimplifier(bool isGenerated);
    internal FSharpExpr TranslateExpression(FSharpExpr q);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal FSharpExpr TranslateQuotationToCode(FSharpFunc`2<FSharpList`1<FSharpExpr>, FSharpExpr> qexprf, String[] paramNames, FSharpExpr[] argExprs);
    [CompilerGeneratedAttribute]
internal FSharpExpr simplifyExpr(FSharpExpr q);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpExpr simplifyLetRec(FSharpList`1<Tuple`2<FSharpVar, FSharpExpr>> bindings, FSharpExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpExpr transLetOfByref(FSharpVar v, FSharpExpr vexpr, FSharpExpr bexpr);
    [CompilerGeneratedAttribute]
internal FSharpExpr transValueArray(Array o, Type ty);
    [CompilerGeneratedAttribute]
internal FSharpExpr transValueList(IEnumerable o, Type ty, UnionCaseInfo nil, UnionCaseInfo cons);
    [CompilerGeneratedAttribute]
internal FSharpFunc`2<object, FSharpExpr> getValueConverterForType(Type ty);
    [CompilerGeneratedAttribute]
internal FSharpExpr transValue(object v, Type tyOfValue, Type expectedTy);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TargetAssembly : Assembly {
    internal ITypeBuilder typeBuilder;
    internal FSharpFunc`2<ILAssemblyRef, FSharpChoice`2<Assembly, Exception>> tryBindAssembly;
    internal string location;
    internal ILGlobals ilGlobals;
    internal FSharpRef`1<TargetAssembly> asm;
    internal TxTable`1<Type> txTable;
    internal FSharpOption`1<ILModuleReader> reader@8098;
    internal TargetModule manifestModule;
    internal Lazy`1<Type[]> types;
    internal int init@8093-10;
    public string FullName { get; }
    public string Location { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    internal FSharpOption`1<ILModuleReader> Reader { get; internal set; }
    public TargetAssembly(ILGlobals ilGlobals, FSharpFunc`2<ILAssemblyRef, FSharpChoice`2<Assembly, Exception>> tryBindAssembly, FSharpOption`1<ILModuleReader> reader, string location, ITypeBuilder typeBuilder);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Type[] GetTypes();
    public virtual Type GetType(string nm);
    public virtual AssemblyName GetName();
    public virtual string get_FullName();
    public virtual string get_Location();
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual Stream GetManifestResourceStream(string resourceName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Type TxILTypeDef(FSharpOption`1<Type> declTyOpt, ILTypeDef inp);
    internal FSharpOption`1<ILModuleReader> get_Reader();
    internal void set_Reader(FSharpOption`1<ILModuleReader> v);
    internal FSharpOption`1<Type> TryBindType(StructOption`1<string> nsp, string nm);
    internal Type BindType(StructOption`1<string> nsp, string nm);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal ILModuleReader getReader();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Type txILTypeDef(FSharpOption`1<Type> declTyOpt, ILTypeDef inp);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TargetGenericParam : TypeDelegator {
    internal ITypeBuilder typeBuilder;
    internal FSharpFunc`2<Tuple`2<Type[], Type[]>, FSharpFunc`2<ILType, Type>> txILType;
    internal FSharpFunc`2<ILCustomAttrs, IList`1<CustomAttributeData>> txCustomAttributesData;
    internal int pos;
    internal ILGenericParameterDef inp;
    internal FSharpFunc`2<Unit, Tuple`2<Type[], Type[]>> gpsf;
    internal TargetAssembly asm;
    internal int init@7548-8;
    public string Name { get; }
    public Assembly Assembly { get; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public string Namespace { get; }
    public Type DeclaringType { get; }
    public Type BaseType { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Type UnderlyingSystemType { get; }
    public string AssemblyQualifiedName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public TargetGenericParam(TargetAssembly asm, FSharpFunc`2<Unit, Tuple`2<Type[], Type[]>> gpsf, int pos, ILGenericParameterDef inp, FSharpFunc`2<Tuple`2<Type[], Type[]>, FSharpFunc`2<ILType, Type>> txILType, FSharpFunc`2<ILCustomAttrs, IList`1<CustomAttributeData>> txCustomAttributesData, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual string get_Namespace();
    public virtual Type get_DeclaringType();
    public virtual Type get_BaseType();
    public virtual Type[] GetInterfaces();
    public virtual ConstructorInfo[] GetConstructors(BindingFlags _bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags _bindingFlags);
    public virtual FieldInfo[] GetFields(BindingFlags _bindingFlags);
    public virtual PropertyInfo[] GetProperties(BindingFlags _bindingFlags);
    public virtual EventInfo[] GetEvents(BindingFlags _bindingFlags);
    public virtual Type[] GetNestedTypes(BindingFlags _bindingFlags);
    public virtual ConstructorInfo GetConstructorImpl(BindingFlags _bindingFlags, Binder _binder, CallingConventions _callConvention, Type[] _types, ParameterModifier[] _modifiers);
    public virtual MethodInfo GetMethodImpl(string _name, BindingFlags _bindingFlags, Binder _binder, CallingConventions _callConvention, Type[] _types, ParameterModifier[] _modifiers);
    public virtual FieldInfo GetField(string _name, BindingFlags _bindingFlags);
    public virtual PropertyInfo GetPropertyImpl(string _name, BindingFlags _bindingFlags, Binder _binder, Type _returnType, Type[] _types, ParameterModifier[] _modifiers);
    public virtual Type GetNestedType(string _name, BindingFlags _bindingFlags);
    public virtual EventInfo GetEvent(string _name, BindingFlags _bindingFlags);
    public virtual MemberInfo[] GetMembers(BindingFlags _bindingFlags);
    public virtual Type MakeGenericType(Type[] _args);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int arg);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool IsArrayImpl();
    public virtual bool IsByRefImpl();
    public virtual bool IsPointerImpl();
    public virtual bool IsPrimitiveImpl();
    public virtual bool IsCOMObjectImpl();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual MemberInfo[] GetMember(string _name, MemberTypes _mt, BindingFlags _bindingFlags);
    public virtual Guid get_GUID();
    public virtual Object[] GetCustomAttributes(bool _inherited);
    public virtual Object[] GetCustomAttributes(Type _attributeType, bool _inherited);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual Type GetInterface(string _name, bool _ignoreCase);
    public virtual Module get_Module();
    public virtual Type GetElementType();
    public virtual object InvokeMember(string _name, BindingFlags _invokeAttr, Binder _binder, object _target, Object[] _args, ParameterModifier[] _modifiers, CultureInfo _culture, String[] _namedParameters);
    public virtual EventInfo[] GetEvents();
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TargetModule : Module {
    internal string location;
    public int MetadataToken { get; }
    public TargetModule(string location);
    public virtual int get_MetadataToken();
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TargetTypeDefinition : TypeDelegator {
    internal ITypeBuilder typeBuilder;
    internal FSharpFunc`2<ILAssemblyRef, FSharpChoice`2<Assembly, Exception>> tryBindAssembly;
    internal ILTypeDef inp;
    internal ILGlobals ilGlobals;
    internal FSharpOption`1<Type> declTyOpt;
    internal TargetAssembly asm;
    internal FSharpRef`1<TargetTypeDefinition> this;
    internal Type[] gps@7909-1;
    internal Lazy`1<Type[]> gps@7909;
    internal bool isNested;
    internal int init@7625-9;
    public string Name { get; }
    public Assembly Assembly { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsEnum { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Type UnderlyingSystemType { get; }
    public string AssemblyQualifiedName { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    internal ILTypeDef Metadata { get; }
    public TargetTypeDefinition(ILGlobals ilGlobals, FSharpFunc`2<ILAssemblyRef, FSharpChoice`2<Assembly, Exception>> tryBindAssembly, TargetAssembly asm, FSharpOption`1<Type> declTyOpt, ILTypeDef inp, ITypeBuilder typeBuilder);
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    public virtual Type[] GetInterfaces();
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual EventInfo[] GetEvents(BindingFlags bindingFlags);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingFlags);
    public virtual Type[] GetNestedTypes(BindingFlags bindingFlags);
    public virtual ConstructorInfo GetConstructorImpl(BindingFlags _bindingFlags, Binder _binder, CallingConventions _callConvention, Type[] types, ParameterModifier[] _modifiers);
    public virtual MethodInfo GetMethodImpl(string name, BindingFlags _bindingFlags, Binder _binder, CallingConventions _callConvention, Type[] types, ParameterModifier[] _modifiers);
    public virtual FieldInfo GetField(string name, BindingFlags _bindingFlags);
    public virtual PropertyInfo GetPropertyImpl(string name, BindingFlags _bindingFlags, Binder _binder, Type _returnType, Type[] _types, ParameterModifier[] _modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags _bindingFlags);
    public virtual Type GetNestedType(string name, BindingFlags _bindingFlags);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingFlags);
    public virtual Type MakeGenericType(Type[] args);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int arg);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool IsValueTypeImpl();
    public virtual bool get_IsEnum();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsArrayImpl();
    public virtual bool IsByRefImpl();
    public virtual bool IsPointerImpl();
    public virtual bool IsPrimitiveImpl();
    public virtual bool IsCOMObjectImpl();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool Equals(object that);
    public virtual bool Equals(Type that);
    public virtual int GetHashCode();
    public virtual bool IsAssignableFrom(Type otherTy);
    public virtual bool IsSubclassOf(Type otherTy);
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual Module get_Module();
    public virtual MemberInfo[] GetMember(string _name, MemberTypes _memberType, BindingFlags _bindingFlags);
    public virtual Guid get_GUID();
    public virtual Object[] GetCustomAttributes(bool _inherited);
    public virtual Object[] GetCustomAttributes(Type _attributeType, bool _inherited);
    public virtual bool IsDefined(Type _attributeType, bool _inherited);
    public virtual Type GetInterface(string _name, bool _ignoreCase);
    public virtual Type GetElementType();
    public virtual object InvokeMember(string _name, BindingFlags _invokeAttr, Binder _binder, object _target, Object[] _args, ParameterModifier[] _modifiers, CultureInfo _culture, String[] _namedParameters);
    internal ILTypeDef get_Metadata();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal MethodInfo MakeMethodInfo(Type declTy, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ConstructorInfo MakeConstructorInfo(Type declTy, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PropertyInfo MakePropertyInfo(Type declTy, ILPropertyDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EventInfo MakeEventInfo(Type declTy, ILEventDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal FieldInfo MakeFieldInfo(Type declTy, ILFieldDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Type MakeNestedTypeInfo(Type declTy, ILTypeDef md);
    public virtual EventInfo[] GetEvents();
    [CompilerGeneratedAttribute]
internal CustomAttributeTypedArgument txCustomAttributesArg(ILType ty, object v);
    [CompilerGeneratedAttribute]
internal CustomAttributeData txCustomAttributesDatum(ILCustomAttribute inp);
    [CompilerGeneratedAttribute]
internal IList`1<CustomAttributeData> txCustomAttributesData(ILCustomAttrs inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ParameterInfo txILParameter(Type[] gps_0, Type[] gps_1, ILParameter inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ConstructorInfo txILConstructorDef(Type declTy, ILMethodDef inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal MethodInfo txILMethodDef(Type declTy, ILMethodDef inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal PropertyInfo txILPropertyDef(Type declTy, ILPropertyDef inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal EventInfo txILEventDef(Type declTy, ILEventDef inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FieldInfo txILFieldDef(Type declTy, ILFieldDef inp);
    [CompilerGeneratedAttribute]
internal Assembly txScopeRef(ILScopeRef sref);
    [CompilerGeneratedAttribute]
internal Type txILTypeRef(ILTypeRef tref);
    [CompilerGeneratedAttribute]
internal ConstructorInfo txILConstructorRef(ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal MethodInfo txILMethodRef(Type declTy, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Type txILType(Type[] gps1, Type[] gps2, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Type txILGenericParam(FSharpFunc`2<Unit, Tuple`2<Type[], Type[]>> gpsf, int pos, ILGenericParameterDef inp);
    [CompilerGeneratedAttribute]
internal Type[] gps();
}
[RequireQualifiedAccessAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal abstract class ProviderImplementation.ProvidedTypes.TypeContainer : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TypeContainer _unique_TypeToBeDecided;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static TypeContainer TypeToBeDecided { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeToBeDecided { get; }
    private static TypeContainer();
    [CompilationMappingAttribute]
internal static TypeContainer NewNamespace(FSharpFunc`2<Unit, Assembly> item1, string item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNamespace();
    [CompilationMappingAttribute]
internal static TypeContainer NewType(ProvidedTypeDefinition item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsType();
    [CompilationMappingAttribute]
internal static TypeContainer get_TypeToBeDecided();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeToBeDecided();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.TypeProviderConfigFix : object {
    internal static String[] GetCurrentReferencedAssemblyPaths(TypeProviderConfig config);
}
[CompilationMappingAttribute]
public class ProviderImplementation.ProvidedTypes.TypeProviderForNamespaces : object {
    internal FSharpRef`1<TypeProviderForNamespaces> this;
    internal ProvidedTypesContext ctxt;
    internal List`1<IProvidedNamespace> namespacesT;
    internal FSharpEvent`2<EventHandler, EventArgs> invalidateE;
    internal FSharpEvent`2<EventHandler, EventArgs> disposing;
    internal List`1<string> probingFolders;
    internal ResolveEventHandler handler;
    internal int init@15866-13;
    public ProvidedTypesContext TargetContext { get; }
    public IProvidedNamespace[] Namespaces { get; }
    internal TypeProviderForNamespaces(TypeProviderConfig config, FSharpList`1<Tuple`2<string, FSharpList`1<ProvidedTypeDefinition>>> namespacesAndTypes, FSharpList`1<Tuple`2<string, string>> assemblyReplacementMap, FSharpList`1<Assembly> sourceAssemblies, bool addDefaultProbingLocation);
    public TypeProviderForNamespaces(TypeProviderConfig config, string namespaceName, FSharpList`1<ProvidedTypeDefinition> types, FSharpOption`1<FSharpList`1<Assembly>> sourceAssemblies, FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> assemblyReplacementMap, FSharpOption`1<bool> addDefaultProbingLocation);
    public TypeProviderForNamespaces(TypeProviderConfig config, FSharpOption`1<FSharpList`1<Assembly>> sourceAssemblies, FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> assemblyReplacementMap, FSharpOption`1<bool> addDefaultProbingLocation);
    public ProvidedTypesContext get_TargetContext();
    [CLIEventAttribute]
public void add_Disposing(EventHandler handler);
    [CLIEventAttribute]
public void remove_Disposing(EventHandler handler);
    public virtual Assembly ResolveAssembly(ResolveEventArgs args);
    public void RegisterProbingFolder(string folder);
    public void RegisterRuntimeAssemblyLocationAsProbingFolder(TypeProviderConfig config);
    public void AddNamespace(string namespaceName, FSharpList`1<ProvidedTypeDefinition> types);
    public IProvidedNamespace[] get_Namespaces();
    public void Invalidate();
    public ParameterInfo[] GetStaticParametersForMethod(MethodBase mb);
    public MethodBase ApplyStaticArgumentsForMethod(MethodBase mb, string mangledName, Object[] objs);
    private virtual override void System.IDisposable.Dispose();
    private virtual override void Microsoft.FSharp.Core.CompilerServices.ITypeProvider.add_Invalidate(EventHandler handler);
    private virtual override void Microsoft.FSharp.Core.CompilerServices.ITypeProvider.remove_Invalidate(EventHandler handler);
    private virtual override IProvidedNamespace[] Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetNamespaces();
    private virtual override FSharpExpr Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetInvokerExpression(MethodBase methodBaseT, FSharpExpr[] parametersT);
    private virtual override ParameterInfo[] Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetStaticParameters(Type ty);
    private virtual override Type Microsoft.FSharp.Core.CompilerServices.ITypeProvider.ApplyStaticArguments(Type ty, String[] typePathAfterArguments, Object[] objs);
    private virtual override Byte[] Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetGeneratedAssemblyContents(Assembly assembly);
    [CompilerGeneratedAttribute]
internal Type ensureCompiled(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal IProvidedNamespace makeProvidedNamespace(string namespaceName, FSharpList`1<ProvidedTypeDefinition> typesSrc);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TypeSymbol : TypeDelegator {
    internal ITypeBuilder typeBuilder;
    internal Type[] typeArgs;
    internal TypeSymbolKind kind;
    internal FSharpRef`1<TypeSymbol> this;
    internal int init@7290-7;
    public string FullName { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Assembly Assembly { get; }
    public string Namespace { get; }
    public bool IsGenericType { get; }
    public Module Module { get; }
    internal TypeSymbolKind Kind { get; }
    internal Type[] Args { get; }
    public string AssemblyQualifiedName { get; }
    public Type UnderlyingSystemType { get; }
    public MemberTypes MemberType { get; }
    public Guid GUID { get; }
    public TypeSymbol(TypeSymbolKind kind, Type[] typeArgs, ITypeBuilder typeBuilder);
    public virtual string get_FullName();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_BaseType();
    public virtual int get_MetadataToken();
    public virtual Assembly get_Assembly();
    public virtual string get_Namespace();
    public virtual int GetArrayRank();
    public virtual bool IsValueTypeImpl();
    public virtual bool IsArrayImpl();
    public virtual bool IsByRefImpl();
    public virtual bool IsPointerImpl();
    public virtual bool IsPrimitiveImpl();
    public virtual bool get_IsGenericType();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool IsCOMObjectImpl();
    public virtual bool HasElementTypeImpl();
    public virtual Type GetElementType();
    public virtual Module get_Module();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public virtual bool Equals(Type otherTy);
    public virtual bool IsAssignableFrom(Type otherTy);
    public virtual bool IsSubclassOf(Type otherTy);
    internal TypeSymbolKind get_Kind();
    internal Type[] get_Args();
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingFlags);
    public virtual EventInfo[] GetEvents(BindingFlags bindingFlags);
    public virtual Type[] GetNestedTypes(BindingFlags bindingFlags);
    public virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingFlags, Binder _binderBinder, CallingConventions _callConvention, Type[] types, ParameterModifier[] _modifiers);
    public virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingFlags, Binder _binderBinder, CallingConventions _callConvention, Type[] types, ParameterModifier[] _modifiers);
    public virtual FieldInfo GetField(string name, BindingFlags bindingFlags);
    public virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingFlags, Binder _binder, Type _returnType, Type[] _types, ParameterModifier[] _modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingFlags);
    public virtual Type GetNestedType(string _name, BindingFlags _bindingFlags);
    public virtual string get_AssemblyQualifiedName();
    public virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberInfo[] GetMembers(BindingFlags _bindingFlags);
    public virtual Type GetInterface(string _name, bool _ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual Object[] GetCustomAttributes(bool _inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool _inherit);
    public virtual bool IsDefined(Type _attributeType, bool _inherit);
    public virtual MemberTypes get_MemberType();
    public virtual MemberInfo[] GetMember(string _name, MemberTypes _mt, BindingFlags _bindingFlags);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string _name, BindingFlags _invokeAttr, Binder _binder, object _target, Object[] _args, ParameterModifier[] _modifiers, CultureInfo _culture, String[] _namedParameters);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int arg);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual EventInfo[] GetEvents();
    public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal class ProviderImplementation.ProvidedTypes.TypeSymbolKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TypeSymbolKind _unique_SDArray;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TypeSymbolKind _unique_Pointer;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TypeSymbolKind _unique_ByRef;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static TypeSymbolKind SDArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSDArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static TypeSymbolKind Pointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static TypeSymbolKind ByRef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsByRef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTargetGeneric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOtherGeneric { get; }
    private static TypeSymbolKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TypeSymbolKind(int _tag);
    [CompilationMappingAttribute]
internal static TypeSymbolKind get_SDArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSDArray();
    [CompilationMappingAttribute]
internal static TypeSymbolKind NewArray(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsArray();
    [CompilationMappingAttribute]
internal static TypeSymbolKind get_Pointer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPointer();
    [CompilationMappingAttribute]
internal static TypeSymbolKind get_ByRef();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsByRef();
    [CompilationMappingAttribute]
internal static TypeSymbolKind NewTargetGeneric(TargetTypeDefinition item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTargetGeneric();
    [CompilationMappingAttribute]
internal static TypeSymbolKind NewOtherGeneric(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOtherGeneric();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeSymbolKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.UncheckedQuotations : object {
    [CompilationMappingAttribute]
internal static Type qTy { get; }
    [CompilationMappingAttribute]
internal static Type pTy { get; }
    [CompilationMappingAttribute]
internal static MethodInfo mkFE0 { get; }
    [CompilationMappingAttribute]
internal static MethodInfo mkFE1 { get; }
    [CompilationMappingAttribute]
internal static MethodInfo mkFE2 { get; }
    [CompilationMappingAttribute]
internal static MethodInfo mkFE3 { get; }
    [CompilationMappingAttribute]
internal static MethodInfo mkFEN { get; }
    [CompilationMappingAttribute]
internal static MethodInfo newDelegateOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo instanceCallOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo staticCallOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo newObjectOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo newArrayOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo appOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo instancePropGetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo staticPropGetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo instancePropSetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo staticPropSetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo instanceFieldGetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo staticFieldGetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo instanceFieldSetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo staticFieldSetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo tupleGetOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo letOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo forIntegerRangeLoopOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo whileLoopOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo ifThenElseOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo newUnionCaseOp { get; }
    [CompilationMappingAttribute]
internal static MethodInfo newRecordOp { get; }
    internal static Type get_qTy();
    internal static Type get_pTy();
    internal static MethodInfo get_mkFE0();
    internal static MethodInfo get_mkFE1();
    internal static MethodInfo get_mkFE2();
    internal static MethodInfo get_mkFE3();
    internal static MethodInfo get_mkFEN();
    internal static MethodInfo get_newDelegateOp();
    internal static MethodInfo get_instanceCallOp();
    internal static MethodInfo get_staticCallOp();
    internal static MethodInfo get_newObjectOp();
    internal static MethodInfo get_newArrayOp();
    internal static MethodInfo get_appOp();
    internal static MethodInfo get_instancePropGetOp();
    internal static MethodInfo get_staticPropGetOp();
    internal static MethodInfo get_instancePropSetOp();
    internal static MethodInfo get_staticPropSetOp();
    internal static MethodInfo get_instanceFieldGetOp();
    internal static MethodInfo get_staticFieldGetOp();
    internal static MethodInfo get_instanceFieldSetOp();
    internal static MethodInfo get_staticFieldSetOp();
    internal static MethodInfo get_tupleGetOp();
    internal static MethodInfo get_letOp();
    internal static MethodInfo get_forIntegerRangeLoopOp();
    internal static MethodInfo get_whileLoopOp();
    internal static MethodInfo get_ifThenElseOp();
    internal static MethodInfo get_newUnionCaseOp();
    internal static MethodInfo get_newRecordOp();
    internal static FSharpExpr Expr.NewDelegateUnchecked.Static(Type ty, FSharpList`1<FSharpVar> vs, FSharpExpr body);
    internal static FSharpExpr Expr.NewObjectUnchecked.Static(ConstructorInfo cinfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr Expr.NewArrayUnchecked.Static(Type elementType, FSharpList`1<FSharpExpr> elements);
    internal static FSharpExpr Expr.CallUnchecked.Static(MethodInfo minfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr Expr.CallUnchecked.Static(FSharpExpr obj, MethodInfo minfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr Expr.ApplicationUnchecked.Static(FSharpExpr f, FSharpExpr x);
    internal static FSharpExpr Expr.PropertyGetUnchecked.Static(PropertyInfo pinfo, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr Expr.PropertyGetUnchecked.Static(FSharpExpr obj, PropertyInfo pinfo, FSharpOption`1<FSharpList`1<FSharpExpr>> args);
    internal static FSharpExpr Expr.PropertySetUnchecked.Static(PropertyInfo pinfo, FSharpExpr value, FSharpOption`1<FSharpList`1<FSharpExpr>> args);
    internal static FSharpExpr Expr.PropertySetUnchecked.Static(FSharpExpr obj, PropertyInfo pinfo, FSharpExpr value, FSharpOption`1<FSharpList`1<FSharpExpr>> args);
    internal static FSharpExpr Expr.FieldGetUnchecked.Static(FieldInfo pinfo);
    internal static FSharpExpr Expr.FieldGetUnchecked.Static(FSharpExpr obj, FieldInfo pinfo);
    internal static FSharpExpr Expr.FieldSetUnchecked.Static(FieldInfo pinfo, FSharpExpr value);
    internal static FSharpExpr Expr.FieldSetUnchecked.Static(FSharpExpr obj, FieldInfo pinfo, FSharpExpr value);
    internal static FSharpExpr Expr.TupleGetUnchecked.Static(FSharpExpr e, int n);
    internal static FSharpExpr Expr.LetUnchecked.Static(FSharpVar v, FSharpExpr e, FSharpExpr body);
    internal static FSharpExpr Expr.ForIntegerRangeLoopUnchecked.Static(FSharpVar loopVariable, FSharpExpr startExpr, FSharpExpr endExpr, FSharpExpr body);
    internal static FSharpExpr Expr.WhileLoopUnchecked.Static(FSharpExpr guard, FSharpExpr body);
    internal static FSharpExpr Expr.IfThenElseUnchecked.Static(FSharpExpr e, FSharpExpr t, FSharpExpr f);
    internal static FSharpExpr Expr.NewUnionCaseUnchecked.Static(UnionCaseInfo uci, FSharpList`1<FSharpExpr> args);
    internal static FSharpExpr Expr.NewRecordUnchecked.Static(Type ty, FSharpList`1<FSharpExpr> args);
    internal static FSharpChoice`3<Tuple`2<Shape, FSharpList`1<FSharpExpr>>, FSharpVar, Tuple`2<FSharpVar, FSharpExpr>> |ShapeCombinationUnchecked|ShapeVarUnchecked|ShapeLambdaUnchecked|(FSharpExpr e);
    internal static FSharpExpr RebuildShapeCombinationUnchecked(Shape _arg1, FSharpList`1<FSharpExpr> args);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.Utils : object {
    internal static BindingFlags bindAll { get; }
    internal static BindingFlags bindCommon { get; }
    [CompilationMappingAttribute]
internal static ITypeBuilder defaultTypeBuilder { get; }
    [CompilationMappingAttribute]
internal static int token { get; internal set; }
    [CompilationMappingAttribute]
internal static Object[] emptyAttributes { get; }
    internal static FSharpChoice`2<Unit, T> |UNone|USome|(StructOption`1<T> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, string> splitNameAt(string nm, int idx);
    internal static Tuple`2<StructOption`1<string>, string> splitILTypeName(string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string joinILTypeName(StructOption`1<string> nspace, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool lengthsEqAndForall2(T1[] arr1, T2[] arr2, FSharpFunc`2<T1, FSharpFunc`2<T2, bool>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqTypes(Type ty1, Type ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqTypeObj(Type this, object other);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAssignableFrom(Type ty, Type otherTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSubclassOf(Type this, Type otherTy);
    internal static TypeAttributes getAttributeFlagsImpl(Type ty);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_bindAll();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_bindCommon();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memberBinds(bool isType, BindingFlags bindingFlags, bool isStatic, bool isPublic);
    internal static ITypeBuilder get_defaultTypeBuilder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type instType(ITypeBuilder typeBuilder, Type[] inst1, Type[] inst2, Type ty);
    internal static int get_token();
    internal static void set_token(int value);
    internal static Object[] get_emptyAttributes();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a nonNone(string str, FSharpOption`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b patchOption(FSharpOption`1<a> v, FSharpFunc`2<Unit, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b notRequired(a this, string opname, string item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeAttributes adjustTypeAttributes(bool isNested, TypeAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo ConstructorInfo.GetDefinition(ConstructorInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyInfo PropertyInfo.GetDefinition(PropertyInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropertyInfo.get_IsStatic(PropertyInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropertyInfo.get_IsPublic(PropertyInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EventInfo EventInfo.GetDefinition(EventInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EventInfo.get_IsStatic(EventInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EventInfo.get_IsPublic(EventInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo FieldInfo.GetDefinition(FieldInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo MethodInfo.GetDefinition(MethodInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindConstructor(BindingFlags bindingFlags, ConstructorInfo c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindMethod(BindingFlags bindingFlags, MethodInfo c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindProperty(BindingFlags bindingFlags, PropertyInfo c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindField(BindingFlags bindingFlags, FieldInfo c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindEvent(BindingFlags bindingFlags, EventInfo c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBindNestedType(BindingFlags bindingFlags, Type c);
    internal static bool loop@301(int i);
    internal static bool ImportProvidedMethodBaseAsILMethodRef_OnStack_HACK();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProvidedTypes.Utils2 : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParameterInfo instParameterInfo(ITypeBuilder typeBuilder, Type[] inst_0, Type[] inst_1, ParameterInfo inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqILTypeRef(ILTypeRef ty1, ILTypeRef ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqILTypeRefScope(ILTypeRefScope ty1, ILTypeRefScope ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqILType(ILType ty1, ILType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqTypeAndILTypeRef(Type ty1, ILTypeRef ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqTypesAndILTypesWithInst(a[] inst2, Type[] tys1, ILType[] tys2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eqTypeAndILTypeWithInst(a[] inst2, Type ty1, ILType ty2);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.ProviderHelpers : object {
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99915@;
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99916@;
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99917@;
    [DebuggerBrowsableAttribute("0")]
internal static T99918_501Bytes@ field99919@;
    [DebuggerBrowsableAttribute("0")]
internal static T99920_382Bytes@ field99921@;
    [DebuggerBrowsableAttribute("0")]
internal static T99922_300Bytes@ field99923@;
    [DebuggerBrowsableAttribute("0")]
internal static T99924_508Bytes@ field99925@;
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99926@;
    [DebuggerBrowsableAttribute("0")]
internal static T99927_390Bytes@ field99928@;
    [DebuggerBrowsableAttribute("0")]
internal static T99924_508Bytes@ field99929@;
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99930@;
    [DebuggerBrowsableAttribute("0")]
internal static T99927_390Bytes@ field99931@;
    [DebuggerBrowsableAttribute("0")]
internal static T99924_508Bytes@ field99932@;
    [DebuggerBrowsableAttribute("0")]
internal static T99914_337Bytes@ field99933@;
    [CompilationMappingAttribute]
internal static IUnitsOfMeasureProvider unitsOfMeasureProvider { get; }
    [CompilationMappingAttribute]
internal static TimeSpan cacheDuration { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<char> invalidChars { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<char> arg@1 { get; }
    [CompilationMappingAttribute]
internal static ICache`2<string, string> webUrisCache { get; }
    [CompilationMappingAttribute]
internal static ICache`2<string, Tuple`3<ProvidedTypeDefinition, Tuple`4<string, string, string, Version>, FSharpOption`1<string>>> providedTypesCache { get; }
    [CompilationMappingAttribute]
internal static HashSet`1<Tuple`2<string, int>> activeDisposeActions { get; }
    private static ProviderHelpers();
    internal static IUnitsOfMeasureProvider get_unitsOfMeasureProvider();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr asyncMap(Type resultType, FSharpExpr`1<FSharpAsync`1<T>> valueAsync, FSharpFunc`2<FSharpExpr`1<T>, FSharpExpr> body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr some(Type typ, FSharpExpr arg);
    internal static TimeSpan get_cacheDuration();
    internal static FSharpSet`1<char> get_invalidChars();
    internal static FSharpList`1<char> get_arg@1();
    internal static ICache`2<string, string> get_webUrisCache();
    internal static FSharpOption`1<string> readResource(DisposableTypeProviderForNamespaces tp, string resourceName);
    internal static FSharpOption`1<string> tryGetResource@241(DisposableTypeProviderForNamespaces tp, string resource, Unit unitVar0);
    internal static FSharpOption`1<Uri> tryGetUri@244(string str);
    internal static string readText@282(string formatName, DisposableTypeProviderForNamespaces tp, TypeProviderConfig cfg, string encodingStr, string fullTypeName, FSharpOption`1<int> maxNumberOfRows, Uri uri, UriResolver resolver, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParseTextResult`1<a> parseTextAtDesignTime(string valueToBeParsedOrItsUri, FSharpFunc`2<string, FSharpFunc`2<string, TypeProviderSpec`1<a>>> parseFunc, string formatName, DisposableTypeProviderForNamespaces tp, TypeProviderConfig cfg, string encodingStr, string resolutionFolder, string resource, string fullTypeName, FSharpOption`1<int> maxNumberOfRows);
    internal static ICache`2<string, Tuple`3<ProvidedTypeDefinition, Tuple`4<string, string, string, Version>, FSharpOption`1<string>>> get_providedTypesCache();
    internal static HashSet`1<Tuple`2<string, int>> get_activeDisposeActions();
    internal static void setupDisposeAction@368(DisposableTypeProviderForNamespaces tp, string fullTypeName, Tuple`4<string, string, string, Version> fullKey, ProvidedTypeDefinition providedType, FSharpOption`1<string> fileToWatch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProvidedTypeDefinition getOrCreateProvidedType(TypeProviderConfig cfg, DisposableTypeProviderForNamespaces tp, string fullTypeName, FSharpFunc`2<Unit, ProvidedTypeDefinition> f);
    internal static FSharpFunc`2<b, FSharpExpr> getSamplesCode@617(string formatName, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, ParseTextResult`1<a> parseResult, TypeProviderSpec`1<a> spec);
    internal static FSharpFunc`2<b, FSharpExpr> methCode@646(string formatName, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, TypeProviderSpec`1<a> spec, Type resultTypeArray);
    internal static FSharpFunc`2<b, FSharpExpr> getSampleCode@675(string formatName, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, ParseTextResult`1<a> parseResult, TypeProviderSpec`1<a> spec);
    internal static FSharpFunc`2<b, FSharpExpr> asyncGetSampleCode@700(string formatName, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, TypeProviderSpec`1<a> spec, Type resultType);
    internal static FSharpFunc`2<b, FSharpExpr> getSchemaCode@725(string formatName, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, ParseTextResult`1<a> parseResult, TypeProviderSpec`1<a> spec);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<MemberInfo> generateType$cont@607(string formatName, Source source, string encodingStr, string resolutionFolder, string defaultResolutionFolder, string valueToBeParsedOrItsUri, ParseTextResult`1<a> parseResult, TypeProviderSpec`1<a> spec, Type resultType, Type resultTypeAsync, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProvidedTypeDefinition generateType(string formatName, Source source, FSharpFunc`2<string, FSharpFunc`2<string, TypeProviderSpec`1<a>>> getSpec, DisposableTypeProviderForNamespaces tp, TypeProviderConfig cfg, string encodingStr, string resolutionFolder, string resource, string fullTypeName, FSharpOption`1<int> maxNumberOfRows);
}
[CompilationMappingAttribute]
public static class ProviderImplementation.QuotationBuilder : object {
    internal static FSharpExpr convertValue@30(object arg);
    internal static FSharpFunc`2<Tuple`2<object, Type>, FSharpExpr> invokeOperation@36(Type typ, string operation, object tyargs, Type tyargsT);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpExpr op_Dynamic(Type typ, string operation, T args1, U args2);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.ReflectionHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr makeDelegate(FSharpFunc`2<FSharpExpr, FSharpExpr> exprfunc, Type argType);
}
[TypeProviderAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.WorldBankProvider : DisposableTypeProviderForNamespaces {
    internal TypeProviderConfig cfg;
    internal FSharpRef`1<WorldBankProvider> this;
    internal Assembly asm;
    internal string ns;
    internal string defaultServiceUrl;
    internal ICache`2<string, string> restCache;
    internal int init@20-19;
    public WorldBankProvider(TypeProviderConfig cfg);
    [CompilerGeneratedAttribute]
internal ProvidedTypeDefinition createTypesForSources(FSharpList`1<string> sources, string worldBankTypeName, bool asynchronous, bool addAttributes);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.XmlGenerationContext : object {
    [DebuggerBrowsableAttribute("0")]
internal string CultureStr@;
    [DebuggerBrowsableAttribute("0")]
internal IUnitsOfMeasureProvider UnitsOfMeasureProvider@;
    [DebuggerBrowsableAttribute("0")]
internal InferenceMode' InferenceMode@;
    [DebuggerBrowsableAttribute("0")]
internal ProvidedTypeDefinition ProvidedType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, string> UniqueNiceName@;
    [DebuggerBrowsableAttribute("0")]
internal bool UnifyGlobally@;
    [DebuggerBrowsableAttribute("0")]
internal Dictionary`2<InferedType, XmlGenerationResult> XmlTypeCache@;
    [DebuggerBrowsableAttribute("0")]
internal Dictionary`2<InferedType, ProvidedTypeDefinition> JsonTypeCache@;
    [CompilationMappingAttribute]
internal string CultureStr { get; }
    [CompilationMappingAttribute]
internal IUnitsOfMeasureProvider UnitsOfMeasureProvider { get; }
    [CompilationMappingAttribute]
internal InferenceMode' InferenceMode { get; }
    [CompilationMappingAttribute]
internal ProvidedTypeDefinition ProvidedType { get; }
    [CompilationMappingAttribute]
internal FSharpFunc`2<string, string> UniqueNiceName { get; }
    [CompilationMappingAttribute]
internal bool UnifyGlobally { get; }
    [CompilationMappingAttribute]
internal Dictionary`2<InferedType, XmlGenerationResult> XmlTypeCache { get; }
    [CompilationMappingAttribute]
internal Dictionary`2<InferedType, ProvidedTypeDefinition> JsonTypeCache { get; }
    internal XmlGenerationContext(string cultureStr, IUnitsOfMeasureProvider unitsOfMeasureProvider, InferenceMode' inferenceMode, ProvidedTypeDefinition providedType, FSharpFunc`2<string, string> uniqueNiceName, bool unifyGlobally, Dictionary`2<InferedType, XmlGenerationResult> xmlTypeCache, Dictionary`2<InferedType, ProvidedTypeDefinition> jsonTypeCache);
    internal string get_CultureStr();
    internal IUnitsOfMeasureProvider get_UnitsOfMeasureProvider();
    internal InferenceMode' get_InferenceMode();
    internal ProvidedTypeDefinition get_ProvidedType();
    internal FSharpFunc`2<string, string> get_UniqueNiceName();
    internal bool get_UnifyGlobally();
    internal Dictionary`2<InferedType, XmlGenerationResult> get_XmlTypeCache();
    internal Dictionary`2<InferedType, ProvidedTypeDefinition> get_JsonTypeCache();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static XmlGenerationContext Create(IUnitsOfMeasureProvider unitsOfMeasureProvider, InferenceMode' inferenceMode, string cultureStr, ProvidedTypeDefinition tpType, bool unifyGlobally);
    internal Tuple`2<Type, FSharpFunc`2<b, FSharpExpr>> ConvertValue(PrimitiveInferedProperty prop);
    internal Tuple`2<Type, FSharpFunc`2<a, FSharpExpr>> ConvertValueBack(PrimitiveInferedProperty prop);
    internal Type MakeOptionType(Type typ);
}
[CompilationMappingAttribute]
internal class ProviderImplementation.XmlGenerationResult : object {
    [DebuggerBrowsableAttribute("0")]
internal Type ConvertedType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<FSharpExpr, FSharpExpr> Converter@;
    [CompilationMappingAttribute]
internal Type ConvertedType { get; }
    [CompilationMappingAttribute]
internal FSharpFunc`2<FSharpExpr, FSharpExpr> Converter { get; }
    internal XmlGenerationResult(Type convertedType, FSharpFunc`2<FSharpExpr, FSharpExpr> converter);
    internal Type get_ConvertedType();
    internal FSharpFunc`2<FSharpExpr, FSharpExpr> get_Converter();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[TypeProviderAttribute]
[CompilationMappingAttribute]
public class ProviderImplementation.XmlProvider : DisposableTypeProviderForNamespaces {
    internal TypeProviderConfig cfg;
    internal FSharpRef`1<XmlProvider> this;
    internal Assembly asm;
    internal string ns;
    internal int init@22-17;
    public XmlProvider(TypeProviderConfig cfg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ProvidedTypeDefinition buildTypes(string typeName, Object[] args);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.XmlTypeBuilder : object {
    [DebuggerBrowsableAttribute("0")]
internal static T100078_332Bytes@ field100079@;
    [DebuggerBrowsableAttribute("0")]
internal static T100080_339Bytes@ field100081@;
    [DebuggerBrowsableAttribute("0")]
internal static T100082_327Bytes@ field100083@;
    [DebuggerBrowsableAttribute("0")]
internal static T100091_354Bytes@ field100092@;
    [DebuggerBrowsableAttribute("0")]
internal static T100093_318Bytes@ field100094@;
    [DebuggerBrowsableAttribute("0")]
internal static T100099_350Bytes@ field100100@;
    [DebuggerBrowsableAttribute("0")]
internal static T100101_298Bytes@ field100102@;
    [DebuggerBrowsableAttribute("0")]
internal static T100111_334Bytes@ field100112@;
    [DebuggerBrowsableAttribute("0")]
internal static T100113_440Bytes@ field100114@;
    [DebuggerBrowsableAttribute("0")]
internal static T100093_318Bytes@ field100115@;
    internal static FSharpList`1<Tuple`2<a, b>> inOrder@75(FSharpList`1<a> order, FSharpMap`2<a, b> types);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<InferedType>, FSharpList`1<Tuple`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>>>>> |ContentType|_|(InferedProperty inferedProp);
    internal static FSharpOption`1<FSharpList`1<Tuple`2<string, InferedType>>> |HeterogeneousRecords|_|(InferedType inferedType);
    internal static FSharpExpr conv@140-3(FSharpFunc`2<FSharpExpr`1<FSharpOption`1<string>>, FSharpExpr> conv, FSharpExpr xml);
    internal static FSharpExpr conv@170-4(JsonGenerationResult result, bool optional, FSharpExpr xml);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`4<Type, string, FSharpFunc`2<a, FSharpExpr>, bool>> getTypesForPrimitives(XmlGenerationContext ctx, bool forceOptional, FSharpList`1<InferedType> primitives);
    internal static Tuple`3<string, ProvidedProperty, ProvidedParameter> createMember@320(FSharpFunc`2<string, string> makeUnique, string nameWithNS, string name, Type typ, FSharpFunc`2<FSharpExpr`1<FSharpOption`1<string>>, FSharpExpr> conv);
    internal static Tuple`3<string, ProvidedProperty, ProvidedParameter> createPrimitiveMember@330(XmlGenerationContext ctx, FSharpFunc`2<string, string> makeUnique, string nameWithNS, string name, Type typ, FSharpOption`1<Type> unit, bool optional);
    internal static bool isCollectionName@432(string parentName, string childName);
    internal static void createConstrutor@571(XmlGenerationContext ctx, string nameWithNS, ProvidedTypeDefinition objectTy, FSharpList`1<ProvidedParameter> attrParameters, FSharpList`1<string> attrNames, FSharpList`1<ProvidedParameter> childElemParameters, FSharpList`1<string> childElemNames, FSharpOption`1<a> primitiveParam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlGenerationResult generateXmlType(XmlGenerationContext ctx, InferedType inferedType);
}
[CompilationMappingAttribute]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyProduct;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyDescription;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
}
