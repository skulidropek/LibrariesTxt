[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.CssSelectorExtensions : object {
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlActivePatterns : object {
    public static FSharpChoice`4<Tuple`3<string, FSharpList`1<HtmlAttribute>, FSharpList`1<HtmlNode>>, string, string, string> |HtmlElement|HtmlText|HtmlComment|HtmlCData|(HtmlNode node);
    public static Tuple`2<string, string> |HtmlAttribute|(HtmlAttribute attribute);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.HtmlAttribute : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _name;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _value;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string name { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string value { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal HtmlAttribute(string _name, string _value);
    [CompilationMappingAttribute]
internal static HtmlAttribute NewHtmlAttribute(string _name, string _value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_value();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlAttribute obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static HtmlAttribute New(string name, string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlAttribute obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public class FSharp.Data.HtmlAttributeExtensions : object {
    [ExtensionAttribute]
public static string Name(HtmlAttribute attr);
    [ExtensionAttribute]
public static string Value(HtmlAttribute attr);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlAttributeModule : object {
    public static string name(HtmlAttribute attr);
    public static string value(HtmlAttribute attr);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlAutoOpens : object {
    public static HtmlDocument HtmlDocument.Parse.Static(string text);
    public static HtmlDocument HtmlDocument.Load.Static(Stream stream);
    public static HtmlDocument HtmlDocument.Load.Static(TextReader reader);
    public static FSharpAsync`1<HtmlDocument> HtmlDocument.AsyncLoad.Static(string uri, FSharpOption`1<Encoding> encoding);
    public static HtmlDocument HtmlDocument.Load.Static(string uri, FSharpOption`1<Encoding> encoding);
    public static FSharpList`1<HtmlNode> HtmlNode.Parse.Static(string text);
    public static HtmlNode HtmlNode.ParseRooted.Static(string rootName, string text);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.HtmlCharRefs : object {
    [CompilationMappingAttribute]
internal static FSharpMap`2<string, string> refs { get; }
    internal static FSharpMap`2<string, string> get_refs();
    [CompilerGeneratedAttribute]
internal static FSharpChoice`2<UInt32, string> |Number|Lookup|$cont@2246(string orig, string s, Unit unitVar);
    internal static FSharpChoice`2<UInt32, string> |Number|Lookup|(string orig);
    internal static string substitute(string ref);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.HtmlCssSelectors : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@9(SelectorToken this, SelectorToken obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@9-1(SelectorToken this, SelectorToken objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@9(SelectorToken this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@9(SelectorToken this, SelectorToken that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@9-1(SelectorToken this, SelectorToken obj, Unit unitVar);
    internal static FSharpOption`1<FSharpList`1<a>> equal@109(FSharpList`1<a> x, FSharpList`1<a> s);
    internal static FSharpList`1<SelectorToken> tokenize'@118(CssSelectorTokenizer this, FSharpList`1<SelectorToken> acc, FSharpList`1<char> sourceChars);
}
[StructuredFormatDisplayAttribute("{_Print}")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.HtmlDocument : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _docType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<HtmlNode> _elements;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string docType { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<HtmlNode> elements { get; }
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public string _Print { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal HtmlDocument(string _docType, FSharpList`1<HtmlNode> _elements);
    [CompilationMappingAttribute]
internal static HtmlDocument NewHtmlDocument(string _docType, FSharpList`1<HtmlNode> _elements);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_docType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<HtmlNode> get_elements();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlDocument obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static HtmlDocument New(string docType, IEnumerable`1<HtmlNode> children);
    public static HtmlDocument New(IEnumerable`1<HtmlNode> children);
    public virtual string ToString();
    public string get__Print();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlDocument obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public class FSharp.Data.HtmlDocumentExtensions : object {
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlDocument doc);
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlDocument doc, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlDocument doc, string name);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlDocument doc, string name);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlDocument doc, string name);
    [ExtensionAttribute]
public static HtmlNode Body(HtmlDocument doc);
    [ExtensionAttribute]
public static FSharpOption`1<HtmlNode> TryGetBody(HtmlDocument doc);
    [ExtensionAttribute]
public static HtmlNode Html(HtmlDocument doc);
    [ExtensionAttribute]
public static FSharpOption`1<HtmlNode> TryGetHtml(HtmlDocument doc);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlDocumentModule : object {
    public static string docType(HtmlDocument doc);
    public static FSharpList`1<HtmlNode> elements(HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<HtmlNode> elementsNamed(IEnumerable`1<string> names, HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendants(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendantsNamed(bool recurseOnMatch, IEnumerable`1<string> names, HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsWithPath(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsNamedWithPath(bool recurseOnMatch, IEnumerable`1<string> names, HtmlDocument doc);
    public static HtmlNode body(HtmlDocument x);
    public static FSharpOption`1<HtmlNode> tryGetBody(HtmlDocument x);
    public static HtmlNode html(HtmlDocument x);
    public static FSharpOption`1<HtmlNode> tryGetHtml(HtmlDocument x);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlExtensionsModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_Dynamic(HtmlNode node, string name);
}
[StructuredFormatDisplayAttribute("{_Print}")]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FSharp.Data.HtmlNode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsHtmlElement { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsHtmlText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsHtmlComment { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsHtmlCData { get; }
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public string _Print { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal HtmlNode(int _tag);
    [CompilationMappingAttribute]
internal static HtmlNode NewHtmlElement(string _name, FSharpList`1<HtmlAttribute> _attributes, FSharpList`1<HtmlNode> _elements);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsHtmlElement();
    [CompilationMappingAttribute]
internal static HtmlNode NewHtmlText(string _content);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsHtmlText();
    [CompilationMappingAttribute]
internal static HtmlNode NewHtmlComment(string _content);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsHtmlComment();
    [CompilationMappingAttribute]
internal static HtmlNode NewHtmlCData(string _content);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsHtmlCData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlNode obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static HtmlNode NewElement(string name);
    public static HtmlNode NewElement(string name, IEnumerable`1<Tuple`2<string, string>> attrs);
    public static HtmlNode NewElement(string name, IEnumerable`1<HtmlNode> children);
    public static HtmlNode NewElement(string name, IEnumerable`1<Tuple`2<string, string>> attrs, IEnumerable`1<HtmlNode> children);
    public static HtmlNode NewText(string content);
    public static HtmlNode NewComment(string content);
    public static HtmlNode NewCData(string content);
    public virtual string ToString();
    public string get__Print();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlNode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public class FSharp.Data.HtmlNodeExtensions : object {
    [ExtensionAttribute]
public static string Name(HtmlNode n);
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlNode n);
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlNode n, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static FSharpList`1<HtmlNode> Elements(HtmlNode n, string name);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> Descendants(HtmlNode n, string name);
    [ExtensionAttribute]
public static IEnumerable`1<HtmlNode> DescendantsAndSelf(HtmlNode n, string name);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, FSharpFunc`2<HtmlNode, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, IEnumerable`1<string> names, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, IEnumerable`1<string> names);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, string name, bool recurseOnMatch);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsWithPath(HtmlNode n, string name);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> DescendantsAndSelfWithPath(HtmlNode n, string name);
    [ExtensionAttribute]
public static FSharpList`1<HtmlAttribute> Attributes(HtmlNode n);
    [ExtensionAttribute]
public static FSharpOption`1<HtmlAttribute> TryGetAttribute(HtmlNode n, string name);
    [ExtensionAttribute]
public static HtmlAttribute Attribute(HtmlNode n, string name);
    [ExtensionAttribute]
public static string AttributeValue(HtmlNode n, string name);
    [ExtensionAttribute]
public static bool HasAttribute(HtmlNode n, string name, string value);
    [ExtensionAttribute]
public static bool HasName(HtmlNode n, string name);
    [ExtensionAttribute]
public static bool HasId(HtmlNode n, string id);
    [ExtensionAttribute]
public static bool HasClass(HtmlNode n, string cssClass);
    [ExtensionAttribute]
public static string InnerText(HtmlNode n);
    [ExtensionAttribute]
public static string DirectInnerText(HtmlNode n);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class FSharp.Data.HtmlNodeModule : object {
    public static string name(HtmlNode n);
    public static FSharpList`1<HtmlNode> elements(HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<HtmlNode> elementsNamed(IEnumerable`1<string> names, HtmlNode n);
    internal static IEnumerable`1<HtmlNode> descendantsBy@74(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, bool includeSelf, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<HtmlNode> descendantsBy(bool includeSelf, bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendants(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendantsAndSelf(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendantsNamed(bool recurseOnMatch, IEnumerable`1<string> names, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<HtmlNode> descendantsAndSelfNamed(bool recurseOnMatch, IEnumerable`1<string> names, HtmlNode n);
    internal static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsByWithPath@134(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, bool includeSelf, FSharpList`1<HtmlNode> path, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsByWithPath(bool includeSelf, bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsWithPath(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsAndSelfWithPath(bool recurseOnMatch, FSharpFunc`2<HtmlNode, bool> predicate, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsNamedWithPath(bool recurseOnMatch, IEnumerable`1<string> names, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<HtmlNode, FSharpList`1<HtmlNode>>> descendantsAndSelfNamedWithPath(bool recurseOnMatch, IEnumerable`1<string> names, HtmlNode n);
    public static FSharpList`1<HtmlAttribute> attributes(HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<HtmlAttribute> tryGetAttribute(string name, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HtmlAttribute attribute(string name, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string attributeValue(string name, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasAttribute(string name, string value, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasName(string expectedName, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasId(string id, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasClass(string cssClass, HtmlNode n);
    internal static string innerText'@260(bool recurse, FSharpList`1<string> exclusions, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string innerTextExcluding'(bool recurse, FSharpList`1<string> exclusions, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string innerTextExcluding(FSharpList`1<string> exclusions, HtmlNode n);
    public static string innerText(HtmlNode n);
    public static string directInnerText(HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<HtmlNode> getTargets(FilterLevel level, FSharpList`1<HtmlNode> matched);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlNode> searchTag(FilterLevel level, FSharpList`1<HtmlNode> matched, string tag);
    [CompilerGeneratedAttribute]
internal static string func1@1(string attr, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlNode> filterByAttr(FilterLevel level, FSharpList`1<HtmlNode> matched, string attr, FSharpFunc`2<string, bool> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlNode> attrExists(FilterLevel level, FSharpList`1<HtmlNode> matched, string attr);
    internal static FSharpList`1<HtmlNode> selectDescendantOfType@333(Char[] whiteSpaces, FilterLevel level, FSharpList`1<HtmlNode> acc, string ty, FSharpList`1<SelectorToken> t);
    internal static FSharpList`1<HtmlNode> selectEvenOdd@337(FSharpList`1<HtmlNode> acc, bool isEven);
    internal static FSharpFunc`2<string, bool> containsIgnoreCase@346(string value);
    internal static FSharpFunc`2<string, bool> equalsIgnoreCase@350(string value);
    internal static FSharpList`1<HtmlNode> selectElements'@326(Char[] whiteSpaces, FilterLevel level, FSharpList`1<HtmlNode> acc, FSharpList`1<SelectorToken> source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlNode> selectCssElements(FSharpList`1<SelectorToken> tokens, FSharpList`1<HtmlNode> nodes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlNode> Select(IEnumerable`1<HtmlNode> nodes, string selector);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<HtmlNode> cssSelect(HtmlNode node, string selector);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.HtmlParser : object {
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> wsRegex { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> invalidTypeNameRegex { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> headingRegex { get; }
    internal static Lazy`1<Regex> get_wsRegex();
    internal static Lazy`1<Regex> get_invalidTypeNameRegex();
    internal static Lazy`1<Regex> get_headingRegex();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@35-4(HtmlToken this, HtmlToken obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@35-5(IComparer comp, HtmlToken this, HtmlToken objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@35-2(IEqualityComparer comp, HtmlToken this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@35-3(HtmlToken this, HtmlToken that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@35-4(HtmlToken this, HtmlToken obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char TextReader.PeekChar(TextReader );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char TextReader.ReadChar(TextReader );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string TextReader.ReadNChar(TextReader x, int n);
    internal static void data@261(HtmlState state);
    internal static void script@287(HtmlState state);
    internal static void scriptSingleQuoteString@306(HtmlState state);
    internal static void scriptDoubleQuoteString@319(HtmlState state);
    internal static void scriptSingleQuoteStringBackslash@332(HtmlState state);
    internal static void scriptDoubleQuoteStringBackslash@338(HtmlState state);
    internal static void scriptSlash@344(HtmlState state);
    internal static void scriptMultiLineComment@354(HtmlState state);
    internal static void scriptMultiLineCommentStar@364(HtmlState state);
    internal static void scriptSingleLineComment@372(HtmlState state);
    internal static void scriptLessThanSign@382(HtmlState state);
    internal static void scriptDataEscapeStart@396(HtmlState state);
    internal static void scriptDataEscapeStartDash@403(HtmlState state);
    internal static void scriptDataEscapedDashDash@410(HtmlState state);
    internal static void scriptDataEscapedLessThanSign@426(HtmlState state);
    internal static void scriptDataDoubleEscapeStart@440(HtmlState state);
    internal static void scriptDataDoubleEscaped@454(HtmlState state);
    internal static void scriptDataDoubleEscapedDash@467(HtmlState state);
    internal static void scriptDataDoubleEscapedLessThanSign@480(HtmlState state);
    internal static void scriptDataDoubleEscapeEnd@489(HtmlState state);
    internal static void scriptDataDoubleEscapedDashDash@503(HtmlState state);
    internal static void scriptDataEscapedEndTagOpen@519(HtmlState state);
    internal static void scriptDataEscapedEndTagName@527(HtmlState state);
    internal static void scriptDataEscaped@551(HtmlState state);
    internal static void scriptDataEscapedDash@562(HtmlState state);
    internal static void scriptEndTagOpen@573(HtmlState state);
    internal static void scriptEndTagName@581(HtmlState state);
    internal static void charRef@601(HtmlState state);
    internal static void tagOpen@614(HtmlState state);
    internal static void bogusComment'@633(HtmlState state);
    internal static void bogusComment@632(HtmlState state);
    internal static void markupDeclaration@649(HtmlState state);
    internal static void cData@660(int i, HtmlState state);
    internal static void docType@676(HtmlState state);
    internal static void comment@686(HtmlState state);
    internal static void commentEndDash@698(HtmlState state);
    internal static void commentEndState@710(HtmlState state);
    internal static void tagName@723(bool isEndTag, HtmlState state);
    internal static void selfClosingStartTag@739(HtmlState state);
    internal static void endTagOpen@747(HtmlState state);
    internal static void beforeAttributeName@758(HtmlState state);
    internal static void attributeName@771(HtmlState state);
    internal static void afterAttributeName@791(HtmlState state);
    internal static void beforeAttributeValue@809(HtmlState state);
    internal static void attributeValueUnquoted@829(HtmlState state);
    internal static void attributeValueUnquotedSlash@849(HtmlState state);
    internal static void attributeValueQuoted@857(char quote, HtmlState state);
    internal static void attributeValueQuotedCharRef@871(char quote, HtmlState state);
    internal static void attributeValueUnquotedCharRef@887(FSharpList`1<char> stop, HtmlState state);
    internal static void afterAttributeValueQuoted@903(HtmlState state);
    internal static FSharpList`1<HtmlToken> tokenise(TextReader reader);
    internal static bool canNotHaveChildren@928(string name);
    internal static bool isImplicitlyClosedByStartTag@948(string expectedTagEnd, string startTag);
    internal static FSharpList`1<HtmlToken> implicitlyCloseByStartTag@959(string expectedTagEnd, string startTag, FSharpList`1<HtmlToken> tokens);
    internal static bool isImplicitlyClosedByEndTag@976(string expectedTagEnd, string startTag);
    internal static FSharpList`1<HtmlToken> implicitlyCloseByEndTag@988(string expectedTagEnd, FSharpList`1<HtmlToken> tokens);
    internal static Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>> recursiveReturn@1011(Stack`1<Tuple`6<string, FSharpList`1<HtmlNode>, string, string, string, FSharpList`1<HtmlAttribute>>> callstack, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlNode>, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlToken>, Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>>>>>>> parse', string dt, FSharpList`1<HtmlToken> tokens, FSharpList`1<HtmlNode> content);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>> parse'$cont@1019-1(Stack`1<Tuple`6<string, FSharpList`1<HtmlNode>, string, string, string, FSharpList`1<HtmlAttribute>>> callstack, string docType, FSharpList`1<HtmlNode> elements, string expectedTagEnd, string parentTagName, FSharpList`1<HtmlToken> tokens, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlNode>, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlToken>, Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>>>>>>> parse', Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>> parse'$cont@1019(Stack`1<Tuple`6<string, FSharpList`1<HtmlNode>, string, string, string, FSharpList`1<HtmlAttribute>>> callstack, string docType, FSharpList`1<HtmlNode> elements, string expectedTagEnd, string parentTagName, FSharpList`1<HtmlToken> tokens, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlNode>, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<HtmlToken>, Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>>>>>>> parse', Unit unitVar);
    internal static FSharpFunc`2<FSharpList`1<HtmlToken>, Tuple`3<string, FSharpList`1<HtmlToken>, FSharpList`1<HtmlNode>>> parse'@1001(Stack`1<Tuple`6<string, FSharpList`1<HtmlNode>, string, string, string, FSharpList`1<HtmlAttribute>>> callstack, string docType, FSharpList`1<HtmlNode> elements, string expectedTagEnd, string parentTagName);
    internal static Tuple`2<string, FSharpList`1<HtmlNode>> parse(TextReader reader);
    internal static HtmlDocument parseDocument(TextReader reader);
    internal static FSharpList`1<HtmlNode> parseFragment(TextReader reader);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.BaseTypes.HtmlDocument : object {
    internal FSharpMap`2<string, HtmlTable> tables;
    internal FSharpMap`2<string, HtmlList> lists;
    internal HtmlDocument doc;
    internal FSharpMap`2<string, HtmlDefinitionList> definitionLists;
    public HtmlDocument Html { get; }
    internal HtmlDocument(HtmlDocument doc, FSharpMap`2<string, HtmlTable> tables, FSharpMap`2<string, HtmlList> lists, FSharpMap`2<string, HtmlDefinitionList> definitionLists);
    public HtmlDocument get_Html();
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public static HtmlDocument Create(bool includeLayoutTables, TextReader reader);
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public HtmlTable GetTable(string id);
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public HtmlList GetList(string id);
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public HtmlDefinitionList GetDefinitionList(string id);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.BaseTypes.HtmlList`1 : object {
    internal ItemType[] values;
    internal string name;
    internal HtmlNode html;
    public string Name { get; }
    public ItemType[] Values { get; }
    public HtmlNode Html { get; }
    internal HtmlList`1(string name, ItemType[] values, HtmlNode html);
    public string get_Name();
    public ItemType[] get_Values();
    public HtmlNode get_Html();
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public static HtmlList`1<ItemType> Create(Func`2<string, ItemType> rowConverter, HtmlDocument doc, string id);
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public static HtmlList`1<ItemType> CreateNested(Func`2<string, ItemType> rowConverter, HtmlDocument doc, string id, int index);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.BaseTypes.HtmlTable`1 : object {
    internal RowType[] values;
    internal string name;
    internal HtmlNode html;
    internal FSharpOption`1<String[]> headers;
    public string Name { get; }
    public FSharpOption`1<String[]> Headers { get; }
    public RowType[] Rows { get; }
    public HtmlNode Html { get; }
    internal HtmlTable`1(string name, FSharpOption`1<String[]> headers, RowType[] values, HtmlNode html);
    public string get_Name();
    public FSharpOption`1<String[]> get_Headers();
    public RowType[] get_Rows();
    public HtmlNode get_Html();
    [EditorBrowsableAttribute("1")]
[CompilerMessageAttribute("This method is intended for use in generated code only.", "10001")]
public static HtmlTable`1<RowType> Create(Func`2<String[], RowType> rowConverter, HtmlDocument doc, string id, bool hasHeaders);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.HtmlDefinitionList : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<HtmlList> Definitions@;
    [DebuggerBrowsableAttribute("0")]
internal HtmlNode Html@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public FSharpList`1<HtmlList> Definitions { get; }
    [CompilationMappingAttribute]
public HtmlNode Html { get; }
    public HtmlDefinitionList(string name, FSharpList`1<HtmlList> definitions, HtmlNode html);
    public string get_Name();
    public FSharpList`1<HtmlList> get_Definitions();
    public HtmlNode get_Html();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlDefinitionList obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlDefinitionList obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class FSharp.Data.Runtime.HtmlInference : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PrimitiveInferedProperty> inferColumns(Parameters parameters, Tuple`2[] headerNamesAndUnits, IEnumerable`1<String[]> rows);
    [CompilerGeneratedAttribute]
internal static Tuple`4<bool, FSharpOption`1<String[]>, FSharpOption`1<FSharpOption`1[]>, FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>>> inferHeaders$cont@39(Parameters parameters, String[][] rows, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<bool, FSharpOption`1<String[]>, FSharpOption`1<FSharpOption`1[]>, FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>>> inferHeaders(Parameters parameters, String[][] rows);
    internal static InferedType inferedtype@57(Parameters parameters, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InferedType inferListType(Parameters parameters, String[] values);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.HtmlList : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal String[] Values@;
    [DebuggerBrowsableAttribute("0")]
internal HtmlNode Html@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public String[] Values { get; }
    [CompilationMappingAttribute]
public HtmlNode Html { get; }
    public HtmlList(string name, String[] values, HtmlNode html);
    public string get_Name();
    public String[] get_Values();
    public HtmlNode get_Html();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlList obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlList obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FSharp.Data.Runtime.HtmlObjectDescription : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDefinitionList { get; }
    public string Name { get; }
    [CompilationMappingAttribute]
public static HtmlObjectDescription NewTable(HtmlTable item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTable();
    [CompilationMappingAttribute]
public static HtmlObjectDescription NewList(HtmlList item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsList();
    [CompilationMappingAttribute]
public static HtmlObjectDescription NewDefinitionList(HtmlDefinitionList item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDefinitionList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlObjectDescription obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class FSharp.Data.Runtime.HtmlRuntime : object {
    internal static string normalizeWs(string str);
    internal static FSharpOption`1<string> tryGetName@137(HtmlNode element, FSharpList`1<string> choices);
    internal static FSharpOption`1<HtmlNode> tryFindPrevious@144(FSharpFunc`2<HtmlNode, bool> f, HtmlNode x, FSharpList`1<HtmlNode> parents);
    internal static FSharpOption`1<HtmlNode> deriveFromSibling@160(HtmlNode element, FSharpList`1<HtmlNode> parents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getName(string defaultName, HtmlNode element, FSharpList`1<HtmlNode> parents);
    internal static bool isAriaHidden@200(HtmlNode n);
    internal static string innerText'@208-3(bool recurse, FSharpList`1<string> exclusions, bool inRoot, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string innerTextExcluding'(bool recurse, FSharpList`1<string> exclusions, HtmlNode n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string innerTextExcluding(FSharpList`1<string> exclusions, HtmlNode n);
    internal static int rowSpan@238(HtmlNode cell);
    internal static int colSpan@241(HtmlNode cell);
    [CompilerGeneratedAttribute]
internal static HtmlTableCell[] initializer@1(int numberOfColumns, int _arg3);
    internal static string getContents@286(FSharpList`1<HtmlNode> contents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<HtmlTable> parseTable(FSharpOption`1<Parameters> inferenceParameters, bool includeLayoutTables, FSharpFunc`2<string, string> makeUnique, int index, HtmlNode table, FSharpList`1<HtmlNode> parents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<HtmlList> parseList(FSharpFunc`2<string, string> makeUnique, int index, HtmlNode list, FSharpList`1<HtmlNode> parents);
    internal static FSharpList`1<Tuple`3<string, HtmlNode, FSharpList`1<string>>> loop@384(FSharpList`1<Tuple`3<string, HtmlNode, FSharpList`1<string>>> state, Tuple`3<string, HtmlNode, FSharpList`1<string>> currentGroup, FSharpList`1<HtmlNode> nodes);
    internal static FSharpList`1<Tuple`3<string, HtmlNode, FSharpList`1<string>>> createDefinitionGroups@383(FSharpList`1<HtmlNode> nodes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<HtmlDefinitionList> parseDefinitionList(FSharpFunc`2<string, string> makeUnique, int index, HtmlNode definitionList, FSharpList`1<HtmlNode> parents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<HtmlTable> getTables(FSharpOption`1<Parameters> inferenceParameters, bool includeLayoutTables, HtmlDocument doc);
    public static FSharpList`1<HtmlList> getLists(HtmlDocument doc);
    public static FSharpList`1<HtmlDefinitionList> getDefinitionLists(HtmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<HtmlObjectDescription> getHtmlObjects(FSharpOption`1<Parameters> inferenceParameters, bool includeLayoutTables, HtmlDocument doc);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.HtmlTable : object {
    internal String[][] rows;
    internal string name;
    internal FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>> inferedProperties;
    internal HtmlNode html;
    internal FSharpOption`1<Tuple`2[]> headerNamesAndUnits;
    internal FSharpOption`1<bool> hasHeaders;
    public string Name { get; }
    internal FSharpOption`1<Tuple`2[]> HeaderNamesAndUnits { get; }
    internal FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>> InferedProperties { get; }
    public FSharpOption`1<bool> HasHeaders { get; }
    public String[][] Rows { get; }
    public HtmlNode Html { get; }
    internal HtmlTable(string name, FSharpOption`1<Tuple`2[]> headerNamesAndUnits, FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>> inferedProperties, FSharpOption`1<bool> hasHeaders, String[][] rows, HtmlNode html);
    public string get_Name();
    internal FSharpOption`1<Tuple`2[]> get_HeaderNamesAndUnits();
    internal FSharpOption`1<FSharpList`1<PrimitiveInferedProperty>> get_InferedProperties();
    public FSharpOption`1<bool> get_HasHeaders();
    public String[][] get_Rows();
    public HtmlNode get_Html();
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class FSharp.Data.Runtime.HtmlTableCell : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static HtmlTableCell _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCell { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static HtmlTableCell Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public bool IsHeader { get; }
    public string Data { get; }
    private static HtmlTableCell();
    [CompilationMappingAttribute]
public static HtmlTableCell NewCell(bool item1, string item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCell();
    [CompilationMappingAttribute]
public static HtmlTableCell get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HtmlTableCell obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsHeader();
    public string get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HtmlTableCell obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.TextParser : object {
    [CompilationMappingAttribute]
internal static FSharpFunc`2<char, FSharpOption`1<char>> |Whitespace|_| { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<char, FSharpOption`1<char>> |LetterDigit|_| { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<char, FSharpOption`1<char>> |Letter|_| { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> toPattern(FSharpFunc`2<a, bool> f, a c);
    internal static FSharpOption`1<char> |EndOfFile|_|(char c);
    internal static FSharpFunc`2<char, FSharpOption`1<char>> get_|Whitespace|_|();
    internal static FSharpFunc`2<char, FSharpOption`1<char>> get_|LetterDigit|_|();
    internal static FSharpFunc`2<char, FSharpOption`1<char>> get_|Letter|_|();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class FSharp.Data.Utils : object {
    internal static string toLower(string s);
    internal static FSharpSet`1<string> getNameSet(IEnumerable`1<string> names);
}
[CompilationMappingAttribute]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyProduct;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyDescription;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
}
