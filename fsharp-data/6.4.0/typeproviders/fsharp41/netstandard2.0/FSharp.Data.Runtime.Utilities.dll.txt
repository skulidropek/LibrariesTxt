[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class FSharp.Data.Helpers : object {
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> msDateRegex { get; }
    internal static DateTimeStyles dateTimeStyles { get; }
    internal static FSharpOption`1<a> asOption(bool _arg1_0, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Unit> |StringEqualsIgnoreCase|_|(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Unit> |OneOfIgnoreCase|_|(String[] set, string str);
    internal static Lazy`1<Regex> get_msDateRegex();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DateTimeStyles get_dateTimeStyles();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<DateTime> ParseISO8601FormattedDateTime(string text, IFormatProvider cultureInfo);
}
[CompilationMappingAttribute]
public enum FSharp.Data.InferenceMode : Enum {
    public int value__;
    public static InferenceMode BackwardCompatible;
    public static InferenceMode NoInference;
    public static InferenceMode ValuesOnly;
    public static InferenceMode ValuesAndInlineSchemasHints;
    public static InferenceMode ValuesAndInlineSchemasOverrides;
}
[CompilationMappingAttribute]
internal static class FSharp.Data.Runtime.Caching : object {
    internal static FSharpAsync`1<Unit> invalidationFunction@21(TimeSpan expiration, ConcurrentDictionary`2<TKey_, Tuple`2<TValue, DateTime>> dict, TKey_ key);
    internal static ICache`2<TKey_, TValue> createInMemoryCache(TimeSpan expiration);
    internal static string hashString(string plainText);
    internal static string cacheFile@76(string downloadCache, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ICache`2<string, string> createInternetFileCache(string prefix, TimeSpan expiration);
}
[CompilationMappingAttribute]
public static class FSharp.Data.Runtime.IO : object {
    [CompilationMappingAttribute]
internal static IDisposable dummyDisposable { get; }
    [CompilationMappingAttribute]
internal static Dictionary`2<string, FileWatcher> watchers { get; }
    internal static bool isWeb(Uri uri);
    internal static IDisposable get_dummyDisposable();
    internal static void log(string _arg1);
    internal static void logWithStackTrace(string _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IDisposable logTime(string _arg2, string _arg1);
    internal static Dictionary`2<string, FileWatcher> get_watchers();
    [CompilerGeneratedAttribute]
internal static FileWatcher action@1(string path, string owner, FSharpFunc`2<Unit, Unit> onChange, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-1(string path, string owner, FileWatcher watcher, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable watchForChanges(string path, string owner, FSharpFunc`2<Unit, Unit> onChange);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpAsync`1<TextReader>, FSharpOption`1<string>> asyncRead(UriResolver uriResolver, string formatName, string encodingStr, Uri uri);
    internal static Uri withUri(string uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<TextReader> asyncReadTextAtRuntime(bool forFSI, string defaultResolutionFolder, string resolutionFolder, string formatName, string encodingStr, string uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<TextReader> asyncReadTextAtRuntimeWithDesignTimeRules(string defaultResolutionFolder, string resolutionFolder, string formatName, string encodingStr, string uri);
}
[CompilationMappingAttribute]
public static class FSharp.Data.Runtime.NameUtils : object {
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> |LetterDigit|_| { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> |Upper|_| { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> |Lower|_| { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<char> tryAt(string s, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<char> sat(FSharpFunc`2<char, bool> f, FSharpValueOption`1<char> c);
    internal static FSharpValueOption`1<Unit> |EOF|_|(FSharpValueOption`1<a> c);
    internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> get_|LetterDigit|_|();
    internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> get_|Upper|_|();
    internal static FSharpFunc`2<FSharpValueOption`1<char>, FSharpValueOption`1<char>> get_|Lower|_|();
    internal static IEnumerable`1<Tuple`2<int, int>> restart@43(string s, int i);
    internal static IEnumerable`1<Tuple`2<int, int>> upperStart@52(string s, int from, int i);
    internal static IEnumerable`1<Tuple`2<int, int>> consume@62(string s, int from, bool takeUpper, int i);
    public static string nicePascalName(string s);
    public static string niceCamelName(string s);
    public static FSharpFunc`2<string, string> uniqueGenerator(FSharpFunc`2<string, string> niceName);
    public static string capitalizeFirstLetter(string s);
    internal static void loop@154(Char[] chars, StringBuilder res, int i, bool emitSpace, bool inside);
    public static string trimHtml(string s);
    public static string pluralize(string s);
    public static string singularize(string s);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.Runtime.Pluralizer : object {
    [CompilationMappingAttribute]
internal static Lazy`1<Tuple`3<FSharpList`1<SuffixRule>, Dictionary`2<string, string>, Dictionary`2<string, string>>> tables { get; }
    internal static Lazy`1<Tuple`3<FSharpList`1<SuffixRule>, Dictionary`2<string, string>, Dictionary`2<string, string>>> get_tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string adjustCase(string s, string template);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> tryToPlural(string word, SuffixRule suffixRule);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> tryToSingular(string word, SuffixRule suffixRule);
    internal static string toPlural(string noun);
    internal static string toSingular(string noun);
}
[CompilationMappingAttribute]
public static class FSharp.Data.Runtime.StructuralInference : object {
    [CompilationMappingAttribute]
internal static FSharpList`1<Type> numericTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Type> primitiveTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<Type, FSharpList`1<Type>>> conversionTable { get; }
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationMappingAttribute]
public static IUnitsOfMeasureProvider defaultUnitsOfMeasureProvider { get; }
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationMappingAttribute]
public static IDictionary`2<string, Tuple`2<Type, TypeWrapper>> nameToType { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<string, Tuple`2<Type, TypeWrapper>>> arg@1 { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> typeAndUnitRegex { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<Regex> validInlineSchema { get; }
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
public static FSharpOption`1<a> asOption(bool inp_0, a x);
    internal static FSharpList`1<Type> get_numericTypes();
    internal static FSharpList`1<Type> get_primitiveTypes();
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
public static bool supportsUnitsOfMeasure(Type typ);
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
public static InferedTypeTag typeTag(InferedType inferredType);
    internal static FSharpList`1<Tuple`2<Type, FSharpList`1<Type>>> get_conversionTable();
    internal static bool convertibleTo@148(Type typ, Type source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Type> subtypePrimitives(Type typ1, Type typ2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<Type, FSharpOption`1<Type>, bool, bool>> |SubtypePrimitives|_|(bool allowEmptyValues, InferedType _arg1_0, InferedType _arg1_1);
    internal static void action@1-2(List`1<Tuple`2<InferedTypeTag, InferedType>> primitiveOverrides, List`1<Tuple`2<InferedTypeTag, InferedType>> nonPrimitives, InferedTypeTag tag, InferedType typ);
    [CompilerGeneratedAttribute]
internal static InferedType subtypeInfered$cont@253(FSharpList`1<Tuple`2<InferedTypeTag, InferedType>> tagMerged, bool containsOptional, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InferedType subtypeInfered(bool allowEmptyValues, InferedType ot1, InferedType ot2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<InferedTypeTag, InferedType>>, bool> unionHeterogeneousTypes(bool allowEmptyValues, FSharpMap`2<InferedTypeTag, InferedType> cases1, FSharpMap`2<InferedTypeTag, InferedType> cases2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>>> unionCollectionTypes(bool allowEmptyValues, FSharpMap`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>> cases1, FSharpMap`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>> cases2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<InferedTypeTag> unionCollectionOrder(FSharpList`1<InferedTypeTag> order1, FSharpList`1<InferedTypeTag> order2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<InferedProperty> unionRecordTypes(bool allowEmptyValues, FSharpList`1<InferedProperty> t1, FSharpList`1<InferedProperty> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InferedType inferCollectionType(bool allowEmptyValues, IEnumerable`1<InferedType> types);
    public static IUnitsOfMeasureProvider get_defaultUnitsOfMeasureProvider();
    internal static FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<IUnitsOfMeasureProvider, FSharpFunc`2<a, Type>>>> uomTransformations();
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Type> parseUnitOfMeasure(IUnitsOfMeasureProvider provider, string str);
    public static IDictionary`2<string, Tuple`2<Type, TypeWrapper>> get_nameToType();
    internal static FSharpList`1<Tuple`2<string, Tuple`2<Type, TypeWrapper>>> get_arg@1();
    internal static Lazy`1<Regex> get_typeAndUnitRegex();
    internal static Lazy`1<Regex> get_validInlineSchema();
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpOption`1<Tuple`2<Type, TypeWrapper>>, FSharpOption`1<Type>> parseTypeAndUnit(IUnitsOfMeasureProvider unitsOfMeasureProvider, IDictionary`2<string, Tuple`2<Type, TypeWrapper>> nameToType, string str);
    internal static FSharpFunc`2<a, FSharpOption`1<b>> |Parse|_|@526(CultureInfo cultureInfo, FSharpFunc`2<CultureInfo, FSharpFunc`2<a, FSharpOption`1<b>>> func);
    internal static FSharpFunc`2<a, FSharpOption`1<b>> |ParseNoCulture|_|@527(FSharpFunc`2<a, FSharpOption`1<b>> func);
    internal static FSharpFunc`2<a, FSharpFunc`2<string, FSharpOption`1<Guid>>> asGuid@529();
    internal static bool isFakeDate@534(CultureInfo cultureInfo, DateTime date, string value);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<InferedType> matchValue$cont@556(CultureInfo cultureInfo, FSharpOption`1<Type> desiredUnit, string value, Unit unitVar);
    internal static FSharpOption`1<InferedType> matchValue@552(CultureInfo cultureInfo, FSharpOption`1<Type> desiredUnit, string value);
    internal static FSharpOption`1<InferedType> matchInlineSchema@573(IUnitsOfMeasureProvider unitsOfMeasureProvider, FSharpOption`1<Type> desiredUnit, bool useInlineSchemasOverrides, string value);
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InferedType inferPrimitiveType(IUnitsOfMeasureProvider unitsOfMeasureProvider, InferenceMode' inferenceMode, CultureInfo cultureInfo, string value, FSharpOption`1<Type> desiredUnit);
    [ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InferedType getInferedTypeFromString(IUnitsOfMeasureProvider unitsOfMeasureProvider, InferenceMode' inferenceMode, CultureInfo cultureInfo, string value, FSharpOption`1<Type> unit);
}
[StructAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.Bit : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Bit Bit { get; }
    [CompilationMappingAttribute]
public static Bit get_Bit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Bit obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Bit obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.Bit0 : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Bit0 Bit0 { get; }
    [CompilationMappingAttribute]
public static Bit0 get_Bit0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Bit0 obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Bit0 obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.Bit1 : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Bit1 Bit1 { get; }
    [CompilationMappingAttribute]
public static Bit1 get_Bit1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Bit1 obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Bit1 obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.InferedMultiplicity : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedMultiplicity Single { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSingle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedMultiplicity OptionalSingle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOptionalSingle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedMultiplicity Multiple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMultiple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InferedMultiplicity(int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InferedMultiplicity(int _tag, byte );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InferedMultiplicity(int _tag, sbyte );
    [CompilationMappingAttribute]
public static InferedMultiplicity get_Single();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSingle();
    [CompilationMappingAttribute]
public static InferedMultiplicity get_OptionalSingle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOptionalSingle();
    [CompilationMappingAttribute]
public static InferedMultiplicity get_Multiple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMultiple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InferedMultiplicity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InferedMultiplicity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.InferedProperty : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
public InferedType Type@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public InferedType Type { get; public set; }
    public InferedProperty(string name, InferedType type);
    public string get_Name();
    public InferedType get_Type();
    public void set_Type(InferedType value);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InferedProperty obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CustomEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.InferedType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedType _unique_Null;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedType _unique_Top;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrimitive { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJson { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCollection { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHeterogeneous { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedType Null { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedType Top { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTop { get; }
    public bool IsOptional { get; }
    private static InferedType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InferedType(int _tag);
    [CompilationMappingAttribute]
public static InferedType NewPrimitive(Type _typ, FSharpOption`1<Type> _unit, bool _optional, bool _shouldOverrideOnMerge);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrimitive();
    [CompilationMappingAttribute]
public static InferedType NewRecord(FSharpOption`1<string> _name, FSharpList`1<InferedProperty> _fields, bool _optional);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute]
public static InferedType NewJson(InferedType _typ, bool _optional);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJson();
    [CompilationMappingAttribute]
public static InferedType NewCollection(FSharpList`1<InferedTypeTag> _order, FSharpMap`2<InferedTypeTag, Tuple`2<InferedMultiplicity, InferedType>> _types);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCollection();
    [CompilationMappingAttribute]
public static InferedType NewHeterogeneous(FSharpMap`2<InferedTypeTag, InferedType> _types, bool _containsOptional);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHeterogeneous();
    [CompilationMappingAttribute]
public static InferedType get_Null();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNull();
    [CompilationMappingAttribute]
public static InferedType get_Top();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    public bool get_IsOptional();
    public static bool CanHaveEmptyValues(Type typ);
    public InferedType EnsuresHandlesMissingValues(bool allowEmptyValues);
    public Tuple`2<InferedType, bool> GetDropOptionality();
    public InferedType DropOptionality();
    public virtual int GetHashCode();
    public virtual bool Equals(object y);
    public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.InferedTypeTag : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Null;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Number;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Boolean;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_String;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Json;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_DateTime;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_TimeSpan;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_DateTimeOffset;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Guid;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Collection;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InferedTypeTag _unique_Heterogeneous;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Null { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Number { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNumber { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Boolean { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBoolean { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag String { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Json { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJson { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag DateTime { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDateTime { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag TimeSpan { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTimeSpan { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag DateTimeOffset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDateTimeOffset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Guid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGuid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Collection { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCollection { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InferedTypeTag Heterogeneous { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHeterogeneous { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    public string NiceName { get; }
    public string Code { get; }
    private static InferedTypeTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InferedTypeTag(int _tag);
    [CompilationMappingAttribute]
public static InferedTypeTag get_Null();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNull();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Number();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNumber();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Boolean();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBoolean();
    [CompilationMappingAttribute]
public static InferedTypeTag get_String();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Json();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJson();
    [CompilationMappingAttribute]
public static InferedTypeTag get_DateTime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDateTime();
    [CompilationMappingAttribute]
public static InferedTypeTag get_TimeSpan();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTimeSpan();
    [CompilationMappingAttribute]
public static InferedTypeTag get_DateTimeOffset();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDateTimeOffset();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Guid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGuid();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Collection();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCollection();
    [CompilationMappingAttribute]
public static InferedTypeTag get_Heterogeneous();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHeterogeneous();
    [CompilationMappingAttribute]
public static InferedTypeTag NewRecord(FSharpOption`1<string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InferedTypeTag obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_NiceName();
    public string get_Code();
    public static InferedTypeTag ParseCode(string str);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InferedTypeTag obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal class FSharp.Data.Runtime.StructuralTypes.PrimitiveInferedProperty : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal PrimitiveInferedValue Value@;
    [CompilationMappingAttribute]
internal string Name { get; }
    [CompilationMappingAttribute]
internal PrimitiveInferedValue Value { get; }
    internal PrimitiveInferedProperty(string name, PrimitiveInferedValue value);
    internal string get_Name();
    internal PrimitiveInferedValue get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static PrimitiveInferedProperty Create(string name, Type typ, TypeWrapper typWrapper, FSharpOption`1<Type> unit);
    internal static PrimitiveInferedProperty Create(string name, Type typ, bool optional, FSharpOption`1<Type> unit);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PrimitiveInferedProperty obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal class FSharp.Data.Runtime.StructuralTypes.PrimitiveInferedValue : object {
    [DebuggerBrowsableAttribute("0")]
internal Type InferedType@;
    [DebuggerBrowsableAttribute("0")]
internal Type RuntimeType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Type> UnitOfMeasure@;
    [DebuggerBrowsableAttribute("0")]
internal TypeWrapper TypeWrapper@;
    [CompilationMappingAttribute]
internal Type InferedType { get; }
    [CompilationMappingAttribute]
internal Type RuntimeType { get; }
    [CompilationMappingAttribute]
internal FSharpOption`1<Type> UnitOfMeasure { get; }
    [CompilationMappingAttribute]
internal TypeWrapper TypeWrapper { get; }
    internal PrimitiveInferedValue(Type inferedType, Type runtimeType, FSharpOption`1<Type> unitOfMeasure, TypeWrapper typeWrapper);
    internal Type get_InferedType();
    internal Type get_RuntimeType();
    internal FSharpOption`1<Type> get_UnitOfMeasure();
    internal TypeWrapper get_TypeWrapper();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static PrimitiveInferedValue Create(Type typ, TypeWrapper typWrapper, FSharpOption`1<Type> unit);
    internal static PrimitiveInferedValue Create(Type typ, bool optional, FSharpOption`1<Type> unit);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PrimitiveInferedValue obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[RequireQualifiedAccessAttribute]
[ObsoleteAttribute("This API will be made internal in a future release. Please file an issue at https://github.com/fsprojects/FSharp.Data/issues/1458 if you need this public.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.StructuralTypes.TypeWrapper : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TypeWrapper None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TypeWrapper Option { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOption { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TypeWrapper Nullable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNullable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TypeWrapper(int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TypeWrapper(int _tag, byte );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TypeWrapper(int _tag, sbyte );
    [CompilationMappingAttribute]
public static TypeWrapper get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute]
public static TypeWrapper get_Option();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOption();
    [CompilationMappingAttribute]
public static TypeWrapper get_Nullable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TypeWrapper obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static TypeWrapper FromOption(bool optional);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeWrapper obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class FSharp.Data.Runtime.TextRuntime : object {
    [ThreadStaticAttribute]
[DefaultValueAttribute]
internal static Dictionary`2<string, CultureInfo> cultureInfoCache@;
    [CompilationMappingAttribute]
internal static Dictionary`2<string, CultureInfo> cultureInfoCache { get; internal set; }
    internal static Dictionary`2<string, CultureInfo> get_cultureInfoCache();
    internal static void set_cultureInfoCache(Dictionary`2<string, CultureInfo> value);
    public static CultureInfo GetCulture(string cultureStr);
    public static String[] GetMissingValues(string missingValuesStr);
    public static FSharpOption`1<string> ConvertString(FSharpOption`1<string> text);
    public static FSharpOption`1<int> ConvertInteger(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<long> ConvertInteger64(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<decimal> ConvertDecimal(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<double> ConvertFloat(string cultureStr, string missingValuesStr, FSharpOption`1<string> text);
    public static FSharpOption`1<bool> ConvertBoolean(FSharpOption`1<string> text);
    public static FSharpOption`1<DateTime> ConvertDateTime(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<DateTimeOffset> ConvertDateTimeOffset(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<TimeSpan> ConvertTimeSpan(string cultureStr, FSharpOption`1<string> text);
    public static FSharpOption`1<Guid> ConvertGuid(FSharpOption`1<string> text);
    public static string ConvertStringBack(FSharpOption`1<string> value);
    public static string ConvertIntegerBack(string cultureStr, FSharpOption`1<int> value);
    public static string ConvertInteger64Back(string cultureStr, FSharpOption`1<long> value);
    public static string ConvertDecimalBack(string cultureStr, FSharpOption`1<decimal> value);
    public static string ConvertFloatBack(string cultureStr, string missingValuesStr, FSharpOption`1<double> value);
    public static string ConvertBooleanBack(FSharpOption`1<bool> value, bool use0and1);
    public static string ConvertDateTimeBack(string cultureStr, FSharpOption`1<DateTime> value);
    public static string ConvertDateTimeOffsetBack(string cultureStr, FSharpOption`1<DateTimeOffset> value);
    public static string ConvertTimeSpanBack(string cultureStr, FSharpOption`1<TimeSpan> value);
    public static string ConvertGuidBack(FSharpOption`1<Guid> value);
    public static T GetNonOptionalValue(string name, FSharpOption`1<T> opt, FSharpOption`1<string> originalValue);
    public static Nullable`1<b> OptionToNullable(FSharpOption`1<b> opt);
    public static FSharpOption`1<a> NullableToOption(Nullable`1<a> nullable);
    public static FSharpAsync`1<R> AsyncMap(FSharpAsync`1<T> valueAsync, Func`2<T, R> mapping);
}
[CompilationMappingAttribute]
public class FSharp.Data.TextConversions : object {
    internal static String[] DefaultMissingValues@;
    internal static FSharpSet`1<char> DefaultNonCurrencyAdorners@;
    internal static FSharpSet`1<char> DefaultCurrencyAdorners@;
    internal static FSharpSet`1<char> DefaultRemovableAdornerCharacters@;
    internal static int init@53;
    public static String[] DefaultMissingValues { get; }
    public static FSharpSet`1<char> DefaultNonCurrencyAdorners { get; }
    public static FSharpSet`1<char> DefaultCurrencyAdorners { get; }
    internal static FSharpSet`1<char> DefaultRemovableAdornerCharacters { get; }
    private static TextConversions();
    public static String[] get_DefaultMissingValues();
    public static FSharpSet`1<char> get_DefaultNonCurrencyAdorners();
    public static FSharpSet`1<char> get_DefaultCurrencyAdorners();
    internal static FSharpSet`1<char> get_DefaultRemovableAdornerCharacters();
    internal static string RemoveAdorners(string value);
    public static FSharpOption`1<string> AsString(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<int> AsInteger(IFormatProvider cultureInfo, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<long> AsInteger64(IFormatProvider cultureInfo, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<decimal> AsDecimal(IFormatProvider cultureInfo, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<double> AsFloat(String[] missingValues, bool useNoneForMissingValues, IFormatProvider cultureInfo, string text);
    public static FSharpOption`1<bool> AsBoolean(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<DateTime> AsDateTime(IFormatProvider cultureInfo, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<DateTimeOffset> AsDateTimeOffset(IFormatProvider cultureInfo, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<TimeSpan> AsTimeSpan(CultureInfo cultureInfo, string text);
    public static FSharpOption`1<Guid> AsGuid(string text);
}
[CompilationMappingAttribute]
internal static class FSharp.Data.UnicodeHelper : object {
    internal static Tuple`2<char, char> getUnicodeSurrogatePair(UInt32 num);
}
[CompilationMappingAttribute]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyProduct;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyDescription;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
}
