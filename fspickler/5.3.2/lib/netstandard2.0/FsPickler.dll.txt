[CompilationMappingAttribute]
internal class MBrace.FsPickler.AbstractPickler : object {
    internal static Pickler`1<T> Create();
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.AltPickler : object {
    internal static Pickler`1<T> Create(FSharpFunc`2<T, int> tagReader, FSharpList`1<Pickler`1<T>> picklers);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ArrayPickler : object {
    internal static Pickler`1<Byte[]> CreateByteArrayPickler();
    internal static Pickler`1<T[]> Create(Pickler`1<T> ep);
    internal static Pickler`1<T[0...,0...]> Create2D(Pickler`1<T> ep);
    internal static Pickler`1<T[0...,0...,0...]> Create3D(Pickler`1<T> ep);
    internal static Pickler`1<T[0...,0...,0...,0...]> Create4D(Pickler`1<T> ep);
    internal static Pickler`1<T[]> Create(IPicklerResolver resolver);
    internal static Pickler`1<T[0...,0...]> Create2D(IPicklerResolver resolver);
    internal static Pickler`1<T[0...,0...,0...]> Create3D(IPicklerResolver resolver);
    internal static Pickler`1<T[0...,0...,0...,0...]> Create4D(IPicklerResolver resolver);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.ArrayPicklerUtils : object {
    [CompilationMappingAttribute]
internal static String[] lengthTags { get; }
    [CompilationMappingAttribute]
internal static Int32[] arg@1 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<int, string> mapping@1-2 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<int, string> clo1@16 { get; }
    [CompilationMappingAttribute]
internal static Int32[] array@1 { get; }
    [CompilationMappingAttribute]
internal static String[] res@1 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isPrimitiveSerialized(Formatter fmt, Pickler ep);
    internal static String[] get_lengthTags();
    internal static Int32[] get_arg@1();
    internal static FSharpFunc`2<int, string> get_mapping@1-2();
    internal static FSharpFunc`2<int, string> get_clo1@16();
    internal static Int32[] get_array@1();
    internal static String[] get_res@1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Int32[] writeMultiDimensionalArrayRanks(IPickleFormatWriter fmt, int rank, Array array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Int32[] readMultiDimensionalArrayRanks(IPickleFormatReader fmt, int rank);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.AssemblyInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal string Version@;
    [DebuggerBrowsableAttribute("0")]
internal string Culture@;
    [DebuggerBrowsableAttribute("0")]
internal string PublicKeyToken@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public string Version { get; }
    [CompilationMappingAttribute]
public string Culture { get; }
    [CompilationMappingAttribute]
public string PublicKeyToken { get; }
    public string AssemblyQualifiedName { get; }
    public AssemblyInfo(string name, string version, string culture, string publicKeyToken);
    public string get_Name();
    public string get_Version();
    public string get_Culture();
    public string get_PublicKeyToken();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AssemblyInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static AssemblyInfo OfAssemblyName(AssemblyName name);
    public static AssemblyInfo OfAssembly(Assembly assembly);
    public AssemblyName ToAssemblyName();
    public string get_AssemblyQualifiedName();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AssemblyInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.BinaryFormatUtils : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ushort formatv0960;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ushort formatv1200;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ushort formatv1400;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ushort formatv2000;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ushort formatv4000;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static UInt32 initValue;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static UInt32 initMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static UInt32 flagMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int bufferSize;
    [CompilationMappingAttribute]
internal static bool isLittleEndianSystem { get; }
    [CompilationMappingAttribute]
internal static ThreadLocal`1<Byte[]> buffer { get; }
    private static BinaryFormatUtils();
    internal static bool get_isLittleEndianSystem();
    internal static UInt32 createHeader(ObjectFlags flags);
    internal static ObjectFlags readHeader(UInt32 header);
    internal static ThreadLocal`1<Byte[]> get_buffer();
    internal static void blockCopy(Array source, Stream target);
    internal static void blockRead(Stream source, Array target);
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.BinaryPickleFormatProvider : object {
    internal bool ForceLittleEndian@;
    public bool ForceLittleEndian { get; public set; }
    public BinaryPickleFormatProvider(bool forceLittleEndian);
    public bool get_ForceLittleEndian();
    public void set_ForceLittleEndian(bool v);
    private virtual override string MBrace-FsPickler-IPickleFormatProvider-get_Name();
    private virtual override Encoding MBrace-FsPickler-IPickleFormatProvider-get_DefaultEncoding();
    private virtual override IPickleFormatWriter MBrace-FsPickler-IPickleFormatProvider-CreateWriter(Stream stream, Encoding encoding, bool _arg1, bool leaveOpen);
    private virtual override IPickleFormatReader MBrace-FsPickler-IPickleFormatProvider-CreateReader(Stream stream, Encoding encoding, bool _arg2, bool leaveOpen);
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.BinaryPickleReader : object {
    internal Stream stream;
    internal Encoding encoding;
    internal BinaryReader br;
    internal bool isForcedLittleEndianStream;
    internal BinaryPickleReader(Stream stream, Encoding encoding, bool leaveOpen);
    private virtual override void System-IDisposable-Dispose();
    private virtual override void MBrace-FsPickler-IPickleFormatReader-BeginReadRoot(string tag);
    private virtual override void MBrace-FsPickler-IPickleFormatReader-EndReadRoot();
    private virtual override ObjectFlags MBrace-FsPickler-IPickleFormatReader-BeginReadObject(string _arg1);
    private virtual override void MBrace-FsPickler-IPickleFormatReader-EndReadObject();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_SerializeUnionCaseNames();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_UseNamedEnumSerialization();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_PreferLengthPrefixInSequences();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-ReadNextSequenceElement();
    private virtual override long MBrace-FsPickler-IPickleFormatReader-ReadCachedObjectId();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-ReadBoolean(string _arg2);
    private virtual override byte MBrace-FsPickler-IPickleFormatReader-ReadByte(string _arg3);
    private virtual override sbyte MBrace-FsPickler-IPickleFormatReader-ReadSByte(string _arg4);
    private virtual override short MBrace-FsPickler-IPickleFormatReader-ReadInt16(string _arg5);
    private virtual override int MBrace-FsPickler-IPickleFormatReader-ReadInt32(string _arg6);
    private virtual override long MBrace-FsPickler-IPickleFormatReader-ReadInt64(string _arg7);
    private virtual override ushort MBrace-FsPickler-IPickleFormatReader-ReadUInt16(string _arg8);
    private virtual override UInt32 MBrace-FsPickler-IPickleFormatReader-ReadUInt32(string _arg9);
    private virtual override ulong MBrace-FsPickler-IPickleFormatReader-ReadUInt64(string _arg10);
    private virtual override decimal MBrace-FsPickler-IPickleFormatReader-ReadDecimal(string _arg11);
    private virtual override float MBrace-FsPickler-IPickleFormatReader-ReadSingle(string _arg12);
    private virtual override double MBrace-FsPickler-IPickleFormatReader-ReadDouble(string _arg13);
    private virtual override char MBrace-FsPickler-IPickleFormatReader-ReadChar(string _arg14);
    private virtual override string MBrace-FsPickler-IPickleFormatReader-ReadString(string _arg15);
    private virtual override DateTime MBrace-FsPickler-IPickleFormatReader-ReadDateTime(string _arg16);
    private virtual override DateTimeOffset MBrace-FsPickler-IPickleFormatReader-ReadDateTimeOffset(string _arg17);
    private virtual override TimeSpan MBrace-FsPickler-IPickleFormatReader-ReadTimeSpan(string _arg18);
    private virtual override Guid MBrace-FsPickler-IPickleFormatReader-ReadGuid(string _arg19);
    private virtual override BigInteger MBrace-FsPickler-IPickleFormatReader-ReadBigInteger(string _arg20);
    private virtual override Byte[] MBrace-FsPickler-IPickleFormatReader-ReadBytes(string _arg21);
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatReader-ReadPrimitiveArray(string _arg22, Array array);
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.BinaryPickleWriter : object {
    internal Stream stream;
    internal bool forceLittleEndian;
    internal Encoding encoding;
    internal BinaryWriter bw;
    internal BinaryPickleWriter(Stream stream, Encoding encoding, bool leaveOpen, bool forceLittleEndian);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-Flush();
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-BeginWriteRoot(string tag);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-EndWriteRoot();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_SerializeUnionCaseNames();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_UseNamedEnumSerialization();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_PreferLengthPrefixInSequences();
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteNextSequenceElement(bool hasNext);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteCachedObjectId(long id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-BeginWriteObject(string _arg1, ObjectFlags objectFlags);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-EndWriteObject();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBoolean(string _arg2, bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteByte(string _arg3, byte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteSByte(string _arg4, sbyte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt16(string _arg5, short value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt32(string _arg6, int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt64(string _arg7, long value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt16(string _arg8, ushort value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt32(string _arg9, UInt32 value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt64(string _arg10, ulong value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteSingle(string _arg11, float value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDouble(string _arg12, double value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDecimal(string _arg13, decimal value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteChar(string _arg14, char value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteString(string _arg15, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDateTime(string _arg16, DateTime value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDateTimeOffset(string _arg17, DateTimeOffset value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteTimeSpan(string _arg18, TimeSpan value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteGuid(string _arg19, Guid value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBigInteger(string _arg20, BigInteger value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBytes(string _arg21, Byte[] value);
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WritePrimitiveArray(string _arg22, Array array);
    private virtual override void System-IDisposable-Dispose();
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.BinarySerializer : FsPicklerSerializer {
    internal BinaryPickleFormatProvider format@;
    [CompilationMappingAttribute]
internal BinaryPickleFormatProvider format { get; }
    public bool ForceLittleEndian { get; public set; }
    public BinarySerializer(FSharpOption`1<bool> forceLittleEndian, FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<IPicklerResolver> picklerResolver);
    internal BinaryPickleFormatProvider get_format();
    public bool get_ForceLittleEndian();
    public void set_ForceLittleEndian(bool f);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ChoicePickler : object {
    internal static UnionCaseSerializationHelper c2;
    internal static UnionCaseSerializationHelper c3;
    internal static UnionCaseSerializationHelper c4;
    internal static UnionCaseSerializationHelper c5;
    internal static UnionCaseSerializationHelper c6;
    internal static UnionCaseSerializationHelper c7;
    internal static int init@35-4;
    private static ChoicePickler();
    internal static Pickler`1<FSharpChoice`2<T1, T2>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2);
    internal static Pickler`1<FSharpChoice`2<T1, T2>> Create(IPicklerResolver resolver);
    internal static Pickler`1<FSharpChoice`3<T1, T2, T3>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3);
    internal static Pickler`1<FSharpChoice`3<T1, T2, T3>> Create(IPicklerResolver resolver);
    internal static Pickler`1<FSharpChoice`4<T1, T2, T3, T4>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4);
    internal static Pickler`1<FSharpChoice`4<T1, T2, T3, T4>> Create(IPicklerResolver resolver);
    internal static Pickler`1<FSharpChoice`5<T1, T2, T3, T4, T5>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5);
    internal static Pickler`1<FSharpChoice`5<T1, T2, T3, T4, T5>> Create(IPicklerResolver resolver);
    internal static Pickler`1<FSharpChoice`6<T1, T2, T3, T4, T5, T6>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5, Pickler`1<T6> p6);
    internal static Pickler`1<FSharpChoice`6<T1, T2, T3, T4, T5, T6>> Create(IPicklerResolver resolver);
    internal static Pickler`1<FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5, Pickler`1<T6> p6, Pickler`1<T7> p7);
    internal static Pickler`1<FSharpChoice`7<T1, T2, T3, T4, T5, T6, T7>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ClassFieldPickler : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler`1<T> Create(ICustomPicklerRegistry picklerRegistry, IPicklerResolver resolver);
}
[SealedAttribute]
[AttributeUsageAttribute("4")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.CloneableOnlyAttribute : Attribute {
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.CloneableOnlyPickler : object {
    internal static Pickler`1<T> Create();
}
[AutoSerializableAttribute("False")]
[SealedAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.CloneState : object {
    internal IPicklerResolver resolver;
    internal StreamingContext sc;
    internal long currentId;
    internal ObjectIDGenerator idGen;
    internal Stack`1<long> objStack;
    internal HashSet`1<long> cyclicObjects;
    internal Dictionary`2<long, object> objCache;
    internal long nodeCount;
    internal FSharpOption`1<Tuple`2<IObjectSifter, Dictionary`2<long, Tuple`2<object, List`1<long>>>>> siftData;
    internal FSharpOption`1<Dictionary`2<long, Tuple`2<long, object>>> unsiftData;
    public StreamingContext StreamingContext { get; }
    internal IPicklerResolver PicklerResolver { get; }
    internal Dictionary`2<long, object> ObjectCache { get; }
    internal Stack`1<long> ObjectStack { get; }
    internal HashSet`1<long> CyclicObjectSet { get; }
    internal FSharpOption`1<Dictionary`2<long, Tuple`2<long, object>>> UnSiftData { get; }
    internal FSharpOption`1<Tuple`2<IObjectSifter, Dictionary`2<long, Tuple`2<object, List`1<long>>>>> SiftData { get; }
    internal CloneState(IPicklerResolver resolver, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<IObjectSifter> sifter, FSharpOption`1<Tuple`2<Tuple`2[], Tuple`2[]>> unSiftData);
    public StreamingContext get_StreamingContext();
    internal IPicklerResolver get_PicklerResolver();
    internal long GetReferenceId(object obj, Boolean& firstTime);
    internal Dictionary`2<long, object> get_ObjectCache();
    internal void EarlyRegisterArray(Array array);
    internal Stack`1<long> get_ObjectStack();
    internal HashSet`1<long> get_CyclicObjectSet();
    internal long NextNodeId();
    internal FSharpOption`1<Dictionary`2<long, Tuple`2<long, object>>> get_UnSiftData();
    internal FSharpOption`1<Tuple`2<IObjectSifter, Dictionary`2<long, Tuple`2<object, List`1<long>>>>> get_SiftData();
    internal void DeclareProperSubtype();
    internal Tuple`2<Sifted`1<T>, Tuple`2[]> CreateSift(T value);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.Combinators.Binary : object {
    [CompilationMappingAttribute]
internal static Lazy`1<BinarySerializer> binarySerializer { get; }
    internal static Lazy`1<BinarySerializer> get_binarySerializer();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] pickle(Pickler`1<T> pickler, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T unpickle(Pickler`1<T> pickler, Byte[] pickle);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.Combinators.Pickler : object {
    [CompilationMappingAttribute]
public static Pickler`1<Unit> unit { get; }
    [CompilationMappingAttribute]
public static Pickler`1<bool> bool { get; }
    [CompilationMappingAttribute]
public static Pickler`1<byte> byte { get; }
    [CompilationMappingAttribute]
public static Pickler`1<sbyte> sbyte { get; }
    [CompilationMappingAttribute]
public static Pickler`1<char> char { get; }
    [CompilationMappingAttribute]
public static Pickler`1<decimal> decimal { get; }
    [CompilationMappingAttribute]
public static Pickler`1<float> single { get; }
    [CompilationMappingAttribute]
public static Pickler`1<double> double { get; }
    [CompilationMappingAttribute]
public static Pickler`1<double> float { get; }
    [CompilationMappingAttribute]
public static Pickler`1<short> int16 { get; }
    [CompilationMappingAttribute]
public static Pickler`1<int> int { get; }
    [CompilationMappingAttribute]
public static Pickler`1<long> int64 { get; }
    [CompilationMappingAttribute]
public static Pickler`1<ushort> uint16 { get; }
    [CompilationMappingAttribute]
public static Pickler`1<UInt32> uint32 { get; }
    [CompilationMappingAttribute]
public static Pickler`1<ulong> uint64 { get; }
    [CompilationMappingAttribute]
public static Pickler`1<string> string { get; }
    [CompilationMappingAttribute]
public static Pickler`1<Guid> guid { get; }
    [CompilationMappingAttribute]
public static Pickler`1<DateTime> dateTime { get; }
    [CompilationMappingAttribute]
public static Pickler`1<DateTimeOffset> dateTimeOffset { get; }
    [CompilationMappingAttribute]
public static Pickler`1<TimeSpan> timeSpan { get; }
    [CompilationMappingAttribute]
public static Pickler`1<Byte[]> bytes { get; }
    [CompilationMappingAttribute]
public static Pickler`1<BigInteger> bigint { get; }
    [CompilationMappingAttribute]
public static Pickler`1<object> obj { get; }
    public static Pickler`1<Unit> get_unit();
    public static Pickler`1<bool> get_bool();
    public static Pickler`1<byte> get_byte();
    public static Pickler`1<sbyte> get_sbyte();
    public static Pickler`1<char> get_char();
    public static Pickler`1<decimal> get_decimal();
    public static Pickler`1<float> get_single();
    public static Pickler`1<double> get_double();
    public static Pickler`1<double> get_float();
    public static Pickler`1<short> get_int16();
    public static Pickler`1<int> get_int();
    public static Pickler`1<long> get_int64();
    public static Pickler`1<ushort> get_uint16();
    public static Pickler`1<UInt32> get_uint32();
    public static Pickler`1<ulong> get_uint64();
    public static Pickler`1<string> get_string();
    public static Pickler`1<Guid> get_guid();
    public static Pickler`1<DateTime> get_dateTime();
    public static Pickler`1<DateTimeOffset> get_dateTimeOffset();
    public static Pickler`1<TimeSpan> get_timeSpan();
    public static Pickler`1<Byte[]> get_bytes();
    public static Pickler`1<BigInteger> get_bigint();
    public static Pickler`1<object> get_obj();
    public static Pickler`1<T> auto();
    internal static Pickler uc(Pickler`1<T> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<Tuple`2<a, b>> pair(Pickler`1<a> f, Pickler`1<b> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<Tuple`3<a, b, c>> triple(Pickler`1<a> f, Pickler`1<b> g, Pickler`1<c> h);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<Tuple`4<a, b, c, d>> quad(Pickler`1<a> f, Pickler`1<b> g, Pickler`1<c> h, Pickler`1<d> i);
    public static Pickler`1<FSharpOption`1<T>> option(Pickler`1<T> f);
    public static Pickler`1<Nullable`1<T>> nullable(Pickler`1<T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<FSharpChoice`2<a, b>> choice2(Pickler`1<a> f, Pickler`1<b> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<FSharpChoice`3<a, b, c>> choice3(Pickler`1<a> f, Pickler`1<b> g, Pickler`1<c> h);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<FSharpChoice`4<a, b, c, d>> choice4(Pickler`1<a> f, Pickler`1<b> g, Pickler`1<c> h, Pickler`1<d> i);
    public static Pickler`1<FSharpRef`1<T>> ref(Pickler`1<T> f);
    public static Pickler`1<FSharpList`1<T>> list(Pickler`1<T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<FSharpMap`2<a, b>> map(Pickler`1<a> kp, Pickler`1<b> vp);
    public static Pickler`1<FSharpSet`1<T>> set(Pickler`1<T> f);
    public static Pickler`1<T[]> array(Pickler`1<T> f);
    public static Pickler`1<T[0...,0...]> array2D(Pickler`1<T> f);
    public static Pickler`1<T[0...,0...,0...]> array3D(Pickler`1<T> f);
    public static Pickler`1<T[0...,0...,0...,0...]> array4D(Pickler`1<T> f);
    public static Pickler`1<IEnumerable`1<a>> seq(Pickler`1<a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<b> wrap(FSharpFunc`2<a, b> recover, FSharpFunc`2<b, a> convert, Pickler`1<a> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<a> alt(FSharpFunc`2<a, int> tagReader, FSharpList`1<Pickler`1<a>> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickler`1<T> fromSerializationInfo(FSharpFunc`2<SerializationInfo, T> ctor, FSharpFunc`2<SerializationInfo, FSharpFunc`2<T, Unit>> proj);
    public static Pickler`1<FSharpFunc`2<T, U>> func();
    public static Pickler`1<T> fix(FSharpFunc`2<Pickler`1<T>, Pickler`1<T>> F);
    internal static FSharpFunc`2<CompositePickler`1<S>, Tuple`2<Pickler`1<T>, Pickler`1<S>>> F@151(FSharpFunc`2<Pickler`1<T>, FSharpFunc`2<Pickler`1<S>, Tuple`2<Pickler`1<T>, Pickler`1<S>>>> F, CompositePickler`1<T> arg00);
    public static Tuple`2<Pickler`1<T>, Pickler`1<S>> fix2(FSharpFunc`2<Pickler`1<T>, FSharpFunc`2<Pickler`1<S>, Tuple`2<Pickler`1<T>, Pickler`1<S>>>> F);
    internal static FSharpFunc`2<CompositePickler`1<S>, FSharpFunc`2<CompositePickler`1<U>, Tuple`3<Pickler`1<T>, Pickler`1<S>, Pickler`1<U>>>> F@159-2(FSharpFunc`2<Pickler`1<T>, FSharpFunc`2<Pickler`1<S>, FSharpFunc`2<Pickler`1<U>, Tuple`3<Pickler`1<T>, Pickler`1<S>, Pickler`1<U>>>>> F, CompositePickler`1<T> arg00);
    public static Tuple`3<Pickler`1<T>, Pickler`1<S>, Pickler`1<U>> fix3(FSharpFunc`2<Pickler`1<T>, FSharpFunc`2<Pickler`1<S>, FSharpFunc`2<Pickler`1<U>, Tuple`3<Pickler`1<T>, Pickler`1<S>, Pickler`1<U>>>>> F);
    public static Wrap`1<FSharpFunc`2<Part`3<b, a, c>, Pickler`1<b>>> product(a f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Wrap`1<FSharpFunc`2<Part`3<a, c, d>, Part`3<a, FSharpFunc`2<b, c>, Tuple`2<b, d>>>> field(FSharpFunc`2<a, b> f, Pickler`1<b> p);
    public static Wrap`1<FSharpFunc`2<Part`4<a, b, c, c>, Pickler`1<a>>> sum(FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Case`2<a, b> case(a inj, b p);
    public static Case`2<FSharpFunc`2<Unit, a>, Pickler`1<Unit>> variant(a v);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.Combinators.Xml : object {
    [CompilationMappingAttribute]
internal static Lazy`1<XmlSerializer> xmlSerializer { get; }
    internal static Lazy`1<XmlSerializer> get_xmlSerializer();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string pickle(Pickler`1<T> pickler, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T unpickle(Pickler`1<T> pickler, string pickle);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.CompositePickler : object {
    internal static Pickler`1<object> ObjectPickler { get; }
    internal static CompositePickler`1<T> CreateUninitialized();
    internal static void Copy(Pickler source, Pickler target);
    internal static Pickler`1<T> Create(FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> reader, FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> writer, FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> cloner, FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> accepter, PicklerInfo picklerInfo, FSharpOption`1<bool> cacheByRef, FSharpOption`1<bool> useWithSubtypes, FSharpOption`1<bool> skipHeaderWrite, FSharpOption`1<bool> bypass, FSharpOption`1<bool> skipVisit, FSharpOption`1<bool> isCloneableOnly);
    internal static Pickler`1<object> get_ObjectPickler();
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
internal class MBrace.FsPickler.CompositePickler`1 : Pickler`1<T> {
    internal bool m_IsInitialized;
    internal FSharpOption`1<Pickler> m_NestedPickler;
    internal FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> m_Writer;
    internal FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> m_Reader;
    internal FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> m_Cloner;
    internal FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> m_Accepter;
    internal PicklerInfo m_PicklerInfo;
    internal bool m_IsCacheByRef;
    internal bool m_UseWithSubtypes;
    internal bool m_SkipHeaderWrite;
    internal bool m_Bypass;
    internal bool m_SkipVisit;
    internal bool m_IsCloneableOnly;
    public Type ImplementationType { get; }
    public PicklerInfo PicklerInfo { get; }
    public bool IsCacheByRef { get; }
    public bool UseWithSubtypes { get; }
    public bool IsCloneableOnly { get; }
    internal FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> Writer { get; }
    internal FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> Reader { get; }
    internal FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> Cloner { get; }
    internal FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> Accepter { get; }
    public CompositePickler`1(FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> reader, FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> writer, FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> cloner, FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> accepter, FSharpOption`1<Pickler> nested, PicklerInfo picklerInfo, FSharpOption`1<bool> cacheByRef, FSharpOption`1<bool> useWithSubtypes, FSharpOption`1<bool> skipHeaderWrite, FSharpOption`1<bool> bypass, FSharpOption`1<bool> skipVisit, FSharpOption`1<bool> isCloneableOnly);
    public CompositePickler`1(FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> reader, FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> writer, FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> cloner, FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> accepter, PicklerInfo picklerInfo, FSharpOption`1<bool> cacheByRef, FSharpOption`1<bool> useWithSubtypes, FSharpOption`1<bool> skipHeaderWrite, FSharpOption`1<bool> bypass, FSharpOption`1<bool> skipVisit, FSharpOption`1<bool> isCloneableOnly);
    public virtual Type get_ImplementationType();
    public virtual PicklerInfo get_PicklerInfo();
    public virtual bool get_IsCacheByRef();
    public virtual bool get_UseWithSubtypes();
    public virtual bool get_IsCloneableOnly();
    public virtual Pickler`1<S> Cast();
    internal void InitializeFrom(Pickler p');
    internal FSharpFunc`2<WriteState, FSharpFunc`2<string, FSharpFunc`2<T, Unit>>> get_Writer();
    internal FSharpFunc`2<ReadState, FSharpFunc`2<string, T>> get_Reader();
    internal FSharpFunc`2<CloneState, FSharpFunc`2<T, T>> get_Cloner();
    internal FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>> get_Accepter();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual void Write(WriteState state, string tag, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual T Read(ReadState state, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual T Clone(CloneState state, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual void Accept(VisitState state, T value);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.CSharpProxy.FSharpFunc : object {
    [ExtensionAttribute]
public static FSharpFunc`2<a, b> ToFSharpFunc(Converter`2<a, b> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, bool> ToFSharpFunc(Predicate`1<a> func);
    [ExtensionAttribute]
public static FSharpFunc`2<Unit, a> ToFSharpFunc(Func`1<a> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, b> ToFSharpFunc(Func`2<a, b> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, c>> ToFSharpFunc(Func`3<a, b, c> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> ToFSharpFunc(Func`4<a, b, c, d> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, e>>>> ToFSharpFunc(Func`5<a, b, c, d, e> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, f>>>>> ToFSharpFunc(Func`6<a, b, c, d, e, f> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, g>>>>>> ToFSharpFunc(Func`7<a, b, c, d, e, f, g> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, h>>>>>>> ToFSharpFunc(Func`8<a, b, c, d, e, f, g, h> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, FSharpFunc`2<h, i>>>>>>>> ToFSharpFunc(Func`9<a, b, c, d, e, f, g, h, i> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, FSharpFunc`2<h, FSharpFunc`2<i, j>>>>>>>>> ToFSharpFunc(Func`10<a, b, c, d, e, f, g, h, i, j> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, FSharpFunc`2<h, FSharpFunc`2<i, FSharpFunc`2<j, k>>>>>>>>>> ToFSharpFunc(Func`11<a, b, c, d, e, f, g, h, i, j, k> func);
    [ExtensionAttribute]
public static FSharpFunc`2<Unit, Unit> ToFSharpFunc(Action func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, Unit> ToFSharpFunc(Action`1<a> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, Unit>> ToFSharpFunc(Action`2<a, b> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, Unit>>> ToFSharpFunc(Action`3<a, b, c> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, Unit>>>> ToFSharpFunc(Action`4<a, b, c, d> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, Unit>>>>> ToFSharpFunc(Action`5<a, b, c, d, e> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, Unit>>>>>> ToFSharpFunc(Action`6<a, b, c, d, e, f> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, Unit>>>>>>> ToFSharpFunc(Action`7<a, b, c, d, e, f, g> func);
    [ExtensionAttribute]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, FSharpFunc`2<f, FSharpFunc`2<g, FSharpFunc`2<h, Unit>>>>>>>> ToFSharpFunc(Action`8<a, b, c, d, e, f, g, h> func);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.CSharpProxy.Option : object {
    public static FSharpOption`1<a> Some(a v);
    public static FSharpOption`1<a> None();
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.CustomPickler : object {
    internal static Pickler`1<T> Create(IPicklerResolver resolver);
}
[SealedAttribute]
[AttributeUsageAttribute("4")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.CustomPicklerAttribute : Attribute {
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.CustomPicklerRegistration : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CustomPicklerRegistration _unique_UnRegistered;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CustomPicklerRegistration _unique_DeclaredSerializable;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CustomPicklerRegistration UnRegistered { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnRegistered { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CustomPicklerRegistration DeclaredSerializable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclaredSerializable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCustomPickler { get; }
    private static CustomPicklerRegistration();
    [CompilationMappingAttribute]
public static CustomPicklerRegistration get_UnRegistered();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnRegistered();
    [CompilationMappingAttribute]
public static CustomPicklerRegistration get_DeclaredSerializable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclaredSerializable();
    [CompilationMappingAttribute]
public static CustomPicklerRegistration NewCustomPickler(FSharpFunc`2<IPicklerResolver, Pickler> _factory);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCustomPickler();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.CustomPicklerRegistry : object {
    internal object syncRoot;
    internal bool isGenerationStarted;
    internal Dictionary`2<Type, FSharpFunc`2<IPicklerResolver, Pickler>> picklerFactories;
    internal HashSet`1<Type> typesDeclaredSerializable;
    internal List`1<FSharpFunc`2<Type, bool>> serializationPredicates;
    public bool IsGenerationStarted { get; }
    public Type[] TypesDeclaredSerializable { get; }
    public Type[] PicklerFactories { get; }
    public FSharpFunc`2[] SerializationPredicates { get; }
    public bool get_IsGenerationStarted();
    public Type[] get_TypesDeclaredSerializable();
    public Type[] get_PicklerFactories();
    public FSharpFunc`2[] get_SerializationPredicates();
    public void RegisterPickler(Pickler pickler);
    public void RegisterPicklers(Pickler[] picklers);
    public void RegisterFactory(FSharpFunc`2<IPicklerResolver, Pickler`1<T>> factory);
    public void DeclareSerializable(FSharpFunc`2<Type, bool> isSerializable);
    public void DeclareSerializable(Type[] typesToSerialize);
    public void DeclareSerializable();
    private virtual override CustomPicklerRegistration MBrace-FsPickler-ICustomPicklerRegistry-GetRegistration(Type t);
    [CompilerGeneratedAttribute]
internal a registerPickler(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
internal CustomPicklerRegistration getPicklerRegistration(Type t);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.DataContractPickler : object {
    internal static Pickler`1<T> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.DelegatePickler : object {
    internal static Pickler`1<Delegate> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.DictionaryPickler : object {
    internal static Pickler`1<Dictionary`2<K, V>> Create(Pickler`1<K> kp, Pickler`1<V> vp);
    internal static Pickler`1<Dictionary`2<K, V>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.Emit : object {
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.EmptyPicklerRegistry : object {
    private virtual override CustomPicklerRegistration MBrace-FsPickler-ICustomPicklerRegistry-GetRegistration(Type _arg1);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.EnumPickler : object {
    internal static Pickler`1<Enum> Create(IPicklerResolver resolver);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.ExtensionMethods : object {
    [CompilationMappingAttribute]
internal static Regex hashRegex { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Pickle`1<T> FsPicklerSerializer.PickleTyped(FsPicklerSerializer fsp, T value, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T FsPicklerSerializer.UnPickleTyped(FsPicklerSerializer fsp, Pickle`1<T> pickle, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public static Pickler`1<T> Pickler.FromPrimitives.Static(FSharpFunc`2<ReadState, T> reader, FSharpFunc`2<WriteState, FSharpFunc`2<T, Unit>> writer, FSharpOption`1<FSharpFunc`2<CloneState, FSharpFunc`2<T, T>>> cloner, FSharpOption`1<FSharpFunc`2<VisitState, FSharpFunc`2<T, Unit>>> accepter, FSharpOption`1<bool> cacheByRef, FSharpOption`1<bool> useWithSubtypes);
    public static Pickler`1<T> Pickler.FromSerializationInfo.Static(FSharpFunc`2<SerializationInfo, T> reader, FSharpFunc`2<SerializationInfo, FSharpFunc`2<T, Unit>> writer, FSharpOption`1<bool> useWithSubtypes);
    public static Pickler`1<T> Pickler.Null.Static(FSharpOption`1<bool> useWithSubtypes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SerializationInfo.Add(SerializationInfo sI, string name, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T SerializationInfo.Get(SerializationInfo sI, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<T> SerializationInfo.TryGet(SerializationInfo sI, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<object> SerializationInfo.TryGetObj(SerializationInfo sI, string name);
    internal static Regex get_hashRegex();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string HashResult.get_Id(HashResult );
    public static HashResult HashResult.Parse.Static(string id);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FsExceptionPickler : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler`1<Exception> Create(ICustomPicklerRegistry registry, IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FSharpMapPickler : object {
    internal static Pickler`1<FSharpMap`2<K, V>> Create(Pickler`1<K> kp, Pickler`1<V> vp);
    internal static Pickler`1<FSharpMap`2<K, V>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FSharpRefPickler : object {
    internal static Pickler`1<FSharpRef`1<T>> Create(Pickler`1<T> ep);
    internal static Pickler`1<FSharpRef`1<T>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FSharpSetPickler : object {
    internal static Pickler`1<FSharpSet`1<T>> Create(Pickler`1<T> ep);
    internal static Pickler`1<FSharpSet`1<T>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.FsPickler : object {
    internal static Lazy`1<BinarySerializer> defaultSerializer;
    internal static int init@12-6;
    private static FsPickler();
    public static BinarySerializer CreateBinarySerializer(FSharpOption`1<bool> forceLittleEndian, FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<IPicklerResolver> picklerResolver);
    public static XmlSerializer CreateXmlSerializer(FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<bool> indent, FSharpOption`1<IPicklerResolver> picklerResolver);
    public static bool IsSerializableType();
    public static bool IsSerializableType(Type t);
    public static bool IsSerializableValue(T graph, FSharpOption`1<bool> failOnCloneableOnlyTypes);
    public static Pickler`1<T> GeneratePickler();
    public static Pickler GeneratePickler(Type t);
    public static T Clone(T value, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public static Tuple`2<Sifted`1<T>, Tuple`2[]> Sift(T value, IObjectSifter sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public static Tuple`2<Sifted`1<T>, Tuple`2[]> Sift(T value, FSharpFunc`2<object, bool> sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public static T UnSift(Sifted`1<T> sifted, Tuple`2[] values, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public static long ComputeSize(T value, FSharpOption`1<Pickler`1<T>> pickler);
    public static ObjectSizeCounter CreateObjectSizeCounter(FSharpOption`1<Encoding> encoding, FSharpOption`1<long> resetInterval);
    public static void VisitObject(IObjectVisitor visitor, T graph, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<VisitOrder> visitOrder);
    public static HashResult ComputeHash(T value, FSharpOption`1<IHashStreamFactory> hashFactory);
    public static Type[] GatherTypesInObjectGraph(object graph);
    public static Object[] GatherObjectsInGraph(object graph);
    public static void EnsureSerializable(T graph, FSharpOption`1<bool> failOnCloneableOnlyTypes);
    [CompilerGeneratedAttribute]
internal static IPicklerResolver resolver();
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.FsPicklerException : Exception {
    public FsPicklerException(string message, FSharpOption`1<Exception> inner);
    internal FsPicklerException(SerializationInfo si, StreamingContext sc);
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.FsPicklerSerializer : object {
    internal IPickleFormatProvider formatProvider;
    internal IPicklerResolver resolver;
    internal ReflectionCache reflectionCache;
    internal bool DisableSubtypeResolution@;
    internal bool DisableAssemblyLoading@;
    public IPicklerResolver Resolver { get; }
    internal ReflectionCache ReflectionCache { get; }
    public bool DisableSubtypeResolution { get; public set; }
    public bool DisableAssemblyLoading { get; public set; }
    public string PickleFormat { get; }
    public FsPicklerSerializer(IPickleFormatProvider formatProvider, FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<IPicklerResolver> picklerResolver);
    public IPicklerResolver get_Resolver();
    internal ReflectionCache get_ReflectionCache();
    public bool get_DisableSubtypeResolution();
    public void set_DisableSubtypeResolution(bool v);
    public bool get_DisableAssemblyLoading();
    public void set_DisableAssemblyLoading(bool v);
    public string get_PickleFormat();
    public void Serialize(Stream stream, T value, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public T Deserialize(Stream stream, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public int SerializeSequence(Stream stream, IEnumerable`1<T> sequence, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public IEnumerable`1<T> DeserializeSequence(Stream stream, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public Tuple`2[] SerializeSifted(Stream stream, T value, IObjectSifter sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public T DeserializeSifted(Stream stream, Tuple`2[] sifted, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public Byte[] Pickle(T value, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public T UnPickle(Byte[] data, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public Tuple`2<Byte[], Tuple`2[]> PickleSifted(T value, IObjectSifter sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public T UnPickleSifted(Byte[] pickle, Tuple`2[] sifted, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public void SerializeUntyped(Stream stream, object value, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public object DeserializeUntyped(Stream stream, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public int SerializeSequenceUntyped(Stream stream, IEnumerable sequence, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public IEnumerable DeserializeSequenceUntyped(Stream stream, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding, FSharpOption`1<bool> leaveOpen);
    public Byte[] PickleUntyped(object value, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public object UnPickleUntyped(Byte[] pickle, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Encoding> encoding);
    public HashResult ComputeHash(T value, FSharpOption`1<IHashStreamFactory> hashFactory);
    public long ComputeSize(T value, FSharpOption`1<Pickler`1<T>> pickler);
    public ObjectSizeCounter CreateObjectSizeCounter(FSharpOption`1<Encoding> encoding, FSharpOption`1<long> resetInterval);
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.FsPicklerTextSerializer : FsPicklerSerializer {
    internal ITextPickleFormatProvider formatProvider;
    internal IPicklerResolver resolver;
    internal ReflectionCache reflectionCache;
    public FsPicklerTextSerializer(ITextPickleFormatProvider formatProvider, FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<IPicklerResolver> picklerResolver);
    public void Serialize(TextWriter writer, T value, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public T Deserialize(TextReader reader, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public int SerializeSequence(TextWriter writer, IEnumerable`1<T> sequence, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public IEnumerable`1<T> DeserializeSequence(TextReader reader, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public Tuple`2[] SerializeSifted(TextWriter writer, T value, IObjectSifter sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public T DeserializeSifted(TextReader reader, Tuple`2[] sifted, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public string PickleToString(T value, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public T UnPickleOfString(string pickle, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public Tuple`2<string, Tuple`2[]> PickleToStringSifted(T value, IObjectSifter sifter, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public T UnPickleOfStringSifted(string pickle, Tuple`2[] sifted, FSharpOption`1<Pickler`1<T>> pickler, FSharpOption`1<StreamingContext> streamingContext);
    public void SerializeUntyped(TextWriter writer, object value, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public object DeserializeUntyped(TextReader reader, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public int SerializeSequenceUntyped(TextWriter writer, IEnumerable sequence, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public IEnumerable DeserializeSequenceUntyped(TextReader reader, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<bool> leaveOpen);
    public string PickleToStringUntyped(object value, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext);
    public object UnPickleOfStringUntyped(string pickle, Pickler pickler, FSharpOption`1<StreamingContext> streamingContext);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FsRecordPickler : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler`1<Record> Create(ICustomPicklerRegistry registry, IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.FsUnionPickler : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler`1<Union> Create(ICustomPicklerRegistry registry, IPicklerResolver resolver);
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
internal class MBrace.FsPickler.Hashing.FNV1aStream : HashStream {
    internal int shift;
    internal ulong mask;
    internal long pos;
    internal ulong hash;
    public string HashAlgorithm { get; }
    public long Length { get; }
    public long Position { get; }
    public FNV1aStream(FSharpOption`1<int> bits);
    public virtual string get_HashAlgorithm();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual Byte[] ComputeHash();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] bytes, int offset, int count);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.Hashing.FNV1aStreamFactory : object {
    internal FSharpOption`1<int> bits;
    public FNV1aStreamFactory(FSharpOption`1<int> bits);
    private virtual override HashStream MBrace-FsPickler-Hashing-IHashStreamFactory-Create();
}
[StructuralEqualityAttribute]
[StructuralComparisonAttribute]
[AutoSerializableAttribute("True")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.Hashing.HashResult : object {
    [DebuggerBrowsableAttribute("0")]
internal string Algorithm@;
    [DebuggerBrowsableAttribute("0")]
internal string Type@;
    [DebuggerBrowsableAttribute("0")]
internal long Length@;
    [DebuggerBrowsableAttribute("0")]
internal Byte[] Hash@;
    [CompilationMappingAttribute]
public string Algorithm { get; }
    [CompilationMappingAttribute]
public string Type { get; }
    [CompilationMappingAttribute]
public long Length { get; }
    [CompilationMappingAttribute]
public Byte[] Hash { get; }
    public HashResult(string algorithm, string type, long length, Byte[] hash);
    public string get_Algorithm();
    public string get_Type();
    public long get_Length();
    public Byte[] get_Hash();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(HashResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HashResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.Hashing.HashStream : Stream {
    public string HashAlgorithm { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; }
    public int WriteTimeout { get; }
    unknown long Position {public set; }
    public abstract virtual string get_HashAlgorithm();
    public abstract virtual Byte[] ComputeHash();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual int get_WriteTimeout();
    public virtual long Seek(long _arg1, SeekOrigin _arg2);
    public virtual void SetLength(long _arg3);
    public virtual int Read(Byte[] _arg4, int _arg5, int _arg6);
    public virtual void Flush();
    public virtual void set_Position(long _arg7);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.Hashing.IHashStreamFactory {
    public abstract virtual HashStream Create();
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.Hashing.MurMur3 : object {
    internal FSharpOption`1<ulong> seed;
    public MurMur3(FSharpOption`1<ulong> seed);
    private virtual override HashStream MBrace-FsPickler-Hashing-IHashStreamFactory-Create();
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
internal class MBrace.FsPickler.Hashing.MurMur3Stream : HashStream {
    internal long length;
    internal ulong h1;
    internal ulong h2;
    internal ulong k1;
    internal ulong k2;
    internal bool atK2;
    internal int pos;
    public string HashAlgorithm { get; }
    public long Length { get; }
    public long Position { get; }
    public MurMur3Stream(FSharpOption`1<ulong> seed);
    public virtual string get_HashAlgorithm();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] bytes, int offset, int count);
    public virtual Byte[] ComputeHash();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.Hashing.MurMur3Utils : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ulong C1;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ulong C2;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong rotateLeft(ulong original, int bits);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong rotateRight(ulong original, int bits);
    internal static ulong mixkey1(ulong k);
    internal static ulong mixkey2(ulong k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mixBody(UInt64& h1, UInt64& h2, ulong k1, ulong k2);
    internal static void mixFinal(UInt64& k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong bytesToUInt64(Byte[] bytes, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void uint64ToBytes(Byte[] buf, int i, ulong value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong writeByte(ulong k, int i, byte b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeBytes(UInt64& k, int boffset, int koffset, int count, Byte[] bs);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.ICustomPicklerRegistry {
    public abstract virtual CustomPicklerRegistration GetRegistration(Type );
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.IgnoreStrongNamesConverter : object {
    internal bool ignoreVersion@205;
    public IgnoreStrongNamesConverter(FSharpOption`1<bool> ignoreVersion);
    private virtual override TypeInfo MBrace-FsPickler-ITypeNameConverter-OfSerializedType(TypeInfo tI);
    private virtual override TypeInfo MBrace-FsPickler-ITypeNameConverter-ToDeserializedType(TypeInfo tI);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.InvalidPickleTypeException : FsPicklerException {
    public InvalidPickleTypeException(string expectedType, string actualType);
    internal InvalidPickleTypeException(SerializationInfo si, StreamingContext sc);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IObjectSifter {
    public abstract virtual bool Sift(Pickler`1<T> pickler, long id, T value);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IObjectVisitor {
    public abstract virtual bool Visit(Pickler`1<T> pickler, T value);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IPickleFormatProvider {
    public string Name { get; }
    public Encoding DefaultEncoding { get; }
    public abstract virtual string get_Name();
    public abstract virtual Encoding get_DefaultEncoding();
    public abstract virtual IPickleFormatWriter CreateWriter(Stream , Encoding , bool isTopLevelSequence, bool leaveOpen);
    public abstract virtual IPickleFormatReader CreateReader(Stream , Encoding , bool isTopLevelSequence, bool leaveOpen);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IPickleFormatReader {
    public bool SerializeUnionCaseNames { get; }
    public bool PreferLengthPrefixInSequences { get; }
    public bool UseNamedEnumSerialization { get; }
    public bool IsPrimitiveArraySerializationSupported { get; }
    public abstract virtual void BeginReadRoot(string tag);
    public abstract virtual void EndReadRoot();
    public abstract virtual ObjectFlags BeginReadObject(string tag);
    public abstract virtual void EndReadObject();
    public abstract virtual bool get_SerializeUnionCaseNames();
    public abstract virtual bool get_PreferLengthPrefixInSequences();
    public abstract virtual bool get_UseNamedEnumSerialization();
    public abstract virtual bool ReadNextSequenceElement();
    public abstract virtual long ReadCachedObjectId();
    public abstract virtual bool ReadBoolean(string tag);
    public abstract virtual byte ReadByte(string tag);
    public abstract virtual sbyte ReadSByte(string tag);
    public abstract virtual short ReadInt16(string tag);
    public abstract virtual int ReadInt32(string tag);
    public abstract virtual long ReadInt64(string tag);
    public abstract virtual ushort ReadUInt16(string tag);
    public abstract virtual UInt32 ReadUInt32(string tag);
    public abstract virtual ulong ReadUInt64(string tag);
    public abstract virtual decimal ReadDecimal(string tag);
    public abstract virtual float ReadSingle(string tag);
    public abstract virtual double ReadDouble(string tag);
    public abstract virtual char ReadChar(string tag);
    public abstract virtual string ReadString(string tag);
    public abstract virtual DateTime ReadDateTime(string tag);
    public abstract virtual DateTimeOffset ReadDateTimeOffset(string tag);
    public abstract virtual TimeSpan ReadTimeSpan(string tag);
    public abstract virtual Guid ReadGuid(string tag);
    public abstract virtual BigInteger ReadBigInteger(string tag);
    public abstract virtual Byte[] ReadBytes(string tag);
    public abstract virtual bool get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void ReadPrimitiveArray(string tag, Array target);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IPickleFormatWriter {
    public bool PreferLengthPrefixInSequences { get; }
    public bool SerializeUnionCaseNames { get; }
    public bool UseNamedEnumSerialization { get; }
    public bool IsPrimitiveArraySerializationSupported { get; }
    public abstract virtual void Flush();
    public abstract virtual void BeginWriteRoot(string tag);
    public abstract virtual void EndWriteRoot();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void BeginWriteObject(string tag, ObjectFlags objectFlags);
    public abstract virtual void EndWriteObject();
    public abstract virtual bool get_PreferLengthPrefixInSequences();
    public abstract virtual bool get_SerializeUnionCaseNames();
    public abstract virtual bool get_UseNamedEnumSerialization();
    public abstract virtual void WriteNextSequenceElement(bool hasNext);
    public abstract virtual void WriteCachedObjectId(long id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteBoolean(string tag, bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteByte(string tag, byte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteSByte(string tag, sbyte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteInt16(string tag, short value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteInt32(string tag, int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteInt64(string tag, long value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteUInt16(string tag, ushort value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteUInt32(string tag, UInt32 value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteUInt64(string tag, ulong value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteSingle(string tag, float value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteDouble(string tag, double value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteDecimal(string tag, decimal value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteChar(string tag, char value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteString(string tag, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteDateTime(string tag, DateTime date);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteDateTimeOffset(string tag, DateTimeOffset date);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteTimeSpan(string tag, TimeSpan span);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteGuid(string tag, Guid guid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteBigInteger(string tag, BigInteger value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WriteBytes(string tag, Byte[] value);
    public abstract virtual bool get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void WritePrimitiveArray(string tag, Array value);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.IPicklerResolver {
    public abstract virtual bool IsSerializable(Type );
    public abstract virtual bool IsSerializable();
    public abstract virtual Pickler Resolve(Type );
    public abstract virtual Pickler`1<T> Resolve();
}
[CompilationMappingAttribute]
internal interface MBrace.FsPickler.IPicklerUnpacker`1 {
    public abstract virtual U Apply(Pickler`1<T> );
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ISerializablePickler : object {
    internal static Pickler`1<T> Create();
    internal static Pickler`1<T> CreateObjectReferencePickler();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler`1<Exn> CreateNonISerializableExceptionPickler(ICustomPicklerRegistry registry, IPicklerResolver resolver);
    internal static Pickler`1<T> FromSerializationInfo(FSharpFunc`2<SerializationInfo, T> ctor, FSharpFunc`2<SerializationInfo, FSharpFunc`2<T, Unit>> proj, FSharpOption`1<bool> useWithSubtypes);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.ISerializableUtils : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception mkDummyException(SerializationInfo si, StreamingContext sc);
    internal static SerializationInfo mkSerializationInfo();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkSerializationSubtype(WriteState w, T value);
    internal static void checkDeserializationSubtype(ReadState r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pickler resolveEntryPickler(IPicklerResolver r, SerializationEntry entry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeSerializationEntry(WriteState w, SerializationEntry entry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void readSerializationEntry(ReadState r, SerializationInfo sI);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeSerializationInfo(WriteState w, SerializationInfo sI);
    internal static SerializationInfo readSerializationInfo(ReadState r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SerializationInfo cloneSerializationInfo(CloneState c, SerializationInfo sI);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void acceptSerializationInfo(VisitState v, SerializationInfo sI);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.ISpecializedObjectVisitor`1 {
    public abstract virtual bool VisitSpecialized(Pickler`1<T> pickler, T value);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.ITextPickleFormatProvider {
    public abstract virtual IPickleFormatWriter CreateWriter(TextWriter , bool isTopLevelSequence, bool leaveOpen);
    public abstract virtual IPickleFormatReader CreateReader(TextReader , bool isTopLevelSequence, bool leaveOpen);
}
[CompilationMappingAttribute]
public interface MBrace.FsPickler.ITypeNameConverter {
    public abstract virtual TypeInfo OfSerializedType(TypeInfo );
    public abstract virtual TypeInfo ToDeserializedType(TypeInfo );
}
[CompilationMappingAttribute]
public enum MBrace.FsPickler.Kind : Enum {
    public byte value__;
    public static Kind Primitive;
    public static Kind Char;
    public static Kind Enum;
    public static Kind Value;
    public static Kind Nullable;
    public static Kind String;
    public static Kind Array;
    public static Kind Sealed;
    public static Kind NonSealed;
    public static Kind Abstract;
    public static Kind Delegate;
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.KindModule : object {
    internal static Kind compute(Type t);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ListPickler : object {
    internal static Pickler`1<FSharpList`1<T>> Create(Pickler`1<T> ep);
    internal static Pickler`1<FSharpList`1<T>> Create(IPicklerResolver resolver);
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.LocalFSharpCoreConverter : object {
    internal AssemblyInfo localCore;
    private virtual override TypeInfo MBrace-FsPickler-ITypeNameConverter-OfSerializedType(TypeInfo tI);
    private virtual override TypeInfo MBrace-FsPickler-ITypeNameConverter-ToDeserializedType(TypeInfo tI);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.NonSerializableTypeException : FsPicklerException {
    internal Type Type@;
    internal FSharpOption`1<Type> containedNonSerializableField@;
    [CompilationMappingAttribute]
public Type Type { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<Type> containedNonSerializableField { get; }
    public Type NonSerializableType { get; }
    internal NonSerializableTypeException(Type t, FSharpOption`1<string> message, FSharpOption`1<Exception> inner);
    internal NonSerializableTypeException(Type t, Type containedNonSerializableField, FSharpOption`1<Exception> inner);
    internal NonSerializableTypeException(SerializationInfo si, StreamingContext sc);
    public Type get_Type();
    public FSharpOption`1<Type> get_containedNonSerializableField();
    public Type get_NonSerializableType();
    private virtual override void System-Runtime-Serialization-ISerializable-GetObjectData(SerializationInfo si, StreamingContext sc);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.NullablePickler : object {
    internal static Pickler`1<Nullable`1<T>> Create(Pickler`1<T> pickler);
    internal static Pickler`1<Nullable`1<T>> Create(IPicklerResolver resolver);
}
[FlagsAttribute]
[CompilationMappingAttribute]
public enum MBrace.FsPickler.ObjectFlags : Enum {
    public byte value__;
    public static ObjectFlags None;
    public static ObjectFlags IsNull;
    public static ObjectFlags IsProperSubtype;
    public static ObjectFlags IsCachedInstance;
    public static ObjectFlags IsCyclicInstance;
    public static ObjectFlags IsSequenceHeader;
    public static ObjectFlags IsSiftedValue;
}
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.ObjectSizeCounter : object {
    internal IPicklerResolver resolver;
    internal FSharpOption`1<long> resetInterval;
    internal LengthCounterStream lengthCounter;
    internal long resetCount;
    internal long totalObjects;
    internal IPickleFormatWriter writer;
    internal WriteState writeState;
    public long Count { get; }
    public long ObjectCount { get; }
    internal ObjectSizeCounter(IPickleFormatProvider formatProvider, IPicklerResolver resolver, ReflectionCache reflectionCache, FSharpOption`1<Encoding> encoding, FSharpOption`1<long> resetInterval);
    public long get_Count();
    public long get_ObjectCount();
    public void Reset();
    public void ResetSerializationCache();
    public void Append(T value, FSharpOption`1<Pickler`1<T>> pickler);
    private virtual override void System-IDisposable-Dispose();
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.OptionPickler : object {
    internal static Pickler`1<FSharpOption`1<T>> Create(Pickler`1<T> ep);
    internal static Pickler`1<FSharpOption`1<T>> Create(IPicklerResolver resolver);
}
[AbstractClassAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.Pickler : object {
    internal Type t;
    internal Kind typeKind;
    internal bool isOpenHierarchy;
    internal bool isOfFixedSize;
    internal bool isRecursive@32;
    public Type ImplementationType { get; }
    public PicklerInfo PicklerInfo { get; }
    public bool IsCacheByRef { get; }
    public bool UseWithSubtypes { get; }
    public bool IsCloneableOnly { get; }
    public Type Type { get; }
    public Kind Kind { get; }
    public bool IsOfFixedSize { get; }
    public bool IsRecursiveType { get; }
    public bool IsOpenHierarchy { get; }
    internal Pickler(Type t);
    public abstract virtual Type get_ImplementationType();
    public abstract virtual PicklerInfo get_PicklerInfo();
    public abstract virtual bool get_IsCacheByRef();
    public abstract virtual bool get_UseWithSubtypes();
    public abstract virtual bool get_IsCloneableOnly();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void UntypedWrite(WriteState state, string tag, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual object UntypedRead(ReadState state, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual object UntypedClone(CloneState state, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void UntypedAccept(VisitState state, object value);
    public abstract virtual U Unpack(IPicklerUnpacker`1<U> );
    public abstract virtual Pickler`1<S> Cast();
    public Type get_Type();
    public Kind get_Kind();
    public bool get_IsOfFixedSize();
    public bool get_IsRecursiveType();
    public bool get_IsOpenHierarchy();
}
[AbstractClassAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public abstract class MBrace.FsPickler.Pickler`1 : Pickler {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void Write(WriteState state, string tag, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual T Read(ReadState state, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual T Clone(CloneState state, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void Accept(VisitState state, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual void UntypedWrite(WriteState state, string tag, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual object UntypedRead(ReadState state, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual object UntypedClone(CloneState state, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual void UntypedAccept(VisitState state, object value);
    public virtual R Unpack(IPicklerUnpacker`1<R> unpacker);
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.PicklerCache : object {
    internal ICustomPicklerRegistry registry;
    internal static int cacheInstaceCounter;
    internal static Lazy`1<PicklerCache> instance;
    internal ConcurrentDictionary`2<Type, Exn`1<Pickler>> dict;
    internal ICache`2<Type, Exn`1<Pickler>> cache;
    internal static int init@20-5;
    public ICustomPicklerRegistry Registry { get; }
    public static PicklerCache Instance { get; }
    internal PicklerCache(ICustomPicklerRegistry registry);
    private static PicklerCache();
    public ICustomPicklerRegistry get_Registry();
    public bool IsPicklerGenerated(Type t);
    public bool IsSerializableType();
    public bool IsSerializableType(Type t);
    public Pickler`1<T> GeneratePickler();
    public Pickler GeneratePickler(Type t);
    public static PicklerCache get_Instance();
    [CompilerMessageAttribute("PicklerCache instances are extremely heavyweight. Should only be created as singletons.", "8989")]
public static PicklerCache FromCustomPicklerRegistry(ICustomPicklerRegistry registry);
    private virtual override bool MBrace-FsPickler-IPicklerResolver-IsSerializable(Type t);
    private virtual override bool MBrace-FsPickler-IPicklerResolver-IsSerializable();
    private virtual override Pickler MBrace-FsPickler-IPicklerResolver-Resolve(Type t);
    private virtual override Pickler`1<T> MBrace-FsPickler-IPicklerResolver-Resolve();
    [CompilerGeneratedAttribute]
internal Exn`1<Pickler> resolve(Type t);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.PicklerEmit : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLoadPickler(EnvItem`1<Pickler[]> picklers, Type t, int idx, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitSerialize(Type t, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDeserialize(Type t, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitClone(Type t, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitAccept(Type t, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitSerializeMembers(MemberInfo[] members, String[] tags, EnvItem`1<WriteState> writer, EnvItem`1<Pickler[]> picklers, EnvItem`1<T> parent, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDeserializeMembers(MemberInfo[] members, String[] tags, EnvItem`1<ReadState> reader, EnvItem`1<Pickler[]> picklers, EnvItem`1<T> parent, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCloneMembers(MemberInfo[] members, EnvItem`1<CloneState> cloner, EnvItem`1<Pickler[]> picklers, EnvItem`1<T> source, EnvItem`1<T> target, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitAcceptMembers(MemberInfo[] members, EnvItem`1<VisitState> visitor, EnvItem`1<Pickler[]> picklers, EnvItem`1<T> source, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDeserializeAndConstruct(FSharpChoice`2<MethodInfo, ConstructorInfo> factory, Type[] fparams, String[] tags, EnvItem`1<ReadState> reader, EnvItem`1<Pickler[]> picklers, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCloneAndConstruct(FSharpChoice`2<MethodInfo, ConstructorInfo> factory, PropertyInfo[] fields, EnvItem`1<CloneState> cloner, EnvItem`1<Pickler[]> picklers, EnvItem`1<T> source, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitObjectInitializer(EnvItem`1<T> target, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitSerializationMethodCalls(MethodInfo[] methods, FSharpChoice`4<EnvItem`1<WriteState>, EnvItem`1<ReadState>, EnvItem`1<CloneState>, EnvItem`1<VisitState>> wOr, EnvItem`1<T> value, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDeserializationCallback(EnvItem`1<T> value, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitObjectReferenceResolver(EnvItem`1<T> value, FSharpChoice`2<EnvItem`1<ReadState>, EnvItem`1<CloneState>> state, ILGenerator ilGen);
    internal static Func`3<SerializationInfo, StreamingContext, T> wrapISerializableConstructor(ConstructorInfo ctor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeString(EnvItem`1<WriteState> writer, string tag, string value, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void readString(EnvItem`1<ReadState> reader, string tag, ILGenerator ilGen);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.PicklerGenerationException : FsPicklerException {
    internal Type Type@;
    [CompilationMappingAttribute]
public Type Type { get; }
    internal PicklerGenerationException(Type t, FSharpOption`1<string> message, FSharpOption`1<Exception> inner);
    internal PicklerGenerationException(SerializationInfo si, StreamingContext sc);
    public Type get_Type();
    private virtual override void System-Runtime-Serialization-ISerializable-GetObjectData(SerializationInfo si, StreamingContext sc);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.PicklerGenerator : object {
    [CompilerGeneratedAttribute]
internal static Pickler Create$cont@40-3(ICustomPicklerRegistry registry, IPicklerResolver resolver, TypeShape shape, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Pickler Create$cont@40-2(ICustomPicklerRegistry registry, IPicklerResolver resolver, TypeShape shape, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Pickler Create$cont@40-1(ICustomPicklerRegistry registry, IPicklerResolver resolver, TypeShape shape, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Pickler Create$cont@40(ICustomPicklerRegistry registry, IPicklerResolver resolver, TypeShape shape, Unit unitVar);
    internal static bool isUnsupportedType@30(Type t);
}
[CompilationMappingAttribute]
public enum MBrace.FsPickler.PicklerInfo : Enum {
    public byte value__;
    public static PicklerInfo Primitive;
    public static PicklerInfo Object;
    public static PicklerInfo ReflectionType;
    public static PicklerInfo FieldSerialization;
    public static PicklerInfo DataContract;
    public static PicklerInfo ISerializable;
    public static PicklerInfo Array;
    public static PicklerInfo FSharpValue;
    public static PicklerInfo Delegate;
    public static PicklerInfo Combinator;
    public static PicklerInfo UserDefined;
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.PicklerRegistryExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ICustomPicklerRegistry.IsDeclaredSerializable(ICustomPicklerRegistry __, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpFunc`2<a, Pickler>> ICustomPicklerRegistry.TryGetPicklerFactory(ICustomPicklerRegistry __, Type t);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.PicklerResolution : object {
    internal static bool isSerializable(Exn`1<Pickler> result);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exn`1<Pickler> resolvePickler(ICustomPicklerRegistry registry, IPicklerResolver resolver, FSharpFunc`2<Pickler, Unit> mkEarlyBinding, FSharpFunc`2<Pickler, bool> isPicklerReferenced, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exn`1<Pickler> generatePickler(ICustomPicklerRegistry registry, ICache`2<Type, Exn`1<Pickler>> globalCache, Type t);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.PrimitivePicklers : object {
}
[AutoSerializableAttribute("False")]
[SealedAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.ReadState : object {
    internal IPicklerResolver resolver;
    internal ReflectionCache reflectionCache;
    internal IPickleFormatReader formatter;
    internal bool disableSubtypes;
    internal bool disableAssemblyLoading;
    internal StreamingContext sc;
    internal long currentId;
    internal bool isUnsifting;
    internal Dictionary`2<long, object> objCache;
    internal Pickler`1<Type> tyPickler;
    public StreamingContext StreamingContext { get; }
    public bool DisableSubtypeResolution { get; }
    public bool DisableAssemblyLoading { get; }
    internal IPicklerResolver PicklerResolver { get; }
    internal bool IsUnSifting { get; }
    internal IPickleFormatReader Formatter { get; }
    internal Pickler`1<Type> TypePickler { get; }
    internal ReflectionCache ReflectionCache { get; }
    internal Dictionary`2<long, object> ObjectCache { get; }
    internal long ObjectCount { get; }
    internal ReadState(IPickleFormatReader formatter, IPicklerResolver resolver, ReflectionCache reflectionCache, bool disableSubtypeResolution, bool disableAssemblyLoading, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Tuple`2[]> sifted);
    public StreamingContext get_StreamingContext();
    public bool get_DisableSubtypeResolution();
    public bool get_DisableAssemblyLoading();
    internal IPicklerResolver get_PicklerResolver();
    internal bool get_IsUnSifting();
    internal IPickleFormatReader get_Formatter();
    internal Pickler`1<Type> get_TypePickler();
    internal ReflectionCache get_ReflectionCache();
    internal Dictionary`2<long, object> get_ObjectCache();
    internal long NextObjectId();
    internal long get_ObjectCount();
    internal void EarlyRegisterArray(Array array);
    internal void Reset();
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.Reflection : object {
    internal static BindingFlags allFields { get; }
    internal static BindingFlags allMembers { get; }
    internal static BindingFlags allStatic { get; }
    internal static BindingFlags allConstructors { get; }
    [CompilationMappingAttribute]
internal static Regex memberNameRegex { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_allFields();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_allMembers();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_allStatic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_allConstructors();
    internal static T Delegate.CreateDelegate.Static(MethodInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo Type.GetGenericMethod(Type t, bool isStatic, string name, int genericArgCount, int paramCount);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ConstructorInfo> Type.TryGetConstructor(Type t, Type[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object MethodInfo.GuardedInvoke(MethodInfo m, object instance, Object[] parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type[] MethodInfo.GetParameterTypes(MethodInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type[] ConstructorInfo.GetParameterTypes(ConstructorInfo );
    internal static Regex get_memberNameRegex();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getNormalizedFieldName(int i, string text);
    internal static bool containsAttr(MemberInfo m);
    internal static FSharpOption`1<T> tryGetAttr(MemberInfo m);
    internal static Dele[] wrapDelegate(MethodInfo[] ms);
    internal static StreamingContext getStreamingContext(T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAssignableFrom(Type interfaceTy, Type ty);
    internal static bool aux@83-3(Type t);
    internal static bool isRoslynReplSubmissionType(Type t);
    internal static bool isLinqEnumerable(Type t);
    internal static bool isReflectionSerializable(Type t);
    internal static bool isISerializable(Type t);
    internal static FSharpOption`1<ConstructorInfo> tryGetISerializableCtor(Type t);
    internal static IEnumerable`1<Type> getSupertypes(Type t);
    internal static MethodInfo[] getSerializationMethods(MethodInfo[] ms);
    internal static bool isNullableType(Type t);
    internal static bool isExceptionDispatchInfo(Type t);
    internal static void gather@139(Dictionary`2<Tuple`2<string, string>, MemberInfo> gathered, Type t);
    internal static MemberInfo[] gatherMembers(Type t);
    internal static FieldInfo[] gatherSerializedFields(Type t);
    internal static FSharpOption`1<Type> aux@185-4(FSharpList`1<Type> traversed, Type t);
    internal static bool isPolymorphicRecursive(Type t);
    internal static bool aux@229-10(bool openHierarchiesOnly, FSharpList`1<Type> traversed, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecursiveType(bool openHierarchiesOnly, Type t);
    internal static bool aux@272-17(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOfFixedSize(bool isRecursive, Type t);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.ReflectionCache : object {
    [CompilationMappingAttribute]
internal static Lazy`1<FSharpOption`1<<>f__AnonymousType3066382101`3<FSharpFunc`2<Unit, Assembly[]>, object, FSharpFunc`2<AssemblyName, Assembly>>>> currentLoadContext { get; }
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@17(IEqualityComparer comp, CompositeMemberInfo this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@17(CompositeMemberInfo this, CompositeMemberInfo that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@17-1(CompositeMemberInfo this, CompositeMemberInfo obj, Unit unitVar);
    internal static Lazy`1<FSharpOption`1<<>f__AnonymousType3066382101`3<FSharpFunc`2<Unit, Assembly[]>, object, FSharpFunc`2<AssemblyName, Assembly>>>> get_currentLoadContext();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Assembly getAssembly(bool enableAssemblyLoading, AssemblyInfo aI);
    [CompilerGeneratedAttribute]
internal static CompositeMemberInfo getMemberInfo$cont@139-1(FSharpFunc`2<MethodInfo, string> getMethodSignature, MethodInfo m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static CompositeMemberInfo getMemberInfo$cont@113(FSharpOption`1<ITypeNameConverter> tyConv, FSharpFunc`2<Assembly, AssemblyInfo> getAssemblyInfo, Type t, Unit unitVar);
    internal static FSharpOption`1<Type> getReflectedType@90(MemberInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositeMemberInfo getMemberInfo(FSharpOption`1<ITypeNameConverter> tyConv, FSharpFunc`2<Assembly, AssemblyInfo> getAssemblyInfo, FSharpFunc`2<MethodInfo, string> getMethodSignature, MemberInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MemberInfo loadMemberInfo(FSharpOption`1<ITypeNameConverter> tyConv, FSharpFunc`2<bool, FSharpFunc`2<AssemblyInfo, Assembly>> getAssembly, FSharpFunc`2<MethodInfo, string> getMethodSignature, bool enableAssemblyLoading, CompositeMemberInfo mI);
    internal static void generate@254(FSharpFunc`2<Type, CompositeMemberInfo> getInfo, StringBuilder sb, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string generateTypeSignature(FSharpFunc`2<Type, CompositeMemberInfo> getInfo, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string generateMethodSignature(FSharpFunc`2<Type, string> getTypeSig, MethodInfo m);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.ReflectionPicklers : object {
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.RootSerialization : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IPickleFormatWriter initStreamWriter(IPickleFormatProvider formatP, Stream stream, FSharpOption`1<Encoding> encoding, bool isSeq, FSharpOption`1<bool> leaveOpen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IPickleFormatReader initStreamReader(IPickleFormatProvider formatP, Stream stream, FSharpOption`1<Encoding> encoding, bool isSeq, FSharpOption`1<bool> leaveOpen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IPickleFormatWriter initTextWriter(ITextPickleFormatProvider formatP, TextWriter writer, bool isSeq, FSharpOption`1<bool> leaveOpen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IPickleFormatReader initTextReader(ITextPickleFormatProvider formatP, TextReader reader, bool isSeq, FSharpOption`1<bool> leaveOpen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static WriteState writeRootObject(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatWriter formatter, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<IObjectSifter> sifter, bool isHash, bool disableSubtypes, Pickler`1<T> pickler, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T readRootObject(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatReader formatter, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Tuple`2[]> sifted, bool disableSubtypes, bool disableAssemblyLoading, Pickler`1<T> pickler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static WriteState writeRootObjectUntyped(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatWriter formatter, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<IObjectSifter> sifter, bool isHash, bool disableSubtypes, Pickler pickler, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object readRootObjectUntyped(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatReader formatter, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<Tuple`2[]> sifted, bool disableSubtypes, bool disableAssemblyLoading, Pickler pickler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int writeTopLevelSequence(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatWriter formatter, FSharpOption`1<StreamingContext> streamingContext, bool isHash, bool disableSubtypes, Pickler`1<T> pickler, IEnumerable`1<T> values);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<T> readTopLevelSequence(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatReader formatter, FSharpOption`1<StreamingContext> streamingContext, bool disableSubtypes, bool disableAssemblyLoading, Pickler`1<T> pickler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int writeTopLevelSequenceUntyped(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatWriter formatter, FSharpOption`1<StreamingContext> streamingContext, bool isHash, bool disableSubtypes, Pickler pickler, IEnumerable values);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable readTopLevelSequenceUntyped(IPicklerResolver resolver, ReflectionCache reflectionCache, IPickleFormatReader formatter, FSharpOption`1<StreamingContext> streamingContext, bool disableSubtypes, bool disableAssemblyLoading, Pickler pickler);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.SeqPickler : object {
    internal static Pickler`1<IEnumerable`1<T>> Create(Pickler`1<T> ep);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.SequenceUtils : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string elemTag;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long objectCountResetThreshold;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void beginReadSequence(IPickleFormatReader formatter, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeBoundedSequence(Pickler`1<T> ep, int _arg1, WriteState w, string tag, IEnumerable`1<T> ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] readBoundedSequence(Pickler`1<T> ep, int count, ReadState r, string tag);
    internal static int write@80(bool enableReset, Pickler`1<T> ep, WriteState w, IPickleFormatWriter formatter, int i, FSharpList`1<T> ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int writeUnboundedSequence(bool enableReset, Pickler`1<T> ep, WriteState w, string tag, IEnumerable`1<T> ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<T> readUnboundedSequenceLazy(bool enableReset, Pickler`1<T> ep, ReadState r, string tag);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.ShallowObjectCopier`1 : object {
    internal static Action`2<T, T> copier;
    internal static int init@13-1;
    private static ShallowObjectCopier`1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Copy(T source, T target);
}
[SealedAttribute]
[DataContractAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.Sifted`1 : object {
    [DataMemberAttribute]
internal T value@236;
    [DataMemberAttribute]
internal Tuple`2[] siftedIndices@240;
    public int SiftCount { get; }
    internal T Value { get; }
    internal Tuple`2[] SiftedIndices { get; }
    internal Sifted`1(T value, Tuple`2[] siftedIndices);
    public int get_SiftCount();
    internal T get_Value();
    internal Tuple`2[] get_SiftedIndices();
    public virtual string ToString();
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.StructFieldPickler : object {
    internal static Pickler`1<T> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.TuplePickler : object {
    internal static Pickler`1<Tuple`1<T1>> Create(Pickler`1<T1> p1);
    internal static Pickler`1<Tuple`1<T1>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`2<T1, T2>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2);
    internal static Pickler`1<Tuple`2<T1, T2>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`3<T1, T2, T3>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3);
    internal static Pickler`1<Tuple`3<T1, T2, T3>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`4<T1, T2, T3, T4>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4);
    internal static Pickler`1<Tuple`4<T1, T2, T3, T4>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`5<T1, T2, T3, T4, T5>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5);
    internal static Pickler`1<Tuple`5<T1, T2, T3, T4, T5>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`6<T1, T2, T3, T4, T5, T6>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5, Pickler`1<T6> p6);
    internal static Pickler`1<Tuple`6<T1, T2, T3, T4, T5, T6>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`7<T1, T2, T3, T4, T5, T6, T7>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5, Pickler`1<T6> p6, Pickler`1<T7> p7);
    internal static Pickler`1<Tuple`7<T1, T2, T3, T4, T5, T6, T7>> Create(IPicklerResolver resolver);
    internal static Pickler`1<Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest>> Create(Pickler`1<T1> p1, Pickler`1<T2> p2, Pickler`1<T3> p3, Pickler`1<T4> p4, Pickler`1<T5> p5, Pickler`1<T6> p6, Pickler`1<T7> p7, Pickler`1<TRest> pr);
    internal static Pickler`1<Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest>> Create(IPicklerResolver resolver);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.TypeInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal AssemblyInfo AssemblyInfo@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public AssemblyInfo AssemblyInfo { get; }
    public TypeInfo(string name, AssemblyInfo assemblyInfo);
    public string get_Name();
    public AssemblyInfo get_AssemblyInfo();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TypeInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.TypeNameConverter : object {
    public static ITypeNameConverter compose(IEnumerable`1<ITypeNameConverter> converters);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.TypeShapeExtensions : object {
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.UnionCaseSerializationHelper : object {
    internal String[] caseNames;
    internal Dictionary`2<string, int> dict;
    public UnionCaseSerializationHelper(String[] caseNames);
    internal void WriteTag(IPickleFormatWriter formatter, int tag);
    internal int ReadTag(IPickleFormatReader formatter);
    internal static UnionCaseSerializationHelper OfUnionType();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void InvokeTagWriter(EnvItem`1<UnionCaseSerializationHelper> c, EnvItem`1<WriteState> w, EnvItem`1<int> tag, ILGenerator ilGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void InvokeTagReader(EnvItem`1<UnionCaseSerializationHelper> c, EnvItem`1<ReadState> r, ILGenerator ilGen);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.Utils : object {
    [CompilationMappingAttribute]
internal static bool isDotNet45OrNewer { get; }
    [CompilationMappingAttribute]
internal static bool runsOnMono { get; }
    [CompilationMappingAttribute]
internal static FieldInfo remoteStackTraceField { get; }
    [CompilationMappingAttribute]
internal static FieldInfo matchValue@43 { get; }
    internal static bool isNull(T t);
    internal static bool isNotNull(T t);
    internal static bool get_isDotNet45OrNewer();
    internal static bool get_runsOnMono();
    internal static HashSet`1<T> hset(IEnumerable`1<T> ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ignore2(a _arg2, b _arg1);
    internal static b reraise'(a e);
    internal static FieldInfo get_remoteStackTraceField();
    internal static FieldInfo get_matchValue@43();
    internal static FSharpOption`1<a> denull(a x);
    internal static T fastUnbox(object x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TValue> IDictionary`2.TryFind(IDictionary`2<TKey, TValue> d, TKey k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<Key, Value> Map`2.AddNoOverwrite(FSharpMap`2<Key, Value> m, Key key, Value value);
    internal static FSharpOption`1<Exception> |InnerExn|_|(a e);
    internal static FSharpFunc`2<T, S> memoize(FSharpFunc`2<T, S> f);
    internal static FSharpFunc`2<P, FSharpFunc`2<T, S>> memoizeParam(FSharpFunc`2<P, FSharpFunc`2<T, S>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SerializationInfo.Write(SerializationInfo sI, string name, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T SerializationInfo.Read(SerializationInfo sI, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] pickleBinary(FSharpFunc`2<Stream, FSharpFunc`2<T, Unit>> f, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T unpickleBinary(FSharpFunc`2<Stream, T> f, Byte[] pickle);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string pickleString(FSharpFunc`2<TextWriter, FSharpFunc`2<T, Unit>> f, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T unpickleString(FSharpFunc`2<TextReader, T> f, string pickle);
}
[CompilationMappingAttribute]
public enum MBrace.FsPickler.VisitOrder : Enum {
    public byte value__;
    public static VisitOrder PreOrder;
    public static VisitOrder PostOrder;
}
[AutoSerializableAttribute("False")]
[SealedAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.VisitState : object {
    internal IObjectVisitor visitor;
    internal IPicklerResolver resolver;
    internal StreamingContext sc;
    internal bool isCancelled;
    internal ObjectIDGenerator idGen;
    internal VisitOrder visitOrder@253;
    public StreamingContext StreamingContext { get; }
    internal VisitOrder VisitOrder { get; }
    internal IPicklerResolver PicklerResolver { get; }
    internal IObjectVisitor Visitor { get; }
    internal ObjectIDGenerator ObjectIDGenerator { get; }
    internal bool IsCancelled { get; internal set; }
    internal VisitState(IPicklerResolver resolver, IObjectVisitor visitor, FSharpOption`1<VisitOrder> visitOrder, FSharpOption`1<StreamingContext> streamingContext);
    public StreamingContext get_StreamingContext();
    internal VisitOrder get_VisitOrder();
    internal IPicklerResolver get_PicklerResolver();
    internal IObjectVisitor get_Visitor();
    internal ObjectIDGenerator get_ObjectIDGenerator();
    internal bool get_IsCancelled();
    internal void set_IsCancelled(bool s);
}
[CompilationMappingAttribute]
internal class MBrace.FsPickler.WrapPickler : object {
    internal static Pickler`1<S> Create(Pickler`1<T> origin, FSharpFunc`2<T, S> recover, FSharpFunc`2<S, T> convert);
}
[AutoSerializableAttribute("False")]
[SealedAttribute]
[CompilationMappingAttribute]
public class MBrace.FsPickler.WriteState : object {
    internal FSharpOption`1<IObjectSifter> sifter;
    internal IPicklerResolver resolver;
    internal ReflectionCache reflectionCache;
    internal bool isHashComputation;
    internal IPickleFormatWriter formatter;
    internal bool disableSubtypeResolution;
    internal Pickler`1<Type> tyPickler;
    internal StreamingContext sc;
    internal long currentId;
    internal ObjectIDGenerator idGen;
    internal Stack`1<long> objStack;
    internal HashSet`1<long> cyclicObjects;
    internal List`1<Tuple`2<long, object>> sifted;
    public bool IsHashComputation { get; }
    public StreamingContext StreamingContext { get; }
    public bool DisableSubtypeResolution { get; }
    internal IPicklerResolver PicklerResolver { get; }
    internal IPickleFormatWriter Formatter { get; }
    internal FSharpOption`1<IObjectSifter> Sifter { get; }
    internal List`1<Tuple`2<long, object>> Sifted { get; }
    internal ReflectionCache ReflectionCache { get; }
    internal Pickler`1<Type> TypePickler { get; }
    internal long ObjectCount { get; }
    internal Stack`1<long> ObjectStack { get; }
    internal HashSet`1<long> CyclicObjectSet { get; }
    internal WriteState(IPickleFormatWriter formatter, IPicklerResolver resolver, ReflectionCache reflectionCache, bool isHashComputation, bool disableSubtypeResolution, FSharpOption`1<StreamingContext> streamingContext, FSharpOption`1<IObjectSifter> sifter);
    public bool get_IsHashComputation();
    public StreamingContext get_StreamingContext();
    public bool get_DisableSubtypeResolution();
    internal IPicklerResolver get_PicklerResolver();
    internal IPickleFormatWriter get_Formatter();
    internal FSharpOption`1<IObjectSifter> get_Sifter();
    internal List`1<Tuple`2<long, object>> get_Sifted();
    internal ReflectionCache get_ReflectionCache();
    internal Pickler`1<Type> get_TypePickler();
    internal long GetObjectId(object obj, Boolean& firstTime);
    internal long get_ObjectCount();
    internal Stack`1<long> get_ObjectStack();
    internal HashSet`1<long> get_CyclicObjectSet();
    internal void Reset();
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.XmlPickleFormatProvider : object {
    internal bool Indent@;
    public bool Indent { get; public set; }
    public XmlPickleFormatProvider(bool indent);
    public bool get_Indent();
    public void set_Indent(bool v);
    private virtual override string MBrace-FsPickler-IPickleFormatProvider-get_Name();
    private virtual override Encoding MBrace-FsPickler-IPickleFormatProvider-get_DefaultEncoding();
    private virtual override IPickleFormatWriter MBrace-FsPickler-IPickleFormatProvider-CreateWriter(Stream stream, Encoding encoding, bool _arg1, bool leaveOpen);
    private virtual override IPickleFormatReader MBrace-FsPickler-IPickleFormatProvider-CreateReader(Stream stream, Encoding encoding, bool _arg2, bool leaveOpen);
    private virtual override IPickleFormatWriter MBrace-FsPickler-ITextPickleFormatProvider-CreateWriter(TextWriter textWriter, bool _arg3, bool leaveOpen);
    private virtual override IPickleFormatReader MBrace-FsPickler-ITextPickleFormatProvider-CreateReader(TextReader textReader, bool _arg4, bool leaveOpen);
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.XmlPickleReader : object {
    internal XmlReader reader;
    internal bool isAtEmptySequenceHeader;
    internal long cachedObjectId;
    internal XmlPickleReader(TextReader textReader, bool leaveOpen);
    private virtual override void MBrace-FsPickler-IPickleFormatReader-BeginReadRoot(string tag);
    private virtual override void MBrace-FsPickler-IPickleFormatReader-EndReadRoot();
    private virtual override ObjectFlags MBrace-FsPickler-IPickleFormatReader-BeginReadObject(string tag);
    private virtual override void MBrace-FsPickler-IPickleFormatReader-EndReadObject();
    private virtual override long MBrace-FsPickler-IPickleFormatReader-ReadCachedObjectId();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_SerializeUnionCaseNames();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_UseNamedEnumSerialization();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_PreferLengthPrefixInSequences();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-ReadNextSequenceElement();
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-ReadBoolean(string tag);
    private virtual override byte MBrace-FsPickler-IPickleFormatReader-ReadByte(string tag);
    private virtual override sbyte MBrace-FsPickler-IPickleFormatReader-ReadSByte(string tag);
    private virtual override short MBrace-FsPickler-IPickleFormatReader-ReadInt16(string tag);
    private virtual override int MBrace-FsPickler-IPickleFormatReader-ReadInt32(string tag);
    private virtual override long MBrace-FsPickler-IPickleFormatReader-ReadInt64(string tag);
    private virtual override ushort MBrace-FsPickler-IPickleFormatReader-ReadUInt16(string tag);
    private virtual override UInt32 MBrace-FsPickler-IPickleFormatReader-ReadUInt32(string tag);
    private virtual override ulong MBrace-FsPickler-IPickleFormatReader-ReadUInt64(string tag);
    private virtual override decimal MBrace-FsPickler-IPickleFormatReader-ReadDecimal(string tag);
    private virtual override float MBrace-FsPickler-IPickleFormatReader-ReadSingle(string tag);
    private virtual override double MBrace-FsPickler-IPickleFormatReader-ReadDouble(string tag);
    private virtual override char MBrace-FsPickler-IPickleFormatReader-ReadChar(string tag);
    private virtual override BigInteger MBrace-FsPickler-IPickleFormatReader-ReadBigInteger(string tag);
    private virtual override string MBrace-FsPickler-IPickleFormatReader-ReadString(string tag);
    private virtual override Guid MBrace-FsPickler-IPickleFormatReader-ReadGuid(string tag);
    private virtual override DateTime MBrace-FsPickler-IPickleFormatReader-ReadDateTime(string tag);
    private virtual override DateTimeOffset MBrace-FsPickler-IPickleFormatReader-ReadDateTimeOffset(string tag);
    private virtual override TimeSpan MBrace-FsPickler-IPickleFormatReader-ReadTimeSpan(string tag);
    private virtual override Byte[] MBrace-FsPickler-IPickleFormatReader-ReadBytes(string tag);
    private virtual override bool MBrace-FsPickler-IPickleFormatReader-get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatReader-ReadPrimitiveArray(string _arg2, Array _arg1);
    private virtual override void System-IDisposable-Dispose();
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.XmlPickleWriter : object {
    internal XmlWriter writer;
    internal XmlPickleWriter(TextWriter textWriter, bool indent, bool leaveOpen);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-Flush();
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-BeginWriteRoot(string tag);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-EndWriteRoot();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-BeginWriteObject(string tag, ObjectFlags flags);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-EndWriteObject();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_SerializeUnionCaseNames();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_UseNamedEnumSerialization();
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_PreferLengthPrefixInSequences();
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteNextSequenceElement(bool _arg1);
    private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteCachedObjectId(long id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBoolean(string tag, bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteByte(string tag, byte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteSByte(string tag, sbyte value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt16(string tag, short value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt32(string tag, int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteInt64(string tag, long value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt16(string tag, ushort value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt32(string tag, UInt32 value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteUInt64(string tag, ulong value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteSingle(string tag, float value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDouble(string tag, double value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDecimal(string tag, decimal value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteChar(string tag, char value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteString(string tag, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBigInteger(string tag, BigInteger value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteGuid(string tag, Guid value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDateTime(string tag, DateTime value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteDateTimeOffset(string tag, DateTimeOffset value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteTimeSpan(string tag, TimeSpan value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WriteBytes(string tag, Byte[] value);
    private virtual override bool MBrace-FsPickler-IPickleFormatWriter-get_IsPrimitiveArraySerializationSupported();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void MBrace-FsPickler-IPickleFormatWriter-WritePrimitiveArray(string _arg3, Array _arg2);
    private virtual override void System-IDisposable-Dispose();
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute]
public class MBrace.FsPickler.XmlSerializer : FsPicklerTextSerializer {
    internal XmlPickleFormatProvider format@;
    [CompilationMappingAttribute]
internal XmlPickleFormatProvider format { get; }
    public bool Indent { get; public set; }
    public XmlSerializer(FSharpOption`1<bool> indent, FSharpOption`1<ITypeNameConverter> typeConverter, FSharpOption`1<IPicklerResolver> picklerResolver);
    internal XmlPickleFormatProvider get_format();
    public bool get_Indent();
    public void set_Indent(bool b);
}
[CompilationMappingAttribute]
internal static class MBrace.FsPickler.XmlUtils : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Formatv0960;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Formatv1200;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Formatv1400;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Formatv2000;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Formatv4000;
    internal static string escapeString(string value);
    internal static string unEscapeString(string value);
    internal static string mkFlagCsv(ObjectFlags flags);
    internal static ObjectFlags parseFlagCsv(string csv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writePrimitive(XmlWriter w, string tag, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void XmlReader.MoveNext(XmlReader );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void XmlReader.SkipWhitespace(XmlReader );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void XmlReader.ReadElementName(XmlReader r, string tag);
}
[CompilationMappingAttribute]
internal static class TypeShape : object {
    internal static object Activator.CreateInstanceGeneric.Static(FSharpOption`1<Type[]> typeArgs, FSharpOption`1<Object[]> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Type.IsInterfaceAssignableFrom(Type iface, Type ty);
    internal static TypeShape`1<T> shapeof();
    internal static IShapeMember`1<Union> mkUnionField@1223(FieldInfo[] allFields, PropertyInfo p);
    [CompilerGeneratedAttribute]
internal static ShapeFSharpUnionCase`1<U> mapping@1(UnionCaseInfo uci);
    [CompilerGeneratedAttribute]
internal static IShapeMember`1<Poco> mapping@1-1(FieldInfo f);
}
