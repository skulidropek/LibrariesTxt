[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class GitVersion.Agents.BuildAgentBase : object {
    protected ILog Log;
    [CompilerGeneratedAttribute]
private IEnvironment <Environment>k__BackingField;
    protected IEnvironment Environment { get; }
    protected string EnvironmentVariable { get; }
    public bool IsDefault { get; }
    protected BuildAgentBase(IEnvironment environment, ILog log);
    [CompilerGeneratedAttribute]
protected IEnvironment get_Environment();
    protected abstract virtual string get_EnvironmentVariable();
    public virtual bool get_IsDefault();
    public abstract virtual string GenerateSetVersionMessage(GitVersionVariables variables);
    public abstract virtual String[] GenerateSetParameterMessage(string name, string value);
    public virtual bool CanApplyToCurrentContext();
    [NullableContextAttribute("2")]
public virtual string GetCurrentBranch(bool usingDynamicRepos);
    public virtual bool PreventFetch();
    public virtual bool ShouldCleanUpRemotes();
    public virtual void WriteIntegration(Action`1<string> writer, GitVersionVariables variables, bool updateBuildNumber);
    protected IEnumerable`1<string> GenerateBuildLogOutput(GitVersionVariables variables);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Agents.BuildAgentResolver : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IBuildAgent> <buildAgents>P;
    private ILog log;
    public BuildAgentResolver(IEnumerable`1<IBuildAgent> buildAgents, ILog log);
    public sealed virtual ICurrentBuildAgent Resolve();
    private ICurrentBuildAgent ResolveInternal();
}
[NullableContextAttribute("1")]
public interface GitVersion.Agents.IBuildAgent {
    public bool IsDefault { get; }
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool CanApplyToCurrentContext();
    [NullableContextAttribute("2")]
public abstract virtual string GetCurrentBranch(bool usingDynamicRepos);
    public abstract virtual bool PreventFetch();
    public abstract virtual bool ShouldCleanUpRemotes();
    public abstract virtual void WriteIntegration(Action`1<string> writer, GitVersionVariables variables, bool updateBuildNumber);
}
[NullableContextAttribute("1")]
internal interface GitVersion.Agents.IBuildAgentResolver {
    public abstract virtual ICurrentBuildAgent Resolve();
}
public interface GitVersion.Agents.ICurrentBuildAgent {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Agents.LocalBuild : BuildAgentBase {
    public bool IsDefault { get; }
    protected string EnvironmentVariable { get; }
    public LocalBuild(IEnvironment environment, ILog log);
    public virtual bool get_IsDefault();
    protected virtual string get_EnvironmentVariable();
    public virtual bool CanApplyToCurrentContext();
    public virtual string GenerateSetVersionMessage(GitVersionVariables variables);
    public virtual String[] GenerateSetParameterMessage(string name, string value);
}
public class GitVersion.AssemblySettingsInfo : object {
    public bool UpdateAssemblyInfo;
    public bool UpdateProjectFiles;
    public bool EnsureAssemblyInfo;
    [NullableAttribute("1")]
public ISet`1<string> Files;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.BranchesContainingCommitFinder : object {
    private ILog log;
    private IGitRepository repository;
    public BranchesContainingCommitFinder(IGitRepository repository, ILog log);
    public IEnumerable`1<IBranch> GetBranchesContainingCommit(ICommit commit, IEnumerable`1<IBranch> branches, bool onlyTrackedBranches);
    [IteratorStateMachineAttribute("GitVersion.BranchesContainingCommitFinder/<InnerGetBranchesContainingCommit>d__4")]
private IEnumerable`1<IBranch> InnerGetBranchesContainingCommit(IGitObject commit, IEnumerable`1<IBranch> branches, bool onlyTrackedBranches);
    private IEnumerable`1<ICommit> GetCommitsReacheableFrom(IGitObject commit, IBranch branch);
    private static bool IncludeTrackedBranches(IBranch branch, bool includeOnlyTracked);
    private static bool BranchTipIsNullOrCommit(IBranch branch, IGitObject commit);
}
public class GitVersion.BugException : Exception {
    [NullableContextAttribute("1")]
public BugException(string message);
    [NullableContextAttribute("2")]
public BugException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
public interface GitVersion.Common.IRepositoryStore {
    [NullableContextAttribute("2")]
public abstract virtual ICommit FindMergeBase(IBranch branch, IBranch otherBranch);
    public abstract virtual ICommit FindMergeBase(ICommit commit, ICommit mainlineTip);
    public abstract virtual ICommit GetCurrentCommit(IBranch currentBranch, string commitId, IIgnoreConfiguration ignore);
    public abstract virtual IReadOnlyList`1<ICommit> GetCommitLog(ICommit baseVersionSource, ICommit currentCommit, IIgnoreConfiguration ignore);
    public abstract virtual IBranch GetTargetBranch(string targetBranchName);
    public abstract virtual IBranch FindBranch(ReferenceName branchName);
    public abstract virtual IBranch FindBranch(string branchName);
    public abstract virtual IEnumerable`1<IBranch> ExcludingBranches(IEnumerable`1<IBranch> branchesToExclude);
    public abstract virtual IEnumerable`1<IBranch> GetBranchesContainingCommit(ICommit commit, IEnumerable`1<IBranch> branches, bool onlyTrackedBranches);
    public abstract virtual BranchCommit FindCommitBranchBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    public abstract virtual IEnumerable`1<BranchCommit> FindCommitBranchesBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    public abstract virtual IEnumerable`1<BranchCommit> FindCommitBranchesBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IEnumerable`1<IBranch> excludedBranches);
    public abstract virtual IEnumerable`1<IBranch> GetSourceBranches(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    public abstract virtual IEnumerable`1<IBranch> GetSourceBranches(IBranch branch, IGitVersionConfiguration configuration, IEnumerable`1<IBranch> excludedBranches);
    public abstract virtual bool IsCommitOnBranch(ICommit baseVersionSource, IBranch branch, ICommit firstMatchingCommit);
    public abstract virtual int GetNumberOfUncommittedChanges();
}
public enum GitVersion.Configuration.AssemblyFileVersioningScheme : Enum {
    public int value__;
    public static AssemblyFileVersioningScheme MajorMinorPatchTag;
    public static AssemblyFileVersioningScheme MajorMinorPatch;
    public static AssemblyFileVersioningScheme MajorMinor;
    public static AssemblyFileVersioningScheme Major;
    public static AssemblyFileVersioningScheme None;
}
public enum GitVersion.Configuration.AssemblyVersioningScheme : Enum {
    public int value__;
    public static AssemblyVersioningScheme MajorMinorPatchTag;
    public static AssemblyVersioningScheme MajorMinorPatch;
    public static AssemblyVersioningScheme MajorMinor;
    public static AssemblyVersioningScheme Major;
    public static AssemblyVersioningScheme None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class GitVersion.Configuration.ConfigurationConstants : object {
    internal static string NameOfDefaultAssemblyVersioningScheme;
    internal static string NameOfDefaultAssemblyFileVersioningScheme;
    internal static string StringDefaultSemanticVersionFormat;
    internal static string StringDefaultTagPreReleaseWeight;
    internal static string StringDefaultUpdateBuildNumber;
    public static AssemblyVersioningScheme DefaultAssemblyVersioningScheme;
    public static AssemblyFileVersioningScheme DefaultAssemblyFileVersioningScheme;
    public static SemanticVersionFormat DefaultSemanticVersionFormat;
    public static VersionStrategies[] DefaultVersionStrategies;
    public static string DefaultAssemblyInformationalFormat;
    public static string DefaultTagPrefix;
    public static string DefaultVersionInBranchPattern;
    public static string DefaultCommitDateFormat;
    public static string BranchNamePlaceholder;
    public static string DefaultLabelNumberPattern;
    public static bool DefaultUpdateBuildNumber;
    public static int DefaultTagPreReleaseWeight;
    public static string MainBranchKey;
    public static string MasterBranchKey;
    public static string DevelopBranchKey;
    public static string ReleaseBranchKey;
    public static string FeatureBranchKey;
    public static string PullRequestBranchKey;
    public static string HotfixBranchKey;
    public static string SupportBranchKey;
    public static string UnknownBranchKey;
    public static string MainBranchRegex;
    public static string DevelopBranchRegex;
    public static string ReleaseBranchRegex;
    public static string FeatureBranchRegex;
    public static string PullRequestBranchRegex;
    public static string HotfixBranchRegex;
    public static string SupportBranchRegex;
    public static string UnknownBranchRegex;
    private static ConfigurationConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class GitVersion.Configuration.ConfigurationExtensions : object {
    [ExtensionAttribute]
public static EffectiveBranchConfiguration GetEffectiveBranchConfiguration(IGitVersionConfiguration configuration, IBranch branch, EffectiveConfiguration parentConfiguration);
    [ExtensionAttribute]
public static EffectiveConfiguration GetEffectiveConfiguration(IGitVersionConfiguration configuration, ReferenceName branchName, EffectiveConfiguration parentConfiguration);
    [ExtensionAttribute]
public static IBranchConfiguration GetBranchConfiguration(IGitVersionConfiguration configuration, IBranch branch);
    [ExtensionAttribute]
public static IBranchConfiguration GetBranchConfiguration(IGitVersionConfiguration configuration, ReferenceName branchName);
    [IteratorStateMachineAttribute("GitVersion.Configuration.ConfigurationExtensions/<ToFilters>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<IVersionFilter> ToFilters(IIgnoreConfiguration source);
    [IteratorStateMachineAttribute("GitVersion.Configuration.ConfigurationExtensions/<GetBranchConfigurations>d__5")]
private static IEnumerable`1<IBranchConfiguration> GetBranchConfigurations(IGitVersionConfiguration configuration, string branchName);
    [ExtensionAttribute]
public static IBranchConfiguration GetFallbackBranchConfiguration(IGitVersionConfiguration configuration);
    [ExtensionAttribute]
public static bool IsReleaseBranch(IGitVersionConfiguration configuration, IBranch branch);
    [ExtensionAttribute]
public static bool IsReleaseBranch(IGitVersionConfiguration configuration, ReferenceName branchName);
    [ExtensionAttribute]
public static string GetBranchSpecificLabel(EffectiveConfiguration configuration, ReferenceName branchName, string branchNameOverride);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetBranchSpecificLabel(EffectiveConfiguration configuration, string branchName, string branchNameOverride);
    [ExtensionAttribute]
public static Nullable`1<ValueTuple`2<string, string>> FindGitDir(string path);
    private static string ReadGitDirFromFile(string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.Configuration.EffectiveBranchConfiguration : object {
    [CompilerGeneratedAttribute]
private IBranch <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private EffectiveConfiguration <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IBranch Branch { get; }
    public EffectiveConfiguration Value { get; }
    public EffectiveBranchConfiguration(EffectiveConfiguration Value, IBranch Branch);
    [CompilerGeneratedAttribute]
protected EffectiveBranchConfiguration(EffectiveBranchConfiguration original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IBranch get_Branch();
    [CompilerGeneratedAttribute]
public EffectiveConfiguration get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EffectiveBranchConfiguration left, EffectiveBranchConfiguration right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EffectiveBranchConfiguration left, EffectiveBranchConfiguration right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(EffectiveBranchConfiguration other);
    [CompilerGeneratedAttribute]
public virtual EffectiveBranchConfiguration <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(EffectiveConfiguration& Value, IBranch& Branch);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.Configuration.EffectiveConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <TracksReleaseBranches>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReleaseBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMainBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private DeploymentMode <DeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyVersioningScheme <AssemblyVersioningScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyFileVersioningScheme <AssemblyFileVersioningScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyInformationalFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersioningFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFileVersioningFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagPrefix>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Regex <VersionInBranchRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IncrementStrategy <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegularExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventIncrementOfMergedBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventIncrementWhenBranchMerged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventIncrementWhenCurrentCommitTagged>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LabelNumberPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackMergeTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackMergeMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MajorVersionBumpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinorVersionBumpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatchVersionBumpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoBumpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private CommitMessageIncrementMode <CommitMessageIncrementing>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<IVersionFilter> <VersionFilters>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IIgnoreConfiguration <Ignore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitDateFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateBuildNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersionFormat <SemanticVersionFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStrategies <VersionStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreReleaseWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TagPreReleaseWeight>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool TracksReleaseBranches { get; }
    public bool IsReleaseBranch { get; }
    public bool IsMainBranch { get; }
    public DeploymentMode DeploymentMode { get; }
    public AssemblyVersioningScheme AssemblyVersioningScheme { get; }
    public AssemblyFileVersioningScheme AssemblyFileVersioningScheme { get; }
    public string AssemblyInformationalFormat { get; }
    public string AssemblyVersioningFormat { get; }
    public string AssemblyFileVersioningFormat { get; }
    public string TagPrefix { get; }
    [NullableAttribute("1")]
public Regex VersionInBranchRegex { get; }
    public string Label { get; }
    public string NextVersion { get; }
    public IncrementStrategy Increment { get; }
    public string RegularExpression { get; }
    public bool PreventIncrementOfMergedBranch { get; }
    public bool PreventIncrementWhenBranchMerged { get; }
    public bool PreventIncrementWhenCurrentCommitTagged { get; }
    public string LabelNumberPattern { get; }
    public bool TrackMergeTarget { get; }
    public bool TrackMergeMessage { get; }
    public string MajorVersionBumpMessage { get; }
    public string MinorVersionBumpMessage { get; }
    public string PatchVersionBumpMessage { get; }
    public string NoBumpMessage { get; }
    public CommitMessageIncrementMode CommitMessageIncrementing { get; }
    [NullableAttribute("1")]
public IEnumerable`1<IVersionFilter> VersionFilters { get; }
    [NullableAttribute("1")]
public IIgnoreConfiguration Ignore { get; }
    public string CommitDateFormat { get; }
    public bool UpdateBuildNumber { get; }
    public SemanticVersionFormat SemanticVersionFormat { get; }
    public VersionStrategies VersionStrategy { get; }
    public int PreReleaseWeight { get; }
    public int TagPreReleaseWeight { get; }
    [NullableContextAttribute("1")]
public EffectiveConfiguration(IGitVersionConfiguration configuration, IBranchConfiguration branchConfiguration, EffectiveConfiguration fallbackConfiguration);
    [CompilerGeneratedAttribute]
protected EffectiveConfiguration(EffectiveConfiguration original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_TracksReleaseBranches();
    [CompilerGeneratedAttribute]
public bool get_IsReleaseBranch();
    [CompilerGeneratedAttribute]
public bool get_IsMainBranch();
    [CompilerGeneratedAttribute]
public DeploymentMode get_DeploymentMode();
    [CompilerGeneratedAttribute]
public AssemblyVersioningScheme get_AssemblyVersioningScheme();
    [CompilerGeneratedAttribute]
public AssemblyFileVersioningScheme get_AssemblyFileVersioningScheme();
    [CompilerGeneratedAttribute]
public string get_AssemblyInformationalFormat();
    [CompilerGeneratedAttribute]
public string get_AssemblyVersioningFormat();
    [CompilerGeneratedAttribute]
public string get_AssemblyFileVersioningFormat();
    [CompilerGeneratedAttribute]
public string get_TagPrefix();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Regex get_VersionInBranchRegex();
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public string get_NextVersion();
    [CompilerGeneratedAttribute]
public IncrementStrategy get_Increment();
    [CompilerGeneratedAttribute]
public string get_RegularExpression();
    [CompilerGeneratedAttribute]
public bool get_PreventIncrementOfMergedBranch();
    [CompilerGeneratedAttribute]
public bool get_PreventIncrementWhenBranchMerged();
    [CompilerGeneratedAttribute]
public bool get_PreventIncrementWhenCurrentCommitTagged();
    [CompilerGeneratedAttribute]
public string get_LabelNumberPattern();
    [CompilerGeneratedAttribute]
public bool get_TrackMergeTarget();
    [CompilerGeneratedAttribute]
public bool get_TrackMergeMessage();
    [CompilerGeneratedAttribute]
public string get_MajorVersionBumpMessage();
    [CompilerGeneratedAttribute]
public string get_MinorVersionBumpMessage();
    [CompilerGeneratedAttribute]
public string get_PatchVersionBumpMessage();
    [CompilerGeneratedAttribute]
public string get_NoBumpMessage();
    [CompilerGeneratedAttribute]
public CommitMessageIncrementMode get_CommitMessageIncrementing();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<IVersionFilter> get_VersionFilters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IIgnoreConfiguration get_Ignore();
    [CompilerGeneratedAttribute]
public string get_CommitDateFormat();
    [CompilerGeneratedAttribute]
public bool get_UpdateBuildNumber();
    [CompilerGeneratedAttribute]
public SemanticVersionFormat get_SemanticVersionFormat();
    [CompilerGeneratedAttribute]
public VersionStrategies get_VersionStrategy();
    [CompilerGeneratedAttribute]
public int get_PreReleaseWeight();
    [CompilerGeneratedAttribute]
public int get_TagPreReleaseWeight();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EffectiveConfiguration left, EffectiveConfiguration right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EffectiveConfiguration left, EffectiveConfiguration right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EffectiveConfiguration other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual EffectiveConfiguration <Clone>$();
}
[NullableContextAttribute("1")]
public interface GitVersion.Configuration.IBranchConfiguration {
    public Nullable`1<DeploymentMode> DeploymentMode { get; }
    [NullableAttribute("2")]
public string Label { get; }
    public IncrementStrategy Increment { get; }
    public IPreventIncrementConfiguration PreventIncrement { get; }
    [NullableAttribute("2")]
public string LabelNumberPattern { get; }
    public Nullable`1<bool> TrackMergeTarget { get; }
    public Nullable`1<bool> TrackMergeMessage { get; }
    public Nullable`1<CommitMessageIncrementMode> CommitMessageIncrementing { get; }
    [NullableAttribute("2")]
public string RegularExpression { get; }
    public IReadOnlyCollection`1<string> SourceBranches { get; }
    public IReadOnlyCollection`1<string> IsSourceBranchFor { get; }
    public Nullable`1<bool> TracksReleaseBranches { get; }
    public Nullable`1<bool> IsReleaseBranch { get; }
    public Nullable`1<bool> IsMainBranch { get; }
    public Nullable`1<int> PreReleaseWeight { get; }
    public abstract virtual Nullable`1<DeploymentMode> get_DeploymentMode();
    [NullableContextAttribute("2")]
public abstract virtual string get_Label();
    public abstract virtual IncrementStrategy get_Increment();
    public abstract virtual IPreventIncrementConfiguration get_PreventIncrement();
    [NullableContextAttribute("2")]
public abstract virtual string get_LabelNumberPattern();
    public abstract virtual Nullable`1<bool> get_TrackMergeTarget();
    public abstract virtual Nullable`1<bool> get_TrackMergeMessage();
    public abstract virtual Nullable`1<CommitMessageIncrementMode> get_CommitMessageIncrementing();
    [NullableContextAttribute("2")]
public abstract virtual string get_RegularExpression();
    public virtual bool IsMatch(string branchName);
    public abstract virtual IReadOnlyCollection`1<string> get_SourceBranches();
    public abstract virtual IReadOnlyCollection`1<string> get_IsSourceBranchFor();
    public abstract virtual Nullable`1<bool> get_TracksReleaseBranches();
    public abstract virtual Nullable`1<bool> get_IsReleaseBranch();
    public abstract virtual Nullable`1<bool> get_IsMainBranch();
    public abstract virtual Nullable`1<int> get_PreReleaseWeight();
    public abstract virtual IBranchConfiguration Inherit(IBranchConfiguration configuration);
    public abstract virtual IBranchConfiguration Inherit(EffectiveConfiguration configuration);
}
[NullableContextAttribute("1")]
public interface GitVersion.Configuration.IConfigurationBuilder {
    public abstract virtual void AddOverride(IReadOnlyDictionary`2<object, object> value);
    public abstract virtual IGitVersionConfiguration Build();
}
[NullableContextAttribute("2")]
public interface GitVersion.Configuration.IConfigurationFileLocator {
    public abstract virtual void Verify(string workingDirectory, string projectRootDirectory);
    public abstract virtual string GetConfigurationFile(string directory);
}
[NullableContextAttribute("1")]
public interface GitVersion.Configuration.IConfigurationProvider {
    public abstract virtual IGitVersionConfiguration Provide(IReadOnlyDictionary`2<object, object> overrideConfiguration);
}
[NullableContextAttribute("1")]
internal interface GitVersion.Configuration.IConfigurationSerializer {
    public abstract virtual T Deserialize(string input);
    public abstract virtual string Serialize(object graph);
    public abstract virtual IGitVersionConfiguration ReadConfiguration(string input);
}
[NullableContextAttribute("2")]
public interface GitVersion.Configuration.IGitVersionConfiguration {
    public string Workflow { get; }
    public Nullable`1<AssemblyVersioningScheme> AssemblyVersioningScheme { get; }
    public Nullable`1<AssemblyFileVersioningScheme> AssemblyFileVersioningScheme { get; }
    public string AssemblyInformationalFormat { get; }
    public string AssemblyVersioningFormat { get; }
    public string AssemblyFileVersioningFormat { get; }
    public string TagPrefix { get; }
    public string VersionInBranchPattern { get; }
    [NullableAttribute("1")]
public Regex VersionInBranchRegex { get; }
    public string NextVersion { get; }
    public string MajorVersionBumpMessage { get; }
    public string MinorVersionBumpMessage { get; }
    public string PatchVersionBumpMessage { get; }
    public string NoBumpMessage { get; }
    public Nullable`1<int> TagPreReleaseWeight { get; }
    public string CommitDateFormat { get; }
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, string> MergeMessageFormats { get; }
    public bool UpdateBuildNumber { get; }
    public SemanticVersionFormat SemanticVersionFormat { get; }
    public VersionStrategies VersionStrategy { get; }
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, IBranchConfiguration> Branches { get; }
    [NullableAttribute("1")]
public IIgnoreConfiguration Ignore { get; }
    public abstract virtual string get_Workflow();
    public abstract virtual Nullable`1<AssemblyVersioningScheme> get_AssemblyVersioningScheme();
    public abstract virtual Nullable`1<AssemblyFileVersioningScheme> get_AssemblyFileVersioningScheme();
    public abstract virtual string get_AssemblyInformationalFormat();
    public abstract virtual string get_AssemblyVersioningFormat();
    public abstract virtual string get_AssemblyFileVersioningFormat();
    public abstract virtual string get_TagPrefix();
    public abstract virtual string get_VersionInBranchPattern();
    [NullableContextAttribute("1")]
public abstract virtual Regex get_VersionInBranchRegex();
    public abstract virtual string get_NextVersion();
    public abstract virtual string get_MajorVersionBumpMessage();
    public abstract virtual string get_MinorVersionBumpMessage();
    public abstract virtual string get_PatchVersionBumpMessage();
    public abstract virtual string get_NoBumpMessage();
    public abstract virtual Nullable`1<int> get_TagPreReleaseWeight();
    public abstract virtual string get_CommitDateFormat();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyDictionary`2<string, string> get_MergeMessageFormats();
    public abstract virtual bool get_UpdateBuildNumber();
    public abstract virtual SemanticVersionFormat get_SemanticVersionFormat();
    public abstract virtual VersionStrategies get_VersionStrategy();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyDictionary`2<string, IBranchConfiguration> get_Branches();
    [NullableContextAttribute("1")]
public abstract virtual IIgnoreConfiguration get_Ignore();
    [NullableContextAttribute("1")]
public abstract virtual IBranchConfiguration GetEmptyBranchConfiguration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class GitVersion.Configuration.IgnoreConfigurationExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITag> Filter(IIgnoreConfiguration ignore, IEnumerable`1<ITag> source);
    [ExtensionAttribute]
public static IEnumerable`1<ICommit> Filter(IIgnoreConfiguration ignore, IEnumerable`1<ICommit> source);
    private static bool ShouldBeIgnored(ICommit commit, IIgnoreConfiguration ignore);
}
[NullableContextAttribute("1")]
public interface GitVersion.Configuration.IIgnoreConfiguration {
    public Nullable`1<DateTimeOffset> Before { get; }
    public IReadOnlySet`1<string> Shas { get; }
    public bool IsEmpty { get; }
    public abstract virtual Nullable`1<DateTimeOffset> get_Before();
    public abstract virtual IReadOnlySet`1<string> get_Shas();
    public virtual bool get_IsEmpty();
}
public interface GitVersion.Configuration.IPreventIncrementConfiguration {
    public Nullable`1<bool> OfMergedBranch { get; }
    public Nullable`1<bool> WhenBranchMerged { get; }
    public Nullable`1<bool> WhenCurrentCommitTagged { get; }
    public abstract virtual Nullable`1<bool> get_OfMergedBranch();
    public abstract virtual Nullable`1<bool> get_WhenBranchMerged();
    public abstract virtual Nullable`1<bool> get_WhenCurrentCommitTagged();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Configuration.ReferenceNameExtensions : object {
    [ExtensionAttribute]
public static bool TryGetSemanticVersion(ReferenceName source, ValueTuple`2& result, IGitVersionConfiguration configuration);
    [ExtensionAttribute]
public static bool TryGetSemanticVersion(ReferenceName source, ValueTuple`2& result, EffectiveConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.ConfigurationInfo : object {
    [NullableAttribute("2")]
public string ConfigurationFile;
    public bool ShowConfiguration;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<object, object> OverrideConfiguration;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected ConfigurationInfo(ConfigurationInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ConfigurationInfo left, ConfigurationInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ConfigurationInfo left, ConfigurationInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ConfigurationInfo other);
    [CompilerGeneratedAttribute]
public virtual ConfigurationInfo <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Core.BranchRepository : object {
    private IGitRepository gitRepository;
    public BranchRepository(IGitRepository gitRepository);
    public sealed virtual IEnumerable`1<IBranch> GetMainBranches(IGitVersionConfiguration configuration, IBranch[] excludeBranches);
    public sealed virtual IEnumerable`1<IBranch> GetReleaseBranches(IGitVersionConfiguration configuration, IBranch[] excludeBranches);
    [IteratorStateMachineAttribute("GitVersion.Core.BranchRepository/<GetBranches>d__4")]
private IEnumerable`1<IBranch> GetBranches(IGitVersionConfiguration configuration, HashSet`1<IBranch> excludeBranches, Func`2<IBranchConfiguration, bool> predicate);
}
[ExtensionAttribute]
internal static class GitVersion.Core.EffectiveConfigurationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TaggedSemanticVersions GetTaggedSemanticVersion(EffectiveConfiguration effectiveConfiguration);
}
[NullableContextAttribute("1")]
internal interface GitVersion.Core.IBranchRepository {
    public abstract virtual IEnumerable`1<IBranch> GetMainBranches(IGitVersionConfiguration configuration, IBranch[] excludeBranches);
    public abstract virtual IEnumerable`1<IBranch> GetReleaseBranches(IGitVersionConfiguration configuration, IBranch[] excludeBranches);
}
[NullableContextAttribute("1")]
internal interface GitVersion.Core.ITaggedSemanticVersionRepository {
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfBranch(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMergeTarget(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersions(string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
}
[NullableContextAttribute("1")]
internal interface GitVersion.Core.ITaggedSemanticVersionService {
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersions(IBranch branch, IGitVersionConfiguration configuration, string label, Nullable`1<DateTimeOffset> notOlderThan, TaggedSemanticVersions taggedSemanticVersion);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfBranch(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMergeTarget(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMainBranches(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
    public abstract virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfReleaseBranches(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Core.TaggedSemanticVersionRepository : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`3<IBranch, string, SemanticVersionFormat>, IReadOnlyList`1<SemanticVersionWithTag>> taggedSemanticVersionsOfBranchCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`3<IBranch, string, SemanticVersionFormat>, IReadOnlyList`1<ValueTuple`2<ICommit, SemanticVersionWithTag>>> taggedSemanticVersionsOfMergeTargetCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<string, SemanticVersionFormat>, IReadOnlyList`1<SemanticVersionWithTag>> taggedSemanticVersionsCache;
    private ILog log;
    private IGitRepository gitRepository;
    public TaggedSemanticVersionRepository(ILog log, IGitRepository gitRepository);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfBranch(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMergeTarget(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersions(string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore);
}
[FlagsAttribute]
internal enum GitVersion.Core.TaggedSemanticVersions : Enum {
    public int value__;
    public static TaggedSemanticVersions None;
    public static TaggedSemanticVersions OfBranch;
    public static TaggedSemanticVersions OfMergeTargets;
    public static TaggedSemanticVersions OfMainBranches;
    public static TaggedSemanticVersions OfReleaseBranches;
    public static TaggedSemanticVersions All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Core.TaggedSemanticVersionService : object {
    [CompilerGeneratedAttribute]
private ITaggedSemanticVersionRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IBranchRepository <BranchRepository>k__BackingField;
    private ITaggedSemanticVersionRepository Repository { get; }
    private IBranchRepository BranchRepository { get; }
    public TaggedSemanticVersionService(ITaggedSemanticVersionRepository Repository, IBranchRepository BranchRepository);
    [CompilerGeneratedAttribute]
private ITaggedSemanticVersionRepository get_Repository();
    [CompilerGeneratedAttribute]
private IBranchRepository get_BranchRepository();
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersions(IBranch branch, IGitVersionConfiguration configuration, string label, Nullable`1<DateTimeOffset> notOlderThan, TaggedSemanticVersions taggedSemanticVersion);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfBranch(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    [IteratorStateMachineAttribute("GitVersion.Core.TaggedSemanticVersionService/<GetTaggedSemanticVersionsOfBranchInternal>d__9")]
private IEnumerable`1<KeyValuePair`2<ICommit, SemanticVersionWithTag>> GetTaggedSemanticVersionsOfBranchInternal(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMergeTarget(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    [IteratorStateMachineAttribute("GitVersion.Core.TaggedSemanticVersionService/<GetTaggedSemanticVersionsOfMergeTargetInternal>d__11")]
private IEnumerable`1<KeyValuePair`2<ICommit, SemanticVersionWithTag>> GetTaggedSemanticVersionsOfMergeTargetInternal(IBranch branch, string tagPrefix, SemanticVersionFormat format, IIgnoreConfiguration ignore, string label, Nullable`1<DateTimeOffset> notOlderThan);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfMainBranches(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
    [IteratorStateMachineAttribute("GitVersion.Core.TaggedSemanticVersionService/<GetTaggedSemanticVersionsOfMainBranchesInternal>d__13")]
private IEnumerable`1<KeyValuePair`2<ICommit, SemanticVersionWithTag>> GetTaggedSemanticVersionsOfMainBranchesInternal(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
    public sealed virtual ILookup`2<ICommit, SemanticVersionWithTag> GetTaggedSemanticVersionsOfReleaseBranches(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
    [IteratorStateMachineAttribute("GitVersion.Core.TaggedSemanticVersionService/<GetTaggedSemanticVersionsOfReleaseBranchesInternal>d__15")]
private IEnumerable`1<KeyValuePair`2<ICommit, SemanticVersionWithTag>> GetTaggedSemanticVersionsOfReleaseBranchesInternal(IGitVersionConfiguration configuration, Nullable`1<DateTimeOffset> notOlderThan, string label, IBranch[] excludeBranches);
}
internal class GitVersion.Environment : object {
    [NullableContextAttribute("1")]
public sealed virtual string GetEnvironmentVariable(string variableName);
    [NullableContextAttribute("1")]
public sealed virtual void SetEnvironmentVariable(string variableName, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.AssemblyVersionsGeneratorExtensions : object {
    [ExtensionAttribute]
public static string GetAssemblyVersion(SemanticVersion sv, AssemblyVersioningScheme scheme);
    [ExtensionAttribute]
public static string GetAssemblyFileVersion(SemanticVersion sv, AssemblyFileVersioningScheme scheme);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.CommonExtensions : object {
    [ExtensionAttribute]
public static T NotNull(T value, string name);
    [ExtensionAttribute]
public static string NotNullOrEmpty(string value, string name);
    [ExtensionAttribute]
public static string NotNullOrWhitespace(string value, string name);
}
[ExtensionAttribute]
public static class GitVersion.Extensions.DictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dict, TKey key, Func`1<TValue> getValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.EnumerableExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T OnlyOrDefault(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T SingleOfType(IEnumerable source);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> source, IEnumerable`1<T> items);
}
public static class GitVersion.Extensions.GitExtensions : object {
    public static void DumpGraphLog(Action`1<string> writer, Nullable`1<int> maxCommits);
    [NullableContextAttribute("1")]
public static string CreateGitLogArgs(Nullable`1<int> maxCommits);
}
[ExtensionAttribute]
public static class GitVersion.Extensions.IncrementStrategyExtensions : object {
    [ExtensionAttribute]
public static VersionField ToVersionField(IncrementStrategy strategy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.ReadEmbeddedResourceExtensions : object {
    [ExtensionAttribute]
public static string ReadAsStringFromEmbeddedResource(string resourceName);
    [ExtensionAttribute]
public static string ReadAsStringFromEmbeddedResource(string resourceName, Assembly assembly);
    [ExtensionAttribute]
private static Stream ReadFromEmbeddedResource(string resourceName, Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddModule(IServiceCollection serviceCollection, IGitVersionModule gitVersionModule);
    [ExtensionAttribute]
public static TService GetServiceForType(IServiceProvider serviceProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static void AppendLineFormat(StringBuilder stringBuilder, string format, Object[] args);
    [ExtensionAttribute]
public static string RegexReplace(string input, string pattern, string replace, RegexOptions options);
    [ExtensionAttribute]
public static bool IsEquivalentTo(string self, string other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmpty(string value);
    [ExtensionAttribute]
public static string WithPrefixIfNotNullOrEmpty(string value, string prefix);
}
[ExtensionAttribute]
internal static class GitVersion.Extensions.VersionFieldExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static VersionField Consolidate(VersionField source, Nullable`1<VersionField> item, Nullable`1[] items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.FileSystem : object {
    public sealed virtual void Copy(string from, string to, bool overwrite);
    public sealed virtual void Move(string from, string to);
    public sealed virtual bool Exists(string file);
    public sealed virtual void Delete(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual void WriteAllText(string file, string fileContents);
    public sealed virtual void WriteAllText(string file, string fileContents, Encoding encoding);
    public sealed virtual IEnumerable`1<string> DirectoryEnumerateFiles(string directory, string searchPattern, SearchOption searchOption);
    public sealed virtual Stream OpenWrite(string path);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual void CreateDirectory(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual long GetLastDirectoryWrite(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.FileWriteInfo : object {
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string WorkingDirectory { get; public set; }
    public string FileName { get; public set; }
    public string FileExtension { get; public set; }
    public FileWriteInfo(string WorkingDirectory, string FileName, string FileExtension);
    [CompilerGeneratedAttribute]
private FileWriteInfo(FileWriteInfo original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_FileExtension();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileExtension(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FileWriteInfo left, FileWriteInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FileWriteInfo left, FileWriteInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileWriteInfo other);
    [CompilerGeneratedAttribute]
public FileWriteInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& WorkingDirectory, String& FileName, String& FileExtension);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.Git.AuthenticationInfo : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Token { get; public set; }
    [CompilerGeneratedAttribute]
protected AuthenticationInfo(AuthenticationInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AuthenticationInfo left, AuthenticationInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AuthenticationInfo left, AuthenticationInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(AuthenticationInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual AuthenticationInfo <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Branch} {Commit}")]
public class GitVersion.Git.BranchCommit : ValueType {
    public static BranchCommit Empty;
    [CompilerGeneratedAttribute]
private IBranch <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommit <Commit>k__BackingField;
    public IBranch Branch { get; }
    public ICommit Commit { get; }
    public BranchCommit(ICommit commit, IBranch branch);
    private static BranchCommit();
    [CompilerGeneratedAttribute]
public IBranch get_Branch();
    [CompilerGeneratedAttribute]
public ICommit get_Commit();
    public sealed virtual bool Equals(Nullable`1<BranchCommit> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BranchCommit left, BranchCommit right);
    public static bool op_Inequality(BranchCommit left, BranchCommit right);
}
[ExtensionAttribute]
public static class GitVersion.Git.CommitExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsMergeCommit(ICommit source);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.Git.CommitFilter : object {
    [CompilerGeneratedAttribute]
private bool <FirstParentOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private object <IncludeReachableFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExcludeReachableFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private CommitSortStrategies <SortBy>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool FirstParentOnly { get; public set; }
    public object IncludeReachableFrom { get; public set; }
    public object ExcludeReachableFrom { get; public set; }
    public CommitSortStrategies SortBy { get; public set; }
    [CompilerGeneratedAttribute]
protected CommitFilter(CommitFilter original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_FirstParentOnly();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FirstParentOnly(bool value);
    [CompilerGeneratedAttribute]
public object get_IncludeReachableFrom();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeReachableFrom(object value);
    [CompilerGeneratedAttribute]
public object get_ExcludeReachableFrom();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExcludeReachableFrom(object value);
    [CompilerGeneratedAttribute]
public CommitSortStrategies get_SortBy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SortBy(CommitSortStrategies value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CommitFilter left, CommitFilter right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CommitFilter left, CommitFilter right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(CommitFilter other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual CommitFilter <Clone>$();
}
[FlagsAttribute]
public enum GitVersion.Git.CommitSortStrategies : Enum {
    public int value__;
    public static CommitSortStrategies None;
    public static CommitSortStrategies Topological;
    public static CommitSortStrategies Time;
    public static CommitSortStrategies Reverse;
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IBranch {
    [NullableAttribute("2")]
public ICommit Tip { get; }
    public bool IsRemote { get; }
    public bool IsTracking { get; }
    public bool IsDetachedHead { get; }
    public ICommitCollection Commits { get; }
    [NullableContextAttribute("2")]
public abstract virtual ICommit get_Tip();
    public abstract virtual bool get_IsRemote();
    public abstract virtual bool get_IsTracking();
    public abstract virtual bool get_IsDetachedHead();
    public abstract virtual ICommitCollection get_Commits();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface GitVersion.Git.IBranchCollection {
    [NullableAttribute("2")]
public IBranch Item { get; }
    public abstract virtual IBranch get_Item(string name);
    public abstract virtual IEnumerable`1<IBranch> ExcludeBranches(IEnumerable`1<IBranch> branchesToExclude);
    public abstract virtual void UpdateTrackedBranch(IBranch branch, string remoteTrackingReferenceName);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.ICommit {
    public IReadOnlyList`1<ICommit> Parents { get; }
    public DateTimeOffset When { get; }
    public string Message { get; }
    public abstract virtual IReadOnlyList`1<ICommit> get_Parents();
    public abstract virtual DateTimeOffset get_When();
    public abstract virtual string get_Message();
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.ICommitCollection {
    public abstract virtual IEnumerable`1<ICommit> GetCommitsPriorTo(DateTimeOffset olderThan);
    public abstract virtual IEnumerable`1<ICommit> QueryBy(CommitFilter commitFilter);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IGitObject {
    public IObjectId Id { get; }
    public string Sha { get; }
    public abstract virtual IObjectId get_Id();
    public abstract virtual string get_Sha();
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IGitRepository {
    public string Path { get; }
    public string WorkingDirectory { get; }
    public bool IsHeadDetached { get; }
    public bool IsShallow { get; }
    public IBranch Head { get; }
    public ITagCollection Tags { get; }
    public IReferenceCollection Refs { get; }
    public IBranchCollection Branches { get; }
    public ICommitCollection Commits { get; }
    public IRemoteCollection Remotes { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_WorkingDirectory();
    public abstract virtual bool get_IsHeadDetached();
    public abstract virtual bool get_IsShallow();
    public abstract virtual IBranch get_Head();
    public abstract virtual ITagCollection get_Tags();
    public abstract virtual IReferenceCollection get_Refs();
    public abstract virtual IBranchCollection get_Branches();
    public abstract virtual ICommitCollection get_Commits();
    public abstract virtual IRemoteCollection get_Remotes();
    public abstract virtual ICommit FindMergeBase(ICommit commit, ICommit otherCommit);
    public abstract virtual int GetNumberOfUncommittedChanges();
    [NullableContextAttribute("2")]
public abstract virtual void DiscoverRepository(string gitDirectory);
}
[NullableContextAttribute("2")]
public interface GitVersion.Git.IGitRepositoryInfo {
    public string DotGitDirectory { get; }
    public string ProjectRootDirectory { get; }
    public string DynamicGitRepositoryPath { get; }
    public string GitRootPath { get; }
    public abstract virtual string get_DotGitDirectory();
    public abstract virtual string get_ProjectRootDirectory();
    public abstract virtual string get_DynamicGitRepositoryPath();
    public abstract virtual string get_GitRootPath();
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IMutatingGitRepository {
    public abstract virtual void CreateBranchForPullRequestBranch(AuthenticationInfo auth);
    public abstract virtual void Checkout(string commitOrBranchSpec);
    public abstract virtual void Fetch(string remote, IEnumerable`1<string> refSpecs, AuthenticationInfo auth, string logMessage);
    [NullableContextAttribute("2")]
public abstract virtual void Clone(string sourceUrl, string workdirPath, AuthenticationInfo auth);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.INamedReference {
    public ReferenceName Name { get; }
    public abstract virtual ReferenceName get_Name();
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IObjectId {
    public string Sha { get; }
    public abstract virtual string get_Sha();
    public abstract virtual string ToString(int prefixLength);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IReference {
    public string TargetIdentifier { get; }
    [NullableAttribute("2")]
public IObjectId ReferenceTargetId { get; }
    public abstract virtual string get_TargetIdentifier();
    [NullableContextAttribute("2")]
public abstract virtual IObjectId get_ReferenceTargetId();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface GitVersion.Git.IReferenceCollection {
    [NullableAttribute("2")]
public IReference Head { get; }
    [NullableAttribute("2")]
public IReference Item { get; }
    [NullableAttribute("2")]
public IReference Item { get; }
    [NullableContextAttribute("2")]
public abstract virtual IReference get_Head();
    public abstract virtual IReference get_Item(string name);
    public abstract virtual IReference get_Item(ReferenceName referenceName);
    public abstract virtual void Add(string name, string canonicalRefNameOrObject, bool allowOverwrite);
    public abstract virtual void UpdateTarget(IReference directRef, IObjectId targetId);
    public abstract virtual IEnumerable`1<IReference> FromGlob(string prefix);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IRefSpec {
    public string Specification { get; }
    public RefSpecDirection Direction { get; }
    public string Source { get; }
    public string Destination { get; }
    public abstract virtual string get_Specification();
    public abstract virtual RefSpecDirection get_Direction();
    public abstract virtual string get_Source();
    public abstract virtual string get_Destination();
}
public interface GitVersion.Git.IRefSpecCollection {
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.IRemote {
    public string Name { get; }
    public string Url { get; }
    public IEnumerable`1<IRefSpec> RefSpecs { get; }
    public IEnumerable`1<IRefSpec> FetchRefSpecs { get; }
    public IEnumerable`1<IRefSpec> PushRefSpecs { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Url();
    public abstract virtual IEnumerable`1<IRefSpec> get_RefSpecs();
    public abstract virtual IEnumerable`1<IRefSpec> get_FetchRefSpecs();
    public abstract virtual IEnumerable`1<IRefSpec> get_PushRefSpecs();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface GitVersion.Git.IRemoteCollection {
    [NullableAttribute("2")]
public IRemote Item { get; }
    public abstract virtual IRemote get_Item(string name);
    public abstract virtual void Remove(string remoteName);
    public abstract virtual void Update(string remoteName, string refSpec);
}
[NullableContextAttribute("1")]
public interface GitVersion.Git.ITag {
    public string TargetSha { get; }
    public ICommit Commit { get; }
    public abstract virtual string get_TargetSha();
    public abstract virtual ICommit get_Commit();
}
public interface GitVersion.Git.ITagCollection {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.Git.ReferenceName : object {
    private static LambdaEqualityHelper`1<ReferenceName> equalityHelper;
    private static LambdaKeyComparer`2<ReferenceName, string> comparerHelper;
    public static string LocalBranchPrefix;
    public static string RemoteTrackingBranchPrefix;
    private static string TagPrefix;
    private static string OriginPrefix;
    private static String[] PullRequestPrefixes;
    [CompilerGeneratedAttribute]
private string <Canonical>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Friendly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WithoutOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocalBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemoteBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPullRequest>k__BackingField;
    public string Canonical { get; }
    public string Friendly { get; }
    public string WithoutOrigin { get; }
    public bool IsLocalBranch { get; }
    public bool IsRemoteBranch { get; }
    public bool IsTag { get; }
    public bool IsPullRequest { get; }
    public ReferenceName(string canonical);
    private static ReferenceName();
    public static ReferenceName Parse(string canonicalName);
    public static bool TryParse(ReferenceName& value, string canonicalName);
    public static ReferenceName FromBranchName(string branchName);
    [CompilerGeneratedAttribute]
public string get_Canonical();
    [CompilerGeneratedAttribute]
public string get_Friendly();
    [CompilerGeneratedAttribute]
public string get_WithoutOrigin();
    [CompilerGeneratedAttribute]
public bool get_IsLocalBranch();
    [CompilerGeneratedAttribute]
public bool get_IsRemoteBranch();
    [CompilerGeneratedAttribute]
public bool get_IsTag();
    [CompilerGeneratedAttribute]
public bool get_IsPullRequest();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ReferenceName other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(ReferenceName other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(ReferenceName left, ReferenceName right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ReferenceName left, ReferenceName right);
    public bool TryGetSemanticVersion(ValueTuple`2& result, Regex versionPatternRegex, string tagPrefix, SemanticVersionFormat format);
    private char GetBranchSeparator();
    [NullableContextAttribute("2")]
public bool EquivalentTo(string name);
    private string Shorten();
    private string RemoveOrigin();
    private static bool IsPrefixedBy(string input, string prefix);
    private static bool IsPrefixedBy(string input, String[] prefixes);
}
public enum GitVersion.Git.RefSpecDirection : Enum {
    public int value__;
    public static RefSpecDirection Fetch;
    public static RefSpecDirection Push;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.GitPreparer : object {
    private ILog log;
    private IEnvironment environment;
    private IMutatingGitRepository repository;
    private IOptions`1<GitVersionOptions> options;
    private IGitRepositoryInfo repositoryInfo;
    private ICurrentBuildAgent buildAgent;
    private RetryAction`1<LockedFileException> retryAction;
    private Lazy`1<GitVersionContext> versionContext;
    private static string DefaultRemoteName;
    public GitPreparer(ILog log, IEnvironment environment, ICurrentBuildAgent buildAgent, IOptions`1<GitVersionOptions> options, IMutatingGitRepository repository, IGitRepositoryInfo repositoryInfo, Lazy`1<GitVersionContext> versionContext);
    public sealed virtual void Prepare();
    private void PrepareInternal(GitVersionOptions gitVersionOptions);
    [NullableContextAttribute("2")]
private string ResolveCurrentBranch();
    private void CleanupDuplicateOrigin();
    [NullableContextAttribute("2")]
private void CreateDynamicRepository(string targetBranch);
    [NullableContextAttribute("2")]
private void NormalizeGitDirectory(string targetBranch, bool isDynamicRepository);
    [NullableContextAttribute("2")]
private void CloneRepository(string repositoryUrl, string gitDirectory, AuthenticationInfo auth);
    [NullableContextAttribute("2")]
private void NormalizeGitDirectory(bool noFetch, string currentBranchName, bool isDynamicRepository);
    private void EnsureRepositoryHeadDuringNormalisation(string occasion, string expectedSha);
    private void EnsureHeadIsAttachedToBranch(string currentBranchName, AuthenticationInfo authentication);
    private void ChooseLocalBranchToAttach(string headSha, IReadOnlyCollection`1<IBranch> localBranches);
    private void FetchRemotesIfRequired(IRemote remote, bool noFetch, AuthenticationInfo authentication);
    private IRemote EnsureOnlyOneRemoteIsDefined();
    private void CreateOrUpdateLocalBranchesFromRemoteTrackingOnes(string remoteName);
    public sealed virtual void EnsureLocalBranchExistsForCurrentBranch(IRemote remote, string currentBranch);
    private void Checkout(string commitOrBranchSpec);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.GitVersionCalculateTool : object {
    private ILog log;
    private IGitVersionCacheProvider gitVersionCacheProvider;
    private INextVersionCalculator nextVersionCalculator;
    private IVariableProvider variableProvider;
    private IGitPreparer gitPreparer;
    private IOptions`1<GitVersionOptions> options;
    private Lazy`1<GitVersionContext> versionContext;
    private GitVersionContext Context { get; }
    public GitVersionCalculateTool(ILog log, INextVersionCalculator nextVersionCalculator, IVariableProvider variableProvider, IGitPreparer gitPreparer, IGitVersionCacheProvider gitVersionCacheProvider, IOptions`1<GitVersionOptions> options, Lazy`1<GitVersionContext> versionContext);
    private GitVersionContext get_Context();
    public sealed virtual GitVersionVariables CalculateVersionVariables();
}
public class GitVersion.GitVersionCommonModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void RegisterTypes(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.GitVersionContext : object {
    [CompilerGeneratedAttribute]
private IGitVersionConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IBranch <CurrentBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommit <CurrentCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCurrentCommitTagged>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfUncommittedChanges>k__BackingField;
    public IGitVersionConfiguration Configuration { get; }
    public IBranch CurrentBranch { get; }
    public IEnumerable`1<ICommit> CurrentBranchCommits { get; }
    public ICommit CurrentCommit { get; }
    public bool IsCurrentCommitTagged { get; }
    public int NumberOfUncommittedChanges { get; }
    public GitVersionContext(IBranch currentBranch, ICommit currentCommit, IGitVersionConfiguration configuration, bool isCurrentCommitTagged, int numberOfUncommittedChanges);
    [CompilerGeneratedAttribute]
public IGitVersionConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public IBranch get_CurrentBranch();
    public IEnumerable`1<ICommit> get_CurrentBranchCommits();
    [CompilerGeneratedAttribute]
public ICommit get_CurrentCommit();
    [CompilerGeneratedAttribute]
public bool get_IsCurrentCommitTagged();
    [CompilerGeneratedAttribute]
public int get_NumberOfUncommittedChanges();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.GitVersionContextFactory : object {
    private IConfigurationProvider configurationProvider;
    private IRepositoryStore repositoryStore;
    private ITaggedSemanticVersionRepository taggedSemanticVersionRepository;
    private IOptions`1<GitVersionOptions> options;
    public GitVersionContextFactory(IConfigurationProvider configurationProvider, IRepositoryStore repositoryStore, ITaggedSemanticVersionRepository taggedSemanticVersionRepository, IOptions`1<GitVersionOptions> options);
    public sealed virtual GitVersionContext Create(GitVersionOptions gitVersionOptions);
}
public class GitVersion.GitVersionCoreModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void RegisterTypes(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.GitVersionException : Exception {
    public GitVersionException(string message);
    public GitVersionException(string message, Exception innerException);
    public GitVersionException(string messageFormat, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.GitVersionOptions : object {
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblySettingsInfo <AssemblySettingsInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationInfo <AuthenticationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationInfo <ConfigurationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryInfo <RepositoryInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private WixInfo <WixInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    public bool Diag;
    public bool IsVersion;
    public bool IsHelp;
    [NullableAttribute("2")]
public string LogFilePath;
    [NullableAttribute("2")]
public string ShowVariable;
    [NullableAttribute("2")]
public string Format;
    [NullableAttribute("2")]
public string OutputFile;
    public ISet`1<OutputType> Output;
    public Verbosity Verbosity;
    public string WorkingDirectory { get; public set; }
    public AssemblySettingsInfo AssemblySettingsInfo { get; }
    public AuthenticationInfo AuthenticationInfo { get; }
    public ConfigurationInfo ConfigurationInfo { get; }
    public RepositoryInfo RepositoryInfo { get; }
    public WixInfo WixInfo { get; }
    public Settings Settings { get; }
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public AssemblySettingsInfo get_AssemblySettingsInfo();
    [CompilerGeneratedAttribute]
public AuthenticationInfo get_AuthenticationInfo();
    [CompilerGeneratedAttribute]
public ConfigurationInfo get_ConfigurationInfo();
    [CompilerGeneratedAttribute]
public RepositoryInfo get_RepositoryInfo();
    [CompilerGeneratedAttribute]
public WixInfo get_WixInfo();
    [CompilerGeneratedAttribute]
public Settings get_Settings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class GitVersion.Helpers.Disposable : object {
    public static IDisposable Empty;
    private static Disposable();
    public static IDisposable Create(Action disposer);
    public static IDisposable`1<T> Create(T value, Action disposer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class GitVersion.Helpers.EncodingHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IList`1<Encoding> encodingsWithPreambles;
    private static int maxPreambleLength;
    [NullableContextAttribute("2")]
public static Encoding DetectEncoding(string filename);
    public static Encoding DetectEncoding(IList`1<byte> bytes);
    private static void ScanEncodings();
    private static bool PreambleMatches(Encoding encoding, IList`1<byte> data);
}
[NullableContextAttribute("1")]
public interface GitVersion.Helpers.IDisposable`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.Helpers.LambdaEqualityHelper`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2[] <equalityContributorAccessors>P;
    public LambdaEqualityHelper`1(Func`2[] equalityContributorAccessors);
    public bool Equals(T instance, T other);
    [NullableContextAttribute("1")]
public int GetHashCode(T instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class GitVersion.Helpers.LambdaKeyComparer`2 : Comparer`1<TSource> {
    [CompilerGeneratedAttribute]
private Func`2<TSource, TKey> <keySelector>P;
    private IComparer`1<TKey> innerComparer;
    public LambdaKeyComparer`2(Func`2<TSource, TKey> keySelector, IComparer`1<TKey> innerComparer);
    [NullableContextAttribute("2")]
public virtual int Compare(TSource x, TSource y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class GitVersion.Helpers.PathHelper : object {
    private static StringComparison OsDependentComparison;
    public static string NewLine { get; }
    private static PathHelper();
    public static string get_NewLine();
    public static string GetCurrentDirectory();
    public static string GetTempPath();
    public static string GetRepositoryTempPath();
    public static string GetFullPath(string path);
    [NullableContextAttribute("2")]
public static string Combine(string path1, string path2);
    public static string Combine(string path1);
    [NullableContextAttribute("2")]
public static string Combine(string path1, string path2, string path3);
    [NullableContextAttribute("2")]
public static string Combine(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("2")]
public static bool Equal(string path, string otherPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class GitVersion.Helpers.RetryAction`1 : RetryAction`2<T, bool> {
    public RetryAction`1(int maxRetries);
    public void Execute(Action operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.Helpers.RetryAction`2 : object {
    private RetryPolicy`1<Result> retryPolicy;
    public RetryAction`2(int maxRetries);
    public Result Execute(Func`1<Result> operation);
    private static IEnumerable`1<TimeSpan> LinearBackoff(TimeSpan initialDelay, int retryCount, double factor, bool fastFirst);
    [IteratorStateMachineAttribute("GitVersion.Helpers.RetryAction`2/<Empty>d__4")]
private static IEnumerable`1<TimeSpan> Empty();
    [IteratorStateMachineAttribute("GitVersion.Helpers.RetryAction`2/<<LinearBackoff>g__Enumerate|3_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TimeSpan> <LinearBackoff>g__Enumerate|3_0(TimeSpan initial, int retry, bool fast, double f);
}
public static class GitVersion.Helpers.ServiceMessageEscapeHelper : object {
    [NullableContextAttribute("2")]
public static string EscapeValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class GitVersion.Helpers.StringFormatWithExtension : object {
    private static Regex TokensRegex;
    private static StringFormatWithExtension();
    [ExtensionAttribute]
public static string FormatWith(string template, T source, IEnvironment environment);
    private static Func`2<object, object> CompileDataBinder(Type type, string expr);
}
[NullableContextAttribute("1")]
public interface GitVersion.IConverterContext {
    public string WorkingDirectory { get; }
    public abstract virtual string get_WorkingDirectory();
}
[NullableContextAttribute("1")]
public interface GitVersion.IEnvironment {
    public abstract virtual string GetEnvironmentVariable(string variableName);
    public abstract virtual void SetEnvironmentVariable(string variableName, string value);
}
[NullableContextAttribute("1")]
public interface GitVersion.IFileSystem {
    public abstract virtual void Copy(string from, string to, bool overwrite);
    public abstract virtual void Move(string from, string to);
    public abstract virtual bool Exists(string file);
    public abstract virtual void Delete(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual void WriteAllText(string file, string fileContents);
    public abstract virtual void WriteAllText(string file, string fileContents, Encoding encoding);
    public abstract virtual IEnumerable`1<string> DirectoryEnumerateFiles(string directory, string searchPattern, SearchOption searchOption);
    public abstract virtual Stream OpenWrite(string path);
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual void CreateDirectory(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual long GetLastDirectoryWrite(string path);
}
[NullableContextAttribute("1")]
public interface GitVersion.IGitPreparer {
    public abstract virtual void Prepare();
    public abstract virtual void EnsureLocalBranchExistsForCurrentBranch(IRemote remote, string currentBranch);
}
[NullableContextAttribute("1")]
public interface GitVersion.IGitVersionCalculateTool {
    public abstract virtual GitVersionVariables CalculateVersionVariables();
}
[NullableContextAttribute("1")]
public interface GitVersion.IGitVersionContextFactory {
    public abstract virtual GitVersionContext Create(GitVersionOptions gitVersionOptions);
}
[NullableContextAttribute("1")]
public interface GitVersion.IGitVersionModule {
    public abstract virtual void RegisterTypes(IServiceCollection services);
    [NullableContextAttribute("2")]
public static IEnumerable`1<Type> FindAllDerivedTypes(Assembly assembly);
}
public enum GitVersion.IncrementStrategy : Enum {
    public int value__;
    public static IncrementStrategy None;
    public static IncrementStrategy Major;
    public static IncrementStrategy Minor;
    public static IncrementStrategy Patch;
    public static IncrementStrategy Inherit;
}
public interface GitVersion.IVersionConverter`1 {
    [NullableContextAttribute("1")]
public abstract virtual void Execute(GitVersionVariables variables, T context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.LockedFileException : Exception {
    [NullableContextAttribute("1")]
public LockedFileException(Exception inner);
    public LockedFileException(string message);
    public LockedFileException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class GitVersion.Logging.ConsoleAdapter : object {
    public sealed virtual void WriteLine(string msg);
    public sealed virtual void WriteLine();
    public sealed virtual void Write(string msg);
    public sealed virtual string ReadLine();
    [NullableContextAttribute("1")]
public sealed virtual IDisposable UseColor(ConsoleColor consoleColor);
}
internal class GitVersion.Logging.ConsoleAppender : object {
    [NullableAttribute("1")]
private object locker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<LogLevel, ValueTuple`2<ConsoleColor, ConsoleColor>> palettes;
    [NullableContextAttribute("1")]
public sealed virtual void WriteTo(LogLevel level, string message);
    private static IDictionary`2<LogLevel, ValueTuple`2<ConsoleColor, ConsoleColor>> CreatePalette();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Logging.FileAppender : object {
    private string filePath;
    public FileAppender(string filePath);
    public sealed virtual void WriteTo(LogLevel level, string message);
    private static void WriteLogEntry(string logFilePath, string str);
}
[NullableContextAttribute("2")]
public interface GitVersion.Logging.IConsole {
    public abstract virtual void WriteLine(string msg);
    public abstract virtual void WriteLine();
    public abstract virtual void Write(string msg);
    public abstract virtual string ReadLine();
    [NullableContextAttribute("1")]
public abstract virtual IDisposable UseColor(ConsoleColor consoleColor);
}
[NullableContextAttribute("1")]
public interface GitVersion.Logging.ILog {
    public Verbosity Verbosity { get; public set; }
    public abstract virtual Verbosity get_Verbosity();
    public abstract virtual void set_Verbosity(Verbosity value);
    public abstract virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
    public abstract virtual IDisposable IndentLog(string operationDescription);
    public abstract virtual void AddLogAppender(ILogAppender logAppender);
    public abstract virtual void Separator();
}
[NullableContextAttribute("1")]
public interface GitVersion.Logging.ILogAppender {
    public abstract virtual void WriteTo(LogLevel level, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.Logging.Log : object {
    private IEnumerable`1<ILogAppender> appenders;
    private Regex obscurePasswordRegex;
    private StringBuilder sb;
    private string currentIndentation;
    private static string Indentation;
    [CompilerGeneratedAttribute]
private Verbosity <Verbosity>k__BackingField;
    public Verbosity Verbosity { get; public set; }
    public Log(ILogAppender[] appenders);
    [CompilerGeneratedAttribute]
public sealed virtual Verbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(Verbosity value);
    public sealed virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
    public sealed virtual IDisposable IndentLog(string operationDescription);
    public sealed virtual void Separator();
    public sealed virtual void AddLogAppender(ILogAppender logAppender);
    public virtual string ToString();
    private string FormatMessage(string message, string level);
}
public class GitVersion.Logging.LogAction : MulticastDelegate {
    public LogAction(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(LogActionEntry actionEntry);
    public virtual IAsyncResult BeginInvoke(LogActionEntry actionEntry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class GitVersion.Logging.LogActionEntry : MulticastDelegate {
    public LogActionEntry(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(string format, Object[] args);
    public virtual IAsyncResult BeginInvoke(string format, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class GitVersion.Logging.LogExtensions : object {
    private static IDictionary`2<LogLevel, Verbosity> VerbosityMaps;
    private static LogExtensions();
    [ExtensionAttribute]
public static void Debug(ILog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ILog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ILog log, LogAction logAction);
    [ExtensionAttribute]
public static void Debug(ILog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Warning(ILog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ILog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ILog log, LogAction logAction);
    [ExtensionAttribute]
public static void Warning(ILog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Info(ILog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(ILog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(ILog log, LogAction logAction);
    [ExtensionAttribute]
public static void Info(ILog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Verbose(ILog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ILog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ILog log, LogAction logAction);
    [ExtensionAttribute]
public static void Verbose(ILog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
public static void Error(ILog log, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ILog log, Verbosity verbosity, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ILog log, LogAction logAction);
    [ExtensionAttribute]
public static void Error(ILog log, Verbosity verbosity, LogAction logAction);
    [ExtensionAttribute]
private static void Write(ILog log, LogLevel level, string format, Object[] args);
    [ExtensionAttribute]
private static void Write(ILog log, Verbosity verbosity, LogLevel level, LogAction logAction);
    [ExtensionAttribute]
private static void Write(ILog log, LogLevel level, LogAction logAction);
    [ExtensionAttribute]
public static IDisposable QuietVerbosity(ILog log);
    [ExtensionAttribute]
public static IDisposable MinimalVerbosity(ILog log);
    [ExtensionAttribute]
public static IDisposable NormalVerbosity(ILog log);
    [ExtensionAttribute]
public static IDisposable VerboseVerbosity(ILog log);
    [ExtensionAttribute]
public static IDisposable DiagnosticVerbosity(ILog log);
    [ExtensionAttribute]
private static IDisposable WithVerbosity(ILog log, Verbosity verbosity);
    private static Verbosity GetVerbosityForLevel(LogLevel level);
}
public enum GitVersion.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Fatal;
    public static LogLevel Error;
    public static LogLevel Warn;
    public static LogLevel Info;
    public static LogLevel Verbose;
    public static LogLevel Debug;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class GitVersion.Logging.NullLog : object {
    [CompilerGeneratedAttribute]
private Verbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    public Verbosity Verbosity { get; public set; }
    public string Indent { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Verbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(Verbosity value);
    [NullableContextAttribute("1")]
public sealed virtual void Write(Verbosity verbosity, LogLevel level, string format, Object[] args);
    [NullableContextAttribute("1")]
public sealed virtual IDisposable IndentLog(string operationDescription);
    [NullableContextAttribute("1")]
public sealed virtual void AddLogAppender(ILogAppender logAppender);
    public sealed virtual void Separator();
    [CompilerGeneratedAttribute]
public string get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(string value);
}
public enum GitVersion.Logging.Verbosity : Enum {
    public int value__;
    public static Verbosity Quiet;
    public static Verbosity Minimal;
    public static Verbosity Normal;
    public static Verbosity Verbose;
    public static Verbosity Diagnostic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.MainlineBranchFinder : object {
    private IGitVersionConfiguration configuration;
    private ILog log;
    private IGitRepository repository;
    private IRepositoryStore repositoryStore;
    private List`1<IBranchConfiguration> mainlineBranchConfigurations;
    public MainlineBranchFinder(IRepositoryStore repositoryStore, IGitRepository repository, IGitVersionConfiguration configuration, ILog log);
    public IDictionary`2<string, List`1<IBranch>> FindMainlineBranches(ICommit commit);
    private bool IsMainBranch(INamedReference branch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.MergeBaseFinder : object {
    private ILog log;
    private IGitRepository repository;
    private IRepositoryStore repositoryStore;
    private Dictionary`2<Tuple`2<IBranch, IBranch>, ICommit> mergeBaseCache;
    public MergeBaseFinder(IRepositoryStore repositoryStore, IGitRepository gitRepository, ILog log);
    [NullableContextAttribute("2")]
public ICommit FindMergeBaseOf(IBranch first, IBranch second);
    private ICommit FindMergeBase(ICommit commit, ICommit commitToFindCommonBase);
    [NullableContextAttribute("2")]
private ICommit GetForwardMerge(ICommit commitToFindCommonBase, ICommit findMergeBase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.MergeCommitFinder : object {
    private ILog log;
    private IEnumerable`1<IBranch> branches;
    private RepositoryStore repositoryStore;
    private IGitVersionConfiguration configuration;
    private Dictionary`2<IBranch, List`1<BranchCommit>> mergeBaseCommitsCache;
    public MergeCommitFinder(RepositoryStore repositoryStore, IGitVersionConfiguration configuration, IEnumerable`1<IBranch> excludedBranches, ILog log);
    public IEnumerable`1<BranchCommit> FindMergeCommitsFor(IBranch branch);
    [IteratorStateMachineAttribute("GitVersion.MergeCommitFinder/<FindMergeBases>d__7")]
private IEnumerable`1<BranchCommit> FindMergeBases(IBranch branch);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.MergeMessage : object {
    [NullableAttribute("1")]
private static IList`1<MergeMessageFormat> DefaultFormats;
    [CompilerGeneratedAttribute]
private string <FormatName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceName <MergedBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PullRequestNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    public string FormatName { get; }
    public string TargetBranch { get; }
    public ReferenceName MergedBranch { get; }
    public bool IsMergedPullRequest { get; }
    public Nullable`1<int> PullRequestNumber { get; }
    public SemanticVersion Version { get; }
    [NullableContextAttribute("1")]
public MergeMessage(string mergeMessage, IGitVersionConfiguration configuration);
    private static MergeMessage();
    [CompilerGeneratedAttribute]
public string get_FormatName();
    [CompilerGeneratedAttribute]
public string get_TargetBranch();
    [CompilerGeneratedAttribute]
public ReferenceName get_MergedBranch();
    public bool get_IsMergedPullRequest();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PullRequestNumber();
    [CompilerGeneratedAttribute]
public SemanticVersion get_Version();
    private SemanticVersion ParseVersion(Regex versionInBranchRegex, string tagPrefix, SemanticVersionFormat format);
    [NullableContextAttribute("1")]
private ReferenceName GetMergedBranchName(string mergedBranch);
    [NullableContextAttribute("1")]
public static bool TryParse(ICommit mergeCommit, IGitVersionConfiguration configuration, MergeMessage& mergeMessage);
}
public enum GitVersion.OutputType : Enum {
    public int value__;
    public static OutputType BuildServer;
    public static OutputType Json;
    public static OutputType File;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.OutputVariables.GitVersionVariables : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Major>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Minor>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildMetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullBuildMetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BranchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EscapedBranchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortSha>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <MajorMinorPatch>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <SemVer>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FullSemVer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblySemVer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblySemFileVer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseTagWithDash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseLabelWithDash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseNumber>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <WeightedPreReleaseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionSourceSha>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitsSinceVersionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UncommittedChanges>k__BackingField;
    [NullableAttribute("1")]
internal static List`1<string> AvailableVariables;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("1")]
public string Major { get; public set; }
    [NullableAttribute("1")]
public string Minor { get; public set; }
    [NullableAttribute("1")]
public string Patch { get; public set; }
    public string BuildMetaData { get; public set; }
    public string FullBuildMetaData { get; public set; }
    public string BranchName { get; public set; }
    public string EscapedBranchName { get; public set; }
    public string Sha { get; public set; }
    public string ShortSha { get; public set; }
    [NullableAttribute("1")]
public string MajorMinorPatch { get; public set; }
    [NullableAttribute("1")]
public string SemVer { get; public set; }
    [NullableAttribute("1")]
public string FullSemVer { get; public set; }
    public string AssemblySemVer { get; public set; }
    public string AssemblySemFileVer { get; public set; }
    public string PreReleaseTag { get; public set; }
    public string PreReleaseTagWithDash { get; public set; }
    public string PreReleaseLabel { get; public set; }
    public string PreReleaseLabelWithDash { get; public set; }
    public string PreReleaseNumber { get; public set; }
    [NullableAttribute("1")]
public string WeightedPreReleaseNumber { get; public set; }
    public string InformationalVersion { get; public set; }
    public string CommitDate { get; public set; }
    public string VersionSourceSha { get; public set; }
    public string CommitsSinceVersionSource { get; public set; }
    public string UncommittedChanges { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> Instance { get; }
    public GitVersionVariables(string Major, string Minor, string Patch, string BuildMetaData, string FullBuildMetaData, string BranchName, string EscapedBranchName, string Sha, string ShortSha, string MajorMinorPatch, string SemVer, string FullSemVer, string AssemblySemVer, string AssemblySemFileVer, string PreReleaseTag, string PreReleaseTagWithDash, string PreReleaseLabel, string PreReleaseLabelWithDash, string PreReleaseNumber, string WeightedPreReleaseNumber, string InformationalVersion, string CommitDate, string VersionSourceSha, string CommitsSinceVersionSource, string UncommittedChanges);
    [CompilerGeneratedAttribute]
protected GitVersionVariables(GitVersionVariables original);
    private static GitVersionVariables();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Major();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Major(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Minor();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Minor(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Patch();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Patch(string value);
    [CompilerGeneratedAttribute]
public string get_BuildMetaData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BuildMetaData(string value);
    [CompilerGeneratedAttribute]
public string get_FullBuildMetaData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FullBuildMetaData(string value);
    [CompilerGeneratedAttribute]
public string get_BranchName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BranchName(string value);
    [CompilerGeneratedAttribute]
public string get_EscapedBranchName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EscapedBranchName(string value);
    [CompilerGeneratedAttribute]
public string get_Sha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Sha(string value);
    [CompilerGeneratedAttribute]
public string get_ShortSha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShortSha(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_MajorMinorPatch();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MajorMinorPatch(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_SemVer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SemVer(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FullSemVer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FullSemVer(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblySemVer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AssemblySemVer(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblySemFileVer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AssemblySemFileVer(string value);
    [CompilerGeneratedAttribute]
public string get_PreReleaseTag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseTag(string value);
    [CompilerGeneratedAttribute]
public string get_PreReleaseTagWithDash();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseTagWithDash(string value);
    [CompilerGeneratedAttribute]
public string get_PreReleaseLabel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseLabel(string value);
    [CompilerGeneratedAttribute]
public string get_PreReleaseLabelWithDash();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseLabelWithDash(string value);
    [CompilerGeneratedAttribute]
public string get_PreReleaseNumber();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseNumber(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_WeightedPreReleaseNumber();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WeightedPreReleaseNumber(string value);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InformationalVersion(string value);
    [CompilerGeneratedAttribute]
public string get_CommitDate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitDate(string value);
    [CompilerGeneratedAttribute]
public string get_VersionSourceSha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VersionSourceSha(string value);
    [CompilerGeneratedAttribute]
public string get_CommitsSinceVersionSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitsSinceVersionSource(string value);
    [CompilerGeneratedAttribute]
public string get_UncommittedChanges();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UncommittedChanges(string value);
    private Dictionary`2<string, string> get_Instance();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public bool TryGetValue(string variable, String& variableValue);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GitVersionVariables left, GitVersionVariables right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GitVersionVariables left, GitVersionVariables right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(GitVersionVariables other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual GitVersionVariables <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Major, String& Minor, String& Patch, String& BuildMetaData, String& FullBuildMetaData, String& BranchName, String& EscapedBranchName, String& Sha, String& ShortSha, String& MajorMinorPatch, String& SemVer, String& FullSemVer, String& AssemblySemVer, String& AssemblySemFileVer, String& PreReleaseTag, String& PreReleaseTagWithDash, String& PreReleaseLabel, String& PreReleaseLabelWithDash, String& PreReleaseNumber, String& WeightedPreReleaseNumber, String& InformationalVersion, String& CommitDate, String& VersionSourceSha, String& CommitsSinceVersionSource, String& UncommittedChanges);
}
[NullableContextAttribute("1")]
public interface GitVersion.OutputVariables.IVersionVariableSerializer {
    public abstract virtual GitVersionVariables FromJson(string json);
    public abstract virtual string ToJson(GitVersionVariables gitVersionVariables);
    public abstract virtual GitVersionVariables FromFile(string filePath);
    public abstract virtual void ToFile(GitVersionVariables gitVersionVariables, string filePath);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.RepositoryInfo : object {
    public string TargetUrl;
    public string TargetBranch;
    public string CommitId;
    public string ClonePath;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected RepositoryInfo(RepositoryInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RepositoryInfo left, RepositoryInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RepositoryInfo left, RepositoryInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(RepositoryInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual RepositoryInfo <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.RepositoryStore : object {
    private ILog log;
    private IGitRepository repository;
    private MergeBaseFinder mergeBaseFinder;
    public RepositoryStore(ILog log, IGitRepository repository);
    [NullableContextAttribute("2")]
public sealed virtual ICommit FindMergeBase(IBranch branch, IBranch otherBranch);
    public sealed virtual ICommit GetCurrentCommit(IBranch currentBranch, string commitId, IIgnoreConfiguration ignore);
    public sealed virtual IBranch GetTargetBranch(string targetBranchName);
    public sealed virtual IBranch FindBranch(ReferenceName branchName);
    public sealed virtual IBranch FindBranch(string branchName);
    public sealed virtual IEnumerable`1<IBranch> ExcludingBranches(IEnumerable`1<IBranch> branchesToExclude);
    public sealed virtual IEnumerable`1<IBranch> GetBranchesContainingCommit(ICommit commit, IEnumerable`1<IBranch> branches, bool onlyTrackedBranches);
    public sealed virtual IEnumerable`1<IBranch> GetSourceBranches(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    [IteratorStateMachineAttribute("GitVersion.RepositoryStore/<GetSourceBranches>d__12")]
public sealed virtual IEnumerable`1<IBranch> GetSourceBranches(IBranch branch, IGitVersionConfiguration configuration, IEnumerable`1<IBranch> excludedBranches);
    public sealed virtual BranchCommit FindCommitBranchBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    public sealed virtual IEnumerable`1<BranchCommit> FindCommitBranchesBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IBranch[] excludedBranches);
    public sealed virtual IEnumerable`1<BranchCommit> FindCommitBranchesBranchedFrom(IBranch branch, IGitVersionConfiguration configuration, IEnumerable`1<IBranch> excludedBranches);
    public sealed virtual IReadOnlyList`1<ICommit> GetCommitLog(ICommit baseVersionSource, ICommit currentCommit, IIgnoreConfiguration ignore);
    public sealed virtual bool IsCommitOnBranch(ICommit baseVersionSource, IBranch branch, ICommit firstMatchingCommit);
    public sealed virtual ICommit FindMergeBase(ICommit commit, ICommit mainlineTip);
    public sealed virtual int GetNumberOfUncommittedChanges();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.SemanticVersion : object {
    public static SemanticVersion Empty;
    private static Regex ParseSemVerStrict;
    private static Regex ParseSemVerLoose;
    [CompilerGeneratedAttribute]
private long <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersionPreReleaseTag <PreReleaseTag>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersionBuildMetaData <BuildMetaData>k__BackingField;
    public long Major { get; public set; }
    public long Minor { get; public set; }
    public long Patch { get; public set; }
    public bool IsPreRelease { get; }
    public SemanticVersionPreReleaseTag PreReleaseTag { get; public set; }
    public SemanticVersionBuildMetaData BuildMetaData { get; public set; }
    public SemanticVersion(long major, long minor, long patch);
    public SemanticVersion(SemanticVersion semanticVersion);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public long get_Major();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Major(long value);
    [CompilerGeneratedAttribute]
public long get_Minor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Minor(long value);
    [CompilerGeneratedAttribute]
public long get_Patch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Patch(long value);
    public bool get_IsPreRelease();
    [CompilerGeneratedAttribute]
public SemanticVersionPreReleaseTag get_PreReleaseTag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreReleaseTag(SemanticVersionPreReleaseTag value);
    [CompilerGeneratedAttribute]
public SemanticVersionBuildMetaData get_BuildMetaData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BuildMetaData(SemanticVersionBuildMetaData value);
    public bool IsLabeledWith(string value);
    [NullableContextAttribute("2")]
public bool IsMatchForBranchSpecificLabel(string value);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SemanticVersion obj);
    public bool IsEmpty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(SemanticVersion v1, SemanticVersion v2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(SemanticVersion v1, SemanticVersion v2);
    public static bool op_GreaterThan(SemanticVersion v1, SemanticVersion v2);
    public static bool op_GreaterThanOrEqual(SemanticVersion v1, SemanticVersion v2);
    public static bool op_LessThanOrEqual(SemanticVersion v1, SemanticVersion v2);
    public static bool op_LessThan(SemanticVersion v1, SemanticVersion v2);
    public static SemanticVersion Parse(string version, string tagPrefixRegex, SemanticVersionFormat versionFormat);
    [NullableContextAttribute("2")]
public static bool TryParse(string version, string tagPrefixRegex, SemanticVersion& semanticVersion, SemanticVersionFormat format);
    private static bool TryParseStrict(string version, SemanticVersion& semanticVersion);
    private static bool TryParseLoose(string version, SemanticVersion& semanticVersion);
    [NullableContextAttribute("2")]
public bool IsGreaterThan(SemanticVersion value, bool includePreRelease);
    [NullableContextAttribute("2")]
public bool IsGreaterThanOrEqualTo(SemanticVersion value, bool includePreRelease);
    [NullableContextAttribute("2")]
public bool IsLessThan(SemanticVersion value, bool includePreRelease);
    [NullableContextAttribute("2")]
public bool IsLessThanOrEqualTo(SemanticVersion value, bool includePreRelease);
    [NullableContextAttribute("2")]
public bool IsEqualTo(SemanticVersion value, bool includePreRelease);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(SemanticVersion value);
    [NullableContextAttribute("2")]
public int CompareTo(SemanticVersion value, bool includePreRelease);
    public virtual string ToString();
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public SemanticVersion WithLabel(string label);
    public SemanticVersion Increment(VersionField increment, string label, SemanticVersion[] alternativeSemanticVersions);
    public SemanticVersion Increment(VersionField increment, string label, bool forceIncrement, SemanticVersion[] alternativeSemanticVersions);
    public SemanticVersion Increment(VersionField increment, string label, IncrementMode mode, SemanticVersion[] alternativeSemanticVersions);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.SemanticVersionBuildMetaData : object {
    [NullableAttribute("1")]
public static SemanticVersionBuildMetaData Empty;
    [NullableAttribute("1")]
private static Regex ParseRegex;
    [NullableAttribute("1")]
private static LambdaEqualityHelper`1<SemanticVersionBuildMetaData> EqualityHelper;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <CommitsSinceTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortSha>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OtherMetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CommitDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionSourceSha>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CommitsSinceVersionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UncommittedChanges>k__BackingField;
    public Nullable`1<long> CommitsSinceTag { get; public set; }
    public string Branch { get; public set; }
    public string Sha { get; public set; }
    public string ShortSha { get; public set; }
    public string OtherMetaData { get; public set; }
    public Nullable`1<DateTimeOffset> CommitDate { get; public set; }
    public string VersionSourceSha { get; public set; }
    public long CommitsSinceVersionSource { get; public set; }
    public long UncommittedChanges { get; public set; }
    public SemanticVersionBuildMetaData(string versionSourceSha, Nullable`1<long> commitsSinceTag, string branch, string commitSha, string commitShortSha, Nullable`1<DateTimeOffset> commitDate, long numberOfUnCommittedChanges, string otherMetadata);
    [NullableContextAttribute("1")]
public SemanticVersionBuildMetaData(SemanticVersionBuildMetaData buildMetaData);
    private static SemanticVersionBuildMetaData();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_CommitsSinceTag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitsSinceTag(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Branch(string value);
    [CompilerGeneratedAttribute]
public string get_Sha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Sha(string value);
    [CompilerGeneratedAttribute]
public string get_ShortSha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShortSha(string value);
    [CompilerGeneratedAttribute]
public string get_OtherMetaData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OtherMetaData(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CommitDate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitDate(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_VersionSourceSha();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VersionSourceSha(string value);
    [CompilerGeneratedAttribute]
public long get_CommitsSinceVersionSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommitsSinceVersionSource(long value);
    [CompilerGeneratedAttribute]
public long get_UncommittedChanges();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UncommittedChanges(long value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemanticVersionBuildMetaData other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(SemanticVersionBuildMetaData left, SemanticVersionBuildMetaData right);
    public static bool op_Inequality(SemanticVersionBuildMetaData left, SemanticVersionBuildMetaData right);
    public static string op_Implicit(SemanticVersionBuildMetaData preReleaseTag);
    [NullableContextAttribute("1")]
public static SemanticVersionBuildMetaData op_Implicit(string preReleaseTag);
    [NullableContextAttribute("1")]
public static SemanticVersionBuildMetaData Parse(string buildMetaData);
    [NullableContextAttribute("1")]
private static string FormatMetaDataPart(string value);
}
public enum GitVersion.SemanticVersionFormat : Enum {
    public int value__;
    public static SemanticVersionFormat Strict;
    public static SemanticVersionFormat Loose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.SemanticVersionFormatValues : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <semver>P;
    [CompilerGeneratedAttribute]
private IGitVersionConfiguration <configuration>P;
    [CompilerGeneratedAttribute]
private int <preReleaseWeight>P;
    public string Major { get; }
    public string Minor { get; }
    public string Patch { get; }
    public string PreReleaseTag { get; }
    public string PreReleaseTagWithDash { get; }
    public string PreReleaseLabel { get; }
    public string PreReleaseLabelWithDash { get; }
    public string PreReleaseNumber { get; }
    public string WeightedPreReleaseNumber { get; }
    public string BuildMetaData { get; }
    public string FullBuildMetaData { get; }
    public string MajorMinorPatch { get; }
    public string SemVer { get; }
    [NullableAttribute("2")]
public string AssemblySemVer { get; }
    [NullableAttribute("2")]
public string AssemblyFileSemVer { get; }
    public string FullSemVer { get; }
    [NullableAttribute("2")]
public string BranchName { get; }
    [NullableAttribute("2")]
public string EscapedBranchName { get; }
    [NullableAttribute("2")]
public string Sha { get; }
    [NullableAttribute("2")]
public string ShortSha { get; }
    [NullableAttribute("2")]
public string CommitDate { get; }
    public string InformationalVersion { get; }
    [NullableAttribute("2")]
public string VersionSourceSha { get; }
    public string CommitsSinceVersionSource { get; }
    public string UncommittedChanges { get; }
    public SemanticVersionFormatValues(SemanticVersion semver, IGitVersionConfiguration configuration, int preReleaseWeight);
    public string get_Major();
    public string get_Minor();
    public string get_Patch();
    public string get_PreReleaseTag();
    public string get_PreReleaseTagWithDash();
    public string get_PreReleaseLabel();
    public string get_PreReleaseLabelWithDash();
    public string get_PreReleaseNumber();
    public string get_WeightedPreReleaseNumber();
    public string get_BuildMetaData();
    public string get_FullBuildMetaData();
    public string get_MajorMinorPatch();
    public string get_SemVer();
    [NullableContextAttribute("2")]
public string get_AssemblySemVer();
    [NullableContextAttribute("2")]
public string get_AssemblyFileSemVer();
    public string get_FullSemVer();
    [NullableContextAttribute("2")]
public string get_BranchName();
    [NullableContextAttribute("2")]
public string get_EscapedBranchName();
    [NullableContextAttribute("2")]
public string get_Sha();
    [NullableContextAttribute("2")]
public string get_ShortSha();
    [NullableContextAttribute("2")]
public string get_CommitDate();
    public string get_InformationalVersion();
    [NullableContextAttribute("2")]
public string get_VersionSourceSha();
    public string get_CommitsSinceVersionSource();
    public string get_UncommittedChanges();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.SemanticVersionPreReleaseTag : object {
    private static StringComparer IgnoreCaseComparer;
    public static SemanticVersionPreReleaseTag Empty;
    private static Regex ParseRegex;
    private static LambdaEqualityHelper`1<SemanticVersionPreReleaseTag> EqualityHelper;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PromoteTagEvenIfNameIsEmpty>k__BackingField;
    public string Name { get; public set; }
    public Nullable`1<long> Number { get; public set; }
    public bool PromoteTagEvenIfNameIsEmpty { get; public set; }
    public SemanticVersionPreReleaseTag(string name, Nullable`1<long> number, bool promoteTagEvenIfNameIsEmpty);
    public SemanticVersionPreReleaseTag(SemanticVersionPreReleaseTag preReleaseTag);
    private static SemanticVersionPreReleaseTag();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Number();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Number(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_PromoteTagEvenIfNameIsEmpty();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PromoteTagEvenIfNameIsEmpty(bool value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SemanticVersionPreReleaseTag other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static bool op_GreaterThan(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static bool op_LessThan(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static bool op_GreaterThanOrEqual(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static bool op_LessThanOrEqual(SemanticVersionPreReleaseTag left, SemanticVersionPreReleaseTag right);
    [NullableContextAttribute("2")]
public static string op_Implicit(SemanticVersionPreReleaseTag preReleaseTag);
    public static SemanticVersionPreReleaseTag op_Implicit(string preReleaseTag);
    public static SemanticVersionPreReleaseTag Parse(string preReleaseTag);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(SemanticVersionPreReleaseTag other);
    public virtual string ToString();
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public bool HasTag();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.SemanticVersionWithTag : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ITag <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public SemanticVersion Value { get; public set; }
    public ITag Tag { get; public set; }
    public SemanticVersionWithTag(SemanticVersion Value, ITag Tag);
    [CompilerGeneratedAttribute]
private SemanticVersionWithTag(SemanticVersionWithTag original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SemanticVersion get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(SemanticVersion value);
    [CompilerGeneratedAttribute]
public ITag get_Tag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tag(ITag value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(SemanticVersionWithTag other);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SemanticVersionWithTag left, SemanticVersionWithTag right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SemanticVersionWithTag left, SemanticVersionWithTag right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SemanticVersionWithTag other);
    [CompilerGeneratedAttribute]
public SemanticVersionWithTag <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(SemanticVersion& Value, ITag& Tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.Settings : object {
    public bool NoFetch;
    public bool NoCache;
    public bool NoNormalize;
    public bool OnlyTrackedBranches;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Settings(Settings original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Settings left, Settings right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Settings left, Settings right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Settings other);
    [CompilerGeneratedAttribute]
public virtual Settings <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.SourceBranchFinder : object {
    private IGitVersionConfiguration configuration;
    private IEnumerable`1<IBranch> excludedBranches;
    public SourceBranchFinder(IEnumerable`1<IBranch> excludedBranches, IGitVersionConfiguration configuration);
    public IEnumerable`1<IBranch> FindSourceBranchesOf(IBranch branch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.VersionCalculation.BaseVersion : object {
    [CompilerGeneratedAttribute]
private BaseVersionOperand <Operand>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BaseVersionOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string Source { get; }
    public SemanticVersion SemanticVersion { get; }
    [NullableAttribute("2")]
public ICommit BaseVersionSource { get; }
    [MemberNotNullWhenAttribute("True", "Operator")]
public bool ShouldIncrement { get; }
    public BaseVersionOperand Operand { get; public set; }
    [NullableAttribute("2")]
public BaseVersionOperator Operator { get; public set; }
    public BaseVersion(BaseVersionOperand Operand);
    public BaseVersion(string source, SemanticVersion semanticVersion, ICommit baseVersionSource);
    [CompilerGeneratedAttribute]
private BaseVersion(BaseVersion original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    public sealed virtual string get_Source();
    public sealed virtual SemanticVersion get_SemanticVersion();
    [NullableContextAttribute("2")]
public sealed virtual ICommit get_BaseVersionSource();
    [MemberNotNullWhenAttribute("True", "Operator")]
public bool get_ShouldIncrement();
    [CompilerGeneratedAttribute]
public BaseVersionOperand get_Operand();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Operand(BaseVersionOperand value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BaseVersionOperator get_Operator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Operator(BaseVersionOperator value);
    public SemanticVersion GetIncrementedVersion();
    public virtual string ToString();
    internal BaseVersion Apply(BaseVersionOperator baseVersionOperator);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BaseVersion left, BaseVersion right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BaseVersion left, BaseVersion right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BaseVersion other);
    [CompilerGeneratedAttribute]
public BaseVersion <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(BaseVersionOperand& Operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.VersionCalculation.BaseVersionOperand : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICommit <BaseVersionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <SemanticVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [NullableAttribute("2")]
public ICommit BaseVersionSource { get; public set; }
    public string Source { get; public set; }
    public SemanticVersion SemanticVersion { get; public set; }
    public BaseVersionOperand(string Source, SemanticVersion SemanticVersion, ICommit BaseVersionSource);
    [CompilerGeneratedAttribute]
private BaseVersionOperand(BaseVersionOperand original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ICommit get_BaseVersionSource();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BaseVersionSource(ICommit value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(string value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_SemanticVersion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SemanticVersion(SemanticVersion value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BaseVersionOperand left, BaseVersionOperand right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BaseVersionOperand left, BaseVersionOperand right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BaseVersionOperand other);
    [CompilerGeneratedAttribute]
public BaseVersionOperand <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Source, SemanticVersion& SemanticVersion, ICommit& BaseVersionSource);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class GitVersion.VersionCalculation.BaseVersionOperator : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommit <BaseVersionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionField <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceIncrement>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <AlternativeSemanticVersion>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [NullableAttribute("1")]
public string Source { get; public set; }
    public ICommit BaseVersionSource { get; public set; }
    public VersionField Increment { get; public set; }
    public bool ForceIncrement { get; public set; }
    public string Label { get; public set; }
    public SemanticVersion AlternativeSemanticVersion { get; public set; }
    [CompilerGeneratedAttribute]
private BaseVersionOperator(BaseVersionOperator original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ICommit get_BaseVersionSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BaseVersionSource(ICommit value);
    [CompilerGeneratedAttribute]
public VersionField get_Increment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Increment(VersionField value);
    [CompilerGeneratedAttribute]
public bool get_ForceIncrement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForceIncrement(bool value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Label(string value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_AlternativeSemanticVersion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AlternativeSemanticVersion(SemanticVersion value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BaseVersionOperator left, BaseVersionOperator right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BaseVersionOperator left, BaseVersionOperator right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BaseVersionOperator other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public BaseVersionOperator <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.VersionCalculation.Caching.GitVersionCacheKey : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Value { get; public set; }
    public GitVersionCacheKey(string Value);
    [CompilerGeneratedAttribute]
protected GitVersionCacheKey(GitVersionCacheKey original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(GitVersionCacheKey left, GitVersionCacheKey right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(GitVersionCacheKey left, GitVersionCacheKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(GitVersionCacheKey other);
    [CompilerGeneratedAttribute]
public virtual GitVersionCacheKey <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Caching.GitVersionCacheKeyFactory : object {
    private IFileSystem fileSystem;
    private ILog log;
    private IOptions`1<GitVersionOptions> options;
    private IConfigurationFileLocator configFileLocator;
    private IConfigurationSerializer configurationSerializer;
    private IGitRepository gitRepository;
    private IGitRepositoryInfo repositoryInfo;
    public GitVersionCacheKeyFactory(IFileSystem fileSystem, ILog log, IOptions`1<GitVersionOptions> options, IConfigurationFileLocator configFileLocator, IConfigurationSerializer configurationSerializer, IGitRepository gitRepository, IGitRepositoryInfo repositoryInfo);
    public sealed virtual GitVersionCacheKey Create(IReadOnlyDictionary`2<object, object> overrideConfiguration);
    private string GetGitSystemHash();
    private List`1<string> CalculateDirectoryContents(string root);
    private string GetRepositorySnapshotHash();
    private string GetOverrideConfigHash(IReadOnlyDictionary`2<object, object> overrideConfiguration);
    private string GetConfigFileHash();
    private static string GetHash(String[] textsToHash);
    private static string GetHash(string textToHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Caching.GitVersionCacheProvider : object {
    private IFileSystem fileSystem;
    private ILog log;
    private IOptions`1<GitVersionOptions> options;
    private IVersionVariableSerializer serializer;
    private IGitVersionCacheKeyFactory cacheKeyFactory;
    private IGitRepositoryInfo repositoryInfo;
    public GitVersionCacheProvider(IFileSystem fileSystem, ILog log, IOptions`1<GitVersionOptions> options, IVersionVariableSerializer serializer, IGitVersionCacheKeyFactory cacheKeyFactory, IGitRepositoryInfo repositoryInfo);
    public sealed virtual void WriteVariablesToDiskCache(GitVersionVariables versionVariables);
    [NullableContextAttribute("2")]
public sealed virtual GitVersionVariables LoadVersionVariablesFromDiskCache();
    internal string GetCacheFileName(GitVersionCacheKey cacheKey);
    internal string GetCacheDirectory();
    private string PrepareCacheDirectory();
    private GitVersionCacheKey GetCacheKey();
    private static string GetCacheFileName(GitVersionCacheKey key, string cacheDir);
}
[NullableContextAttribute("1")]
internal interface GitVersion.VersionCalculation.Caching.IGitVersionCacheKeyFactory {
    public abstract virtual GitVersionCacheKey Create(IReadOnlyDictionary`2<object, object> overrideConfiguration);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.Caching.IGitVersionCacheProvider {
    public abstract virtual void WriteVariablesToDiskCache(GitVersionVariables versionVariables);
    [NullableContextAttribute("2")]
public abstract virtual GitVersionVariables LoadVersionVariablesFromDiskCache();
}
public enum GitVersion.VersionCalculation.CommitMessageIncrementMode : Enum {
    public int value__;
    public static CommitMessageIncrementMode Enabled;
    public static CommitMessageIncrementMode Disabled;
    public static CommitMessageIncrementMode MergeMessageOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.ConfiguredNextVersionVersionStrategy : object {
    private Lazy`1<GitVersionContext> contextLazy;
    private GitVersionContext Context { get; }
    public ConfiguredNextVersionVersionStrategy(Lazy`1<GitVersionContext> contextLazy);
    private GitVersionContext get_Context();
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.ConfiguredNextVersionVersionStrategy/<GetBaseVersions>d__4")]
public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.ContinuousDeliveryVersionCalculator : VersionCalculatorBase {
    public ContinuousDeliveryVersionCalculator(ILog log, IRepositoryStore repositoryStore, Lazy`1<GitVersionContext> versionContext);
    public sealed virtual SemanticVersion Calculate(SemanticVersion semanticVersion, ICommit baseVersionSource);
    private SemanticVersion CalculateInternal(SemanticVersion semanticVersion, ICommit baseVersionSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.ContinuousDeploymentVersionCalculator : VersionCalculatorBase {
    public ContinuousDeploymentVersionCalculator(ILog log, IRepositoryStore repositoryStore, Lazy`1<GitVersionContext> versionContext);
    public sealed virtual SemanticVersion Calculate(SemanticVersion semanticVersion, ICommit baseVersionSource);
    private SemanticVersion CalculateInternal(SemanticVersion semanticVersion, ICommit baseVersionSource);
}
public enum GitVersion.VersionCalculation.DeploymentMode : Enum {
    public int value__;
    public static DeploymentMode ManualDeployment;
    public static DeploymentMode ContinuousDelivery;
    public static DeploymentMode ContinuousDeployment;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.EffectiveBranchConfigurationFinder : object {
    private ILog log;
    private IRepositoryStore repositoryStore;
    public EffectiveBranchConfigurationFinder(ILog log, IRepositoryStore repositoryStore);
    public sealed virtual IEnumerable`1<EffectiveBranchConfiguration> GetConfigurations(IBranch branch, IGitVersionConfiguration configuration);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.EffectiveBranchConfigurationFinder/<GetEffectiveConfigurationsRecursive>d__4")]
private IEnumerable`1<EffectiveBranchConfiguration> GetEffectiveConfigurationsRecursive(IBranch branch, IGitVersionConfiguration configuration, IBranchConfiguration childBranchConfiguration, HashSet`1<IBranch> traversedBranches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.FallbackVersionStrategy : object {
    private Lazy`1<GitVersionContext> contextLazy;
    private IIncrementStrategyFinder incrementStrategyFinder;
    private ITaggedSemanticVersionService taggedSemanticVersionService;
    private GitVersionContext Context { get; }
    public FallbackVersionStrategy(Lazy`1<GitVersionContext> contextLazy, IIncrementStrategyFinder incrementStrategyFinder, ITaggedSemanticVersionService taggedSemanticVersionService);
    private GitVersionContext get_Context();
    public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.FallbackVersionStrategy/<GetBaseVersionsInternal>d__7")]
private IEnumerable`1<BaseVersion> GetBaseVersionsInternal(EffectiveBranchConfiguration configuration);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IBaseVersion {
    public SemanticVersion SemanticVersion { get; }
    public abstract virtual SemanticVersion get_SemanticVersion();
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IBaseVersionIncrement {
    public string Source { get; }
    [NullableAttribute("2")]
public ICommit BaseVersionSource { get; }
    public abstract virtual string get_Source();
    [NullableContextAttribute("2")]
public abstract virtual ICommit get_BaseVersionSource();
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IDeploymentModeCalculator {
    public abstract virtual SemanticVersion Calculate(SemanticVersion semanticVersion, ICommit baseVersionSource);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IEffectiveBranchConfigurationFinder {
    public abstract virtual IEnumerable`1<EffectiveBranchConfiguration> GetConfigurations(IBranch branch, IGitVersionConfiguration configuration);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IIncrementStrategyFinder {
    public abstract virtual VersionField DetermineIncrementedField(ICommit currentCommit, ICommit baseVersionSource, bool shouldIncrement, EffectiveConfiguration configuration, string label);
    [NullableContextAttribute("2")]
public abstract virtual Nullable`1<VersionField> GetIncrementForCommits(string majorVersionBumpMessage, string minorVersionBumpMessage, string patchVersionBumpMessage, string noBumpMessage, ICommit[] commits);
    public abstract virtual IEnumerable`1<ICommit> GetMergedCommits(ICommit mergeCommit, int index, IIgnoreConfiguration ignore);
    public abstract virtual VersionField GetIncrementForcedByCommit(ICommit commit, IGitVersionConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.IncrementStrategyFinder : object {
    public static string DefaultMajorPattern;
    public static string DefaultMinorPattern;
    public static string DefaultPatchPattern;
    public static string DefaultNoBumpPattern;
    private static ConcurrentDictionary`2<string, Regex> CompiledRegexCache;
    private Dictionary`2<string, Nullable`1<VersionField>> commitIncrementCache;
    private Dictionary`2<string, Dictionary`2<string, int>> headCommitsMapCache;
    private Dictionary`2<string, ICommit[]> headCommitsCache;
    private static Regex DefaultMajorPatternRegex;
    private static Regex DefaultMinorPatternRegex;
    private static Regex DefaultPatchPatternRegex;
    private static Regex DefaultNoBumpPatternRegex;
    private IGitRepository repository;
    private ITaggedSemanticVersionRepository taggedSemanticVersionRepository;
    public IncrementStrategyFinder(IGitRepository repository, ITaggedSemanticVersionRepository taggedSemanticVersionRepository);
    private static IncrementStrategyFinder();
    public sealed virtual VersionField DetermineIncrementedField(ICommit currentCommit, ICommit baseVersionSource, bool shouldIncrement, EffectiveConfiguration configuration, string label);
    [NullableContextAttribute("2")]
public sealed virtual Nullable`1<VersionField> GetIncrementForCommits(string majorVersionBumpMessage, string minorVersionBumpMessage, string patchVersionBumpMessage, string noBumpMessage, ICommit[] commits);
    private Nullable`1<VersionField> FindCommitMessageIncrement(EffectiveConfiguration configuration, ICommit baseVersionSource, ICommit currentCommit, string label);
    private static Regex TryGetRegexOrDefault(string messageRegex, Regex defaultRegex);
    private IReadOnlyCollection`1<ICommit> GetCommitHistory(string tagPrefix, SemanticVersionFormat semanticVersionFormat, ICommit baseVersionSource, ICommit currentCommit, string label, IIgnoreConfiguration ignore);
    private IEnumerable`1<ICommit> GetIntermediateCommits(ICommit baseCommit, ICommit headCommit, IIgnoreConfiguration ignore);
    private Dictionary`2<string, int> GetHeadCommitsMap(ICommit headCommit, IIgnoreConfiguration ignore);
    private ICommit[] GetHeadCommits(ICommit headCommit, IIgnoreConfiguration ignore);
    private Nullable`1<VersionField> GetIncrementFromCommit(ICommit commit, Regex majorRegex, Regex minorRegex, Regex patchRegex, Regex none);
    private static Nullable`1<VersionField> GetIncrementFromMessage(string message, Regex majorRegex, Regex minorRegex, Regex patchRegex, Regex none);
    private IEnumerable`1<ICommit> GetCommitsReacheableFromHead(ICommit headCommit, IIgnoreConfiguration ignore);
    public sealed virtual IEnumerable`1<ICommit> GetMergedCommits(ICommit mergeCommit, int index, IIgnoreConfiguration ignore);
    private static ICommit GetMergedHead(ICommit mergeCommit);
    public sealed virtual VersionField GetIncrementForcedByCommit(ICommit commit, IGitVersionConfiguration configuration);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.INextVersionCalculator {
    public abstract virtual SemanticVersion FindVersion();
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IVariableProvider {
    public abstract virtual GitVersionVariables GetVariablesFor(SemanticVersion semanticVersion, IGitVersionConfiguration configuration, int preReleaseWeight);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IVersionFilter {
    public abstract virtual bool Exclude(IBaseVersion baseVersion, String& reason);
}
[NullableContextAttribute("1")]
public interface GitVersion.VersionCalculation.IVersionStrategy {
    public abstract virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
}
internal class GitVersion.VersionCalculation.Mainline.EnrichIncrement : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
private static VersionField GetIncrementForcedByCommit(MainlineContext context, ICommit commit, EffectiveConfiguration configuration);
}
internal class GitVersion.VersionCalculation.Mainline.EnrichSemanticVersion : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
internal interface GitVersion.VersionCalculation.Mainline.IContextPostEnricher {
    public abstract virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
internal interface GitVersion.VersionCalculation.Mainline.IContextPreEnricher {
    public abstract virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
internal interface GitVersion.VersionCalculation.Mainline.IIncrementer {
    public abstract virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    public abstract virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("\{ BranchName = {BranchName}, Increment = {Increment}, HasSuccessor = {HasSuccessor}, HasPredecessor = {HasPredecessor}, HasChildIteration = {HasChildIteration}, Message = {Message} \}")]
internal class GitVersion.VersionCalculation.Mainline.MainlineCommit : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICommit <value>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionField <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private MainlineIteration <Iteration>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceName <BranchName>k__BackingField;
    [CompilerGeneratedAttribute]
private IBranchConfiguration <Configuration>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MainlineCommit <Successor>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MainlineCommit <Predecessor>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MainlineIteration <ChildIteration>k__BackingField;
    private HashSet`1<SemanticVersion> semanticVersions;
    [NullableAttribute("2")]
private EffectiveConfiguration effectiveConfiguration;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("2")]
public ICommit value { get; public set; }
    public VersionField Increment { get; public set; }
    public MainlineIteration Iteration { get; }
    public ReferenceName BranchName { get; }
    private IBranchConfiguration Configuration { get; }
    public bool HasSuccessor { get; }
    [NullableAttribute("2")]
public MainlineCommit Successor { get; private set; }
    public bool HasPredecessor { get; }
    [NullableAttribute("2")]
public MainlineCommit Predecessor { get; private set; }
    public ICommit Value { get; }
    [MemberNotNullWhenAttribute("False", "Value")]
public bool IsDummy { get; }
    public string Message { get; }
    [NullableAttribute("2")]
public MainlineIteration ChildIteration { get; private set; }
    [MemberNotNullWhenAttribute("True", "ChildIteration")]
public bool HasChildIteration { get; }
    [NullableAttribute("2")]
public MainlineIteration ParentIteration { get; }
    [NullableAttribute("2")]
public MainlineCommit ParentCommit { get; }
    [MemberNotNullWhenAttribute("True", "Mono.Cecil.CustomAttributeArgument[]")]
private bool HasParentIteration { get; }
    public IReadOnlyCollection`1<SemanticVersion> SemanticVersions { get; }
    public MainlineCommit(MainlineIteration Iteration, ICommit value, ReferenceName BranchName, IBranchConfiguration Configuration);
    [CompilerGeneratedAttribute]
protected MainlineCommit(MainlineCommit original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICommit get_value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_value(ICommit value);
    public bool IsPredecessorTheLastCommitOnTrunk(IGitVersionConfiguration configuration);
    [CompilerGeneratedAttribute]
public VersionField get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(VersionField value);
    [CompilerGeneratedAttribute]
public MainlineIteration get_Iteration();
    [CompilerGeneratedAttribute]
public ReferenceName get_BranchName();
    [CompilerGeneratedAttribute]
private IBranchConfiguration get_Configuration();
    public bool get_HasSuccessor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MainlineCommit get_Successor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Successor(MainlineCommit value);
    public bool get_HasPredecessor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MainlineCommit get_Predecessor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Predecessor(MainlineCommit value);
    public ICommit get_Value();
    [MemberNotNullWhenAttribute("False", "Value")]
public bool get_IsDummy();
    public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MainlineIteration get_ChildIteration();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ChildIteration(MainlineIteration value);
    [MemberNotNullWhenAttribute("True", "ChildIteration")]
public bool get_HasChildIteration();
    [NullableContextAttribute("2")]
public MainlineIteration get_ParentIteration();
    [NullableContextAttribute("2")]
public MainlineCommit get_ParentCommit();
    [MemberNotNullWhenAttribute("True", "Mono.Cecil.CustomAttributeArgument[]")]
private bool get_HasParentIteration();
    public IReadOnlyCollection`1<SemanticVersion> get_SemanticVersions();
    public EffectiveConfiguration GetEffectiveConfiguration(IGitVersionConfiguration configuration);
    public VersionField GetIncrementForcedByBranch(IGitVersionConfiguration configuration);
    public void AddSemanticVersions(SemanticVersion[] values);
    public void AddSemanticVersions(IEnumerable`1<SemanticVersion> values);
    public void AddChildIteration(MainlineIteration iteration);
    public MainlineCommit Append(ICommit referenceValue, ReferenceName branchName, IBranchConfiguration configuration);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MainlineCommit left, MainlineCommit right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MainlineCommit left, MainlineCommit right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MainlineCommit other);
    [CompilerGeneratedAttribute]
public virtual MainlineCommit <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(MainlineIteration& Iteration, ICommit& value, ReferenceName& BranchName, IBranchConfiguration& Configuration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.MainlineContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IIncrementStrategyFinder <IncrementStrategyFinder>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IGitVersionConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <SemanticVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionField <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommit <BaseVersionSource>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private HashSet`1<SemanticVersion> <AlternativeSemanticVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceIncrement>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("1")]
public IIncrementStrategyFinder IncrementStrategyFinder { get; }
    [NullableAttribute("1")]
public IGitVersionConfiguration Configuration { get; }
    public string TargetLabel { get; public set; }
    public SemanticVersion SemanticVersion { get; public set; }
    public string Label { get; public set; }
    public VersionField Increment { get; public set; }
    public ICommit BaseVersionSource { get; public set; }
    [NullableAttribute("1")]
public HashSet`1<SemanticVersion> AlternativeSemanticVersions { get; }
    public bool ForceIncrement { get; public set; }
    [NullableContextAttribute("1")]
public MainlineContext(IIncrementStrategyFinder IncrementStrategyFinder, IGitVersionConfiguration Configuration);
    [CompilerGeneratedAttribute]
protected MainlineContext(MainlineContext original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IIncrementStrategyFinder get_IncrementStrategyFinder();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IGitVersionConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public string get_TargetLabel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetLabel(string value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_SemanticVersion();
    [CompilerGeneratedAttribute]
public void set_SemanticVersion(SemanticVersion value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public VersionField get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(VersionField value);
    [CompilerGeneratedAttribute]
public ICommit get_BaseVersionSource();
    [CompilerGeneratedAttribute]
public void set_BaseVersionSource(ICommit value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public HashSet`1<SemanticVersion> get_AlternativeSemanticVersions();
    [CompilerGeneratedAttribute]
public bool get_ForceIncrement();
    [CompilerGeneratedAttribute]
public void set_ForceIncrement(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MainlineContext left, MainlineContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MainlineContext left, MainlineContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MainlineContext other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual MainlineContext <Clone>$();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(IIncrementStrategyFinder& IncrementStrategyFinder, IGitVersionConfiguration& Configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("\{ Id = {Id}, BranchName = {BranchName}, Depth = {Depth}, NumberOfCommits = {NumberOfCommits}} \}")]
internal class GitVersion.VersionCalculation.Mainline.MainlineIteration : object {
    [CompilerGeneratedAttribute]
private IBranchConfiguration <Configuration>k__BackingField;
    [NullableAttribute("2")]
private EffectiveConfiguration effectiveConfiguration;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MainlineIteration <ParentIteration>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MainlineCommit <ParentCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceName <BranchName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    private Stack`1<MainlineCommit> commits;
    private Dictionary`2<ICommit, MainlineCommit> commitLookup;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IBranchConfiguration Configuration { get; }
    [NullableAttribute("2")]
public MainlineIteration ParentIteration { get; }
    [NullableAttribute("2")]
public MainlineCommit ParentCommit { get; }
    public string Id { get; }
    public ReferenceName BranchName { get; }
    public int Depth { get; }
    public int NumberOfCommits { get; }
    public IReadOnlyCollection`1<MainlineCommit> Commits { get; }
    public MainlineIteration(string id, ReferenceName branchName, IBranchConfiguration configuration, MainlineIteration parentIteration, MainlineCommit parentCommit);
    [CompilerGeneratedAttribute]
protected MainlineIteration(MainlineIteration original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IBranchConfiguration get_Configuration();
    public EffectiveConfiguration GetEffectiveConfiguration(IGitVersionConfiguration configuration);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MainlineIteration get_ParentIteration();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MainlineCommit get_ParentCommit();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ReferenceName get_BranchName();
    [CompilerGeneratedAttribute]
public int get_Depth();
    public int get_NumberOfCommits();
    public IReadOnlyCollection`1<MainlineCommit> get_Commits();
    public MainlineCommit CreateCommit(ICommit value, ReferenceName branchName, IBranchConfiguration configuration);
    public MainlineCommit FindCommit(ICommit commit);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MainlineIteration left, MainlineIteration right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MainlineIteration left, MainlineIteration right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MainlineIteration other);
    [CompilerGeneratedAttribute]
public virtual MainlineIteration <Clone>$();
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunk : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunk/<GetIncrements>d__1")]
public sealed virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkBranchedBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkBranchedBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkBranchedToNonTrunk : CommitOnNonTrunkBranchedBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkBranchedToTrunk : CommitOnNonTrunkBranchedBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithPreReleaseTag : CommitOnNonTrunkWithPreReleaseTagBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithPreReleaseTagBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithPreReleaseTagBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithStableTag : CommitOnNonTrunkWithStableTagBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithStableTagBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.CommitOnNonTrunkWithStableTagBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.FirstCommitOnRelease : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.FirstCommitOnRelease/<GetIncrements>d__1")]
public sealed virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.LastCommitOnNonTrunkWithPreReleaseTag : CommitOnNonTrunkWithPreReleaseTagBase {
    public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.LastCommitOnNonTrunkWithPreReleaseTag/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IBaseVersionIncrement> <>n__0(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.LastCommitOnNonTrunkWithStableTag : CommitOnNonTrunkWithStableTagBase {
    public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.LastCommitOnNonTrunkWithStableTag/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IBaseVersionIncrement> <>n__0(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.LastMergeCommitOnNonTrunk : MergeCommitOnNonTrunkBase {
    public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.LastMergeCommitOnNonTrunk/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IBaseVersionIncrement> <>n__0(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.NonTrunk.MergeCommitOnNonTrunk : MergeCommitOnNonTrunkBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.NonTrunk.MergeCommitOnNonTrunkBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.NonTrunk.MergeCommitOnNonTrunkBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.RemoveIncrement : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.RemoveSemanticVersion : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunk : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunk/<GetIncrements>d__1")]
public sealed virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkBranchedBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkBranchedBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkBranchedToNonTrunk : CommitOnTrunkBranchedBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkBranchedToTrunk : CommitOnTrunkBranchedBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithPreReleaseTag : CommitOnTrunkWithPreReleaseTagBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithPreReleaseTagBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithPreReleaseTagBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithStableTag : CommitOnTrunkWithStableTagBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithStableTagBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.CommitOnTrunkWithStableTagBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.Trunk.LastCommitOnTrunkWithPreReleaseTag : CommitOnTrunkWithPreReleaseTagBase {
    public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.LastCommitOnTrunkWithPreReleaseTag/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IBaseVersionIncrement> <>n__0(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.Mainline.Trunk.LastCommitOnTrunkWithStableTag : CommitOnTrunkWithStableTagBase {
    public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.LastCommitOnTrunkWithStableTag/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<IBaseVersionIncrement> <>n__0(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.LastMergeCommitOnTrunk : MergeCommitOnTrunkBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal class GitVersion.VersionCalculation.Mainline.Trunk.MergeCommitOnTrunk : MergeCommitOnTrunkBase {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
internal abstract class GitVersion.VersionCalculation.Mainline.Trunk.MergeCommitOnTrunkBase : object {
    [NullableContextAttribute("1")]
public virtual bool MatchPrecondition(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("GitVersion.VersionCalculation.Mainline.Trunk.MergeCommitOnTrunkBase/<GetIncrements>d__1")]
public virtual IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, MainlineCommit commit, MainlineContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.MainlineVersionStrategy : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) iterationCounter;
    private Lazy`1<GitVersionContext> contextLazy;
    private ITaggedSemanticVersionService taggedSemanticVersionService;
    private IRepositoryStore repositoryStore;
    private IIncrementStrategyFinder incrementStrategyFinder;
    private static IReadOnlyCollection`1<IContextPreEnricher> TrunkContextPreEnricherCollection;
    private static IReadOnlyCollection`1<IContextPostEnricher> TrunkContextPostEnricherCollection;
    private static IReadOnlyCollection`1<IIncrementer> TrunkIncrementerCollection;
    private GitVersionContext Context { get; }
    public MainlineVersionStrategy(Lazy`1<GitVersionContext> contextLazy, IRepositoryStore repositoryStore, ITaggedSemanticVersionService taggedSemanticVersionService, IIncrementStrategyFinder incrementStrategyFinder);
    private static MainlineVersionStrategy();
    private GitVersionContext get_Context();
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.MainlineVersionStrategy/<GetBaseVersions>d__11")]
public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    private MainlineIteration CreateIteration(ReferenceName branchName, IBranchConfiguration configuration, MainlineIteration parentIteration, MainlineCommit parentCommit);
    private bool IterateOverCommitsRecursive(IEnumerable`1<ICommit> commitsInReverseOrder, MainlineIteration iteration, IBranch targetBranch, string targetLabel, ILookup`2<ICommit, SemanticVersionWithTag> taggedSemanticVersions, HashSet`1<ICommit> traversedCommits);
    private IReadOnlyDictionary`2<ICommit, List`1<ValueTuple`2<IBranch, IBranchConfiguration>>> GetCommitsWasBranchedFrom(IBranch branch, IBranch[] excludedBranches);
    private static BaseVersion DetermineBaseVersion(MainlineIteration iteration, string targetLabel, IIncrementStrategyFinder incrementStrategyFinder, IGitVersionConfiguration configuration);
    internal static BaseVersion DetermineBaseVersionRecursive(MainlineIteration iteration, string targetLabel, IIncrementStrategyFinder incrementStrategyFinder, IGitVersionConfiguration configuration);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.MainlineVersionStrategy/<GetIncrements>d__17")]
private static IEnumerable`1<IBaseVersionIncrement> GetIncrements(MainlineIteration iteration, string targetLabel, IIncrementStrategyFinder incrementStrategyFinder, IGitVersionConfiguration configuration);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetCommitsWasBranchedFrom>b__14_2(ValueTuple`2<IBranch, IBranchConfiguration> element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.ManualDeploymentVersionCalculator : VersionCalculatorBase {
    public ManualDeploymentVersionCalculator(ILog log, IRepositoryStore repositoryStore, Lazy`1<GitVersionContext> versionContext);
    public sealed virtual SemanticVersion Calculate(SemanticVersion semanticVersion, ICommit baseVersionSource);
    private SemanticVersion CalculateInternal(SemanticVersion semanticVersion, ICommit baseVersionSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.MergeMessageVersionStrategy : object {
    private ILog log;
    private Lazy`1<GitVersionContext> contextLazy;
    private IRepositoryStore repositoryStore;
    private IIncrementStrategyFinder incrementStrategyFinder;
    private GitVersionContext Context { get; }
    public MergeMessageVersionStrategy(ILog log, Lazy`1<GitVersionContext> contextLazy, IRepositoryStore repositoryStore, IIncrementStrategyFinder incrementStrategyFinder);
    private GitVersionContext get_Context();
    public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.MergeMessageVersionStrategy/<GetBaseVersionsInternal>d__8")]
private IEnumerable`1<BaseVersion> GetBaseVersionsInternal(EffectiveBranchConfiguration configuration);
}
internal class GitVersion.VersionCalculation.MinDateVersionFilter : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <minimum>P;
    public MinDateVersionFilter(DateTimeOffset minimum);
    [NullableContextAttribute("1")]
public sealed virtual bool Exclude(IBaseVersion baseVersion, String& reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.VersionCalculation.NextVersion : object {
    [CompilerGeneratedAttribute]
private IBaseVersion <BaseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <IncrementedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private EffectiveBranchConfiguration <BranchConfiguration>k__BackingField;
    public IBaseVersion BaseVersion { get; }
    public SemanticVersion IncrementedVersion { get; }
    public EffectiveBranchConfiguration BranchConfiguration { get; }
    public EffectiveConfiguration Configuration { get; }
    public NextVersion(SemanticVersion incrementedVersion, IBaseVersion baseVersion, EffectiveBranchConfiguration configuration);
    [CompilerGeneratedAttribute]
public IBaseVersion get_BaseVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_IncrementedVersion();
    [CompilerGeneratedAttribute]
public EffectiveBranchConfiguration get_BranchConfiguration();
    public EffectiveConfiguration get_Configuration();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(NextVersion other);
    public static bool op_Equality(NextVersion left, NextVersion right);
    public static bool op_Inequality(NextVersion left, NextVersion right);
    public static bool op_LessThan(NextVersion left, NextVersion right);
    public static bool op_LessThanOrEqual(NextVersion left, NextVersion right);
    public static bool op_GreaterThan(NextVersion left, NextVersion right);
    public static bool op_GreaterThanOrEqual(NextVersion left, NextVersion right);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NextVersion other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.NextVersionCalculator : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IDeploymentModeCalculator> <deploymentModeCalculators>P;
    [CompilerGeneratedAttribute]
private ITaggedSemanticVersionService <taggedSemanticVersionService>P;
    private ILog log;
    private Lazy`1<GitVersionContext> versionContext;
    private IVersionStrategy[] versionStrategies;
    private IEffectiveBranchConfigurationFinder effectiveBranchConfigurationFinder;
    private GitVersionContext Context { get; }
    public NextVersionCalculator(ILog log, Lazy`1<GitVersionContext> versionContext, IEnumerable`1<IDeploymentModeCalculator> deploymentModeCalculators, IEnumerable`1<IVersionStrategy> versionStrategies, IEffectiveBranchConfigurationFinder effectiveBranchConfigurationFinder, ITaggedSemanticVersionService taggedSemanticVersionService);
    private GitVersionContext get_Context();
    public virtual SemanticVersion FindVersion();
    private bool TryGetSemanticVersion(EffectiveConfiguration effectiveConfiguration, IReadOnlyCollection`1<SemanticVersionWithTag> taggedSemanticVersionsOfCurrentCommit, SemanticVersion& result);
    private SemanticVersion CalculateSemanticVersion(DeploymentMode deploymentMode, SemanticVersion semanticVersion, ICommit baseVersionSource);
    private NextVersion CalculateNextVersion(IBranch branch, IGitVersionConfiguration configuration);
    private static NextVersion CompareVersions(NextVersion version1, NextVersion version2);
    private IReadOnlyCollection`1<NextVersion> GetNextVersions(IBranch branch, IGitVersionConfiguration configuration);
    private bool IncludeVersion(IBaseVersion baseVersion, IIgnoreConfiguration ignoreConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.ShaVersionFilter : object {
    private IEnumerable`1<string> shaList;
    public ShaVersionFilter(IEnumerable`1<string> shaList);
    public sealed virtual bool Exclude(IBaseVersion baseVersion, String& reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.TaggedCommitVersionStrategy : object {
    private ITaggedSemanticVersionService taggedSemanticVersionService;
    private Lazy`1<GitVersionContext> contextLazy;
    private IIncrementStrategyFinder incrementStrategyFinder;
    private GitVersionContext Context { get; }
    public TaggedCommitVersionStrategy(Lazy`1<GitVersionContext> contextLazy, ITaggedSemanticVersionService taggedSemanticVersionService, IIncrementStrategyFinder incrementStrategyFinder);
    private GitVersionContext get_Context();
    public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.TaggedCommitVersionStrategy/<GetBaseVersionsInternal>d__7")]
private IEnumerable`1<BaseVersion> GetBaseVersionsInternal(EffectiveBranchConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.TrackReleaseBranchesVersionStrategy : object {
    private Lazy`1<GitVersionContext> contextLazy;
    private IRepositoryStore repositoryStore;
    private IBranchRepository branchRepository;
    private IIncrementStrategyFinder incrementStrategyFinder;
    private VersionInBranchNameVersionStrategy releaseVersionStrategy;
    private GitVersionContext Context { get; }
    public TrackReleaseBranchesVersionStrategy(Lazy`1<GitVersionContext> contextLazy, IRepositoryStore repositoryStore, IBranchRepository branchRepository, IIncrementStrategyFinder incrementStrategyFinder);
    private GitVersionContext get_Context();
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.TrackReleaseBranchesVersionStrategy/<GetBaseVersions>d__8")]
public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    private bool TryGetBaseVersion(IBranch releaseBranch, EffectiveBranchConfiguration configuration, BaseVersion& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.VariableProvider : object {
    private IEnvironment environment;
    public VariableProvider(IEnvironment environment);
    public sealed virtual GitVersionVariables GetVariablesFor(SemanticVersion semanticVersion, IGitVersionConfiguration configuration, int preReleaseWeight);
    [NullableContextAttribute("2")]
private string CheckAndFormatString(string formatString, T source, string defaultValue, string formatVarName);
}
public class GitVersion.VersionCalculation.VersionCalculationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void RegisterTypes(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class GitVersion.VersionCalculation.VersionCalculatorBase : object {
    protected ILog log;
    protected IRepositoryStore repositoryStore;
    private Lazy`1<GitVersionContext> versionContext;
    protected GitVersionContext Context { get; }
    protected VersionCalculatorBase(ILog log, IRepositoryStore repositoryStore, Lazy`1<GitVersionContext> versionContext);
    protected GitVersionContext get_Context();
    protected SemanticVersionBuildMetaData CreateVersionBuildMetaData(ICommit baseVersionSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class GitVersion.VersionCalculation.VersionInBranchNameVersionStrategy : object {
    private Lazy`1<GitVersionContext> contextLazy;
    private GitVersionContext Context { get; }
    public VersionInBranchNameVersionStrategy(Lazy`1<GitVersionContext> contextLazy);
    private GitVersionContext get_Context();
    [IteratorStateMachineAttribute("GitVersion.VersionCalculation.VersionInBranchNameVersionStrategy/<GetBaseVersions>d__4")]
public sealed virtual IEnumerable`1<BaseVersion> GetBaseVersions(EffectiveBranchConfiguration configuration);
    public bool TryGetBaseVersion(EffectiveBranchConfiguration configuration, BaseVersion& baseVersion);
}
[FlagsAttribute]
public enum GitVersion.VersionCalculation.VersionStrategies : Enum {
    public int value__;
    public static VersionStrategies None;
    public static VersionStrategies Fallback;
    public static VersionStrategies ConfiguredNextVersion;
    public static VersionStrategies MergeMessage;
    public static VersionStrategies TaggedCommit;
    public static VersionStrategies TrackReleaseBranches;
    public static VersionStrategies VersionInBranchName;
    public static VersionStrategies Mainline;
}
public class GitVersion.VersionCalculation.VersionStrategyModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void RegisterTypes(IServiceCollection services);
}
public enum GitVersion.VersionField : Enum {
    public int value__;
    public static VersionField None;
    public static VersionField Patch;
    public static VersionField Minor;
    public static VersionField Major;
}
public class GitVersion.WarningException : Exception {
    [NullableContextAttribute("1")]
public WarningException(string message);
    [NullableContextAttribute("2")]
public WarningException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class GitVersion.WixInfo : object {
    public bool UpdateWixVersionFile;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected WixInfo(WixInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(WixInfo left, WixInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(WixInfo left, WixInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(WixInfo other);
    [CompilerGeneratedAttribute]
public virtual WixInfo <Clone>$();
}
