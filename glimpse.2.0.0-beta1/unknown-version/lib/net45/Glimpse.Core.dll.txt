internal class Antlr.Runtime.ANTLRFileStream : ANTLRStringStream {
    protected string fileName;
    public string SourceName { get; }
    public ANTLRFileStream(string fileName);
    public ANTLRFileStream(string fileName, Encoding encoding);
    public virtual void Load(string fileName, Encoding encoding);
    public virtual string get_SourceName();
}
internal class Antlr.Runtime.ANTLRInputStream : ANTLRReaderStream {
    public ANTLRInputStream(Stream input);
    public ANTLRInputStream(Stream input, int size);
    public ANTLRInputStream(Stream input, Encoding encoding);
    public ANTLRInputStream(Stream input, int size, Encoding encoding);
    public ANTLRInputStream(Stream input, int size, int readBufferSize, Encoding encoding);
    private static StreamReader GetStreamReader(Stream input, Encoding encoding);
}
internal class Antlr.Runtime.ANTLRReaderStream : ANTLRStringStream {
    public static int ReadBufferSize;
    public static int InitialBufferSize;
    public ANTLRReaderStream(TextReader r);
    public ANTLRReaderStream(TextReader r, int size);
    public ANTLRReaderStream(TextReader r, int size, int readChunkSize);
    public virtual void Load(TextReader r, int size, int readChunkSize);
}
internal class Antlr.Runtime.ANTLRStringStream : object {
    protected Char[] data;
    protected int n;
    protected int p;
    private int line;
    private int charPositionInLine;
    protected int markDepth;
    protected IList`1<CharStreamState> markers;
    protected int lastMarker;
    public string name;
    public int Index { get; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Count { get; }
    public string SourceName { get; }
    public ANTLRStringStream(string input);
    public ANTLRStringStream(string input, string sourceName);
    public ANTLRStringStream(Char[] data, int numberOfActualCharsInArray);
    public ANTLRStringStream(Char[] data, int numberOfActualCharsInArray, string sourceName);
    public virtual int get_Index();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_CharPositionInLine();
    public virtual void set_CharPositionInLine(int value);
    public virtual void Reset();
    public virtual void Consume();
    public virtual int LA(int i);
    public virtual int LT(int i);
    public virtual int get_Count();
    public virtual int Mark();
    public virtual void Rewind(int m);
    public virtual void Rewind();
    public virtual void Release(int marker);
    public virtual void Seek(int index);
    public virtual string Substring(int start, int length);
    public virtual string get_SourceName();
    public virtual string ToString();
}
internal class Antlr.Runtime.AstParserRuleReturnScope`2 : ParserRuleReturnScope`1<TToken> {
    private TTree _tree;
    public TTree Tree { get; public set; }
    private object Antlr.Runtime.IAstRuleReturnScope.Tree { get; }
    public sealed virtual TTree get_Tree();
    public void set_Tree(TTree value);
    private sealed virtual override object Antlr.Runtime.IAstRuleReturnScope.get_Tree();
}
internal abstract class Antlr.Runtime.BaseRecognizer : object {
    public static int MemoRuleFailed;
    public static int MemoRuleUnknown;
    public static int InitialFollowStackSize;
    public static int DefaultTokenChannel;
    public static int Hidden;
    public static string NextTokenRuleName;
    protected internal RecognizerSharedState state;
    [CompilerGeneratedAttribute]
private TextWriter <TraceDestination>k__BackingField;
    public TextWriter TraceDestination { get; public set; }
    public int NumberOfSyntaxErrors { get; }
    public int BacktrackingLevel { get; public set; }
    public bool Failed { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public string SourceName { get; }
    public IDebugEventListener DebugListener { get; }
    public BaseRecognizer(RecognizerSharedState state);
    [CompilerGeneratedAttribute]
public TextWriter get_TraceDestination();
    [CompilerGeneratedAttribute]
public void set_TraceDestination(TextWriter value);
    public virtual void SetState(RecognizerSharedState value);
    protected virtual void InitDFAs();
    public virtual void Reset();
    public virtual object Match(IIntStream input, int ttype, BitSet follow);
    public virtual void MatchAny(IIntStream input);
    public virtual bool MismatchIsUnwantedToken(IIntStream input, int ttype);
    public virtual bool MismatchIsMissingToken(IIntStream input, BitSet follow);
    public virtual void ReportError(RecognitionException e);
    public virtual void DisplayRecognitionError(String[] tokenNames, RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    public virtual int get_NumberOfSyntaxErrors();
    public virtual string GetErrorHeader(RecognitionException e);
    public virtual string GetTokenErrorDisplay(IToken t);
    public virtual void EmitErrorMessage(string msg);
    public virtual void Recover(IIntStream input, RecognitionException re);
    public virtual void BeginResync();
    public virtual void EndResync();
    protected virtual BitSet ComputeErrorRecoverySet();
    protected virtual BitSet ComputeContextSensitiveRuleFOLLOW();
    protected virtual BitSet CombineFollows(bool exact);
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public virtual object RecoverFromMismatchedSet(IIntStream input, RecognitionException e, BitSet follow);
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual void ConsumeUntil(IIntStream input, int tokenType);
    public virtual void ConsumeUntil(IIntStream input, BitSet set);
    protected void PushFollow(BitSet fset);
    protected void PopFollow();
    public virtual IList`1<string> GetRuleInvocationStack();
    public static IList`1<string> GetRuleInvocationStack(StackTrace trace);
    public virtual int get_BacktrackingLevel();
    public virtual void set_BacktrackingLevel(int value);
    public virtual bool get_Failed();
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    public abstract virtual string get_SourceName();
    public virtual List`1<string> ToStrings(ICollection`1<IToken> tokens);
    public virtual int GetRuleMemoization(int ruleIndex, int ruleStartIndex);
    public virtual bool AlreadyParsedRule(IIntStream input, int ruleIndex);
    public virtual void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex);
    public virtual int GetRuleMemoizationCacheSize();
    public virtual void TraceIn(string ruleName, int ruleIndex, object inputSymbol);
    public virtual void TraceOut(string ruleName, int ruleIndex, object inputSymbol);
    public virtual IDebugEventListener get_DebugListener();
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterRule(string grammarFileName, string ruleName);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitRule(string grammarFileName, string ruleName);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterSubRule(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitSubRule(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterAlt(int alt);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterDecision(int decisionNumber, bool couldBacktrack);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitDecision(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugLocation(int line, int charPositionInLine);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugSemanticPredicate(bool result, string predicate);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugBeginBacktrack(int level);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEndBacktrack(int level, bool successful);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugRecognitionException(RecognitionException ex);
}
internal class Antlr.Runtime.BitSet : object {
    private static int BITS;
    private static int LOG_BITS;
    private static int MOD_MASK;
    private UInt64[] _bits;
    [CLSCompliantAttribute("False")]
public BitSet(UInt64[] bits);
    public BitSet(IEnumerable`1<int> items);
    public BitSet(int nbits);
    public static BitSet Of(int el);
    public static BitSet Of(int a, int b);
    public static BitSet Of(int a, int b, int c);
    public static BitSet Of(int a, int b, int c, int d);
    public BitSet Or(BitSet a);
    public void Add(int el);
    public void GrowToInclude(int bit);
    public void OrInPlace(BitSet a);
    private void SetSize(int nwords);
    private static ulong BitMask(int bitNumber);
    public sealed virtual object Clone();
    public int Size();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public bool Member(int el);
    public void Remove(int el);
    public bool IsNil();
    private static int NumWordsToHold(int el);
    public int NumBits();
    public int LengthInLongWords();
    public Int32[] ToArray();
    private static int WordNumber(int bit);
    public virtual string ToString();
    public string ToString(String[] tokenNames);
}
internal class Antlr.Runtime.BufferedTokenStream : object {
    private ITokenSource _tokenSource;
    [CLSCompliantAttribute("False")]
protected List`1<IToken> _tokens;
    private int _lastMarker;
    [CLSCompliantAttribute("False")]
protected int _p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public ITokenSource TokenSource { get; public set; }
    public int Index { get; }
    public int Range { get; protected set; }
    public int Count { get; }
    public string SourceName { get; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public BufferedTokenStream(ITokenSource tokenSource);
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual int get_Index();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual int get_Count();
    public virtual string get_SourceName();
    public virtual IToken get_LastToken();
    public virtual IToken get_LastRealToken();
    public virtual int get_MaxLookBehind();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual void Consume();
    protected virtual void Sync(int i);
    protected virtual void Fetch(int n);
    public virtual IToken Get(int i);
    public virtual int LA(int i);
    protected virtual IToken LB(int k);
    public virtual IToken LT(int k);
    protected virtual void Setup();
    public virtual List`1<IToken> GetTokens();
    public virtual List`1<IToken> GetTokens(int start, int stop);
    public virtual List`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual List`1<IToken> GetTokens(int start, int stop, IEnumerable`1<int> types);
    public virtual List`1<IToken> GetTokens(int start, int stop, int ttype);
    public virtual string ToString();
    public virtual string ToString(int start, int stop);
    public virtual string ToString(IToken start, IToken stop);
    public virtual void Fill();
}
internal static class Antlr.Runtime.CharStreamConstants : object {
    public static int EndOfFile;
}
internal class Antlr.Runtime.CharStreamState : object {
    public int p;
    public int line;
    public int charPositionInLine;
}
internal class Antlr.Runtime.ClassicToken : object {
    private string text;
    private int type;
    private int line;
    private int charPositionInLine;
    private int channel;
    private int index;
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public ClassicToken(int type);
    public ClassicToken(IToken oldToken);
    public ClassicToken(int type, string text);
    public ClassicToken(int type, string text, int channel);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public sealed virtual int get_Line();
    public sealed virtual void set_Line(int value);
    public sealed virtual int get_CharPositionInLine();
    public sealed virtual void set_CharPositionInLine(int value);
    public sealed virtual int get_Channel();
    public sealed virtual void set_Channel(int value);
    public sealed virtual int get_StartIndex();
    public sealed virtual void set_StartIndex(int value);
    public sealed virtual int get_StopIndex();
    public sealed virtual void set_StopIndex(int value);
    public sealed virtual int get_TokenIndex();
    public sealed virtual void set_TokenIndex(int value);
    public sealed virtual ICharStream get_InputStream();
    public sealed virtual void set_InputStream(ICharStream value);
    public virtual string ToString();
}
internal class Antlr.Runtime.CommonToken : object {
    private int type;
    private int line;
    private int charPositionInLine;
    private int channel;
    private ICharStream input;
    private string text;
    private int index;
    private int start;
    private int stop;
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public CommonToken(int type);
    public CommonToken(ICharStream input, int type, int channel, int start, int stop);
    public CommonToken(int type, string text);
    public CommonToken(IToken oldToken);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public sealed virtual int get_Line();
    public sealed virtual void set_Line(int value);
    public sealed virtual int get_CharPositionInLine();
    public sealed virtual void set_CharPositionInLine(int value);
    public sealed virtual int get_Channel();
    public sealed virtual void set_Channel(int value);
    public sealed virtual int get_StartIndex();
    public sealed virtual void set_StartIndex(int value);
    public sealed virtual int get_StopIndex();
    public sealed virtual void set_StopIndex(int value);
    public sealed virtual int get_TokenIndex();
    public sealed virtual void set_TokenIndex(int value);
    public sealed virtual ICharStream get_InputStream();
    public sealed virtual void set_InputStream(ICharStream value);
    public virtual string ToString();
    [OnSerializingAttribute]
internal void OnSerializing(StreamingContext context);
}
internal class Antlr.Runtime.CommonTokenStream : BufferedTokenStream {
    private int _channel;
    public int Channel { get; }
    public ITokenSource TokenSource { get; public set; }
    public CommonTokenStream(ITokenSource tokenSource);
    public CommonTokenStream(ITokenSource tokenSource, int channel);
    public int get_Channel();
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual void Consume();
    protected virtual IToken LB(int k);
    public virtual IToken LT(int k);
    protected virtual int SkipOffTokenChannels(int i);
    protected virtual int SkipOffTokenChannelsReverse(int i);
    public virtual void Reset();
    protected virtual void Setup();
}
internal interface Antlr.Runtime.Debug.IDebugEventListener {
    public abstract virtual void Initialize();
    public abstract virtual void EnterRule(string grammarFileName, string ruleName);
    public abstract virtual void EnterAlt(int alt);
    public abstract virtual void ExitRule(string grammarFileName, string ruleName);
    public abstract virtual void EnterSubRule(int decisionNumber);
    public abstract virtual void ExitSubRule(int decisionNumber);
    public abstract virtual void EnterDecision(int decisionNumber, bool couldBacktrack);
    public abstract virtual void ExitDecision(int decisionNumber);
    public abstract virtual void ConsumeToken(IToken t);
    public abstract virtual void ConsumeHiddenToken(IToken t);
    public abstract virtual void LT(int i, IToken t);
    public abstract virtual void Mark(int marker);
    public abstract virtual void Rewind(int marker);
    public abstract virtual void Rewind();
    public abstract virtual void BeginBacktrack(int level);
    public abstract virtual void EndBacktrack(int level, bool successful);
    public abstract virtual void Location(int line, int pos);
    public abstract virtual void RecognitionException(RecognitionException e);
    public abstract virtual void BeginResync();
    public abstract virtual void EndResync();
    public abstract virtual void SemanticPredicate(bool result, string predicate);
    public abstract virtual void Commence();
    public abstract virtual void Terminate();
    public abstract virtual void ConsumeNode(object t);
    public abstract virtual void LT(int i, object t);
    public abstract virtual void NilNode(object t);
    public abstract virtual void ErrorNode(object t);
    public abstract virtual void CreateNode(object t);
    public abstract virtual void CreateNode(object node, IToken token);
    public abstract virtual void BecomeRoot(object newRoot, object oldRoot);
    public abstract virtual void AddChild(object root, object child);
    public abstract virtual void SetTokenBoundaries(object t, int tokenStartIndex, int tokenStopIndex);
}
internal class Antlr.Runtime.DFA : object {
    protected Int16[] eot;
    protected Int16[] eof;
    protected Char[] min;
    protected Char[] max;
    protected Int16[] accept;
    protected Int16[] special;
    protected Int16[][] transition;
    protected int decisionNumber;
    protected BaseRecognizer recognizer;
    public bool debug;
    [CompilerGeneratedAttribute]
private SpecialStateTransitionHandler <SpecialStateTransition>k__BackingField;
    public string Description { get; }
    public SpecialStateTransitionHandler SpecialStateTransition { get; private set; }
    public DFA(SpecialStateTransitionHandler specialStateTransition);
    public virtual string get_Description();
    public virtual int Predict(IIntStream input);
    protected virtual void NoViableAlt(int s, IIntStream input);
    public virtual void Error(NoViableAltException nvae);
    [CompilerGeneratedAttribute]
public SpecialStateTransitionHandler get_SpecialStateTransition();
    [CompilerGeneratedAttribute]
private void set_SpecialStateTransition(SpecialStateTransitionHandler value);
    private static int SpecialStateTransitionDefault(DFA dfa, int s, IIntStream input);
    public static Int16[] UnpackEncodedString(string encodedString);
    public static Char[] UnpackEncodedStringToUnsignedChars(string encodedString);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugRecognitionException(RecognitionException ex);
}
internal class Antlr.Runtime.EarlyExitException : RecognitionException {
    private int _decisionNumber;
    public int DecisionNumber { get; }
    public EarlyExitException(string message);
    public EarlyExitException(string message, Exception innerException);
    public EarlyExitException(int decisionNumber, IIntStream input);
    public EarlyExitException(string message, int decisionNumber, IIntStream input);
    public EarlyExitException(string message, int decisionNumber, IIntStream input, Exception innerException);
    protected EarlyExitException(SerializationInfo info, StreamingContext context);
    public int get_DecisionNumber();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Antlr.Runtime.FailedPredicateException : RecognitionException {
    private string _ruleName;
    private string _predicateText;
    public string RuleName { get; }
    public string PredicateText { get; }
    public FailedPredicateException(string message);
    public FailedPredicateException(string message, Exception innerException);
    public FailedPredicateException(IIntStream input, string ruleName, string predicateText);
    public FailedPredicateException(string message, IIntStream input, string ruleName, string predicateText);
    public FailedPredicateException(string message, IIntStream input, string ruleName, string predicateText, Exception innerException);
    protected FailedPredicateException(SerializationInfo info, StreamingContext context);
    public string get_RuleName();
    public string get_PredicateText();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("64")]
internal class Antlr.Runtime.GrammarRuleAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public GrammarRuleAttribute(string name);
    public string get_Name();
}
internal interface Antlr.Runtime.IAstRuleReturnScope {
    public object Tree { get; }
    public abstract virtual object get_Tree();
}
internal interface Antlr.Runtime.IAstRuleReturnScope`1 {
    public TAstLabel Tree { get; }
    public abstract virtual TAstLabel get_Tree();
}
internal interface Antlr.Runtime.ICharStream {
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public abstract virtual string Substring(int start, int length);
    public abstract virtual int LT(int i);
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual void set_CharPositionInLine(int value);
}
internal interface Antlr.Runtime.IIntStream {
    public int Index { get; }
    public int Count { get; }
    public string SourceName { get; }
    public abstract virtual void Consume();
    public abstract virtual int LA(int i);
    public abstract virtual int Mark();
    public abstract virtual int get_Index();
    public abstract virtual void Rewind(int marker);
    public abstract virtual void Rewind();
    public abstract virtual void Release(int marker);
    public abstract virtual void Seek(int index);
    public abstract virtual int get_Count();
    public abstract virtual string get_SourceName();
}
internal interface Antlr.Runtime.IRuleReturnScope {
    public object Start { get; }
    public object Stop { get; }
    public abstract virtual object get_Start();
    public abstract virtual object get_Stop();
}
internal interface Antlr.Runtime.IRuleReturnScope`1 {
    public TLabel Start { get; }
    public TLabel Stop { get; }
    public abstract virtual TLabel get_Start();
    public abstract virtual TLabel get_Stop();
}
internal interface Antlr.Runtime.ITemplateRuleReturnScope {
    public object Template { get; }
    public abstract virtual object get_Template();
}
internal interface Antlr.Runtime.ITemplateRuleReturnScope`1 {
    public TTemplate Template { get; }
    public abstract virtual TTemplate get_Template();
}
internal interface Antlr.Runtime.IToken {
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual void set_CharPositionInLine(int value);
    public abstract virtual int get_Channel();
    public abstract virtual void set_Channel(int value);
    public abstract virtual int get_StartIndex();
    public abstract virtual void set_StartIndex(int value);
    public abstract virtual int get_StopIndex();
    public abstract virtual void set_StopIndex(int value);
    public abstract virtual int get_TokenIndex();
    public abstract virtual void set_TokenIndex(int value);
    public abstract virtual ICharStream get_InputStream();
    public abstract virtual void set_InputStream(ICharStream value);
}
internal interface Antlr.Runtime.ITokenSource {
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public abstract virtual IToken NextToken();
    public abstract virtual string get_SourceName();
    public abstract virtual String[] get_TokenNames();
}
internal interface Antlr.Runtime.ITokenStream {
    public int Range { get; }
    public ITokenSource TokenSource { get; }
    public abstract virtual IToken LT(int k);
    public abstract virtual int get_Range();
    public abstract virtual IToken Get(int i);
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual string ToString(int start, int stop);
    public abstract virtual string ToString(IToken start, IToken stop);
}
internal interface Antlr.Runtime.ITokenStreamInformation {
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public abstract virtual IToken get_LastToken();
    public abstract virtual IToken get_LastRealToken();
    public abstract virtual int get_MaxLookBehind();
}
internal class Antlr.Runtime.LegacyCommonTokenStream : object {
    private ITokenSource _tokenSource;
    protected List`1<IToken> tokens;
    protected IDictionary`2<int, int> channelOverrideMap;
    protected List`1<int> discardSet;
    protected int channel;
    protected bool discardOffChannelTokens;
    protected int lastMarker;
    protected int p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public int Index { get; }
    public int Range { get; protected set; }
    public int Count { get; }
    public ITokenSource TokenSource { get; }
    public string SourceName { get; }
    public LegacyCommonTokenStream(ITokenSource tokenSource);
    public LegacyCommonTokenStream(ITokenSource tokenSource, int channel);
    public virtual int get_Index();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual void SetTokenSource(ITokenSource tokenSource);
    public virtual void FillBuffer();
    public virtual void Consume();
    protected virtual int SkipOffTokenChannels(int i);
    protected virtual int SkipOffTokenChannelsReverse(int i);
    public virtual void SetTokenTypeChannel(int ttype, int channel);
    public virtual void DiscardTokenType(int ttype);
    public virtual void SetDiscardOffChannelTokens(bool discardOffChannelTokens);
    public virtual IList`1<IToken> GetTokens();
    public virtual IList`1<IToken> GetTokens(int start, int stop);
    public virtual IList`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, IList`1<int> types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, int ttype);
    public virtual IToken LT(int k);
    protected virtual IToken LB(int k);
    public virtual IToken Get(int i);
    public virtual int LA(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Count();
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual ITokenSource get_TokenSource();
    public virtual string get_SourceName();
    public virtual string ToString();
    public virtual string ToString(int start, int stop);
    public virtual string ToString(IToken start, IToken stop);
}
internal abstract class Antlr.Runtime.Lexer : BaseRecognizer {
    protected ICharStream input;
    public string Text { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public ICharStream CharStream { get; public set; }
    public string SourceName { get; }
    public int CharIndex { get; }
    public Lexer(ICharStream input);
    public Lexer(ICharStream input, RecognizerSharedState state);
    public string get_Text();
    public void set_Text(string value);
    public int get_Line();
    public void set_Line(int value);
    public int get_CharPositionInLine();
    public void set_CharPositionInLine(int value);
    public virtual void Reset();
    public virtual IToken NextToken();
    public virtual void Skip();
    public abstract virtual void mTokens();
    public virtual ICharStream get_CharStream();
    public virtual void set_CharStream(ICharStream value);
    public virtual string get_SourceName();
    public virtual void Emit(IToken token);
    public virtual IToken Emit();
    public virtual void Match(string s);
    public virtual void MatchAny();
    public virtual void Match(int c);
    public virtual void MatchRange(int a, int b);
    public virtual int get_CharIndex();
    public virtual void ReportError(RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    public virtual string GetCharErrorDisplay(int c);
    public virtual void Recover(RecognitionException re);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
    protected virtual void ParseNextToken();
}
internal class Antlr.Runtime.Misc.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class Antlr.Runtime.Misc.FastQueue`1 : object {
    internal List`1<T> _data;
    internal int _p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public int Count { get; }
    public int Range { get; protected set; }
    public T Item { get; }
    public virtual int get_Count();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual T get_Item(int i);
    public virtual T Dequeue();
    public virtual void Enqueue(T o);
    public virtual T Peek();
    public virtual void Clear();
    public virtual string ToString();
}
internal class Antlr.Runtime.Misc.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class Antlr.Runtime.Misc.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class Antlr.Runtime.Misc.ListStack`1 : List`1<T> {
    public T Peek();
    public T Peek(int depth);
    public bool TryPeek(T& item);
    public bool TryPeek(int depth, T& item);
    public T Pop();
    public bool TryPop(T& item);
    public void Push(T item);
}
internal abstract class Antlr.Runtime.Misc.LookaheadStream`1 : FastQueue`1<T> {
    private int _currentElementIndex;
    private T _previousElement;
    private T _eof;
    private int _lastMarker;
    private int _markDepth;
    public T EndOfFile { get; protected set; }
    public T PreviousElement { get; }
    public int Count { get; }
    public int Index { get; }
    public T get_EndOfFile();
    protected void set_EndOfFile(T value);
    public T get_PreviousElement();
    public virtual void Clear();
    public abstract virtual T NextElement();
    public abstract virtual bool IsEndOfFile(T o);
    public virtual T Dequeue();
    public virtual void Consume();
    protected virtual void SyncAhead(int need);
    public virtual void Fill(int n);
    public virtual int get_Count();
    public virtual T LT(int k);
    public virtual int get_Index();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Seek(int index);
    protected virtual T LB(int k);
}
internal class Antlr.Runtime.MismatchedNotSetException : MismatchedSetException {
    public MismatchedNotSetException(string message);
    public MismatchedNotSetException(string message, Exception innerException);
    public MismatchedNotSetException(BitSet expecting, IIntStream input);
    public MismatchedNotSetException(string message, BitSet expecting, IIntStream input);
    public MismatchedNotSetException(string message, BitSet expecting, IIntStream input, Exception innerException);
    protected MismatchedNotSetException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.MismatchedRangeException : RecognitionException {
    private int _a;
    private int _b;
    public int A { get; }
    public int B { get; }
    public MismatchedRangeException(string message);
    public MismatchedRangeException(string message, Exception innerException);
    public MismatchedRangeException(int a, int b, IIntStream input);
    public MismatchedRangeException(string message, int a, int b, IIntStream input);
    public MismatchedRangeException(string message, int a, int b, IIntStream input, Exception innerException);
    protected MismatchedRangeException(SerializationInfo info, StreamingContext context);
    public int get_A();
    public int get_B();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.MismatchedSetException : RecognitionException {
    private BitSet _expecting;
    public BitSet Expecting { get; }
    public MismatchedSetException(string message);
    public MismatchedSetException(string message, Exception innerException);
    public MismatchedSetException(BitSet expecting, IIntStream input);
    public MismatchedSetException(string message, BitSet expecting, IIntStream input);
    public MismatchedSetException(string message, BitSet expecting, IIntStream input, Exception innerException);
    protected MismatchedSetException(SerializationInfo info, StreamingContext context);
    public BitSet get_Expecting();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.MismatchedTokenException : RecognitionException {
    private int _expecting;
    private ReadOnlyCollection`1<string> _tokenNames;
    public int Expecting { get; }
    public ReadOnlyCollection`1<string> TokenNames { get; }
    public MismatchedTokenException(string message);
    public MismatchedTokenException(string message, Exception innerException);
    public MismatchedTokenException(int expecting, IIntStream input);
    public MismatchedTokenException(int expecting, IIntStream input, IList`1<string> tokenNames);
    public MismatchedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames);
    public MismatchedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames, Exception innerException);
    protected MismatchedTokenException(SerializationInfo info, StreamingContext context);
    public int get_Expecting();
    public ReadOnlyCollection`1<string> get_TokenNames();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.MismatchedTreeNodeException : RecognitionException {
    private int _expecting;
    public int Expecting { get; }
    public MismatchedTreeNodeException(string message);
    public MismatchedTreeNodeException(string message, Exception innerException);
    public MismatchedTreeNodeException(int expecting, ITreeNodeStream input);
    public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input);
    public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input, Exception innerException);
    protected MismatchedTreeNodeException(SerializationInfo info, StreamingContext context);
    public int get_Expecting();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.MissingTokenException : MismatchedTokenException {
    private object _inserted;
    public int MissingType { get; }
    public MissingTokenException(string message);
    public MissingTokenException(string message, Exception innerException);
    public MissingTokenException(int expecting, IIntStream input, object inserted);
    public MissingTokenException(int expecting, IIntStream input, object inserted, IList`1<string> tokenNames);
    public MissingTokenException(string message, int expecting, IIntStream input, object inserted, IList`1<string> tokenNames);
    public MissingTokenException(string message, int expecting, IIntStream input, object inserted, IList`1<string> tokenNames, Exception innerException);
    protected MissingTokenException(SerializationInfo info, StreamingContext context);
    public virtual int get_MissingType();
    public virtual string ToString();
}
internal class Antlr.Runtime.NoViableAltException : RecognitionException {
    private string _grammarDecisionDescription;
    private int _decisionNumber;
    private int _stateNumber;
    public int DecisionNumber { get; }
    public string GrammarDecisionDescription { get; }
    public int StateNumber { get; }
    public NoViableAltException(string grammarDecisionDescription);
    public NoViableAltException(string message, string grammarDecisionDescription);
    public NoViableAltException(string message, string grammarDecisionDescription, Exception innerException);
    public NoViableAltException(string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input);
    public NoViableAltException(string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, Exception innerException);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k, Exception innerException);
    protected NoViableAltException(SerializationInfo info, StreamingContext context);
    public int get_DecisionNumber();
    public string get_GrammarDecisionDescription();
    public int get_StateNumber();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
internal class Antlr.Runtime.Parser : BaseRecognizer {
    public ITokenStream input;
    public ITokenStream TokenStream { get; public set; }
    public string SourceName { get; }
    public Parser(ITokenStream input);
    public Parser(ITokenStream input, RecognizerSharedState state);
    public virtual void Reset();
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual string get_SourceName();
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
}
internal class Antlr.Runtime.ParserRuleReturnScope`1 : object {
    private TToken _start;
    private TToken _stop;
    public TToken Start { get; public set; }
    public TToken Stop { get; public set; }
    private object Antlr.Runtime.IRuleReturnScope.Start { get; }
    private object Antlr.Runtime.IRuleReturnScope.Stop { get; }
    public sealed virtual TToken get_Start();
    public void set_Start(TToken value);
    public sealed virtual TToken get_Stop();
    public void set_Stop(TToken value);
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Start();
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Stop();
}
internal class Antlr.Runtime.RecognitionException : Exception {
    private IIntStream _input;
    private int _k;
    private int _index;
    private IToken _token;
    private object _node;
    private int _c;
    private int _line;
    private int _charPositionInLine;
    private bool _approximateLineInfo;
    public int UnexpectedType { get; }
    public bool ApproximateLineInfo { get; protected set; }
    public IIntStream Input { get; protected set; }
    public int Lookahead { get; }
    public IToken Token { get; public set; }
    public object Node { get; protected set; }
    public int Character { get; protected set; }
    public int Index { get; protected set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public RecognitionException(IIntStream input);
    public RecognitionException(IIntStream input, int k);
    public RecognitionException(string message);
    public RecognitionException(string message, IIntStream input);
    public RecognitionException(string message, IIntStream input, int k);
    public RecognitionException(string message, Exception innerException);
    public RecognitionException(string message, IIntStream input, Exception innerException);
    public RecognitionException(string message, IIntStream input, int k, Exception innerException);
    protected RecognitionException(SerializationInfo info, StreamingContext context);
    public virtual int get_UnexpectedType();
    public bool get_ApproximateLineInfo();
    protected void set_ApproximateLineInfo(bool value);
    public IIntStream get_Input();
    protected void set_Input(IIntStream value);
    public int get_Lookahead();
    public IToken get_Token();
    public void set_Token(IToken value);
    public object get_Node();
    protected void set_Node(object value);
    public int get_Character();
    protected void set_Character(int value);
    public int get_Index();
    protected void set_Index(int value);
    public int get_Line();
    public void set_Line(int value);
    public int get_CharPositionInLine();
    public void set_CharPositionInLine(int value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input);
    protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input, int k);
}
internal class Antlr.Runtime.RecognizerSharedState : object {
    public BitSet[] following;
    [CLSCompliantAttribute("False")]
public int _fsp;
    public bool errorRecovery;
    public int lastErrorIndex;
    public bool failed;
    public int syntaxErrors;
    public int backtracking;
    public IDictionary`2[] ruleMemo;
    public IToken token;
    public int tokenStartCharIndex;
    public int tokenStartLine;
    public int tokenStartCharPositionInLine;
    public int channel;
    public int type;
    public string text;
    public RecognizerSharedState(RecognizerSharedState state);
}
internal class Antlr.Runtime.SpecialStateTransitionHandler : MulticastDelegate {
    public SpecialStateTransitionHandler(object object, IntPtr method);
    public virtual int Invoke(DFA dfa, int s, IIntStream input);
    public virtual IAsyncResult BeginInvoke(DFA dfa, int s, IIntStream input, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Antlr.Runtime.TemplateParserRuleReturnScope`2 : ParserRuleReturnScope`1<TToken> {
    private TTemplate _template;
    public TTemplate Template { get; public set; }
    private object Antlr.Runtime.ITemplateRuleReturnScope.Template { get; }
    public sealed virtual TTemplate get_Template();
    public void set_Template(TTemplate value);
    private sealed virtual override object Antlr.Runtime.ITemplateRuleReturnScope.get_Template();
}
internal static class Antlr.Runtime.TokenChannels : object {
    public static int Default;
    public static int Hidden;
}
[DebuggerDisplayAttribute("TODO: TokenRewriteStream debugger display")]
internal class Antlr.Runtime.TokenRewriteStream : CommonTokenStream {
    public static string DEFAULT_PROGRAM_NAME;
    public static int PROGRAM_INIT_SIZE;
    public static int MIN_TOKEN_INDEX;
    protected IDictionary`2<string, IList`1<RewriteOperation>> programs;
    protected IDictionary`2<string, int> lastRewriteTokenIndexes;
    public TokenRewriteStream(ITokenSource tokenSource);
    public TokenRewriteStream(ITokenSource tokenSource, int channel);
    protected void Init();
    public virtual void Rollback(int instructionIndex);
    public virtual void Rollback(string programName, int instructionIndex);
    public virtual void DeleteProgram();
    public virtual void DeleteProgram(string programName);
    public virtual void InsertAfter(IToken t, object text);
    public virtual void InsertAfter(int index, object text);
    public virtual void InsertAfter(string programName, IToken t, object text);
    public virtual void InsertAfter(string programName, int index, object text);
    public virtual void InsertBefore(IToken t, object text);
    public virtual void InsertBefore(int index, object text);
    public virtual void InsertBefore(string programName, IToken t, object text);
    public virtual void InsertBefore(string programName, int index, object text);
    public virtual void Replace(int index, object text);
    public virtual void Replace(int from, int to, object text);
    public virtual void Replace(IToken indexT, object text);
    public virtual void Replace(IToken from, IToken to, object text);
    public virtual void Replace(string programName, int from, int to, object text);
    public virtual void Replace(string programName, IToken from, IToken to, object text);
    public virtual void Delete(int index);
    public virtual void Delete(int from, int to);
    public virtual void Delete(IToken indexT);
    public virtual void Delete(IToken from, IToken to);
    public virtual void Delete(string programName, int from, int to);
    public virtual void Delete(string programName, IToken from, IToken to);
    public virtual int GetLastRewriteTokenIndex();
    protected virtual int GetLastRewriteTokenIndex(string programName);
    protected virtual void SetLastRewriteTokenIndex(string programName, int i);
    protected virtual IList`1<RewriteOperation> GetProgram(string name);
    private IList`1<RewriteOperation> InitializeProgram(string name);
    public virtual string ToOriginalString();
    public virtual string ToOriginalString(int start, int end);
    public virtual string ToString();
    public virtual string ToString(string programName);
    public virtual string ToString(int start, int end);
    public virtual string ToString(string programName, int start, int end);
    protected virtual IDictionary`2<int, RewriteOperation> ReduceToSingleOperationPerIndex(IList`1<RewriteOperation> rewrites);
    protected virtual string CatOpText(object a, object b);
    protected virtual IList`1<RewriteOperation> GetKindOfOps(IList`1<RewriteOperation> rewrites, Type kind);
    protected virtual IList`1<RewriteOperation> GetKindOfOps(IList`1<RewriteOperation> rewrites, Type kind, int before);
    public virtual string ToDebugString();
    public virtual string ToDebugString(int start, int end);
}
internal static class Antlr.Runtime.Tokens : object {
    public static IToken Skip;
    private static Tokens();
}
internal static class Antlr.Runtime.TokenTypes : object {
    public static int EndOfFile;
    public static int Invalid;
    public static int EndOfRule;
    public static int Down;
    public static int Up;
    public static int Min;
}
internal class Antlr.Runtime.Tree.AntlrRuntime_BaseTreeDebugView : object {
    private BaseTree _tree;
    [DebuggerBrowsableAttribute("3")]
public ITree[] Children { get; }
    public AntlrRuntime_BaseTreeDebugView(BaseTree tree);
    public ITree[] get_Children();
}
internal class Antlr.Runtime.Tree.AstTreeRuleReturnScope`2 : TreeRuleReturnScope`1<TInputTree> {
    private TOutputTree _tree;
    public TOutputTree Tree { get; public set; }
    private object Antlr.Runtime.IAstRuleReturnScope.Tree { get; }
    public sealed virtual TOutputTree get_Tree();
    public void set_Tree(TOutputTree value);
    private sealed virtual override object Antlr.Runtime.IAstRuleReturnScope.get_Tree();
}
[DebuggerTypeProxyAttribute("Antlr.Runtime.Tree.AntlrRuntime_BaseTreeDebugView")]
internal abstract class Antlr.Runtime.Tree.BaseTree : object {
    private IList`1<ITree> _children;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharPositionInLine>k__BackingField;
    public IList`1<ITree> Children { get; private set; }
    public int ChildCount { get; }
    public ITree Parent { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public string Text { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public BaseTree(ITree node);
    public virtual IList`1<ITree> get_Children();
    private void set_Children(IList`1<ITree> value);
    public virtual int get_ChildCount();
    public virtual ITree get_Parent();
    public virtual void set_Parent(ITree value);
    public virtual int get_ChildIndex();
    public virtual void set_ChildIndex(int value);
    public virtual bool get_IsNil();
    public abstract virtual int get_TokenStartIndex();
    public abstract virtual void set_TokenStartIndex(int value);
    public abstract virtual int get_TokenStopIndex();
    public abstract virtual void set_TokenStopIndex(int value);
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Line();
    [CompilerGeneratedAttribute]
public virtual void set_Line(int value);
    [CompilerGeneratedAttribute]
public virtual int get_CharPositionInLine();
    [CompilerGeneratedAttribute]
public virtual void set_CharPositionInLine(int value);
    public virtual ITree GetChild(int i);
    public virtual ITree GetFirstChildWithType(int type);
    public virtual void AddChild(ITree t);
    public virtual void AddChildren(IEnumerable`1<ITree> kids);
    public virtual void SetChild(int i, ITree t);
    public virtual void InsertChild(int i, ITree t);
    public virtual object DeleteChild(int i);
    public virtual void ReplaceChildren(int startChildIndex, int stopChildIndex, object t);
    protected virtual IList`1<ITree> CreateChildrenList();
    public virtual void FreshenParentAndChildIndexes();
    public virtual void FreshenParentAndChildIndexes(int offset);
    public virtual void FreshenParentAndChildIndexesDeeply();
    public virtual void FreshenParentAndChildIndexesDeeply(int offset);
    public virtual void SanityCheckParentAndChildIndexes();
    public virtual void SanityCheckParentAndChildIndexes(ITree parent, int i);
    public virtual bool HasAncestor(int ttype);
    public virtual ITree GetAncestor(int ttype);
    public virtual IList`1<ITree> GetAncestors();
    public virtual string ToStringTree();
    public abstract virtual string ToString();
    public abstract virtual ITree DupNode();
}
internal abstract class Antlr.Runtime.Tree.BaseTreeAdaptor : object {
    protected IDictionary`2<object, int> treeToUniqueIDMap;
    protected int uniqueNodeID;
    public virtual object Nil();
    public virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public virtual bool IsNil(object tree);
    public virtual object DupNode(int type, object treeNode);
    public virtual object DupNode(object treeNode, string text);
    public virtual object DupNode(int type, object treeNode, string text);
    public virtual object DupTree(object tree);
    public virtual object DupTree(object t, object parent);
    public virtual void AddChild(object t, object child);
    public virtual object BecomeRoot(object newRoot, object oldRoot);
    public virtual object RulePostProcessing(object root);
    public virtual object BecomeRoot(IToken newRoot, object oldRoot);
    public virtual object Create(int tokenType, IToken fromToken);
    public virtual object Create(int tokenType, IToken fromToken, string text);
    public virtual object Create(IToken fromToken, string text);
    public virtual object Create(int tokenType, string text);
    public virtual int GetType(object t);
    public virtual void SetType(object t, int type);
    public virtual string GetText(object t);
    public virtual void SetText(object t, string text);
    public virtual object GetChild(object t, int i);
    public virtual void SetChild(object t, int i, object child);
    public virtual object DeleteChild(object t, int i);
    public virtual int GetChildCount(object t);
    public virtual int GetUniqueID(object node);
    public abstract virtual IToken CreateToken(int tokenType, string text);
    public abstract virtual IToken CreateToken(IToken fromToken);
    public abstract virtual object Create(IToken payload);
    public virtual object DupNode(object treeNode);
    public abstract virtual IToken GetToken(object t);
    public virtual void SetTokenBoundaries(object t, IToken startToken, IToken stopToken);
    public virtual int GetTokenStartIndex(object t);
    public virtual int GetTokenStopIndex(object t);
    public virtual object GetParent(object t);
    public virtual void SetParent(object t, object parent);
    public virtual int GetChildIndex(object t);
    public virtual void SetChildIndex(object t, int index);
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    protected virtual ITree GetTree(object t);
}
[DefaultMemberAttribute("Item")]
internal class Antlr.Runtime.Tree.BufferedTreeNodeStream : object {
    public static int DEFAULT_INITIAL_BUFFER_SIZE;
    public static int INITIAL_CALL_STACK_SIZE;
    protected object down;
    protected object up;
    protected object eof;
    protected IList nodes;
    protected object root;
    protected ITokenStream tokens;
    private ITreeAdaptor adaptor;
    private bool uniqueNavigationNodes;
    protected int p;
    protected int lastMarker;
    protected Stack`1<int> calls;
    public int Count { get; }
    public object TreeSource { get; }
    public string SourceName { get; }
    public ITokenStream TokenStream { get; public set; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public bool UniqueNavigationNodes { get; public set; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public object Item { get; }
    public int Index { get; }
    public BufferedTreeNodeStream(object tree);
    public BufferedTreeNodeStream(ITreeAdaptor adaptor, object tree);
    public BufferedTreeNodeStream(ITreeAdaptor adaptor, object tree, int initialBufferSize);
    public virtual int get_Count();
    public virtual object get_TreeSource();
    public virtual string get_SourceName();
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual ITreeAdaptor get_TreeAdaptor();
    public virtual void set_TreeAdaptor(ITreeAdaptor value);
    public virtual bool get_UniqueNavigationNodes();
    public virtual void set_UniqueNavigationNodes(bool value);
    public virtual IToken get_LastToken();
    public virtual IToken get_LastRealToken();
    public virtual int get_MaxLookBehind();
    protected virtual void FillBuffer();
    public virtual void FillBuffer(object t);
    protected virtual int GetNodeIndex(object node);
    protected virtual void AddNavigationNode(int ttype);
    public virtual object get_Item(int i);
    public virtual object LT(int k);
    public virtual object GetCurrentSymbol();
    protected virtual object LB(int k);
    public virtual void Consume();
    public virtual int LA(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Seek(int index);
    public virtual void Push(int index);
    public virtual int Pop();
    public virtual void Reset();
    public virtual IEnumerator`1<object> Iterator();
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    public virtual string ToTokenTypeString();
    public virtual string ToTokenString(int start, int stop);
    public virtual string ToString(object start, object stop);
}
internal class Antlr.Runtime.Tree.CommonErrorNode : CommonTree {
    public IIntStream input;
    public IToken start;
    public IToken stop;
    public RecognitionException trappedException;
    public bool IsNil { get; }
    public string Text { get; public set; }
    public int Type { get; public set; }
    public CommonErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public virtual bool get_IsNil();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual string ToString();
}
internal class Antlr.Runtime.Tree.CommonTree : BaseTree {
    private IToken _token;
    protected int startIndex;
    protected int stopIndex;
    private CommonTree parent;
    private int childIndex;
    public int CharPositionInLine { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int Line { get; public set; }
    public ITree Parent { get; public set; }
    public string Text { get; public set; }
    public IToken Token { get; public set; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public CommonTree(CommonTree node);
    public CommonTree(IToken t);
    public virtual int get_CharPositionInLine();
    public virtual void set_CharPositionInLine(int value);
    public virtual int get_ChildIndex();
    public virtual void set_ChildIndex(int value);
    public virtual bool get_IsNil();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual ITree get_Parent();
    public virtual void set_Parent(ITree value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public IToken get_Token();
    public void set_Token(IToken value);
    public virtual int get_TokenStartIndex();
    public virtual void set_TokenStartIndex(int value);
    public virtual int get_TokenStopIndex();
    public virtual void set_TokenStopIndex(int value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual ITree DupNode();
    public virtual void SetUnknownTokenBoundaries();
    public virtual string ToString();
}
internal class Antlr.Runtime.Tree.CommonTreeAdaptor : BaseTreeAdaptor {
    public virtual object Create(IToken payload);
    public virtual IToken CreateToken(int tokenType, string text);
    public virtual IToken CreateToken(IToken fromToken);
    public virtual IToken GetToken(object t);
}
internal class Antlr.Runtime.Tree.CommonTreeNodeStream : LookaheadStream`1<object> {
    public static int DEFAULT_INITIAL_BUFFER_SIZE;
    public static int INITIAL_CALL_STACK_SIZE;
    private object _root;
    protected ITokenStream tokens;
    private ITreeAdaptor _adaptor;
    private TreeIterator _it;
    private Stack`1<int> _calls;
    private bool _hasNilRoot;
    private int _level;
    public string SourceName { get; }
    public ITokenStream TokenStream { get; public set; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public object TreeSource { get; }
    public bool UniqueNavigationNodes { get; public set; }
    public CommonTreeNodeStream(object tree);
    public CommonTreeNodeStream(ITreeAdaptor adaptor, object tree);
    public virtual string get_SourceName();
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual ITreeAdaptor get_TreeAdaptor();
    public virtual void set_TreeAdaptor(ITreeAdaptor value);
    public virtual object get_TreeSource();
    public virtual bool get_UniqueNavigationNodes();
    public virtual void set_UniqueNavigationNodes(bool value);
    public virtual void Reset();
    public virtual object NextElement();
    public virtual bool IsEndOfFile(object o);
    public virtual int LA(int i);
    public virtual void Push(int index);
    public virtual int Pop();
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    public virtual string ToString(object start, object stop);
    public virtual string ToTokenTypeString();
}
internal class Antlr.Runtime.Tree.DotTreeGenerator : object {
    private static string Footer;
    private static string NodeFormat;
    private static string EdgeFormat;
    private String[] HeaderLines;
    private Dictionary`2<object, int> nodeToNumberMap;
    private int nodeNumber;
    public virtual string ToDot(object tree, ITreeAdaptor adaptor);
    public virtual string ToDot(ITree tree);
    protected virtual IEnumerable`1<string> DefineNodes(object tree, ITreeAdaptor adaptor);
    protected virtual IEnumerable`1<string> DefineEdges(object tree, ITreeAdaptor adaptor);
    protected virtual string GetNodeText(ITreeAdaptor adaptor, object t);
    protected virtual int GetNodeNumber(object t);
    protected virtual string FixString(string text);
}
internal interface Antlr.Runtime.Tree.ITree {
    public int ChildCount { get; }
    public ITree Parent { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; }
    public string Text { get; }
    public int Line { get; }
    public int CharPositionInLine { get; }
    public abstract virtual ITree GetChild(int i);
    public abstract virtual int get_ChildCount();
    public abstract virtual ITree get_Parent();
    public abstract virtual void set_Parent(ITree value);
    public abstract virtual bool HasAncestor(int ttype);
    public abstract virtual ITree GetAncestor(int ttype);
    public abstract virtual IList`1<ITree> GetAncestors();
    public abstract virtual int get_ChildIndex();
    public abstract virtual void set_ChildIndex(int value);
    public abstract virtual void FreshenParentAndChildIndexes();
    public abstract virtual void AddChild(ITree t);
    public abstract virtual void SetChild(int i, ITree t);
    public abstract virtual object DeleteChild(int i);
    public abstract virtual void ReplaceChildren(int startChildIndex, int stopChildIndex, object t);
    public abstract virtual bool get_IsNil();
    public abstract virtual int get_TokenStartIndex();
    public abstract virtual void set_TokenStartIndex(int value);
    public abstract virtual int get_TokenStopIndex();
    public abstract virtual void set_TokenStopIndex(int value);
    public abstract virtual ITree DupNode();
    public abstract virtual int get_Type();
    public abstract virtual string get_Text();
    public abstract virtual int get_Line();
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual string ToStringTree();
    public abstract virtual string ToString();
}
internal interface Antlr.Runtime.Tree.ITreeAdaptor {
    public abstract virtual object Create(IToken payload);
    public abstract virtual object Create(int tokenType, IToken fromToken);
    public abstract virtual object Create(int tokenType, IToken fromToken, string text);
    public abstract virtual object Create(IToken fromToken, string text);
    public abstract virtual object Create(int tokenType, string text);
    public abstract virtual object DupNode(object treeNode);
    public abstract virtual object DupNode(int type, object treeNode);
    public abstract virtual object DupNode(object treeNode, string text);
    public abstract virtual object DupNode(int type, object treeNode, string text);
    public abstract virtual object DupTree(object tree);
    public abstract virtual object Nil();
    public abstract virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public abstract virtual bool IsNil(object tree);
    public abstract virtual void AddChild(object t, object child);
    public abstract virtual object BecomeRoot(object newRoot, object oldRoot);
    public abstract virtual object RulePostProcessing(object root);
    public abstract virtual int GetUniqueID(object node);
    public abstract virtual object BecomeRoot(IToken newRoot, object oldRoot);
    public abstract virtual int GetType(object t);
    public abstract virtual void SetType(object t, int type);
    public abstract virtual string GetText(object t);
    public abstract virtual void SetText(object t, string text);
    public abstract virtual IToken GetToken(object t);
    public abstract virtual void SetTokenBoundaries(object t, IToken startToken, IToken stopToken);
    public abstract virtual int GetTokenStartIndex(object t);
    public abstract virtual int GetTokenStopIndex(object t);
    public abstract virtual object GetChild(object t, int i);
    public abstract virtual void SetChild(object t, int i, object child);
    public abstract virtual object DeleteChild(object t, int i);
    public abstract virtual int GetChildCount(object t);
    public abstract virtual object GetParent(object t);
    public abstract virtual void SetParent(object t, object parent);
    public abstract virtual int GetChildIndex(object t);
    public abstract virtual void SetChildIndex(object t, int index);
    public abstract virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
}
[DefaultMemberAttribute("Item")]
internal interface Antlr.Runtime.Tree.ITreeNodeStream {
    public object Item { get; }
    public object TreeSource { get; }
    public ITokenStream TokenStream { get; }
    public ITreeAdaptor TreeAdaptor { get; }
    public bool UniqueNavigationNodes { get; public set; }
    public abstract virtual object get_Item(int i);
    public abstract virtual object LT(int k);
    public abstract virtual object get_TreeSource();
    public abstract virtual ITokenStream get_TokenStream();
    public abstract virtual ITreeAdaptor get_TreeAdaptor();
    public abstract virtual bool get_UniqueNavigationNodes();
    public abstract virtual void set_UniqueNavigationNodes(bool value);
    public abstract virtual string ToString(object start, object stop);
    public abstract virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
}
internal interface Antlr.Runtime.Tree.ITreeVisitorAction {
    public abstract virtual object Pre(object t);
    public abstract virtual object Post(object t);
}
internal class Antlr.Runtime.Tree.ParseTree : BaseTree {
    public object payload;
    public List`1<IToken> hiddenTokens;
    public string Text { get; public set; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public ParseTree(object label);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_TokenStartIndex();
    public virtual void set_TokenStartIndex(int value);
    public virtual int get_TokenStopIndex();
    public virtual void set_TokenStopIndex(int value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual ITree DupNode();
    public virtual string ToString();
    public virtual string ToStringWithHiddenTokens();
    public virtual string ToInputString();
    protected virtual void ToStringLeaves(StringBuilder buf);
}
internal class Antlr.Runtime.Tree.RewriteCardinalityException : Exception {
    private string _elementDescription;
    public RewriteCardinalityException(string elementDescription);
    public RewriteCardinalityException(string elementDescription, Exception innerException);
    public RewriteCardinalityException(string message, string elementDescription);
    public RewriteCardinalityException(string message, string elementDescription, Exception innerException);
    protected RewriteCardinalityException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Antlr.Runtime.Tree.RewriteEarlyExitException : RewriteCardinalityException {
    public RewriteEarlyExitException(string elementDescription);
    public RewriteEarlyExitException(string elementDescription, Exception innerException);
    public RewriteEarlyExitException(string message, string elementDescription);
    public RewriteEarlyExitException(string message, string elementDescription, Exception innerException);
    protected RewriteEarlyExitException(SerializationInfo info, StreamingContext context);
}
internal class Antlr.Runtime.Tree.RewriteEmptyStreamException : RewriteCardinalityException {
    public RewriteEmptyStreamException(string elementDescription);
    public RewriteEmptyStreamException(string elementDescription, Exception innerException);
    public RewriteEmptyStreamException(string message, string elementDescription);
    public RewriteEmptyStreamException(string message, string elementDescription, Exception innerException);
    protected RewriteEmptyStreamException(SerializationInfo info, StreamingContext context);
}
internal abstract class Antlr.Runtime.Tree.RewriteRuleElementStream : object {
    protected int cursor;
    protected object singleElement;
    protected IList elements;
    protected bool dirty;
    protected string elementDescription;
    protected ITreeAdaptor adaptor;
    public bool HasNext { get; }
    public int Count { get; }
    public string Description { get; }
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual void Reset();
    public virtual void Add(object el);
    public virtual object NextTree();
    protected virtual object NextCore();
    protected abstract virtual object Dup(object el);
    protected virtual object ToTree(object el);
    public virtual bool get_HasNext();
    public virtual int get_Count();
    public virtual string get_Description();
}
internal class Antlr.Runtime.Tree.RewriteRuleNodeStream : RewriteRuleElementStream {
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    protected virtual object ToTree(object el);
    protected virtual object Dup(object el);
}
internal class Antlr.Runtime.Tree.RewriteRuleSubtreeStream : RewriteRuleElementStream {
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    protected virtual object Dup(object el);
}
internal class Antlr.Runtime.Tree.RewriteRuleTokenStream : RewriteRuleElementStream {
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    public virtual IToken NextToken();
    protected virtual object ToTree(object el);
    protected virtual object Dup(object el);
}
internal class Antlr.Runtime.Tree.TemplateTreeRuleReturnScope`2 : TreeRuleReturnScope`1<TTree> {
    private TTemplate _template;
    public TTemplate Template { get; public set; }
    private object Antlr.Runtime.ITemplateRuleReturnScope.Template { get; }
    public sealed virtual TTemplate get_Template();
    public void set_Template(TTemplate value);
    private sealed virtual override object Antlr.Runtime.ITemplateRuleReturnScope.get_Template();
}
internal class Antlr.Runtime.Tree.TreeFilter : TreeParser {
    protected ITokenStream originalTokenStream;
    protected ITreeAdaptor originalAdaptor;
    public TreeFilter(ITreeNodeStream input);
    public TreeFilter(ITreeNodeStream input, RecognizerSharedState state);
    public virtual void ApplyOnce(object t, Action whichRule);
    public virtual void Downup(object t);
    protected virtual void Topdown();
    protected virtual void Bottomup();
    [CompilerGeneratedAttribute]
private object <Downup>b__0(object o);
    [CompilerGeneratedAttribute]
private object <Downup>b__1(object o);
}
internal class Antlr.Runtime.Tree.TreeIterator : object {
    protected ITreeAdaptor adaptor;
    protected object root;
    protected object tree;
    protected bool firstTime;
    private bool reachedEof;
    public object up;
    public object down;
    public object eof;
    protected Queue`1<object> nodes;
    [CompilerGeneratedAttribute]
private object <Current>k__BackingField;
    public object Current { get; private set; }
    public TreeIterator(CommonTree tree);
    public TreeIterator(ITreeAdaptor adaptor, object tree);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(object value);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class Antlr.Runtime.Tree.TreeParser : BaseRecognizer {
    public static int DOWN;
    public static int UP;
    private static string dotdot;
    private static string doubleEtc;
    private static Regex dotdotPattern;
    private static Regex doubleEtcPattern;
    protected ITreeNodeStream input;
    public string SourceName { get; }
    public TreeParser(ITreeNodeStream input);
    public TreeParser(ITreeNodeStream input, RecognizerSharedState state);
    private static TreeParser();
    public virtual void Reset();
    public virtual void SetTreeNodeStream(ITreeNodeStream input);
    public virtual ITreeNodeStream GetTreeNodeStream();
    public virtual string get_SourceName();
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual void MatchAny(IIntStream ignore);
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public virtual string GetErrorHeader(RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
}
internal class Antlr.Runtime.Tree.TreePatternLexer : object {
    public static int Begin;
    public static int End;
    public static int Id;
    public static int Arg;
    public static int Percent;
    public static int Colon;
    public static int Dot;
    protected string pattern;
    protected int p;
    protected int c;
    protected int n;
    public StringBuilder sval;
    public bool error;
    public TreePatternLexer(string pattern);
    public virtual int NextToken();
    protected virtual void Consume();
}
internal class Antlr.Runtime.Tree.TreePatternParser : object {
    protected TreePatternLexer tokenizer;
    protected int ttype;
    protected TreeWizard wizard;
    protected ITreeAdaptor adaptor;
    public TreePatternParser(TreePatternLexer tokenizer, TreeWizard wizard, ITreeAdaptor adaptor);
    public virtual object Pattern();
    public virtual object ParseTree();
    public virtual object ParseNode();
}
internal class Antlr.Runtime.Tree.TreeRewriter : TreeParser {
    protected bool showTransformations;
    protected ITokenStream originalTokenStream;
    protected ITreeAdaptor originalAdaptor;
    private Func`1<IAstRuleReturnScope> topdown_func;
    private Func`1<IAstRuleReturnScope> bottomup_func;
    public TreeRewriter(ITreeNodeStream input);
    public TreeRewriter(ITreeNodeStream input, RecognizerSharedState state);
    public virtual object ApplyOnce(object t, Func`1<IAstRuleReturnScope> whichRule);
    public virtual object ApplyRepeatedly(object t, Func`1<IAstRuleReturnScope> whichRule);
    public virtual object Downup(object t);
    public virtual object Downup(object t, bool showTransformations);
    protected virtual IAstRuleReturnScope Topdown();
    protected virtual IAstRuleReturnScope Bottomup();
    protected virtual void ReportTransformation(object oldTree, object newTree);
    [CompilerGeneratedAttribute]
private IAstRuleReturnScope <.ctor>b__0();
    [CompilerGeneratedAttribute]
private IAstRuleReturnScope <.ctor>b__1();
    [CompilerGeneratedAttribute]
private object <Downup>b__4(object o);
    [CompilerGeneratedAttribute]
private object <Downup>b__5(object o);
}
internal class Antlr.Runtime.Tree.TreeRuleReturnScope`1 : object {
    private TTree _start;
    public TTree Start { get; public set; }
    private object Antlr.Runtime.IRuleReturnScope.Start { get; }
    private TTree Antlr.Runtime.IRuleReturnScope<TTree>.Stop { get; }
    private object Antlr.Runtime.IRuleReturnScope.Stop { get; }
    public sealed virtual TTree get_Start();
    public void set_Start(TTree value);
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Start();
    private sealed virtual override TTree Antlr.Runtime.IRuleReturnScope<TTree>.get_Stop();
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Stop();
}
internal class Antlr.Runtime.Tree.TreeVisitor : object {
    protected ITreeAdaptor adaptor;
    public TreeVisitor(ITreeAdaptor adaptor);
    public object Visit(object t, ITreeVisitorAction action);
    public object Visit(object t, Func`2<object, object> preAction, Func`2<object, object> postAction);
}
internal class Antlr.Runtime.Tree.TreeVisitorAction : object {
    private Func`2<object, object> _preAction;
    private Func`2<object, object> _postAction;
    public TreeVisitorAction(Func`2<object, object> preAction, Func`2<object, object> postAction);
    public sealed virtual object Pre(object t);
    public sealed virtual object Post(object t);
}
internal class Antlr.Runtime.Tree.TreeWizard : object {
    protected ITreeAdaptor adaptor;
    protected IDictionary`2<string, int> tokenNameToTypeMap;
    public TreeWizard(ITreeAdaptor adaptor);
    public TreeWizard(ITreeAdaptor adaptor, IDictionary`2<string, int> tokenNameToTypeMap);
    public TreeWizard(ITreeAdaptor adaptor, String[] tokenNames);
    public TreeWizard(String[] tokenNames);
    public virtual IDictionary`2<string, int> ComputeTokenTypes(String[] tokenNames);
    public virtual int GetTokenType(string tokenName);
    public IDictionary`2<int, IList> Index(object t);
    protected virtual void IndexCore(object t, IDictionary`2<int, IList> m);
    public virtual IList Find(object t, int ttype);
    public virtual IList Find(object t, string pattern);
    public virtual object FindFirst(object t, int ttype);
    public virtual object FindFirst(object t, string pattern);
    public void Visit(object t, int ttype, IContextVisitor visitor);
    public void Visit(object t, int ttype, Action`1<object> action);
    protected virtual void VisitCore(object t, object parent, int childIndex, int ttype, IContextVisitor visitor);
    public void Visit(object t, string pattern, IContextVisitor visitor);
    public bool Parse(object t, string pattern, IDictionary`2<string, object> labels);
    public bool Parse(object t, string pattern);
    protected virtual bool ParseCore(object t1, TreePattern tpattern, IDictionary`2<string, object> labels);
    public virtual object Create(string pattern);
    public static bool Equals(object t1, object t2, ITreeAdaptor adaptor);
    public bool Equals(object t1, object t2);
    protected static bool EqualsCore(object t1, object t2, ITreeAdaptor adaptor);
}
internal class Antlr.Runtime.UnbufferedTokenStream : LookaheadStream`1<IToken> {
    [CLSCompliantAttribute("False")]
protected ITokenSource tokenSource;
    protected int tokenIndex;
    protected int channel;
    private ListStack`1<IToken> _realTokens;
    public ITokenSource TokenSource { get; }
    public string SourceName { get; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public UnbufferedTokenStream(ITokenSource tokenSource);
    public sealed virtual ITokenSource get_TokenSource();
    public sealed virtual string get_SourceName();
    public sealed virtual IToken get_LastToken();
    public sealed virtual IToken get_LastRealToken();
    public sealed virtual int get_MaxLookBehind();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Clear();
    public virtual void Consume();
    public virtual IToken NextElement();
    public virtual bool IsEndOfFile(IToken o);
    public sealed virtual IToken Get(int i);
    public sealed virtual int LA(int i);
    public sealed virtual string ToString(int start, int stop);
    public sealed virtual string ToString(IToken start, IToken stop);
}
internal class Antlr.Runtime.UnwantedTokenException : MismatchedTokenException {
    public IToken UnexpectedToken { get; }
    public UnwantedTokenException(string message);
    public UnwantedTokenException(string message, Exception innerException);
    public UnwantedTokenException(int expecting, IIntStream input);
    public UnwantedTokenException(int expecting, IIntStream input, IList`1<string> tokenNames);
    public UnwantedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames);
    public UnwantedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames, Exception innerException);
    protected UnwantedTokenException(SerializationInfo info, StreamingContext context);
    public virtual IToken get_UnexpectedToken();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.AutoIndentWriter : object {
    public static int NoWrap;
    private ListStack`1<string> _indents;
    private Stack`1<int> _anchors;
    private string _newline;
    private TextWriter _writer;
    private int _charPosition;
    private int _charIndex;
    private int _lineWidth;
    public int Index { get; protected set; }
    public int LineWidth { get; public set; }
    protected bool AtStartOfLine { get; }
    protected TextWriter Writer { get; protected set; }
    public AutoIndentWriter(TextWriter writer);
    public AutoIndentWriter(TextWriter writer, string newline);
    public sealed virtual int get_Index();
    protected void set_Index(int value);
    public sealed virtual int get_LineWidth();
    public sealed virtual void set_LineWidth(int value);
    protected bool get_AtStartOfLine();
    protected TextWriter get_Writer();
    protected void set_Writer(TextWriter value);
    public virtual void PushIndentation(string indent);
    public virtual string PopIndentation();
    public virtual void PushAnchorPoint();
    public virtual void PopAnchorPoint();
    public virtual int Write(string value);
    public virtual int WriteSeparator(string value);
    public virtual int Write(string value, string wrap);
    public virtual int WriteWrap(string wrap);
    protected virtual int Indent();
}
internal enum Antlr4.StringTemplate.Compiler.Bytecode : Enum {
    public byte value__;
    public static Bytecode Invalid;
    public static Bytecode INSTR_LOAD_STR;
    public static Bytecode INSTR_LOAD_ATTR;
    public static Bytecode INSTR_LOAD_LOCAL;
    public static Bytecode INSTR_LOAD_PROP;
    public static Bytecode INSTR_LOAD_PROP_IND;
    public static Bytecode INSTR_STORE_OPTION;
    public static Bytecode INSTR_STORE_ARG;
    public static Bytecode INSTR_NEW;
    public static Bytecode INSTR_NEW_IND;
    public static Bytecode INSTR_NEW_BOX_ARGS;
    public static Bytecode INSTR_SUPER_NEW;
    public static Bytecode INSTR_SUPER_NEW_BOX_ARGS;
    public static Bytecode INSTR_WRITE;
    public static Bytecode INSTR_WRITE_OPT;
    public static Bytecode INSTR_MAP;
    public static Bytecode INSTR_ROT_MAP;
    public static Bytecode INSTR_ZIP_MAP;
    public static Bytecode INSTR_BR;
    public static Bytecode INSTR_BRF;
    public static Bytecode INSTR_OPTIONS;
    public static Bytecode INSTR_ARGS;
    public static Bytecode INSTR_PASSTHRU;
    public static Bytecode INSTR_LIST;
    public static Bytecode INSTR_ADD;
    public static Bytecode INSTR_TOSTR;
    public static Bytecode INSTR_FIRST;
    public static Bytecode INSTR_LAST;
    public static Bytecode INSTR_REST;
    public static Bytecode INSTR_TRUNC;
    public static Bytecode INSTR_STRIP;
    public static Bytecode INSTR_TRIM;
    public static Bytecode INSTR_LENGTH;
    public static Bytecode INSTR_STRLEN;
    public static Bytecode INSTR_REVERSE;
    public static Bytecode INSTR_NOT;
    public static Bytecode INSTR_OR;
    public static Bytecode INSTR_AND;
    public static Bytecode INSTR_INDENT;
    public static Bytecode INSTR_DEDENT;
    public static Bytecode INSTR_NEWLINE;
    public static Bytecode INSTR_NOOP;
    public static Bytecode INSTR_POP;
    public static Bytecode INSTR_NULL;
    public static Bytecode INSTR_TRUE;
    public static Bytecode INSTR_FALSE;
    public static Bytecode INSTR_WRITE_STR;
    public static Bytecode INSTR_WRITE_LOCAL;
}
internal class Antlr4.StringTemplate.Compiler.BytecodeDisassembler : object {
    private CompiledTemplate code;
    public BytecodeDisassembler(CompiledTemplate code);
    public virtual string GetInstructions();
    public virtual string Disassemble();
    public virtual int DisassembleInstruction(StringBuilder buf, int ip);
    private string ShowConstantPoolOperand(int poolIndex);
    internal static int GetShort(Byte[] memory, int index);
    public virtual string GetStrings();
    public virtual string GetSourceMap();
}
[GeneratedCodeAttribute("ANTLR", "3.4.1.9004")]
[CLSCompliantAttribute("False")]
internal class Antlr4.StringTemplate.Compiler.CodeGenerator : TreeParser {
    public static int EOF;
    public static int IF;
    public static int ELSE;
    public static int ELSEIF;
    public static int ENDIF;
    public static int SUPER;
    public static int SEMI;
    public static int BANG;
    public static int ELLIPSIS;
    public static int EQUALS;
    public static int COLON;
    public static int LPAREN;
    public static int RPAREN;
    public static int LBRACK;
    public static int RBRACK;
    public static int COMMA;
    public static int DOT;
    public static int LCURLY;
    public static int RCURLY;
    public static int TEXT;
    public static int LDELIM;
    public static int RDELIM;
    public static int ID;
    public static int STRING;
    public static int WS;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    public static int ARGS;
    public static int ELEMENTS;
    public static int EXEC_FUNC;
    public static int EXPR;
    public static int INCLUDE;
    public static int INCLUDE_IND;
    public static int INCLUDE_REGION;
    public static int INCLUDE_SUPER;
    public static int INCLUDE_SUPER_REGION;
    public static int LIST;
    public static int MAP;
    public static int NULL;
    public static int OPTIONS;
    public static int PROP;
    public static int PROP_IND;
    public static int REGION;
    public static int SUBTEMPLATE;
    public static int TO_STR;
    public static int ZIP;
    private string outermostTemplateName;
    private IToken templateToken;
    private string _template;
    private TemplateCompiler _compiler;
    private CompiledTemplate outermostImpl;
    internal static String[] tokenNames;
    protected ListStack`1<template_scope> template_stack;
    public ErrorManager errMgr { get; }
    public TemplateGroup Group { get; }
    public CompilationState CompilationState { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public CodeGenerator(ITreeNodeStream input, TemplateCompiler compiler, string name, string template, IToken templateToken);
    private CodeGenerator(ITreeNodeStream input);
    private CodeGenerator(ITreeNodeStream input, RecognizerSharedState state);
    private static CodeGenerator();
    public ErrorManager get_errMgr();
    public TemplateGroup get_Group();
    public CompilationState get_CompilationState();
    public void emit1(CommonTree opAST, Bytecode opcode, int arg);
    public void emit1(CommonTree opAST, Bytecode opcode, string arg);
    public void emit2(CommonTree opAST, Bytecode opcode, int arg, int arg2);
    public void emit2(CommonTree opAST, Bytecode opcode, string s, int arg2);
    public void emit(Bytecode opcode);
    public void emit(CommonTree opAST, Bytecode opcode);
    private void Indent(CommonTree indent);
    private void Dedent();
    public void insert(int addr, Bytecode opcode, string s);
    public void setOption(CommonTree id);
    public void write(int addr, short value);
    public int address();
    public void func(CommonTree id);
    public void refAttr(CommonTree id);
    public int defineString(string s);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("templateAndEOF")]
private void templateAndEOF();
    [GrammarRuleAttribute("template")]
public CompiledTemplate template(string name, List`1<FormalArgument> args);
    [GrammarRuleAttribute("chunk")]
private void chunk();
    [GrammarRuleAttribute("element")]
private void element();
    [GrammarRuleAttribute("singleElement")]
private void singleElement();
    [GrammarRuleAttribute("compoundElement")]
private void compoundElement(CommonTree indent);
    [GrammarRuleAttribute("exprElement")]
private void exprElement();
    [GrammarRuleAttribute("region")]
private region_return region(CommonTree indent);
    [GrammarRuleAttribute("subtemplate")]
private subtemplate_return subtemplate();
    [GrammarRuleAttribute("ifstat")]
private void ifstat(CommonTree indent);
    [GrammarRuleAttribute("conditional")]
private TreeRuleReturnScope`1<CommonTree> conditional();
    [GrammarRuleAttribute("exprOptions")]
private void exprOptions();
    [GrammarRuleAttribute("option")]
private void option();
    [GrammarRuleAttribute("expr")]
private void expr();
    [GrammarRuleAttribute("prop")]
private void prop();
    [GrammarRuleAttribute("mapTemplateRef")]
private TreeRuleReturnScope`1<CommonTree> mapTemplateRef(int num_exprs);
    [GrammarRuleAttribute("includeExpr")]
private TreeRuleReturnScope`1<CommonTree> includeExpr();
    [GrammarRuleAttribute("primary")]
private TreeRuleReturnScope`1<CommonTree> primary();
    [GrammarRuleAttribute("arg")]
private void arg();
    [GrammarRuleAttribute("args")]
private args_return args();
    [GrammarRuleAttribute("list")]
private TreeRuleReturnScope`1<CommonTree> list();
    [GrammarRuleAttribute("listElement")]
private TreeRuleReturnScope`1<CommonTree> listElement();
}
internal class Antlr4.StringTemplate.Compiler.CompilationState : object {
    internal CompiledTemplate impl;
    internal StringTable stringtable;
    internal int ip;
    internal ITokenStream tokens;
    internal ErrorManager errMgr;
    public CompilationState(ErrorManager errMgr, string name, ITokenStream tokens);
    public virtual int DefineString(string s);
    public virtual void ReferenceAttribute(IToken templateToken, CommonTree id);
    public virtual void SetOption(CommonTree id);
    public virtual void Function(IToken templateToken, CommonTree id);
    public virtual void Emit(Bytecode opcode);
    public virtual void Emit(CommonTree opAST, Bytecode opcode);
    public virtual void Emit1(CommonTree opAST, Bytecode opcode, int arg);
    public virtual void Emit2(CommonTree opAST, Bytecode opcode, int arg, int arg2);
    public virtual void Emit2(CommonTree opAST, Bytecode opcode, string s, int arg2);
    public virtual void Emit1(CommonTree opAST, Bytecode opcode, string s);
    public virtual void Insert(int addr, Bytecode opcode, string s);
    public virtual void Write(int addr, short value);
    protected virtual void EnsureCapacity(int n);
    public virtual void Indent(CommonTree indent);
    public static void WriteShort(Byte[] memory, int index, short value);
}
internal class Antlr4.StringTemplate.Compiler.CompiledTemplate : object {
    private static ReadOnlyCollection`1<CompiledTemplate> EmptyImplicitlyDefinedTemplates;
    private string _name;
    private string _prefix;
    private string _template;
    private IToken _templateDefStartToken;
    private ITokenStream _tokens;
    private CommonTree _ast;
    private List`1<FormalArgument> _formalArguments;
    private bool _hasFormalArgs;
    private List`1<CompiledTemplate> implicitlyDefinedTemplates;
    private int _numberOfArgsWithDefaultValues;
    private TemplateGroup _nativeGroup;
    private bool isRegion;
    private RegionType regionDefType;
    private bool isAnonSubtemplate;
    public String[] strings;
    public Byte[] instrs;
    public int codeSize;
    public Interval[] sourceMap;
    [CompilerGeneratedAttribute]
private static Func`2<FormalArgument, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Name { get; public set; }
    public string Prefix { get; public set; }
    public string Template { get; public set; }
    public IToken TemplateDefStartToken { get; public set; }
    public ITokenStream Tokens { get; public set; }
    public CommonTree Ast { get; public set; }
    public List`1<FormalArgument> FormalArguments { get; public set; }
    public bool HasFormalArgs { get; public set; }
    public ReadOnlyCollection`1<CompiledTemplate> ImplicitlyDefinedTemplates { get; }
    public TemplateGroup NativeGroup { get; public set; }
    public bool IsRegion { get; public set; }
    public RegionType RegionDefType { get; public set; }
    public bool IsAnonSubtemplate { get; public set; }
    public string TemplateSource { get; }
    public Interval TemplateRange { get; }
    public int NumberOfArgsWithDefaultValues { get; }
    private static CompiledTemplate();
    public string get_Name();
    public void set_Name(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Template();
    public void set_Template(string value);
    public IToken get_TemplateDefStartToken();
    public void set_TemplateDefStartToken(IToken value);
    public ITokenStream get_Tokens();
    public void set_Tokens(ITokenStream value);
    public CommonTree get_Ast();
    public void set_Ast(CommonTree value);
    public List`1<FormalArgument> get_FormalArguments();
    public void set_FormalArguments(List`1<FormalArgument> value);
    public bool get_HasFormalArgs();
    public void set_HasFormalArgs(bool value);
    public ReadOnlyCollection`1<CompiledTemplate> get_ImplicitlyDefinedTemplates();
    public virtual TemplateGroup get_NativeGroup();
    public virtual void set_NativeGroup(TemplateGroup value);
    public bool get_IsRegion();
    public void set_IsRegion(bool value);
    public RegionType get_RegionDefType();
    public void set_RegionDefType(RegionType value);
    public bool get_IsAnonSubtemplate();
    public void set_IsAnonSubtemplate(bool value);
    public virtual string get_TemplateSource();
    public virtual Interval get_TemplateRange();
    public virtual int get_NumberOfArgsWithDefaultValues();
    public virtual FormalArgument TryGetFormalArgument(string name);
    public virtual void AddImplicitlyDefinedTemplate(CompiledTemplate sub);
    public virtual void DefineArgumentDefaultValueTemplates(TemplateGroup group);
    public virtual void DefineFormalArguments(IEnumerable`1<FormalArgument> args);
    public virtual void AddArgument(FormalArgument a);
    public virtual void DefineImplicitlyDefinedTemplates(TemplateGroup group);
    public virtual string GetInstructions();
    public virtual void Dump();
    public virtual string Disassemble();
    [CompilerGeneratedAttribute]
private static bool <set_FormalArguments>b__0(FormalArgument i);
}
internal class Antlr4.StringTemplate.Compiler.FormalArgument : object {
    private string name;
    private int index;
    private IToken defaultValueToken;
    private object defaultValue;
    private CompiledTemplate compiledDefaultValue;
    public string Name { get; }
    public int Index { get; internal set; }
    public IToken DefaultValueToken { get; }
    public object DefaultValue { get; public set; }
    public CompiledTemplate CompiledDefaultValue { get; internal set; }
    public FormalArgument(string name);
    public FormalArgument(string name, IToken defaultValueToken);
    public string get_Name();
    public int get_Index();
    internal void set_Index(int value);
    public IToken get_DefaultValueToken();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public CompiledTemplate get_CompiledDefaultValue();
    internal void set_CompiledDefaultValue(CompiledTemplate value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[GeneratedCodeAttribute("ANTLR", "3.4.1.9004")]
[CLSCompliantAttribute("False")]
internal class Antlr4.StringTemplate.Compiler.GroupLexer : Lexer {
    public static int EOF;
    public static int ANONYMOUS_TEMPLATE;
    public static int BIGSTRING;
    public static int BIGSTRING_NO_NL;
    public static int COMMA;
    public static int COMMENT;
    public static int FALSE;
    public static int ID;
    public static int LINE_COMMENT;
    public static int STRING;
    public static int TRUE;
    public static int WS;
    public static int T__15;
    public static int T__16;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int T__28;
    public TemplateGroup group;
    private DFA8 dfa8;
    public string SourceName { get; }
    public string GrammarFileName { get; }
    public GroupLexer(ICharStream input);
    public GroupLexer(ICharStream input, RecognizerSharedState state);
    public virtual void ReportError(RecognitionException e);
    public virtual string get_SourceName();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("COMMA")]
private void mCOMMA();
    [GrammarRuleAttribute("FALSE")]
private void mFALSE();
    [GrammarRuleAttribute("TRUE")]
private void mTRUE();
    [GrammarRuleAttribute("T__15")]
private void mT__15();
    [GrammarRuleAttribute("T__16")]
private void mT__16();
    [GrammarRuleAttribute("T__17")]
private void mT__17();
    [GrammarRuleAttribute("T__18")]
private void mT__18();
    [GrammarRuleAttribute("T__19")]
private void mT__19();
    [GrammarRuleAttribute("T__20")]
private void mT__20();
    [GrammarRuleAttribute("T__21")]
private void mT__21();
    [GrammarRuleAttribute("T__22")]
private void mT__22();
    [GrammarRuleAttribute("T__23")]
private void mT__23();
    [GrammarRuleAttribute("T__24")]
private void mT__24();
    [GrammarRuleAttribute("T__25")]
private void mT__25();
    [GrammarRuleAttribute("T__26")]
private void mT__26();
    [GrammarRuleAttribute("T__27")]
private void mT__27();
    [GrammarRuleAttribute("T__28")]
private void mT__28();
    [GrammarRuleAttribute("ID")]
private void mID();
    [GrammarRuleAttribute("STRING")]
private void mSTRING();
    [GrammarRuleAttribute("BIGSTRING")]
private void mBIGSTRING();
    [GrammarRuleAttribute("BIGSTRING_NO_NL")]
private void mBIGSTRING_NO_NL();
    [GrammarRuleAttribute("ANONYMOUS_TEMPLATE")]
private void mANONYMOUS_TEMPLATE();
    [GrammarRuleAttribute("COMMENT")]
private void mCOMMENT();
    [GrammarRuleAttribute("LINE_COMMENT")]
private void mLINE_COMMENT();
    [GrammarRuleAttribute("WS")]
private void mWS();
    public virtual void mTokens();
    protected virtual void InitDFAs();
}
[GeneratedCodeAttribute("ANTLR", "3.4.1.9004")]
[CLSCompliantAttribute("False")]
internal class Antlr4.StringTemplate.Compiler.GroupParser : Parser {
    public static int EOF;
    public static int ANONYMOUS_TEMPLATE;
    public static int BIGSTRING;
    public static int BIGSTRING_NO_NL;
    public static int COMMA;
    public static int COMMENT;
    public static int FALSE;
    public static int ID;
    public static int LINE_COMMENT;
    public static int STRING;
    public static int TRUE;
    public static int WS;
    public static int T__15;
    public static int T__16;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int T__28;
    private TemplateGroup _group;
    internal static String[] tokenNames;
    protected ListStack`1<formalArgs_scope> formalArgs_stack;
    public TemplateGroup Group { get; internal set; }
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public GroupParser(ITokenStream input);
    public GroupParser(ITokenStream input, RecognizerSharedState state);
    private static GroupParser();
    public TemplateGroup get_Group();
    internal void set_Group(TemplateGroup value);
    public virtual void DisplayRecognitionError(String[] tokenNames, RecognitionException e);
    public virtual string get_SourceName();
    public virtual void Error(string msg);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("group")]
public void group(TemplateGroup group, string prefix);
    [GrammarRuleAttribute("oldStyleHeader")]
private void oldStyleHeader();
    [GrammarRuleAttribute("groupName")]
private string groupName();
    [GrammarRuleAttribute("delimiters")]
private void delimiters();
    [GrammarRuleAttribute("def")]
private void def(string prefix);
    [GrammarRuleAttribute("templateDef")]
public void templateDef(string prefix);
    [GrammarRuleAttribute("formalArgs")]
private List`1<FormalArgument> formalArgs();
    [GrammarRuleAttribute("formalArg")]
private void formalArg(List`1<FormalArgument> args);
    [GrammarRuleAttribute("dictDef")]
private void dictDef();
    [GrammarRuleAttribute("dict")]
private IDictionary`2<string, object> dict();
    [GrammarRuleAttribute("dictPairs")]
private void dictPairs(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("defaultValuePair")]
private void defaultValuePair(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("keyValuePair")]
private void keyValuePair(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("keyValue")]
private object keyValue();
}
internal class Antlr4.StringTemplate.Compiler.Instruction : object {
    public static int MaxOperands;
    public static int OperandSizeInBytes;
    public static Instruction[] instructions;
    internal string name;
    internal OperandType[] type;
    internal int nopnds;
    private static Instruction();
    public Instruction(string name);
    public Instruction(string name, OperandType a);
    public Instruction(string name, OperandType a, OperandType b);
}
internal enum Antlr4.StringTemplate.Compiler.OperandType : Enum {
    public int value__;
    public static OperandType None;
    public static OperandType String;
    public static OperandType Address;
    public static OperandType Int;
}
internal class Antlr4.StringTemplate.Compiler.StringTable : object {
    private Dictionary`2<string, int> table;
    private int i;
    public virtual int Add(string s);
    public virtual String[] ToArray();
}
internal class Antlr4.StringTemplate.Compiler.TemplateCompiler : object {
    public static int InitialCodeSize;
    public static string SubtemplatePrefix;
    public static IDictionary`2<string, RenderOption> supportedOptions;
    public static int NUM_OPTIONS;
    public static IDictionary`2<string, string> defaultOptionValues;
    public static IDictionary`2<string, Bytecode> funcs;
    public static int subtemplateCount;
    private TemplateGroup _group;
    public TemplateGroup Group { get; }
    public ErrorManager ErrorManager { get; }
    public char DelimiterStartChar { get; }
    public char DelimiterStopChar { get; }
    public TemplateCompiler(TemplateGroup group);
    private static TemplateCompiler();
    public TemplateGroup get_Group();
    public ErrorManager get_ErrorManager();
    public char get_DelimiterStartChar();
    public char get_DelimiterStopChar();
    public virtual CompiledTemplate Compile(string template);
    public virtual CompiledTemplate Compile(string name, string template);
    public virtual CompiledTemplate Compile(string srcName, string name, List`1<FormalArgument> args, string template, IToken templateToken);
    public static CompiledTemplate DefineBlankRegion(CompiledTemplate outermostImpl, IToken nameToken);
    public static string GetNewSubtemplateName();
    protected virtual void ReportMessageAndThrowTemplateException(ITokenStream tokens, IToken templateToken, Parser parser, RecognitionException re);
}
internal class Antlr4.StringTemplate.Compiler.TemplateException : Exception {
    public TemplateException(string message, Exception innerException);
}
internal class Antlr4.StringTemplate.Compiler.TemplateLexer : object {
    public static char EOF;
    public static int EOF_TYPE;
    public static int RBRACK;
    public static int LBRACK;
    public static int ELSE;
    public static int ELLIPSIS;
    public static int LCURLY;
    public static int BANG;
    [CLSCompliantAttribute("False")]
public static int EQUALS;
    public static int TEXT;
    public static int ID;
    public static int SEMI;
    public static int LPAREN;
    public static int IF;
    public static int ELSEIF;
    public static int COLON;
    public static int RPAREN;
    public static int COMMA;
    public static int RCURLY;
    public static int ENDIF;
    public static int RDELIM;
    public static int SUPER;
    public static int DOT;
    public static int LDELIM;
    public static int STRING;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int REGION_END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    public static IToken SkipToken;
    private char delimiterStartChar;
    private char delimiterStopChar;
    private bool scanningInsideExpr;
    public int subtemplateDepth;
    private ErrorManager errMgr;
    private IToken templateToken;
    private ICharStream input;
    private char c;
    private int startCharIndex;
    private int startLine;
    private int startCharPositionInLine;
    private Queue`1<IToken> tokens;
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public TemplateLexer(ICharStream input);
    public TemplateLexer(ErrorManager errMgr, ICharStream input, IToken templateToken);
    public TemplateLexer(ErrorManager errMgr, ICharStream input, IToken templateToken, char delimiterStartChar, char delimiterStopChar);
    private static TemplateLexer();
    public virtual string get_SourceName();
    public sealed virtual String[] get_TokenNames();
    public virtual IToken NextToken();
    public virtual void Match(char x);
    protected virtual void Consume();
    public virtual void Emit(IToken token);
    public virtual IToken NextTokenImpl();
    protected virtual IToken NextTokenOutside();
    protected virtual IToken NextTokenInside();
    private IToken MatchSubTemplate();
    private IToken MatchEscape();
    private IToken MatchUnicode();
    private IToken MatchText();
    private IToken MatchIdentifier();
    private IToken MatchString();
    private void ConsumeWhitespace();
    private IToken MatchComment();
    private void ConsumeLineBreak();
    public static bool IsIDStartLetter(char c);
    public static bool IsIDLetter(char c);
    public static bool IsWS(char c);
    public static bool IsUnicodeLetter(char c);
    public virtual IToken NewToken(int ttype);
    public virtual IToken NewTokenFromPreviousChar(int ttype);
    public virtual IToken NewToken(int ttype, string text, int pos);
    public virtual IToken NewToken(int ttype, string text);
    private static string GetCharString(char c);
}
[CLSCompliantAttribute("False")]
[GeneratedCodeAttribute("ANTLR", "3.4.1.9004")]
internal class Antlr4.StringTemplate.Compiler.TemplateParser : Parser {
    public static int EOF;
    public static int IF;
    public static int ELSE;
    public static int ELSEIF;
    public static int ENDIF;
    public static int SUPER;
    public static int SEMI;
    public static int BANG;
    public static int ELLIPSIS;
    public static int EQUALS;
    public static int COLON;
    public static int LPAREN;
    public static int RPAREN;
    public static int LBRACK;
    public static int RBRACK;
    public static int COMMA;
    public static int DOT;
    public static int LCURLY;
    public static int RCURLY;
    public static int TEXT;
    public static int LDELIM;
    public static int RDELIM;
    public static int ID;
    public static int STRING;
    public static int WS;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    public static int ARGS;
    public static int ELEMENTS;
    public static int EXEC_FUNC;
    public static int EXPR;
    public static int INCLUDE;
    public static int INCLUDE_IND;
    public static int INCLUDE_REGION;
    public static int INCLUDE_SUPER;
    public static int INCLUDE_SUPER_REGION;
    public static int LIST;
    public static int MAP;
    public static int NULL;
    public static int OPTIONS;
    public static int PROP;
    public static int PROP_IND;
    public static int REGION;
    public static int SUBTEMPLATE;
    public static int TO_STR;
    public static int ZIP;
    private ErrorManager errMgr;
    private IToken templateToken;
    internal static String[] tokenNames;
    private ITreeAdaptor adaptor;
    protected ListStack`1<conditional_scope> conditional_stack;
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public TemplateParser(ITokenStream input, ErrorManager errMgr, IToken templateToken);
    private TemplateParser(ITokenStream input);
    private TemplateParser(ITokenStream input, RecognizerSharedState state);
    private static TemplateParser();
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public ITreeAdaptor get_TreeAdaptor();
    public void set_TreeAdaptor(ITreeAdaptor value);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("templateAndEOF")]
public AstParserRuleReturnScope`2<CommonTree, CommonToken> templateAndEOF();
    [GrammarRuleAttribute("template")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> template();
    [GrammarRuleAttribute("element")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> element();
    [GrammarRuleAttribute("singleElement")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> singleElement();
    [GrammarRuleAttribute("compoundElement")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> compoundElement();
    [GrammarRuleAttribute("exprTag")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprTag();
    [GrammarRuleAttribute("region")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> region();
    [GrammarRuleAttribute("regionbody")]
private regionbody_return regionbody();
    [GrammarRuleAttribute("subtemplate")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate();
    [GrammarRuleAttribute("subtemplateargs")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplateargs();
    [GrammarRuleAttribute("subtemplate_args_trunc")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate_args_trunc();
    [GrammarRuleAttribute("subtemplate_args_last")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate_args_last();
    [GrammarRuleAttribute("ifstat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> ifstat();
    [GrammarRuleAttribute("ifstatbody")]
private ifstatbody_return ifstatbody();
    [GrammarRuleAttribute("elseifstat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> elseifstat();
    [GrammarRuleAttribute("elsestat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> elsestat();
    [GrammarRuleAttribute("conditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> conditional();
    [GrammarRuleAttribute("andConditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> andConditional();
    [GrammarRuleAttribute("notConditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> notConditional();
    [GrammarRuleAttribute("exprOptions")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprOptions();
    [GrammarRuleAttribute("option")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> option();
    [GrammarRuleAttribute("exprNoComma")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprNoComma();
    [GrammarRuleAttribute("expr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> expr();
    [GrammarRuleAttribute("mapExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> mapExpr();
    [GrammarRuleAttribute("mapTemplateRef")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> mapTemplateRef();
    [GrammarRuleAttribute("memberExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> memberExpr();
    [GrammarRuleAttribute("includeExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> includeExpr();
    [GrammarRuleAttribute("primary")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> primary();
    [GrammarRuleAttribute("args")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> args();
    [GrammarRuleAttribute("argExprList")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> argExprList();
    [GrammarRuleAttribute("arg")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> arg();
    [GrammarRuleAttribute("namedArg")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> namedArg();
    [GrammarRuleAttribute("list")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> list();
}
internal class Antlr4.StringTemplate.Debug.AddAttributeEvent : ConstructionEvent {
    private string name;
    private object value;
    public string Name { get; }
    public object Value { get; }
    public AddAttributeEvent(string name, object value);
    public string get_Name();
    public object get_Value();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Debug.ConstructionEvent : object {
    private StackTrace stack;
    public virtual string GetFileName();
    public virtual int GetLine();
    public virtual StackFrame GetTemplateEntryPoint();
}
internal class Antlr4.StringTemplate.Debug.DebugEvents : object {
    public List`1<InterpEvent> Events;
    public List`1<EvalTemplateEvent> ChildEvalTemplateEvents;
}
internal class Antlr4.StringTemplate.Debug.EvalExprEvent : InterpEvent {
    private Interval _sourceInterval;
    private string expr;
    public Interval SourceInterval { get; }
    public string Expr { get; }
    public EvalExprEvent(TemplateFrame frame, Interval outputInterval, Interval sourceInterval);
    public Interval get_SourceInterval();
    public string get_Expr();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Debug.EvalTemplateEvent : InterpEvent {
    public EvalTemplateEvent(TemplateFrame frame, Interval interval);
}
internal class Antlr4.StringTemplate.Debug.IndentEvent : EvalExprEvent {
    public IndentEvent(TemplateFrame frame, Interval outputInterval, Interval sourceInterval);
}
internal class Antlr4.StringTemplate.Debug.InterpEvent : object {
    private TemplateFrame _frame;
    private Interval _interval;
    public TemplateFrame Frame { get; }
    public Template Template { get; }
    public Interval OutputInterval { get; }
    public InterpEvent(TemplateFrame frame, Interval interval);
    public TemplateFrame get_Frame();
    public Template get_Template();
    public Interval get_OutputInterval();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Antlr4.StringTemplate.Extensions.ExceptionExtensions : object {
    private static Action`1<Exception> _internalPreserveStackTrace;
    private static ExceptionExtensions();
    [ExtensionAttribute]
public static bool IsCritical(Exception e);
    [ExtensionAttribute]
public static void PreserveStackTrace(Exception e);
}
internal interface Antlr4.StringTemplate.IAttributeRenderer {
    public abstract virtual string ToString(object obj, string formatString, CultureInfo culture);
}
internal interface Antlr4.StringTemplate.IModelAdaptor {
    public abstract virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object obj, object property, string propertyName);
}
internal class Antlr4.StringTemplate.Interpreter : object {
    public static int DefaultOperandStackSize;
    private static String[] predefinedAnonSubtemplateAttributes;
    private static bool trace;
    private TemplateGroup group;
    private CultureInfo culture;
    private ErrorManager _errorManager;
    private Object[] operands;
    private int sp;
    private int nwline;
    private List`1<string> executeTrace;
    private bool _debug;
    private List`1<InterpEvent> events;
    [CompilerGeneratedAttribute]
private static Func`2<FormalArgument, string> CS$<>9__CachedAnonymousMethodDelegate6;
    public static ReadOnlyCollection`1<string> PredefinedAnonymousSubtemplateAttributes { get; }
    public Interpreter(TemplateGroup group, bool debug);
    public Interpreter(TemplateGroup group, CultureInfo culture, bool debug);
    public Interpreter(TemplateGroup group, ErrorManager errorManager, bool debug);
    public Interpreter(TemplateGroup group, CultureInfo culture, ErrorManager errorManager, bool debug);
    private static Interpreter();
    public static ReadOnlyCollection`1<string> get_PredefinedAnonymousSubtemplateAttributes();
    public virtual int Execute(ITemplateWriter out, TemplateFrame frame);
    protected virtual int ExecuteImpl(ITemplateWriter out, TemplateFrame frame);
    internal virtual void SuperNew(TemplateFrame frame, string name, int nargs);
    internal virtual void SuperNew(TemplateFrame frame, string name, IDictionary`2<string, object> attrs);
    internal virtual void PassThrough(TemplateFrame frame, string templateName, IDictionary`2<string, object> attrs);
    internal virtual void StoreArguments(TemplateFrame frame, IDictionary`2<string, object> attrs, Template st);
    internal virtual void StoreArguments(TemplateFrame frame, int nargs, Template st);
    protected void Indent(ITemplateWriter out, TemplateFrame frame, int strIndex);
    protected virtual int WriteObjectNoOptions(ITemplateWriter out, TemplateFrame frame, object o);
    protected virtual int WriteObjectWithOptions(ITemplateWriter out, TemplateFrame frame, object o, Object[] options);
    protected virtual int WriteObject(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual int WriteIterator(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual int WritePlainObject(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual Interval GetExpressionInterval(TemplateFrame frame);
    protected virtual void Map(TemplateFrame frame, object attr, Template st);
    protected virtual void RotateMap(TemplateFrame frame, object attr, List`1<Template> prototypes);
    protected virtual List`1<Template> RotateMapIterator(TemplateFrame frame, IEnumerator iterator, List`1<Template> prototypes);
    protected virtual AttributeList ZipMap(TemplateFrame frame, List`1<object> exprs, Template prototype);
    protected virtual void SetFirstArgument(TemplateFrame frame, Template st, object attr);
    protected virtual void AddToList(List`1<object> list, TemplateFrame frame, object o);
    public virtual object First(TemplateFrame frame, object v);
    public virtual object Last(TemplateFrame frame, object v);
    public virtual object Rest(TemplateFrame frame, object v);
    public virtual object Trunc(TemplateFrame frame, object v);
    public virtual object Strip(TemplateFrame frame, object v);
    public virtual object Reverse(TemplateFrame frame, object v);
    public virtual object Length(object v);
    protected virtual string ToString(TemplateFrame frame, object value);
    public static object ConvertAnythingIteratableToIterator(TemplateFrame frame, object o);
    public static IEnumerator ConvertAnythingToIterator(TemplateFrame frame, object o);
    protected virtual bool TestAttributeTrue(object a);
    protected virtual object GetObjectProperty(TemplateFrame frame, object o, object property);
    public virtual object GetAttribute(TemplateFrame frame, string name);
    protected virtual void SetDefaultArguments(TemplateFrame frame);
    protected virtual void Trace(TemplateFrame frame, int ip);
    protected virtual void PrintForTrace(StringBuilder tr, TemplateFrame frame, object o);
    public virtual List`1<InterpEvent> GetEvents();
    protected void TrackDebugEvent(TemplateFrame frame, InterpEvent e);
    public virtual List`1<string> GetExecutionTrace();
    private static int GetShort(Byte[] value, int startIndex);
    [CompilerGeneratedAttribute]
private static string <ZipMap>b__5(FormalArgument i);
}
internal interface Antlr4.StringTemplate.ITemplateErrorListener {
    public abstract virtual void CompiletimeError(TemplateMessage msg);
    public abstract virtual void RuntimeError(TemplateMessage msg);
    public abstract virtual void IOError(TemplateMessage msg);
    public abstract virtual void InternalError(TemplateMessage msg);
}
internal interface Antlr4.StringTemplate.ITemplateWriter {
    public int Index { get; }
    public int LineWidth { get; public set; }
    public abstract virtual int get_Index();
    public abstract virtual int get_LineWidth();
    public abstract virtual void set_LineWidth(int value);
    public abstract virtual void PushIndentation(string indent);
    public abstract virtual string PopIndentation();
    public abstract virtual void PushAnchorPoint();
    public abstract virtual void PopAnchorPoint();
    public abstract virtual int Write(string str);
    public abstract virtual int Write(string str, string wrap);
    public abstract virtual int WriteWrap(string wrap);
    public abstract virtual int WriteSeparator(string str);
}
internal interface Antlr4.StringTemplate.ITypeProxyFactory {
    public abstract virtual object CreateProxy(TemplateFrame frame, object obj);
}
[DefaultMemberAttribute("Item")]
internal class Antlr4.StringTemplate.Misc.Aggregate : object {
    private Dictionary`2<string, object> _properties;
    public IDictionary`2<string, object> Properties { get; }
    public object Item { get; internal set; }
    public IDictionary`2<string, object> get_Properties();
    public object get_Item(string propertyName);
    internal void set_Item(string propertyName, object value);
    public bool TryGetValue(string propertyName, Object& value);
}
internal class Antlr4.StringTemplate.Misc.AggregateModelAdaptor : MapModelAdaptor {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
internal class Antlr4.StringTemplate.Misc.AttributeNotFoundException : TemplateException {
    private TemplateFrame _frame;
    private string _attributeName;
    public string Message { get; }
    public AttributeNotFoundException(TemplateFrame frame, string attributeName);
    public virtual string get_Message();
}
[DebuggerDisplayAttribute("({_line},{_charPosition})")]
internal class Antlr4.StringTemplate.Misc.Coordinate : ValueType {
    private int _line;
    private int _charPosition;
    public int Line { get; }
    public int CharPosition { get; }
    public Coordinate(int line, int charPosition);
    public int get_Line();
    public int get_CharPosition();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.DebugErrorListener : object {
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual void Error(string s);
    public virtual void Error(string s, Exception e);
}
internal class Antlr4.StringTemplate.Misc.ErrorBuffer : object {
    private List`1<TemplateMessage> errors;
    public ReadOnlyCollection`1<TemplateMessage> Errors { get; }
    protected List`1<TemplateMessage> ErrorList { get; }
    public ReadOnlyCollection`1<TemplateMessage> get_Errors();
    protected List`1<TemplateMessage> get_ErrorList();
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.ErrorManager : object {
    private static ITemplateErrorListener _defaultErrorListener;
    private ITemplateErrorListener _listener;
    public static ITemplateErrorListener DefaultErrorListener { get; public set; }
    public ITemplateErrorListener Listener { get; }
    public ErrorManager(ITemplateErrorListener listener);
    private static ErrorManager();
    public static ITemplateErrorListener get_DefaultErrorListener();
    public static void set_DefaultErrorListener(ITemplateErrorListener value);
    public ITemplateErrorListener get_Listener();
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t);
    public virtual void LexerError(string srcName, string msg, IToken templateToken, RecognitionException e);
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t, object arg);
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t, object arg, object arg2);
    public virtual void GroupSyntaxError(ErrorType error, string sourceName, IToken token);
    public virtual void GroupSyntaxError(ErrorType error, string sourceName, RecognitionException e, string message);
    public virtual void GroupLexerError(ErrorType error, string srcName, RecognitionException e, string msg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, Exception e, object arg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg, object arg2);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg, object arg2, object arg3);
    public virtual void IOError(Template self, ErrorType error, Exception e);
    public virtual void IOError(Template self, ErrorType error, Exception e, object arg);
    public virtual void InternalError(Template self, string msg, Exception e);
}
[DebuggerDisplayAttribute("{Message}")]
internal class Antlr4.StringTemplate.Misc.ErrorType : object {
    public static ErrorType NO_SUCH_TEMPLATE;
    public static ErrorType NO_IMPORTED_TEMPLATE;
    public static ErrorType NO_SUCH_ATTRIBUTE;
    public static ErrorType REF_TO_IMPLICIT_ATTRIBUTE_OUT_OF_SCOPE;
    public static ErrorType MISSING_FORMAL_ARGUMENTS;
    public static ErrorType NO_SUCH_PROPERTY;
    public static ErrorType MAP_ARGUMENT_COUNT_MISMATCH;
    public static ErrorType ARGUMENT_COUNT_MISMATCH;
    public static ErrorType EXPECTING_STRING;
    public static ErrorType CANT_IMPORT;
    public static ErrorType SYNTAX_ERROR;
    public static ErrorType TEMPLATE_REDEFINITION;
    public static ErrorType EMBEDDED_REGION_REDEFINITION;
    public static ErrorType REGION_REDEFINITION;
    public static ErrorType HIDDEN_EMBEDDED_REGION_DEFINITION;
    public static ErrorType MAP_REDEFINITION;
    public static ErrorType ALIAS_TARGET_UNDEFINED;
    public static ErrorType TEMPLATE_REDEFINITION_AS_MAP;
    public static ErrorType LEXER_ERROR;
    public static ErrorType NO_DEFAULT_VALUE;
    public static ErrorType NO_SUCH_FUNCTION;
    public static ErrorType NO_SUCH_REGION;
    public static ErrorType NO_SUCH_OPTION;
    public static ErrorType INVALID_TEMPLATE_NAME;
    public static ErrorType ANON_ARGUMENT_MISMATCH;
    public static ErrorType REQUIRED_PARAMETER_AFTER_OPTIONAL;
    public static ErrorType INVALID_DELIMITER;
    public static ErrorType INTERNAL_ERROR;
    public static ErrorType WRITE_IO_ERROR;
    public static ErrorType CANT_LOAD_GROUP_FILE;
    private string _message;
    public string Message { get; }
    private ErrorType(string m);
    private static ErrorType();
    public string get_Message();
}
internal static class Antlr4.StringTemplate.Misc.HttpUtility : object {
    internal static string UrlEncode(string str);
    internal static string UrlEncode(string str, Encoding e);
    internal static Byte[] UrlEncodeToBytes(string str, Encoding e);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    internal static bool IsUrlSafeChar(char ch);
    internal static char IntToHex(int n);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
[DebuggerDisplayAttribute("[{Start}..{End})")]
internal class Antlr4.StringTemplate.Misc.Interval : object {
    private int _start;
    private int _length;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Interval(int start, int length);
    public int get_Start();
    public int get_End();
    public int get_Length();
    public bool get_IsEmpty();
    public static Interval FromBounds(int start, int end);
    public bool Contains(int position);
    public bool Contains(Interval interval);
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.MapModelAdaptor : object {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
internal class Antlr4.StringTemplate.Misc.MultiMap`2 : Dictionary`2<TKey, List`1<TValue>> {
    public virtual void Add(TKey key, TValue value);
}
internal class Antlr4.StringTemplate.Misc.ObjectModelAdaptor : object {
    private static Dictionary`2<Type, Dictionary`2<string, Func`2<object, object>>> _memberAccessors;
    private static ObjectModelAdaptor();
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
    private static Func`2<object, object> FindMember(Type type, string name);
    private static bool IsIndexer(PropertyInfo propertyInfo);
    private static Func`2<object, object> BuildAccessor(MethodInfo method);
    private static Func`2<object, object> BuildAccessor(MethodInfo method, string argument);
    private static Func`2<object, object> BuildAccessor(FieldInfo field);
}
internal class Antlr4.StringTemplate.Misc.TemplateCompiletimeMessage : TemplateMessage {
    private IToken templateToken;
    private IToken token;
    private string srcName;
    public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t);
    public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause);
    public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg);
    public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg, object arg2);
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.TemplateGroupCompiletimeMessage : TemplateMessage {
    private IToken token;
    private string srcName;
    public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t);
    public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause);
    public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg);
    public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg, object arg2);
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.TemplateLexerMessage : TemplateMessage {
    private string msg;
    private IToken templateToken;
    private string srcName;
    public TemplateLexerMessage(string srcName, string msg, IToken templateToken, Exception cause);
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.TemplateMessage : object {
    private Template self;
    private ErrorType error;
    private object arg;
    private object arg2;
    private object arg3;
    private Exception cause;
    public Template Self { get; }
    public ErrorType Error { get; }
    public object Arg { get; }
    public object Arg2 { get; }
    public object Arg3 { get; }
    public Exception Cause { get; }
    public TemplateMessage(ErrorType error);
    public TemplateMessage(ErrorType error, Template self);
    public TemplateMessage(ErrorType error, Template self, Exception cause);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg);
    public TemplateMessage(ErrorType error, Template self, Exception cause, IToken where, object arg);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2, object arg3);
    public Template get_Self();
    public ErrorType get_Error();
    public object get_Arg();
    public object get_Arg2();
    public object get_Arg3();
    public Exception get_Cause();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.TemplateModelAdaptor : object {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
internal class Antlr4.StringTemplate.Misc.TemplateNoSuchPropertyException : TemplateException {
    private object _object;
    private string _propertyName;
    public string PropertyName { get; }
    public TemplateNoSuchPropertyException(object obj, string propertyName);
    public TemplateNoSuchPropertyException(object obj, string propertyName, Exception innerException);
    public string get_PropertyName();
}
internal class Antlr4.StringTemplate.Misc.TemplateRuntimeMessage : TemplateMessage {
    private int ip;
    private TemplateFrame _frame;
    public TemplateFrame Frame { get; }
    public Interval SourceInterval { get; }
    public TemplateRuntimeMessage(ErrorType error, int ip);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, object arg);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg, object arg2);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg, object arg2, object arg3);
    public TemplateFrame get_Frame();
    public Interval get_SourceInterval();
    public virtual string GetSourceLocation();
    public virtual string ToString();
}
internal class Antlr4.StringTemplate.Misc.TextWriterErrorListener : object {
    private TextWriter _writer;
    public TextWriterErrorListener(TextWriter writer);
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual void Error(string s);
    public virtual void Error(string s, Exception e);
}
[DefaultMemberAttribute("Item")]
internal class Antlr4.StringTemplate.Misc.TypeRegistry`1 : object {
    private Dictionary`2<Type, T> _backingStore;
    private Dictionary`2<Type, Type> _cache;
    [CompilerGeneratedAttribute]
private static Predicate`1<Type> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<Type, Type>, Type> CS$<>9__CachedAnonymousMethodDelegate7;
    private ICollection`1<Type> System.Collections.Generic.IDictionary<System.Type,T>.Keys { get; }
    private ICollection`1<T> System.Collections.Generic.IDictionary<System.Type,T>.Values { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Count { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public TypeRegistry`1(IEnumerable`1<KeyValuePair`2<Type, T>> collection);
    private sealed virtual override ICollection`1<Type> System.Collections.Generic.IDictionary<System.Type,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.Type,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.get_Count();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(Type key);
    public sealed virtual void set_Item(Type key, T value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(Type key, T value);
    public sealed virtual bool ContainsKey(Type key);
    public sealed virtual bool Remove(Type key);
    public sealed virtual bool TryGetValue(Type key, T& value);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, T>> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Add(KeyValuePair`2<Type, T> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Contains(KeyValuePair`2<Type, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Remove(KeyValuePair`2<Type, T> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private void HandleAlteration(Type type);
    [CompilerGeneratedAttribute]
private static bool <TryGetValue>b__1(Type i);
    [CompilerGeneratedAttribute]
private static Type <HandleAlteration>b__6(KeyValuePair`2<Type, Type> i);
}
internal static class Antlr4.StringTemplate.Misc.Utility : object {
    public static string Strip(string s, int n);
    public static string TrimOneStartingNewline(string s);
    public static string TrimOneTrailingNewline(string s);
    public static string GetParent(string name);
    public static string GetPrefix(string name);
    public static string ReplaceEscapes(string s);
    public static Coordinate GetLineCharPosition(string s, int index);
}
internal class Antlr4.StringTemplate.NoIndentWriter : AutoIndentWriter {
    public NoIndentWriter(TextWriter writer);
    public virtual int Write(string value);
}
internal class Antlr4.StringTemplate.NumberRenderer : object {
    public virtual string ToString(object o, string formatString, CultureInfo culture);
}
internal enum Antlr4.StringTemplate.RenderOption : Enum {
    public int value__;
    public static RenderOption Anchor;
    public static RenderOption Format;
    public static RenderOption Null;
    public static RenderOption Separator;
    public static RenderOption Wrap;
}
internal class Antlr4.StringTemplate.StringRenderer : object {
    public virtual string ToString(object o, string formatString, CultureInfo culture);
}
internal class Antlr4.StringTemplate.Template : object {
    public static string UnknownName;
    public static object EmptyAttribute;
    public CompiledTemplate impl;
    protected internal Object[] locals;
    private TemplateGroup groupThatCreatedThisInstance;
    private TemplateDebugState _debugState;
    [CompilerGeneratedAttribute]
private static Converter`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<FormalArgument, string> CS$<>9__CachedAnonymousMethodDelegate4;
    public TemplateDebugState DebugState { get; public set; }
    public TemplateGroup Group { get; public set; }
    public string Name { get; }
    public bool IsAnonymousSubtemplate { get; }
    internal Template(TemplateGroup group);
    public Template(string template);
    public Template(string template, char delimiterStartChar, char delimiterStopChar);
    public Template(TemplateGroup group, string template);
    public Template(Template prototype);
    protected Template(Template prototype, bool shadowLocals);
    private static Template();
    public TemplateDebugState get_DebugState();
    public void set_DebugState(TemplateDebugState value);
    public TemplateGroup get_Group();
    public void set_Group(TemplateGroup value);
    public virtual Template CreateShadow();
    public virtual Template Add(string name, object value);
    public Template AddMany(string aggrSpec, Object[] values);
    public virtual void Remove(string name);
    protected internal virtual void RawSetAttribute(string name, object value);
    public virtual object GetAttribute(string name);
    public virtual IDictionary`2<string, object> GetAttributes();
    protected static AttributeList ConvertToAttributeList(object curvalue);
    public virtual string get_Name();
    public virtual bool get_IsAnonymousSubtemplate();
    public virtual int Write(ITemplateWriter out);
    public virtual int Write(ITemplateWriter out, CultureInfo culture);
    public virtual int Write(ITemplateWriter out, ITemplateErrorListener listener);
    public virtual int Write(ITemplateWriter out, CultureInfo culture, ITemplateErrorListener listener);
    public virtual int Write(TextWriter writer, ITemplateErrorListener listener);
    public virtual int Write(TextWriter writer, ITemplateErrorListener listener, int lineWidth);
    public virtual int Write(TextWriter writer, CultureInfo culture, ITemplateErrorListener listener, int lineWidth);
    public virtual string Render();
    public virtual string Render(int lineWidth);
    public virtual string Render(CultureInfo culture);
    public virtual string Render(CultureInfo culture, int lineWidth);
    public virtual List`1<InterpEvent> GetEvents();
    public virtual List`1<InterpEvent> GetEvents(int lineWidth);
    public virtual List`1<InterpEvent> GetEvents(ITemplateWriter writer);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo locale);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo locale, int lineWidth);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo culture, ITemplateWriter writer);
    public virtual string ToString();
    public static string Format(string template, Object[] attributes);
    public static string Format(int lineWidth, string template, Object[] attributes);
    [CompilerGeneratedAttribute]
private static string <AddMany>b__0(string p);
    [CompilerGeneratedAttribute]
private static string <ToString>b__3(FormalArgument i);
}
internal class Antlr4.StringTemplate.TemplateFrame : object {
    private Template _template;
    private TemplateFrame _parent;
    private int _depth;
    private int _ip;
    private DebugEvents _debugState;
    public Template Template { get; }
    public TemplateFrame Parent { get; }
    public int StackDepth { get; }
    public int InstructionPointer { get; public set; }
    public TemplateFrame(Template template, TemplateFrame parent);
    public Template get_Template();
    public TemplateFrame get_Parent();
    public int get_StackDepth();
    public int get_InstructionPointer();
    public void set_InstructionPointer(int value);
    public DebugEvents GetDebugState();
    public string GetEnclosingInstanceStackString();
    public List`1<Template> GetEnclosingInstanceStack(bool topdown);
    public List`1<TemplateFrame> GetFrameStack(bool topdown);
    public List`1<EvalTemplateEvent> GetEvalTemplateEventStack(bool topdown);
}
internal class Antlr4.StringTemplate.TemplateGroup : object {
    public static string DictionaryKey;
    public static string DefaultKey;
    private Encoding _encoding;
    private List`1<TemplateGroup> _imports;
    private List`1<TemplateGroup> _importsToClearOnUnload;
    private char delimiterStartChar;
    private char delimiterStopChar;
    private Dictionary`2<string, CompiledTemplate> templates;
    private Dictionary`2<string, IDictionary`2<string, object>> dictionaries;
    private TypeRegistry`1<IAttributeRenderer> renderers;
    private TypeRegistry`1<ITypeProxyFactory> _proxyFactories;
    protected TypeRegistry`1<IModelAdaptor> adaptors;
    private bool _verbose;
    private bool _trackCreationEvents;
    private bool _iterateAcrossValues;
    protected static CompiledTemplate NotFoundTemplate;
    private static ErrorManager _defaultErrorManager;
    private static TemplateGroup _defaultGroup;
    private ErrorManager _errorManager;
    [CompilerGeneratedAttribute]
private static Func`2<FormalArgument, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public static ErrorManager DefaultErrorManager { get; }
    public static TemplateGroup DefaultGroup { get; public set; }
    public char DelimiterStartChar { get; }
    public char DelimiterStopChar { get; }
    public ICollection`1<CompiledTemplate> CompiledTemplates { get; }
    public Encoding Encoding { get; public set; }
    public ErrorManager ErrorManager { get; public set; }
    public bool Verbose { get; public set; }
    public bool TrackCreationEvents { get; public set; }
    public bool IterateAcrossValues { get; public set; }
    public ReadOnlyCollection`1<TemplateGroup> ImportedGroups { get; }
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public ITemplateErrorListener Listener { get; public set; }
    public TemplateGroup(char delimiterStartChar, char delimiterStopChar);
    private static TemplateGroup();
    public static ErrorManager get_DefaultErrorManager();
    public static TemplateGroup get_DefaultGroup();
    public static void set_DefaultGroup(TemplateGroup value);
    public char get_DelimiterStartChar();
    public char get_DelimiterStopChar();
    public ICollection`1<CompiledTemplate> get_CompiledTemplates();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public ErrorManager get_ErrorManager();
    public void set_ErrorManager(ErrorManager value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_TrackCreationEvents();
    public void set_TrackCreationEvents(bool value);
    public bool get_IterateAcrossValues();
    public void set_IterateAcrossValues(bool value);
    public ReadOnlyCollection`1<TemplateGroup> get_ImportedGroups();
    public virtual Template GetInstanceOf(string name);
    protected internal virtual Template GetEmbeddedInstanceOf(TemplateFrame frame, string name);
    public virtual Template CreateSingleton(IToken templateToken);
    public virtual bool IsDefined(string name);
    public virtual CompiledTemplate LookupTemplate(string name);
    public virtual void Unload();
    protected virtual CompiledTemplate Load(string name);
    public virtual void Load();
    protected internal virtual CompiledTemplate LookupImportedTemplate(string name);
    public virtual CompiledTemplate RawGetTemplate(string name);
    public virtual IDictionary`2<string, object> RawGetDictionary(string name);
    public virtual bool IsDictionary(string name);
    public virtual CompiledTemplate DefineTemplate(string name, string template);
    public virtual CompiledTemplate DefineTemplate(string name, string template, String[] arguments);
    public virtual CompiledTemplate DefineTemplate(string fullyQualifiedTemplateName, IToken nameT, List`1<FormalArgument> args, string template, IToken templateToken);
    public virtual CompiledTemplate DefineTemplateAlias(IToken aliasT, IToken targetT);
    public virtual CompiledTemplate DefineRegion(string enclosingTemplateName, IToken regionT, string template, IToken templateToken);
    public virtual void DefineTemplateOrRegion(string fullyQualifiedTemplateName, string regionSurroundingTemplateName, IToken templateToken, string template, IToken nameToken, List`1<FormalArgument> args);
    public virtual void RawDefineTemplate(string name, CompiledTemplate code, IToken defT);
    public virtual void UndefineTemplate(string name);
    public virtual CompiledTemplate Compile(string srcName, string name, List`1<FormalArgument> args, string template, IToken templateToken);
    public static string GetMangledRegionName(string enclosingTemplateName, string name);
    public static string GetUnmangledTemplateName(string mangledName);
    public virtual void DefineDictionary(string name, IDictionary`2<string, object> mapping);
    public virtual void SetDelimiters(IToken openDelimiter, IToken closeDelimiter);
    public virtual void SetDelimiters(char delimiterStartChar, char delimiterStopChar);
    public virtual void ImportTemplates(TemplateGroup g);
    private void ImportTemplates(TemplateGroup group, bool clearOnUnload);
    public virtual void ImportTemplates(IToken fileNameToken);
    public virtual void LoadGroupFile(string prefix, string fileName);
    public virtual CompiledTemplate LoadAbsoluteTemplateFile(string fileName);
    public CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName, ICharStream templateStream);
    public virtual void RegisterModelAdaptor(Type attributeType, IModelAdaptor adaptor);
    public virtual IModelAdaptor GetModelAdaptor(Type attributeType);
    public void RegisterRenderer(Type attributeType, IAttributeRenderer renderer);
    public virtual void RegisterRenderer(Type attributeType, IAttributeRenderer renderer, bool recursive);
    public virtual IAttributeRenderer GetAttributeRenderer(Type attributeType);
    public virtual void RegisterTypeProxyFactory(Type targetType, ITypeProxyFactory factory);
    public virtual ITypeProxyFactory GetTypeProxyFactory(Type targetType);
    public virtual Template CreateStringTemplate();
    public virtual Template CreateStringTemplate(CompiledTemplate impl);
    public Template CreateStringTemplateInternally(CompiledTemplate impl);
    public Template CreateStringTemplateInternally(Template prototype);
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
    public virtual string ToString();
    public virtual string Show();
    public virtual ITemplateErrorListener get_Listener();
    public virtual void set_Listener(ITemplateErrorListener value);
    [CompilerGeneratedAttribute]
private static string <Show>b__2(FormalArgument i);
}
internal class Antlr4.StringTemplate.TemplateGroupDirectory : TemplateGroup {
    public string groupDirName;
    public Uri root;
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public TemplateGroupDirectory(string dirName);
    public TemplateGroupDirectory(string dirName, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupDirectory(string dirName, Encoding encoding);
    public TemplateGroupDirectory(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupDirectory(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    protected virtual CompiledTemplate Load(string name);
    public virtual CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName);
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
}
internal class Antlr4.StringTemplate.TemplateGroupFile : TemplateGroup {
    private string _fileName;
    private Uri _url;
    private bool _alreadyLoaded;
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public TemplateGroupFile(string fileName);
    public TemplateGroupFile(string fileName, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding);
    public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupFile(Uri url, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public virtual bool IsDefined(string name);
    public virtual void Unload();
    protected virtual CompiledTemplate Load(string name);
    public virtual void Load();
    public virtual string Show();
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
}
internal class Antlr4.StringTemplate.TemplateGroupString : TemplateGroup {
    private string sourceName;
    private string text;
    private bool alreadyLoaded;
    public string FileName { get; }
    public TemplateGroupString(string text);
    public TemplateGroupString(string sourceName, string text);
    public TemplateGroupString(string sourceName, string text, char delimiterStartChar, char delimiterStopChar);
    public virtual string get_FileName();
    public virtual bool IsDefined(string name);
    public virtual void Load();
    protected virtual CompiledTemplate Load(string name);
}
internal class Antlr4.StringTemplate.TemplateName : object {
    private static Regex NameFormatRegex;
    private string _name;
    public bool IsRooted { get; }
    public bool IsTemplate { get; }
    public string Name { get; }
    public TemplateName(string name);
    private static TemplateName();
    public bool get_IsRooted();
    public bool get_IsTemplate();
    public string get_Name();
    public static TemplateName op_Implicit(string name);
    public static string GetTemplatePath(string localPathRoot, TemplateName templateName);
}
[DefaultMemberAttribute("Item")]
internal abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public abstract virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor : object {
    private Dictionary`2<IDictionaryAdapter, int> scopes;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    protected bool Cancelled { get; protected set; }
    protected AbstractDictionaryAdapterVisitor(AbstractDictionaryAdapterVisitor parent);
    [CompilerGeneratedAttribute]
protected bool get_Cancelled();
    [CompilerGeneratedAttribute]
protected void set_Cancelled(bool value);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    protected virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    private bool PushScope(IDictionaryAdapter dictionaryAdapter);
    private void PopScope(IDictionaryAdapter dictionaryAdapter);
    private static bool IsCollection(PropertyDescriptor property, Type& collectionItemType);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.BindingList`1 : object {
    private BindingList`1<T> list;
    public BindingList`1<T> InnerList { get; }
    public IBindingList AsBindingList { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool AllowNew { get; public set; }
    public bool AllowEdit { get; public set; }
    public bool AllowRemove { get; public set; }
    public bool RaiseListChangedEvents { get; public set; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public BindingList`1(IList`1<T> list);
    public BindingList`1(BindingList`1<T> list);
    public BindingList`1<T> get_InnerList();
    public sealed virtual IBindingList get_AsBindingList();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool get_AllowNew();
    public void set_AllowNew(bool value);
    public sealed virtual bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    public sealed virtual bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T AddNew();
    public sealed virtual void CancelNew(int index);
    public sealed virtual void EndNew(int index);
    public sealed virtual void Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public sealed virtual void Clear();
    public void ResetBindings();
    public void ResetItem(int index);
}
internal class Castle.Components.DictionaryAdapter.BindingListInitializer`1 : object {
    private Func`1<object> addNew;
    private Func`3<int, object, object> addAt;
    private Func`3<int, object, object> setAt;
    private Action`1<int> removeAt;
    private Action reset;
    private bool addingNew;
    public BindingListInitializer`1(Func`3<int, object, object> addAt, Func`1<object> addNew, Func`3<int, object, object> setAt, Action`1<int> removeAt, Action reset);
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__0(object sender, AddingNewEventArgs args);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.CascadingDictionaryAdapter : AbstractDictionaryAdapter {
    private IDictionary primary;
    private IDictionary secondary;
    public IDictionary Primary { get; }
    public IDictionary Secondary { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public CascadingDictionaryAdapter(IDictionary primary, IDictionary secondary);
    public IDictionary get_Primary();
    public IDictionary get_Secondary();
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.ComponentAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool NoPrefix { get; public set; }
    public string Prefix { get; public set; }
    public bool get_NoPrefix();
    public void set_NoPrefix(bool value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
internal class Castle.Components.DictionaryAdapter.DefaultPropertyGetter : object {
    private TypeConverter converter;
    public int ExecutionOrder { get; }
    public DefaultPropertyGetter(TypeConverter converter);
    public sealed virtual int get_ExecutionOrder();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual IDictionaryBehavior Copy();
}
[AttributeUsageAttribute("4")]
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    public Type InterfaceType { get; private set; }
    public DictionaryAdapterAttribute(Type interfaceType);
    [CompilerGeneratedAttribute]
public Type get_InterfaceType();
    [CompilerGeneratedAttribute]
private void set_InterfaceType(Type value);
}
[DefaultMemberAttribute("Item")]
internal abstract class Castle.Components.DictionaryAdapter.DictionaryAdapterBase : object {
    private int suppressEditingCount;
    private Stack`1<Dictionary`2<string, Edit>> updates;
    private HashSet`1<IEditableObject> editDependencies;
    [ThreadStaticAttribute]
private static TrackPropertyChangeScope readOnlyTrackingScope;
    private int suppressNotificationCount;
    private PropertyChangingEventHandler PropertyChanging;
    private PropertyChangedEventHandler PropertyChanged;
    private ICollection`1<IDictionaryValidator> validators;
    [CompilerGeneratedAttribute]
private DictionaryAdapterInstance <This>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsMultiLevelEdit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanValidate>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Dictionary`2<string, Edit>, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IChangeTracking, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate18;
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; private set; }
    public bool CanEdit { get; public set; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public bool IsChanged { get; }
    public bool CanNotify { get; public set; }
    public bool ShouldNotify { get; }
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryAdapterBase(DictionaryAdapterInstance instance);
    public sealed virtual void CopyTo(IDictionaryAdapter other);
    public sealed virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public sealed virtual T Coerce();
    public sealed virtual object Coerce(Type type);
    public sealed virtual T Create();
    public sealed virtual object Create(Type type);
    public sealed virtual T Create(IDictionary dictionary);
    public sealed virtual object Create(Type type, IDictionary dictionary);
    public sealed virtual T Create(Action`1<T> init);
    public sealed virtual T Create(IDictionary dictionary, Action`1<T> init);
    public abstract virtual DictionaryAdapterMeta get_Meta();
    [CompilerGeneratedAttribute]
public sealed virtual DictionaryAdapterInstance get_This();
    [CompilerGeneratedAttribute]
private void set_This(DictionaryAdapterInstance value);
    public sealed virtual string GetKey(string propertyName);
    public virtual object GetProperty(string propertyName, bool ifExists);
    public sealed virtual T GetPropertyOfType(string propertyName);
    public sealed virtual object ReadProperty(string key);
    public virtual bool SetProperty(string propertyName, Object& value);
    public sealed virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public sealed virtual void ClearProperty(PropertyDescriptor property, string key);
    public sealed virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void Initialize();
    private static IDictionary GetDictionary(IDictionary dictionary, String& key);
    public sealed virtual bool get_CanEdit();
    public void set_CanEdit(bool value);
    public sealed virtual bool get_IsEditing();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsMultiLevelEdit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SupportsMultiLevelEdit(bool value);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void RejectChanges();
    public sealed virtual void AcceptChanges();
    public sealed virtual IDisposable SuppressEditingBlock();
    public sealed virtual void SuppressEditing();
    public sealed virtual void ResumeEditing();
    protected bool GetEditedProperty(string propertyName, Object& propertyValue);
    protected bool EditProperty(PropertyDescriptor property, string key, object propertyValue);
    protected bool ClearEditProperty(PropertyDescriptor property, string key);
    protected void AddEditDependency(IEditableObject editDependency);
    public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanNotify();
    [CompilerGeneratedAttribute]
public void set_CanNotify(bool value);
    public sealed virtual bool get_ShouldNotify();
    public sealed virtual IDisposable SuppressNotificationsBlock();
    public sealed virtual void SuppressNotifications();
    public sealed virtual void ResumeNotifications();
    protected bool NotifyPropertyChanging(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(string propertyName);
    protected TrackPropertyChangeScope TrackPropertyChange(PropertyDescriptor property, object oldValue, object newValue);
    protected TrackPropertyChangeScope TrackReadonlyPropertyChanges();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanValidate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    protected internal void Invalidate();
    [CompilerGeneratedAttribute]
private static bool <CopyTo>b__1(PropertyDescriptor property);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__9(Dictionary`2<string, Edit> level);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__a(PropertyDescriptor prop);
    [CompilerGeneratedAttribute]
private object <get_IsChanged>b__b(PropertyDescriptor prop);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__c(IChangeTracking track);
    [CompilerGeneratedAttribute]
private bool <get_IsValid>b__10(IDictionaryValidator v);
    [CompilerGeneratedAttribute]
private string <get_Error>b__12(IDictionaryValidator v);
    [CompilerGeneratedAttribute]
private static bool <get_Error>b__13(string e);
    [CompilerGeneratedAttribute]
private static bool <get_Item>b__17(string e);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.DictionaryAdapterExtensions : object {
    [ExtensionAttribute]
public static IVirtual AsVirtual(IDictionaryAdapter dictionaryAdapter);
}
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterFactory : object {
    private Dictionary`2<Type, DictionaryAdapterMeta> interfaceToMeta;
    private Lock interfaceToMetaLock;
    private static PropertyInfo AdapterGetMeta;
    private static ConstructorInfo BaseCtor;
    private static Type[] ConstructorParameterTypes;
    private static MethodInfo AdapterGetProperty;
    private static MethodInfo AdapterSetProperty;
    private static HashSet`1<Type> InfrastructureTypes;
    [CompilerGeneratedAttribute]
private static Func`2<FetchAttribute, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate14;
    private static DictionaryAdapterFactory();
    public sealed virtual T GetAdapter(IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public T GetAdapter(IDictionary`2<string, R> dictionary);
    public object GetAdapter(Type type, IDictionary`2<string, R> dictionary);
    public sealed virtual T GetAdapter(NameValueCollection nameValues);
    public sealed virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public sealed virtual T GetAdapter(XmlNode xmlNode);
    public sealed virtual object GetAdapter(Type type, XmlNode xmlNode);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
    private DictionaryAdapterMeta InternalGetAdapterMeta(Type type, PropertyDescriptor descriptor, DictionaryAdapterMeta other);
    private object InternalGetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    private static TypeBuilder CreateTypeBuilder(Type type, AppDomain appDomain);
    private static TypeBuilder CreateAdapterType(Type type, ModuleBuilder moduleBuilder);
    private DictionaryAdapterMeta CreateAdapterMeta(Type type, TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static ConstructorInfo CreateAdapterConstructor(TypeBuilder typeBuilder);
    private static void CreateAdapterFactoryMethod(TypeBuilder typeBuilder, ConstructorInfo constructor);
    private static void CreateMetaProperty(TypeBuilder typeBuilder, PropertyInfo prop, FieldInfo field);
    private static void CreateAdapterProperty(TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static void PreparePropertyMethod(PropertyDescriptor descriptor, ILGenerator propILGenerator);
    private static void CreatePropertyGetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static void CreatePropertySetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static Dictionary`2<string, PropertyDescriptor> GetPropertyDescriptors(Type type, PropertyDescriptor initializers, Object[]& typeBehaviors);
    private static IEnumerable`1<object> ExpandBehaviors(IEnumerable`1<object> behaviors);
    private static void CollectProperties(Type currentType, Action`1<PropertyInfo> onProperty);
    private static void AddDefaultGetter(PropertyDescriptor descriptor);
    [CompilerGeneratedAttribute]
private static bool <GetPropertyDescriptors>b__0(FetchAttribute b);
    [CompilerGeneratedAttribute]
private static bool <CollectProperties>b__13(Type t);
}
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterInstance : object {
    private IDictionary extendedProperties;
    private List`1<IDictionaryCopyStrategy> copyStrategies;
    private static IDictionaryInitializer[] NoInitializers;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OldHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryEqualityHashCodeStrategy <EqualityHashCodeStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCreateStrategy <CreateStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCoerceStrategy <CoerceStrategy>k__BackingField;
    internal Nullable`1<int> OldHashCode { get; internal set; }
    public IDictionary Dictionary { get; private set; }
    public PropertyDescriptor Descriptor { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryEqualityHashCodeStrategy EqualityHashCodeStrategy { get; public set; }
    public IDictionaryCreateStrategy CreateStrategy { get; public set; }
    public IDictionaryCoerceStrategy CoerceStrategy { get; public set; }
    public IEnumerable`1<IDictionaryCopyStrategy> CopyStrategies { get; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterInstance(IDictionary dictionary, DictionaryAdapterMeta meta, PropertyDescriptor descriptor, IDictionaryAdapterFactory factory);
    private static DictionaryAdapterInstance();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_OldHashCode();
    [CompilerGeneratedAttribute]
internal void set_OldHashCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(IDictionary value);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
private void set_Descriptor(PropertyDescriptor value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryEqualityHashCodeStrategy get_EqualityHashCodeStrategy();
    [CompilerGeneratedAttribute]
public void set_EqualityHashCodeStrategy(IDictionaryEqualityHashCodeStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCreateStrategy get_CreateStrategy();
    [CompilerGeneratedAttribute]
public void set_CreateStrategy(IDictionaryCreateStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCoerceStrategy get_CoerceStrategy();
    [CompilerGeneratedAttribute]
public void set_CoerceStrategy(IDictionaryCoerceStrategy value);
    public IEnumerable`1<IDictionaryCopyStrategy> get_CopyStrategies();
    public void AddCopyStrategy(IDictionaryCopyStrategy copyStrategy);
    public IDictionary get_ExtendedProperties();
    private static IDictionaryInitializer[] MergeInitializers(IDictionaryInitializer[] source, List`1<IDictionaryBehavior> behaviors);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source, List`1<IDictionaryBehavior> behaviors);
}
[DebuggerDisplayAttribute("Type: {Type.FullName,nq}")]
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterMeta : object {
    private IDictionary extendedProperties;
    private Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Behaviors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryMetaInitializer[] <MetaInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    public Type Type { get; private set; }
    public Type Implementation { get; private set; }
    public Object[] Behaviors { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryMetaInitializer[] MetaInitializers { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterMeta(Type type, Type implementation, Object[] behaviors, IDictionaryMetaInitializer[] metaInitializers, IDictionaryInitializer[] initializers, IDictionary`2<string, PropertyDescriptor> properties, IDictionaryAdapterFactory factory, Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Type get_Implementation();
    [CompilerGeneratedAttribute]
private void set_Implementation(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_Behaviors();
    [CompilerGeneratedAttribute]
private void set_Behaviors(Object[] value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryMetaInitializer[] get_MetaInitializers();
    [CompilerGeneratedAttribute]
private void set_MetaInitializers(IDictionaryMetaInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    public IDictionary get_ExtendedProperties();
    public PropertyDescriptor CreateDescriptor();
    private static List`1<T> CollectSharedBehaviors(T[] source, IDictionaryMetaInitializer[] predicates);
    public DictionaryAdapterMeta GetAdapterMeta(Type type);
    public object CreateInstance(IDictionary dictionary, PropertyDescriptor descriptor);
    private void InitializeMeta();
}
internal abstract class Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute : Attribute {
    public static int FirstExecutionOrder;
    public static int DefaultExecutionOrder;
    public static int LastExecutionOrder;
    [CompilerGeneratedAttribute]
private int <ExecutionOrder>k__BackingField;
    public int ExecutionOrder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExecutionOrder();
    [CompilerGeneratedAttribute]
public void set_ExecutionOrder(int value);
    public virtual IDictionaryBehavior Copy();
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.DictionaryValidateGroup : object {
    private Object[] groups;
    private IDictionaryAdapter adapter;
    private String[] propertyNames;
    private PropertyChangedEventHandler propertyChanged;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, IEnumerable`1<GroupAttribute>> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`3<PropertyDescriptor, GroupAttribute, <>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute>, string> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegated;
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryValidateGroup(Object[] groups, IDictionaryAdapter adapter);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual bool get_CanValidate();
    public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<GroupAttribute> <.ctor>b__1(PropertyDescriptor property);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <.ctor>b__2(PropertyDescriptor property, GroupAttribute groupings);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3(<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static string <.ctor>b__4(<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5(object sender, PropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
private string <get_Error>b__b(string propertyName);
    [CompilerGeneratedAttribute]
private static bool <get_Error>b__c(string errors);
}
internal abstract class Castle.Components.DictionaryAdapter.DynamicValue`1 : object {
    public T Value { get; }
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDynamicValue.GetValue();
    public abstract virtual T get_Value();
    public virtual string ToString();
}
internal class Castle.Components.DictionaryAdapter.DynamicValueDelegate`1 : DynamicValue`1<T> {
    private Func`1<T> dynamicDelegate;
    public T Value { get; }
    public DynamicValueDelegate`1(Func`1<T> dynamicDelegate);
    public virtual T get_Value();
}
internal class Castle.Components.DictionaryAdapter.EditableBindingList`1 : BindingList`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableBindingList`1(IList`1<T> initial);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
internal class Castle.Components.DictionaryAdapter.EditableList : EditableList`1<object> {
    public EditableList(IEnumerable`1<object> collection);
}
internal class Castle.Components.DictionaryAdapter.EditableList`1 : List`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableList`1(IEnumerable`1<T> collection);
    public sealed virtual void BeginEdit();
    public sealed virtual bool get_IsChanged();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.FetchAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    public bool Fetch { get; private set; }
    public FetchAttribute(bool fetch);
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
private void set_Fetch(bool value);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter : object {
    [ExtensionAttribute]
public static GenericDictionaryAdapter`1<TValue> ForDictionaryAdapter(IDictionary`2<string, TValue> dictionary);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter`1 : AbstractDictionaryAdapter {
    private IDictionary`2<string, TValue> dictionary;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public GenericDictionaryAdapter`1(IDictionary`2<string, TValue> dictionary);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private static string GetKey(object key);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.GroupAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Object[] <Group>k__BackingField;
    public Object[] Group { get; private set; }
    public GroupAttribute(object group);
    public GroupAttribute(Object[] group);
    [CompilerGeneratedAttribute]
public Object[] get_Group();
    [CompilerGeneratedAttribute]
private void set_Group(Object[] value);
}
internal interface Castle.Components.DictionaryAdapter.IBindingList`1 {
    public bool AllowNew { get; }
    public bool AllowEdit { get; }
    public bool AllowRemove { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public bool IsSorted { get; }
    public PropertyDescriptor SortProperty { get; }
    public ListSortDirection SortDirection { get; }
    public abstract virtual bool get_AllowNew();
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    public abstract virtual bool get_IsSorted();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual ListSortDirection get_SortDirection();
    public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual T AddNew();
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual void RemoveSort();
}
internal interface Castle.Components.DictionaryAdapter.IBindingListSource {
    public IBindingList AsBindingList { get; }
    public abstract virtual IBindingList get_AsBindingList();
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Components.DictionaryAdapter.ICollectionAdapter`1 {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public abstract virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public abstract virtual IEqualityComparer`1<T> get_Comparer();
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual T AddNew();
    public abstract virtual bool Add(T value);
    public abstract virtual bool Insert(int index, T value);
    public abstract virtual void Remove(int index);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
    public abstract virtual bool get_HasSnapshot();
    public abstract virtual int get_SnapshotCount();
    public abstract virtual T GetCurrentItem(int index);
    public abstract virtual T GetSnapshotItem(int index);
    public abstract virtual void SaveSnapshot();
    public abstract virtual void LoadSnapshot();
    public abstract virtual void DropSnapshot();
}
internal interface Castle.Components.DictionaryAdapter.ICollectionAdapterObserver`1 {
    public abstract virtual bool OnInserting(T newValue);
    public abstract virtual bool OnReplacing(T oldValue, T newValue);
    public abstract virtual void OnRemoving(T oldValue);
    public abstract virtual void OnInserted(T newValue, int index);
    public abstract virtual void OnReplaced(T oldValue, T newValue, int index);
    public abstract virtual void OnRemoved(T oldValue, int index);
}
internal interface Castle.Components.DictionaryAdapter.ICollectionProjection {
    public abstract virtual void Replace(IEnumerable source);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
}
internal interface Castle.Components.DictionaryAdapter.ICondition {
    public abstract virtual bool SatisfiedBy(object value);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapter {
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; }
    public abstract virtual DictionaryAdapterMeta get_Meta();
    public abstract virtual DictionaryAdapterInstance get_This();
    public abstract virtual string GetKey(string propertyName);
    public abstract virtual object GetProperty(string propertyName, bool ifExists);
    public abstract virtual object ReadProperty(string key);
    public abstract virtual T GetPropertyOfType(string propertyName);
    public abstract virtual bool SetProperty(string propertyName, Object& value);
    public abstract virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public abstract virtual void ClearProperty(PropertyDescriptor property, string key);
    public abstract virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public abstract virtual void CopyTo(IDictionaryAdapter other);
    public abstract virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public abstract virtual T Coerce();
    public abstract virtual object Coerce(Type type);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory {
    public abstract virtual T GetAdapter(IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public abstract virtual T GetAdapter(NameValueCollection nameValues);
    public abstract virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public abstract virtual T GetAdapter(XmlNode xmlNode);
    public abstract virtual object GetAdapter(Type type, XmlNode xmlNode);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor {
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    public abstract virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryBehavior {
    public int ExecutionOrder { get; }
    public abstract virtual int get_ExecutionOrder();
    public abstract virtual IDictionaryBehavior Copy();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder {
    public abstract virtual Object[] BuildBehaviors();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCoerceStrategy {
    public abstract virtual object Coerce(IDictionaryAdapter adapter, Type type);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy {
    public abstract virtual bool Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCreate {
    public abstract virtual T Create();
    public abstract virtual object Create(Type type);
    public abstract virtual T Create(IDictionary dictionary);
    public abstract virtual object Create(Type type, IDictionary dictionary);
    public abstract virtual T Create(Action`1<T> init);
    public abstract virtual T Create(IDictionary dictionary, Action`1<T> init);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy {
    public abstract virtual object Create(IDictionaryAdapter adapter, Type type, IDictionary dictionary);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryEdit {
    public bool CanEdit { get; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public abstract virtual bool get_CanEdit();
    public abstract virtual bool get_IsEditing();
    public abstract virtual bool get_SupportsMultiLevelEdit();
    public abstract virtual void set_SupportsMultiLevelEdit(bool value);
    public abstract virtual IDisposable SuppressEditingBlock();
    public abstract virtual void SuppressEditing();
    public abstract virtual void ResumeEditing();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryEqualityHashCodeStrategy {
    public abstract virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public abstract virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder {
    public abstract virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer {
    public abstract virtual void Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta dictionaryMeta);
    public abstract virtual bool ShouldHaveBehavior(object behavior);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryNotify {
    public bool CanNotify { get; }
    public bool ShouldNotify { get; }
    public abstract virtual bool get_CanNotify();
    public abstract virtual bool get_ShouldNotify();
    public abstract virtual IDisposable SuppressNotificationsBlock();
    public abstract virtual void SuppressNotifications();
    public abstract virtual void ResumeNotifications();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter {
    public abstract virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryPropertySetter {
    public abstract virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryReferenceManager {
    public abstract virtual bool IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    public abstract virtual bool TryGetReference(object keyObject, Object& inGraphObject);
    public abstract virtual void AddReference(object keyObject, object relatedObject, bool isInGraph);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryValidate {
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public abstract virtual bool get_CanValidate();
    public abstract virtual void set_CanValidate(bool value);
    public abstract virtual bool get_IsValid();
    public abstract virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public abstract virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public abstract virtual void AddValidator(IDictionaryValidator validator);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryValidator {
    public abstract virtual bool IsValid(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    public abstract virtual void Invalidate(IDictionaryAdapter dictionaryAdapter);
}
internal interface Castle.Components.DictionaryAdapter.IDynamicValue {
    public abstract virtual object GetValue();
}
internal interface Castle.Components.DictionaryAdapter.IDynamicValue`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.IfExistsAttribute : Attribute {
}
internal interface Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer {
    public abstract virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
internal interface Castle.Components.DictionaryAdapter.IValueInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
}
internal interface Castle.Components.DictionaryAdapter.IVirtual {
    public bool IsReal { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual void Realize();
    public abstract virtual void add_Realized(EventHandler value);
    public abstract virtual void remove_Realized(EventHandler value);
}
internal interface Castle.Components.DictionaryAdapter.IVirtual`1 {
    public abstract virtual T Realize();
    public abstract virtual void AddSite(IVirtualSite`1<T> site);
    public abstract virtual void RemoveSite(IVirtualSite`1<T> site);
}
internal interface Castle.Components.DictionaryAdapter.IVirtualSite`1 {
    public abstract virtual void OnRealizing(T node);
}
internal interface Castle.Components.DictionaryAdapter.IVirtualTarget`2 {
    public abstract virtual void OnRealizing(TNode node, TMember member);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.KeyAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; private set; }
    public KeyAttribute(string key);
    public KeyAttribute(String[] keys);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.KeyPrefixAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <KeyPrefix>k__BackingField;
    public string KeyPrefix { get; public set; }
    public KeyPrefixAttribute(string keyPrefix);
    [CompilerGeneratedAttribute]
public string get_KeyPrefix();
    [CompilerGeneratedAttribute]
public void set_KeyPrefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.KeySubstitutionAttribute : DictionaryBehaviorAttribute {
    private string oldValue;
    private string newValue;
    public KeySubstitutionAttribute(string oldValue, string newValue);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[DebuggerTypeProxyAttribute("Castle.Components.DictionaryAdapter.ListProjectionDebugView`1")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}, Adapter = {Adapter}")]
internal class Castle.Components.DictionaryAdapter.ListProjection`1 : object {
    private static int NoIndex;
    private ICollectionAdapter`1<T> adapter;
    private int addNewIndex;
    private int addedIndex;
    private int suspendLevel;
    private int changedIndex;
    private PropertyChangedEventHandler propertyHandler;
    private static PropertyDescriptorCollection itemProperties;
    private ListChangedEventHandler ListChanged;
    public int Count { get; }
    public IBindingList AsBindingList { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowEdit { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowNew { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowRemove { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public bool IsChanged { get; }
    public bool EventsEnabled { get; }
    public ListProjection`1(ICollectionAdapter`1<T> adapter);
    public sealed virtual int get_Count();
    public sealed virtual IBindingList get_AsBindingList();
    public ICollectionAdapter`1<T> get_Adapter();
    public IEqualityComparer`1<T> get_Comparer();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowEdit();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowNew();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowRemove();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public void Replace(IEnumerable`1<T> items);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.Replace(IEnumerable items);
    protected virtual bool OnReplacing(T oldValue, T newValue);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplacing(T oldValue, T newValue);
    protected virtual void OnReplaced(T oldValue, T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplaced(T oldValue, T newValue, int index);
    public virtual T AddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    public bool IsNew(int index);
    public virtual void EndNew(int index);
    public virtual void CancelNew(int index);
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    protected virtual bool OnInserting(T value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserting(T value);
    protected virtual void OnInserted(T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserted(T newValue, int index);
    public virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.ClearReferences();
    protected virtual void OnRemoving(T oldValue);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoving(T oldValue);
    protected virtual void OnRemoved(T oldValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoved(T oldValue, int index);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
    private void AttachPropertyChanged(T value);
    private void DetachPropertyChanged(T value);
    private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool CanHandle(object sender, PropertyChangedEventArgs e);
    private bool TryGetChangedItem(object sender, T& item);
    private bool TryGetChangedIndex(T item);
    private static PropertyDescriptor GetChangedProperty(PropertyChangedEventArgs e);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    protected virtual void OnListChanged(ListChangedEventArgs args);
    protected void NotifyListChanged(ListChangedType type, int index);
    protected void NotifyListReset();
    public bool get_EventsEnabled();
    public void SuspendEvents();
    public bool ResumeEvents();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
}
internal class Castle.Components.DictionaryAdapter.ListProjectionDebugView`1 : object {
    private ListProjection`1<T> projection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public ListProjectionDebugView`1(ListProjection`1<T> projection);
    public T[] get_Items();
    public ICollectionAdapter`1<T> get_Adapter();
}
internal class Castle.Components.DictionaryAdapter.MemberwiseEqualityHashCodeStrategy : DictionaryBehaviorAttribute {
    public sealed virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public sealed virtual int GetHashCode(IDictionaryAdapter adapter);
    public sealed virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.MultiLevelEditAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.NameValueCollectionAdapter : AbstractDictionaryAdapter {
    private NameValueCollection nameValues;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public NameValueCollectionAdapter(NameValueCollection nameValues);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static NameValueCollectionAdapter Adapt(NameValueCollection nameValues);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.NewGuidAttribute : DictionaryBehaviorAttribute {
    private static Guid UnassignedGuid;
    private static NewGuidAttribute();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.OnDemandAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, Castle.Core.<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Castle.Core.<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]>, ConstructorInfo> CS$<>9__CachedAnonymousMethodDelegate6;
    public Type Type { get; private set; }
    public object Value { get; private set; }
    public OnDemandAttribute(Type type);
    public OnDemandAttribute(object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private static bool IsAcceptedType(Type type);
    private static Type GetInferredType(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, IValueInitializer& initializer);
    [CompilerGeneratedAttribute]
private static Castle.Core.<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]> <GetPropertyValue>b__1(ConstructorInfo ctor);
    [CompilerGeneratedAttribute]
private static ConstructorInfo <GetPropertyValue>b__3(Castle.Core.<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]> <>h__TransparentIdentifier0);
}
internal class Castle.Components.DictionaryAdapter.PropertyChangedEventArgsEx : PropertyChangedEventArgs {
    private object oldValue;
    private object newValue;
    public object OldValue { get; }
    public object NewValue { get; }
    public PropertyChangedEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
}
internal class Castle.Components.DictionaryAdapter.PropertyChangingEventArgsEx : PropertyChangingEventArgs {
    private object oldValue;
    private object newValue;
    private bool cancel;
    public object OldValue { get; }
    public object NewValue { get; }
    public bool Cancel { get; public set; }
    public PropertyChangingEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[DebuggerDisplayAttribute("{Property.DeclaringType.FullName,nq}.{PropertyName,nq}")]
internal class Castle.Components.DictionaryAdapter.PropertyDescriptor : object {
    private IDictionary state;
    private Dictionary`2<object, object> extendedProperties;
    protected List`1<IDictionaryBehavior> dictionaryBehaviors;
    private static Object[] NoAnnotations;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamicProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IfExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressNotifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Annotations>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConverter <TypeConverter>k__BackingField;
    public int ExecutionOrder { get; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    public PropertyInfo Property { get; private set; }
    public bool IsDynamicProperty { get; private set; }
    public IDictionary State { get; }
    public bool Fetch { get; public set; }
    public bool IfExists { get; public set; }
    public bool SuppressNotifications { get; public set; }
    public Object[] Annotations { get; private set; }
    public TypeConverter TypeConverter { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public IEnumerable`1<IDictionaryBehavior> Behaviors { get; }
    internal List`1<IDictionaryBehavior> BehaviorsInternal { get; }
    public IEnumerable`1<IDictionaryKeyBuilder> KeyBuilders { get; }
    public IEnumerable`1<IDictionaryPropertySetter> Setters { get; }
    public IEnumerable`1<IDictionaryPropertyGetter> Getters { get; }
    public IEnumerable`1<IDictionaryInitializer> Initializers { get; }
    public IEnumerable`1<IDictionaryMetaInitializer> MetaInitializers { get; }
    public PropertyDescriptor(PropertyInfo property, Object[] annotations);
    public PropertyDescriptor(Object[] annotations);
    public PropertyDescriptor(PropertyDescriptor source, bool copyBehaviors);
    private static PropertyDescriptor();
    public sealed virtual int get_ExecutionOrder();
    public string get_PropertyName();
    public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsDynamicProperty();
    [CompilerGeneratedAttribute]
private void set_IsDynamicProperty(bool value);
    public IDictionary get_State();
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
public void set_Fetch(bool value);
    [CompilerGeneratedAttribute]
public bool get_IfExists();
    [CompilerGeneratedAttribute]
public void set_IfExists(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressNotifications();
    [CompilerGeneratedAttribute]
public void set_SuppressNotifications(bool value);
    [CompilerGeneratedAttribute]
public Object[] get_Annotations();
    [CompilerGeneratedAttribute]
private void set_Annotations(Object[] value);
    [CompilerGeneratedAttribute]
public TypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
private void set_TypeConverter(TypeConverter value);
    public IDictionary get_ExtendedProperties();
    public IEnumerable`1<IDictionaryBehavior> get_Behaviors();
    internal List`1<IDictionaryBehavior> get_BehaviorsInternal();
    public IEnumerable`1<IDictionaryKeyBuilder> get_KeyBuilders();
    public IEnumerable`1<IDictionaryPropertySetter> get_Setters();
    public IEnumerable`1<IDictionaryPropertyGetter> get_Getters();
    public IEnumerable`1<IDictionaryInitializer> get_Initializers();
    public IEnumerable`1<IDictionaryMetaInitializer> get_MetaInitializers();
    public sealed virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor descriptor);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor descriptor, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor descriptor);
    public PropertyDescriptor AddBehavior(IDictionaryBehavior behavior);
    public static void MergeBehavior(List`1& dictionaryBehaviors, T behavior);
    public PropertyDescriptor AddBehaviors(IDictionaryBehavior[] behaviors);
    public PropertyDescriptor AddBehaviors(IEnumerable`1<IDictionaryBehavior> behaviors);
    public PropertyDescriptor CopyBehaviors(PropertyDescriptor other);
    public sealed virtual IDictionaryBehavior Copy();
    private void ObtainTypeConverter();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.ReferenceAttribute : Attribute {
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.RemoveIfAttribute : DictionaryBehaviorAttribute {
    private ICondition condition;
    unknown Type Condition {public set; }
    public RemoveIfAttribute(Object[] values);
    public RemoveIfAttribute(Object[] values, Type comparerType);
    protected RemoveIfAttribute(ICondition condition);
    public void set_Condition(Type value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal bool ShouldRemove(object value);
    private static TBase Construct(Type type, string paramName);
}
internal class Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute : RemoveIfAttribute {
    [CompilerGeneratedAttribute]
private Type <Condition>k__BackingField;
    private Type Condition { get; private set; }
    [CompilerGeneratedAttribute]
private Type get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(Type value);
}
internal class Castle.Components.DictionaryAdapter.SetProjection`1 : ListProjection`1<T> {
    private HashSet`1<T> set;
    public SetProjection`1(ICollectionAdapter`1<T> adapter);
    public virtual bool Contains(T item);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private void Repopulate();
    public virtual void EndNew(int index);
    public virtual bool Add(T item);
    protected virtual bool OnInserting(T value);
    protected virtual bool OnReplacing(T oldValue, T newValue);
    public virtual bool Remove(T item);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.StringFormatAttribute : DictionaryBehaviorAttribute {
    private static Char[] PropertyDelimeters;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Properties>k__BackingField;
    public string Format { get; private set; }
    public string Properties { get; private set; }
    public StringFormatAttribute(string format, string properties);
    private static StringFormatAttribute();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(string value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private Object[] GetFormatArguments(IDictionaryAdapter dictionaryAdapter, string formattedPropertyName);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.StringListAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public char Separator { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal static string BuildString(IEnumerable enumerable, char separator);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.StringStorageAttribute : DictionaryBehaviorAttribute {
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.StringValuesAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private string GetPropertyAsString(PropertyDescriptor property, object value);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute : DictionaryBehaviorAttribute {
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
internal abstract class Castle.Components.DictionaryAdapter.VirtualObject`1 : object {
    private List`1<IVirtualSite`1<TNode>> sites;
    private EventHandler Realized;
    public bool IsReal { get; }
    protected VirtualObject`1(IVirtualSite`1<TNode> site);
    public abstract virtual bool get_IsReal();
    protected void AddSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.AddSite(IVirtualSite`1<TNode> site);
    protected void RemoveSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.RemoveSite(IVirtualSite`1<TNode> site);
    public sealed virtual TNode Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    protected abstract virtual bool TryRealize(TNode& node);
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
}
internal class Castle.Components.DictionaryAdapter.VirtualSite`2 : object {
    private IVirtualTarget`2<TNode, TMember> target;
    private TMember member;
    private static IEqualityComparer`1<IVirtualTarget`2<TNode, TMember>> TargetComparer;
    private static IEqualityComparer`1<TMember> MemberComparer;
    public IVirtualTarget`2<TNode, TMember> Target { get; }
    public TMember Member { get; }
    public VirtualSite`2(IVirtualTarget`2<TNode, TMember> target, TMember member);
    private static VirtualSite`2();
    public IVirtualTarget`2<TNode, TMember> get_Target();
    public TMember get_Member();
    public sealed virtual void OnRealizing(TNode node);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VirtualSite`2<TNode, TMember> other);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.VolatileAttribute : Attribute {
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPath : object {
    private XPathExpression path;
    private CompiledXPathStep firstStep;
    private int depth;
    private static IList`1<CompiledXPathStep> NoSteps;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep FirstStep { get; internal set; }
    public CompiledXPathStep LastStep { get; }
    public int Depth { get; internal set; }
    public bool IsCreatable { get; }
    private static CompiledXPath();
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_FirstStep();
    internal void set_FirstStep(CompiledXPathStep value);
    public CompiledXPathStep get_LastStep();
    public int get_Depth();
    internal void set_Depth(int value);
    public bool get_IsCreatable();
    internal void MakeNotCreatable();
    internal void Prepare();
    public void SetContext(XsltContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPathNode : object {
    private string prefix;
    private string localName;
    private bool isAttribute;
    private XPathExpression value;
    private CompiledXPathNode next;
    private CompiledXPathNode previous;
    private IList`1<CompiledXPathNode> dependencies;
    private static IList`1<CompiledXPathNode> NoDependencies;
    public string Prefix { get; internal set; }
    public string LocalName { get; internal set; }
    public bool IsAttribute { get; internal set; }
    public bool IsSelfReference { get; }
    public bool IsSimple { get; }
    public XPathExpression Value { get; internal set; }
    public CompiledXPathNode NextNode { get; internal set; }
    public CompiledXPathNode PreviousNode { get; internal set; }
    public IList`1<CompiledXPathNode> Dependencies { get; }
    private static CompiledXPathNode();
    public string get_Prefix();
    internal void set_Prefix(string value);
    public string get_LocalName();
    internal void set_LocalName(string value);
    public bool get_IsAttribute();
    internal void set_IsAttribute(bool value);
    public bool get_IsSelfReference();
    public bool get_IsSimple();
    public XPathExpression get_Value();
    internal void set_Value(XPathExpression value);
    public CompiledXPathNode get_NextNode();
    internal void set_NextNode(CompiledXPathNode value);
    public CompiledXPathNode get_PreviousNode();
    internal void set_PreviousNode(CompiledXPathNode value);
    public IList`1<CompiledXPathNode> get_Dependencies();
    private bool HasNoRealDependencies();
    private XPathExpression GetSelfReferenceValue();
    internal virtual void Prepare();
    internal virtual void SetContext(XsltContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPathStep : CompiledXPathNode {
    private XPathExpression path;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep NextStep { get; }
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_NextStep();
    internal virtual void SetContext(XsltContext context);
}
[FlagsAttribute]
internal enum Castle.Components.DictionaryAdapter.Xml.CursorFlags : Enum {
    public int value__;
    public static CursorFlags None;
    public static CursorFlags Elements;
    public static CursorFlags Attributes;
    public static CursorFlags Multiple;
    public static CursorFlags Mutable;
    public static CursorFlags AllNodes;
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.CursorFlagsExtensions : object {
    [ExtensionAttribute]
public static CursorFlags MutableIf(CursorFlags flags, bool mutable);
    [ExtensionAttribute]
public static bool IncludesElements(CursorFlags flags);
    [ExtensionAttribute]
public static bool IncludesAttributes(CursorFlags flags);
    [ExtensionAttribute]
public static bool AllowsMultipleItems(CursorFlags flags);
    [ExtensionAttribute]
public static bool SupportsMutation(CursorFlags flags);
}
internal class Castle.Components.DictionaryAdapter.Xml.DefaultXmlReferenceFormat : object {
    private static NumberStyles IntegerStyle;
    public static DefaultXmlReferenceFormat Instance;
    private static IFormatProvider Culture;
    private static DefaultXmlReferenceFormat();
    public sealed virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public sealed virtual bool TryGetReference(IXmlNode node, Int32& id);
    public sealed virtual void SetIdentity(IXmlNode node, int id);
    public sealed virtual void SetReference(IXmlNode node, int id);
    public sealed virtual void ClearIdentity(IXmlNode node);
    public sealed virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.DictionaryAdapterExtensions : object {
    private static string XmlAccessorKey;
    private static string XmlMetaKey;
    private static string XmlTypeKey;
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter);
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter, IDictionary dictionary);
    [ExtensionAttribute]
public static bool HasAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static XmlAccessor GetAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static void SetAccessor(PropertyDescriptor property, XmlAccessor accessor);
    [ExtensionAttribute]
public static bool HasXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static XmlMetadata GetXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlMeta(DictionaryAdapterMeta meta, XmlMetadata xmlMeta);
    [ExtensionAttribute]
public static bool HasXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static string GetXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlType(DictionaryAdapterMeta meta, string value);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Error : object {
    internal static Exception ArgumentNull(string paramName);
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception InvalidOperation();
    internal static Exception NotSupported();
    internal static Exception ObjectDisposed(string objectName);
    internal static Exception AttributeConflict(string propertyName);
    internal static Exception SeparateGetterSetterOnComplexType(string propertyName);
    internal static Exception XmlMetadataNotAvailable(Type clrType);
    internal static Exception NotDictionaryAdapter(string paramName);
    internal static Exception NoInstanceDescriptor(string paramName);
    internal static Exception NoXmlAdapter(string paramName);
    internal static Exception NotRealizable();
    internal static Exception CursorNotMutable();
    internal static Exception CursorNotInCreatableState();
    internal static Exception CursorNotInRemovableState();
    internal static Exception CursorNotInCoercibleState();
    internal static Exception CursorNotInRealizableState();
    internal static Exception CursorCannotMoveToGivenNode();
    internal static Exception CannotSetAttribute(IXmlIdentity identity);
    internal static Exception NotXmlKnownType(Type clrType);
    internal static Exception UnsupportedCollectionType(Type clrType);
    internal static Exception NotCollectionType(string paramName);
    internal static Exception InvalidLocalName();
    internal static Exception InvalidNamespaceUri();
    internal static Exception NoDefaultKnownType();
    internal static Exception XPathNotCreatable(CompiledXPath path);
    internal static Exception XPathNavigationFailed(XPathExpression path);
    internal static Exception ObjectIdNotFound(string id);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IConfigurable`1 {
    public abstract virtual void Configure(T value);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IRealizable`1 {
    public bool IsReal { get; }
    public T Value { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual T get_Value();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IRealizableSource {
    public abstract virtual IRealizable`1<T> AsRealizable();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlAccessor {
    public Type ClrType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; }
    public bool IsNillable { get; }
    public bool IsReference { get; }
    public abstract virtual Type get_ClrType();
    public abstract virtual XmlTypeSerializer get_Serializer();
    public abstract virtual IXmlContext get_Context();
    public abstract virtual bool get_IsNillable();
    public abstract virtual bool get_IsReference();
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    public abstract virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public abstract virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlBehaviorSemantics`1 {
    public abstract virtual string GetLocalName(T behavior);
    public abstract virtual string GetNamespaceUri(T behavior);
    public abstract virtual Type GetClrType(T behavior);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlCollectionAccessor {
    public abstract virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
    public abstract virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlContext {
    public string ChildNamespaceUri { get; }
    public abstract virtual string get_ChildNamespaceUri();
    public abstract virtual IXmlContext Clone();
    public abstract virtual XmlName GetDefaultXsiType(Type clrType);
    public abstract virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    public abstract virtual bool IsReservedNamespaceUri(string namespaceUri);
    public abstract virtual void AddVariable(XPathVariableAttribute attribute);
    public abstract virtual void AddFunction(XPathFunctionAttribute attribute);
    public abstract virtual void Enlist(CompiledXPath path);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlCursor {
    public abstract virtual void Reset();
    public abstract virtual void MoveTo(IXmlNode node);
    public abstract virtual void MoveToEnd();
    public abstract virtual void Create(Type type);
    public abstract virtual void Coerce(Type type);
    public abstract virtual void Remove();
    public abstract virtual void RemoveAllNext();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIdentity {
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XmlName get_XsiType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType {
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public abstract virtual XmlName get_XsiType();
    public abstract virtual Type get_ClrType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap {
    public IXmlIncludedType Default { get; }
    public abstract virtual IXmlIncludedType get_Default();
    public abstract virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public abstract virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIterator {
    public abstract virtual bool MoveNext();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownType {
    public Type ClrType { get; }
    public abstract virtual Type get_ClrType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap {
    public IXmlKnownType Default { get; }
    public abstract virtual IXmlKnownType get_Default();
    public abstract virtual bool TryGet(IXmlIdentity xmlNode, IXmlKnownType& knownType);
    public abstract virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNamespaceSource {
    public abstract virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public abstract virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNode {
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public CompiledXPath Path { get; }
    public abstract virtual bool get_IsElement();
    public abstract virtual bool get_IsAttribute();
    public abstract virtual bool get_IsNil();
    public abstract virtual void set_IsNil(bool value);
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual string get_Xml();
    public abstract virtual IXmlNode get_Parent();
    public abstract virtual IXmlNamespaceSource get_Namespaces();
    public abstract virtual string GetAttribute(XmlName name);
    public abstract virtual void SetAttribute(XmlName name, string value);
    public abstract virtual string LookupPrefix(string namespaceUri);
    public abstract virtual string LookupNamespaceUri(string prefix);
    public abstract virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public abstract virtual object get_UnderlyingObject();
    public abstract virtual bool UnderlyingPositionEquals(IXmlNode node);
    public abstract virtual IXmlNode Save();
    public abstract virtual IXmlCursor SelectSelf(Type clrType);
    public abstract virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual IXmlIterator SelectSubtree();
    public abstract virtual CompiledXPath get_Path();
    public abstract virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual object Evaluate(CompiledXPath path);
    public abstract virtual void Clear();
    public abstract virtual XmlReader ReadSubtree();
    public abstract virtual XmlWriter WriteAttributes();
    public abstract virtual XmlWriter WriteChildren();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNodeSource {
    public IXmlNode Node { get; }
    public abstract virtual IXmlNode get_Node();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlPropertyAccessor {
    public abstract virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public abstract virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& newValue);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlReferenceFormat {
    public abstract virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public abstract virtual bool TryGetReference(IXmlNode node, Int32& id);
    public abstract virtual void SetIdentity(IXmlNode node, int id);
    public abstract virtual void SetReference(IXmlNode node, int id);
    public abstract virtual void ClearIdentity(IXmlNode node);
    public abstract virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.RealizableExtensions : object {
    [ExtensionAttribute]
public static IRealizable`1<T> RequireRealizable(IRealizableSource obj);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.Xml.SingletonDispenser`2 : object {
    private Lock locker;
    private Dictionary`2<TKey, object> items;
    private Func`2<TKey, TItem> factory;
    public TItem Item { get; protected set; }
    public SingletonDispenser`2(Func`2<TKey, TItem> factory);
    public TItem get_Item(TKey key);
    protected void set_Item(TKey key, TItem value);
    private TItem GetOrCreate(TKey key);
    private bool TryGetExistingItem(TKey key, Object& item);
    private TItem WaitForCreate(TKey key, object item);
    private TItem Create(TKey key, object item);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.StringExtensions : object {
    [ExtensionAttribute]
public static string NonEmpty(string s);
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlCursor : SysXmlNode {
    private State state;
    private int index;
    private IXmlKnownTypeMap knownTypes;
    private CursorFlags flags;
    private EventHandler Realized;
    protected static StringComparer DefaultComparer;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public SysXmlCursor(IXmlNode parent, IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    private static SysXmlCursor();
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool MoveNextCore();
    private bool IsMatch();
    private bool Advance();
    protected virtual bool AdvanceToFirstElement();
    private bool AdvanceToNextElement();
    protected virtual bool AdvanceToFirstAttribute();
    private bool AdvanceToNextAttribute();
    private bool AdvanceElement(XmlNode next);
    private bool AdvanceAttribute(XmlNode parent);
    private bool Succeed(State state);
    private bool Fail(State state);
    private bool IsAtEnd();
    public sealed virtual void MoveTo(IXmlNode position);
    private void SetMovedToElement();
    private void SetMovedToAttribute();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    private void MoveToParentOfElement();
    private void MoveToParentOfAttribute();
    private void MoveToRealizedParent();
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    private void CoerceElement(IXmlKnownType knownType);
    private void CoerceAttribute(IXmlKnownType knownType);
    public sealed virtual void Create(Type type);
    private void CreateElement(IXmlKnownType knownType, XmlNode position);
    private void CreateAttribute(IXmlKnownType knownType, XmlNode position);
    private XmlElement CreateElementCore(XmlNode parent, XmlName name);
    private XmlAttribute CreateAttributeCore(XmlNode parent, XmlName name);
    private void RequireNoXsiType(IXmlKnownType knownType);
    private XmlName GetEffectiveName(IXmlKnownType knownType, XmlNode parent);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    private void RemoveElement(XmlNode node);
    private void RemoveAttribute(XmlNode node);
    public virtual IXmlNode Save();
    private XmlNode RequireCreatable();
    private void RequireCoercible();
    private void RequireRemovable();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.SysXmlExtensions : object {
    [ExtensionAttribute]
public static void DefineNamespace(XmlElement node, string prefix, string namespaceUri);
    [ExtensionAttribute]
public static bool IsNamespace(XmlAttribute attribute);
    [ExtensionAttribute]
public static XmlElement FindRoot(XmlElement node);
    [ExtensionAttribute]
public static bool IsXsiType(XmlAttribute attribute);
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlNode : XmlNodeBase {
    protected XmlNode node;
    public object UnderlyingObject { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected SysXmlNode(IXmlNamespaceSource namespaces, IXmlNode parent);
    public SysXmlNode(XmlNode node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    private XmlElement GetNamespaceTargetElement();
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public XmlNode GetNode();
    public sealed virtual void Clear();
    private void ClearAttributes();
    private void ClearChildren();
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlSubtreeIterator : SysXmlNode {
    private State state;
    public SysXmlSubtreeIterator(IXmlNode parent, IXmlNamespaceSource namespaces);
    public sealed virtual bool MoveNext();
    private bool MoveToInitial();
    private bool MoveToSubsequent();
    private bool MoveToElement(XmlNode node);
    private bool SetNext(XmlNode node);
    public virtual IXmlNode Save();
}
internal static class Castle.Components.DictionaryAdapter.Xml.Try : object {
    [DebuggerHiddenAttribute]
public static bool Failure(T& result);
    [DebuggerHiddenAttribute]
public static bool Success(T& result, T value);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.TypeExtensions : object {
    [ExtensionAttribute]
public static Type NonNullable(Type type);
    [ExtensionAttribute]
public static Type GetCollectionItemType(Type type);
    [ExtensionAttribute]
public static Type GetComponentType(object obj);
    [ExtensionAttribute]
internal static bool IsCustomSerializable(Type type);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Wsdl : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Wsdl();
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlAccessor : object {
    private Type clrType;
    private XmlName xsiType;
    private XmlTypeSerializer serializer;
    private IXmlContext context;
    protected States state;
    public Type ClrType { get; }
    public XmlName XsiType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; protected set; }
    public bool IsCollection { get; }
    public bool IsIgnored { get; }
    public bool IsNillable { get; }
    public bool IsVolatile { get; }
    public bool IsReference { get; }
    protected XmlAccessor(Type clrType, IXmlContext context);
    public sealed virtual Type get_ClrType();
    public XmlName get_XsiType();
    public sealed virtual XmlTypeSerializer get_Serializer();
    public sealed virtual IXmlContext get_Context();
    protected void set_Context(IXmlContext value);
    public bool get_IsCollection();
    public virtual bool get_IsIgnored();
    public sealed virtual bool get_IsNillable();
    public bool get_IsVolatile();
    public sealed virtual bool get_IsReference();
    public virtual void ConfigureNillable(bool nillable);
    public void ConfigureVolatile(bool isVolatile);
    public virtual void ConfigureReference(bool isReference);
    public virtual void Prepare();
    protected IXmlContext CloneContext();
    private void SetContext(IXmlContext value);
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public sealed virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parentObject, bool nodeExists, bool orStub);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    private void Coerce(IXmlCursor cursor, Type clrType, bool replace);
    public sealed virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
    protected void RemoveCollectionItems(IXmlNode parentNode, XmlReferenceManager references, object value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    protected IXmlCollectionAccessor GetDefaultCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAccessorFactory`1 : MulticastDelegate {
    public XmlAccessorFactory`1(object object, IntPtr method);
    public virtual TAccessor Invoke(string name, Type type, IXmlContext context);
    public virtual IAsyncResult BeginInvoke(string name, Type type, IXmlContext context, AsyncCallback callback, object object);
    public virtual TAccessor EndInvoke(IAsyncResult result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAdapter : DictionaryBehaviorAttribute {
    private IXmlNode node;
    private object source;
    private XmlReferenceManager references;
    private XmlMetadata primaryXmlMeta;
    private Dictionary`2<Type, XmlMetadata> secondaryXmlMetas;
    private bool isRoot;
    private EventHandler Realized;
    public bool IsReal { get; }
    public IXmlNode Node { get; }
    internal XmlReferenceManager References { get; }
    public XmlAdapter(XmlNode node);
    public XmlAdapter(IXmlNode node, XmlReferenceManager references);
    public sealed virtual bool get_IsReal();
    public sealed virtual IXmlNode get_Node();
    internal XmlReferenceManager get_References();
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy.Create(IDictionaryAdapter parent, Type type, IDictionary dictionary);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
    private void InitializePrimary(DictionaryAdapterMeta meta, IDictionaryAdapter dictionaryAdapter);
    private void InitializeSecondary(DictionaryAdapterMeta meta);
    private void InitializeBaseTypes(DictionaryAdapterMeta meta);
    private void InitializeStrategies(IDictionaryAdapter dictionaryAdapter);
    private void InitializeReference(object value);
    private void AddSecondaryXmlMeta(DictionaryAdapterMeta meta);
    private static void RequireXmlMeta(DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy.Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private static string EnsureKey(string key, PropertyDescriptor property);
    private IXmlNode GetBaseNode();
    private IXmlNode GetSourceNode();
    private bool TryGetAccessor(string key, PropertyDescriptor property, bool requireVolatile, XmlAccessor& accessor);
    private XmlAccessor CreateAccessor(string key, PropertyDescriptor property);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor, XmlAccessorFactory`1<TAccessor> factory);
    private TAccessor CreateAccessor(string key, PropertyDescriptor property, XmlAccessorFactory`1<TAccessor> factory);
    private XmlMetadata GetXmlMetadata(Type type);
    private static bool IsIgnoreBehavior(object behavior);
    private static bool IsVolatileBehavior(object behavior);
    private static bool IsReferenceBehavior(object behavior);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    private void HandleNodeRealized(object sender, EventArgs e);
    private void AttachObservers(object value, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private void HandleListChanged(object value, ListChangedEventArgs args, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.TryGetReference(object keyObject, Object& inGraphObject);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.AddReference(object keyObject, object relatedObject, bool isInGraph);
    public virtual IDictionaryBehavior Copy();
    public static XmlAdapter For(object obj);
    public static XmlAdapter For(object obj, bool required);
    public static bool IsPropertyDefined(string propertyName, IDictionaryAdapter dictionaryAdapter);
    public bool HasProperty(string propertyName, IDictionaryAdapter dictionaryAdapter);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlArrayBehaviorAccessor : XmlNodeAccessor {
    private static CursorFlags PropertyFlags;
    private static CursorFlags CollectionItemFlags;
    private ItemAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XmlArrayBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlArrayBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlArrayBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlArrayBehaviorAccessor();
    public sealed virtual void Configure(XmlArrayAttribute attribute);
    public sealed virtual void Configure(XmlArrayItemAttribute attribute);
    public virtual void Prepare();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlArrayBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlArraySerializer : XmlTypeSerializer {
    public static XmlArraySerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlArraySerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    private static object GetItemSafe(Array array, int index);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAttributeBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlAttributeBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlAttributeBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlAttributeBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlAttributeBehaviorAccessor();
    public sealed virtual void Configure(XmlAttributeAttribute attribute);
    public virtual void ConfigureNillable(bool nillable);
    public virtual void ConfigureReference(bool isReference);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlAttributeBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionAdapter`1 : object {
    private List`1<XmlCollectionItem`1<T>> items;
    private List`1<XmlCollectionItem`1<T>> snapshot;
    private ICollectionAdapterObserver`1<T> advisor;
    private IXmlCursor cursor;
    private IXmlCollectionAccessor accessor;
    private IXmlNode parentNode;
    private IDictionaryAdapter parentObject;
    private XmlReferenceManager references;
    public IXmlNode Node { get; }
    public XmlReferenceManager References { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public IEqualityComparer`1<T> Comparer { get; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public XmlCollectionAdapter`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
    public XmlReferenceManager get_References();
    public sealed virtual int get_Count();
    public sealed virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual T AddNew();
    public sealed virtual bool Add(T value);
    public sealed virtual bool Insert(int index, T value);
    private bool InsertCore(int index, T value, bool append);
    private bool CommitInsert(int index, IXmlNode node, T value, bool append);
    private bool RollbackInsert();
    public sealed virtual void Remove(int index);
    public sealed virtual void Clear();
    public sealed virtual void ClearReferences();
    private void OnRemoving(XmlCollectionItem`1<T> item);
    private T GetValue(IXmlNode node);
    private void SetValue(IXmlCursor cursor, object oldValue, T& value);
    private static Type GetTypeOrDefault(T value);
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
    public sealed virtual bool get_HasSnapshot();
    public sealed virtual int get_SnapshotCount();
    public sealed virtual T GetCurrentItem(int index);
    public sealed virtual T GetSnapshotItem(int index);
    public sealed virtual void SaveSnapshot();
    public sealed virtual void LoadSnapshot();
    public sealed virtual void DropSnapshot();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionItem`1 : ValueType {
    public IXmlNode Node;
    public T Value;
    public bool HasValue;
    public XmlCollectionItem`1(IXmlNode node);
    public XmlCollectionItem`1(IXmlNode node, T value);
    private XmlCollectionItem`1(IXmlNode node, T value, bool hasValue);
    public XmlCollectionItem`1<T> WithValue(T value);
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlCollectionSerializer : XmlTypeSerializer {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public Type ListTypeConstructor { get; }
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public abstract virtual Type get_ListTypeConstructor();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlComponentSerializer : XmlTypeSerializer {
    public static XmlComponentSerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlComponentSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlContext : XmlContextBase {
    private XmlMetadata metadata;
    public string ChildNamespaceUri { get; }
    public XmlContext(XmlMetadata metadata);
    protected XmlContext(XmlContext parent);
    public sealed virtual IXmlContext Clone();
    public sealed virtual string get_ChildNamespaceUri();
    public sealed virtual bool IsReservedNamespaceUri(string namespaceUri);
    public sealed virtual XmlName GetDefaultXsiType(Type clrType);
    public sealed virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlContextBase : XsltContext {
    private XmlContextBase parent;
    private Dictionary`2<string, string> rootNamespaces;
    private bool hasNamespaces;
    private XPathContext xPathContext;
    private Dictionary`2<XmlName, IXsltContextVariable> variables;
    private Dictionary`2<XmlName, IXsltContextFunction> functions;
    private XPathContext XPathContext { get; }
    public bool Whitespace { get; }
    protected XmlContextBase(XmlContextBase parent);
    private static NameTable GetNameTable(XmlContextBase parent);
    public void AddNamespace(XmlNamespaceAttribute attribute);
    public virtual void AddNamespace(string prefix, string uri);
    private Dictionary`2<string, string> EnsureRootNamespaces();
    public virtual string LookupNamespace(string prefix);
    public virtual string LookupPrefix(string uri);
    public sealed virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public sealed virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
    private static bool TryGetDefinedPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private bool TryGetPreferredPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private static string GeneratePrefix(IXmlNode node);
    private bool ShouldDefineOnRoot(string prefix, string uri);
    private bool ShouldDefineOnRootCore(string prefix, string uri);
    private XPathContext get_XPathContext();
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUriA, string baseUriB);
    public void AddVariable(string prefix, string name, IXsltContextVariable variable);
    public void AddFunction(string prefix, string name, IXsltContextFunction function);
    public sealed virtual void AddVariable(XPathVariableAttribute attribute);
    public sealed virtual void AddFunction(XPathFunctionAttribute attribute);
    public void AddVariable(XmlName name, IXsltContextVariable variable);
    public void AddFunction(XmlName name, IXsltContextFunction function);
    private Dictionary`2<XmlName, IXsltContextVariable> EnsureVariables();
    private Dictionary`2<XmlName, IXsltContextFunction> EnsureFunctions();
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    private IXsltContextVariable ResolveVariableCore(string prefix, string name);
    private IXsltContextFunction ResolveFunctionCore(string prefix, string name, XPathResultType[] argTypes);
    public sealed virtual void Enlist(CompiledXPath path);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlCustomSerializer : XmlTypeSerializer {
    public static XmlCustomSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlCustomSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDefaultBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlDefaultBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlDefaultBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlDefaultBehaviorAccessor(Type type, IXmlContext context);
    public XmlDefaultBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlDefaultBehaviorAccessor();
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlDefaultBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDefaultSerializer : XmlTypeSerializer {
    private XmlSerializer serializer;
    public static XmlRootAttribute Root;
    public XmlTypeKind Kind { get; }
    public XmlDefaultSerializer(Type type);
    private static XmlDefaultSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDynamicSerializer : XmlTypeSerializer {
    public static XmlDynamicSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlDynamicSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlElementBehaviorAccessor : XmlNodeAccessor {
    private ItemAccessor itemAccessor;
    private List`1<XmlElementAttribute> attributes;
    internal static XmlAccessorFactory`1<XmlElementBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlElementBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlElementBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlElementBehaviorAccessor();
    public sealed virtual void Configure(XmlElementAttribute attribute);
    public virtual void Prepare();
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public sealed virtual string GetLocalName(XmlElementAttribute attribute);
    public sealed virtual string GetNamespaceUri(XmlElementAttribute attribute);
    public sealed virtual Type GetClrType(XmlElementAttribute attribute);
    [CompilerGeneratedAttribute]
private static XmlElementBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlEnumerationSerializer : XmlStringSerializer {
    public static XmlEnumerationSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlEnumerationSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlExtensions : object {
    [ExtensionAttribute]
public static bool PositionEquals(IXmlNode nodeA, IXmlNode nodeB);
    [ExtensionAttribute]
public static void CopyTo(IXmlNode source, IXmlNode target);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIgnoreBehaviorAccessor : XmlAccessor {
    public static XmlIgnoreBehaviorAccessor Instance;
    public bool IsIgnored { get; }
    private static XmlIgnoreBehaviorAccessor();
    public virtual bool get_IsIgnored();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIncludedType : object {
    private XmlName xsiType;
    private Type clrType;
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlIncludedType(XmlName xsiType, Type clrType);
    public XmlIncludedType(string localName, string namespaceUri, Type clrType);
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlIncludedType Require(IXmlIncludedTypeMap includedTypes, Type clrType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeSet : object {
    private Dictionary`2<XmlName, IXmlIncludedType> itemsByXsiType;
    private Dictionary`2<Type, IXmlIncludedType> itemsByClrType;
    public static IList`1<IXmlIncludedType> DefaultEntries;
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private static XmlIncludedTypeSet();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public void Add(IXmlIncludedType includedType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    public sealed virtual IEnumerator`1<IXmlIncludedType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlKnownType : object {
    private XmlName name;
    private XmlName xsiType;
    private Type clrType;
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlKnownType(XmlName name, XmlName xsiType, Type clrType);
    public XmlKnownType(string nameLocalName, string nameNamespaceUri, string xsiTypeLocalName, string xsiTypeNamespaceUri, Type clrType);
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlKnownType Require(IXmlKnownTypeMap map, Type clrType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeSet : object {
    private Dictionary`2<IXmlIdentity, IXmlKnownType> itemsByXmlIdentity;
    private Dictionary`2<Type, IXmlKnownType> itemsByClrType;
    private Type defaultType;
    private static StringComparer NameComparer;
    private static XmlNameComparer XsiTypeComparer;
    public IXmlKnownType Default { get; }
    public XmlKnownTypeSet(Type defaultType);
    private static XmlKnownTypeSet();
    public sealed virtual IXmlKnownType get_Default();
    public void Add(IXmlKnownType knownType, bool overwrite);
    public void AddXsiTypeDefaults();
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public IXmlKnownType[] ToArray();
    public sealed virtual IEnumerator`1<IXmlKnownType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlListSerializer : XmlCollectionSerializer {
    public static XmlListSerializer Instance;
    public Type ListTypeConstructor { get; }
    private static XmlListSerializer();
    public virtual Type get_ListTypeConstructor();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlMetadata : object {
    private static CursorFlags RootFlags;
    private Type clrType;
    private Nullable`1<bool> qualified;
    private Nullable`1<bool> isNullable;
    private Nullable`1<bool> isReference;
    private string rootLocalName;
    private string rootNamespaceUri;
    private string childNamespaceUri;
    private string typeLocalName;
    private string typeNamespaceUri;
    private HashSet`1<string> reservedNamespaceUris;
    private List`1<Type> pendingIncludes;
    private XmlIncludedTypeSet includedTypes;
    private XmlContext context;
    private DictionaryAdapterMeta source;
    private CompiledXPath path;
    protected static StringComparer NameComparer;
    public Type ClrType { get; }
    public Nullable`1<bool> Qualified { get; }
    public Nullable`1<bool> IsNullable { get; }
    public Nullable`1<bool> IsReference { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    public string ChildNamespaceUri { get; }
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    public XmlIncludedTypeSet IncludedTypes { get; }
    public IXmlContext Context { get; }
    public CompiledXPath Path { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    public XmlMetadata(DictionaryAdapterMeta meta, IEnumerable`1<string> reservedNamespaceUris);
    private static XmlMetadata();
    public sealed virtual Type get_ClrType();
    public Nullable`1<bool> get_Qualified();
    public Nullable`1<bool> get_IsNullable();
    public Nullable`1<bool> get_IsReference();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    public string get_ChildNamespaceUri();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlIncludedTypeSet get_IncludedTypes();
    public IXmlContext get_Context();
    public CompiledXPath get_Path();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public bool IsReservedNamespaceUri(string namespaceUri);
    public IXmlCursor SelectBase(IXmlNode node);
    private bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatch(Type clrType);
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    private void AddPendingInclude(XmlIncludeAttribute attribute);
    private void ProcessPendingIncludes();
    public XmlName GetDefaultXsiType(Type clrType);
    public IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    private bool TryGetXmlMetadata(Type clrType, XmlMetadata& metadata);
    private XmlMetadata GetXmlMetadata(Type clrType);
    private string GetDefaultTypeLocalName(Type clrType);
    private static bool IsInterfaceName(string name);
    private static bool TryCast(object obj, T& result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlMetadataBehavior : DictionaryBehaviorAttribute {
    public static XmlMetadataBehavior Default;
    private HashSet`1<string> reservedNamespaceUris;
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    private static XmlMetadataBehavior();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlMetadataBehavior AddReservedNamespaceUri(string uri);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(object behavior);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlName : ValueType {
    public static XmlName Empty;
    private string localName;
    private string namespaceUri;
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public XmlName(string localName, string namespaceUri);
    private static XmlName();
    public string get_LocalName();
    public string get_NamespaceUri();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XmlName other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(XmlName x, XmlName y);
    public static bool op_Inequality(XmlName x, XmlName y);
    public XmlName WithNamespaceUri(string namespaceUri);
    public virtual string ToString();
    public static XmlName ParseQName(string text);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNameComparer : object {
    public static XmlNameComparer Default;
    public static XmlNameComparer IgnoreCase;
    private StringComparer comparer;
    private XmlNameComparer(StringComparer comparer);
    private static XmlNameComparer();
    public sealed virtual int GetHashCode(XmlName name);
    public sealed virtual bool Equals(XmlName x, XmlName y);
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeAccessor : XmlAccessor {
    private string localName;
    private string namespaceUri;
    private XmlKnownTypeSet knownTypes;
    protected static StringComparer NameComparer;
    public XmlName Name { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    protected IXmlKnownTypeMap KnownTypes { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    protected XmlNodeAccessor(Type type, IXmlContext context);
    protected XmlNodeAccessor(string name, Type type, IXmlContext context);
    private static XmlNodeAccessor();
    public sealed virtual XmlName get_Name();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    protected IXmlKnownTypeMap get_KnownTypes();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    public sealed virtual bool TryGet(IXmlIdentity xmlName, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    protected virtual bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatchOnNamespaceUri(IXmlIdentity xmlIdentity);
    private bool IsMatchOnXsiType(IXmlIdentity xmlIdentity);
    private bool ShouldIgnoreAttributeNamespaceUri(IXmlIdentity xmlName);
    protected virtual bool IsMatch(Type clrType);
    protected void ConfigureLocalName(string localName);
    protected void ConfigureNamespaceUri(string namespaceUri);
    private void ConfigureField(String& field, string value, States mask);
    protected void ConfigureKnownTypesFromParent(XmlNodeAccessor accessor);
    protected void ConfigureKnownTypesFromAttributes(IEnumerable`1<T> attributes, IXmlBehaviorSemantics`1<T> semantics);
    public virtual void Prepare();
    private void ConfigureDefaultAndIncludedTypes();
    private void ConfigureIncludedTypes(IXmlKnownType knownType);
    private void AddKnownType(XmlName name, XmlName xsiType, Type clrType, bool overwrite);
    private void AddSelfAsKnownType();
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeBase : object {
    protected Type type;
    private IXmlNode parent;
    private IXmlNamespaceSource namespaces;
    public bool IsReal { get; }
    public Type ClrType { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public CompiledXPath Path { get; }
    protected XmlNodeBase(IXmlNamespaceSource namespaces, IXmlNode parent);
    public virtual bool get_IsReal();
    public virtual Type get_ClrType();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public virtual CompiledXPath get_Path();
    private sealed virtual override IRealizable`1<T> Castle.Components.DictionaryAdapter.Xml.IRealizableSource.AsRealizable();
    protected virtual void Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNodeList`1 : ListProjection`1<T> {
    public IXmlNode Node { get; }
    public XmlNodeList`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNodeSet`1 : SetProjection`1<T> {
    public IXmlNode Node { get; }
    public XmlNodeSet`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
}
internal static class Castle.Components.DictionaryAdapter.Xml.Xmlns : object {
    public static string Prefix;
    public static string NamespaceUri;
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlPositionComparer : object {
    public static XmlPositionComparer Instance;
    private static XmlPositionComparer();
    public bool Equals(IXmlNode nodeA, IXmlNode nodeB);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager : object {
    private Dictionary`2<int, Entry> entriesById;
    private WeakKeyDictionary`2<object, Entry> entriesByValue;
    private IXmlReferenceFormat format;
    private int nextId;
    private static Type StringType;
    private static object CreateEntryToken;
    public XmlReferenceManager(IXmlNode root, IXmlReferenceFormat format);
    private static XmlReferenceManager();
    private void Populate(IXmlNode node);
    private void PopulateFromNode(IXmlIterator node, ICollection`1<Reference> references);
    private void PopulateIdentity(int id, IXmlNode node);
    private void PopulateReference(int id, IXmlNode node, ICollection`1<Reference> references);
    private void PopulateDeferredReferences(ICollection`1<Reference> references);
    public bool TryGet(object keyObject, Object& inGraphObject);
    public void Add(IXmlNode node, object keyValue, object newValue, bool isInGraph);
    public bool OnGetStarting(IXmlNode& node, Object& value, Object& token);
    public void OnGetCompleted(IXmlNode node, object value, object token);
    public bool OnAssigningNull(IXmlNode node, object oldValue);
    public bool OnAssigningValue(IXmlNode node, object oldValue, Object& newValue, Object& token);
    private bool ShouldAssignmentProceed(Entry oldEntry, Entry newEntry, object token);
    private Entry OnReplacingValue(IXmlNode node, object oldValue);
    public void OnAssignedValue(IXmlNode node, object givenValue, object storedValue, object token);
    private void AddReference(IXmlNode node, Entry entry);
    private void GenerateId(Entry entry);
    private void AddValue(Entry entry, Type type, object value, XmlAdapter xmlAdapter);
    private void AddValueCore(Entry entry, Type type, object value, bool isInGraph);
    private void ClearReference(Entry entry, IXmlNode node);
    private void PrepareForReuse(Entry entry);
    private bool TryGetEntry(IXmlNode node, Entry& entry, Boolean& reference);
    private bool TryGetCompatibleValue(Entry entry, Type type, Object& value);
    private static void SetNotInGraph(Entry entry, object value);
    private static bool ShouldExclude(Type type);
    private static void SetNotInGraphCore(Entry entry, object value);
    private static IXmlNode RedirectNode(IXmlNode& node, Entry entry);
    public void UnionWith(XmlReferenceManager other);
    private static Exception IdNotFoundError(int id);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSelfAccessor : XmlAccessor {
    internal static XmlAccessorFactory`1<XmlSelfAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlSelfAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlSelfAccessor(Type clrType, IXmlContext context);
    private static XmlSelfAccessor();
    public virtual void ConfigureNillable(bool nillable);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlSelfAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSelfCursor : object {
    private IXmlNode node;
    private Type clrType;
    private int position;
    public CursorFlags Flags { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public bool IsReal { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public XmlSelfCursor(IXmlNode node, Type clrType);
    public CursorFlags get_Flags();
    public sealed virtual CompiledXPath get_Path();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
    public sealed virtual bool get_IsReal();
    public sealed virtual bool get_IsElement();
    public sealed virtual bool get_IsAttribute();
    public sealed virtual bool get_IsNil();
    public sealed virtual void set_IsNil(bool value);
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual string get_Xml();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public sealed virtual object get_UnderlyingObject();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual IRealizable`1<T> AsRealizable();
    public sealed virtual void Realize();
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool MoveNext();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual object Evaluate(CompiledXPath path);
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Clear();
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSetSerializer : XmlCollectionSerializer {
    public static XmlSetSerializer Instance;
    public Type ListTypeConstructor { get; }
    private static XmlSetSerializer();
    public virtual Type get_ListTypeConstructor();
}
internal static class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer : object {
    public static XmlTypeSerializer ForBoolean;
    public static XmlTypeSerializer ForChar;
    public static XmlTypeSerializer ForSByte;
    public static XmlTypeSerializer ForInt16;
    public static XmlTypeSerializer ForInt32;
    public static XmlTypeSerializer ForInt64;
    public static XmlTypeSerializer ForByte;
    public static XmlTypeSerializer ForUInt16;
    public static XmlTypeSerializer ForUInt32;
    public static XmlTypeSerializer ForUInt64;
    public static XmlTypeSerializer ForSingle;
    public static XmlTypeSerializer ForDouble;
    public static XmlTypeSerializer ForDecimal;
    public static XmlTypeSerializer ForTimeSpan;
    public static XmlTypeSerializer ForDateTime;
    public static XmlTypeSerializer ForDateTimeOffset;
    public static XmlTypeSerializer ForGuid;
    public static XmlTypeSerializer ForByteArray;
    public static XmlTypeSerializer ForUri;
    [CompilerGeneratedAttribute]
private static Func`2<Uri, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, Uri> CS$<>9__CachedAnonymousMethodDelegate3;
    private static XmlSimpleSerializer();
    private static string XmlConvert_ToString(DateTime value);
    private static DateTime XmlConvert_ToDateTime(string value);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__0(Uri u);
    [CompilerGeneratedAttribute]
private static Uri <.cctor>b__1(string s);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer`1 : XmlTypeSerializer {
    private Func`2<T, string> getString;
    private Func`2<string, T> getObject;
    public XmlTypeKind Kind { get; }
    public XmlSimpleSerializer`1(Func`2<T, string> getString, Func`2<string, T> getObject);
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlStringSerializer : XmlTypeSerializer {
    public static XmlStringSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlStringSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeReader : XmlReader {
    private string rootLocalName;
    private string rootNamespaceURI;
    private string underlyingNamespaceURI;
    private XmlReader reader;
    public bool IsDisposed { get; }
    protected XmlReader Reader { get; }
    public ReadState ReadState { get; }
    public int Depth { get; }
    public XmlNodeType NodeType { get; }
    public bool IsAtRootElement { get; }
    public bool EOF { get; }
    public string Prefix { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlSubtreeReader(IXmlNode node, XmlRootAttribute root);
    public XmlSubtreeReader(IXmlNode node, string rootLocalName, string rootNamespaceUri);
    protected virtual void Dispose(bool managed);
    private void DisposeReader();
    public bool get_IsDisposed();
    private void RequireNotDisposed();
    protected XmlReader get_Reader();
    public virtual ReadState get_ReadState();
    public virtual int get_Depth();
    public virtual XmlNodeType get_NodeType();
    public bool get_IsAtRootElement();
    public virtual bool get_EOF();
    public virtual string get_Prefix();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    private string CaptureNamespaceUri();
    private string TranslateNamespaceURI();
    public virtual string get_Value();
    public virtual bool get_IsEmptyElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual bool Read();
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool ReadAttributeValue();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void ResolveEntity();
    public virtual void Close();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeWriter : XmlWriter {
    private IXmlNode node;
    private XmlWriter rootWriter;
    private XmlWriter childWriter;
    private WriteState state;
    private int depth;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate32;
    private XmlWriter RootWriter { get; }
    private XmlWriter ChildWriter { get; }
    private bool IsInRootAttribute { get; }
    private bool IsInRoot { get; }
    private bool IsInChild { get; }
    public WriteState WriteState { get; }
    public XmlSubtreeWriter(IXmlNode node);
    protected virtual void Dispose(bool managed);
    private void DisposeWriter(XmlWriter& writer);
    private XmlWriter get_RootWriter();
    private XmlWriter get_ChildWriter();
    private bool get_IsInRootAttribute();
    private bool get_IsInRoot();
    private bool get_IsInChild();
    public virtual WriteState get_WriteState();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    private void WriteEndElement(Action`1<XmlWriter> action);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    private void WriteAttribute(Action`1<XmlWriter> action, WriteState entryState, WriteState exitState);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    private void WriteElementOrAttributeContent(Action`1<XmlWriter> action);
    public virtual void WriteString(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    private void WriteElementContent(Action`1<XmlWriter> action);
    public virtual void WriteCData(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void WithWriters(Action`1<XmlWriter> action, bool worksIfClosed, Nullable`1<WriteState> resetTo);
    public virtual void Flush();
    public virtual void WriteEndDocument();
    public virtual void Close();
    public virtual string LookupPrefix(string ns);
    private void RequireNotClosed();
    private void RequireState(WriteState state);
    private void RequireState(WriteState state1, WriteState state2);
    private void Reset(WriteState state);
    [CompilerGeneratedAttribute]
private static void <WriteEndElement>b__0(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteFullEndElement>b__2(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteEndAttribute>b__7(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <Flush>b__2d(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteEndDocument>b__2f(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <Close>b__31(XmlWriter w);
}
internal enum Castle.Components.DictionaryAdapter.Xml.XmlTypeKind : Enum {
    public int value__;
    public static XmlTypeKind Simple;
    public static XmlTypeKind Complex;
    public static XmlTypeKind Collection;
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializer : object {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public abstract virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    public static XmlTypeSerializer For(Type type);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializerCache : SingletonDispenser`2<Type, XmlTypeSerializer> {
    public static XmlTypeSerializerCache Instance;
    private static XmlTypeSerializerCache();
    private static XmlTypeSerializer CreateSerializer(Type type);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlXmlNodeSerializer : XmlTypeSerializer {
    public static XmlXmlNodeSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlXmlNodeSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.Xml.XPathAttribute : Attribute {
    private CompiledXPath getPath;
    private CompiledXPath setPath;
    [CompilerGeneratedAttribute]
private bool <Nullable>k__BackingField;
    public CompiledXPath GetPath { get; }
    public CompiledXPath SetPath { get; }
    public bool Nullable { get; public set; }
    public XPathAttribute(string path);
    public XPathAttribute(string get, string set);
    public CompiledXPath get_GetPath();
    public CompiledXPath get_SetPath();
    [CompilerGeneratedAttribute]
public bool get_Nullable();
    [CompilerGeneratedAttribute]
public void set_Nullable(bool value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathBehaviorAccessor : XmlAccessor {
    private CompiledXPath path;
    private XmlIncludedTypeSet includedTypes;
    private XmlAccessor defaultAccessor;
    private XmlAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XPathBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XPathBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.XsiType { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private bool SelectsNodes { get; }
    private bool CreatesAttributes { get; }
    protected XPathBehaviorAccessor(Type type, IXmlContext context);
    private static XPathBehaviorAccessor();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.get_XsiType();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    private bool get_SelectsNodes();
    private bool get_CreatesAttributes();
    public sealed virtual void Configure(XPathAttribute attribute);
    public sealed virtual void Configure(XPathVariableAttribute attribute);
    public sealed virtual void Configure(XPathFunctionAttribute attribute);
    public virtual void Prepare();
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetPropertyValueCore(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetDefaultPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object Evaluate(IXmlNode node);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool create);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    [CompilerGeneratedAttribute]
private static XPathBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathBufferedNodeIterator : XPathNodeIterator {
    private IList`1<XPathNavigator> items;
    private int index;
    public int CurrentPosition { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public XPathNavigator Current { get; }
    public XPathBufferedNodeIterator(XPathNodeIterator iterator);
    private XPathBufferedNodeIterator(XPathBufferedNodeIterator iterator);
    public virtual int get_CurrentPosition();
    public virtual int get_Count();
    public bool get_IsEmpty();
    public virtual XPathNavigator get_Current();
    public void Reset();
    public virtual bool MoveNext();
    public void MoveToEnd();
    public virtual XPathNodeIterator Clone();
}
internal static class Castle.Components.DictionaryAdapter.Xml.XPathCompiler : object {
    private static Func`1<CompiledXPathNode> NodeFactory;
    private static Func`1<CompiledXPathStep> StepFactory;
    [CompilerGeneratedAttribute]
private static Func`1<CompiledXPathNode> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`1<CompiledXPathStep> CS$<>9__CachedAnonymousMethodDelegate3;
    private static XPathCompiler();
    public static CompiledXPath Compile(string path);
    private static bool ParsePath(Tokenizer source, CompiledXPath path);
    private static bool ParseStep(Tokenizer source, CompiledXPath path, CompiledXPathStep& step);
    private static bool ParseNodeCore(Tokenizer source, Func`1<TNode> factory, TNode& node);
    private static bool ParsePredicateList(Tokenizer source, CompiledXPathNode parent);
    private static bool ParsePredicate(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseAndExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseLeftToRightExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseRightToLeftExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseNestedPath(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseNode(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseValue(Tokenizer source, XPathExpression& value);
    private static bool ParseQualifiedName(Tokenizer source, CompiledXPathNode node);
    private static bool ParseName(Tokenizer source, String& name);
    private static bool Consume(Tokenizer source, Token token);
    private static void LinkNodes(CompiledXPathNode previous, CompiledXPathNode next);
    [CompilerGeneratedAttribute]
private static CompiledXPathNode <.cctor>b__0();
    [CompilerGeneratedAttribute]
private static CompiledXPathStep <.cctor>b__1();
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathContext : XsltContext {
    private XsltContext context;
    public string DefaultNamespace { get; }
    public bool Whitespace { get; }
    public XPathContext(XsltContext xpathContext);
    public virtual string get_DefaultNamespace();
    public virtual string LookupNamespace(string prefix);
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUri, string nextbaseUri);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XPathExtensions : object {
    [ExtensionAttribute]
public static XPathNavigator CreateNavigatorSafe(IXPathNavigable source);
    [ExtensionAttribute]
public static bool MoveToLastChild(XPathNavigator navigator);
    [ExtensionAttribute]
public static bool MoveToLastAttribute(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetRootElement(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetParent(XPathNavigator navigator);
    [ExtensionAttribute]
public static void DeleteChildren(XPathNavigator node);
}
[AttributeUsageAttribute("1152")]
internal abstract class Castle.Components.DictionaryAdapter.Xml.XPathFunctionAttribute : Attribute {
    public static XPathResultType[] NoArgs;
    public XmlName Name { get; }
    public XPathResultType ReturnType { get; }
    public XPathResultType[] ArgTypes { get; }
    public int Maxargs { get; }
    public int Minargs { get; }
    private static XPathFunctionAttribute();
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_ReturnType();
    public virtual XPathResultType[] get_ArgTypes();
    public virtual int get_Maxargs();
    public virtual int get_Minargs();
    public abstract virtual object Invoke(XsltContext context, Object[] args, XPathNavigator node);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathMutableCursor : XPathNode {
    private XPathBufferedNodeIterator iterator;
    private CompiledXPathStep step;
    private int depth;
    private IXmlIncludedTypeMap knownTypes;
    private CursorFlags flags;
    private EventHandler Realized;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public bool HasPartialOrCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public XPathMutableCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public bool get_HasPartialOrCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool SeekCurrent();
    private bool Consume(XPathNodeIterator iterator, bool multiple);
    private bool SetAtEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveToEnd();
    private void ResetCurrent();
    private void ResetDepth();
    private int Descend();
    public sealed virtual void MoveTo(IXmlNode position);
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    public sealed virtual void Create(Type type);
    private void Insert();
    private void Append();
    private void Complete();
    private XmlWriter CreateWriterForAppend();
    private void WriteNode(CompiledXPathNode node, XmlWriter writer);
    private void WriteAttribute(CompiledXPathNode node, XmlWriter writer);
    private void WriteSimpleElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteComplexElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteSubnodes(CompiledXPathNode parent, XmlWriter writer, bool attributes);
    private void WriteValue(CompiledXPathNode node, XmlWriter writer);
    private void SeekCurrentAfterCreate(bool moved);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    public virtual IXmlNode Save();
    private void RequireRemovable();
    private void RequireMoved(bool result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathNode : XmlNodeBase {
    protected XPathNavigator node;
    protected CompiledXPath xpath;
    public object UnderlyingObject { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected XPathNode(CompiledXPath path, IXmlNamespaceSource namespaces, IXmlNode parent);
    public XPathNode(XPathNavigator node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    public virtual CompiledXPath get_Path();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public virtual XmlReader ReadSubtree();
    public virtual XmlWriter WriteAttributes();
    public virtual XmlWriter WriteChildren();
    public virtual void Clear();
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathReadOnlyCursor : XPathNode {
    private XPathNodeIterator iterator;
    private IXmlIncludedTypeMap includedTypes;
    private CursorFlags flags;
    public XPathReadOnlyCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    private bool SetAtEnd();
    private bool SetAtNext();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual void MoveToEnd();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
    public virtual IXmlNode Save();
}
[AttributeUsageAttribute("1152")]
internal abstract class Castle.Components.DictionaryAdapter.Xml.XPathVariableAttribute : Attribute {
    public XmlName Name { get; }
    public XPathResultType VariableType { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsLocal { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsParam { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_VariableType();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsLocal();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsParam();
    public abstract virtual object Evaluate(XsltContext context);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XRef : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static XmlName Id;
    public static XmlName Ref;
    internal static XmlNamespaceAttribute Namespace;
    private static XRef();
    [ExtensionAttribute]
public static string GetId(IXmlNode node);
    [ExtensionAttribute]
public static void SetId(IXmlCursor node, string id);
    [ExtensionAttribute]
public static string GetReference(IXmlNode node);
    [ExtensionAttribute]
public static void SetReference(IXmlCursor cursor, string id);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Xsd : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsd();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.Xsi : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static string NilValue;
    public static XmlName Type;
    public static XmlName Nil;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsi();
    [ExtensionAttribute]
public static XmlName GetXsiType(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiType(IXmlNode node, XmlName xsiType);
    [ExtensionAttribute]
public static bool IsXsiNil(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiNil(IXmlNode node, bool nil);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.XmlDefaultsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Qualified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    public bool Qualified { get; public set; }
    public bool IsNullable { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Qualified();
    [CompilerGeneratedAttribute]
public void set_Qualified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
public void set_IsNullable(bool value);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.XmlNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool Root { get; public set; }
    public bool Default { get; public set; }
    public string NamespaceUri { get; private set; }
    public string Prefix { get; private set; }
    public XmlNamespaceAttribute(string namespaceUri, string prefix);
    [CompilerGeneratedAttribute]
public bool get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(bool value);
    [CompilerGeneratedAttribute]
public bool get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(bool value);
    [CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [CompilerGeneratedAttribute]
private void set_NamespaceUri(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
private void set_Prefix(string value);
}
internal abstract class Castle.Core.Configuration.AbstractConfiguration : object {
    private ConfigurationAttributeCollection attributes;
    private ConfigurationCollection children;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ConfigurationAttributeCollection Attributes { get; }
    public ConfigurationCollection Children { get; }
    public string Name { get; protected set; }
    public string Value { get; protected set; }
    public virtual ConfigurationAttributeCollection get_Attributes();
    public virtual ConfigurationCollection get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(string value);
    public virtual object GetValue(Type type, object defaultValue);
}
internal class Castle.Core.Configuration.ConfigurationAttributeCollection : NameValueCollection {
    protected ConfigurationAttributeCollection(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.Configuration.ConfigurationCollection : List`1<IConfiguration> {
    public IConfiguration Item { get; }
    public ConfigurationCollection(IEnumerable`1<IConfiguration> value);
    public IConfiguration get_Item(string name);
}
internal interface Castle.Core.Configuration.IConfiguration {
    public string Name { get; }
    public string Value { get; }
    public ConfigurationCollection Children { get; }
    public ConfigurationAttributeCollection Attributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Value();
    public abstract virtual ConfigurationCollection get_Children();
    public abstract virtual ConfigurationAttributeCollection get_Attributes();
    public abstract virtual object GetValue(Type type, object defaultValue);
}
internal class Castle.Core.Configuration.MutableConfiguration : AbstractConfiguration {
    public string Value { get; public set; }
    public MutableConfiguration(string name);
    public MutableConfiguration(string name, string value);
    public string get_Value();
    public void set_Value(string value);
    public static MutableConfiguration Create(string name);
    public MutableConfiguration Attribute(string name, string value);
    public MutableConfiguration CreateChild(string name);
    public MutableConfiguration CreateChild(string name, string value);
}
internal class Castle.Core.Configuration.Xml.XmlConfigurationDeserializer : object {
    public IConfiguration Deserialize(XmlNode node);
    public static string GetConfigValue(string value);
    public static IConfiguration GetDeserializedNode(XmlNode node);
    public static bool IsTextNode(XmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.AttributesUtil : object {
    private static AttributeUsageAttribute DefaultAttributeUsage;
    private static AttributesUtil();
    [ExtensionAttribute]
public static T GetAttribute(ICustomAttributeProvider member);
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider member);
    [ExtensionAttribute]
public static T GetTypeAttribute(Type type);
    public static T[] GetTypeAttributes(Type type);
    public static Object[] GetInterfaceAttributes(Type type);
    [ExtensionAttribute]
public static AttributeUsageAttribute GetAttributeUsage(Type attributeType);
    public static Type GetTypeConverter(MemberInfo member);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider member);
}
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
internal static class Castle.Core.Internal.CollectionExtensions : object {
    [ExtensionAttribute]
public static TResult[] ConvertAll(T[] items, Converter`2<T, TResult> transformation);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> items, Action`1<T> action);
    [ExtensionAttribute]
public static T Find(T[] items, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static T[] FindAll(T[] items, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IEnumerable this);
}
internal interface Castle.Core.Internal.ILockHolder {
    public bool LockAcquired { get; }
    public abstract virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.InterfaceAttributeUtil : object {
    private Aged`1[] types;
    private Dictionary`2<Type, Aged`1<object>> singletons;
    private List`1<object> results;
    private int index;
    private static object ConflictMarker;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<Type, int>, Aged`1<Type>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<Aged`1<Type>, int> CS$<>9__CachedAnonymousMethodDelegate3;
    private Type CurrentType { get; }
    private int CurrentAge { get; }
    private bool IsMostDerivedType { get; }
    private InterfaceAttributeUtil(Type derivedType, Type[] baseTypes);
    private static InterfaceAttributeUtil();
    private Type get_CurrentType();
    private int get_CurrentAge();
    private bool get_IsMostDerivedType();
    public static Object[] GetAttributes(Type type, bool inherit);
    private Aged`1[] CollectTypes(Type derivedType, Type[] baseTypes);
    private Object[] GetAttributes(Object[] attributes);
    private void ProcessType(Object[] attributes);
    private void AddSingleton(object attribute, Type attributeType);
    private void CollectSingletons();
    private void HandleAttributeConflict(Type attributeType);
    private static bool ShouldConsiderType(Type type);
    private Aged`1<T> MakeAged(T value);
    [CompilerGeneratedAttribute]
private static Aged`1<Type> <CollectTypes>b__0(KeyValuePair`2<Type, int> a);
    [CompilerGeneratedAttribute]
private static int <CollectTypes>b__1(Aged`1<Type> t);
}
internal class Castle.Core.Internal.InternalsVisible : object {
    public static string ToCastleCore;
    public static string ToDynamicProxyGenAssembly2;
}
internal interface Castle.Core.Internal.IUpgradeableLockHolder {
    public abstract virtual ILockHolder Upgrade();
    public abstract virtual ILockHolder Upgrade(bool waitForLock);
}
internal abstract class Castle.Core.Internal.Lock : object {
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public abstract virtual ILockHolder ForReading();
    public abstract virtual ILockHolder ForWriting();
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public abstract virtual ILockHolder ForReading(bool waitForLock);
    public abstract virtual ILockHolder ForWriting(bool waitForLock);
    public static Lock Create();
}
internal class Castle.Core.Internal.MonitorLockHolder : object {
    private object locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public MonitorLockHolder(object locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.MonitorUpgradeableLockHolder : object {
    private object locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public MonitorUpgradeableLockHolder(object locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.NoOpLock : object {
    public static ILockHolder Lock;
    public bool LockAcquired { get; }
    private static NoOpLock();
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.NoOpUpgradeableLock : object {
    public static IUpgradeableLockHolder Lock;
    public bool LockAcquired { get; }
    private static NoOpUpgradeableLock();
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.PermissionUtil : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static bool IsGranted(IPermission permission);
}
internal class Castle.Core.Internal.SlimReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public SlimReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.SlimReadWriteLock : Lock {
    private ReaderWriterLockSlim locker;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public virtual ILockHolder ForReading();
    public virtual ILockHolder ForWriting();
    public virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public virtual ILockHolder ForReading(bool waitForLock);
    public virtual ILockHolder ForWriting(bool waitForLock);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
}
internal class Castle.Core.Internal.SlimUpgradeableReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    private SlimWriteLockHolder writerLock;
    private bool wasLockAlreadyHeld;
    public bool LockAcquired { get; }
    public SlimUpgradeableReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock, bool wasLockAlreadyHelf);
    public sealed virtual void Dispose();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.SlimWriteLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public SlimWriteLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.WeakKey : WeakReference {
    private int hashCode;
    public object Target { get; public set; }
    public WeakKey(object target, int hashCode);
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
internal class Castle.Core.Internal.WeakKeyComparer`1 : object {
    public static WeakKeyComparer`1<TKey> Default;
    private IEqualityComparer`1<TKey> comparer;
    public WeakKeyComparer`1(IEqualityComparer`1<TKey> comparer);
    private static WeakKeyComparer`1();
    public object Wrap(TKey key);
    public TKey Unwrap(object obj);
    public sealed virtual int GetHashCode(object obj);
    public sealed virtual bool Equals(object objA, object objB);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.Internal.WeakKeyDictionary`2 : object {
    private static int AgeThreshold;
    private Dictionary`2<object, TValue> dictionary;
    private WeakKeyComparer`1<TKey> comparer;
    private KeyCollection<TKey, TValue> keys;
    private int age;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public WeakKeyDictionary`2(int capacity);
    public WeakKeyDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakKeyDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private void Age(int amount);
    public void TrimDeadObjects();
}
internal interface Castle.Core.IServiceEnabledComponent {
    public abstract virtual void Service(IServiceProvider provider);
}
internal interface Castle.Core.IServiceProviderEx {
    public abstract virtual T GetService();
}
internal interface Castle.Core.IServiceProviderExAccessor {
    public IServiceProviderEx ServiceProvider { get; }
    public abstract virtual IServiceProviderEx get_ServiceProvider();
}
internal abstract class Castle.Core.Logging.AbstractExtendedLoggerFactory : MarshalByRefObject {
    public virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
internal abstract class Castle.Core.Logging.AbstractLoggerFactory : MarshalByRefObject {
    public virtual ILogger Create(Type type);
    public virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
internal class Castle.Core.Logging.ConsoleFactory : MarshalByRefObject {
    private Nullable`1<LoggerLevel> level;
    public ConsoleFactory(LoggerLevel level);
    public sealed virtual ILogger Create(Type type);
    public sealed virtual ILogger Create(string name);
    public sealed virtual ILogger Create(Type type, LoggerLevel level);
    public sealed virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.ConsoleLogger : LevelFilteredLogger {
    public ConsoleLogger(LoggerLevel logLevel);
    public ConsoleLogger(string name);
    public ConsoleLogger(string name, LoggerLevel logLevel);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
internal class Castle.Core.Logging.DiagnosticsLogger : LevelFilteredLogger {
    private EventLog eventLog;
    public DiagnosticsLogger(string logName);
    public DiagnosticsLogger(string logName, string source);
    public DiagnosticsLogger(string logName, string machineName, string source);
    public virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected virtual void Finalize();
    private static EventLogEntryType TranslateLevel(LoggerLevel level);
}
internal class Castle.Core.Logging.DiagnosticsLoggerFactory : AbstractLoggerFactory {
    private static string DefaultLogName;
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Core.Logging.IContextProperties {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
}
internal interface Castle.Core.Logging.IContextStack {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Clear();
    public abstract virtual string Pop();
    public abstract virtual IDisposable Push(string message);
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Core.Logging.IContextStacks {
    public IContextStack Item { get; }
    public abstract virtual IContextStack get_Item(string key);
}
internal interface Castle.Core.Logging.IExtendedLogger {
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public abstract virtual IContextProperties get_GlobalProperties();
    public abstract virtual IContextProperties get_ThreadProperties();
    public abstract virtual IContextStacks get_ThreadStacks();
}
internal interface Castle.Core.Logging.IExtendedLoggerFactory {
    public abstract virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public abstract virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
}
internal interface Castle.Core.Logging.ILogger {
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(Func`1<string> messageFactory);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, string format, Object[] args);
    public abstract virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(Func`1<string> messageFactory);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public abstract virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Fatal(Func`1<string> messageFactory);
    public abstract virtual void Fatal(string message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, string format, Object[] args);
    public abstract virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(Func`1<string> messageFactory);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, string format, Object[] args);
    public abstract virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(Func`1<string> messageFactory);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, string format, Object[] args);
    public abstract virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
internal interface Castle.Core.Logging.ILoggerFactory {
    public abstract virtual ILogger Create(Type type);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
}
internal abstract class Castle.Core.Logging.LevelFilteredLogger : MarshalByRefObject {
    private LoggerLevel level;
    private string name;
    public LoggerLevel Level { get; public set; }
    public string Name { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    protected LevelFilteredLogger(string name);
    protected LevelFilteredLogger(LoggerLevel loggerLevel);
    protected LevelFilteredLogger(string loggerName, LoggerLevel loggerLevel);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public LoggerLevel get_Level();
    public void set_Level(LoggerLevel value);
    public string get_Name();
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    protected abstract virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected void ChangeName(string newName);
    private void Log(LoggerLevel loggerLevel, string message, Exception exception);
}
internal class Castle.Core.Logging.LoggerException : Exception {
    public LoggerException(string message);
    public LoggerException(string message, Exception innerException);
    protected LoggerException(SerializationInfo info, StreamingContext context);
}
internal enum Castle.Core.Logging.LoggerLevel : Enum {
    public int value__;
    public static LoggerLevel Off;
    public static LoggerLevel Fatal;
    public static LoggerLevel Error;
    public static LoggerLevel Warn;
    public static LoggerLevel Info;
    public static LoggerLevel Debug;
}
internal class Castle.Core.Logging.NullLogFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.NullLogger : object {
    public static NullLogger Instance;
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    private static NullLogger();
    public sealed virtual IContextProperties get_GlobalProperties();
    public sealed virtual IContextProperties get_ThreadProperties();
    public sealed virtual IContextStacks get_ThreadStacks();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
internal class Castle.Core.Logging.StreamLogger : LevelFilteredLogger {
    private StreamWriter writer;
    public StreamLogger(string name, Stream stream);
    public StreamLogger(string name, Stream stream, Encoding encoding);
    public StreamLogger(string name, Stream stream, Encoding encoding, int bufferSize);
    protected StreamLogger(string name, StreamWriter writer);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
internal class Castle.Core.Logging.StreamLoggerFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.TraceLogger : LevelFilteredLogger {
    private static Dictionary`2<string, TraceSource> cache;
    private TraceSource traceSource;
    [SecuritySafeCriticalAttribute]
public TraceLogger(string name);
    [SecuritySafeCriticalAttribute]
public TraceLogger(string name, LoggerLevel level);
    private static TraceLogger();
    [SecuritySafeCriticalAttribute]
public virtual ILogger CreateChildLogger(string loggerName);
    [SecurityCriticalAttribute]
private ILogger InternalCreateChildLogger(string loggerName);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    [SecurityCriticalAttribute]
private void Initialize();
    private static string ShortenName(string name);
    [SecuritySafeCriticalAttribute]
private static bool IsSourceConfigured(TraceSource source);
    private static LoggerLevel MapLoggerLevel(SourceLevels level);
    private static SourceLevels MapSourceLevels(LoggerLevel level);
    private static TraceEventType MapTraceEventType(LoggerLevel level);
}
internal class Castle.Core.Logging.TraceLoggerFactory : AbstractLoggerFactory {
    [SecuritySafeCriticalAttribute]
public virtual ILogger Create(string name);
    [SecurityCriticalAttribute]
private ILogger InternalCreate(string name);
    [SecuritySafeCriticalAttribute]
public virtual ILogger Create(string name, LoggerLevel level);
    [SecurityCriticalAttribute]
private ILogger InternalCreate(string name, LoggerLevel level);
}
internal class Castle.Core.Pair`2 : object {
    private TFirst first;
    private TSecond second;
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair`2(TFirst first, TSecond second);
    public TFirst get_First();
    public TSecond get_Second();
    public virtual string ToString();
    public sealed virtual bool Equals(Pair`2<TFirst, TSecond> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Castle.Core.ProxyServices : object {
    public static bool IsDynamicProxy(Type type);
}
internal class Castle.Core.ReferenceEqualityComparer`1 : object {
    private static ReferenceEqualityComparer`1<T> instance;
    public static ReferenceEqualityComparer`1<T> Instance { get; }
    private static ReferenceEqualityComparer`1();
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
    public static ReferenceEqualityComparer`1<T> get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.ReflectionBasedDictionaryAdapter : object {
    private Dictionary`2<string, object> properties;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public ReflectionBasedDictionaryAdapter(object target);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Remove(object key);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public static void Read(IDictionary targetDictionary, object valuesAsAnonymousObject);
    private static object GetPropertyValue(object target, PropertyInfo property);
    private static IEnumerable`1<PropertyInfo> GetReadableProperties(Type targetType);
    private static bool IsReadable(PropertyInfo property);
}
internal abstract class Castle.Core.Resource.AbstractResource : object {
    protected static string DefaultBasePath;
    public string FileBasePath { get; }
    private static AbstractResource();
    public virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Castle.Core.Resource.AbstractStreamResource : AbstractResource {
    private StreamFactory createStream;
    public StreamFactory CreateStream { get; public set; }
    protected virtual void Finalize();
    public StreamFactory get_CreateStream();
    public void set_CreateStream(StreamFactory value);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
}
internal class Castle.Core.Resource.AssemblyBundleResource : AbstractResource {
    private CustomUri resource;
    public AssemblyBundleResource(CustomUri resource);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
    private static Assembly ObtainAssembly(string assemblyName);
}
internal class Castle.Core.Resource.AssemblyResource : AbstractStreamResource {
    private string assemblyName;
    private string resourcePath;
    private string basePath;
    public AssemblyResource(CustomUri resource);
    public AssemblyResource(CustomUri resource, string basePath);
    public AssemblyResource(string resource);
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateResourceFromPath(string resource, string path);
    private Stream CreateResourceFromUri(CustomUri resourcex, string path);
    private string GetNameFound(String[] names);
    private string ConvertToResourceName(string assembly, string resource);
    private string GetSimpleName(string assembly);
    private string ConvertToPath(string resource);
    private static Assembly ObtainAssembly(string assemblyName);
}
internal class Castle.Core.Resource.AssemblyResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.ConfigResource : AbstractResource {
    private XmlNode configSectionNode;
    private string sectionName;
    public ConfigResource(CustomUri uri);
    public ConfigResource(string sectionName);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
}
internal class Castle.Core.Resource.ConfigResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.CustomUri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeAssembly;
    private string scheme;
    private string host;
    private string path;
    private bool isUnc;
    private bool isFile;
    private bool isAssembly;
    public bool IsUnc { get; }
    public bool IsFile { get; }
    public bool IsAssembly { get; }
    public string Scheme { get; }
    public string Host { get; }
    public string Path { get; }
    public CustomUri(string resourceIdentifier);
    private static CustomUri();
    public bool get_IsUnc();
    public bool get_IsFile();
    public bool get_IsAssembly();
    public string get_Scheme();
    public string get_Host();
    public string get_Path();
    private void ParseIdentifier(string identifier);
}
internal class Castle.Core.Resource.FileResource : AbstractStreamResource {
    private string filePath;
    private string basePath;
    public string FileBasePath { get; }
    public FileResource(CustomUri resource);
    public FileResource(CustomUri resource, string basePath);
    public FileResource(string resourceName);
    public FileResource(string resourceName, string basePath);
    public virtual string ToString();
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private Stream CreateStreamFromPath(string resourcePath, string rootPath);
    private static void CheckFileExists(string path);
}
internal class Castle.Core.Resource.FileResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal interface Castle.Core.Resource.IResource {
    public string FileBasePath { get; }
    public abstract virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
}
internal interface Castle.Core.Resource.IResourceFactory {
    public abstract virtual bool Accept(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.ResourceException : Exception {
    public ResourceException(string message);
    public ResourceException(string message, Exception innerException);
    protected ResourceException(SerializationInfo info, StreamingContext context);
}
internal class Castle.Core.Resource.StaticContentResource : AbstractResource {
    private string contents;
    public StaticContentResource(string contents);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
}
internal class Castle.Core.Resource.StreamFactory : MulticastDelegate {
    public StreamFactory(object object, IntPtr method);
    public virtual Stream Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
internal class Castle.Core.Resource.UncResource : AbstractStreamResource {
    private string basePath;
    private string filePath;
    public string FileBasePath { get; }
    public UncResource(CustomUri resource);
    public UncResource(CustomUri resource, string basePath);
    public UncResource(string resourceName);
    public UncResource(string resourceName, string basePath);
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private static void CheckFileExists(string path);
}
internal class Castle.Core.Resource.UncResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Smtp.DefaultSmtpSender : object {
    private bool asyncSend;
    private string hostname;
    private int port;
    private Nullable`1<int> timeout;
    private bool useSsl;
    private NetworkCredential credentials;
    public int Port { get; public set; }
    public string Hostname { get; }
    public bool AsyncSend { get; public set; }
    public int Timeout { get; public set; }
    public bool UseSsl { get; public set; }
    public string Domain { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    private bool HasCredentials { get; }
    public DefaultSmtpSender(string hostname);
    public int get_Port();
    public void set_Port(int value);
    public string get_Hostname();
    public bool get_AsyncSend();
    public void set_AsyncSend(bool value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UseSsl();
    public void set_UseSsl(bool value);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Send(string from, string to, string subject, string messageText);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Send(MailMessage message);
    [SecurityCriticalAttribute]
private void InternalSend(MailMessage message);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Send(IEnumerable`1<MailMessage> messages);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    [SecurityCriticalAttribute]
protected virtual void Configure(SmtpClient smtpClient);
    private bool get_HasCredentials();
    private static bool CanAccessCredentials();
}
internal interface Castle.Core.Smtp.IEmailSender {
    public abstract virtual void Send(string from, string to, string subject, string messageText);
    public abstract virtual void Send(MailMessage message);
    public abstract virtual void Send(IEnumerable`1<MailMessage> messages);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.StringObjectDictionaryAdapter : object {
    private IDictionary dictionary;
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public StringObjectDictionaryAdapter(IDictionary dictionary);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public bool Contains(object key);
    public void Add(object key, object value);
    public sealed virtual void Clear();
    public void Remove(object key);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public ICollection get_Keys();
    public ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class Castle.DynamicProxy.AbstractInvocation : object {
    private IInterceptor[] interceptors;
    private Object[] arguments;
    private int currentInterceptorIndex;
    private Type[] genericMethodArguments;
    private MethodInfo proxiedMethod;
    protected object proxyObject;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type[] GenericArguments { get; }
    public object Proxy { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; public set; }
    public Object[] Arguments { get; }
    protected AbstractInvocation(object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    protected AbstractInvocation(object proxy, Type targetType, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments, IInterceptorSelector selector, IInterceptor[]& methodInterceptors);
    private IInterceptor[] SelectMethodInterceptors(IInterceptorSelector selector, IInterceptor[] methodInterceptors, Type targetType);
    public void SetGenericMethodArguments(Type[] arguments);
    public abstract virtual object get_InvocationTarget();
    public abstract virtual Type get_TargetType();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual object get_Proxy();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ReturnValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValue(object value);
    public sealed virtual Object[] get_Arguments();
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual void Proceed();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected abstract virtual void InvokeMethodOnTarget();
    protected void ThrowOnNoTarget();
    private MethodInfo EnsureClosedMethod(MethodInfo method);
}
internal class Castle.DynamicProxy.AllMethodsHook : object {
    protected static ICollection`1<Type> SkippedTypes;
    private static AllMethodsHook();
    public virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
    public virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public virtual void MethodsInspected();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Castle.DynamicProxy.Contributors.ClassMembersCollector : MembersCollector {
    public ClassMembersCollector(Type targetType);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyInstanceContributor : ProxyInstanceContributor {
    private bool delegateToBaseGetObjectData;
    private bool implementISerializable;
    private ConstructorInfo serializationConstructor;
    private IList`1<FieldReference> serializedFields;
    public ClassProxyInstanceContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, Type[] interfaces, string typeId);
    protected virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected virtual void AddAddValueInvocation(ArgumentReference serializationInfo, MethodEmitter getObjectData, FieldReference field);
    protected virtual void CustomizeGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
    private void EmitCustomGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo);
    private void EmitCallToBaseGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext);
    private void Constructor(ClassEmitter emitter);
    private void GenerateSerializationConstructor(ClassEmitter emitter);
    private bool VerifyIfBaseImplementsGetObjectData(Type baseType, IList`1<MethodInfo> methodsToSkip);
    private bool IsDelegate(Type baseType);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyTargetContributor : CompositeTypeContributor {
    private IList`1<MethodInfo> methodsToSkip;
    private Type targetType;
    public ClassProxyTargetContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private MethodBuilder CreateCallbackMethod(ClassEmitter emitter, MethodInfo methodInfo, MethodInfo methodOnTarget);
    private bool ExplicitlyImplementedInterfaceMethod(MetaMethod method);
    private MethodGenerator ExplicitlyImplementedInterfaceMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private Expression <GetMethodGenerator>b__a(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private Expression <ExplicitlyImplementedInterfaceMethodGenerator>b__b(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyWithTargetTargetContributor : CompositeTypeContributor {
    private IList`1<MethodInfo> methodsToSkip;
    private Type targetType;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegated;
    public ClassProxyWithTargetTargetContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private MethodGenerator IndirectlyCalledMethodGenerator(MetaMethod method, ClassEmitter proxy, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private bool IsDirectlyAccessible(MetaMethod method);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__a(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private static Expression <IndirectlyCalledMethodGenerator>b__c(ClassEmitter c, MethodInfo m);
}
internal abstract class Castle.DynamicProxy.Contributors.CompositeTypeContributor : object {
    protected INamingScope namingScope;
    protected ICollection`1<Type> interfaces;
    private ILogger logger;
    private ICollection`1<MetaProperty> properties;
    private ICollection`1<MetaEvent> events;
    private ICollection`1<MetaMethod> methods;
    public ILogger Logger { get; public set; }
    protected CompositeTypeContributor(INamingScope namingScope);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    protected abstract virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    public void AddInterfaceToProxy(Type interface);
    private void ImplementEvent(ClassEmitter emitter, MetaEvent event, ProxyGenerationOptions options);
    private void ImplementProperty(ClassEmitter emitter, MetaProperty property, ProxyGenerationOptions options);
    protected abstract virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private void ImplementMethod(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.DelegateProxyTargetContributor : CompositeTypeContributor {
    private Type targetType;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate6;
    public DelegateProxyTargetContributor(Type targetType, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__5(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.DelegateTypeGenerator : object {
    private static TypeAttributes DelegateFlags;
    private MetaMethod method;
    private Type targetType;
    public DelegateTypeGenerator(MetaMethod method, Type targetType);
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private void BuildConstructor(AbstractTypeEmitter emitter);
    private void BuildInvokeMethod(AbstractTypeEmitter delegate);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, INamingScope namingScope);
    private Type[] GetParamTypes(AbstractTypeEmitter delegate);
}
internal class Castle.DynamicProxy.Contributors.ForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public ForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal class Castle.DynamicProxy.Contributors.GetTargetExpressionDelegate : MulticastDelegate {
    public GetTargetExpressionDelegate(object object, IntPtr method);
    public virtual Expression Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.GetTargetReferenceDelegate : MulticastDelegate {
    public GetTargetReferenceDelegate(object object, IntPtr method);
    public virtual Reference Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual Reference EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersCollector : MembersCollector {
    public InterfaceMembersCollector(Type interface);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersOnClassCollector : MembersCollector {
    private InterfaceMapping map;
    private bool onlyProxyVirtual;
    public InterfaceMembersOnClassCollector(Type type, bool onlyProxyVirtual, InterfaceMapping map);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    private MethodInfo GetMethodOnTarget(MethodInfo method);
    private bool IsVirtuallyImplementedInterfaceMethod(MethodInfo method);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyInstanceContributor : ProxyInstanceContributor {
    public InterfaceProxyInstanceContributor(Type targetType, string proxyGeneratorId, Type[] interfaces);
    protected virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    protected virtual void CustomizeGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyTargetContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private Type proxyTargetType;
    [CompilerGeneratedAttribute]
private static GetTargetReferenceDelegate CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegatea;
    public InterfaceProxyTargetContributor(Type proxyTargetType, bool canChangeTarget, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private static Reference <GetMethodGenerator>b__7(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__8(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithOptionalTargetContributor : InterfaceProxyWithoutTargetContributor {
    private GetTargetReferenceDelegate getTargetReference;
    public InterfaceProxyWithOptionalTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithoutTargetContributor : CompositeTypeContributor {
    private GetTargetExpressionDelegate getTargetExpression;
    protected bool canChangeTarget;
    public InterfaceProxyWithoutTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithTargetInterfaceTargetContributor : InterfaceProxyTargetContributor {
    public InterfaceProxyWithTargetInterfaceTargetContributor(Type proxyTargetType, bool allowChangeTarget, INamingScope namingScope);
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private INamingScope namingScope;
    private Type targetType;
    public InvocationWithDelegateContributor(Type delegateType, Type targetType, MetaMethod method, INamingScope namingScope);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
    private FieldReference BuildDelegateToken(ClassEmitter proxy);
    private Expression[] GetAllArgs(Expression[] args, Reference targetField);
    private ArgumentReference[] GetArguments(ArgumentReference[] baseCtorArguments);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithGenericDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private Reference targetReference;
    public InvocationWithGenericDelegateContributor(Type delegateType, MetaMethod method, Reference targetReference);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
    private Reference GetDelegate(AbstractTypeEmitter invocation, MethodEmitter invokeMethodOnTarget);
    private AssignStatement SetDelegate(LocalReference localDelegate, ReferenceExpression localTarget, Type closedDelegateType, MethodInfo closedMethodOnTarget);
}
internal interface Castle.DynamicProxy.Contributors.ITypeContributor {
    public abstract virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    public abstract virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
}
internal abstract class Castle.DynamicProxy.Contributors.MembersCollector : object {
    private static BindingFlags Flags;
    private ILogger logger;
    private ICollection`1<MethodInfo> checkedMethods;
    private IDictionary`2<PropertyInfo, MetaProperty> properties;
    private IDictionary`2<EventInfo, MetaEvent> events;
    private IDictionary`2<MethodInfo, MetaMethod> methods;
    protected Type type;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public ILogger Logger { get; public set; }
    public IEnumerable`1<MetaMethod> Methods { get; }
    public IEnumerable`1<MetaProperty> Properties { get; }
    public IEnumerable`1<MetaEvent> Events { get; }
    protected MembersCollector(Type type);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public IEnumerable`1<MetaMethod> get_Methods();
    public IEnumerable`1<MetaProperty> get_Properties();
    public IEnumerable`1<MetaEvent> get_Events();
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook);
    private void CollectProperties(IProxyGenerationHook hook);
    private void CollectEvents(IProxyGenerationHook hook);
    private void CollectMethods(IProxyGenerationHook hook);
    private void AddProperty(PropertyInfo property, IProxyGenerationHook hook);
    private void AddEvent(EventInfo event, IProxyGenerationHook hook);
    private MetaMethod AddMethod(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected abstract virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool AcceptMethod(MethodInfo method, bool onlyVirtuals, IProxyGenerationHook hook);
    private static bool IsInternalAndNotVisibleToDynamicProxy(MethodInfo method);
    [CompilerGeneratedAttribute]
private static Type <AddProperty>b__0(ParameterInfo a);
}
internal class Castle.DynamicProxy.Contributors.MinimialisticMethodGenerator : MethodGenerator {
    public MinimialisticMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private void InitOutParameters(MethodEmitter emitter, ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Contributors.MixinContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private IList`1<Type> empty;
    private IDictionary`2<Type, FieldReference> fields;
    private GetTargetExpressionDelegate getTargetExpression;
    public IEnumerable`1<FieldReference> Fields { get; }
    public MixinContributor(INamingScope namingScope, bool canChangeTarget);
    public IEnumerable`1<FieldReference> get_Fields();
    public void AddEmptyInterface(Type interface);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private GetTargetExpressionDelegate BuildGetTargetExpression();
    private FieldReference BuildTargetField(ClassEmitter class, Type type);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private Reference <GetMethodGenerator>b__7(ClassEmitter c, MethodInfo i);
    [CompilerGeneratedAttribute]
private Expression <BuildGetTargetExpression>b__9(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private Expression <BuildGetTargetExpression>b__a(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.OptionallyForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public OptionallyForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private Expression IfNotNull(Reference targetReference);
    private Expression IfNull(Type returnType);
    private void InitOutParameters(MultiStatementExpression expression, ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Contributors.OverrideMethodDelegate : MulticastDelegate {
    public OverrideMethodDelegate(object object, IntPtr method);
    public virtual MethodEmitter Invoke(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public virtual IAsyncResult BeginInvoke(string name, MethodAttributes attributes, MethodInfo methodToOverride, AsyncCallback callback, object object);
    public virtual MethodEmitter EndInvoke(IAsyncResult result);
}
internal abstract class Castle.DynamicProxy.Contributors.ProxyInstanceContributor : object {
    protected Type targetType;
    private string proxyTypeId;
    private Type[] interfaces;
    protected ProxyInstanceContributor(Type targetType, Type[] interfaces, string proxyTypeId);
    protected abstract virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected void ImplementProxyTargetAccessor(ClassEmitter emitter, FieldReference interceptorsField);
    protected void ImplementGetObjectData(ClassEmitter emitter);
    protected virtual void AddAddValueInvocation(ArgumentReference serializationInfo, MethodEmitter getObjectData, FieldReference field);
    protected abstract virtual void CustomizeGetObjectData(AbstractCodeBuilder builder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
}
internal class Castle.DynamicProxy.Contributors.WrappedClassMembersCollector : ClassMembersCollector {
    public WrappedClassMembersCollector(Type type);
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool IsGeneratedByTheCompiler(FieldInfo field);
    protected virtual bool IsOKToBeOnProxy(FieldInfo field);
    private void CollectFields(IProxyGenerationHook hook);
}
internal class Castle.DynamicProxy.DefaultProxyBuilder : object {
    private ModuleScope scope;
    private ILogger logger;
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public DefaultProxyBuilder(ModuleScope scope);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    public sealed virtual ModuleScope get_ModuleScope();
    public sealed virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    private void AssertValidType(Type target);
    private void AssertValidTypes(IEnumerable`1<Type> targetTypes);
    private bool IsAccessible(Type target);
    private bool IsPublic(Type target);
    private static bool IsInternal(Type target);
}
internal class Castle.DynamicProxy.Generators.AttributeDisassembler : object {
    public sealed virtual CustomAttributeBuilder Disassemble(Attribute attribute);
    protected virtual CustomAttributeBuilder HandleError(Type attributeType, Exception exception);
    private static Object[] GetConstructorAndArgs(Type attributeType, Attribute attribute, ConstructorInfo& ctor);
    private static Object[] GetPropertyValues(Type attType, PropertyInfo[]& properties, Attribute original, Attribute replicated);
    private static Object[] GetFieldValues(Type attType, FieldInfo[]& fields, Attribute original, Attribute replicated);
    private static Object[] InitializeConstructorArgs(Type attributeType, Attribute attribute, ParameterInfo[] parameters);
    private static object GetArgumentValue(Type attributeType, Attribute attribute, ParameterInfo parameter);
    private static PropertyInfo ReplaceIfBetterMatch(ParameterInfo parameterInfo, PropertyInfo propertyInfo, PropertyInfo bestMatch);
    private static object ConvertValue(object obj, Type paramType);
    private static object GetDefaultValueFor(ParameterInfo parameter);
    private static List`1<PropertyInfo> GetPropertyCandidates(Type attributeType);
    private static bool AreAttributeElementsEqual(object first, object second);
    private static bool AreStringsEqual(string first, string second);
    public bool Equals(AttributeDisassembler other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class Castle.DynamicProxy.Generators.AttributesToAvoidReplicating : object {
    private static IList`1<Type> attributes;
    private static AttributesToAvoidReplicating();
    public static void Add(Type attribute);
    public static void Add();
    public static bool Contains(Type type);
}
internal abstract class Castle.DynamicProxy.Generators.BaseProxyGenerator : object {
    protected Type targetType;
    private ModuleScope scope;
    private ILogger logger;
    private ProxyGenerationOptions proxyGenerationOptions;
    public ILogger Logger { get; public set; }
    protected ProxyGenerationOptions ProxyGenerationOptions { get; protected set; }
    protected ModuleScope Scope { get; }
    protected BaseProxyGenerator(ModuleScope scope, Type targetType);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    protected ProxyGenerationOptions get_ProxyGenerationOptions();
    protected void set_ProxyGenerationOptions(ProxyGenerationOptions value);
    protected ModuleScope get_Scope();
    protected void AddMapping(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected void AddMappingForISerializable(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ITypeContributor instance);
    protected void AddMappingNoCheck(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected void AddToCache(CacheKey key, Type type);
    protected virtual ClassEmitter BuildClassEmitter(string typeName, Type parentType, IEnumerable`1<Type> interfaces);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected void CompleteInitCacheMethod(ConstructorCodeBuilder constCodeBuilder);
    protected virtual void CreateFields(ClassEmitter emitter);
    protected void CreateInterceptorsField(ClassEmitter emitter);
    protected FieldReference CreateOptionsField(ClassEmitter emitter);
    protected void CreateSelectorField(ClassEmitter emitter);
    protected virtual void CreateTypeAttributes(ClassEmitter emitter);
    protected void EnsureOptionsOverrideEqualsAndGetHashCode(ProxyGenerationOptions options);
    protected void GenerateConstructor(ClassEmitter emitter, ConstructorInfo baseConstructor, FieldReference[] fields);
    protected void GenerateConstructors(ClassEmitter emitter, Type baseType, FieldReference[] fields);
    protected void GenerateParameterlessConstructor(ClassEmitter emitter, Type baseClass, FieldReference interceptorField);
    protected ConstructorEmitter GenerateStaticConstructor(ClassEmitter emitter);
    protected Type GetFromCache(CacheKey key);
    protected void HandleExplicitlyPassedProxyTargetAccessor(ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces);
    protected void InitializeStaticFields(Type builtType);
    protected Type ObtainProxyType(CacheKey cacheKey, Func`3<string, INamingScope, Type> factory);
    private bool IsConstructorVisible(ConstructorInfo constructor);
    private bool OverridesEqualsAndGetHashCode(Type type);
}
internal class Castle.DynamicProxy.Generators.CacheKey : object {
    private MemberInfo target;
    private Type[] interfaces;
    private ProxyGenerationOptions options;
    private Type type;
    public CacheKey(MemberInfo target, Type type, Type[] interfaces, ProxyGenerationOptions options);
    public CacheKey(Type target, Type[] interfaces, ProxyGenerationOptions options);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Castle.DynamicProxy.Generators.ClassProxyGenerator : BaseProxyGenerator {
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate8;
    public ClassProxyGenerator(ModuleScope scope, Type targetType);
    public Type GenerateCode(Type[] interfaces, ProxyGenerationOptions options);
    protected virtual Type GenerateType(string name, Type[] interfaces, INamingScope namingScope);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type[] interfaces, IEnumerable`1& contributors, INamingScope namingScope);
    private void EnsureDoesNotImplementIProxyTargetAccessor(Type type, string name);
    [CompilerGeneratedAttribute]
private static Expression <GetTypeImplementerMapping>b__7(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.ClassProxyWithTargetGenerator : BaseProxyGenerator {
    private Type[] additionalInterfacesToProxy;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate5;
    public ClassProxyWithTargetGenerator(ModuleScope scope, Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public Type GetGeneratedType();
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(IEnumerable`1& contributors, INamingScope namingScope);
    private FieldReference CreateTargetField(ClassEmitter emitter);
    private void EnsureDoesNotImplementIProxyTargetAccessor(Type type, string name);
    private Type GenerateType(string name, INamingScope namingScope);
    [CompilerGeneratedAttribute]
private static Expression <GetTypeImplementerMapping>b__4(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.CompositionInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public CompositionInvocationTypeGenerator(Type target, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    private static CompositionInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
}
internal class Castle.DynamicProxy.Generators.DelegateMembersCollector : MembersCollector {
    public DelegateMembersCollector(Type type);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Generators.DelegateProxyGenerationHook : object {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void MethodsInspected();
    public sealed virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public sealed virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
internal class Castle.DynamicProxy.Generators.DelegateProxyGenerator : BaseProxyGenerator {
    public DelegateProxyGenerator(ModuleScope scope, Type delegateType);
    public Type GetProxyType();
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(IEnumerable`1& contributors, INamingScope namingScope);
    private FieldReference CreateTargetField(ClassEmitter emitter);
    private Type GenerateType(string name, INamingScope namingScope);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter : object {
    private static MethodAttributes defaultAttributes;
    private ConstructorCollection constructors;
    private EventCollection events;
    private IDictionary`2<string, FieldReference> fields;
    private MethodCollection methods;
    private Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType;
    private NestedClassCollection nested;
    private PropertiesCollection properties;
    private TypeBuilder typebuilder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    [CompilerGeneratedAttribute]
private TypeConstructorEmitter <ClassConstructor>k__BackingField;
    public Type BaseType { get; }
    public TypeConstructorEmitter ClassConstructor { get; private set; }
    public ConstructorCollection Constructors { get; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public NestedClassCollection Nested { get; }
    public TypeBuilder TypeBuilder { get; }
    protected AbstractTypeEmitter(TypeBuilder typeBuilder);
    public Type get_BaseType();
    [CompilerGeneratedAttribute]
public TypeConstructorEmitter get_ClassConstructor();
    [CompilerGeneratedAttribute]
private void set_ClassConstructor(TypeConstructorEmitter value);
    public ConstructorCollection get_Constructors();
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public NestedClassCollection get_Nested();
    public TypeBuilder get_TypeBuilder();
    public void AddCustomAttributes(ProxyGenerationOptions proxyGenerationOptions);
    public virtual Type BuildType();
    public void CopyGenericParametersFromMethod(MethodInfo methodToCopyGenericsFrom);
    public ConstructorEmitter CreateConstructor(ArgumentReference[] arguments);
    public void CreateDefaultConstructor();
    public EventEmitter CreateEvent(string name, EventAttributes atts, Type type);
    public FieldReference CreateField(string name, Type fieldType);
    public FieldReference CreateField(string name, Type fieldType, bool serializable);
    public FieldReference CreateField(string name, Type fieldType, FieldAttributes atts);
    public MethodEmitter CreateMethod(string name, MethodAttributes attrs, Type returnType, Type[] argumentTypes);
    public MethodEmitter CreateMethod(string name, Type returnType, Type[] parameterTypes);
    public MethodEmitter CreateMethod(string name, MethodInfo methodToUseAsATemplate);
    public MethodEmitter CreateMethod(string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public PropertyEmitter CreateProperty(string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public FieldReference CreateStaticField(string name, Type fieldType);
    public FieldReference CreateStaticField(string name, Type fieldType, FieldAttributes atts);
    public ConstructorEmitter CreateTypeConstructor();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void DefineCustomAttribute(Object[] constructorArguments);
    public void DefineCustomAttribute();
    public void DefineCustomAttributeFor(FieldReference field);
    public IEnumerable`1<FieldReference> GetAllFields();
    public FieldReference GetField(string name);
    public Type GetGenericArgument(string genericArgumentName);
    public Type[] GetGenericArgumentsFor(Type genericType);
    public Type[] GetGenericArgumentsFor(MethodInfo genericMethod);
    public void SetGenericTypeParameters(GenericTypeParameterBuilder[] genericTypeParameterBuilders);
    protected Type CreateType(TypeBuilder type);
    protected virtual void EnsureBuildersAreInAValidState();
}
internal class Castle.DynamicProxy.Generators.Emitters.ApplyGenArgs : MulticastDelegate {
    public ApplyGenArgs(object object, IntPtr method);
    public virtual GenericTypeParameterBuilder[] Invoke(String[] argumentNames);
    public virtual IAsyncResult BeginInvoke(String[] argumentNames, AsyncCallback callback, object object);
    public virtual GenericTypeParameterBuilder[] EndInvoke(IAsyncResult result);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.ArgumentsUtil : object {
    public static Expression[] ConvertArgumentReferenceToExpression(ArgumentReference[] args);
    public static ArgumentReference[] ConvertToArgumentReference(Type[] args);
    public static ArgumentReference[] ConvertToArgumentReference(ParameterInfo[] args);
    public static ReferenceExpression[] ConvertToArgumentReferenceExpression(ParameterInfo[] args);
    public static void EmitLoadOwnerAndReference(Reference reference, ILGenerator il);
    public static Type[] GetTypes(ParameterInfo[] parameters);
    public static Type[] InitializeAndConvert(ArgumentReference[] args);
    public static void InitializeArgumentsByPosition(ArgumentReference[] args, bool isStatic);
    public static bool IsAnyByRef(ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Generators.Emitters.ClassEmitter : AbstractTypeEmitter {
    private static TypeAttributes DefaultAttributes;
    private ModuleScope moduleScope;
    public ModuleScope ModuleScope { get; }
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces);
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags);
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
    public ClassEmitter(TypeBuilder typeBuilder);
    public ModuleScope get_ModuleScope();
    protected virtual IEnumerable`1<Type> InitializeGenericArgumentsFromBases(Type& baseType, IEnumerable`1<Type> interfaces);
    private static TypeBuilder CreateTypeBuilder(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
    private static bool ShouldForceUnsigned();
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.AbstractCodeBuilder : object {
    private ILGenerator generator;
    private List`1<Reference> ilmarkers;
    private List`1<Statement> stmts;
    private bool isEmpty;
    public ILGenerator Generator { get; }
    internal bool IsEmpty { get; }
    protected AbstractCodeBuilder(ILGenerator generator);
    public ILGenerator get_Generator();
    internal bool get_IsEmpty();
    public AbstractCodeBuilder AddStatement(Statement stmt);
    public LocalReference DeclareLocal(Type type);
    public void SetNonEmpty();
    internal void Generate(IMemberEmitter member, ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.ConstructorCodeBuilder : AbstractCodeBuilder {
    private Type baseType;
    public ConstructorCodeBuilder(Type baseType, ILGenerator generator);
    public void InvokeBaseConstructor();
    public void InvokeBaseConstructor(ConstructorInfo constructor);
    public void InvokeBaseConstructor(ConstructorInfo constructor, ArgumentReference[] arguments);
}
internal class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.MethodCodeBuilder : AbstractCodeBuilder {
    public MethodCodeBuilder(ILGenerator generator);
}
internal class Castle.DynamicProxy.Generators.Emitters.ConstructorCollection : Collection`1<ConstructorEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter : object {
    private ConstructorBuilder builder;
    private AbstractTypeEmitter maintype;
    private ConstructorCodeBuilder constructorCodeBuilder;
    public ConstructorCodeBuilder CodeBuilder { get; }
    public ConstructorBuilder ConstructorBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal ConstructorEmitter(AbstractTypeEmitter maintype, ConstructorBuilder builder);
    internal ConstructorEmitter(AbstractTypeEmitter maintype, ArgumentReference[] arguments);
    public virtual ConstructorCodeBuilder get_CodeBuilder();
    public ConstructorBuilder get_ConstructorBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.EventCollection : Collection`1<EventEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.EventEmitter : object {
    private EventBuilder eventBuilder;
    private Type type;
    private AbstractTypeEmitter typeEmitter;
    private MethodEmitter addMethod;
    private MethodEmitter removeMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public EventEmitter(AbstractTypeEmitter typeEmitter, string name, EventAttributes attributes, Type type);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateAddMethod(string addMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateRemoveMethod(string removeMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.GenericUtil : object {
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, TypeBuilder builder, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, MethodBuilder builder, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Type ExtractCorrectType(Type paramType, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Type[] ExtractParametersTypes(ParameterInfo[] baseMethodParameters, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Dictionary`2<string, GenericTypeParameterBuilder> GetGenericArgumentsMap(AbstractTypeEmitter parentEmitter);
    private static Type AdjustConstraintToNewGenericParameters(Type constraint, MethodInfo methodToCopyGenericsFrom, Type[] originalGenericParameters, GenericTypeParameterBuilder[] newGenericParameters);
    private static Type[] AdjustGenericConstraints(MethodInfo methodToCopyGenericsFrom, GenericTypeParameterBuilder[] newGenericParameters, Type[] originalGenericArguments, Type[] constraints);
    private static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType, ApplyGenArgs genericParameterGenerator);
    private static void CopyNonInheritableAttributes(GenericTypeParameterBuilder newGenericParameter, Type originalGenericArgument);
    private static String[] GetArgumentNames(Type[] originalGenericArguments);
}
internal interface Castle.DynamicProxy.Generators.Emitters.IMemberEmitter {
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public abstract virtual MemberInfo get_Member();
    public abstract virtual Type get_ReturnType();
    public abstract virtual void EnsureValidCodeBlock();
    public abstract virtual void Generate();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdcOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdcOpCodesDictionary Instance { get; }
    private static LdcOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdcOpCodesDictionary get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdindOpCodesDictionary Instance { get; }
    private static LdindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdindOpCodesDictionary get_Instance();
}
internal class Castle.DynamicProxy.Generators.Emitters.MethodCollection : Collection`1<MethodEmitter> {
}
[DebuggerDisplayAttribute("{builder.Name}")]
internal class Castle.DynamicProxy.Generators.Emitters.MethodEmitter : object {
    private MethodBuilder builder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    private ArgumentReference[] arguments;
    private MethodCodeBuilder codebuilder;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type[]> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type[]> CS$<>9__CachedAnonymousMethodDelegate3;
    public ArgumentReference[] Arguments { get; }
    public MethodCodeBuilder CodeBuilder { get; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public MethodBuilder MethodBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal MethodEmitter(MethodBuilder builder);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, Type returnType, Type[] argumentTypes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public ArgumentReference[] get_Arguments();
    public virtual MethodCodeBuilder get_CodeBuilder();
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public MethodBuilder get_MethodBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void SetParameters(Type[] paramTypes);
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
    private void DefineParameters(ParameterInfo[] parameters);
    private void SetReturnType(Type returnType);
    private void SetSignature(Type returnType, ParameterInfo returnParameter, Type[] parameters, ParameterInfo[] baseMethodParameters);
    [CompilerGeneratedAttribute]
private static Type[] <SetSignature>b__0(ParameterInfo x);
    [CompilerGeneratedAttribute]
private static Type[] <SetSignature>b__1(ParameterInfo x);
}
internal class Castle.DynamicProxy.Generators.Emitters.NestedClassCollection : Collection`1<NestedClassEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter : AbstractTypeEmitter {
    public NestedClassEmitter(AbstractTypeEmitter maintype, string name, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter maintype, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter maintype, TypeBuilder typeBuilder);
    private static TypeBuilder CreateTypeBuilder(AbstractTypeEmitter maintype, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.OpCodeUtil : object {
    public static void EmitLoadIndirectOpCodeForType(ILGenerator gen, Type type);
    public static void EmitLoadOpCodeForConstantValue(ILGenerator gen, object value);
    public static void EmitLoadOpCodeForDefaultValueOfType(ILGenerator gen, Type type);
    public static void EmitStoreIndirectOpCodeForType(ILGenerator gen, Type type);
    private static Type GetUnderlyingTypeOfEnum(Type enumType);
    private static bool Is64BitTypeLoadedAsInt32(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.PropertiesCollection : Collection`1<PropertyEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.PropertyEmitter : object {
    private PropertyBuilder builder;
    private AbstractTypeEmitter parentTypeEmitter;
    private MethodEmitter getMethod;
    private MethodEmitter setMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public PropertyEmitter(AbstractTypeEmitter parentTypeEmitter, string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AddressOfReferenceExpression : Expression {
    private Reference reference;
    public AddressOfReferenceExpression(Reference reference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("argument {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ArgumentReference : TypeReference {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Position { get; internal set; }
    public ArgumentReference(Type argumentType);
    public ArgumentReference(Type argumentType, int position);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArgumentStatement : Statement {
    private ArgumentReference argument;
    private Expression expression;
    public AssignArgumentStatement(ArgumentReference argument, Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArrayStatement : Statement {
    private Reference targetArray;
    private int targetPosition;
    private Expression value;
    public AssignArrayStatement(Reference targetArray, int targetPosition, Expression value);
    public virtual void Emit(IMemberEmitter member, ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignStatement : Statement {
    private Expression expression;
    private Reference target;
    public AssignStatement(Reference target, Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("{reference} as {type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AsTypeReference : Reference {
    private Reference reference;
    private Type type;
    public AsTypeReference(Reference reference, Type type);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.BindDelegateExpression : Expression {
    private ConstructorInfo delegateCtor;
    private MethodInfo methodToBindTo;
    private Expression owner;
    public BindDelegateExpression(Type delegate, Expression owner, MethodInfo methodToBindTo, GenericTypeParameterBuilder[] genericTypeParams);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("&{localReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ByRefReference : TypeReference {
    private LocalReference localReference;
    public ByRefReference(LocalReference localReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
[DebuggerDisplayAttribute("{value}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConstReference : TypeReference {
    private object value;
    public ConstReference(object value);
    public virtual void Generate(ILGenerator gen);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConstructorInvocationStatement : Statement {
    private Expression[] args;
    private ConstructorInfo cmethod;
    public ConstructorInvocationStatement(ConstructorInfo method, Expression[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConvertExpression : Expression {
    private Expression right;
    private Type fromType;
    private Type target;
    public ConvertExpression(Type targetType, Expression right);
    public ConvertExpression(Type targetType, Type fromType, Expression right);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
    private static void EmitCastIfNeeded(Type from, Type target, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.DefaultValueExpression : Expression {
    private Type type;
    public DefaultValueExpression(Type type);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
    private void EmitByRef(ILGenerator gen);
    private bool IsPrimitiveOrClass(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.EndExceptionBlockStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Expression : object {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ExpressionStatement : Statement {
    private Expression expression;
    public ExpressionStatement(Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("{fieldbuilder.Name} ({fieldbuilder.FieldType})")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference : Reference {
    private FieldInfo field;
    private FieldBuilder fieldbuilder;
    private bool isStatic;
    public FieldBuilder Fieldbuilder { get; }
    public FieldInfo Reference { get; }
    public FieldReference(FieldInfo field);
    public FieldReference(FieldBuilder fieldbuilder);
    public FieldBuilder get_Fieldbuilder();
    public FieldInfo get_Reference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FinallyStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IfNullExpression : Expression {
    private Expression ifNotNull;
    private Expression ifNull;
    private Reference reference;
    public IfNullExpression(Reference reference, Expression ifNull, Expression ifNotNull);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal interface Castle.DynamicProxy.Generators.Emitters.SimpleAST.IILEmitter {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("&{OwnerReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference : TypeReference {
    public IndirectReference(TypeReference byRefReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
    public static TypeReference WrapIfByRef(TypeReference reference);
    public static TypeReference[] WrapIfByRef(TypeReference[] references);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LiteralIntExpression : Expression {
    private int value;
    public LiteralIntExpression(int value);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LoadArrayElementExpression : Expression {
    private Reference arrayReference;
    private ConstReference index;
    private Type returnType;
    public LoadArrayElementExpression(int index, Reference arrayReference, Type returnType);
    public LoadArrayElementExpression(ConstReference index, Reference arrayReference, Type returnType);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LoadRefArrayElementExpression : Expression {
    private Reference arrayReference;
    private ConstReference index;
    public LoadRefArrayElementExpression(int index, Reference arrayReference);
    public LoadRefArrayElementExpression(ConstReference index, Reference arrayReference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("local {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LocalReference : TypeReference {
    private LocalBuilder localbuilder;
    public LocalReference(Type type);
    public virtual void Generate(ILGenerator gen);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodInvocationExpression : Expression {
    protected Expression[] args;
    protected MethodInfo method;
    protected Reference owner;
    [CompilerGeneratedAttribute]
private bool <VirtualCall>k__BackingField;
    public bool VirtualCall { get; public set; }
    public MethodInvocationExpression(MethodInfo method, Expression[] args);
    public MethodInvocationExpression(MethodEmitter method, Expression[] args);
    public MethodInvocationExpression(Reference owner, MethodEmitter method, Expression[] args);
    public MethodInvocationExpression(Reference owner, MethodInfo method, Expression[] args);
    [CompilerGeneratedAttribute]
public bool get_VirtualCall();
    [CompilerGeneratedAttribute]
public void set_VirtualCall(bool value);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodTokenExpression : Expression {
    private MethodInfo method;
    private Type declaringType;
    public MethodTokenExpression(MethodInfo method);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MultiStatementExpression : Expression {
    private List`1<Statement> statements;
    public void AddStatement(Statement statement);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression : Expression {
    private Type arrayType;
    private int size;
    public NewArrayExpression(int size, Type arrayType);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewInstanceExpression : Expression {
    private Expression[] arguments;
    private Type[] constructorArgs;
    private Type type;
    private ConstructorInfo constructor;
    public NewInstanceExpression(ConstructorInfo constructor, Expression[] args);
    public NewInstanceExpression(Type target, Type[] constructor_args, Expression[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NopStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullCoalescingOperatorExpression : Expression {
    private Expression default;
    private Expression expression;
    public NullCoalescingOperatorExpression(Expression expression, Expression default);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullExpression : Expression {
    public static NullExpression Instance;
    private static NullExpression();
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Reference : object {
    protected Reference owner;
    public Reference OwnerReference { get; public set; }
    protected Reference(Reference owner);
    public Reference get_OwnerReference();
    public void set_OwnerReference(Reference value);
    public abstract virtual void LoadAddressOfReference(ILGenerator gen);
    public abstract virtual void LoadReference(ILGenerator gen);
    public abstract virtual void StoreReference(ILGenerator gen);
    public virtual void Generate(ILGenerator gen);
    public virtual Expression ToAddressOfExpression();
    public virtual Expression ToExpression();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferenceExpression : Expression {
    private Reference reference;
    public ReferenceExpression(Reference reference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression : Expression {
    private TypeReference[] args;
    public ReferencesToObjectArrayExpression(TypeReference[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReturnStatement : Statement {
    private Expression expression;
    private Reference reference;
    public ReturnStatement(Reference reference);
    public ReturnStatement(Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("this")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.SelfReference : Reference {
    public static SelfReference Self;
    private static SelfReference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Statement : object {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ThrowStatement : Statement {
    private string errorMessage;
    private Type exceptionType;
    public ThrowStatement(Type exceptionType, string errorMessage);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TryStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeReference : Reference {
    private Type type;
    public Type Type { get; }
    protected TypeReference(Type argumentType);
    protected TypeReference(Reference owner, Type type);
    public Type get_Type();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeTokenExpression : Expression {
    private Type type;
    public TypeTokenExpression(Type type);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static StindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static StindOpCodesDictionary Instance { get; }
    private static StindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static StindOpCodesDictionary get_Instance();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Generators.Emitters.StrongNameUtil : object {
    private static IDictionary`2<Assembly, bool> signedAssemblyCache;
    private static object lockObject;
    [CompilerGeneratedAttribute]
private static bool <CanStrongNameAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    public static bool CanStrongNameAssembly { get; public set; }
    [SecuritySafeCriticalAttribute]
private static StrongNameUtil();
    [ExtensionAttribute]
public static bool IsAssemblySigned(Assembly assembly);
    [ExtensionAttribute]
private static bool ContainsPublicKey(Assembly assembly);
    public static bool IsAnyTypeFromUnsignedAssembly(IEnumerable`1<Type> types);
    public static bool IsAnyTypeFromUnsignedAssembly(Type baseType, IEnumerable`1<Type> interfaces);
    [CompilerGeneratedAttribute]
public static bool get_CanStrongNameAssembly();
    [CompilerGeneratedAttribute]
public static void set_CanStrongNameAssembly(bool value);
    [CompilerGeneratedAttribute]
private static bool <IsAnyTypeFromUnsignedAssembly>b__1(Type t);
}
internal class Castle.DynamicProxy.Generators.Emitters.TypeConstructorEmitter : ConstructorEmitter {
    internal TypeConstructorEmitter(AbstractTypeEmitter maintype);
    public virtual void EnsureValidCodeBlock();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Generators.Emitters.TypeUtil : object {
    [CompilerGeneratedAttribute]
private static Comparison`1<MemberInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Comparison`1<Type> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static FieldInfo[] GetAllFields(Type type);
    public static ICollection`1<Type> GetAllInterfaces(Type[] types);
    [ExtensionAttribute]
public static ICollection`1<Type> GetAllInterfaces(Type type);
    [ExtensionAttribute]
public static Type GetClosedParameterType(AbstractTypeEmitter type, Type parameter);
    [ExtensionAttribute]
public static bool IsFinalizer(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsGetType(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsMemberwiseClone(MethodInfo methodInfo);
    [ExtensionAttribute]
public static void SetStaticField(Type type, string fieldName, BindingFlags additionalFlags, object value);
    public static MemberInfo[] Sort(MemberInfo[] members);
    private static bool CloseGenericParametersIfAny(AbstractTypeEmitter emitter, Type[] arguments);
    private static Type[] Sort(IEnumerable`1<Type> types);
    [CompilerGeneratedAttribute]
private static int <Sort>b__0(MemberInfo l, MemberInfo r);
    [CompilerGeneratedAttribute]
private static int <Sort>b__2(Type l, Type r);
}
internal class Castle.DynamicProxy.Generators.GeneratorException : Exception {
    public GeneratorException(string message);
    public GeneratorException(string message, Exception innerException);
    public GeneratorException(SerializationInfo info, StreamingContext context);
}
internal static class Castle.DynamicProxy.Generators.GeneratorUtil : object {
    public static void CopyOutAndRefParameters(TypeReference[] dereferencedArguments, LocalReference invocation, MethodInfo method, MethodEmitter emitter);
    private static ConvertExpression Argument(int i, LocalReference invocationArgs, TypeReference[] arguments);
    private static AssignStatement AssignArgument(TypeReference[] dereferencedArguments, int i, LocalReference invocationArgs);
    private static AssignStatement GetArguments(LocalReference invocationArgs, LocalReference invocation);
    private static LocalReference StoreInvocationArgumentsInLocal(MethodEmitter emitter, LocalReference invocation);
}
internal interface Castle.DynamicProxy.Generators.IGenerator`1 {
    public abstract virtual T Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal interface Castle.DynamicProxy.Generators.IInvocationCreationContributor {
    public abstract virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public abstract virtual MethodInfo GetCallbackMethod();
    public abstract virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public abstract virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
}
internal interface Castle.DynamicProxy.Generators.INamingScope {
    public INamingScope ParentScope { get; }
    public abstract virtual INamingScope get_ParentScope();
    public abstract virtual string GetUniqueName(string suggestedName);
    public abstract virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.InheritanceInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public InheritanceInvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, IInvocationCreationContributor contributor);
    private static InheritanceInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator : InterfaceProxyWithTargetGenerator {
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegateb;
    protected string GeneratorType { get; }
    public InterfaceProxyWithoutTargetGenerator(ModuleScope scope, Type interface);
    protected virtual string get_GeneratorType();
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> interfaceTypeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual Type GenerateType(string typeName, Type proxyTargetType, Type[] interfaces, INamingScope namingScope);
    [CompilerGeneratedAttribute]
private static Expression <AddMappingForTargetType>b__a(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator : BaseProxyGenerator {
    protected FieldReference targetField;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate6;
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetGenerator(ModuleScope scope, Type interface);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    public Type GenerateCode(Type proxyTargetType, Type[] interfaces, ProxyGenerationOptions options);
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual void CreateTypeAttributes(ClassEmitter emitter);
    protected virtual Type GenerateType(string typeName, Type proxyTargetType, Type[] interfaces, INamingScope namingScope);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type[] interfaces, Type proxyTargetType, IEnumerable`1& contributors, INamingScope namingScope);
    protected virtual Type Init(string typeName, ClassEmitter& emitter, Type proxyTargetType, FieldReference& interceptorsField, IEnumerable`1<Type> interfaces);
    private void CreateFields(ClassEmitter emitter, Type proxyTargetType);
    private void EnsureValidBaseType(Type type);
    private bool ImplementedByTarget(ICollection`1<Type> targetInterfaces, Type interface);
    private void ThrowInvalidBaseType(Type type, string doesNotHaveAccessibleParameterlessConstructor);
    [CompilerGeneratedAttribute]
private static Expression <GetContributorForAdditionalInterfaces>b__5(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator : InterfaceProxyWithTargetGenerator {
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetInterfaceGenerator(ModuleScope scope, Type interface);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    private Reference GetTarget(ClassEmitter class, MethodInfo method);
    private Expression GetTargetExpression(ClassEmitter class, MethodInfo method);
}
internal abstract class Castle.DynamicProxy.Generators.InvocationTypeGenerator : object {
    protected MetaMethod method;
    protected Type targetType;
    private MethodInfo callback;
    private bool canChangeTarget;
    private IInvocationCreationContributor contributor;
    protected InvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    protected abstract virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected abstract virtual Type GetBaseType();
    protected abstract virtual FieldReference GetTargetReference();
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    protected virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, MethodInfo callbackMethod, Reference targetField, MethodEmitter invokeMethodOnTarget);
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
    private void AssignBackByRefArguments(MethodEmitter invokeMethodOnTarget, Dictionary`2<int, LocalReference> byRefArguments);
    private void CreateConstructor(AbstractTypeEmitter invocation, ProxyGenerationOptions options);
    private ConstructorEmitter CreateConstructor(AbstractTypeEmitter invocation, ArgumentReference[] baseCtorArguments);
    private AbstractCodeBuilder EmitCallEnsureValidTarget(MethodEmitter invokeMethodOnTarget);
    private void EmitCallThrowOnNoTarget(MethodEmitter invokeMethodOnTarget);
    private MethodInfo GetCallbackMethod(AbstractTypeEmitter invocation);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, Type[] interfaces, INamingScope namingScope, MethodInfo methodInfo);
    private void ImplemementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, FieldReference targetField, MethodInfo callbackMethod);
    private void ImplementChangeInvocationTarget(AbstractTypeEmitter invocation, FieldReference targetField);
    private void ImplementChangeProxyTarget(AbstractTypeEmitter invocation, ClassEmitter class);
    private void ImplementChangeProxyTargetInterface(ClassEmitter class, AbstractTypeEmitter invocation, FieldReference targetField);
}
internal class Castle.DynamicProxy.Generators.MetaEvent : MetaTypeElement {
    private MetaMethod adder;
    private MetaMethod remover;
    private Type type;
    private EventEmitter emitter;
    private string name;
    [CompilerGeneratedAttribute]
private EventAttributes <Attributes>k__BackingField;
    public MetaMethod Adder { get; }
    public EventAttributes Attributes { get; private set; }
    public EventEmitter Emitter { get; }
    public MetaMethod Remover { get; }
    public MetaEvent(string name, Type declaringType, Type eventDelegateType, MetaMethod adder, MetaMethod remover, EventAttributes attributes);
    public MetaMethod get_Adder();
    [CompilerGeneratedAttribute]
public EventAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(EventAttributes value);
    public EventEmitter get_Emitter();
    public MetaMethod get_Remover();
    public void BuildEventEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaEvent other);
    internal virtual void SwitchToExplicitImplementation();
}
[DebuggerDisplayAttribute("{Method}")]
internal class Castle.DynamicProxy.Generators.MetaMethod : MetaTypeElement {
    private static MethodAttributes ExplicitImplementationAttributes;
    private string name;
    [CompilerGeneratedAttribute]
private MethodAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodOnTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Proxyable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Standalone>k__BackingField;
    public MethodAttributes Attributes { get; private set; }
    public bool HasTarget { get; private set; }
    public MethodInfo Method { get; private set; }
    public MethodInfo MethodOnTarget { get; private set; }
    public string Name { get; }
    public bool Proxyable { get; private set; }
    public bool Standalone { get; private set; }
    public MetaMethod(MethodInfo method, MethodInfo methodOnTarget, bool standalone, bool proxyable, bool hasTarget);
    [CompilerGeneratedAttribute]
public MethodAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(MethodAttributes value);
    [CompilerGeneratedAttribute]
public bool get_HasTarget();
    [CompilerGeneratedAttribute]
private void set_HasTarget(bool value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodOnTarget();
    [CompilerGeneratedAttribute]
private void set_MethodOnTarget(MethodInfo value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Proxyable();
    [CompilerGeneratedAttribute]
private void set_Proxyable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Standalone();
    [CompilerGeneratedAttribute]
private void set_Standalone(bool value);
    public sealed virtual bool Equals(MetaMethod other);
    internal virtual void SwitchToExplicitImplementation();
    private MethodAttributes ObtainAttributes();
}
internal class Castle.DynamicProxy.Generators.MetaProperty : MetaTypeElement {
    private Type[] arguments;
    private PropertyAttributes attributes;
    private IEnumerable`1<CustomAttributeBuilder> customAttributes;
    private MetaMethod getter;
    private MetaMethod setter;
    private Type type;
    private PropertyEmitter emitter;
    private string name;
    public Type[] Arguments { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public PropertyEmitter Emitter { get; }
    public MethodInfo GetMethod { get; }
    public MetaMethod Getter { get; }
    public MethodInfo SetMethod { get; }
    public MetaMethod Setter { get; }
    public MetaProperty(string name, Type propertyType, Type declaringType, MetaMethod getter, MetaMethod setter, IEnumerable`1<CustomAttributeBuilder> customAttributes, Type[] arguments);
    public Type[] get_Arguments();
    public bool get_CanRead();
    public bool get_CanWrite();
    public PropertyEmitter get_Emitter();
    public MethodInfo get_GetMethod();
    public MetaMethod get_Getter();
    public MethodInfo get_SetMethod();
    public MetaMethod get_Setter();
    public void BuildPropertyEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaProperty other);
    internal virtual void SwitchToExplicitImplementation();
}
internal class Castle.DynamicProxy.Generators.MetaType : object {
    private ICollection`1<MetaEvent> events;
    private ICollection`1<MetaMethod> methods;
    private ICollection`1<MetaProperty> properties;
    public IEnumerable`1<MetaEvent> Events { get; }
    public IEnumerable`1<MetaMethod> Methods { get; }
    public IEnumerable`1<MetaProperty> Properties { get; }
    public IEnumerable`1<MetaEvent> get_Events();
    public IEnumerable`1<MetaMethod> get_Methods();
    public IEnumerable`1<MetaProperty> get_Properties();
    public void AddEvent(MetaEvent event);
    public void AddMethod(MetaMethod method);
    public void AddProperty(MetaProperty property);
}
internal abstract class Castle.DynamicProxy.Generators.MetaTypeElement : object {
    protected Type sourceType;
    internal bool CanBeImplementedExplicitly { get; }
    protected MetaTypeElement(Type sourceType);
    internal bool get_CanBeImplementedExplicitly();
    internal abstract virtual void SwitchToExplicitImplementation();
}
internal class Castle.DynamicProxy.Generators.MethodFinder : object {
    private static Dictionary`2<Type, object> cachedMethodInfosByType;
    private static object lockObject;
    private static MethodFinder();
    public static MethodInfo[] GetAllInstanceMethods(Type type, BindingFlags flags);
    private static MethodInfo[] MakeFilteredCopy(MethodInfo[] methodsInCache, BindingFlags visibilityFlags);
    private static object RemoveDuplicates(MethodInfo[] infos);
}
internal abstract class Castle.DynamicProxy.Generators.MethodGenerator : object {
    private MetaMethod method;
    private OverrideMethodDelegate overrideMethod;
    protected MethodInfo MethodOnTarget { get; }
    protected MethodInfo MethodToOverride { get; }
    protected MethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected MethodInfo get_MethodOnTarget();
    protected MethodInfo get_MethodToOverride();
    protected abstract virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    public sealed virtual MethodEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal class Castle.DynamicProxy.Generators.MethodSignatureComparer : object {
    public static MethodSignatureComparer Instance;
    private static MethodSignatureComparer();
    public bool EqualGenericParameters(MethodInfo x, MethodInfo y);
    public bool EqualParameters(MethodInfo x, MethodInfo y);
    public bool EqualSignatureTypes(Type x, Type y);
    public sealed virtual bool Equals(MethodInfo x, MethodInfo y);
    public sealed virtual int GetHashCode(MethodInfo obj);
    private bool EqualNames(MethodInfo x, MethodInfo y);
}
internal class Castle.DynamicProxy.Generators.MethodWithInvocationGenerator : MethodGenerator {
    private IInvocationCreationContributor contributor;
    private GetTargetExpressionDelegate getTargetExpression;
    private Reference interceptors;
    private Type invocation;
    [CompilerGeneratedAttribute]
private static Predicate`1<Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public MethodWithInvocationGenerator(MetaMethod method, Reference interceptors, Type invocation, GetTargetExpressionDelegate getTargetExpression, OverrideMethodDelegate createMethod, IInvocationCreationContributor contributor);
    protected FieldReference BuildMethodInterceptorsField(ClassEmitter class, MethodInfo method, INamingScope namingScope);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private void EmitLoadGenricMethodArguments(MethodEmitter methodEmitter, MethodInfo method, Reference invocationLocal);
    private Expression[] GetCtorArguments(ClassEmitter class, INamingScope namingScope, Expression proxiedMethodTokenExpression, TypeReference[] dereferencedArguments);
    private Expression[] ModifyArguments(ClassEmitter class, Expression[] arguments);
    private bool HasByRefArguments(ArgumentReference[] arguments);
    [CompilerGeneratedAttribute]
private static bool <EmitLoadGenricMethodArguments>b__0(Type t);
}
internal class Castle.DynamicProxy.Generators.NamingScope : object {
    private IDictionary`2<string, int> names;
    private INamingScope parentScope;
    public INamingScope ParentScope { get; }
    private NamingScope(INamingScope parent);
    public sealed virtual INamingScope get_ParentScope();
    public sealed virtual string GetUniqueName(string suggestedName);
    public sealed virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.TypeElementCollection`1 : object {
    private ICollection`1<TElement> items;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TElement>.IsReadOnly { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.get_IsReadOnly();
    public sealed virtual void Add(TElement item);
    public sealed virtual bool Contains(TElement item);
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.Remove(TElement item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface Castle.DynamicProxy.IAttributeDisassembler {
    public abstract virtual CustomAttributeBuilder Disassemble(Attribute attribute);
}
internal interface Castle.DynamicProxy.IChangeProxyTarget {
    public abstract virtual void ChangeInvocationTarget(object target);
    public abstract virtual void ChangeProxyTarget(object target);
}
internal interface Castle.DynamicProxy.IInterceptor {
    public abstract virtual void Intercept(IInvocation invocation);
}
public interface Castle.DynamicProxy.IInterceptorSelector {
    public abstract virtual IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors);
}
internal interface Castle.DynamicProxy.IInvocation {
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public object InvocationTarget { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object Proxy { get; }
    public object ReturnValue { get; public set; }
    public Type TargetType { get; }
    public abstract virtual Object[] get_Arguments();
    public abstract virtual Type[] get_GenericArguments();
    public abstract virtual object get_InvocationTarget();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public abstract virtual object get_Proxy();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual Type get_TargetType();
    public abstract virtual object GetArgumentValue(int index);
    public abstract virtual MethodInfo GetConcreteMethod();
    public abstract virtual MethodInfo GetConcreteMethodInvocationTarget();
    public abstract virtual void Proceed();
    public abstract virtual void SetArgumentValue(int index, object value);
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Internal.AttributeUtil : object {
    private static IDictionary`2<Type, IAttributeDisassembler> disassemblers;
    private static IAttributeDisassembler fallbackDisassembler;
    public static IAttributeDisassembler FallbackDisassembler { get; public set; }
    private static AttributeUtil();
    public static IAttributeDisassembler get_FallbackDisassembler();
    public static void set_FallbackDisassembler(IAttributeDisassembler value);
    public static void AddDisassembler(IAttributeDisassembler disassembler);
    public static CustomAttributeBuilder CreateBuilder(CustomAttributeData attribute);
    private static Object[] GetArguments(IList`1<CustomAttributeTypedArgument> constructorArguments);
    private static object ReadAttributeValue(CustomAttributeTypedArgument argument);
    private static void GetSettersAndFields(IEnumerable`1<CustomAttributeNamedArgument> namedArguments, PropertyInfo[]& properties, Object[]& propertyValues, FieldInfo[]& fields, Object[]& fieldValues);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeBuilder> GetNonInheritableAttributes(MemberInfo member);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeBuilder> GetNonInheritableAttributes(ParameterInfo parameter);
    private static bool ShouldSkipAttributeReplication(Type attribute);
    private static bool SpecialCaseAttributThatShouldNotBeReplicated(Type attribute);
    public static CustomAttributeBuilder CreateBuilder();
    public static CustomAttributeBuilder CreateBuilder(Type attribute, Object[] constructorArguments);
    internal static CustomAttributeBuilder CreateBuilder(Attribute attribute);
    private static Type[] GetTypes(Object[] objects);
}
public abstract class Castle.DynamicProxy.Internal.CompositionInvocation : AbstractInvocation {
    protected object target;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected CompositionInvocation(object target, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    protected CompositionInvocation(object target, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments, IInterceptorSelector selector, IInterceptor[]& methodInterceptors);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected void EnsureValidProxyTarget(object newTarget);
    protected void EnsureValidTarget();
    private static Type GetTargetType(object targetObject);
}
public abstract class Castle.DynamicProxy.Internal.InheritanceInvocation : AbstractInvocation {
    private Type targetType;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected InheritanceInvocation(Type targetType, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    protected InheritanceInvocation(Type targetType, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments, IInterceptorSelector selector, IInterceptor[]& methodInterceptors);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected abstract virtual void InvokeMethodOnTarget();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Internal.InternalsUtil : object {
    private static IDictionary`2<Assembly, bool> internalsToDynProxy;
    private static Lock internalsToDynProxyLock;
    private static InternalsUtil();
    [ExtensionAttribute]
public static bool IsInternal(MethodBase method);
    [ExtensionAttribute]
public static bool IsInternalToDynamicProxy(Assembly asm);
    private static bool VisibleToDynamicProxy(InternalsVisibleToAttribute attribute);
    [ExtensionAttribute]
public static bool IsAccessible(MethodBase method);
}
internal static class Castle.DynamicProxy.Internal.InvocationHelper : object {
    private static Dictionary`2<KeyValuePair`2<MethodInfo, Type>, MethodInfo> cache;
    private static Lock lock;
    private static InvocationHelper();
    public static MethodInfo GetMethodOnObject(object target, MethodInfo proxiedMethod);
    public static MethodInfo GetMethodOnType(Type type, MethodInfo proxiedMethod);
    private static MethodInfo GetFromCache(MethodInfo methodInfo, Type type);
    private static MethodInfo ObtainMethod(MethodInfo proxiedMethod, Type type);
    private static void PutToCache(MethodInfo methodInfo, Type type, MethodInfo value);
}
internal class Castle.DynamicProxy.InvalidMixinConfigurationException : Exception {
    public InvalidMixinConfigurationException(string message);
    public InvalidMixinConfigurationException(string message, Exception innerException);
    protected InvalidMixinConfigurationException(SerializationInfo info, StreamingContext context);
}
internal class Castle.DynamicProxy.InvalidProxyConstructorArgumentsException : ArgumentException {
    [CompilerGeneratedAttribute]
private Type <ClassToProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ProxyType>k__BackingField;
    public Type ClassToProxy { get; private set; }
    public Type ProxyType { get; private set; }
    public InvalidProxyConstructorArgumentsException(string message, Type proxyType, Type classToProxy);
    [CompilerGeneratedAttribute]
public Type get_ClassToProxy();
    [CompilerGeneratedAttribute]
private void set_ClassToProxy(Type value);
    [CompilerGeneratedAttribute]
public Type get_ProxyType();
    [CompilerGeneratedAttribute]
private void set_ProxyType(Type value);
}
internal interface Castle.DynamicProxy.IProxyBuilder {
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual ModuleScope get_ModuleScope();
    public abstract virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
public interface Castle.DynamicProxy.IProxyGenerationHook {
    public abstract virtual void MethodsInspected();
    public abstract virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public abstract virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
public interface Castle.DynamicProxy.IProxyTargetAccessor {
    public abstract virtual object DynProxyGetTarget();
    public abstract virtual IInterceptor[] GetInterceptors();
}
internal class Castle.DynamicProxy.MixinData : object {
    private Dictionary`2<Type, int> mixinPositions;
    private List`1<object> mixinsImpl;
    [CompilerGeneratedAttribute]
private static Comparison`1<Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public IEnumerable`1<Type> MixinInterfaces { get; }
    public IEnumerable`1<object> Mixins { get; }
    public MixinData(IEnumerable`1<object> mixinInstances);
    public IEnumerable`1<Type> get_MixinInterfaces();
    public IEnumerable`1<object> get_Mixins();
    public bool ContainsMixin(Type mixinInterfaceType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object GetMixinInstance(Type mixinInterfaceType);
    public int GetMixinPosition(Type mixinInterfaceType);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(Type x, Type y);
}
internal class Castle.DynamicProxy.ModuleScope : object {
    public static string DEFAULT_FILE_NAME;
    public static string DEFAULT_ASSEMBLY_NAME;
    private ModuleBuilder moduleBuilderWithStrongName;
    private ModuleBuilder moduleBuilder;
    private string strongAssemblyName;
    private string weakAssemblyName;
    private string strongModulePath;
    private string weakModulePath;
    private Dictionary`2<CacheKey, Type> typeCache;
    private Lock cacheLock;
    private object moduleLocker;
    private bool savePhysicalAssembly;
    private bool disableSignedModule;
    private INamingScope namingScope;
    public INamingScope NamingScope { get; }
    public Lock Lock { get; }
    public ModuleBuilder StrongNamedModule { get; }
    public string StrongNamedModuleName { get; }
    public string StrongNamedModuleDirectory { get; }
    public ModuleBuilder WeakNamedModule { get; }
    public string WeakNamedModuleName { get; }
    public string WeakNamedModuleDirectory { get; }
    public ModuleScope(bool savePhysicalAssembly);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, INamingScope namingScope, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    private static ModuleScope();
    public INamingScope get_NamingScope();
    public Lock get_Lock();
    public Type GetFromCache(CacheKey key);
    public void RegisterInCache(CacheKey key, Type type);
    public static Byte[] GetKeyPair();
    public ModuleBuilder get_StrongNamedModule();
    public string get_StrongNamedModuleName();
    public string get_StrongNamedModuleDirectory();
    public ModuleBuilder get_WeakNamedModule();
    public string get_WeakNamedModuleName();
    public string get_WeakNamedModuleDirectory();
    public ModuleBuilder ObtainDynamicModule(bool isStrongNamed);
    public ModuleBuilder ObtainDynamicModuleWithStrongName();
    public ModuleBuilder ObtainDynamicModuleWithWeakName();
    private ModuleBuilder CreateModule(bool signStrongName);
    private AssemblyName GetAssemblyName(bool signStrongName);
    public string SaveAssembly();
    public string SaveAssembly(bool strongNamed);
    private void AddCacheMappings(AssemblyBuilder builder);
    public void LoadAssemblyIntoCache(Assembly assembly);
    public TypeBuilder DefineType(bool inSignedModulePreferably, string name, TypeAttributes flags);
}
internal class Castle.DynamicProxy.PersistentProxyBuilder : DefaultProxyBuilder {
    public string SaveAssembly();
}
internal class Castle.DynamicProxy.ProxyGenerationException : Exception {
    public ProxyGenerationException(string message);
    public ProxyGenerationException(string message, Exception innerException);
}
internal class Castle.DynamicProxy.ProxyGenerationOptions : object {
    public static ProxyGenerationOptions Default;
    private List`1<object> mixins;
    internal IList`1<Attribute> attributesToAddToGeneratedTypes;
    private IList`1<CustomAttributeBuilder> additionalAttributes;
    private MixinData mixinData;
    [CompilerGeneratedAttribute]
private IProxyGenerationHook <Hook>k__BackingField;
    [CompilerGeneratedAttribute]
private IInterceptorSelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseTypeForInterfaceProxy>k__BackingField;
    public IProxyGenerationHook Hook { get; public set; }
    public IInterceptorSelector Selector { get; public set; }
    public Type BaseTypeForInterfaceProxy { get; public set; }
    [ObsoleteAttribute("This property is obsolete and will be removed in future versions. Use AdditionalAttributes property instead. You can use AttributeUtil class to simplify creating CustomAttributeBuilder instances for common cases.")]
public IList`1<Attribute> AttributesToAddToGeneratedTypes { get; }
    public IList`1<CustomAttributeBuilder> AdditionalAttributes { get; }
    public MixinData MixinData { get; }
    public bool HasMixins { get; }
    public ProxyGenerationOptions(IProxyGenerationHook hook);
    private ProxyGenerationOptions(SerializationInfo info, StreamingContext context);
    private static ProxyGenerationOptions();
    public void Initialize();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IProxyGenerationHook get_Hook();
    [CompilerGeneratedAttribute]
public void set_Hook(IProxyGenerationHook value);
    [CompilerGeneratedAttribute]
public IInterceptorSelector get_Selector();
    [CompilerGeneratedAttribute]
public void set_Selector(IInterceptorSelector value);
    [CompilerGeneratedAttribute]
public Type get_BaseTypeForInterfaceProxy();
    [CompilerGeneratedAttribute]
public void set_BaseTypeForInterfaceProxy(Type value);
    public IList`1<Attribute> get_AttributesToAddToGeneratedTypes();
    public IList`1<CustomAttributeBuilder> get_AdditionalAttributes();
    public MixinData get_MixinData();
    public void AddMixinInstance(object instance);
    public Object[] MixinsAsArray();
    public bool get_HasMixins();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[CLSCompliantAttribute("True")]
internal class Castle.DynamicProxy.ProxyGenerator : object {
    private ILogger logger;
    private IProxyBuilder proxyBuilder;
    public ILogger Logger { get; public set; }
    public IProxyBuilder ProxyBuilder { get; }
    public ProxyGenerator(IProxyBuilder builder);
    public ProxyGenerator(bool disableSignedModule);
    private bool HasSecurityPermission();
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public IProxyBuilder get_ProxyBuilder();
    public TInterface CreateInterfaceProxyWithTarget(TInterface target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTarget(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> GetConstructorArguments(object target, IInterceptor[] interceptors, ProxyGenerationOptions options);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    [SecuritySafeCriticalAttribute]
public virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithoutTarget(IInterceptor interceptor);
    public TInterface CreateInterfaceProxyWithoutTarget(IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithoutTarget(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor interceptor);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public TClass CreateClassProxyWithTarget(TClass target, IInterceptor[] interceptors);
    public TClass CreateClassProxyWithTarget(TClass target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public TClass CreateClassProxy(IInterceptor[] interceptors);
    public TClass CreateClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    protected object CreateClassProxyInstance(Type proxyType, List`1<object> proxyArguments, Type classToProxy, Object[] constructorArguments);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected List`1<object> BuildArgumentListForClassProxyWithTarget(object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> BuildArgumentListForClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
internal class Castle.DynamicProxy.ProxyUtil : object {
    public static object GetUnproxiedInstance(object instance);
    public static Type GetUnproxiedType(object instance);
    public static bool IsProxy(object instance);
    public static bool IsProxyType(Type type);
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("1")]
internal class Castle.DynamicProxy.Serialization.CacheMappingsAttribute : Attribute {
    private static ConstructorInfo constructor;
    private Byte[] _serializedCacheMappings;
    public Byte[] SerializedCacheMappings { get; }
    public CacheMappingsAttribute(Byte[] serializedCacheMappings);
    private static CacheMappingsAttribute();
    public Byte[] get_SerializedCacheMappings();
    public Dictionary`2<CacheKey, string> GetDeserializedMappings();
    public static void ApplyTo(AssemblyBuilder assemblyBuilder, Dictionary`2<CacheKey, string> mappings);
}
internal class Castle.DynamicProxy.Serialization.ProxyObjectReference : object {
    private static ModuleScope scope;
    private SerializationInfo info;
    private StreamingContext context;
    private Type baseType;
    private Type[] interfaces;
    private object proxy;
    private ProxyGenerationOptions proxyGenerationOptions;
    private bool isInterfaceProxy;
    private bool delegateToBase;
    public static ModuleScope ModuleScope { get; }
    [SecurityCriticalAttribute]
protected ProxyObjectReference(SerializationInfo info, StreamingContext context);
    private static ProxyObjectReference();
    public static void ResetScope();
    public static void SetScope(ModuleScope scope);
    public static ModuleScope get_ModuleScope();
    private Type DeserializeTypeFromString(string key);
    [SecurityCriticalAttribute]
protected virtual object RecreateProxy();
    [SecurityCriticalAttribute]
private object RecreateClassProxyWithTarget();
    [SecurityCriticalAttribute]
public object RecreateInterfaceProxy(string generatorType);
    [SecurityCriticalAttribute]
public object RecreateClassProxy();
    [SecurityCriticalAttribute]
private object InstantiateClassProxy(Type proxy_type);
    protected void InvokeCallback(object target);
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private void DeserializeProxyMembers();
    [SecurityCriticalAttribute]
private void DeserializeProxyState();
    private void SetTarget(object target);
    private void SetInterceptors(IInterceptor[] interceptors);
    private T GetValue(string name);
}
internal static class Castle.DynamicProxy.Serialization.ProxyTypeConstants : object {
    public static string Class;
    public static string ClassWithTarget;
    public static string InterfaceWithTarget;
    public static string InterfaceWithTargetInterface;
    public static string InterfaceWithoutTarget;
    private static ProxyTypeConstants();
}
internal class Castle.DynamicProxy.Serialization.RemotableInvocation : MarshalByRefObject {
    private IInvocation parent;
    public Type[] GenericArguments { get; }
    public object Proxy { get; }
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public Object[] Arguments { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object ReturnValue { get; public set; }
    public RemotableInvocation(IInvocation parent);
    protected RemotableInvocation(SerializationInfo info, StreamingContext context);
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual void Proceed();
    public sealed virtual object get_Proxy();
    public sealed virtual object get_InvocationTarget();
    public sealed virtual Type get_TargetType();
    public sealed virtual Object[] get_Arguments();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    public sealed virtual object get_ReturnValue();
    public sealed virtual void set_ReturnValue(object value);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Castle.DynamicProxy.StandardInterceptor : MarshalByRefObject {
    public sealed virtual void Intercept(IInvocation invocation);
    protected virtual void PerformProceed(IInvocation invocation);
    protected virtual void PreProceed(IInvocation invocation);
    protected virtual void PostProceed(IInvocation invocation);
}
internal static class Castle.DynamicProxy.Tokens.DelegateMethods : object {
    public static MethodInfo CreateDelegate;
    private static DelegateMethods();
}
internal static class Castle.DynamicProxy.Tokens.FormatterServicesMethods : object {
    public static MethodInfo GetObjectData;
    public static MethodInfo GetSerializableMembers;
    private static FormatterServicesMethods();
}
internal static class Castle.DynamicProxy.Tokens.InvocationMethods : object {
    public static ConstructorInfo CompositionInvocationConstructorNoSelector;
    public static ConstructorInfo CompositionInvocationConstructorWithSelector;
    public static MethodInfo EnsureValidTarget;
    public static MethodInfo GetArgumentValue;
    public static MethodInfo GetArguments;
    public static MethodInfo GetReturnValue;
    public static ConstructorInfo InheritanceInvocationConstructorNoSelector;
    public static ConstructorInfo InheritanceInvocationConstructorWithSelector;
    public static MethodInfo Proceed;
    public static FieldInfo ProxyObject;
    public static MethodInfo SetArgumentValue;
    public static MethodInfo SetGenericMethodArguments;
    public static MethodInfo SetReturnValue;
    public static FieldInfo Target;
    public static MethodInfo ThrowOnNoTarget;
    private static InvocationMethods();
}
internal static class Castle.DynamicProxy.Tokens.MethodBaseMethods : object {
    public static MethodInfo GetMethodFromHandle1;
    public static MethodInfo GetMethodFromHandle2;
    private static MethodBaseMethods();
}
internal static class Castle.DynamicProxy.Tokens.SerializationInfoMethods : object {
    public static MethodInfo AddValue_Bool;
    public static MethodInfo AddValue_Int32;
    public static MethodInfo AddValue_Object;
    public static MethodInfo GetValue;
    public static MethodInfo SetType;
    private static SerializationInfoMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeBuilderMethods : object {
    public static MethodInfo DefineProperty;
    private static TypeBuilderMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeMethods : object {
    public static MethodInfo GetTypeFromHandle;
    public static MethodInfo StaticGetType;
    private static TypeMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeUtilMethods : object {
    public static MethodInfo Sort;
    private static TypeUtilMethods();
}
public class Glimpse.Core.ClientScript.Client : object {
    public ScriptOrder Order { get; }
    public sealed virtual ScriptOrder get_Order();
    public sealed virtual string GetResourceName();
}
public class Glimpse.Core.ClientScript.Data : object {
    public ScriptOrder Order { get; }
    public sealed virtual ScriptOrder get_Order();
    public sealed virtual string GetResourceName();
    public sealed virtual void OverrideParameterValues(IDictionary`2<string, string> defaults);
}
public class Glimpse.Core.ClientScript.Metadata : object {
    public ScriptOrder Order { get; }
    public sealed virtual ScriptOrder get_Order();
    public sealed virtual string GetResourceName();
    public sealed virtual void OverrideParameterValues(IDictionary`2<string, string> defaults);
}
public class Glimpse.Core.Configuration.ContentTypeElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("contentType")]
public string ContentType { get; public set; }
    [ConfigurationPropertyAttribute("runtimePolicy")]
public RuntimePolicy RuntimePolicy { get; public set; }
    public string get_ContentType();
    public void set_ContentType(string value);
    public RuntimePolicy get_RuntimePolicy();
    public void set_RuntimePolicy(RuntimePolicy value);
}
[ConfigurationCollectionAttribute]
public class Glimpse.Core.Configuration.ContentTypeElementCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class Glimpse.Core.Configuration.DiscoverableCollectionElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("autoDiscover")]
public bool AutoDiscover { get; public set; }
    [ConfigurationPropertyAttribute("discoveryLocation")]
public string DiscoveryLocation { get; public set; }
    [ConfigurationPropertyAttribute("ignoredTypes")]
public TypeElementCollection IgnoredTypes { get; public set; }
    public bool get_AutoDiscover();
    public void set_AutoDiscover(bool value);
    public string get_DiscoveryLocation();
    public void set_DiscoveryLocation(string value);
    public TypeElementCollection get_IgnoredTypes();
    public void set_IgnoredTypes(TypeElementCollection value);
}
public class Glimpse.Core.Configuration.LoggingElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("level")]
public LoggingLevel Level { get; public set; }
    [ConfigurationPropertyAttribute("logLocation")]
public string LogLocation { get; public set; }
    public LoggingLevel get_Level();
    public void set_Level(LoggingLevel value);
    public string get_LogLocation();
    public void set_LogLocation(string value);
}
public enum Glimpse.Core.Configuration.LoggingLevel : Enum {
    public int value__;
    public static LoggingLevel Trace;
    public static LoggingLevel Debug;
    public static LoggingLevel Info;
    public static LoggingLevel Warn;
    public static LoggingLevel Error;
    public static LoggingLevel Fatal;
    public static LoggingLevel Off;
}
public class Glimpse.Core.Configuration.PolicyDiscoverableCollectionElement : DiscoverableCollectionElement {
    [ConfigurationPropertyAttribute("contentTypes")]
public ContentTypeElementCollection ContentTypes { get; public set; }
    [ConfigurationPropertyAttribute("statusCodes")]
public StatusCodeElementCollection StatusCodes { get; public set; }
    [ConfigurationPropertyAttribute("uris")]
public RegexElementCollection Uris { get; public set; }
    public ContentTypeElementCollection get_ContentTypes();
    public void set_ContentTypes(ContentTypeElementCollection value);
    public StatusCodeElementCollection get_StatusCodes();
    public void set_StatusCodes(StatusCodeElementCollection value);
    public RegexElementCollection get_Uris();
    public void set_Uris(RegexElementCollection value);
}
internal class Glimpse.Core.Configuration.RegexConverter : ConfigurationConverterBase {
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class Glimpse.Core.Configuration.RegexElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("regex")]
[TypeConverterAttribute("Glimpse.Core.Configuration.RegexConverter")]
public Regex Regex { get; public set; }
    public Regex get_Regex();
    public void set_Regex(Regex value);
}
[ConfigurationCollectionAttribute]
public class Glimpse.Core.Configuration.RegexElementCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class Glimpse.Core.Configuration.Section : ConfigurationSection {
    internal static string DefaultLocation;
    [ConfigurationPropertyAttribute("logging")]
public LoggingElement Logging { get; public set; }
    [ConfigurationPropertyAttribute("clientScripts")]
public DiscoverableCollectionElement ClientScripts { get; public set; }
    [ConfigurationPropertyAttribute("inspectors")]
public DiscoverableCollectionElement Inspectors { get; public set; }
    [ConfigurationPropertyAttribute("resources")]
public DiscoverableCollectionElement Resources { get; public set; }
    [ConfigurationPropertyAttribute("tabs")]
public DiscoverableCollectionElement Tabs { get; public set; }
    [ConfigurationPropertyAttribute("displays")]
public DiscoverableCollectionElement Displays { get; public set; }
    [ConfigurationPropertyAttribute("runtimePolicies")]
public PolicyDiscoverableCollectionElement RuntimePolicies { get; public set; }
    [ConfigurationPropertyAttribute("serializationConverters")]
public DiscoverableCollectionElement SerializationConverters { get; public set; }
    [ConfigurationPropertyAttribute("defaultRuntimePolicy")]
public RuntimePolicy DefaultRuntimePolicy { get; public set; }
    [TypeConverterAttribute("Glimpse.Core.Configuration.TypeConverter")]
[ConfigurationPropertyAttribute("serviceLocatorType")]
public Type ServiceLocatorType { get; public set; }
    [ConfigurationPropertyAttribute("endpointBaseUri")]
public string EndpointBaseUri { get; public set; }
    [ConfigurationPropertyAttribute("discoveryLocation")]
public string DiscoveryLocation { get; public set; }
    public LoggingElement get_Logging();
    public void set_Logging(LoggingElement value);
    public DiscoverableCollectionElement get_ClientScripts();
    public void set_ClientScripts(DiscoverableCollectionElement value);
    public DiscoverableCollectionElement get_Inspectors();
    public void set_Inspectors(DiscoverableCollectionElement value);
    public DiscoverableCollectionElement get_Resources();
    public void set_Resources(DiscoverableCollectionElement value);
    public DiscoverableCollectionElement get_Tabs();
    public void set_Tabs(DiscoverableCollectionElement value);
    public DiscoverableCollectionElement get_Displays();
    public void set_Displays(DiscoverableCollectionElement value);
    public PolicyDiscoverableCollectionElement get_RuntimePolicies();
    public void set_RuntimePolicies(PolicyDiscoverableCollectionElement value);
    public DiscoverableCollectionElement get_SerializationConverters();
    public void set_SerializationConverters(DiscoverableCollectionElement value);
    public RuntimePolicy get_DefaultRuntimePolicy();
    public void set_DefaultRuntimePolicy(RuntimePolicy value);
    public Type get_ServiceLocatorType();
    public void set_ServiceLocatorType(Type value);
    public string get_EndpointBaseUri();
    public void set_EndpointBaseUri(string value);
    public string get_DiscoveryLocation();
    public void set_DiscoveryLocation(string value);
}
public class Glimpse.Core.Configuration.StatusCodeElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("statusCode")]
public int StatusCode { get; public set; }
    public int get_StatusCode();
    public void set_StatusCode(int value);
}
[ConfigurationCollectionAttribute]
public class Glimpse.Core.Configuration.StatusCodeElementCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal class Glimpse.Core.Configuration.TypeConverter : ConfigurationConverterBase {
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class Glimpse.Core.Configuration.TypeElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("type")]
[TypeConverterAttribute("Glimpse.Core.Configuration.TypeConverter")]
public Type Type { get; public set; }
    public Type get_Type();
    public void set_Type(Type value);
}
[ConfigurationCollectionAttribute]
public class Glimpse.Core.Configuration.TypeElementCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal static class Glimpse.Core.Constants : object {
    internal static string TabStorageKey;
    internal static string ClientIdCookieName;
    internal static string GlobalStopwatchKey;
    internal static string GlobalTimerKey;
    internal static string HttpRequestHeader;
    internal static string HttpResponseHeader;
    internal static string RequestIdKey;
    internal static string RuntimePolicyKey;
    internal static string TabResultsDataStoreKey;
    internal static string DisplayResultsDataStoreKey;
    internal static string UserAgentHeaderName;
    internal static string ScriptsHaveRenderedKey;
    internal static string ClientScriptsStrategy;
}
[ObsoleteAttribute]
public class Glimpse.Core.Display.TimingsDisplay : object {
    private static string InternalName;
    [CompilerGeneratedAttribute]
private static Func`2<ITimelineMessage, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<ITimelineMessage, TimeSpan> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Name { get; }
    public string Key { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual object GetData(ITabContext context);
    public sealed virtual void Setup(ITabSetupContext context);
    [CompilerGeneratedAttribute]
private static bool <GetData>b__0(ITimelineMessage m);
    [CompilerGeneratedAttribute]
private static TimeSpan <GetData>b__1(ITimelineMessage m);
}
public abstract class Glimpse.Core.Extensibility.AlternateMethod : object {
    [CompilerGeneratedAttribute]
private MethodInfo <MethodToImplement>k__BackingField;
    public MethodInfo MethodToImplement { get; private set; }
    protected AlternateMethod(Type type, string methodName);
    protected AlternateMethod(Type type, string methodName, BindingFlags bindingFlags);
    protected AlternateMethod(MethodInfo methodToImplement);
    [CompilerGeneratedAttribute]
public sealed virtual MethodInfo get_MethodToImplement();
    [CompilerGeneratedAttribute]
private void set_MethodToImplement(MethodInfo value);
    public sealed virtual void NewImplementation(IAlternateMethodContext context);
    public abstract virtual void PostImplementation(IAlternateMethodContext context, TimerResult timerResult);
}
public abstract class Glimpse.Core.Extensibility.AlternateType`1 : object {
    [CompilerGeneratedAttribute]
private IProxyFactory <ProxyFactory>k__BackingField;
    public IProxyFactory ProxyFactory { get; public set; }
    public IEnumerable`1<IAlternateMethod> AllMethods { get; }
    protected AlternateType`1(IProxyFactory proxyFactory);
    [CompilerGeneratedAttribute]
public IProxyFactory get_ProxyFactory();
    [CompilerGeneratedAttribute]
public void set_ProxyFactory(IProxyFactory value);
    public abstract virtual IEnumerable`1<IAlternateMethod> get_AllMethods();
    public sealed virtual bool TryCreate(T originalObj, T& newObj);
    public bool TryCreate(T originalObj, T& newObj, IEnumerable`1<object> mixins);
    public virtual bool TryCreate(T originalObj, T& newObj, IEnumerable`1<object> mixins, Object[] constructorArguments);
}
public class Glimpse.Core.Extensibility.AlternateTypeGenerationHook`1 : object {
    private IEnumerable`1<MethodInfo> methodSet;
    private IEnumerable`1<IAlternateMethod> methodImplementations;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IAlternateMethod, MethodInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IAlternateMethod, MethodInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    internal IEnumerable`1<IAlternateMethod> MethodImplementations { get; internal set; }
    internal ILogger Logger { get; internal set; }
    public AlternateTypeGenerationHook`1(IEnumerable`1<IAlternateMethod> methodImplementations, ILogger logger);
    internal IEnumerable`1<IAlternateMethod> get_MethodImplementations();
    internal void set_MethodImplementations(IEnumerable`1<IAlternateMethod> value);
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(ILogger value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void MethodsInspected();
    public sealed virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public sealed virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
private static MethodInfo <set_MethodImplementations>b__0(IAlternateMethod m);
    [CompilerGeneratedAttribute]
private static MethodInfo <Equals>b__2(IAlternateMethod m);
}
public class Glimpse.Core.Extensibility.AlternateTypeSelector : object {
    public sealed virtual IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors);
}
public class Glimpse.Core.Extensibility.AlternateTypeToCastleInterceptorAdapter : object {
    [CompilerGeneratedAttribute]
private IAlternateMethod <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyFactory <ProxyFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<RuntimePolicy> <RuntimePolicyStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IExecutionTimer> <TimerStrategy>k__BackingField;
    public IAlternateMethod Implementation { get; public set; }
    public ILogger Logger { get; public set; }
    public IMessageBroker MessageBroker { get; public set; }
    public IProxyFactory ProxyFactory { get; public set; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; public set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; public set; }
    public MethodInfo MethodToImplement { get; }
    public AlternateTypeToCastleInterceptorAdapter(IAlternateMethod implementation, ILogger logger, IMessageBroker messageBroker, IProxyFactory proxyFactory, Func`1<IExecutionTimer> timerStrategy, Func`1<RuntimePolicy> runtimePolicyStrategy);
    [CompilerGeneratedAttribute]
public IAlternateMethod get_Implementation();
    [CompilerGeneratedAttribute]
public void set_Implementation(IAlternateMethod value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
public void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
public IProxyFactory get_ProxyFactory();
    [CompilerGeneratedAttribute]
public void set_ProxyFactory(IProxyFactory value);
    [CompilerGeneratedAttribute]
public Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    [CompilerGeneratedAttribute]
public void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
    [CompilerGeneratedAttribute]
public Func`1<IExecutionTimer> get_TimerStrategy();
    [CompilerGeneratedAttribute]
public void set_TimerStrategy(Func`1<IExecutionTimer> value);
    public MethodInfo get_MethodToImplement();
    public sealed virtual void Intercept(IInvocation invocation);
}
public class Glimpse.Core.Extensibility.AntiXssEncoder : object {
    public sealed virtual string HtmlAttributeEncode(string input);
}
public class Glimpse.Core.Extensibility.CastleInvocationToAlternateMethodContextAdapter : object {
    [CompilerGeneratedAttribute]
private IInvocation <Invocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyFactory <ProxyFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IExecutionTimer> <TimerStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<RuntimePolicy> <RuntimePolicyStrategy>k__BackingField;
    public IInvocation Invocation { get; public set; }
    public ILogger Logger { get; public set; }
    public object Proxy { get; }
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object ReturnValue { get; public set; }
    public IMessageBroker MessageBroker { get; private set; }
    public IProxyFactory ProxyFactory { get; private set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; private set; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; private set; }
    public CastleInvocationToAlternateMethodContextAdapter(IInvocation invocation, ILogger logger, IMessageBroker messageBroker, IProxyFactory proxyFactory, Func`1<IExecutionTimer> timerStrategy, Func`1<RuntimePolicy> runtimePolicyStrategy);
    [CompilerGeneratedAttribute]
public IInvocation get_Invocation();
    [CompilerGeneratedAttribute]
public void set_Invocation(IInvocation value);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    public sealed virtual object get_Proxy();
    public sealed virtual object get_InvocationTarget();
    public sealed virtual Type get_TargetType();
    public sealed virtual Object[] get_Arguments();
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual object get_ReturnValue();
    public sealed virtual void set_ReturnValue(object value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
private void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
public sealed virtual IProxyFactory get_ProxyFactory();
    [CompilerGeneratedAttribute]
private void set_ProxyFactory(IProxyFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<IExecutionTimer> get_TimerStrategy();
    [CompilerGeneratedAttribute]
private void set_TimerStrategy(Func`1<IExecutionTimer> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    [CompilerGeneratedAttribute]
private void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    public sealed virtual void Proceed();
}
public class Glimpse.Core.Extensibility.DictionaryDataStoreAdapter : object {
    [CompilerGeneratedAttribute]
private IDictionary <Dictionary>k__BackingField;
    internal IDictionary Dictionary { get; internal set; }
    public DictionaryDataStoreAdapter(IDictionary dictionary);
    [CompilerGeneratedAttribute]
internal IDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
internal void set_Dictionary(IDictionary value);
    public sealed virtual object Get(string key);
    public sealed virtual void Set(string key, object value);
    public sealed virtual bool Contains(string key);
    private static bool IsValidDictionaryType(IDictionary dictionary);
}
public class Glimpse.Core.Extensibility.ExecutionTimer : object {
    [CompilerGeneratedAttribute]
private DateTime <RequestStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    public DateTime RequestStart { get; private set; }
    internal Stopwatch Stopwatch { get; internal set; }
    public ExecutionTimer(Stopwatch stopwatch);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_RequestStart();
    [CompilerGeneratedAttribute]
private void set_RequestStart(DateTime value);
    [CompilerGeneratedAttribute]
internal Stopwatch get_Stopwatch();
    [CompilerGeneratedAttribute]
internal void set_Stopwatch(Stopwatch value);
    public sealed virtual TimerResult Point();
    public sealed virtual TimerResult`1<T> Time(Func`1<T> function);
    public sealed virtual TimerResult Time(Action action);
    public sealed virtual TimeSpan Start();
    public sealed virtual TimerResult Stop(TimeSpan offset);
}
public interface Glimpse.Core.Extensibility.IAlternateMethod {
    public MethodInfo MethodToImplement { get; }
    public abstract virtual MethodInfo get_MethodToImplement();
    public abstract virtual void NewImplementation(IAlternateMethodContext context);
}
public interface Glimpse.Core.Extensibility.IAlternateMethodContext {
    public object Proxy { get; }
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object ReturnValue { get; public set; }
    public IMessageBroker MessageBroker { get; }
    public IProxyFactory ProxyFactory { get; }
    public Func`1<IExecutionTimer> TimerStrategy { get; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; }
    public abstract virtual object get_Proxy();
    public abstract virtual object get_InvocationTarget();
    public abstract virtual Type get_TargetType();
    public abstract virtual Object[] get_Arguments();
    public abstract virtual Type[] get_GenericArguments();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual IMessageBroker get_MessageBroker();
    public abstract virtual IProxyFactory get_ProxyFactory();
    public abstract virtual Func`1<IExecutionTimer> get_TimerStrategy();
    public abstract virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    public abstract virtual void SetArgumentValue(int index, object value);
    public abstract virtual object GetArgumentValue(int index);
    public abstract virtual MethodInfo GetConcreteMethod();
    public abstract virtual MethodInfo GetConcreteMethodInvocationTarget();
    public abstract virtual void Proceed();
}
public interface Glimpse.Core.Extensibility.IAlternateType`1 {
    public abstract virtual bool TryCreate(T originalObj, T& newObj);
}
public interface Glimpse.Core.Extensibility.IClientScript {
    public ScriptOrder Order { get; }
    public abstract virtual ScriptOrder get_Order();
}
public interface Glimpse.Core.Extensibility.IConfigurable {
    public abstract virtual void Configure(Section section);
}
public interface Glimpse.Core.Extensibility.IContext {
    public ILogger Logger { get; }
    public abstract virtual ILogger get_Logger();
}
public interface Glimpse.Core.Extensibility.IDataStore {
    public abstract virtual object Get(string key);
    public abstract virtual void Set(string key, object value);
    public abstract virtual bool Contains(string key);
}
internal interface Glimpse.Core.Extensibility.IDependOnResources {
    public abstract virtual bool DependsOn(string resourceName);
}
[ObsoleteAttribute]
public interface Glimpse.Core.Extensibility.IDisplay {
    [ObsoleteAttribute]
public string Name { get; }
    public abstract virtual string get_Name();
    [ObsoleteAttribute]
public abstract virtual object GetData(ITabContext context);
}
public interface Glimpse.Core.Extensibility.IDocumentation {
    public string DocumentationUri { get; }
    public abstract virtual string get_DocumentationUri();
}
public interface Glimpse.Core.Extensibility.IDynamicClientScript {
    public abstract virtual string GetResourceName();
}
public interface Glimpse.Core.Extensibility.IExecutionTimer {
    public DateTime RequestStart { get; }
    public abstract virtual DateTime get_RequestStart();
    public abstract virtual TimerResult Point();
    public abstract virtual TimerResult`1<T> Time(Func`1<T> function);
    public abstract virtual TimerResult Time(Action action);
    public abstract virtual TimeSpan Start();
    public abstract virtual TimerResult Stop(TimeSpan offset);
}
public interface Glimpse.Core.Extensibility.IHtmlEncoder {
    public abstract virtual string HtmlAttributeEncode(string input);
}
public interface Glimpse.Core.Extensibility.IInspector {
    public abstract virtual void Setup(IInspectorContext context);
}
public interface Glimpse.Core.Extensibility.IInspectorContext {
    public IProxyFactory ProxyFactory { get; }
    public Func`1<IExecutionTimer> TimerStrategy { get; }
    public IMessageBroker MessageBroker { get; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; }
    public abstract virtual IProxyFactory get_ProxyFactory();
    public abstract virtual Func`1<IExecutionTimer> get_TimerStrategy();
    public abstract virtual IMessageBroker get_MessageBroker();
    public abstract virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
}
public interface Glimpse.Core.Extensibility.IKey {
    public string Key { get; }
    public abstract virtual string get_Key();
}
public interface Glimpse.Core.Extensibility.ILayoutControl {
    public bool KeysHeadings { get; }
    public abstract virtual bool get_KeysHeadings();
}
public interface Glimpse.Core.Extensibility.ILogger {
    public abstract virtual void Trace(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Warn(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Trace(string message, Exception exception);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void Fatal(string message, Exception exception);
    public abstract virtual void Trace(string messageFormat, Object[] args);
    public abstract virtual void Debug(string messageFormat, Object[] args);
    public abstract virtual void Info(string messageFormat, Object[] args);
    public abstract virtual void Warn(string messageFormat, Object[] args);
    public abstract virtual void Error(string messageFormat, Object[] args);
    public abstract virtual void Fatal(string messageFormat, Object[] args);
    public abstract virtual void Trace(string messageFormat, Exception exception, Object[] args);
    public abstract virtual void Debug(string messageFormat, Exception exception, Object[] args);
    public abstract virtual void Info(string messageFormat, Exception exception, Object[] args);
    public abstract virtual void Warn(string messageFormat, Exception exception, Object[] args);
    public abstract virtual void Error(string messageFormat, Exception exception, Object[] args);
    public abstract virtual void Fatal(string messageFormat, Exception exception, Object[] args);
}
public interface Glimpse.Core.Extensibility.IMessageBroker {
    public abstract virtual void Publish(T message);
    public abstract virtual Guid Subscribe(Action`1<T> action);
    public abstract virtual void Unsubscribe(Guid subscriptionId);
}
public class Glimpse.Core.Extensibility.InspectorContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyFactory <ProxyFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IExecutionTimer> <TimerStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<RuntimePolicy> <RuntimePolicyStrategy>k__BackingField;
    public ILogger Logger { get; public set; }
    public IProxyFactory ProxyFactory { get; public set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; public set; }
    public IMessageBroker MessageBroker { get; public set; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; public set; }
    public InspectorContext(ILogger logger, IProxyFactory proxyFactory, IMessageBroker messageBroker, Func`1<IExecutionTimer> timerStrategy, Func`1<RuntimePolicy> runtimePolicyStrategy);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual IProxyFactory get_ProxyFactory();
    [CompilerGeneratedAttribute]
public void set_ProxyFactory(IProxyFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<IExecutionTimer> get_TimerStrategy();
    [CompilerGeneratedAttribute]
public void set_TimerStrategy(Func`1<IExecutionTimer> value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
public void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    [CompilerGeneratedAttribute]
public void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
}
public interface Glimpse.Core.Extensibility.IParameterValueProvider {
    public abstract virtual void OverrideParameterValues(IDictionary`2<string, string> defaults);
}
internal interface Glimpse.Core.Extensibility.IPrivilegedResource {
    public abstract virtual IResourceResult Execute(IResourceContext context, IGlimpseConfiguration configuration);
}
public interface Glimpse.Core.Extensibility.IProxyFactory {
    public abstract virtual bool IsWrapInterfaceEligible(Type type);
    public abstract virtual T WrapInterface(T instance, IEnumerable`1<IAlternateMethod> methodImplementations);
    public abstract virtual T WrapInterface(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public abstract virtual bool IsWrapClassEligible(Type type);
    public abstract virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations);
    public abstract virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public abstract virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins, IEnumerable`1<object> constructorArguments);
    public abstract virtual bool IsExtendClassEligible(Type type);
    public abstract virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations);
    public abstract virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public abstract virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins, IEnumerable`1<object> constructorArguments);
}
public interface Glimpse.Core.Extensibility.IResource {
    public string Name { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public abstract virtual IResourceResult Execute(IResourceContext context);
}
public interface Glimpse.Core.Extensibility.IResourceContext {
    public IDictionary`2<string, string> Parameters { get; }
    public IReadOnlyPersistenceStore PersistenceStore { get; }
    public abstract virtual IDictionary`2<string, string> get_Parameters();
    public abstract virtual IReadOnlyPersistenceStore get_PersistenceStore();
}
public interface Glimpse.Core.Extensibility.IResourceResult {
    public abstract virtual void Execute(IResourceResultContext context);
}
public interface Glimpse.Core.Extensibility.IResourceResultContext {
    public IFrameworkProvider FrameworkProvider { get; }
    public ISerializer Serializer { get; }
    public IHtmlEncoder HtmlEncoder { get; }
    public abstract virtual IFrameworkProvider get_FrameworkProvider();
    public abstract virtual ISerializer get_Serializer();
    public abstract virtual IHtmlEncoder get_HtmlEncoder();
}
public interface Glimpse.Core.Extensibility.IRuntimePolicy {
    public RuntimeEvent ExecuteOn { get; }
    public abstract virtual RuntimeEvent get_ExecuteOn();
    public abstract virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
}
public interface Glimpse.Core.Extensibility.IRuntimePolicyContext {
    public IRequestMetadata RequestMetadata { get; }
    public abstract virtual IRequestMetadata get_RequestMetadata();
    public abstract virtual T GetRequestContext();
}
public interface Glimpse.Core.Extensibility.ISerializationConverter {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_SupportedTypes();
    public abstract virtual object Convert(object target);
}
public interface Glimpse.Core.Extensibility.ISerializer {
    public abstract virtual string Serialize(object target);
    public abstract virtual void RegisterSerializationConverters(IEnumerable`1<ISerializationConverter> converters);
}
public interface Glimpse.Core.Extensibility.IStaticClientScript {
    public abstract virtual string GetUri(string version);
}
public interface Glimpse.Core.Extensibility.ITab {
    public string Name { get; }
    public RuntimeEvent ExecuteOn { get; }
    public Type RequestContextType { get; }
    public abstract virtual string get_Name();
    public abstract virtual RuntimeEvent get_ExecuteOn();
    public abstract virtual Type get_RequestContextType();
    public abstract virtual object GetData(ITabContext context);
}
public interface Glimpse.Core.Extensibility.ITabContext {
    public IDataStore TabStore { get; }
    public IMessageBroker MessageBroker { get; }
    public abstract virtual IDataStore get_TabStore();
    public abstract virtual IMessageBroker get_MessageBroker();
    public abstract virtual T GetRequestContext();
}
public interface Glimpse.Core.Extensibility.ITabLayout {
    public abstract virtual object GetLayout();
}
public interface Glimpse.Core.Extensibility.ITabSetup {
    public abstract virtual void Setup(ITabSetupContext context);
}
public interface Glimpse.Core.Extensibility.ITabSetupContext {
    public IMessageBroker MessageBroker { get; }
    public abstract virtual IMessageBroker get_MessageBroker();
    public abstract virtual IDataStore GetTabStore();
}
public interface Glimpse.Core.Extensibility.IWrapper`1 {
    public abstract virtual T GetWrappedObject();
}
public class Glimpse.Core.Extensibility.JsonNetConverterDictionaryKeysAreNotPropertyNames : JsonConverter {
    public bool CanRead { get; }
    public virtual bool get_CanRead();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Glimpse.Core.Extensibility.JsonNetSerializationConverterAdapter : JsonConverter {
    [CompilerGeneratedAttribute]
private ISerializationConverter <Converter>k__BackingField;
    private ISerializationConverter Converter { get; private set; }
    public JsonNetSerializationConverterAdapter(ISerializationConverter converter);
    [CompilerGeneratedAttribute]
private ISerializationConverter get_Converter();
    [CompilerGeneratedAttribute]
private void set_Converter(ISerializationConverter value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Glimpse.Core.Extensibility.JsonNetSerializer : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <Settings>k__BackingField;
    private ILogger Logger { get; private set; }
    private JsonSerializerSettings Settings { get; private set; }
    public JsonNetSerializer(ILogger logger);
    [CompilerGeneratedAttribute]
private ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
private JsonSerializerSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(JsonSerializerSettings value);
    public sealed virtual string Serialize(object target);
    public sealed virtual void RegisterSerializationConverters(IEnumerable`1<ISerializationConverter> converters);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1(object obj, ErrorEventArgs args);
}
public abstract class Glimpse.Core.Extensibility.LoggerBase : object {
    public abstract virtual void Trace(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Warn(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Trace(string message, Exception exception);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void Fatal(string message, Exception exception);
    public sealed virtual void Trace(string messageFormat, Object[] args);
    public sealed virtual void Debug(string messageFormat, Object[] args);
    public sealed virtual void Info(string messageFormat, Object[] args);
    public sealed virtual void Warn(string messageFormat, Object[] args);
    public sealed virtual void Error(string messageFormat, Object[] args);
    public sealed virtual void Fatal(string messageFormat, Object[] args);
    public sealed virtual void Trace(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Debug(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Info(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Warn(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Error(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Fatal(string messageFormat, Exception exception, Object[] args);
}
public class Glimpse.Core.Extensibility.MessageBroker : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Type, List`1<Subscriber>> <Subscriptions>k__BackingField;
    public ILogger Logger { get; public set; }
    internal IDictionary`2<Type, List`1<Subscriber>> Subscriptions { get; internal set; }
    public MessageBroker(ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<Type, List`1<Subscriber>> get_Subscriptions();
    [CompilerGeneratedAttribute]
internal void set_Subscriptions(IDictionary`2<Type, List`1<Subscriber>> value);
    public sealed virtual void Publish(T message);
    public sealed virtual Guid Subscribe(Action`1<T> action);
    public sealed virtual void Unsubscribe(Guid subscriptionId);
    private List`1<Subscriber> GetSubscriptions(Type type);
}
public class Glimpse.Core.Extensibility.NLogLogger : LoggerBase {
    [CompilerGeneratedAttribute]
private Logger <Logger>k__BackingField;
    private Logger Logger { get; private set; }
    public NLogLogger(Logger logger);
    [CompilerGeneratedAttribute]
private Logger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(Logger value);
    public virtual void Trace(string message);
    public virtual void Debug(string message);
    public virtual void Info(string message);
    public virtual void Warn(string message);
    public virtual void Error(string message);
    public virtual void Fatal(string message);
    public virtual void Trace(string message, Exception exception);
    public virtual void Debug(string message, Exception exception);
    public virtual void Info(string message, Exception exception);
    public virtual void Warn(string message, Exception exception);
    public virtual void Error(string message, Exception exception);
    public virtual void Fatal(string message, Exception exception);
}
[AttributeUsageAttribute("1")]
public class Glimpse.Core.Extensibility.NuGetPackageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    private string Id { get; private set; }
    private string Version { get; private set; }
    private string AssemblyName { get; private set; }
    public NuGetPackageAttribute(string id);
    public NuGetPackageAttribute(string id, string version);
    [CompilerGeneratedAttribute]
private string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
private string get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(string value);
    [CompilerGeneratedAttribute]
private string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    public void Initialize(Assembly assembly);
    public string GetId();
    public string GetVersion();
    public string GetAssemblyName();
}
public class Glimpse.Core.Extensibility.NullLogger : object {
    public sealed virtual void Trace(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Warn(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Trace(string message, Exception exception);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void Trace(string messageFormat, Object[] args);
    public sealed virtual void Debug(string messageFormat, Object[] args);
    public sealed virtual void Info(string messageFormat, Object[] args);
    public sealed virtual void Warn(string messageFormat, Object[] args);
    public sealed virtual void Error(string messageFormat, Object[] args);
    public sealed virtual void Fatal(string messageFormat, Object[] args);
    public sealed virtual void Trace(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Debug(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Info(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Warn(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Error(string messageFormat, Exception exception, Object[] args);
    public sealed virtual void Fatal(string messageFormat, Exception exception, Object[] args);
}
public class Glimpse.Core.Extensibility.ResourceContext : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyPersistenceStore <PersistenceStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public IDictionary`2<string, string> Parameters { get; public set; }
    public IReadOnlyPersistenceStore PersistenceStore { get; public set; }
    public ILogger Logger { get; public set; }
    public ResourceContext(IDictionary`2<string, string> parameters, IReadOnlyPersistenceStore persistenceStore, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyPersistenceStore get_PersistenceStore();
    [CompilerGeneratedAttribute]
public void set_PersistenceStore(IReadOnlyPersistenceStore value);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
}
public static class Glimpse.Core.Extensibility.ResourceParameter : object {
    public static ResourceParameterMetadata RequestId;
    public static ResourceParameterMetadata VersionNumber;
    public static ResourceParameterMetadata Callback;
    public static ResourceParameterMetadata Timestamp;
    public static ResourceParameterMetadata Hash;
    public static ResourceParameterMetadata LogoName;
    private static ResourceParameter();
}
public class Glimpse.Core.Extensibility.ResourceParameterMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public string Name { get; public set; }
    public bool IsRequired { get; public set; }
    public ResourceParameterMetadata(string name, bool isRequired);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
}
public class Glimpse.Core.Extensibility.ResourceResultContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IHtmlEncoder <HtmlEncoder>k__BackingField;
    public ILogger Logger { get; public set; }
    public IFrameworkProvider FrameworkProvider { get; public set; }
    public ISerializer Serializer { get; public set; }
    public IHtmlEncoder HtmlEncoder { get; public set; }
    public ResourceResultContext(ILogger logger, IFrameworkProvider frameworkProvider, ISerializer serializer, IHtmlEncoder htmlEncoder);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual IFrameworkProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
public void set_FrameworkProvider(IFrameworkProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public void set_Serializer(ISerializer value);
    [CompilerGeneratedAttribute]
public sealed virtual IHtmlEncoder get_HtmlEncoder();
    [CompilerGeneratedAttribute]
public void set_HtmlEncoder(IHtmlEncoder value);
}
public abstract class Glimpse.Core.Extensibility.ResourceResultDecorator : object {
    [CompilerGeneratedAttribute]
private IResourceResult <WrappedResourceResult>k__BackingField;
    protected IResourceResult WrappedResourceResult { get; protected set; }
    protected ResourceResultDecorator(IResourceResult wrappedResourceResult);
    [CompilerGeneratedAttribute]
protected IResourceResult get_WrappedResourceResult();
    [CompilerGeneratedAttribute]
protected void set_WrappedResourceResult(IResourceResult value);
    public sealed virtual IResourceResult GetWrappedObject();
    public sealed virtual void Execute(IResourceResultContext context);
    protected abstract virtual void Decorate(IResourceResultContext context);
}
[FlagsAttribute]
public enum Glimpse.Core.Extensibility.RuntimeEvent : Enum {
    public int value__;
    public static RuntimeEvent Initialize;
    public static RuntimeEvent BeginRequest;
    public static RuntimeEvent BeginSessionAccess;
    public static RuntimeEvent ExecuteResource;
    public static RuntimeEvent EndSessionAccess;
    public static RuntimeEvent EndRequest;
}
[FlagsAttribute]
public enum Glimpse.Core.Extensibility.RuntimePolicy : Enum {
    public int value__;
    public static RuntimePolicy Off;
    public static RuntimePolicy ExecuteResourceOnly;
    public static RuntimePolicy PersistResults;
    public static RuntimePolicy ModifyResponseHeaders;
    public static RuntimePolicy ModifyResponseBody;
    public static RuntimePolicy DisplayGlimpseClient;
    public static RuntimePolicy On;
}
public class Glimpse.Core.Extensibility.RuntimePolicyContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestMetadata <RequestMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RequestContext>k__BackingField;
    public ILogger Logger { get; public set; }
    public IRequestMetadata RequestMetadata { get; public set; }
    private object RequestContext { get; private set; }
    public RuntimePolicyContext(IRequestMetadata requestMetadata, ILogger logger, object requestContext);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestMetadata get_RequestMetadata();
    [CompilerGeneratedAttribute]
public void set_RequestMetadata(IRequestMetadata value);
    [CompilerGeneratedAttribute]
private object get_RequestContext();
    [CompilerGeneratedAttribute]
private void set_RequestContext(object value);
    public sealed virtual T GetRequestContext();
}
public enum Glimpse.Core.Extensibility.ScriptOrder : Enum {
    public int value__;
    public static ScriptOrder IncludeBeforeClientInterfaceScript;
    public static ScriptOrder ClientInterfaceScript;
    public static ScriptOrder IncludeAfterClientInterfaceScript;
    public static ScriptOrder RequestMetadataScript;
    public static ScriptOrder IncludeBeforeRequestDataScript;
    public static ScriptOrder RequestDataScript;
    public static ScriptOrder IncludeAfterRequestDataScript;
}
public abstract class Glimpse.Core.Extensibility.SerializationConverter`1 : object {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public sealed virtual IEnumerable`1<Type> get_SupportedTypes();
    public sealed virtual object Convert(object obj);
    public abstract virtual object Convert(T obj);
}
internal abstract class Glimpse.Core.Extensibility.Subscriber : object {
    [CompilerGeneratedAttribute]
private Guid <SubscriptionId>k__BackingField;
    public Guid SubscriptionId { get; public set; }
    protected Subscriber(Guid subscriptionId);
    [CompilerGeneratedAttribute]
public Guid get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(Guid value);
    public abstract virtual void Execute(object message);
}
internal class Glimpse.Core.Extensibility.Subscriber`1 : Subscriber {
    [CompilerGeneratedAttribute]
private Action`1<T> <Action>k__BackingField;
    private Action`1<T> Action { get; private set; }
    public Subscriber`1(Action`1<T> action, Guid subscriptionId);
    [CompilerGeneratedAttribute]
private Action`1<T> get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(Action`1<T> value);
    public virtual void Execute(object message);
}
public abstract class Glimpse.Core.Extensibility.TabBase : object {
    public string Name { get; }
    public RuntimeEvent ExecuteOn { get; }
    public Type RequestContextType { get; }
    public abstract virtual string get_Name();
    public virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual Type get_RequestContextType();
    public abstract virtual object GetData(ITabContext context);
}
public abstract class Glimpse.Core.Extensibility.TabBase`1 : object {
    public string Name { get; }
    public RuntimeEvent ExecuteOn { get; }
    public Type RequestContextType { get; }
    public abstract virtual string get_Name();
    public virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual Type get_RequestContextType();
    public abstract virtual object GetData(ITabContext context);
}
public class Glimpse.Core.Extensibility.TabContext : object {
    [CompilerGeneratedAttribute]
private IDataStore <TabStore>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RequestContext>k__BackingField;
    public IDataStore TabStore { get; private set; }
    public IMessageBroker MessageBroker { get; public set; }
    public ILogger Logger { get; public set; }
    private object RequestContext { get; private set; }
    public TabContext(object requestContext, IDataStore tabStore, ILogger logger, IMessageBroker messageBroker);
    [CompilerGeneratedAttribute]
public sealed virtual IDataStore get_TabStore();
    [CompilerGeneratedAttribute]
private void set_TabStore(IDataStore value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
public void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
private object get_RequestContext();
    [CompilerGeneratedAttribute]
private void set_RequestContext(object value);
    public sealed virtual T GetRequestContext();
}
public class Glimpse.Core.Extensibility.TabSetupContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IDataStore> <TabStoreStrategy>k__BackingField;
    public ILogger Logger { get; public set; }
    public IMessageBroker MessageBroker { get; public set; }
    private Func`1<IDataStore> TabStoreStrategy { get; private set; }
    public TabSetupContext(ILogger logger, IMessageBroker messageBroker, Func`1<IDataStore> tabStoreStrategy);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
public void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
private Func`1<IDataStore> get_TabStoreStrategy();
    [CompilerGeneratedAttribute]
private void set_TabStoreStrategy(Func`1<IDataStore> value);
    public sealed virtual IDataStore GetTabStore();
}
public class Glimpse.Core.Extensibility.TimerResult : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    public TimeSpan Offset { get; public set; }
    public TimeSpan Duration { get; public set; }
    public DateTime StartTime { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
}
public class Glimpse.Core.Extensibility.TimerResult`1 : TimerResult {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public T Result { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(T value);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.AlternateMethodContextExtensions : object {
    [ExtensionAttribute]
public static bool TryProceedWithTimer(IAlternateMethodContext context, TimerResult& timerResult);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.DataStoreExtensions : object {
    [ExtensionAttribute]
public static T Get(IDataStore store);
    [ExtensionAttribute]
public static T Get(IDataStore store, string key);
    [ExtensionAttribute]
public static void Set(IDataStore store, T value);
    [ExtensionAttribute]
public static bool Contains(IDataStore store);
    private static string KeyOf();
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue ifNotFound);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.EnumExtensions : object {
    [ExtensionAttribute]
public static string ToDescription(Enum enumeration);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.NameValueCollectionExtension : object {
    [ExtensionAttribute]
public static IDictionary`2<string, string> ToDictionary(NameValueCollection input);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static string ToStringOrDefault(object value);
    [ExtensionAttribute]
public static Type GetTypeOrNull(object value);
    [ExtensionAttribute]
public static T CastOrDefault(object value);
}
[ExtensionAttribute]
public static class Glimpse.Core.Extensions.TabContextExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> GetMessages(ITabContext context);
    [ExtensionAttribute]
public static void PersistMessages(ITabSetupContext context);
    private static void PersistMessage(T message, ITabSetupContext context);
}
public class Glimpse.Core.Framework.ApplicationPersistenceStore : object {
    private static string PersistenceStoreKey;
    private static int BufferSize;
    private object queueLock;
    [CompilerGeneratedAttribute]
private Queue`1<GlimpseRequest> <GlimpseRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataStore <DataStore>k__BackingField;
    [CompilerGeneratedAttribute]
private GlimpseMetadata <Metadata>k__BackingField;
    internal Queue`1<GlimpseRequest> GlimpseRequests { get; internal set; }
    private IDataStore DataStore { get; private set; }
    private GlimpseMetadata Metadata { get; private set; }
    public ApplicationPersistenceStore(IDataStore dataStore);
    [CompilerGeneratedAttribute]
internal Queue`1<GlimpseRequest> get_GlimpseRequests();
    [CompilerGeneratedAttribute]
internal void set_GlimpseRequests(Queue`1<GlimpseRequest> value);
    [CompilerGeneratedAttribute]
private IDataStore get_DataStore();
    [CompilerGeneratedAttribute]
private void set_DataStore(IDataStore value);
    [CompilerGeneratedAttribute]
private GlimpseMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(GlimpseMetadata value);
    public sealed virtual void Save(GlimpseRequest request);
    public sealed virtual void Save(GlimpseMetadata metadata);
    public sealed virtual GlimpseRequest GetByRequestId(Guid requestId);
    public sealed virtual TabResult GetByRequestIdAndTabKey(Guid requestId, string tabKey);
    public sealed virtual IEnumerable`1<GlimpseRequest> GetByRequestParentId(Guid parentRequestId);
    public sealed virtual IEnumerable`1<GlimpseRequest> GetTop(int count);
    public sealed virtual GlimpseMetadata GetMetadata();
}
public static class Glimpse.Core.Framework.AssemblyTypesResolver : object {
    private static Dictionary`2<Assembly, Type[]> typesByAssembly;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    private static AssemblyTypesResolver();
    public static Type[] ResolveTypes(Assembly assembly, ILogger logger);
    [CompilerGeneratedAttribute]
private static bool <ResolveTypes>b__1(Type t);
}
public enum Glimpse.Core.Framework.CacheSetting : Enum {
    public int value__;
    [DescriptionAttribute("public")]
public static CacheSetting Public;
    [DescriptionAttribute("private")]
public static CacheSetting Private;
    [DescriptionAttribute("no-cache")]
public static CacheSetting NoCache;
    [DescriptionAttribute("no-store")]
public static CacheSetting NoStore;
}
public class Glimpse.Core.Framework.CastleDynamicProxyFactory : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyGenerator <ProxyGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<RuntimePolicy> <RuntimePolicyStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IExecutionTimer> <TimerStrategy>k__BackingField;
    public ILogger Logger { get; public set; }
    public ProxyGenerator ProxyGenerator { get; public set; }
    public IMessageBroker MessageBroker { get; public set; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; public set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; public set; }
    public CastleDynamicProxyFactory(ILogger logger, IMessageBroker messageBroker, Func`1<IExecutionTimer> timerStrategy, Func`1<RuntimePolicy> runtimePolicyStrategy);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public ProxyGenerator get_ProxyGenerator();
    [CompilerGeneratedAttribute]
public void set_ProxyGenerator(ProxyGenerator value);
    [CompilerGeneratedAttribute]
public IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
public void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
public Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    [CompilerGeneratedAttribute]
public void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
    [CompilerGeneratedAttribute]
public Func`1<IExecutionTimer> get_TimerStrategy();
    [CompilerGeneratedAttribute]
public void set_TimerStrategy(Func`1<IExecutionTimer> value);
    public sealed virtual bool IsWrapInterfaceEligible(Type type);
    public sealed virtual T WrapInterface(T instance, IEnumerable`1<IAlternateMethod> methodImplementations);
    public sealed virtual T WrapInterface(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public sealed virtual bool IsWrapClassEligible(Type type);
    public sealed virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations);
    public sealed virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public sealed virtual T WrapClass(T instance, IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins, IEnumerable`1<object> constructorArguments);
    public sealed virtual bool IsExtendClassEligible(Type type);
    public sealed virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations);
    public sealed virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    public sealed virtual T ExtendClass(IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins, IEnumerable`1<object> constructorArguments);
    private static TSource[] ToArrayOrDefault(IEnumerable`1<TSource> source);
    private void CheckInput(IEnumerable`1<IAlternateMethod> methodImplementations);
    private void CheckInput(object instance, IEnumerable`1<IAlternateMethod> methodImplementations);
    private bool IsGenerallyEligable(Type type);
    private ProxyGenerationOptions CreateProxyOptions(IEnumerable`1<IAlternateMethod> methodImplementations, IEnumerable`1<object> mixins);
    private IInterceptor[] CreateInterceptorArray(IEnumerable`1<IAlternateMethod> methodImplementations);
    [CompilerGeneratedAttribute]
private AlternateTypeToCastleInterceptorAdapter <CreateInterceptorArray>b__1(IAlternateMethod implementaion);
}
internal class Glimpse.Core.Framework.CastleDynamicProxyWrapper`1 : object {
    [CompilerGeneratedAttribute]
private IProxyTargetAccessor <ProxyTargetAccessor>k__BackingField;
    internal IProxyTargetAccessor ProxyTargetAccessor { get; internal set; }
    [CompilerGeneratedAttribute]
internal IProxyTargetAccessor get_ProxyTargetAccessor();
    [CompilerGeneratedAttribute]
internal void set_ProxyTargetAccessor(IProxyTargetAccessor value);
    public sealed virtual T GetWrappedObject();
}
internal class Glimpse.Core.Framework.Crc32 : HashAlgorithm {
    public static UInt32 DefaultPolynomial;
    public static UInt32 DefaultSeed;
    private static UInt32[] defaultTable;
    private UInt32 hash;
    private UInt32 seed;
    private UInt32[] table;
    public int HashSize { get; }
    public Crc32(UInt32 polynomial, UInt32 seed);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] buffer, int start, int length);
    protected virtual Byte[] HashFinal();
    public virtual int get_HashSize();
    public static UInt32 Compute(Byte[] buffer);
    public static UInt32 Compute(UInt32 seed, Byte[] buffer);
    public static UInt32 Compute(UInt32 polynomial, UInt32 seed, Byte[] buffer);
    private static UInt32[] InitializeTable(UInt32 polynomial);
    private static UInt32 CalculateHash(UInt32[] table, UInt32 seed, Byte[] buffer, int start, int size);
    private Byte[] UInt32ToBigEndianBytes(UInt32 x);
}
public class Glimpse.Core.Framework.Factory : object {
    [CompilerGeneratedAttribute]
private IServiceLocator <UserServiceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceLocator <ProviderServiceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Section <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBroker <MessageBroker>k__BackingField;
    internal IServiceLocator UserServiceLocator { get; internal set; }
    internal IServiceLocator ProviderServiceLocator { get; internal set; }
    internal Section Configuration { get; internal set; }
    private ILogger Logger { get; private set; }
    private IFrameworkProvider FrameworkProvider { get; private set; }
    private IMessageBroker MessageBroker { get; private set; }
    public Factory(IServiceLocator providerServiceLocator);
    public Factory(IServiceLocator providerServiceLocator, IServiceLocator userServiceLocator);
    public Factory(IServiceLocator providerServiceLocator, IServiceLocator userServiceLocator, Section configuration);
    [CompilerGeneratedAttribute]
internal IServiceLocator get_UserServiceLocator();
    [CompilerGeneratedAttribute]
internal void set_UserServiceLocator(IServiceLocator value);
    [CompilerGeneratedAttribute]
internal IServiceLocator get_ProviderServiceLocator();
    [CompilerGeneratedAttribute]
internal void set_ProviderServiceLocator(IServiceLocator value);
    [CompilerGeneratedAttribute]
internal Section get_Configuration();
    [CompilerGeneratedAttribute]
internal void set_Configuration(Section value);
    [CompilerGeneratedAttribute]
private ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
private IFrameworkProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
private void set_FrameworkProvider(IFrameworkProvider value);
    [CompilerGeneratedAttribute]
private IMessageBroker get_MessageBroker();
    [CompilerGeneratedAttribute]
private void set_MessageBroker(IMessageBroker value);
    public IGlimpseRuntime InstantiateRuntime();
    public IFrameworkProvider InstantiateFrameworkProvider();
    public ResourceEndpointConfiguration InstantiateResourceEndpointConfiguration();
    public ICollection`1<IClientScript> InstantiateClientScripts();
    public ILogger InstantiateLogger();
    public RuntimePolicy InstantiateDefaultRuntimePolicy();
    public IHtmlEncoder InstantiateHtmlEncoder();
    public IPersistenceStore InstantiatePersistenceStore();
    public ICollection`1<IInspector> InstantiateInspectors();
    public ICollection`1<IResource> InstantiateResources();
    public ISerializer InstantiateSerializer();
    public ICollection`1<ITab> InstantiateTabs();
    public ICollection`1<IDisplay> InstantiateDisplays();
    public ICollection`1<IRuntimePolicy> InstantiateRuntimePolicies();
    public ICollection`1<ISerializationConverter> InstantiateSerializationConverters();
    public IResource InstantiateDefaultResource();
    public Func`1<IExecutionTimer> InstantiateTimerStrategy();
    public Func`1<RuntimePolicy> InstantiateRuntimePolicyStrategy();
    public IGlimpseConfiguration InstantiateConfiguration();
    public string InstantiateBaseResourceUri();
    public IMessageBroker InstantiateMessageBroker();
    public IProxyFactory InstantiateProxyFactory();
    private static IEnumerable`1<Type> ToEnumerable(TypeElementCollection collection);
    private IDiscoverableCollection`1<T> CreateDiscoverableCollection(DiscoverableCollectionElement config);
    private bool TrySingleInstanceFromServiceLocators(T& instance);
    private bool TryAllInstancesFromServiceLocators(ICollection`1& instance);
}
public class Glimpse.Core.Framework.GlimpseConfiguration : object {
    private static IMessageBroker messageBroker;
    private static Func`1<IExecutionTimer> timerStrategy;
    private static ILogger logger;
    private ICollection`1<IClientScript> clientScripts;
    private IResource defaultResource;
    private string endpointBaseUri;
    private IFrameworkProvider frameworkProvider;
    private IHtmlEncoder htmlEncoder;
    private IPersistenceStore persistenceStore;
    private ICollection`1<IInspector> inspectors;
    private IProxyFactory proxyFactory;
    private ResourceEndpointConfiguration resourceEndpoint;
    private ICollection`1<IResource> resources;
    private ICollection`1<IRuntimePolicy> runtimePolicies;
    private ISerializer serializer;
    private ICollection`1<ITab> tabs;
    private ICollection`1<IDisplay> displays;
    private Func`1<RuntimePolicy> runtimePolicyStrategy;
    private string hash;
    [CompilerGeneratedAttribute]
private RuntimePolicy <DefaultRuntimePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<ITab, Type> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<IInspector, Type> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IResource, Type> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<IClientScript, Type> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<IRuntimePolicy, Type> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`1<IExecutionTimer> CS$<>9__CachedAnonymousMethodDelegate16;
    public ICollection`1<IClientScript> ClientScripts { get; public set; }
    public IResource DefaultResource { get; public set; }
    public RuntimePolicy DefaultRuntimePolicy { get; public set; }
    public string EndpointBaseUri { get; public set; }
    public IFrameworkProvider FrameworkProvider { get; public set; }
    public IHtmlEncoder HtmlEncoder { get; public set; }
    public ILogger Logger { get; public set; }
    public IMessageBroker MessageBroker { get; public set; }
    public IPersistenceStore PersistenceStore { get; public set; }
    public ICollection`1<IInspector> Inspectors { get; public set; }
    public IProxyFactory ProxyFactory { get; public set; }
    public ResourceEndpointConfiguration ResourceEndpoint { get; public set; }
    public ICollection`1<IResource> Resources { get; public set; }
    public ICollection`1<IRuntimePolicy> RuntimePolicies { get; public set; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; public set; }
    public ISerializer Serializer { get; public set; }
    public ICollection`1<ITab> Tabs { get; public set; }
    public ICollection`1<IDisplay> Displays { get; public set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; public set; }
    public string Hash { get; public set; }
    public GlimpseConfiguration(IFrameworkProvider frameworkProvider, ResourceEndpointConfiguration endpointConfiguration, ICollection`1<IClientScript> clientScripts, ILogger logger, RuntimePolicy defaultRuntimePolicy, IHtmlEncoder htmlEncoder, IPersistenceStore persistenceStore, ICollection`1<IInspector> inspectors, ICollection`1<IResource> resources, ISerializer serializer, ICollection`1<ITab> tabs, ICollection`1<IDisplay> displays, ICollection`1<IRuntimePolicy> runtimePolicies, IResource defaultResource, IProxyFactory proxyFactory, IMessageBroker messageBroker, string endpointBaseUri, Func`1<IExecutionTimer> timerStrategy, Func`1<RuntimePolicy> runtimePolicyStrategy);
    public sealed virtual ICollection`1<IClientScript> get_ClientScripts();
    public void set_ClientScripts(ICollection`1<IClientScript> value);
    public sealed virtual IResource get_DefaultResource();
    public void set_DefaultResource(IResource value);
    [CompilerGeneratedAttribute]
public sealed virtual RuntimePolicy get_DefaultRuntimePolicy();
    [CompilerGeneratedAttribute]
public void set_DefaultRuntimePolicy(RuntimePolicy value);
    public sealed virtual string get_EndpointBaseUri();
    public void set_EndpointBaseUri(string value);
    public sealed virtual IFrameworkProvider get_FrameworkProvider();
    public void set_FrameworkProvider(IFrameworkProvider value);
    public sealed virtual IHtmlEncoder get_HtmlEncoder();
    public void set_HtmlEncoder(IHtmlEncoder value);
    public sealed virtual ILogger get_Logger();
    public void set_Logger(ILogger value);
    public sealed virtual IMessageBroker get_MessageBroker();
    public void set_MessageBroker(IMessageBroker value);
    public sealed virtual IPersistenceStore get_PersistenceStore();
    public void set_PersistenceStore(IPersistenceStore value);
    public sealed virtual ICollection`1<IInspector> get_Inspectors();
    public void set_Inspectors(ICollection`1<IInspector> value);
    public sealed virtual IProxyFactory get_ProxyFactory();
    public void set_ProxyFactory(IProxyFactory value);
    public sealed virtual ResourceEndpointConfiguration get_ResourceEndpoint();
    public void set_ResourceEndpoint(ResourceEndpointConfiguration value);
    public sealed virtual ICollection`1<IResource> get_Resources();
    public void set_Resources(ICollection`1<IResource> value);
    public sealed virtual ICollection`1<IRuntimePolicy> get_RuntimePolicies();
    public void set_RuntimePolicies(ICollection`1<IRuntimePolicy> value);
    public sealed virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    public sealed virtual void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
    public sealed virtual ISerializer get_Serializer();
    public void set_Serializer(ISerializer value);
    public sealed virtual ICollection`1<ITab> get_Tabs();
    public void set_Tabs(ICollection`1<ITab> value);
    public sealed virtual ICollection`1<IDisplay> get_Displays();
    public void set_Displays(ICollection`1<IDisplay> value);
    public sealed virtual Func`1<IExecutionTimer> get_TimerStrategy();
    public sealed virtual void set_TimerStrategy(Func`1<IExecutionTimer> value);
    public sealed virtual string get_Hash();
    public void set_Hash(string value);
    [ObsoleteAttribute("HACK: To support TraceListener with TraceSource via web.config")]
public static ILogger GetLogger();
    [ObsoleteAttribute("HACK: To support TraceListener with TraceSource via web.config")]
public static Func`1<IExecutionTimer> GetConfiguredTimerStrategy();
    [ObsoleteAttribute("HACK: To support TraceListener with TraceSource via web.config")]
public static IMessageBroker GetConfiguredMessageBroker();
    [CompilerGeneratedAttribute]
private static Type <get_Hash>b__1(ITab tab);
    [CompilerGeneratedAttribute]
private static string <get_Hash>b__2(Type type);
    [CompilerGeneratedAttribute]
private static Type <get_Hash>b__3(IInspector inspector);
    [CompilerGeneratedAttribute]
private static string <get_Hash>b__4(Type type);
    [CompilerGeneratedAttribute]
private static Type <get_Hash>b__5(IResource resource);
    [CompilerGeneratedAttribute]
private static string <get_Hash>b__6(Type type);
    [CompilerGeneratedAttribute]
private static Type <get_Hash>b__7(IClientScript clientScript);
    [CompilerGeneratedAttribute]
private static string <get_Hash>b__8(Type type);
    [CompilerGeneratedAttribute]
private static Type <get_Hash>b__9(IRuntimePolicy policy);
    [CompilerGeneratedAttribute]
private static string <get_Hash>b__a(Type type);
    [CompilerGeneratedAttribute]
private static IExecutionTimer <GetConfiguredTimerStrategy>b__15();
}
public class Glimpse.Core.Framework.GlimpseException : Exception {
    public GlimpseException(string message);
    public GlimpseException(string message, Exception innerException);
    public GlimpseException(SerializationInfo info, StreamingContext context);
}
public class Glimpse.Core.Framework.GlimpseMetadata : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TabMetadata> <Tabs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Resources>k__BackingField;
    public string Version { get; public set; }
    public string Hash { get; public set; }
    public IDictionary`2<string, TabMetadata> Tabs { get; public set; }
    public IDictionary`2<string, string> Resources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TabMetadata> get_Tabs();
    [CompilerGeneratedAttribute]
public void set_Tabs(IDictionary`2<string, TabMetadata> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Resources();
    [CompilerGeneratedAttribute]
public void set_Resources(IDictionary`2<string, string> value);
}
public class Glimpse.Core.Framework.GlimpseRequest : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ParentRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestIsAjax>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestHttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponseStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TabResult> <TabData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TabResult> <DisplayData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    public string ClientId { get; public set; }
    public DateTime DateTime { get; public set; }
    public TimeSpan Duration { get; public set; }
    public Nullable`1<Guid> ParentRequestId { get; public set; }
    public Guid RequestId { get; public set; }
    public bool RequestIsAjax { get; public set; }
    public string RequestHttpMethod { get; public set; }
    public string RequestUri { get; public set; }
    public string ResponseContentType { get; public set; }
    public int ResponseStatusCode { get; public set; }
    public IDictionary`2<string, TabResult> TabData { get; public set; }
    public IDictionary`2<string, TabResult> DisplayData { get; public set; }
    public string UserAgent { get; public set; }
    public GlimpseRequest(Guid requestId, IRequestMetadata requestMetadata, IDictionary`2<string, TabResult> tabData, IDictionary`2<string, TabResult> displayData, TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    [CompilerGeneratedAttribute]
public void set_DateTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ParentRequestId();
    [CompilerGeneratedAttribute]
public void set_ParentRequestId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Guid get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_RequestIsAjax();
    [CompilerGeneratedAttribute]
public void set_RequestIsAjax(bool value);
    [CompilerGeneratedAttribute]
public string get_RequestHttpMethod();
    [CompilerGeneratedAttribute]
public void set_RequestHttpMethod(string value);
    [CompilerGeneratedAttribute]
public string get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseContentType();
    [CompilerGeneratedAttribute]
public void set_ResponseContentType(string value);
    [CompilerGeneratedAttribute]
public int get_ResponseStatusCode();
    [CompilerGeneratedAttribute]
public void set_ResponseStatusCode(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TabResult> get_TabData();
    [CompilerGeneratedAttribute]
public void set_TabData(IDictionary`2<string, TabResult> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TabResult> get_DisplayData();
    [CompilerGeneratedAttribute]
public void set_DisplayData(IDictionary`2<string, TabResult> value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
}
public class Glimpse.Core.Framework.GlimpseRequestHeaders : object {
    [CompilerGeneratedAttribute]
private GlimpseRequest <GlimpseRequest>k__BackingField;
    public string ClientId { get; }
    public DateTime DateTime { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<Guid> ParentRequestId { get; }
    public Guid RequestId { get; }
    public bool RequestIsAjax { get; }
    public string RequestHttpMethod { get; }
    public string RequestUri { get; }
    public string ResponseContentType { get; }
    public int ResponseStatusCode { get; }
    public string UserAgent { get; }
    private GlimpseRequest GlimpseRequest { get; private set; }
    public GlimpseRequestHeaders(GlimpseRequest glimpseRequest);
    public string get_ClientId();
    public DateTime get_DateTime();
    public TimeSpan get_Duration();
    public Nullable`1<Guid> get_ParentRequestId();
    public Guid get_RequestId();
    public bool get_RequestIsAjax();
    public string get_RequestHttpMethod();
    public string get_RequestUri();
    public string get_ResponseContentType();
    public int get_ResponseStatusCode();
    public string get_UserAgent();
    [CompilerGeneratedAttribute]
private GlimpseRequest get_GlimpseRequest();
    [CompilerGeneratedAttribute]
private void set_GlimpseRequest(GlimpseRequest value);
}
public class Glimpse.Core.Framework.GlimpseRuntime : object {
    private static MethodInfo MethodInfoBeginRequest;
    private static MethodInfo MethodInfoEndRequest;
    private static object LockObj;
    [CompilerGeneratedAttribute]
private static string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IGlimpseConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IDisplay, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<IDisplay, IDisplay> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<ITab, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<ITab, ITab> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<IClientScript, ScriptOrder> CS$<>9__CachedAnonymousMethodDelegate22;
    public static string Version { get; private set; }
    public IGlimpseConfiguration Configuration { get; public set; }
    public bool IsInitialized { get; private set; }
    private IDictionary`2<string, TabResult> TabResultsStore { get; }
    private IDictionary`2<string, TabResult> DisplayResultsStore { get; }
    private static GlimpseRuntime();
    public GlimpseRuntime(IGlimpseConfiguration configuration);
    [CompilerGeneratedAttribute]
public static string get_Version();
    [CompilerGeneratedAttribute]
private static void set_Version(string value);
    [CompilerGeneratedAttribute]
public IGlimpseConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(IGlimpseConfiguration value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    private IDictionary`2<string, TabResult> get_TabResultsStore();
    private IDictionary`2<string, TabResult> get_DisplayResultsStore();
    public sealed virtual void BeginRequest();
    private bool HasOffRuntimePolicy(RuntimeEvent policyName);
    public sealed virtual void EndRequest();
    public sealed virtual void ExecuteDefaultResource();
    public sealed virtual void BeginSessionAccess();
    public sealed virtual void EndSessionAccess();
    public sealed virtual void ExecuteResource(string resourceName, ResourceParameters parameters);
    public sealed virtual bool Initialize();
    private static UriTemplate SetParameters(UriTemplate template, IEnumerable`1<KeyValuePair`2<string, string>> nameValues);
    private static ExecutionTimer CreateAndStartGlobalExecutionTimer(IDataStore requestStore);
    private static string CreateKey(object obj);
    private IDataStore GetTabStore(string tabName);
    private void ExecuteTabs(RuntimeEvent runtimeEvent);
    private void ExecuteDisplays();
    private void PersistMetadata();
    private RuntimePolicy DetermineRuntimePolicy(RuntimeEvent runtimeEvent, RuntimePolicy maximumAllowedPolicy);
    private RuntimePolicy DetermineAndStoreAccumulatedRuntimePolicy(RuntimeEvent runtimeEvent);
    private string GenerateScriptTags(Guid requestId);
    [CompilerGeneratedAttribute]
private static bool <Initialize>b__7(IDisplay display);
    [CompilerGeneratedAttribute]
private static IDisplay <Initialize>b__8(IDisplay display);
    [CompilerGeneratedAttribute]
private static bool <Initialize>b__a(ITab tab);
    [CompilerGeneratedAttribute]
private static ITab <Initialize>b__b(ITab tab);
    [CompilerGeneratedAttribute]
private static ScriptOrder <GenerateScriptTags>b__20(IClientScript cs);
}
public interface Glimpse.Core.Framework.IDiscoverableCollection`1 {
    public bool AutoDiscover { get; }
    public string DiscoveryLocation { get; }
    public abstract virtual bool get_AutoDiscover();
    public abstract virtual string get_DiscoveryLocation();
    public abstract virtual void IgnoreType(Type type);
    public abstract virtual void Discover();
}
public interface Glimpse.Core.Framework.IFrameworkProvider {
    public IDataStore HttpRequestStore { get; }
    public IDataStore HttpServerStore { get; }
    public object RuntimeContext { get; }
    public IRequestMetadata RequestMetadata { get; }
    public abstract virtual IDataStore get_HttpRequestStore();
    public abstract virtual IDataStore get_HttpServerStore();
    public abstract virtual object get_RuntimeContext();
    public abstract virtual IRequestMetadata get_RequestMetadata();
    public abstract virtual void SetHttpResponseHeader(string name, string value);
    public abstract virtual void SetHttpResponseStatusCode(int statusCode);
    public abstract virtual void SetCookie(string name, string value);
    public abstract virtual void InjectHttpResponseBody(string htmlSnippet);
    public abstract virtual void WriteHttpResponse(Byte[] content);
    public abstract virtual void WriteHttpResponse(string content);
}
public interface Glimpse.Core.Framework.IGlimpseConfiguration {
    public ICollection`1<IClientScript> ClientScripts { get; }
    public IFrameworkProvider FrameworkProvider { get; }
    public IHtmlEncoder HtmlEncoder { get; }
    public ILogger Logger { get; }
    public IPersistenceStore PersistenceStore { get; }
    public ICollection`1<IInspector> Inspectors { get; }
    public ResourceEndpointConfiguration ResourceEndpoint { get; }
    public ICollection`1<IResource> Resources { get; }
    public ISerializer Serializer { get; }
    public ICollection`1<ITab> Tabs { get; }
    [ObsoleteAttribute]
public ICollection`1<IDisplay> Displays { get; }
    public ICollection`1<IRuntimePolicy> RuntimePolicies { get; }
    public IResource DefaultResource { get; }
    public RuntimePolicy DefaultRuntimePolicy { get; }
    public IProxyFactory ProxyFactory { get; }
    public IMessageBroker MessageBroker { get; }
    public string EndpointBaseUri { get; }
    public string Hash { get; }
    public Func`1<RuntimePolicy> RuntimePolicyStrategy { get; public set; }
    public Func`1<IExecutionTimer> TimerStrategy { get; public set; }
    public abstract virtual ICollection`1<IClientScript> get_ClientScripts();
    public abstract virtual IFrameworkProvider get_FrameworkProvider();
    public abstract virtual IHtmlEncoder get_HtmlEncoder();
    public abstract virtual ILogger get_Logger();
    public abstract virtual IPersistenceStore get_PersistenceStore();
    public abstract virtual ICollection`1<IInspector> get_Inspectors();
    public abstract virtual ResourceEndpointConfiguration get_ResourceEndpoint();
    public abstract virtual ICollection`1<IResource> get_Resources();
    public abstract virtual ISerializer get_Serializer();
    public abstract virtual ICollection`1<ITab> get_Tabs();
    public abstract virtual ICollection`1<IDisplay> get_Displays();
    public abstract virtual ICollection`1<IRuntimePolicy> get_RuntimePolicies();
    public abstract virtual IResource get_DefaultResource();
    public abstract virtual RuntimePolicy get_DefaultRuntimePolicy();
    public abstract virtual IProxyFactory get_ProxyFactory();
    public abstract virtual IMessageBroker get_MessageBroker();
    public abstract virtual string get_EndpointBaseUri();
    public abstract virtual string get_Hash();
    public abstract virtual Func`1<RuntimePolicy> get_RuntimePolicyStrategy();
    public abstract virtual void set_RuntimePolicyStrategy(Func`1<RuntimePolicy> value);
    public abstract virtual Func`1<IExecutionTimer> get_TimerStrategy();
    public abstract virtual void set_TimerStrategy(Func`1<IExecutionTimer> value);
}
public interface Glimpse.Core.Framework.IGlimpseRuntime {
    public bool IsInitialized { get; }
    public abstract virtual bool get_IsInitialized();
    public abstract virtual void BeginRequest();
    public abstract virtual void EndRequest();
    public abstract virtual void ExecuteDefaultResource();
    public abstract virtual void ExecuteResource(string resourceName, ResourceParameters parameters);
    public abstract virtual void BeginSessionAccess();
    public abstract virtual void EndSessionAccess();
    public abstract virtual bool Initialize();
}
public interface Glimpse.Core.Framework.IPersistenceStore {
    public abstract virtual void Save(GlimpseRequest request);
    public abstract virtual void Save(GlimpseMetadata metadata);
}
public interface Glimpse.Core.Framework.IReadOnlyPersistenceStore {
    public abstract virtual GlimpseRequest GetByRequestId(Guid requestId);
    public abstract virtual TabResult GetByRequestIdAndTabKey(Guid requestId, string tabKey);
    public abstract virtual IEnumerable`1<GlimpseRequest> GetByRequestParentId(Guid parentRequestId);
    public abstract virtual IEnumerable`1<GlimpseRequest> GetTop(int count);
    public abstract virtual GlimpseMetadata GetMetadata();
}
public interface Glimpse.Core.Framework.IRequestMetadata {
    public string RequestUri { get; }
    public string RequestHttpMethod { get; }
    public int ResponseStatusCode { get; }
    public string ResponseContentType { get; }
    public bool RequestIsAjax { get; }
    public string ClientId { get; }
    public abstract virtual string get_RequestUri();
    public abstract virtual string get_RequestHttpMethod();
    public abstract virtual int get_ResponseStatusCode();
    public abstract virtual string get_ResponseContentType();
    public abstract virtual bool get_RequestIsAjax();
    public abstract virtual string get_ClientId();
    public abstract virtual string GetCookie(string name);
    public abstract virtual string GetHttpHeader(string name);
}
public interface Glimpse.Core.Framework.IServiceLocator {
    public abstract virtual T GetInstance();
    public abstract virtual ICollection`1<T> GetAllInstances();
}
public static class Glimpse.Core.Framework.ReflectionBlackList : object {
    private static List`1<string> blackList;
    private static ReflectionBlackList();
    public static bool IsBlackListed(Assembly assembly);
}
public class Glimpse.Core.Framework.ReflectionDiscoverableCollection`1 : object {
    private string discoveryLocation;
    [CompilerGeneratedAttribute]
private bool <AutoDiscover>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<T> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <IgnoredTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public bool AutoDiscover { get; public set; }
    public int Count { get; }
    public string DiscoveryLocation { get; public set; }
    public bool IsReadOnly { get; }
    internal List`1<T> Items { get; internal set; }
    internal List`1<Type> IgnoredTypes { get; internal set; }
    internal ILogger Logger { get; internal set; }
    private static string BaseDirectory { get; }
    public ReflectionDiscoverableCollection`1(ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoDiscover();
    [CompilerGeneratedAttribute]
public void set_AutoDiscover(bool value);
    public sealed virtual int get_Count();
    public sealed virtual string get_DiscoveryLocation();
    public void set_DiscoveryLocation(string value);
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal List`1<T> get_Items();
    [CompilerGeneratedAttribute]
internal void set_Items(List`1<T> value);
    [CompilerGeneratedAttribute]
internal List`1<Type> get_IgnoredTypes();
    [CompilerGeneratedAttribute]
internal void set_IgnoredTypes(List`1<Type> value);
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(ILogger value);
    private static string get_BaseDirectory();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual void IgnoreType(Type type);
    public sealed virtual void Discover();
    private void GetConcreteTypes(Assembly assembly, List`1<T> results);
    [CompilerGeneratedAttribute]
private bool <GetConcreteTypes>b__0(Type type);
}
public abstract class Glimpse.Core.Framework.ResourceEndpointConfiguration : object {
    public string GenerateUriTemplate(IResource resource, string baseUri, ILogger logger);
    protected abstract virtual string GenerateUriTemplate(string resourceName, string baseUri, IEnumerable`1<ResourceParameterMetadata> parameters, ILogger logger);
}
public class Glimpse.Core.Framework.ResourceParameters : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <NamedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OrderedParameters>k__BackingField;
    internal IDictionary`2<string, string> NamedParameters { get; internal set; }
    internal String[] OrderedParameters { get; internal set; }
    public ResourceParameters(IDictionary`2<string, string> namedParameters);
    public ResourceParameters(String[] orderedParameters);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_NamedParameters();
    [CompilerGeneratedAttribute]
internal void set_NamedParameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal String[] get_OrderedParameters();
    [CompilerGeneratedAttribute]
internal void set_OrderedParameters(String[] value);
    public static ResourceParameters None();
    public IDictionary`2<string, string> GetParametersFor(IResource resource);
}
public abstract class Glimpse.Core.Framework.Support.ExecutionBlockBase : object {
    private object hasInitalizedLock;
    private bool hasInitalized;
    private ILogger logger;
    private IList`1<IExecutionTask> tasks;
    protected ILogger Logger { get; }
    protected ILogger get_Logger();
    public void RegisterProvider(IExecutionTask task);
    public void Execute();
}
public interface Glimpse.Core.Framework.Support.IExecutionTask {
    public abstract virtual void Execute();
}
public class Glimpse.Core.Framework.TabMetadata : object {
    [CompilerGeneratedAttribute]
private string <DocumentationUri>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeysHeadings>k__BackingField;
    public string DocumentationUri { get; public set; }
    public object Layout { get; public set; }
    public bool KeysHeadings { get; public set; }
    public bool HasMetadata { get; }
    [CompilerGeneratedAttribute]
public string get_DocumentationUri();
    [CompilerGeneratedAttribute]
public void set_DocumentationUri(string value);
    [CompilerGeneratedAttribute]
public object get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(object value);
    [CompilerGeneratedAttribute]
public bool get_KeysHeadings();
    [CompilerGeneratedAttribute]
public void set_KeysHeadings(bool value);
    public bool get_HasMetadata();
}
public class Glimpse.Core.Framework.TabResult : object {
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public object Data { get; public set; }
    public string Name { get; public set; }
    public TabResult(string name, object data);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class Glimpse.Core.Inspector.TraceInspector : object {
    public sealed virtual void Setup(IInspectorContext context);
}
public interface Glimpse.Core.Message.IMessage {
    public Guid Id { get; }
    public abstract virtual Guid get_Id();
}
public interface Glimpse.Core.Message.ISourceMessage {
    public Type ExecutedType { get; public set; }
    public MethodInfo ExecutedMethod { get; public set; }
    public abstract virtual Type get_ExecutedType();
    public abstract virtual void set_ExecutedType(Type value);
    public abstract virtual MethodInfo get_ExecutedMethod();
    public abstract virtual void set_ExecutedMethod(MethodInfo value);
}
public interface Glimpse.Core.Message.ITimedMessage {
    public TimeSpan Offset { get; public set; }
    public TimeSpan Duration { get; public set; }
    public DateTime StartTime { get; public set; }
    public abstract virtual TimeSpan get_Offset();
    public abstract virtual void set_Offset(TimeSpan value);
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual void set_Duration(TimeSpan value);
    public abstract virtual DateTime get_StartTime();
    public abstract virtual void set_StartTime(DateTime value);
}
public interface Glimpse.Core.Message.ITimelineMessage {
    public string EventName { get; public set; }
    public TimelineCategoryItem EventCategory { get; public set; }
    public string EventSubText { get; public set; }
    public abstract virtual string get_EventName();
    public abstract virtual void set_EventName(string value);
    public abstract virtual TimelineCategoryItem get_EventCategory();
    public abstract virtual void set_EventCategory(TimelineCategoryItem value);
    public abstract virtual string get_EventSubText();
    public abstract virtual void set_EventSubText(string value);
}
public interface Glimpse.Core.Message.ITraceMessage {
    public string Category { get; }
    public string Message { get; }
    public TimeSpan FromFirst { get; }
    public TimeSpan FromLast { get; }
    public int IndentLevel { get; }
    public abstract virtual string get_Category();
    public abstract virtual string get_Message();
    public abstract virtual TimeSpan get_FromFirst();
    public abstract virtual TimeSpan get_FromLast();
    public abstract virtual int get_IndentLevel();
}
public class Glimpse.Core.Message.MessageBase : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; protected internal set; }
    public MessageBase(Guid id);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
protected internal void set_Id(Guid value);
}
[ExtensionAttribute]
public static class Glimpse.Core.Message.SourceMessageExtension : object {
    [ExtensionAttribute]
public static T AsSourceMessage(T message, Type executedType, MethodInfo executedMethod);
}
[ExtensionAttribute]
public static class Glimpse.Core.Message.TimedMessageExtension : object {
    [ExtensionAttribute]
public static T AsTimedMessage(T message, TimerResult timerResult);
    [ExtensionAttribute]
public static T AsTimedMessage(T message, TimeSpan offset, TimeSpan duration, DateTime startTime);
    [ExtensionAttribute]
public static T AsTimedMessage(T message, TimeSpan offset);
    [ExtensionAttribute]
public static T AsTimedMessage(T message, TimeSpan offset, DateTime startTime);
    [ExtensionAttribute]
public static T AsTimedMessage(T message, TimeSpan offset, TimeSpan duration);
}
public class Glimpse.Core.Message.TimelineCategory : object {
    private static TimelineCategoryItem request;
    private static TimelineCategoryItem other;
    public static TimelineCategoryItem Request { get; }
    public static TimelineCategoryItem Other { get; }
    private static TimelineCategory();
    public static TimelineCategoryItem get_Request();
    public static TimelineCategoryItem get_Other();
}
public class Glimpse.Core.Message.TimelineCategoryItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColorHighlight>k__BackingField;
    public string Name { get; public set; }
    public string Color { get; public set; }
    public string ColorHighlight { get; public set; }
    public TimelineCategoryItem(string name, string color, string colorHighlight);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(string value);
    [CompilerGeneratedAttribute]
public string get_ColorHighlight();
    [CompilerGeneratedAttribute]
public void set_ColorHighlight(string value);
}
[ExtensionAttribute]
public static class Glimpse.Core.Message.TimelineMessageExtension : object {
    [ExtensionAttribute]
public static T AsTimelineMessage(T message, string eventName, TimelineCategoryItem eventCategory, string eventSubText);
    [ExtensionAttribute]
public static T AsTimelineMessage(T message, TimelineCategoryItem eventCategory, string eventSubText);
}
public class Glimpse.Core.Message.TraceMessage : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FromFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FromLast>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentLevel>k__BackingField;
    public string Category { get; public set; }
    public string Message { get; public set; }
    public TimeSpan FromFirst { get; public set; }
    public TimeSpan FromLast { get; public set; }
    public int IndentLevel { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_FromFirst();
    [CompilerGeneratedAttribute]
public void set_FromFirst(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_FromLast();
    [CompilerGeneratedAttribute]
public void set_FromLast(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndentLevel();
    [CompilerGeneratedAttribute]
public void set_IndentLevel(int value);
}
public class Glimpse.Core.Model.TimelineCategoryModel : object {
    [CompilerGeneratedAttribute]
private string <EventColorHighlight>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventColor>k__BackingField;
    public string EventColorHighlight { get; public set; }
    public string EventColor { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventColorHighlight();
    [CompilerGeneratedAttribute]
public void set_EventColorHighlight(string value);
    [CompilerGeneratedAttribute]
public string get_EventColor();
    [CompilerGeneratedAttribute]
public void set_EventColor(string value);
}
public class Glimpse.Core.Model.TimelineEventModel : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <StartPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubText>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Details>k__BackingField;
    public string Category { get; public set; }
    public DateTime StartTime { get; public set; }
    public TimeSpan StartPoint { get; public set; }
    public TimeSpan Duration { get; public set; }
    public string Title { get; public set; }
    public string SubText { get; public set; }
    public IDictionary`2<string, object> Details { get; public set; }
    public TimeSpan EndPoint { get; }
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_StartPoint();
    [CompilerGeneratedAttribute]
public void set_StartPoint(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_SubText();
    [CompilerGeneratedAttribute]
public void set_SubText(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(IDictionary`2<string, object> value);
    public TimeSpan get_EndPoint();
}
public class Glimpse.Core.Model.TimelineModel : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TimelineCategoryModel> <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TimelineEventModel> <Events>k__BackingField;
    public TimeSpan Duration { get; public set; }
    public IDictionary`2<string, TimelineCategoryModel> Category { get; public set; }
    public IList`1<TimelineEventModel> Events { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TimelineCategoryModel> get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(IDictionary`2<string, TimelineCategoryModel> value);
    [CompilerGeneratedAttribute]
public IList`1<TimelineEventModel> get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(IList`1<TimelineEventModel> value);
}
public class Glimpse.Core.Policy.AjaxPolicy : object {
    public RuntimeEvent ExecuteOn { get; }
    public sealed virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
}
public class Glimpse.Core.Policy.ContentTypePolicy : object {
    [CompilerGeneratedAttribute]
private IList`1<Tuple`2<string, RuntimePolicy>> <ContentTypeWhiteList>k__BackingField;
    public IList`1<Tuple`2<string, RuntimePolicy>> ContentTypeWhiteList { get; public set; }
    public RuntimeEvent ExecuteOn { get; }
    public ContentTypePolicy(IList`1<Tuple`2<string, RuntimePolicy>> contentTypeWhiteList);
    [CompilerGeneratedAttribute]
public IList`1<Tuple`2<string, RuntimePolicy>> get_ContentTypeWhiteList();
    [CompilerGeneratedAttribute]
public void set_ContentTypeWhiteList(IList`1<Tuple`2<string, RuntimePolicy>> value);
    public sealed virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
    public sealed virtual void Configure(Section section);
}
public class Glimpse.Core.Policy.ControlCookiePolicy : object {
    internal static string ControlCookieName;
    public RuntimeEvent ExecuteOn { get; }
    public sealed virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
}
public class Glimpse.Core.Policy.GlimpseResourcePolicy : object {
    public RuntimeEvent ExecuteOn { get; }
    public sealed virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
}
public class Glimpse.Core.Policy.StatusCodePolicy : object {
    [CompilerGeneratedAttribute]
private IList`1<int> <StatusCodeWhiteList>k__BackingField;
    public RuntimeEvent ExecuteOn { get; }
    public IList`1<int> StatusCodeWhiteList { get; public set; }
    public StatusCodePolicy(IList`1<int> statusCodeWhiteList);
    public sealed virtual RuntimeEvent get_ExecuteOn();
    [CompilerGeneratedAttribute]
public IList`1<int> get_StatusCodeWhiteList();
    [CompilerGeneratedAttribute]
public void set_StatusCodeWhiteList(IList`1<int> value);
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
    public sealed virtual void Configure(Section section);
}
public class Glimpse.Core.Policy.UriPolicy : object {
    [CompilerGeneratedAttribute]
private IList`1<Regex> <UriBlackList>k__BackingField;
    public RuntimeEvent ExecuteOn { get; }
    public IList`1<Regex> UriBlackList { get; public set; }
    public UriPolicy(IList`1<Regex> uriBlackList);
    public sealed virtual RuntimeEvent get_ExecuteOn();
    [CompilerGeneratedAttribute]
public IList`1<Regex> get_UriBlackList();
    [CompilerGeneratedAttribute]
public void set_UriBlackList(IList`1<Regex> value);
    public sealed virtual RuntimePolicy Execute(IRuntimePolicyContext policyContext);
    public sealed virtual void Configure(Section section);
}
public class Glimpse.Core.Resource.AjaxResource : object {
    internal static string InternalName;
    private static string ParentRequestKey;
    [CompilerGeneratedAttribute]
private static Func`2<GlimpseRequest, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Name { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public string Key { get; }
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual string get_Key();
    public sealed virtual IResourceResult Execute(IResourceContext context);
    [CompilerGeneratedAttribute]
private static bool <Execute>b__0(GlimpseRequest r);
}
public class Glimpse.Core.Resource.ClientResource : FileResource {
    internal static string InternalName;
    [CompilerGeneratedAttribute]
private EmbeddedResourceInfo <GlimpseClientEmbeddedResourceInfo>k__BackingField;
    private EmbeddedResourceInfo GlimpseClientEmbeddedResourceInfo { get; private set; }
    public string Key { get; }
    [CompilerGeneratedAttribute]
private EmbeddedResourceInfo get_GlimpseClientEmbeddedResourceInfo();
    [CompilerGeneratedAttribute]
private void set_GlimpseClientEmbeddedResourceInfo(EmbeddedResourceInfo value);
    public sealed virtual string get_Key();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.ConfigurationResource : object {
    internal static string InternalName;
    private String[] resourceDependencies;
    [CompilerGeneratedAttribute]
private static Func`3<string, int, <>f__AnonymousType0`2<string, bool>> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<ITab, object> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<ITab, string> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<IRuntimePolicy, object> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<IRuntimePolicy, string> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<IInspector, object> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<IInspector, string> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<IResource, string> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<IClientScript, object> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<IClientScript, string> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetPackageAttribute, <>f__AnonymousType6`2<string, string>> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<Assembly, string> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<IResource, string> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, IResource>, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, IResource>, string> CS$<>9__CachedAnonymousMethodDelegate24;
    public string Name { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public string Key { get; }
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual string get_Key();
    public sealed virtual bool DependsOn(string resourceName);
    public sealed virtual IResourceResult Execute(IResourceContext context);
    public sealed virtual IResourceResult Execute(IResourceContext context, IGlimpseConfiguration configuration);
    private static IEnumerable`1<object> GroupItemsByPackage(IEnumerable`1<T> items, IDictionary`2<string, PackageItemDetail> packages, Func`2<T, object> createItemDisplay);
    private static IDictionary`2<string, PackageItem`1<T>> GroupItems(IEnumerable`1<T> items, IDictionary`2<string, PackageItemDetail> packages);
    private static IDictionary`2<string, PackageItemDetail> FindPackages();
    private static IEnumerable`1<string> DetectDuplicateResources(IEnumerable`1<IResource> resources);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<string, bool> <Execute>b__0(string duplicateResource, int index);
    [CompilerGeneratedAttribute]
private static object <Execute>b__1(ITab registeredTab);
    [CompilerGeneratedAttribute]
private static string <Execute>b__2(ITab x);
    [CompilerGeneratedAttribute]
private static object <Execute>b__3(IRuntimePolicy registeredRuntimePolicy);
    [CompilerGeneratedAttribute]
private static string <Execute>b__4(IRuntimePolicy x);
    [CompilerGeneratedAttribute]
private static object <Execute>b__5(IInspector inspector);
    [CompilerGeneratedAttribute]
private static string <Execute>b__6(IInspector x);
    [CompilerGeneratedAttribute]
private static string <Execute>b__9(IResource x);
    [CompilerGeneratedAttribute]
private static object <Execute>b__a(IClientScript clientScript);
    [CompilerGeneratedAttribute]
private static string <Execute>b__b(IClientScript x);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType6`2<string, string> <Execute>b__c(NuGetPackageAttribute registeredNuGetPackage);
    [CompilerGeneratedAttribute]
private static string <Execute>b__d(Assembly nonProcessableAssembly);
    [CompilerGeneratedAttribute]
private static string <DetectDuplicateResources>b__1f(IResource x);
    [CompilerGeneratedAttribute]
private static bool <DetectDuplicateResources>b__20(IGrouping`2<string, IResource> x);
    [CompilerGeneratedAttribute]
private static string <DetectDuplicateResources>b__21(IGrouping`2<string, IResource> x);
}
public class Glimpse.Core.Resource.ConfigurationScriptResource : FileResource {
    internal static string InternalName;
    public string Key { get; }
    public sealed virtual string get_Key();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.ConfigurationStyleResource : FileResource {
    internal static string InternalName;
    public string Key { get; }
    public sealed virtual string get_Key();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public abstract class Glimpse.Core.Resource.FileResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; protected set; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    protected int CacheDuration { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    protected virtual int get_CacheDuration();
    public sealed virtual IResourceResult Execute(IResourceContext context);
    protected abstract virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.HistoryResource : object {
    internal static string InternalName;
    internal static string TopKey;
    [CompilerGeneratedAttribute]
private static Func`2<GlimpseRequest, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, GlimpseRequest>, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, GlimpseRequest>, IEnumerable`1<GlimpseRequestHeaders>> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<GlimpseRequest, GlimpseRequestHeaders> CS$<>9__CachedAnonymousMethodDelegate7;
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
    [CompilerGeneratedAttribute]
private static string <Execute>b__0(GlimpseRequest d);
    [CompilerGeneratedAttribute]
private static string <Execute>b__1(IGrouping`2<string, GlimpseRequest> group);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<GlimpseRequestHeaders> <Execute>b__2(IGrouping`2<string, GlimpseRequest> group);
    [CompilerGeneratedAttribute]
private static GlimpseRequestHeaders <Execute>b__3(GlimpseRequest g);
}
[ObsoleteAttribute("This resource should not be requested anymore, but rather the LogosResource")]
public class Glimpse.Core.Resource.LogoResource : FileResource {
    internal static string InternalName;
    [CompilerGeneratedAttribute]
private EmbeddedResourceInfo <GlimpseTextLogoEmbeddedResourceInfo>k__BackingField;
    private EmbeddedResourceInfo GlimpseTextLogoEmbeddedResourceInfo { get; private set; }
    public string Key { get; }
    [CompilerGeneratedAttribute]
private EmbeddedResourceInfo get_GlimpseTextLogoEmbeddedResourceInfo();
    [CompilerGeneratedAttribute]
private void set_GlimpseTextLogoEmbeddedResourceInfo(EmbeddedResourceInfo value);
    public sealed virtual string get_Key();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.LogosResource : FileResource {
    internal static string InternalName;
    private static string GlimpseTextLogoResourceName;
    private static string GlimpseImageLogoResourceName;
    private static string GlimpseFaviconResourceName;
    private static string GithubLogoResourceName;
    private static string TwitterLogoResourceName;
    private IDictionary`2<string, EmbeddedResourceInfo> embeddedResourceInfos;
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Key();
    public virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.MetadataResource : object {
    internal static string InternalName;
    private static int CacheDuration;
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
}
public class Glimpse.Core.Resource.PopupRedirectResource : object {
    [CompilerGeneratedAttribute]
private static Func`2<IResource, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
    public sealed virtual IResourceResult Execute(IResourceContext context, IGlimpseConfiguration configuration);
    [CompilerGeneratedAttribute]
private static bool <Execute>b__1(IResource r);
}
public class Glimpse.Core.Resource.PopupResource : object {
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
    public sealed virtual IResourceResult Execute(IResourceContext context, IGlimpseConfiguration configuration);
}
public class Glimpse.Core.Resource.RequestResource : object {
    internal static string InternalName;
    private static int CacheDuration;
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
}
public class Glimpse.Core.Resource.SpriteResource : FileResource {
    internal static string InternalName;
    public string Key { get; }
    public sealed virtual string get_Key();
    protected virtual EmbeddedResourceInfo GetEmbeddedResourceInfo(IResourceContext context);
}
public class Glimpse.Core.Resource.VersionCheckResource : object {
    internal static string InternalName;
    private static int OneDay;
    public string Name { get; }
    public string Key { get; }
    public IEnumerable`1<ResourceParameterMetadata> Parameters { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual IEnumerable`1<ResourceParameterMetadata> get_Parameters();
    public sealed virtual IResourceResult Execute(IResourceContext context);
}
public class Glimpse.Core.ResourceResult.CacheControlDecorator : ResourceResultDecorator {
    private static long NoCaching;
    [CompilerGeneratedAttribute]
private long <CacheDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CacheSetting> <CacheSetting>k__BackingField;
    public long CacheDuration { get; public set; }
    public Nullable`1<CacheSetting> CacheSetting { get; public set; }
    public CacheControlDecorator(IResourceResult wrappedResourceResult);
    public CacheControlDecorator(long cacheDuration, Nullable`1<CacheSetting> cacheSetting, IResourceResult wrappedResourceResult);
    [CompilerGeneratedAttribute]
public long get_CacheDuration();
    [CompilerGeneratedAttribute]
public void set_CacheDuration(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<CacheSetting> get_CacheSetting();
    [CompilerGeneratedAttribute]
public void set_CacheSetting(Nullable`1<CacheSetting> value);
    protected virtual void Decorate(IResourceResultContext context);
}
public class Glimpse.Core.ResourceResult.ExceptionResourceResult : StatusCodeResourceResult {
    public ExceptionResourceResult(Exception exception);
}
public class Glimpse.Core.ResourceResult.FileResourceResult : object {
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public Byte[] Content { get; public set; }
    public string ContentType { get; public set; }
    public FileResourceResult(Byte[] content, string contentType);
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    public sealed virtual void Execute(IResourceResultContext context);
}
public class Glimpse.Core.ResourceResult.HtmlResourceResult : object {
    [CompilerGeneratedAttribute]
private string <Html>k__BackingField;
    public string Html { get; public set; }
    public HtmlResourceResult(string html);
    [CompilerGeneratedAttribute]
public string get_Html();
    [CompilerGeneratedAttribute]
public void set_Html(string value);
    public sealed virtual void Execute(IResourceResultContext context);
}
public class Glimpse.Core.ResourceResult.JsonResourceResult : object {
    [CompilerGeneratedAttribute]
private string <Callback>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public string Callback { get; public set; }
    public string ContentType { get; public set; }
    public object Data { get; public set; }
    public JsonResourceResult(object data);
    public JsonResourceResult(object data, string callback);
    [CompilerGeneratedAttribute]
public string get_Callback();
    [CompilerGeneratedAttribute]
public void set_Callback(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    public sealed virtual void Execute(IResourceResultContext context);
}
public class Glimpse.Core.ResourceResult.RedirectResourceResult : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private UriTemplate <UriTemplate>k__BackingField;
    private IDictionary`2<string, object> Data { get; private set; }
    private UriTemplate UriTemplate { get; private set; }
    public RedirectResourceResult(string uriTemplate);
    public RedirectResourceResult(string uriTemplate, IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
private UriTemplate get_UriTemplate();
    [CompilerGeneratedAttribute]
private void set_UriTemplate(UriTemplate value);
    public sealed virtual void Execute(IResourceResultContext context);
}
public class Glimpse.Core.ResourceResult.StatusCodeResourceResult : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    public string Message { get; public set; }
    public int StatusCode { get; public set; }
    public StatusCodeResourceResult(int statusCode, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(int value);
    public sealed virtual void Execute(IResourceResultContext context);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
internal class Glimpse.Core.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AlternateTypeGenerationHookMethodsInspected { get; }
    internal static string AlternateTypeGenerationHookNonProxyableMemberNotification { get; }
    internal static string BeginRequestOutOfOrderRuntimeMethodCall { get; }
    internal static string DiscoverableCollectionAdd { get; }
    internal static string DiscoverableCollectionClear { get; }
    internal static string DiscoverableCollectionDiscover { get; }
    internal static string DiscoverableCollectionRemove { get; }
    internal static string DiscoverCreateInstance { get; }
    internal static string DiscoverGetType { get; }
    internal static string DiscoverLoadAssembly { get; }
    internal static string EndRequestOutOfOrderRuntimeMethodCall { get; }
    internal static string ExecutePolicyWarning { get; }
    internal static string ExecuteResourceDuplicateError { get; }
    internal static string ExecuteResourceInsufficientPolicy { get; }
    internal static string ExecuteResourceMissingError { get; }
    internal static string ExecuteTabError { get; }
    internal static string GenerateScriptTagsDynamicException { get; }
    internal static string GenerateScriptTagsStaticException { get; }
    internal static string GenerateUriExecutionError { get; }
    internal static string GenerateUriParameterKeysWarning { get; }
    internal static string GlimpseRuntimeEndRequesPersistError { get; }
    internal static string GlimpseRuntimeExecuteResourceError { get; }
    internal static string GlimpseRuntimeExecuteResourceResultError { get; }
    internal static string GlimpseRuntimeInitializeSetupInspector { get; }
    internal static string GlimpseRuntimePersistMetadataMultipleResourceWarning { get; }
    internal static string InitializeInspectorError { get; }
    internal static string InitializeTabError { get; }
    internal static string InstantiateFrameworkProviderException { get; }
    internal static string InstantiateResourceEndpointConfigurationException { get; }
    internal static string MessageBrokerSubscribe { get; }
    internal static string PrivilegedResourceExecuteNotSupported { get; }
    internal static string RenderClientScriptImproperImplementationWarning { get; }
    internal static string RenderClientScriptMissingResourceWarning { get; }
    internal static string SetDiscoveryLocationDirectoryNotFoundMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AlternateTypeGenerationHookMethodsInspected();
    internal static string get_AlternateTypeGenerationHookNonProxyableMemberNotification();
    internal static string get_BeginRequestOutOfOrderRuntimeMethodCall();
    internal static string get_DiscoverableCollectionAdd();
    internal static string get_DiscoverableCollectionClear();
    internal static string get_DiscoverableCollectionDiscover();
    internal static string get_DiscoverableCollectionRemove();
    internal static string get_DiscoverCreateInstance();
    internal static string get_DiscoverGetType();
    internal static string get_DiscoverLoadAssembly();
    internal static string get_EndRequestOutOfOrderRuntimeMethodCall();
    internal static string get_ExecutePolicyWarning();
    internal static string get_ExecuteResourceDuplicateError();
    internal static string get_ExecuteResourceInsufficientPolicy();
    internal static string get_ExecuteResourceMissingError();
    internal static string get_ExecuteTabError();
    internal static string get_GenerateScriptTagsDynamicException();
    internal static string get_GenerateScriptTagsStaticException();
    internal static string get_GenerateUriExecutionError();
    internal static string get_GenerateUriParameterKeysWarning();
    internal static string get_GlimpseRuntimeEndRequesPersistError();
    internal static string get_GlimpseRuntimeExecuteResourceError();
    internal static string get_GlimpseRuntimeExecuteResourceResultError();
    internal static string get_GlimpseRuntimeInitializeSetupInspector();
    internal static string get_GlimpseRuntimePersistMetadataMultipleResourceWarning();
    internal static string get_InitializeInspectorError();
    internal static string get_InitializeTabError();
    internal static string get_InstantiateFrameworkProviderException();
    internal static string get_InstantiateResourceEndpointConfigurationException();
    internal static string get_MessageBrokerSubscribe();
    internal static string get_PrivilegedResourceExecuteNotSupported();
    internal static string get_RenderClientScriptImproperImplementationWarning();
    internal static string get_RenderClientScriptMissingResourceWarning();
    internal static string get_SetDiscoveryLocationDirectoryNotFoundMessage();
}
public class Glimpse.Core.SerializationConverter.CSharpTypeConverter : SerializationConverter`1<Type> {
    private static Dictionary`2<Type, string> PrimitiveTypes;
    private static CSharpTypeConverter();
    public virtual object Convert(Type type);
    private string GetName(Type type);
    private void GetName(Type type, StringBuilder output, Queue`1<Type> genericArgsStack);
    private int GetGenericArgumentCount(Type type);
}
public class Glimpse.Core.SerializationConverter.DateTimeConverter : object {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public sealed virtual IEnumerable`1<Type> get_SupportedTypes();
    public sealed virtual object Convert(object date);
}
public class Glimpse.Core.SerializationConverter.EnumerableOfITimelineMessageConverter : SerializationConverter`1<IEnumerable`1<ITimelineMessage>> {
    [CompilerGeneratedAttribute]
private static Func`2<ITimelineMessage, <>f__AnonymousType8`5<string, DateTime, TimeSpan, TimeSpan, string>> CS$<>9__CachedAnonymousMethodDelegate1;
    public virtual object Convert(IEnumerable`1<ITimelineMessage> obj);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType8`5<string, DateTime, TimeSpan, TimeSpan, string> <Convert>b__0(ITimelineMessage message);
}
public class Glimpse.Core.SerializationConverter.GlimpseMetadataConverter : SerializationConverter`1<GlimpseMetadata> {
    public virtual object Convert(GlimpseMetadata metadata);
}
public class Glimpse.Core.SerializationConverter.GlimpseRequestConverter : SerializationConverter`1<GlimpseRequest> {
    public virtual object Convert(GlimpseRequest request);
}
public class Glimpse.Core.SerializationConverter.GlimpseRequestHeadersConverter : SerializationConverter`1<GlimpseRequestHeaders> {
    public virtual object Convert(GlimpseRequestHeaders request);
}
public class Glimpse.Core.SerializationConverter.ListOfTraceMessageConverter : SerializationConverter`1<IEnumerable`1<ITraceMessage>> {
    public virtual object Convert(IEnumerable`1<ITraceMessage> obj);
    private string GenerateTabs(ITraceMessage item);
}
public class Glimpse.Core.SerializationConverter.MethodInfoConverter : SerializationConverter`1<MethodInfo> {
    public virtual object Convert(MethodInfo methodInfo);
}
public class Glimpse.Core.SerializationConverter.TabMetadataConverter : SerializationConverter`1<TabMetadata> {
    public virtual object Convert(TabMetadata metadata);
}
public class Glimpse.Core.SerializationConverter.TabResultConverter : SerializationConverter`1<TabResult> {
    public virtual object Convert(TabResult result);
}
public class Glimpse.Core.SerializationConverter.TimelineEventModelConverter : SerializationConverter`1<TimelineEventModel> {
    public virtual object Convert(TimelineEventModel model);
}
public class Glimpse.Core.SerializationConverter.TimeSpanConverter : object {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public sealed virtual IEnumerable`1<Type> get_SupportedTypes();
    public sealed virtual object Convert(object date);
}
public class Glimpse.Core.Setting.Initializer : object {
}
public static class Glimpse.Core.Support.NuGetPackage : object {
    public static IDictionary`2<string, string> GetRegisteredPackageVersions();
    public static IList`1<NuGetPackageAttribute> GetRegisteredPackages();
}
public class Glimpse.Core.Support.NuGetPackageDiscoverer : object {
    public static NuGetPackageDiscoveryResult Discover();
}
public class Glimpse.Core.Support.NuGetPackageDiscoveryResult : object {
    [CompilerGeneratedAttribute]
private NuGetPackageAttribute[] <FoundNuGetPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly[] <NonProcessableAssemblies>k__BackingField;
    public NuGetPackageAttribute[] FoundNuGetPackages { get; private set; }
    public Assembly[] NonProcessableAssemblies { get; private set; }
    public NuGetPackageDiscoveryResult(NuGetPackageAttribute[] foundNuGetPackages, Assembly[] nonProcessableAssemblies);
    [CompilerGeneratedAttribute]
public NuGetPackageAttribute[] get_FoundNuGetPackages();
    [CompilerGeneratedAttribute]
private void set_FoundNuGetPackages(NuGetPackageAttribute[] value);
    [CompilerGeneratedAttribute]
public Assembly[] get_NonProcessableAssemblies();
    [CompilerGeneratedAttribute]
private void set_NonProcessableAssemblies(Assembly[] value);
}
public enum Glimpse.Core.Tab.Assist.CodeType : Enum {
    public int value__;
    public static CodeType Bash;
    public static CodeType C;
    public static CodeType Cpp;
    public static CodeType Csharp;
    public static CodeType Html;
    public static CodeType Java;
    public static CodeType Javascript;
    public static CodeType Python;
    public static CodeType Ruby;
    public static CodeType Shell;
    public static CodeType Sql;
    public static CodeType Xml;
    public static CodeType Xsl;
}
public static class Glimpse.Core.Tab.Assist.CodeTypeConverter : object {
    private static IDictionary`2<CodeType, string> Map;
    private static CodeTypeConverter();
    public static string Convert(CodeType codeType);
}
public static class Glimpse.Core.Tab.Assist.Formats : object {
    public static string Strong;
    public static string Emphasis;
    public static string Raw;
    public static string Sub;
    public static string Underline;
}
public static class Glimpse.Core.Tab.Assist.FormattingKeywords : object {
    public static string Error;
    public static string Fail;
    public static string Info;
    public static string Loading;
    public static string Ms;
    public static string Quiet;
    public static string Selected;
    public static string Warn;
}
public interface Glimpse.Core.Tab.Assist.ITabBuild {
    public abstract virtual object Build();
}
public interface Glimpse.Core.Tab.Assist.ITabObjectItem {
    public abstract virtual ITabStyleValue Value(object value);
}
public interface Glimpse.Core.Tab.Assist.ITabStyleRow {
    public abstract virtual void ApplyRowStyle(string style);
}
public interface Glimpse.Core.Tab.Assist.ITabStyleValue {
    public abstract virtual void ApplyValueStyle(string format);
}
public interface Glimpse.Core.Tab.Assist.ITabStyleValue`1 {
    public abstract virtual T ApplyValueStyle(string format);
}
[ExtensionAttribute]
public static class Glimpse.Core.Tab.Assist.Plugin : object {
    public static TabSection Create(String[] headers);
    [ExtensionAttribute]
public static TabSection Section(TabSection current, string sectionName, Action`1<TabSection> section);
    [ExtensionAttribute]
public static TabSection Section(TabSection current, string sectionName, TabSection section);
}
[ExtensionAttribute]
public static class Glimpse.Core.Tab.Assist.StringFormattingExtensions : object {
    [ExtensionAttribute]
public static string Strong(string value);
    [ExtensionAttribute]
public static string StrongIf(string value, bool condition);
    [ExtensionAttribute]
public static string Emphasis(string value);
    [ExtensionAttribute]
public static string EmphasisIf(string value, bool condition);
    [ExtensionAttribute]
public static string Raw(string value);
    [ExtensionAttribute]
public static string RawIf(string value, bool condition);
    [ExtensionAttribute]
public static string Sub(string value);
    [ExtensionAttribute]
public static string SubIf(string value, bool condition);
    [ExtensionAttribute]
public static string Underline(string value);
    [ExtensionAttribute]
public static string UnderlineIf(string value, bool condition);
    [ExtensionAttribute]
public static string FormatWith(string format, Object[] arguments);
}
public class Glimpse.Core.Tab.Assist.TabLayout : object {
    private List`1<TabLayoutRow> rows;
    private Dictionary`2<string, TabLayout> cells;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, TabLayout>, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, TabLayout>, <>f__AnonymousTypea`1<object>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<TabLayoutRow, object> CS$<>9__CachedAnonymousMethodDelegate5;
    public IEnumerable`1<TabLayoutRow> Rows { get; }
    public IEnumerable`1<TabLayoutRow> get_Rows();
    public static TabLayout Create();
    public static TabLayout Create(Action`1<TabLayout> layout);
    public TabLayout Row(Action`1<TabLayoutRow> row);
    public TabLayout Cell(string target, TabLayout layout);
    public sealed virtual object Build();
    [CompilerGeneratedAttribute]
private static string <Build>b__0(KeyValuePair`2<string, TabLayout> x);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypea`1<object> <Build>b__1(KeyValuePair`2<string, TabLayout> x);
    [CompilerGeneratedAttribute]
private static object <Build>b__2(TabLayoutRow r);
}
public class Glimpse.Core.Tab.Assist.TabLayoutCell : object {
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Align>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PaddingLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PaddingRight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ForceFull>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pre>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Post>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public object Data { get; private set; }
    public object Layout { get; private set; }
    public Nullable`1<bool> Key { get; private set; }
    public Nullable`1<bool> IsCode { get; private set; }
    public string CodeType { get; private set; }
    public string Align { get; private set; }
    public string Width { get; private set; }
    public string PaddingLeft { get; private set; }
    public string PaddingRight { get; private set; }
    public Nullable`1<int> Span { get; private set; }
    public string ClassName { get; private set; }
    public Nullable`1<bool> ForceFull { get; private set; }
    public Nullable`1<int> Limit { get; private set; }
    public string Pre { get; private set; }
    public string Post { get; private set; }
    public bool MinDisplay { get; private set; }
    public string Title { get; private set; }
    public TabLayoutCell(int cell);
    public TabLayoutCell(string format);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(object value);
    [CompilerGeneratedAttribute]
public object get_Layout();
    [CompilerGeneratedAttribute]
private void set_Layout(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCode();
    [CompilerGeneratedAttribute]
private void set_IsCode(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_CodeType();
    [CompilerGeneratedAttribute]
private void set_CodeType(string value);
    [CompilerGeneratedAttribute]
public string get_Align();
    [CompilerGeneratedAttribute]
private void set_Align(string value);
    [CompilerGeneratedAttribute]
public string get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(string value);
    [CompilerGeneratedAttribute]
public string get_PaddingLeft();
    [CompilerGeneratedAttribute]
private void set_PaddingLeft(string value);
    [CompilerGeneratedAttribute]
public string get_PaddingRight();
    [CompilerGeneratedAttribute]
private void set_PaddingRight(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
private void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ForceFull();
    [CompilerGeneratedAttribute]
private void set_ForceFull(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Limit();
    [CompilerGeneratedAttribute]
private void set_Limit(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Pre();
    [CompilerGeneratedAttribute]
private void set_Pre(string value);
    [CompilerGeneratedAttribute]
public string get_Post();
    [CompilerGeneratedAttribute]
private void set_Post(string value);
    [CompilerGeneratedAttribute]
public bool get_MinDisplay();
    [CompilerGeneratedAttribute]
private void set_MinDisplay(bool value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    public TabLayoutCell Format(string format);
    public TabLayoutCell SetLayout(TabLayout layout);
    public TabLayoutCell SetLayout(Action`1<TabLayout> layout);
    public TabLayoutCell AsKey();
    public TabLayoutCell AsCode(CodeType codeType);
    public TabLayoutCell AlignRight();
    public TabLayoutCell WidthInPixels(int pixels);
    public TabLayoutCell WidthInPercent(int percent);
    public TabLayoutCell PaddingLeftInPixels(int pixels);
    public TabLayoutCell PaddingLeftInPercent(int percent);
    public TabLayoutCell PaddingRightInPixels(int pixels);
    public TabLayoutCell PaddingRightInPercent(int percent);
    public TabLayoutCell SpanColumns(int rows);
    public TabLayoutCell Class(string className);
    public TabLayoutCell DisablePreview();
    public TabLayoutCell LimitTo(int rows);
    public TabLayoutCell Prefix(string prefix);
    public TabLayoutCell Suffix(string suffix);
    public TabLayoutCell WithTitle(string title);
    public TabLayoutCell AsMinimalDisplay();
    public sealed virtual object Build();
}
public class Glimpse.Core.Tab.Assist.TabLayoutRow : object {
    private List`1<TabLayoutCell> cells;
    [CompilerGeneratedAttribute]
private static Func`2<TabLayoutCell, object> CS$<>9__CachedAnonymousMethodDelegate1;
    public TabLayoutCell Cell(int cell);
    public TabLayoutCell Cell(string format);
    public sealed virtual object Build();
    [CompilerGeneratedAttribute]
private static object <Build>b__0(TabLayoutCell x);
}
public class Glimpse.Core.Tab.Assist.TabObject : object {
    private IList`1<TabObjectRow> rows;
    public TabObjectRow AddRow();
    public sealed virtual object Build();
}
public class Glimpse.Core.Tab.Assist.TabObjectRow : object {
    [CompilerGeneratedAttribute]
private object <BaseKey>k__BackingField;
    [CompilerGeneratedAttribute]
private object <BaseValue>k__BackingField;
    internal object BaseKey { get; internal set; }
    internal object BaseValue { get; internal set; }
    [CompilerGeneratedAttribute]
internal object get_BaseKey();
    [CompilerGeneratedAttribute]
internal void set_BaseKey(object value);
    [CompilerGeneratedAttribute]
internal object get_BaseValue();
    [CompilerGeneratedAttribute]
internal void set_BaseValue(object value);
    public ITabObjectItem Key(object value);
    public sealed virtual ITabStyleValue Value(object value);
    public sealed virtual void ApplyValueStyle(string format);
}
[ExtensionAttribute]
public static class Glimpse.Core.Tab.Assist.TabRowFormattingExtensions : object {
    [ExtensionAttribute]
public static T Strong(ITabStyleValue`1<T> sectionRow);
    [ExtensionAttribute]
public static T StrongIf(ITabStyleValue`1<T> sectionRow, bool condition);
    [ExtensionAttribute]
public static T Emphasis(ITabStyleValue`1<T> sectionRow);
    [ExtensionAttribute]
public static T EmphasisIf(ITabStyleValue`1<T> sectionRow, bool condition);
    [ExtensionAttribute]
public static T Raw(ITabStyleValue`1<T> sectionRow);
    [ExtensionAttribute]
public static T RawIf(ITabStyleValue`1<T> sectionRow, bool condition);
    [ExtensionAttribute]
public static T Sub(ITabStyleValue`1<T> sectionRow);
    [ExtensionAttribute]
public static T SubIf(ITabStyleValue`1<T> sectionRow, bool condition);
    [ExtensionAttribute]
public static T Underline(ITabStyleValue`1<T> sectionRow);
    [ExtensionAttribute]
public static T UnderlineIf(ITabStyleValue`1<T> sectionRow, bool condition);
    [ExtensionAttribute]
public static void Strong(ITabStyleValue sectionRow);
    [ExtensionAttribute]
public static void StrongIf(ITabStyleValue sectionRow, bool condition);
    [ExtensionAttribute]
public static void Emphasis(ITabStyleValue sectionRow);
    [ExtensionAttribute]
public static void EmphasisIf(ITabStyleValue sectionRow, bool condition);
    [ExtensionAttribute]
public static void Raw(ITabStyleValue sectionRow);
    [ExtensionAttribute]
public static void RawIf(ITabStyleValue sectionRow, bool condition);
    [ExtensionAttribute]
public static void Sub(ITabStyleValue sectionRow);
    [ExtensionAttribute]
public static void SubIf(ITabStyleValue sectionRow, bool condition);
    [ExtensionAttribute]
public static void Underline(ITabStyleValue sectionRow);
    [ExtensionAttribute]
public static void UnderlineIf(ITabStyleValue sectionRow, bool condition);
    [ExtensionAttribute]
public static void Error(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void ErrorIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Fail(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void FailIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Info(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void InfoIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Loading(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void LoadingIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Ms(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void MsIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Quiet(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void QuietIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Selected(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void SelectedIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Warn(ITabStyleRow sectionRow);
    [ExtensionAttribute]
public static void WarnIf(ITabStyleRow sectionRow, bool condition);
    [ExtensionAttribute]
public static void Style(ITabStyleRow sectionRow, string style);
    [ExtensionAttribute]
public static void StyleIf(ITabStyleRow sectionRow, string style, bool condition);
}
public class Glimpse.Core.Tab.Assist.TabSection : object {
    private List`1<TabSectionRow> rows;
    [CompilerGeneratedAttribute]
private static Func`2<TabSectionRow, object> CS$<>9__CachedAnonymousMethodDelegate1;
    public IEnumerable`1<TabSectionRow> Rows { get; }
    public TabSection(String[] headers);
    public IEnumerable`1<TabSectionRow> get_Rows();
    public TabSectionRow AddRow();
    public sealed virtual object Build();
    [CompilerGeneratedAttribute]
private static object <Build>b__0(TabSectionRow r);
}
public class Glimpse.Core.Tab.Assist.TabSectionColumn : object {
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public object Data { get; private set; }
    public TabSectionColumn(object columnData);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(object value);
    public sealed virtual object Build();
    internal void OverrideData(object columnData);
}
public class Glimpse.Core.Tab.Assist.TabSectionRow : object {
    private List`1<TabSectionColumn> columns;
    [CompilerGeneratedAttribute]
private static Func`2<TabSectionColumn, object> CS$<>9__CachedAnonymousMethodDelegate1;
    public IEnumerable`1<TabSectionColumn> Columns { get; }
    public IEnumerable`1<TabSectionColumn> get_Columns();
    public TabSectionRow Column(object columnData);
    public sealed virtual object Build();
    public sealed virtual TabSectionRow ApplyValueStyle(string format);
    public sealed virtual void ApplyRowStyle(string style);
    [CompilerGeneratedAttribute]
private static object <Build>b__0(TabSectionColumn x);
}
public class Glimpse.Core.Tab.Timeline : TabBase {
    [CompilerGeneratedAttribute]
private static Func`2<ITimelineMessage, TimeSpan> CS$<>9__CachedAnonymousMethodDelegate2;
    public string Name { get; }
    public string Key { get; }
    public string DocumentationUri { get; }
    public virtual string get_Name();
    public sealed virtual string get_Key();
    public sealed virtual string get_DocumentationUri();
    public sealed virtual void Setup(ITabSetupContext context);
    public virtual object GetData(ITabContext context);
    [CompilerGeneratedAttribute]
private static TimeSpan <GetData>b__1(ITimelineMessage x);
}
public class Glimpse.Core.Tab.Trace : object {
    public static string TabKey;
    private static object Layout;
    [CompilerGeneratedAttribute]
private static Action`1<TabLayoutRow> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Name { get; }
    public string DocumentationUri { get; }
    public RuntimeEvent ExecuteOn { get; }
    public Type RequestContextType { get; }
    public string Key { get; }
    private static Trace();
    public sealed virtual string get_Name();
    public sealed virtual string get_DocumentationUri();
    public sealed virtual RuntimeEvent get_ExecuteOn();
    public sealed virtual Type get_RequestContextType();
    public sealed virtual string get_Key();
    public sealed virtual object GetLayout();
    public sealed virtual object GetData(ITabContext context);
    public sealed virtual void Setup(ITabSetupContext context);
    [CompilerGeneratedAttribute]
private static void <.cctor>b__0(TabLayoutRow r);
}
public class Glimpse.Core.TraceListener : TraceListener {
    [ThreadStaticAttribute]
private static Stopwatch fromLastWatch;
    private IMessageBroker messageBroker;
    [CompilerGeneratedAttribute]
private Func`1<IExecutionTimer> <TimerStrategy>k__BackingField;
    internal IMessageBroker MessageBroker { get; internal set; }
    internal Func`1<IExecutionTimer> TimerStrategy { get; internal set; }
    public TraceListener(string initializeData);
    public TraceListener(IMessageBroker messageBroker, Func`1<IExecutionTimer> timerStrategy);
    internal IMessageBroker get_MessageBroker();
    internal void set_MessageBroker(IMessageBroker value);
    [CompilerGeneratedAttribute]
internal Func`1<IExecutionTimer> get_TimerStrategy();
    [CompilerGeneratedAttribute]
internal void set_TimerStrategy(Func`1<IExecutionTimer> value);
    public virtual void Write(object o);
    public virtual void Write(string message);
    public virtual void Write(object o, string category);
    public virtual void Write(string message, string category);
    public virtual void WriteLine(object o);
    public virtual void WriteLine(string message);
    public virtual void WriteLine(object o, string category);
    public virtual void WriteLine(string message, string category);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    private TimeSpan CalculateFromLast(IExecutionTimer timer);
    private void InternalWrite(string message, string category);
    private string WriteHeader(string source, int id);
    private string WriteFooter(TraceEventCache eventCache);
    private bool IsEnabled(TraceOptions opts);
    private string DeriveCategory(string category);
    private string DeriveCategory(TraceEventType type);
}
public static class Glimpse.Settings : object {
    public static Initializer Initialize;
    private static Settings();
}
[ObsoleteAttribute("This class has been deprecated. Please use Microsoft.Security.Application.Encoder instead.")]
internal static class Microsoft.Security.Application.AntiXss : object {
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.HtmlEncode() instead.")]
public static string HtmlEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.HtmlAttributeEncode() instead.")]
public static string HtmlAttributeEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.UrlEncode() instead.")]
public static string UrlEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.UrlEncode() instead.")]
public static string UrlEncode(string input, int codepage);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.XmlEncode() instead.")]
public static string XmlEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.XmlAttributeEncode() instead.")]
public static string XmlAttributeEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.JavaScriptEncode() instead.")]
public static string JavaScriptEncode(string input);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.JavaScriptEncode() instead.")]
public static string JavaScriptEncode(string input, bool flagforQuote);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.VisualBasicScriptEncode() instead.")]
public static string VisualBasicScriptEncode(string input);
}
internal class Microsoft.Security.Application.AntiXssEncoder : HttpEncoder {
    protected virtual void HtmlEncode(string value, TextWriter output);
    protected virtual void HtmlAttributeEncode(string value, TextWriter output);
    protected virtual Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    protected virtual string UrlPathEncode(string value);
}
internal static class Microsoft.Security.Application.CodeCharts.CodeChartHelper : object {
    internal static IEnumerable`1<int> GetRange(int min, int max, Func`2<int, bool> exclusionFilter);
    internal static IEnumerable`1<int> GetRange(int min, int max);
}
internal static class Microsoft.Security.Application.CodeCharts.Lower : object {
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate27;
    public static bool IsFlagSet(LowerCodeCharts flags, LowerCodeCharts flagToCheck);
    public static IEnumerable BasicLatin();
    public static IEnumerable Latin1Supplement();
    public static IEnumerable LatinExtendedA();
    public static IEnumerable LatinExtendedB();
    public static IEnumerable IpaExtensions();
    public static IEnumerable SpacingModifierLetters();
    public static IEnumerable CombiningDiacriticalMarks();
    public static IEnumerable GreekAndCoptic();
    public static IEnumerable Cyrillic();
    public static IEnumerable CyrillicSupplement();
    public static IEnumerable Armenian();
    public static IEnumerable Hebrew();
    public static IEnumerable Arabic();
    public static IEnumerable Syriac();
    public static IEnumerable ArabicSupplement();
    public static IEnumerable Thaana();
    public static IEnumerable Nko();
    public static IEnumerable Samaritan();
    public static IEnumerable Devanagari();
    public static IEnumerable Bengali();
    public static IEnumerable Gurmukhi();
    public static IEnumerable Gujarati();
    public static IEnumerable Oriya();
    public static IEnumerable Tamil();
    public static IEnumerable Telugu();
    public static IEnumerable Kannada();
    public static IEnumerable Malayalam();
    public static IEnumerable Sinhala();
    public static IEnumerable Thai();
    public static IEnumerable Lao();
    public static IEnumerable Tibetan();
    [CompilerGeneratedAttribute]
private static bool <Latin1Supplement>b__0(int i);
    [CompilerGeneratedAttribute]
private static bool <GreekAndCoptic>b__2(int i);
    [CompilerGeneratedAttribute]
private static bool <Armenian>b__4(int i);
    [CompilerGeneratedAttribute]
private static bool <Hebrew>b__6(int i);
    [CompilerGeneratedAttribute]
private static bool <Arabic>b__8(int i);
    [CompilerGeneratedAttribute]
private static bool <Syriac>b__a(int i);
    [CompilerGeneratedAttribute]
private static bool <Samaritan>b__c(int i);
    [CompilerGeneratedAttribute]
private static bool <Devanagari>b__e(int i);
    [CompilerGeneratedAttribute]
private static bool <Bengali>b__10(int i);
    [CompilerGeneratedAttribute]
private static bool <Gurmukhi>b__12(int i);
    [CompilerGeneratedAttribute]
private static bool <Gujarati>b__14(int i);
    [CompilerGeneratedAttribute]
private static bool <Oriya>b__16(int i);
    [CompilerGeneratedAttribute]
private static bool <Tamil>b__18(int i);
    [CompilerGeneratedAttribute]
private static bool <Telugu>b__1a(int i);
    [CompilerGeneratedAttribute]
private static bool <Kannada>b__1c(int i);
    [CompilerGeneratedAttribute]
private static bool <Malayalam>b__1e(int i);
    [CompilerGeneratedAttribute]
private static bool <Sinhala>b__20(int i);
    [CompilerGeneratedAttribute]
private static bool <Thai>b__22(int i);
    [CompilerGeneratedAttribute]
private static bool <Lao>b__24(int i);
    [CompilerGeneratedAttribute]
private static bool <Tibetan>b__26(int i);
}
internal static class Microsoft.Security.Application.CodeCharts.LowerMiddle : object {
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    public static bool IsFlagSet(LowerMidCodeCharts flags, LowerMidCodeCharts flagToCheck);
    public static IEnumerable Myanmar();
    public static IEnumerable Georgian();
    public static IEnumerable HangulJamo();
    public static IEnumerable Ethiopic();
    public static IEnumerable EthiopicSupplement();
    public static IEnumerable Cherokee();
    public static IEnumerable UnifiedCanadianAboriginalSyllabics();
    public static IEnumerable Ogham();
    public static IEnumerable Runic();
    public static IEnumerable Tagalog();
    public static IEnumerable Hanunoo();
    public static IEnumerable Buhid();
    public static IEnumerable Tagbanwa();
    public static IEnumerable Khmer();
    public static IEnumerable Mongolian();
    public static IEnumerable UnifiedCanadianAboriginalSyllabicsExtended();
    public static IEnumerable Limbu();
    public static IEnumerable TaiLe();
    public static IEnumerable NewTaiLue();
    public static IEnumerable KhmerSymbols();
    public static IEnumerable Buginese();
    public static IEnumerable TaiTham();
    public static IEnumerable Balinese();
    public static IEnumerable Sudanese();
    public static IEnumerable Lepcha();
    public static IEnumerable OlChiki();
    public static IEnumerable VedicExtensions();
    public static IEnumerable PhoneticExtensions();
    public static IEnumerable PhoneticExtensionsSupplement();
    public static IEnumerable CombiningDiacriticalMarksSupplement();
    public static IEnumerable LatinExtendedAdditional();
    [CompilerGeneratedAttribute]
private static bool <Georgian>b__0(int i);
    [CompilerGeneratedAttribute]
private static bool <Ethiopic>b__2(int i);
    [CompilerGeneratedAttribute]
private static bool <Tagalog>b__4(int i);
    [CompilerGeneratedAttribute]
private static bool <Tagbanwa>b__6(int i);
    [CompilerGeneratedAttribute]
private static bool <Khmer>b__8(int i);
    [CompilerGeneratedAttribute]
private static bool <Mongolian>b__a(int i);
    [CompilerGeneratedAttribute]
private static bool <Limbu>b__c(int i);
    [CompilerGeneratedAttribute]
private static bool <TaiLe>b__e(int i);
    [CompilerGeneratedAttribute]
private static bool <NewTaiLue>b__10(int i);
    [CompilerGeneratedAttribute]
private static bool <Buginese>b__12(int i);
    [CompilerGeneratedAttribute]
private static bool <TaiTham>b__14(int i);
    [CompilerGeneratedAttribute]
private static bool <Balinese>b__16(int i);
    [CompilerGeneratedAttribute]
private static bool <Sudanese>b__18(int i);
    [CompilerGeneratedAttribute]
private static bool <Lepcha>b__1a(int i);
    [CompilerGeneratedAttribute]
private static bool <CombiningDiacriticalMarksSupplement>b__1c(int i);
}
internal static class Microsoft.Security.Application.CodeCharts.Middle : object {
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    public static bool IsFlagSet(MidCodeCharts flags, MidCodeCharts flagToCheck);
    public static IEnumerable GreekExtended();
    public static IEnumerable GeneralPunctuation();
    public static IEnumerable SuperscriptsAndSubscripts();
    public static IEnumerable CurrencySymbols();
    public static IEnumerable CombiningDiacriticalMarksForSymbols();
    public static IEnumerable LetterlikeSymbols();
    public static IEnumerable NumberForms();
    public static IEnumerable Arrows();
    public static IEnumerable MathematicalOperators();
    public static IEnumerable MiscellaneousTechnical();
    public static IEnumerable ControlPictures();
    public static IEnumerable OpticalCharacterRecognition();
    public static IEnumerable EnclosedAlphanumerics();
    public static IEnumerable BoxDrawing();
    public static IEnumerable BlockElements();
    public static IEnumerable GeometricShapes();
    public static IEnumerable MiscellaneousSymbols();
    public static IEnumerable Dingbats();
    public static IEnumerable MiscellaneousMathematicalSymbolsA();
    public static IEnumerable SupplementalArrowsA();
    public static IEnumerable BraillePatterns();
    public static IEnumerable SupplementalArrowsB();
    public static IEnumerable MiscellaneousMathematicalSymbolsB();
    public static IEnumerable SupplementalMathematicalOperators();
    public static IEnumerable MiscellaneousSymbolsAndArrows();
    public static IEnumerable Glagolitic();
    public static IEnumerable LatinExtendedC();
    public static IEnumerable Coptic();
    public static IEnumerable GeorgianSupplement();
    public static IEnumerable Tifinagh();
    public static IEnumerable EthiopicExtended();
    [CompilerGeneratedAttribute]
private static bool <GreekExtended>b__0(int i);
    [CompilerGeneratedAttribute]
private static bool <GeneralPunctuation>b__2(int i);
    [CompilerGeneratedAttribute]
private static bool <SuperscriptsAndSubscripts>b__4(int i);
    [CompilerGeneratedAttribute]
private static bool <MiscellaneousSymbols>b__6(int i);
    [CompilerGeneratedAttribute]
private static bool <Dingbats>b__8(int i);
    [CompilerGeneratedAttribute]
private static bool <MiscellaneousMathematicalSymbolsA>b__a(int i);
    [CompilerGeneratedAttribute]
private static bool <MiscellaneousSymbolsAndArrows>b__c(int i);
    [CompilerGeneratedAttribute]
private static bool <Glagolitic>b__e(int i);
    [CompilerGeneratedAttribute]
private static bool <Coptic>b__10(int i);
    [CompilerGeneratedAttribute]
private static bool <Tifinagh>b__12(int i);
    [CompilerGeneratedAttribute]
private static bool <EthiopicExtended>b__14(int i);
}
internal static class Microsoft.Security.Application.CodeCharts.Upper : object {
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    public static bool IsFlagSet(UpperCodeCharts flags, UpperCodeCharts flagToCheck);
    public static IEnumerable DevanagariExtended();
    public static IEnumerable KayahLi();
    public static IEnumerable Rejang();
    public static IEnumerable HangulJamoExtendedA();
    public static IEnumerable Javanese();
    public static IEnumerable Cham();
    public static IEnumerable MyanmarExtendedA();
    public static IEnumerable TaiViet();
    public static IEnumerable MeeteiMayek();
    public static IEnumerable HangulSyllables();
    public static IEnumerable HangulJamoExtendedB();
    public static IEnumerable CjkCompatibilityIdeographs();
    public static IEnumerable AlphabeticPresentationForms();
    public static IEnumerable ArabicPresentationFormsA();
    public static IEnumerable VariationSelectors();
    public static IEnumerable VerticalForms();
    public static IEnumerable CombiningHalfMarks();
    public static IEnumerable CjkCompatibilityForms();
    public static IEnumerable SmallFormVariants();
    public static IEnumerable ArabicPresentationFormsB();
    public static IEnumerable HalfWidthAndFullWidthForms();
    public static IEnumerable Specials();
    [CompilerGeneratedAttribute]
private static bool <Javanese>b__0(int i);
    [CompilerGeneratedAttribute]
private static bool <Cham>b__2(int i);
    [CompilerGeneratedAttribute]
private static bool <MeeteiMayek>b__4(int i);
    [CompilerGeneratedAttribute]
private static bool <HangulJamoExtendedB>b__6(int i);
    [CompilerGeneratedAttribute]
private static bool <CjkCompatibilityIdeographs>b__8(int i);
    [CompilerGeneratedAttribute]
private static bool <AlphabeticPresentationForms>b__a(int i);
    [CompilerGeneratedAttribute]
private static bool <ArabicPresentationFormsA>b__c(int i);
    [CompilerGeneratedAttribute]
private static bool <SmallFormVariants>b__e(int i);
    [CompilerGeneratedAttribute]
private static bool <ArabicPresentationFormsB>b__10(int i);
    [CompilerGeneratedAttribute]
private static bool <HalfWidthAndFullWidthForms>b__12(int i);
}
internal static class Microsoft.Security.Application.CodeCharts.UpperMiddle : object {
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    public static bool IsFlagSet(UpperMidCodeCharts flags, UpperMidCodeCharts flagToCheck);
    public static IEnumerable CyrillicExtendedA();
    public static IEnumerable SupplementalPunctuation();
    public static IEnumerable CjkRadicalsSupplement();
    public static IEnumerable KangxiRadicals();
    public static IEnumerable IdeographicDescriptionCharacters();
    public static IEnumerable CjkSymbolsAndPunctuation();
    public static IEnumerable Hiragana();
    public static IEnumerable Katakana();
    public static IEnumerable Bopomofo();
    public static IEnumerable HangulCompatibilityJamo();
    public static IEnumerable Kanbun();
    public static IEnumerable BopomofoExtended();
    public static IEnumerable CjkStrokes();
    public static IEnumerable KatakanaPhoneticExtensions();
    public static IEnumerable EnclosedCjkLettersAndMonths();
    public static IEnumerable CjkCompatibility();
    public static IEnumerable CjkUnifiedIdeographsExtensionA();
    public static IEnumerable YijingHexagramSymbols();
    public static IEnumerable CjkUnifiedIdeographs();
    public static IEnumerable YiSyllables();
    public static IEnumerable YiRadicals();
    public static IEnumerable Lisu();
    public static IEnumerable Vai();
    public static IEnumerable CyrillicExtendedB();
    public static IEnumerable Bamum();
    public static IEnumerable ModifierToneLetters();
    public static IEnumerable LatinExtendedD();
    public static IEnumerable SylotiNagri();
    public static IEnumerable CommonIndicNumberForms();
    public static IEnumerable Phagspa();
    public static IEnumerable Saurashtra();
    [CompilerGeneratedAttribute]
private static bool <CjkRadicalsSupplement>b__0(int i);
    [CompilerGeneratedAttribute]
private static bool <Hiragana>b__2(int i);
    [CompilerGeneratedAttribute]
private static bool <EnclosedCjkLettersAndMonths>b__4(int i);
    [CompilerGeneratedAttribute]
private static bool <CyrillicExtendedB>b__6(int i);
    [CompilerGeneratedAttribute]
private static bool <Saurashtra>b__8(int i);
}
internal static class Microsoft.Security.Application.CssEncoder : object {
    private static char UnicodeReplacementCharacter;
    private static ReaderWriterLockSlim SyncLock;
    private static Char[][] characterValues;
    private static CssEncoder();
    private static void AcquireReadLock();
    private static void ReleaseReadLock();
    private static void AcquireWriteLock();
    private static void ReleaseWriteLock();
    internal static string Encode(string input);
    private static void InitialiseSafeList();
    private static IEnumerable CssSafeList();
}
internal static class Microsoft.Security.Application.Encoder : object {
    private static string VbScriptEmptyString;
    private static string JavaScriptEmptyString;
    private static Char[][] SafeListCodes;
    private static Encoder();
    public static string LdapFilterEncode(string input);
    public static string LdapDistinguishedNameEncode(string input);
    public static string LdapDistinguishedNameEncode(string input, bool useInitialCharacterRules, bool useFinalCharacterRule);
    [ObsoleteAttribute("This method has been deprecated. Please use Encoder.LdapFilterEncode() instead.")]
public static string LdapEncode(string input);
    public static string CssEncode(string input);
    public static string HtmlEncode(string input);
    public static string HtmlEncode(string input, bool useNamedEntities);
    public static string HtmlAttributeEncode(string input);
    public static string UrlEncode(string input);
    public static string HtmlFormUrlEncode(string input);
    public static string UrlEncode(string input, int codePage);
    public static string HtmlFormUrlEncode(string input, int codePage);
    public static string UrlEncode(string input, Encoding inputEncoding);
    public static string HtmlFormUrlEncode(string input, Encoding inputEncoding);
    public static string UrlPathEncode(string input);
    public static string XmlEncode(string input);
    public static string XmlAttributeEncode(string input);
    public static string JavaScriptEncode(string input);
    public static string JavaScriptEncode(string input, bool emitQuotes);
    public static string VisualBasicScriptEncode(string input);
    private static Char[][] InitializeSafeList();
}
internal enum Microsoft.Security.Application.EncodingType : Enum {
    public int value__;
    public static EncodingType QueryString;
    public static EncodingType HtmlForm;
}
internal static class Microsoft.Security.Application.HtmlParameterEncoder : object {
    private static ReaderWriterLockSlim SyncLock;
    private static Char[] QueryStringSpace;
    private static Char[] FormStringSpace;
    private static Char[][] characterValues;
    private static HtmlParameterEncoder();
    private static void AcquireReadLock();
    private static void ReleaseReadLock();
    private static void AcquireWriteLock();
    private static void ReleaseWriteLock();
    internal static string QueryStringParameterEncode(string s, Encoding encoding);
    internal static string FormStringParameterEncode(string s, Encoding encoding);
    private static string FormQueryEncode(string s, Encoding encoding, EncodingType encodingType, Char[][] safeList);
    private static void InitialiseParameterSafeList();
    private static IEnumerable UrlParameterSafeList();
}
internal static class Microsoft.Security.Application.LdapEncoder : object {
    private static ReaderWriterLockSlim SyncLock;
    private static Char[][] filterCharacterValues;
    private static Char[][] distinguishedNameCharacterValues;
    private static LdapEncoder();
    private static void AcquireReadLock();
    private static void ReleaseReadLock();
    private static void AcquireWriteLock();
    private static void ReleaseWriteLock();
    internal static string FilterEncode(string input);
    internal static string DistinguishedNameEncode(string input, bool useInitialCharacterRules, bool useFinalCharacterRule);
    private static void InitialiseFilterSafeList();
    private static IEnumerable FilterEncodingSafeList();
    private static void InitialiseDistinguishedNameSafeList();
    private static IEnumerable DistinguishedNameSafeList();
    private static void EscapeDistinguisedNameCharacter(char c);
}
[FlagsAttribute]
internal enum Microsoft.Security.Application.LowerCodeCharts : Enum {
    public long value__;
    public static LowerCodeCharts None;
    public static LowerCodeCharts BasicLatin;
    public static LowerCodeCharts C1ControlsAndLatin1Supplement;
    public static LowerCodeCharts LatinExtendedA;
    public static LowerCodeCharts LatinExtendedB;
    public static LowerCodeCharts IpaExtensions;
    public static LowerCodeCharts SpacingModifierLetters;
    public static LowerCodeCharts CombiningDiacriticalMarks;
    public static LowerCodeCharts GreekAndCoptic;
    public static LowerCodeCharts Cyrillic;
    public static LowerCodeCharts CyrillicSupplement;
    public static LowerCodeCharts Armenian;
    public static LowerCodeCharts Hebrew;
    public static LowerCodeCharts Arabic;
    public static LowerCodeCharts Syriac;
    public static LowerCodeCharts ArabicSupplement;
    public static LowerCodeCharts Thaana;
    public static LowerCodeCharts Nko;
    public static LowerCodeCharts Samaritan;
    public static LowerCodeCharts Devanagari;
    public static LowerCodeCharts Bengali;
    public static LowerCodeCharts Gurmukhi;
    public static LowerCodeCharts Gujarati;
    public static LowerCodeCharts Oriya;
    public static LowerCodeCharts Tamil;
    public static LowerCodeCharts Telugu;
    public static LowerCodeCharts Kannada;
    public static LowerCodeCharts Malayalam;
    public static LowerCodeCharts Sinhala;
    public static LowerCodeCharts Thai;
    public static LowerCodeCharts Lao;
    public static LowerCodeCharts Tibetan;
    public static LowerCodeCharts Default;
}
[FlagsAttribute]
internal enum Microsoft.Security.Application.LowerMidCodeCharts : Enum {
    public long value__;
    public static LowerMidCodeCharts None;
    public static LowerMidCodeCharts Myanmar;
    public static LowerMidCodeCharts Georgian;
    public static LowerMidCodeCharts HangulJamo;
    public static LowerMidCodeCharts Ethiopic;
    public static LowerMidCodeCharts EthiopicSupplement;
    public static LowerMidCodeCharts Cherokee;
    public static LowerMidCodeCharts UnifiedCanadianAboriginalSyllabics;
    public static LowerMidCodeCharts Ogham;
    public static LowerMidCodeCharts Runic;
    public static LowerMidCodeCharts Tagalog;
    public static LowerMidCodeCharts Hanunoo;
    public static LowerMidCodeCharts Buhid;
    public static LowerMidCodeCharts Tagbanwa;
    public static LowerMidCodeCharts Khmer;
    public static LowerMidCodeCharts Mongolian;
    public static LowerMidCodeCharts UnifiedCanadianAboriginalSyllabicsExtended;
    public static LowerMidCodeCharts Limbu;
    public static LowerMidCodeCharts TaiLe;
    public static LowerMidCodeCharts NewTaiLue;
    public static LowerMidCodeCharts KhmerSymbols;
    public static LowerMidCodeCharts Buginese;
    public static LowerMidCodeCharts TaiTham;
    public static LowerMidCodeCharts Balinese;
    public static LowerMidCodeCharts Sudanese;
    public static LowerMidCodeCharts Lepcha;
    public static LowerMidCodeCharts OlChiki;
    public static LowerMidCodeCharts VedicExtensions;
    public static LowerMidCodeCharts PhoneticExtensions;
    public static LowerMidCodeCharts PhoneticExtensionsSupplement;
    public static LowerMidCodeCharts CombiningDiacriticalMarksSupplement;
    public static LowerMidCodeCharts LatinExtendedAdditional;
}
[FlagsAttribute]
internal enum Microsoft.Security.Application.MidCodeCharts : Enum {
    public long value__;
    public static MidCodeCharts None;
    public static MidCodeCharts GreekExtended;
    public static MidCodeCharts GeneralPunctuation;
    public static MidCodeCharts SuperscriptsAndSubscripts;
    public static MidCodeCharts CurrencySymbols;
    public static MidCodeCharts CombiningDiacriticalMarksForSymbols;
    public static MidCodeCharts LetterlikeSymbols;
    public static MidCodeCharts NumberForms;
    public static MidCodeCharts Arrows;
    public static MidCodeCharts MathematicalOperators;
    public static MidCodeCharts MiscellaneousTechnical;
    public static MidCodeCharts ControlPictures;
    public static MidCodeCharts OpticalCharacterRecognition;
    public static MidCodeCharts EnclosedAlphanumerics;
    public static MidCodeCharts BoxDrawing;
    public static MidCodeCharts BlockElements;
    public static MidCodeCharts GeometricShapes;
    public static MidCodeCharts MiscellaneousSymbols;
    public static MidCodeCharts Dingbats;
    public static MidCodeCharts MiscellaneousMathematicalSymbolsA;
    public static MidCodeCharts SupplementalArrowsA;
    public static MidCodeCharts BraillePatterns;
    public static MidCodeCharts SupplementalArrowsB;
    public static MidCodeCharts MiscellaneousMathematicalSymbolsB;
    public static MidCodeCharts SupplementalMathematicalOperators;
    public static MidCodeCharts MiscellaneousSymbolsAndArrows;
    public static MidCodeCharts Glagolitic;
    public static MidCodeCharts LatinExtendedC;
    public static MidCodeCharts Coptic;
    public static MidCodeCharts GeorgianSupplement;
    public static MidCodeCharts Tifinagh;
    public static MidCodeCharts EthiopicExtended;
}
internal static class Microsoft.Security.Application.SafeList : object {
    internal static Char[][] Generate(int length, GenerateSafeValue generateSafeValue);
    internal static void PunchUnicodeThrough(Char[][]& safeList, LowerCodeCharts lowerCodeCharts, LowerMidCodeCharts lowerMidCodeCharts, MidCodeCharts midCodeCharts, UpperMidCodeCharts upperMidCodeCharts, UpperCodeCharts upperCodeCharts);
    internal static void PunchSafeList(Char[][]& safeList, IEnumerable whiteListedCharacters);
    internal static Char[] HashThenValueGenerator(int value);
    internal static Char[] HashThenHexValueGenerator(int value);
    internal static Char[] PercentThenHexValueGenerator(int value);
    internal static Char[] SlashThenHexValueGenerator(int value);
    internal static Char[] SlashThenSixDigitHexValueGenerator(long value);
    internal static Char[] SlashThenSixDigitHexValueGenerator(int value);
    internal static Char[] HashThenValueGenerator(long value);
    private static Char[] StringToCharArrayWithHashPrefix(string value);
    private static Char[] StringToCharArrayWithPercentPrefix(string value);
    private static Char[] StringToCharArrayWithSlashPrefix(string value);
    private static Char[] StringToCharArrayWithPrefix(string value, char prefix);
    private static void PunchCodeCharts(Char[][]& safeList, LowerCodeCharts codeCharts);
    private static void PunchCodeCharts(Char[][]& safeList, LowerMidCodeCharts codeCharts);
    private static void PunchCodeCharts(Char[][]& safeList, MidCodeCharts codeCharts);
    private static void PunchCodeCharts(Char[][]& safeList, UpperMidCodeCharts codeCharts);
    private static void PunchCodeCharts(Char[][]& safeList, UpperCodeCharts codeCharts);
    private static void PunchHolesIfNeeded(Char[][]& safeList, bool isNeeded, IEnumerable whiteListedCharacters);
}
internal static class Microsoft.Security.Application.UnicodeCharacterEncoder : object {
    private static char UnicodeReplacementCharacter;
    private static ReaderWriterLockSlim SyncLock;
    private static Char[] UnicodeSpace;
    private static Char[] UnicodeApostrophe;
    private static Char[] XmlApostrophe;
    private static LowerCodeCharts currentLowerCodeChartSettings;
    private static LowerMidCodeCharts currentLowerMidCodeChartSettings;
    private static MidCodeCharts currentMidCodeChartSettings;
    private static UpperMidCodeCharts currentUpperMidCodeChartSettings;
    private static UpperCodeCharts currentUpperCodeChartSettings;
    private static Char[][] characterValues;
    private static Char[][] namedEntities;
    private static UnicodeCharacterEncoder();
    private static void AcquireReadLock();
    private static void ReleaseReadLock();
    private static void AcquireWriteLock();
    private static void ReleaseWriteLock();
    public static void MarkAsSafe(LowerCodeCharts lowerCodeCharts, LowerMidCodeCharts lowerMidCodeCharts, MidCodeCharts midCodeCharts, UpperMidCodeCharts upperMidCodeCharts, UpperCodeCharts upperCodeCharts);
    internal static string XmlEncode(string input);
    internal static string XmlAttributeEncode(string input);
    internal static string HtmlAttributeEncode(string input);
    internal static string HtmlEncode(string input, bool useNamedEntities);
    private static void ApplyHtmlSpecificValues();
    private static bool HtmlAttributeTweak(char input, Char[]& output);
    private static bool XmlTweak(char input, Char[]& output);
    private static bool XmlAttributeTweak(char input, Char[]& output);
    private static string HtmlEncode(string input, bool useNamedEntities, MethodSpecificEncoder encoderTweak);
    private static void InitialiseSafeList();
    private static void InitialiseNamedEntityList();
}
[FlagsAttribute]
internal enum Microsoft.Security.Application.UpperCodeCharts : Enum {
    public int value__;
    public static UpperCodeCharts None;
    public static UpperCodeCharts DevanagariExtended;
    public static UpperCodeCharts KayahLi;
    public static UpperCodeCharts Rejang;
    public static UpperCodeCharts HangulJamoExtendedA;
    public static UpperCodeCharts Javanese;
    public static UpperCodeCharts Cham;
    public static UpperCodeCharts MyanmarExtendedA;
    public static UpperCodeCharts TaiViet;
    public static UpperCodeCharts MeeteiMayek;
    public static UpperCodeCharts HangulSyllables;
    public static UpperCodeCharts HangulJamoExtendedB;
    public static UpperCodeCharts CjkCompatibilityIdeographs;
    public static UpperCodeCharts AlphabeticPresentationForms;
    public static UpperCodeCharts ArabicPresentationFormsA;
    public static UpperCodeCharts VariationSelectors;
    public static UpperCodeCharts VerticalForms;
    public static UpperCodeCharts CombiningHalfMarks;
    public static UpperCodeCharts CjkCompatibilityForms;
    public static UpperCodeCharts SmallFormVariants;
    public static UpperCodeCharts ArabicPresentationFormsB;
    public static UpperCodeCharts HalfWidthAndFullWidthForms;
    public static UpperCodeCharts Specials;
}
[FlagsAttribute]
internal enum Microsoft.Security.Application.UpperMidCodeCharts : Enum {
    public long value__;
    public static UpperMidCodeCharts None;
    public static UpperMidCodeCharts CyrillicExtendedA;
    public static UpperMidCodeCharts SupplementalPunctuation;
    public static UpperMidCodeCharts CjkRadicalsSupplement;
    public static UpperMidCodeCharts KangxiRadicals;
    public static UpperMidCodeCharts IdeographicDescriptionCharacters;
    public static UpperMidCodeCharts CjkSymbolsAndPunctuation;
    public static UpperMidCodeCharts Hiragana;
    public static UpperMidCodeCharts Katakana;
    public static UpperMidCodeCharts Bopomofo;
    public static UpperMidCodeCharts HangulCompatibilityJamo;
    public static UpperMidCodeCharts Kanbun;
    public static UpperMidCodeCharts BopomofoExtended;
    public static UpperMidCodeCharts CjkStrokes;
    public static UpperMidCodeCharts KatakanaPhoneticExtensions;
    public static UpperMidCodeCharts EnclosedCjkLettersAndMonths;
    public static UpperMidCodeCharts CjkCompatibility;
    public static UpperMidCodeCharts CjkUnifiedIdeographsExtensionA;
    public static UpperMidCodeCharts YijingHexagramSymbols;
    public static UpperMidCodeCharts CjkUnifiedIdeographs;
    public static UpperMidCodeCharts YiSyllables;
    public static UpperMidCodeCharts YiRadicals;
    public static UpperMidCodeCharts Lisu;
    public static UpperMidCodeCharts Vai;
    public static UpperMidCodeCharts CyrillicExtendedB;
    public static UpperMidCodeCharts Bamum;
    public static UpperMidCodeCharts ModifierToneLetters;
    public static UpperMidCodeCharts LatinExtendedD;
    public static UpperMidCodeCharts SylotiNagri;
    public static UpperMidCodeCharts CommonIndicNumberForms;
    public static UpperMidCodeCharts Phagspa;
    public static UpperMidCodeCharts Saurashtra;
}
internal static class Microsoft.Security.Application.UrlEncoder : object {
    private static ReaderWriterLockSlim SyncLock;
    private static Char[][] characterValues;
    private static UrlEncoder();
    private static void AcquireReadLock();
    private static void ReleaseReadLock();
    private static void AcquireWriteLock();
    private static void ReleaseWriteLock();
    internal static string PathEncode(string s);
    private static bool AreNextTwoCharactersValidHexString(Byte[] input, int position);
    private static bool IsValidHexCharacter(char c);
    private static void InitializeSafeList();
    private static IEnumerable`1<int> UrlSafeList();
}
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; private set; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Byte[] value);
}
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
internal class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    internal virtual bool ReadInternal();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary();
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; public set; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
    [CompilerGeneratedAttribute]
public void set_IncludeLength(bool value);
}
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
internal enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
internal class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
internal class Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
}
internal class Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonToken tokenType);
    public virtual bool CanConvert(Type valueType);
}
internal abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
    private static string EntityKeyMemberFullTypeName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void ReadAndAssertProperty(JsonReader reader, string propertyName);
    private static void ReadAndAssert(JsonReader reader);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
internal interface Newtonsoft.Json.Converters.IBinary {
    public abstract virtual Byte[] ToArray();
}
internal interface Newtonsoft.Json.Converters.IEntityKeyMember {
    public string Key { get; public set; }
    public object Value { get; public set; }
    public abstract virtual string get_Key();
    public abstract virtual void set_Key(string value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    private string _dateTimeFormat;
    private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public string get_DateTimeFormat();
    public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
}
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual IList`1<IXmlNode> get_ChildNodes();
    public abstract virtual IList`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
internal class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    private Dictionary`2<Type, BidirectionalDictionary`2<string, string>> _enumMemberNamesPerType;
    [CompilerGeneratedAttribute]
private bool <CamelCaseText>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<EnumMemberAttribute, string> CS$<>9__CachedAnonymousMethodDelegate2;
    public bool CamelCaseText { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CamelCaseText();
    [CompilerGeneratedAttribute]
public void set_CamelCaseText(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText);
    private BidirectionalDictionary`2<string, string> GetEnumNameMap(Type t);
    public virtual bool CanConvert(Type objectType);
    [CompilerGeneratedAttribute]
private static string <GetEnumNameMap>b__1(EnumMemberAttribute a);
}
internal class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    public XAttributeWrapper(XAttribute attribute);
    private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XCommentWrapper(XComment text);
    private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]
private static Func`2<XNode, IXmlNode> CS$<>9__CachedAnonymousMethodDelegate1;
    private XContainer Container { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    [CompilerGeneratedAttribute]
private static IXmlNode <get_ChildNodes>b__0(XNode n);
}
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    internal XDeclaration Declaration { get; private set; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XDeclarationWrapper(XDeclaration declaration);
    [CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
private void set_Declaration(XDeclaration value);
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    [CompilerGeneratedAttribute]
private static Func`2<XAttribute, XAttributeWrapper> CS$<>9__CachedAnonymousMethodDelegate1;
    private XElement Element { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual IList`1<IXmlNode> get_Attributes();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    [CompilerGeneratedAttribute]
private static XAttributeWrapper <get_Attributes>b__0(XAttribute a);
}
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
}
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
}
internal class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IXmlNode, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IXmlNode, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private IEnumerable`1<IXmlNode> ValueAttributes(IEnumerable`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    [CompilerGeneratedAttribute]
private static bool <IsArray>b__0(IXmlNode a);
    [CompilerGeneratedAttribute]
private static bool <ValueAttributes>b__e(IXmlNode a);
}
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    private XmlNode _node;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public sealed virtual string get_LocalName();
    public sealed virtual IList`1<IXmlNode> get_ChildNodes();
    private IXmlNode WrapNode(XmlNode node);
    public sealed virtual IList`1<IXmlNode> get_Attributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
    [CompilerGeneratedAttribute]
private IXmlNode <get_ChildNodes>b__0(XmlNode n);
    [CompilerGeneratedAttribute]
private IXmlNode <get_Attributes>b__1(XmlAttribute a);
}
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public virtual IList`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XTextWrapper(XText text);
    private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal enum Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
internal enum Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
internal enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
internal enum Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
internal enum Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
internal enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
internal interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
internal class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
internal abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
internal static class Newtonsoft.Json.JsonConvert : object {
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    [CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    private static string ToStringInternal(BigInteger value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(object value);
    public static string SerializeObject(object value);
    public static string SerializeObject(object value, Formatting formatting);
    public static string SerializeObject(object value, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    public static string SerializeObject(object value, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    public static Task`1<string> SerializeObjectAsync(object value);
    public static Task`1<string> SerializeObjectAsync(object value, Formatting formatting);
    public static Task`1<string> SerializeObjectAsync(object value, Formatting formatting, JsonSerializerSettings settings);
    public static object DeserializeObject(string value);
    public static object DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type);
    public static T DeserializeObject(string value);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    public static T DeserializeObject(string value, JsonConverter[] converters);
    public static T DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    public static Task`1<T> DeserializeObjectAsync(string value);
    public static Task`1<T> DeserializeObjectAsync(string value, JsonSerializerSettings settings);
    public static Task`1<object> DeserializeObjectAsync(string value);
    public static Task`1<object> DeserializeObjectAsync(string value, Type type, JsonSerializerSettings settings);
    public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static Task PopulateObjectAsync(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
}
internal abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual JsonSchema GetSchema();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[AttributeUsageAttribute("3484")]
internal class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    public Type ConverterType { get; }
    public JsonConverterAttribute(Type converterType);
    public Type get_ConverterType();
    internal static JsonConverter CreateJsonConverterInstance(Type converterType);
}
internal class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    public JsonDictionaryAttribute(string id);
}
internal class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<Required> _itemRequired;
    public MemberSerialization MemberSerialization { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
internal class Newtonsoft.Json.JsonPosition : ValueType {
    internal JsonContainerType Type;
    internal int Position;
    internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    internal void WriteTo(StringBuilder sb);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(IEnumerable`1<JsonPosition> positions);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("2432")]
internal class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
internal abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    internal ReadType _readType;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    public string Path { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public abstract virtual Nullable`1<int> ReadAsInt32();
    public abstract virtual string ReadAsString();
    public abstract virtual Byte[] ReadAsBytes();
    public abstract virtual Nullable`1<decimal> ReadAsDecimal();
    public abstract virtual Nullable`1<DateTime> ReadAsDateTime();
    public abstract virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    internal Nullable`1<DateTimeOffset> ReadAsDateTimeOffsetInternal();
    internal Byte[] ReadAsBytesInternal();
    internal Nullable`1<decimal> ReadAsDecimalInternal();
    internal Nullable`1<int> ReadAsInt32Internal();
    internal string ReadAsStringInternal();
    internal Nullable`1<DateTime> ReadAsDateTimeInternal();
    private bool IsWrappedInTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    internal static bool IsPrimitiveToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
}
internal class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string Path { get; private set; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
internal class Newtonsoft.Json.JsonSerializationException : JsonException {
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
internal class Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal FormatterAssemblyStyle _typeNameAssemblyFormat;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    internal ITraceWriter _traceWriter;
    internal SerializationBinder _binder;
    internal StreamingContext _context;
    private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    private string _dateFormatString;
    private bool _dateFormatStringSet;
    private EventHandler`1<ErrorEventArgs> Error;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    public void Populate(TextReader reader, object target);
    public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    public object Deserialize(JsonReader reader);
    public object Deserialize(TextReader reader, Type objectType);
    public T Deserialize(JsonReader reader);
    public object Deserialize(JsonReader reader, Type objectType);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    public void Serialize(TextWriter textWriter, object value);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
internal class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static FormatterAssemblyStyle DefaultTypeNameAssemblyFormat;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static FormatterAssemblyStyle DefaultFormatterAssemblyStyle;
    internal static bool DefaultCheckAdditionalContent;
    internal static string DefaultDateFormatString;
    internal static StreamingContext DefaultContext;
    internal static CultureInfo DefaultCulture;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IReferenceResolver <ReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IReferenceResolver ReferenceResolver { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IReferenceResolver get_ReferenceResolver();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
internal class Newtonsoft.Json.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _buffer;
    private StringReference _stringReference;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    private StringBuffer GetBuffer();
    private void OnNewLine(int pos);
    private void ParseString(char quote);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    [DebuggerStepThroughAttribute]
public virtual bool Read();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    private void ReadStringIntoBuffer(char quote);
    private void WriteCharToBuffer(StringBuffer buffer, char writeChar, int lastWritePosition, int writeToPosition);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private void ClearRecentString();
    private bool ParsePostValue();
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private bool EatWhitespace(bool oneOrMore);
    private void ParseConstructor();
    private void ParseNumber();
    private void ParseComment();
    private bool MatchValue(string value);
    private bool MatchValueWithTrailingSeperator(string value);
    private bool IsSeperator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private void ParseNumberNegativeInfinity();
    private void ParseNumberPositiveInfinity();
    private void ParseNumberNaN();
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private TextWriter _writer;
    private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    private Boolean[] _charEscapeFlags;
    private Char[] _writeBuffer;
    private Base64Encoder Base64Encoder { get; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    private Base64Encoder get_Base64Encoder();
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteValue(string value);
    private void WriteEscapedString(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong uvalue);
}
internal enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
internal class Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchemaModel, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchemaModel, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchemaModel, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, bool>, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, bool>, string> CS$<>9__CachedAnonymousMethodDelegate9;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    [CompilerGeneratedAttribute]
private static bool <WriteToken>b__0(JsonSchemaModel s);
    [CompilerGeneratedAttribute]
private static bool <WriteToken>b__1(JsonSchemaModel s);
    [CompilerGeneratedAttribute]
private static bool <WriteToken>b__2(JsonSchemaModel s);
    [CompilerGeneratedAttribute]
private static bool <ValidateEndObject>b__6(KeyValuePair`2<string, bool> kv);
    [CompilerGeneratedAttribute]
private static string <ValidateEndObject>b__7(KeyValuePair`2<string, bool> kv);
}
internal abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTempate;
    private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    private string _dateFormatString;
    private CultureInfo _culture;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    public bool CloseOutput { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate);
    internal void WriteToken(JsonReader reader, int initialDepth, bool writeChildren, bool writeDateConstructorAsDate);
    private void WriteConstructorDate(JsonReader reader);
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
}
internal class Newtonsoft.Json.JsonWriterException : JsonException {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; private set; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    internal JsonWriterException(string message, Exception innerException, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Linq.Extensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<JObject, IEnumerable`1<JProperty>> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Ancestors>b__0(T j);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Descendants>b__1(T j);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JProperty> <Properties>b__2(JObject d);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Children>b__e(T c);
}
[DefaultMemberAttribute("Item")]
internal interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Parse(string json);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JConstructor : JContainer {
    private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; public set; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public string get_Name();
    public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
}
internal abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    internal ListChangedEventHandler _listChanged;
    internal AddingNewEventHandler _addingNew;
    internal NotifyCollectionChangedEventHandler _collectionChanged;
    private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    public virtual void Add(object content);
    internal void AddAndSkipParentCheck(JToken token);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal void ReadTokenFrom(JsonReader reader);
    internal void ReadContentFrom(JsonReader r);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    private PropertyChangedEventHandler PropertyChanged;
    private PropertyChangingEventHandler PropertyChanging;
    [CompilerGeneratedAttribute]
private static Func`2<JProperty, JToken> CS$<>9__CachedAnonymousMethodDelegate1;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Parse(string json);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public JToken GetValue(string propertyName);
    public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private static Type GetTokenPropertyType(JToken token);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [CompilerGeneratedAttribute]
private static JToken <PropertyValues>b__0(JProperty p);
}
internal class Newtonsoft.Json.Linq.JPath : object {
    private string _expression;
    private int _currentIndex;
    [CompilerGeneratedAttribute]
private List`1<object> <Parts>k__BackingField;
    public List`1<object> Parts { get; private set; }
    public JPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<object> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(List`1<object> value);
    private void ParseMain();
    private void ParseIndexer(char indexerOpenChar);
    internal JToken Evaluate(JToken root, bool errorWhenNoMatch);
}
internal class Newtonsoft.Json.Linq.JProperty : JContainer {
    private List`1<JToken> _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
}
internal class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    private Type _propertyType;
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name, Type propertyType);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public bool Compare(JPropertyKeyedCollection other);
}
internal class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    public JRaw(object rawJson);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
[DefaultMemberAttribute("Item")]
internal abstract class Newtonsoft.Json.Linq.JToken : object {
    private JContainer _parent;
    private JToken _previous;
    private JToken _next;
    private static JTokenEqualityComparer _equalityComparer;
    private Nullable`1<int> _lineNumber;
    private Nullable`1<int> _linePosition;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] BigIntegerTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public string Path { get; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public static JTokenEqualityComparer get_EqualityComparer();
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public static bool DeepEquals(JToken t1, JToken t2);
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public string get_Path();
    public void AddAfterSelf(object content);
    public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AfterSelf();
    public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    public static Nullable`1<DateTime> op_Explicit(JToken value);
    public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    public static Nullable`1<decimal> op_Explicit(JToken value);
    public static Nullable`1<double> op_Explicit(JToken value);
    public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    public static Nullable`1<int> op_Explicit(JToken value);
    public static Nullable`1<short> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    public static Nullable`1<byte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    public static Nullable`1<long> op_Explicit(JToken value);
    public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    public static Uri op_Explicit(JToken value);
    private static BigInteger ToBigInteger(JToken value);
    private static Nullable`1<BigInteger> ToBigIntegerNullable(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public object ToObject(Type objectType);
    public T ToObject(JsonSerializer jsonSerializer);
    public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken Parse(string json);
    public static JToken Load(JsonReader reader);
    internal void SetLineInfo(IJsonLineInfo lineInfo);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
}
internal class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
internal class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    private bool IsEndElement { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JTokenReader(JToken token);
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private bool get_IsEndElement();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
internal enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
internal class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    public JToken Token { get; }
    public JTokenWriter(JContainer container);
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
}
internal class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    private static int CompareBigInteger(BigInteger i1, object i2);
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
internal enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
internal enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
internal enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
internal enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
}
internal enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
internal enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Schema.Extensions : object {
    [ExtensionAttribute]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
internal class Newtonsoft.Json.Schema.JsonSchema : object {
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
internal class Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
internal static class Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static string ReferencePropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
internal class Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string Path { get; private set; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    public JsonSchemaException(SerializationInfo info, StreamingContext context);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
internal class Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
internal class Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
internal class Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
internal class Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchema, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Id { get; private set; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; private set; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; private set; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; private set; }
    public List`1<JsonSchemaNode> Items { get; private set; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
private void set_Schemas(ReadOnlyCollection`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
private void set_PatternProperties(Dictionary`2<string, JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(List`1<JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
    [CompilerGeneratedAttribute]
private static string <GetId>b__0(JsonSchema s);
    [CompilerGeneratedAttribute]
private static string <GetId>b__1(string id);
}
internal class Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
internal class Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
internal enum Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
internal class Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchemaType, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
    [CompilerGeneratedAttribute]
private static bool <WriteType>b__1(JsonSchemaType v);
}
internal enum Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
internal class Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
internal class Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(object type);
}
internal class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    protected internal virtual string ResolvePropertyName(string propertyName);
}
internal class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static IList`1<JsonConverter> BuiltInConverters;
    private static Dictionary`2<ResolverContractKey, JsonContract> _sharedContractCache;
    private static object _typeContractCacheLock;
    private Dictionary`2<ResolverContractKey, JsonContract> _instanceContractCache;
    private bool _sharedCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, int> CS$<>9__CachedAnonymousMethodDelegatee;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    public DefaultContractResolver(bool shareCache);
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    private Dictionary`2<ResolverContractKey, JsonContract> GetCache();
    private void UpdateCache(Dictionary`2<ResolverContractKey, JsonContract> cache);
    public virtual JsonContract ResolveContract(Type type);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private ExtensionDataSetter GetExtensionDataForType(Type type);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetParametrizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    [SuppressMessageAttribute("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework")]
private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected internal virtual string ResolvePropertyName(string propertyName);
    public string GetResolvedPropertyName(string propertyName);
    [CompilerGeneratedAttribute]
private static bool <GetSerializableMembers>b__1(MemberInfo m);
    [CompilerGeneratedAttribute]
private static bool <GetSerializableMembers>b__2(MemberInfo m);
    [CompilerGeneratedAttribute]
private static bool <GetAttributeConstructor>b__8(ConstructorInfo c);
    [CompilerGeneratedAttribute]
private static int <CreateProperties>b__d(JsonProperty p);
}
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
internal class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    private ThreadSafeStore`2<TypeNameKey, Type> _typeCache;
    private static DefaultSerializationBinder();
    private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
internal class Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    private Func`2<object, object> _getter;
    private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; private set; }
    public object OriginalObject { get; private set; }
    public object Member { get; private set; }
    public string Path { get; private set; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public object get_OriginalObject();
    [CompilerGeneratedAttribute]
private void set_OriginalObject(object value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
internal class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    public object CurrentObject { get; private set; }
    public ErrorContext ErrorContext { get; private set; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
private void set_CurrentObject(object value);
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorContext value);
}
internal class Newtonsoft.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    private Func`2<object, object> _getter;
    private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    public virtual void Invoke(object o, string key, JToken value);
    public virtual IAsyncResult BeginInvoke(object o, string key, JToken value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
internal interface Newtonsoft.Json.Serialization.IMetadataTypeAttribute {
    public Type MetadataClassType { get; }
    public abstract virtual Type get_MetadataClassType();
}
internal interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
internal interface Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
internal interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    private bool _isCollectionItemTypeNullableType;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall`2<object, object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ParametrizedConstructor>k__BackingField;
    public Type CollectionItemType { get; private set; }
    public bool IsMultidimensionalArray { get; private set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal bool CanDeserialize { get; private set; }
    internal ConstructorInfo ParametrizedConstructor { get; private set; }
    public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
private void set_CollectionItemType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
private void set_IsMultidimensionalArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ParametrizedConstructor();
    [CompilerGeneratedAttribute]
private void set_ParametrizedConstructor(ConstructorInfo value);
    internal IWrappedCollection CreateWrapper(object list);
    internal IList CreateTemporaryCollection();
}
internal class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
internal abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsSealed;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsInstantiable;
    private List`1<SerializationCallback> _onDeserializedCallbacks;
    private IList`1<SerializationCallback> _onDeserializingCallbacks;
    private IList`1<SerializationCallback> _onSerializedCallbacks;
    private IList`1<SerializationCallback> _onSerializingCallbacks;
    private IList`1<SerializationErrorCallback> _onErrorCallbacks;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CreatedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; private set; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public JsonConverter Converter { get; public set; }
    internal JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
public MethodInfo OnDeserialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
public MethodInfo OnDeserializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
public MethodInfo OnSerialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
public MethodInfo OnSerializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
public MethodInfo OnError { get; public set; }
    public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    [CompilerGeneratedAttribute]
public Type get_CreatedType();
    [CompilerGeneratedAttribute]
public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
internal JsonConverter get_InternalConverter();
    [CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    public MethodInfo get_OnDeserialized();
    public void set_OnDeserialized(MethodInfo value);
    public MethodInfo get_OnDeserializing();
    public void set_OnDeserializing(MethodInfo value);
    public MethodInfo get_OnSerialized();
    public void set_OnSerialized(MethodInfo value);
    public MethodInfo get_OnSerializing();
    public void set_OnSerializing(MethodInfo value);
    public MethodInfo get_OnError();
    public void set_OnError(MethodInfo value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
internal class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    private bool _isDictionaryValueTypeNullableType;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall`2<object, object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ParametrizedConstructor>k__BackingField;
    public Func`2<string, string> PropertyNameResolver { get; public set; }
    public Type DictionaryKeyType { get; private set; }
    public Type DictionaryValueType { get; private set; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal ConstructorInfo ParametrizedConstructor { get; private set; }
    public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
private void set_DictionaryValueType(Type value);
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ParametrizedConstructor();
    [CompilerGeneratedAttribute]
private void set_ParametrizedConstructor(ConstructorInfo value);
    internal IWrappedDictionary CreateWrapper(object dictionary);
    internal IDictionary CreateTemporaryDictionary();
}
internal class Newtonsoft.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    public JsonPropertyCollection Properties { get; private set; }
    public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializer _serializer;
    public JsonFormatterConverter(JsonSerializer serializer);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
internal class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
internal class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
internal class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <ConstructorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <OverrideConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ParametrizedConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public JsonPropertyCollection Properties { get; private set; }
    public JsonPropertyCollection ConstructorParameters { get; private set; }
    public ConstructorInfo OverrideConstructor { get; public set; }
    public ConstructorInfo ParametrizedConstructor { get; public set; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_ConstructorParameters();
    [CompilerGeneratedAttribute]
private void set_ConstructorParameters(JsonPropertyCollection value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_OverrideConstructor();
    [CompilerGeneratedAttribute]
public void set_OverrideConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_ParametrizedConstructor();
    [CompilerGeneratedAttribute]
public void set_ParametrizedConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    [SecuritySafeCriticalAttribute]
internal object GetUninitializedObject();
}
internal class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
internal class Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    internal object _defaultValue;
    private string _propertyName;
    private bool _skipPropertyNameEscape;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <MemberConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    public Predicate`1<object> ShouldSerialize { get; public set; }
    public Predicate`1<object> GetIsSpecified { get; public set; }
    public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    private void CalculateSkipPropertyNameEscape();
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
public JsonConverter get_MemberConverter();
    [CompilerGeneratedAttribute]
public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    internal void WritePropertyName(JsonWriter writer);
}
internal class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValue(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    private ErrorContext _currentErrorContext;
    private BidirectionalDictionary`2<string, object> _mappings;
    private bool _serializing;
    internal JsonSerializer Serializer;
    internal ITraceWriter TraceWriter;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    private JsonSerializerProxy _internalSerializer;
    private JsonFormatterConverter _formatterConverter;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, ParameterInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, object> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<ParameterInfo, object>, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, JsonProperty> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, PropertyPresence> CS$<>9__CachedAnonymousMethodDelegate9;
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    private JsonContract GetContractSafe(Type type);
    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonFormatterConverter GetFormatterConverter();
    private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    internal string GetExpectedDescription(JsonContract contract);
    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool ReadSpecialProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    private void CheckedRead(JsonReader reader);
    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool ShouldSetPropertyValue(JsonProperty property, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultConstructor);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultConstructor);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectFromNonDefaultConstructor(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ConstructorInfo constructorInfo, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private IDictionary`2<JsonProperty, object> ResolvePropertyAndConstructorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultConstructor);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private void SetExtensionData(JsonObjectContract contract, JsonReader reader, string memberName, object o);
    private void EndObject(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, Dictionary`2<JsonProperty, PropertyPresence> propertiesPresence);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
    [CompilerGeneratedAttribute]
private static ParameterInfo <CreateObjectFromNonDefaultConstructor>b__0(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static object <CreateObjectFromNonDefaultConstructor>b__1(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static string <CreateObjectFromNonDefaultConstructor>b__2(KeyValuePair`2<ParameterInfo, object> kv);
    [CompilerGeneratedAttribute]
private static JsonProperty <PopulateObject>b__6(JsonProperty m);
    [CompilerGeneratedAttribute]
private static PropertyPresence <PopulateObject>b__7(JsonProperty m);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    private JsonContract _rootContract;
    private List`1<object> _serializeStack;
    private JsonSerializerProxy _internalSerializer;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonContract GetContractSafe(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteProperty(object memberValue, JsonProperty property);
    private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [SecuritySafeCriticalAttribute]
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteDynamicProperty(object memberValue);
    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, DictionaryEntry entry, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    private JsonSerializerInternalReader _serializerReader;
    private JsonSerializerInternalWriter _serializerWriter;
    private JsonSerializer _serializer;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
internal class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    public JsonStringContract(Type underlyingType);
}
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    private static string MetadataTypeAttributeTypeName;
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    private static ThreadSafeStore`2<object, Type> JsonConverterTypeCache;
    private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    private static Type _cachedMetadataTypeAttributeType;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static JsonContainerAttribute GetJsonContainerAttribute(Type type);
    public static JsonObjectAttribute GetJsonObjectAttribute(Type type);
    public static JsonArrayAttribute GetJsonArrayAttribute(Type type);
    public static JsonDictionaryAttribute GetJsonDictionaryAttribute(Type type);
    public static SerializableAttribute GetSerializableAttribute(Type type);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    private static Type GetJsonConverterType(object attributeProvider);
    private static Type GetJsonConverterTypeFromAttribute(object attributeProvider);
    public static JsonConverter GetJsonConverter(object attributeProvider, Type targetConvertedType);
    public static TypeConverter GetTypeConverter(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static Type GetMetadataTypeAttributeType();
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static T GetAttribute(object provider);
    [SecuritySafeCriticalAttribute]
public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
internal class Newtonsoft.Json.Serialization.LateBoundMetadataTypeAttribute : object {
    private static PropertyInfo _metadataClassTypeProperty;
    private object _attribute;
    public Type MetadataClassType { get; }
    public LateBoundMetadataTypeAttribute(object attribute);
    public sealed virtual Type get_MetadataClassType();
}
internal class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
internal class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
internal class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
internal class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
    private Type _resolverType;
    private Type _contractType;
    public ResolverContractKey(Type resolverType, Type contractType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResolverContractKey other);
}
internal class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetJson();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetJson();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(double value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void Close();
    public virtual void Flush();
}
internal enum Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    public void Encode(Byte[] buffer, int index, int count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
}
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumableCollectionConstructor(Type collectionType, Type collectionItemType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<TSource> list, TSource value, IEqualityComparer`1<TSource> comparer);
    private static IList`1<int> GetDimensions(IList values);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
}
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    private IList _list;
    private ICollection`1<T> _genericCollection;
    private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static List`1<TypeInformation> PrimitiveTypeCodes;
    private static ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(object o);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    private static Func`2<object, object> CreateCastConverter(TypeConvertKey t);
    internal static BigInteger ToBigInteger(object value);
    public static object FromBigInteger(BigInteger i, Type targetType);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    public static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& convertedValue);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static object ToValue(INullable nullableValue);
    internal static TypeConverter GetConverter(Type t);
    public static bool IsInteger(object value);
    public static int Int32Parse(Char[] chars, int start, int length);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
}
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    private static short MaxFractionDigits;
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private string _text;
    private int _length;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static int Lz_zz_;
    private static int Lz_zz_zz;
    private static DateTimeParser();
    public bool Parse(string text);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    internal static long InitialJavaScriptDateTicks;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateIso(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, Object& dt);
    internal static bool TryParseDateTime(string s, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, Object& dt);
    private static bool TryParseDateMicrosoft(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, Object& dt);
    private static TimeSpan ReadOffset(string offsetText);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    private IDictionary _dictionary;
    private IDictionary`2<TKey, TValue> _genericDictionary;
    private object _syncRoot;
    [CompilerGeneratedAttribute]
private static Func`2<DictionaryEntry, KeyValuePair`2<TKey, TValue>> CS$<>9__CachedAnonymousMethodDelegate1;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<TKey, TValue> <GetEnumerator>b__0(DictionaryEntry de);
}
internal class Newtonsoft.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
internal class Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private bool _dontFallbackFirst;
    private static Expression[] NoArgs;
    [CompilerGeneratedAttribute]
private static Func`2<DynamicMetaObject, UnaryExpression> CS$<>9__CachedAnonymousMethodDelegate26;
    private T Value { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy, bool dontFallbackFirst);
    private static DynamicProxyMetaObject`1();
    private T get_Value();
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    [CompilerGeneratedAttribute]
private static UnaryExpression <GetArgs>b__25(DynamicMetaObject arg);
}
internal class Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    public static DynamicReflectionDelegateFactory Instance;
    private static DynamicReflectionDelegateFactory();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
internal static class Newtonsoft.Json.Utilities.DynamicWrapper : object {
    private static object _lock;
    private static WrapperDictionary _wrapperDictionary;
    private static ModuleBuilder _moduleBuilder;
    private static ModuleBuilder ModuleBuilder { get; }
    private static DynamicWrapper();
    private static ModuleBuilder get_ModuleBuilder();
    private static void Init();
    private static Byte[] GetStrongKey();
    public static Type GetWrapper(Type interfaceType, Type realObjectType);
    public static object GetUnderlyingObject(object wrapper);
    private static Type GenerateWrapperType(Type interfaceType, Type underlyingType);
    public static T CreateWrapper(object realObject);
}
internal class Newtonsoft.Json.Utilities.DynamicWrapperBase : object {
    protected internal object UnderlyingObject;
}
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public static IList`1<T> GetFlagsValues(T value);
    public static EnumValues`1<ulong> GetNamesAndValues();
    public static EnumValues`1<TUnderlyingType> GetNamesAndValues(Type enumType);
    public static IList`1<object> GetValues(Type enumType);
    public static IList`1<string> GetNames(Type enumType);
    [CompilerGeneratedAttribute]
private static bool <GetFlagsValues>b__0(EnumValue`1<ulong> v);
    [CompilerGeneratedAttribute]
private static bool <GetValues>b__1(FieldInfo field);
    [CompilerGeneratedAttribute]
private static bool <GetNames>b__3(FieldInfo field);
}
internal class Newtonsoft.Json.Utilities.EnumValue`1 : object {
    private string _name;
    private T _value;
    public string Name { get; }
    public T Value { get; }
    public EnumValue`1(string name, T value);
    public string get_Name();
    public T get_Value();
}
internal class Newtonsoft.Json.Utilities.EnumValues`1 : KeyedCollection`2<string, EnumValue`1<T>> {
    protected virtual string GetKeyForItem(EnumValue`1<T> item);
}
internal class Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    private static string EscapedUnicodeText;
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static JavaScriptUtils();
    public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters);
}
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static string FormatValueForPrint(object value);
}
internal class Newtonsoft.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
internal class Newtonsoft.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Newtonsoft.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
    [CompilerGeneratedAttribute]
private static bool <GetDefaultConstructor>b__0(ConstructorInfo c);
    [CompilerGeneratedAttribute]
private static string <GetFieldsAndProperties>b__2(MemberInfo m);
    [CompilerGeneratedAttribute]
private static Type <GetMemberInfoFromType>b__8(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static bool <GetChildPrivateFields>b__a(FieldInfo f);
}
internal class Newtonsoft.Json.Utilities.StringBuffer : object {
    private Char[] _buffer;
    private int _position;
    private static Char[] EmptyBuffer;
    public int Position { get; public set; }
    public StringBuffer(int initalSize);
    private static StringBuffer();
    public int get_Position();
    public void set_Position(int value);
    public void Append(char value);
    public void Append(Char[] buffer, int startIndex, int count);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] GetInternalBuffer();
}
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static string NullEmptyString(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static Nullable`1<int> GetLength(string value);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
}
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private object _lock;
    private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, IEnumerable`1<MethodInfo>> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`3<Type, MethodInfo, MethodInfo> CS$<>9__CachedAnonymousMethodDelegate14;
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName);
    [ExtensionAttribute]
public static MethodInfo GetGenericMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static bool HasParameters(MethodInfo method, Type[] parameterTypes);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetAllInterfaces(Type target);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetAllMethods(Type target);
    [CompilerGeneratedAttribute]
private static Type <HasParameters>b__3(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<MethodInfo> <GetAllMethods>b__11(Type type);
    [CompilerGeneratedAttribute]
private static MethodInfo <GetAllMethods>b__12(Type type, MethodInfo method);
}
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; public set; }
    public PrimitiveTypeCode TypeCode { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public void set_TypeCode(PrimitiveTypeCode value);
}
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    public static void ArgumentNotNullOrEmpty(string value, string parameterName);
    public static void ArgumentTypeIsEnum(Type enumType, string parameterName);
    public static void ArgumentNotNull(object value, string parameterName);
}
internal class Newtonsoft.Json.Utilities.WrapperDictionary : object {
    private Dictionary`2<string, Type> _wrapperTypes;
    private static string GenerateKey(Type interfaceType, Type realObjectType);
    public Type GetType(Type interfaceType, Type realObjectType);
    public void SetType(Type interfaceType, Type realObjectType, Type wrapperType);
}
internal class Newtonsoft.Json.Utilities.WrapperMethodBuilder : object {
    private Type _realObjectType;
    private TypeBuilder _wrapperBuilder;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public WrapperMethodBuilder(Type realObjectType, TypeBuilder proxyBuilder);
    public void Generate(MethodInfo newMethod);
    private static void Return(ILGenerator ilGenerator);
    private void ExecuteMethod(MethodBase newMethod, Type[] parameterTypes, ILGenerator ilGenerator);
    private MethodInfo GetMethod(MethodBase realMethod, Type[] parameterTypes);
    private static void PushParameters(ICollection`1<ParameterInfo> parameters, ILGenerator ilGenerator);
    private static void LoadUnderlyingObject(ILGenerator ilGenerator, FieldInfo srcField);
    [CompilerGeneratedAttribute]
private static Type <Generate>b__0(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
private static string <Generate>b__1(Type arg);
}
internal enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
[ProgIdAttribute("NLog.Logger")]
[GuidAttribute("181f39a8-41a8-4e35-91b6-5f8d96f5e61c")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class NLog.ComInterop.ComLogger : object {
    private static Logger DefaultLogger;
    private Logger logger;
    private string loggerName;
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public string LoggerName { get; public set; }
    private static ComLogger();
    public sealed virtual bool get_IsTraceEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual string get_LoggerName();
    public sealed virtual void set_LoggerName(string value);
    public sealed virtual void Log(string level, string message);
    public sealed virtual void Trace(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Warn(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Fatal(string message);
    public sealed virtual bool IsEnabled(string level);
}
[ProgIdAttribute("NLog.LogManager")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[GuidAttribute("9a7e8d84-72e4-478a-9a05-23c7ef0cfca8")]
internal class NLog.ComInterop.ComLogManager : object {
    public bool InternalLogToConsole { get; public set; }
    public string InternalLogLevel { get; public set; }
    public string InternalLogFile { get; public set; }
    public sealed virtual bool get_InternalLogToConsole();
    public sealed virtual void set_InternalLogToConsole(bool value);
    public sealed virtual string get_InternalLogLevel();
    public sealed virtual void set_InternalLogLevel(string value);
    public sealed virtual string get_InternalLogFile();
    public sealed virtual void set_InternalLogFile(string value);
    public sealed virtual IComLogger GetLogger(string loggerName);
    public sealed virtual void LoadConfigFromFile(string fileName);
}
[ComVisibleAttribute("True")]
[GuidAttribute("757fd55a-cc93-4b53-a7a0-18e85620704a")]
[InterfaceTypeAttribute("0")]
internal interface NLog.ComInterop.IComLogger {
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsTraceEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsDebugEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsInfoEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsWarnEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsErrorEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public bool IsFatalEnabled { get; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public string LoggerName { get; public set; }
    public abstract virtual void Log(string level, string message);
    public abstract virtual void Trace(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Warn(string message);
    [SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
public abstract virtual void Error(string message);
    public abstract virtual void Fatal(string message);
    public abstract virtual bool IsEnabled(string level);
    public abstract virtual bool get_IsTraceEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual string get_LoggerName();
    public abstract virtual void set_LoggerName(string value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("7ee3af3b-ba37-45b6-8f5d-cc23bb46c698")]
[InterfaceTypeAttribute("0")]
internal interface NLog.ComInterop.IComLogManager {
    public bool InternalLogToConsole { get; public set; }
    public string InternalLogFile { get; public set; }
    public string InternalLogLevel { get; public set; }
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.OrderingRules", "SA1201:ElementsMustAppearInTheCorrectOrder")]
public abstract virtual void LoadConfigFromFile(string fileName);
    public abstract virtual bool get_InternalLogToConsole();
    public abstract virtual void set_InternalLogToConsole(bool value);
    public abstract virtual string get_InternalLogFile();
    public abstract virtual void set_InternalLogFile(string value);
    public abstract virtual string get_InternalLogLevel();
    public abstract virtual void set_InternalLogLevel(string value);
    public abstract virtual IComLogger GetLogger(string loggerName);
}
internal class NLog.Common.AsyncContinuation : MulticastDelegate {
    public AsyncContinuation(object object, IntPtr method);
    public virtual void Invoke(Exception exception);
    public virtual IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class NLog.Common.AsyncHelpers : object {
    public static void ForEachItemSequentially(IEnumerable`1<T> items, AsyncContinuation asyncContinuation, AsynchronousAction`1<T> action);
    public static void Repeat(int repeatCount, AsyncContinuation asyncContinuation, AsynchronousAction action);
    public static AsyncContinuation PrecededBy(AsyncContinuation asyncContinuation, AsynchronousAction action);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public static AsyncContinuation WithTimeout(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public static void ForEachItemInParallel(IEnumerable`1<T> values, AsyncContinuation asyncContinuation, AsynchronousAction`1<T> action);
    public static void RunSynchronously(AsynchronousAction action);
    public static AsyncContinuation PreventMultipleCalls(AsyncContinuation asyncContinuation);
    public static Exception GetCombinedException(IList`1<Exception> exceptions);
    private static AsynchronousAction ExceptionGuard(AsynchronousAction action);
    private static AsynchronousAction`1<T> ExceptionGuard(AsynchronousAction`1<T> action);
}
internal class NLog.Common.AsynchronousAction : MulticastDelegate {
    public AsynchronousAction(object object, IntPtr method);
    public virtual void Invoke(AsyncContinuation asyncContinuation);
    public virtual IAsyncResult BeginInvoke(AsyncContinuation asyncContinuation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class NLog.Common.AsynchronousAction`1 : MulticastDelegate {
    public AsynchronousAction`1(object object, IntPtr method);
    public virtual void Invoke(T argument, AsyncContinuation asyncContinuation);
    public virtual IAsyncResult BeginInvoke(T argument, AsyncContinuation asyncContinuation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class NLog.Common.AsyncLogEventInfo : ValueType {
    [CompilerGeneratedAttribute]
private LogEventInfo <LogEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncContinuation <Continuation>k__BackingField;
    public LogEventInfo LogEvent { get; private set; }
    public AsyncContinuation Continuation { get; internal set; }
    public AsyncLogEventInfo(LogEventInfo logEvent, AsyncContinuation continuation);
    [CompilerGeneratedAttribute]
public LogEventInfo get_LogEvent();
    [CompilerGeneratedAttribute]
private void set_LogEvent(LogEventInfo value);
    [CompilerGeneratedAttribute]
public AsyncContinuation get_Continuation();
    [CompilerGeneratedAttribute]
internal void set_Continuation(AsyncContinuation value);
    public static bool op_Equality(AsyncLogEventInfo eventInfo1, AsyncLogEventInfo eventInfo2);
    public static bool op_Inequality(AsyncLogEventInfo eventInfo1, AsyncLogEventInfo eventInfo2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class NLog.Common.InternalLogger : object {
    private static object lockObject;
    [CompilerGeneratedAttribute]
private static LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogToConsole>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogToConsoleError>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <LogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextWriter <LogWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IncludeTimestamp>k__BackingField;
    public static LogLevel LogLevel { get; public set; }
    public static bool LogToConsole { get; public set; }
    public static bool LogToConsoleError { get; public set; }
    public static string LogFile { get; public set; }
    public static TextWriter LogWriter { get; public set; }
    public static bool IncludeTimestamp { get; public set; }
    public static bool IsTraceEnabled { get; }
    public static bool IsDebugEnabled { get; }
    public static bool IsInfoEnabled { get; }
    public static bool IsWarnEnabled { get; }
    public static bool IsErrorEnabled { get; }
    public static bool IsFatalEnabled { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
private static InternalLogger();
    [CompilerGeneratedAttribute]
public static LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public static void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public static bool get_LogToConsole();
    [CompilerGeneratedAttribute]
public static void set_LogToConsole(bool value);
    [CompilerGeneratedAttribute]
public static bool get_LogToConsoleError();
    [CompilerGeneratedAttribute]
public static void set_LogToConsoleError(bool value);
    [CompilerGeneratedAttribute]
public static string get_LogFile();
    [CompilerGeneratedAttribute]
public static void set_LogFile(string value);
    [CompilerGeneratedAttribute]
public static TextWriter get_LogWriter();
    [CompilerGeneratedAttribute]
public static void set_LogWriter(TextWriter value);
    [CompilerGeneratedAttribute]
public static bool get_IncludeTimestamp();
    [CompilerGeneratedAttribute]
public static void set_IncludeTimestamp(bool value);
    public static bool get_IsTraceEnabled();
    public static bool get_IsDebugEnabled();
    public static bool get_IsInfoEnabled();
    public static bool get_IsWarnEnabled();
    public static bool get_IsErrorEnabled();
    public static bool get_IsFatalEnabled();
    public static void Log(LogLevel level, string message, Object[] args);
    public static void Log(LogLevel level, string message);
    public static void Trace(string message, Object[] args);
    public static void Trace(string message);
    public static void Debug(string message, Object[] args);
    public static void Debug(string message);
    public static void Info(string message, Object[] args);
    public static void Info(string message);
    public static void Warn(string message, Object[] args);
    public static void Warn(string message);
    public static void Error(string message, Object[] args);
    public static void Error(string message);
    public static void Fatal(string message, Object[] args);
    public static void Fatal(string message);
    private static void Write(LogLevel level, string message, Object[] args);
    private static string GetSettingString(string configName, string envName);
    private static LogLevel GetSetting(string configName, string envName, LogLevel defaultValue);
    private static T GetSetting(string configName, string envName, T defaultValue);
}
internal class NLog.Common.LogEventInfoBuffer : object {
    private bool growAsNeeded;
    private int growLimit;
    private AsyncLogEventInfo[] buffer;
    private int getPointer;
    private int putPointer;
    private int count;
    public int Size { get; }
    public LogEventInfoBuffer(int size, bool growAsNeeded, int growLimit);
    public int get_Size();
    public int Append(AsyncLogEventInfo eventInfo);
    public AsyncLogEventInfo[] GetEventsAndClear();
}
internal class NLog.Conditions.ConditionAndExpression : ConditionExpression {
    private static object boxedFalse;
    private static object boxedTrue;
    [CompilerGeneratedAttribute]
private ConditionExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Right>k__BackingField;
    public ConditionExpression Left { get; private set; }
    public ConditionExpression Right { get; private set; }
    public ConditionAndExpression(ConditionExpression left, ConditionExpression right);
    private static ConditionAndExpression();
    [CompilerGeneratedAttribute]
public ConditionExpression get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Right();
    [CompilerGeneratedAttribute]
private void set_Right(ConditionExpression value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionEvaluationException : Exception {
    public ConditionEvaluationException(string message);
    public ConditionEvaluationException(string message, Exception innerException);
    protected ConditionEvaluationException(SerializationInfo info, StreamingContext context);
}
[ThreadAgnosticAttribute]
[NLogConfigurationItemAttribute]
internal abstract class NLog.Conditions.ConditionExpression : object {
    public static ConditionExpression op_Implicit(string conditionExpressionText);
    public object Evaluate(LogEventInfo context);
    public abstract virtual string ToString();
    protected abstract virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLayoutExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    public Layout Layout { get; private set; }
    public ConditionLayoutExpression(Layout layout);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
private void set_Layout(Layout value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLevelExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLiteralExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private object <LiteralValue>k__BackingField;
    public object LiteralValue { get; private set; }
    public ConditionLiteralExpression(object literalValue);
    [CompilerGeneratedAttribute]
public object get_LiteralValue();
    [CompilerGeneratedAttribute]
private void set_LiteralValue(object value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionLoggerNameExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionMessageExpression : ConditionExpression {
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
[AttributeUsageAttribute("64")]
internal class NLog.Conditions.ConditionMethodAttribute : NameBaseAttribute {
    public ConditionMethodAttribute(string name);
}
internal class NLog.Conditions.ConditionMethodExpression : ConditionExpression {
    private bool acceptsLogEvent;
    private string conditionMethodName;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConditionExpression> <MethodParameters>k__BackingField;
    public MethodInfo MethodInfo { get; private set; }
    public IList`1<ConditionExpression> MethodParameters { get; private set; }
    public ConditionMethodExpression(string conditionMethodName, MethodInfo methodInfo, IEnumerable`1<ConditionExpression> methodParameters);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodInfo();
    [CompilerGeneratedAttribute]
private void set_MethodInfo(MethodInfo value);
    [CompilerGeneratedAttribute]
public IList`1<ConditionExpression> get_MethodParameters();
    [CompilerGeneratedAttribute]
private void set_MethodParameters(IList`1<ConditionExpression> value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
[ConditionMethodsAttribute]
internal static class NLog.Conditions.ConditionMethods : object {
    [ConditionMethodAttribute("equals")]
public static bool Equals2(object firstValue, object secondValue);
    [ConditionMethodAttribute("contains")]
public static bool Contains(string haystack, string needle);
    [ConditionMethodAttribute("starts-with")]
public static bool StartsWith(string haystack, string needle);
    [ConditionMethodAttribute("ends-with")]
public static bool EndsWith(string haystack, string needle);
    [ConditionMethodAttribute("length")]
public static int Length(string text);
}
[AttributeUsageAttribute("4")]
internal class NLog.Conditions.ConditionMethodsAttribute : Attribute {
}
internal class NLog.Conditions.ConditionNotExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <Expression>k__BackingField;
    public ConditionExpression Expression { get; private set; }
    public ConditionNotExpression(ConditionExpression expression);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(ConditionExpression value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionOrExpression : ConditionExpression {
    private static object boxedFalse;
    private static object boxedTrue;
    [CompilerGeneratedAttribute]
private ConditionExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <RightExpression>k__BackingField;
    public ConditionExpression LeftExpression { get; private set; }
    public ConditionExpression RightExpression { get; private set; }
    public ConditionOrExpression(ConditionExpression left, ConditionExpression right);
    private static ConditionOrExpression();
    [CompilerGeneratedAttribute]
public ConditionExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
private void set_LeftExpression(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_RightExpression();
    [CompilerGeneratedAttribute]
private void set_RightExpression(ConditionExpression value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
}
internal class NLog.Conditions.ConditionParseException : Exception {
    public ConditionParseException(string message);
    public ConditionParseException(string message, Exception innerException);
    protected ConditionParseException(SerializationInfo info, StreamingContext context);
}
internal class NLog.Conditions.ConditionParser : object {
    private ConditionTokenizer tokenizer;
    private ConfigurationItemFactory configurationItemFactory;
    private ConditionParser(SimpleStringReader stringReader, ConfigurationItemFactory configurationItemFactory);
    public static ConditionExpression ParseExpression(string expressionText);
    public static ConditionExpression ParseExpression(string expressionText, ConfigurationItemFactory configurationItemFactories);
    internal static ConditionExpression ParseExpression(SimpleStringReader stringReader, ConfigurationItemFactory configurationItemFactories);
    private ConditionMethodExpression ParsePredicate(string functionName);
    private ConditionExpression ParseLiteralExpression();
    private ConditionExpression ParseBooleanRelation();
    private ConditionExpression ParseBooleanPredicate();
    private ConditionExpression ParseBooleanAnd();
    private ConditionExpression ParseBooleanOr();
    private ConditionExpression ParseBooleanExpression();
    private ConditionExpression ParseExpression();
}
internal class NLog.Conditions.ConditionRelationalExpression : ConditionExpression {
    [CompilerGeneratedAttribute]
private ConditionExpression <LeftExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <RightExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionRelationalOperator <RelationalOperator>k__BackingField;
    public ConditionExpression LeftExpression { get; private set; }
    public ConditionExpression RightExpression { get; private set; }
    public ConditionRelationalOperator RelationalOperator { get; private set; }
    public ConditionRelationalExpression(ConditionExpression leftExpression, ConditionExpression rightExpression, ConditionRelationalOperator relationalOperator);
    [CompilerGeneratedAttribute]
public ConditionExpression get_LeftExpression();
    [CompilerGeneratedAttribute]
private void set_LeftExpression(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_RightExpression();
    [CompilerGeneratedAttribute]
private void set_RightExpression(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionRelationalOperator get_RelationalOperator();
    [CompilerGeneratedAttribute]
private void set_RelationalOperator(ConditionRelationalOperator value);
    public virtual string ToString();
    protected virtual object EvaluateNode(LogEventInfo context);
    private static object Compare(object leftValue, object rightValue, ConditionRelationalOperator relationalOperator);
    private static void PromoteTypes(Object& val1, Object& val2);
    private string GetOperatorString();
}
internal enum NLog.Conditions.ConditionRelationalOperator : Enum {
    public int value__;
    public static ConditionRelationalOperator Equal;
    public static ConditionRelationalOperator NotEqual;
    public static ConditionRelationalOperator Less;
    public static ConditionRelationalOperator Greater;
    public static ConditionRelationalOperator LessOrEqual;
    public static ConditionRelationalOperator GreaterOrEqual;
}
internal class NLog.Conditions.ConditionTokenizer : object {
    private static ConditionTokenType[] charIndexToTokenType;
    private SimpleStringReader stringReader;
    [CompilerGeneratedAttribute]
private int <TokenPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenValue>k__BackingField;
    public int TokenPosition { get; private set; }
    public ConditionTokenType TokenType { get; private set; }
    public string TokenValue { get; private set; }
    public string StringTokenValue { get; }
    public ConditionTokenizer(SimpleStringReader stringReader);
    private static ConditionTokenizer();
    [CompilerGeneratedAttribute]
public int get_TokenPosition();
    [CompilerGeneratedAttribute]
private void set_TokenPosition(int value);
    [CompilerGeneratedAttribute]
public ConditionTokenType get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(ConditionTokenType value);
    [CompilerGeneratedAttribute]
public string get_TokenValue();
    [CompilerGeneratedAttribute]
private void set_TokenValue(string value);
    public string get_StringTokenValue();
    public void Expect(ConditionTokenType tokenType);
    public string EatKeyword();
    public bool IsKeyword(string keyword);
    public bool IsEOF();
    public bool IsNumber();
    public bool IsToken(ConditionTokenType tokenType);
    public void GetNextToken();
    private static ConditionTokenType[] BuildCharIndexToTokenType();
    private void ParseSingleQuotedString(char ch);
    private void ParseKeyword(char ch);
    private void ParseNumber(char ch);
    private void SkipWhitespace();
    private int PeekChar();
    private int ReadChar();
}
internal enum NLog.Conditions.ConditionTokenType : Enum {
    public int value__;
    public static ConditionTokenType EndOfInput;
    public static ConditionTokenType BeginningOfInput;
    public static ConditionTokenType Number;
    public static ConditionTokenType String;
    public static ConditionTokenType Keyword;
    public static ConditionTokenType Whitespace;
    public static ConditionTokenType FirstPunct;
    public static ConditionTokenType LessThan;
    public static ConditionTokenType GreaterThan;
    public static ConditionTokenType LessThanOrEqualTo;
    public static ConditionTokenType GreaterThanOrEqualTo;
    public static ConditionTokenType EqualTo;
    public static ConditionTokenType NotEqual;
    public static ConditionTokenType LeftParen;
    public static ConditionTokenType RightParen;
    public static ConditionTokenType Dot;
    public static ConditionTokenType Comma;
    public static ConditionTokenType Not;
    public static ConditionTokenType And;
    public static ConditionTokenType Or;
    public static ConditionTokenType Minus;
    public static ConditionTokenType LastPunct;
    public static ConditionTokenType Invalid;
    public static ConditionTokenType ClosingCurlyBrace;
    public static ConditionTokenType Colon;
    public static ConditionTokenType Exclamation;
    public static ConditionTokenType Ampersand;
    public static ConditionTokenType Pipe;
}
[AttributeUsageAttribute("128")]
internal class NLog.Config.AdvancedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class NLog.Config.AppDomainFixedOutputAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class NLog.Config.ArrayParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    public Type ItemType { get; private set; }
    public string ElementName { get; private set; }
    public ArrayParameterAttribute(Type itemType, string elementName);
    [CompilerGeneratedAttribute]
public Type get_ItemType();
    [CompilerGeneratedAttribute]
private void set_ItemType(Type value);
    [CompilerGeneratedAttribute]
public string get_ElementName();
    [CompilerGeneratedAttribute]
private void set_ElementName(string value);
}
internal class NLog.Config.ConfigSectionHandler : object {
    private sealed virtual override object System.Configuration.IConfigurationSectionHandler.Create(object parent, object configContext, XmlNode section);
}
internal class NLog.Config.ConfigurationItemCreator : MulticastDelegate {
    public ConfigurationItemCreator(object object, IntPtr method);
    public virtual object Invoke(Type itemType);
    public virtual IAsyncResult BeginInvoke(Type itemType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class NLog.Config.ConfigurationItemFactory : object {
    private IList`1<object> allFactories;
    private Factory`2<Target, TargetAttribute> targets;
    private Factory`2<Filter, FilterAttribute> filters;
    private Factory`2<LayoutRenderer, LayoutRendererAttribute> layoutRenderers;
    private Factory`2<Layout, LayoutAttribute> layouts;
    private MethodFactory`2<ConditionMethodsAttribute, ConditionMethodAttribute> conditionMethods;
    private Factory`2<LayoutRenderer, AmbientPropertyAttribute> ambientProperties;
    [CompilerGeneratedAttribute]
private static ConfigurationItemFactory <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationItemCreator <CreateInstance>k__BackingField;
    public static ConfigurationItemFactory Default { get; public set; }
    public ConfigurationItemCreator CreateInstance { get; public set; }
    public INamedItemFactory`2<Target, Type> Targets { get; }
    public INamedItemFactory`2<Filter, Type> Filters { get; }
    public INamedItemFactory`2<LayoutRenderer, Type> LayoutRenderers { get; }
    public INamedItemFactory`2<Layout, Type> Layouts { get; }
    public INamedItemFactory`2<LayoutRenderer, Type> AmbientProperties { get; }
    public INamedItemFactory`2<MethodInfo, MethodInfo> ConditionMethods { get; }
    private static ConfigurationItemFactory();
    public ConfigurationItemFactory(Assembly[] assemblies);
    [CompilerGeneratedAttribute]
public static ConfigurationItemFactory get_Default();
    [CompilerGeneratedAttribute]
public static void set_Default(ConfigurationItemFactory value);
    [CompilerGeneratedAttribute]
public ConfigurationItemCreator get_CreateInstance();
    [CompilerGeneratedAttribute]
public void set_CreateInstance(ConfigurationItemCreator value);
    public INamedItemFactory`2<Target, Type> get_Targets();
    public INamedItemFactory`2<Filter, Type> get_Filters();
    public INamedItemFactory`2<LayoutRenderer, Type> get_LayoutRenderers();
    public INamedItemFactory`2<Layout, Type> get_Layouts();
    public INamedItemFactory`2<LayoutRenderer, Type> get_AmbientProperties();
    public INamedItemFactory`2<MethodInfo, MethodInfo> get_ConditionMethods();
    public void RegisterItemsFromAssembly(Assembly assembly);
    public void RegisterItemsFromAssembly(Assembly assembly, string itemNamePrefix);
    public void Clear();
    public void RegisterType(Type type, string itemNamePrefix);
    private static ConfigurationItemFactory BuildDefaultFactory();
    private void RegisterExtendedItems();
}
[AttributeUsageAttribute("128")]
internal class NLog.Config.DefaultParameterAttribute : Attribute {
}
internal class NLog.Config.Factory`2 : object {
    private Dictionary`2<string, GetTypeDelegate<TBaseType, TAttributeType>> items;
    private ConfigurationItemFactory parentFactory;
    internal Factory`2(ConfigurationItemFactory parentFactory);
    public sealed virtual void ScanAssembly(Assembly theAssembly, string prefix);
    public sealed virtual void RegisterType(Type type, string itemNamePrefix);
    public void RegisterNamedType(string itemName, string typeName);
    public sealed virtual void Clear();
    public sealed virtual void RegisterDefinition(string name, Type type);
    public sealed virtual bool TryGetDefinition(string itemName, Type& result);
    public sealed virtual bool TryCreateInstance(string itemName, TBaseType& result);
    public sealed virtual TBaseType CreateInstance(string name);
}
internal interface NLog.Config.IFactory {
    public abstract virtual void Clear();
    public abstract virtual void ScanAssembly(Assembly theAssembly, string prefix);
    public abstract virtual void RegisterType(Type type, string itemNamePrefix);
}
internal interface NLog.Config.IInstallable {
    public abstract virtual void Install(InstallationContext installationContext);
    public abstract virtual void Uninstall(InstallationContext installationContext);
    public abstract virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
}
internal interface NLog.Config.INamedItemFactory`2 {
    public abstract virtual void RegisterDefinition(string itemName, TDefinitionType itemDefinition);
    public abstract virtual bool TryGetDefinition(string itemName, TDefinitionType& result);
    public abstract virtual TInstanceType CreateInstance(string itemName);
    public abstract virtual bool TryCreateInstance(string itemName, TInstanceType& result);
}
internal class NLog.Config.InstallationContext : object {
    private static Dictionary`2<LogLevel, ConsoleColor> logLevel2ConsoleColor;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <LogOutput>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    public bool IgnoreFailures { get; public set; }
    public IDictionary`2<string, string> Parameters { get; private set; }
    public TextWriter LogOutput { get; public set; }
    public InstallationContext(TextWriter logOutput);
    private static InstallationContext();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailures();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailures(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public TextWriter get_LogOutput();
    [CompilerGeneratedAttribute]
public void set_LogOutput(TextWriter value);
    public void Trace(string message, Object[] arguments);
    public void Debug(string message, Object[] arguments);
    public void Info(string message, Object[] arguments);
    public void Warning(string message, Object[] arguments);
    public void Error(string message, Object[] arguments);
    public sealed virtual void Dispose();
    public LogEventInfo CreateLogEvent();
    private void Log(LogLevel logLevel, string message, Object[] arguments);
}
internal class NLog.Config.LoggingConfiguration : object {
    private IDictionary`2<string, Target> targets;
    private Object[] configItems;
    [CompilerGeneratedAttribute]
private IList`1<LoggingRule> <LoggingRules>k__BackingField;
    [CompilerGeneratedAttribute]
private static AsynchronousAction`1<Target> CS$<>9__CachedAnonymousMethodDelegate1;
    public ReadOnlyCollection`1<Target> ConfiguredNamedTargets { get; }
    public IEnumerable`1<string> FileNamesToWatch { get; }
    public IList`1<LoggingRule> LoggingRules { get; private set; }
    public ReadOnlyCollection`1<Target> AllTargets { get; }
    public ReadOnlyCollection`1<Target> get_ConfiguredNamedTargets();
    public virtual IEnumerable`1<string> get_FileNamesToWatch();
    [CompilerGeneratedAttribute]
public IList`1<LoggingRule> get_LoggingRules();
    [CompilerGeneratedAttribute]
private void set_LoggingRules(IList`1<LoggingRule> value);
    public ReadOnlyCollection`1<Target> get_AllTargets();
    public void AddTarget(string name, Target target);
    public Target FindTargetByName(string name);
    public virtual LoggingConfiguration Reload();
    public void RemoveTarget(string name);
    public void Install(InstallationContext installationContext);
    public void Uninstall(InstallationContext installationContext);
    internal void Close();
    internal void Dump();
    internal void FlushAllTargets(AsyncContinuation asyncContinuation);
    internal void ValidateConfig();
    internal void InitializeAll();
    internal void EnsureInitialized();
    [CompilerGeneratedAttribute]
private static void <FlushAllTargets>b__0(Target target, AsyncContinuation cont);
}
internal class NLog.Config.LoggingConfigurationChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LoggingConfiguration <OldConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <NewConfiguration>k__BackingField;
    public LoggingConfiguration OldConfiguration { get; private set; }
    public LoggingConfiguration NewConfiguration { get; private set; }
    internal LoggingConfigurationChangedEventArgs(LoggingConfiguration oldConfiguration, LoggingConfiguration newConfiguration);
    [CompilerGeneratedAttribute]
public LoggingConfiguration get_OldConfiguration();
    [CompilerGeneratedAttribute]
private void set_OldConfiguration(LoggingConfiguration value);
    [CompilerGeneratedAttribute]
public LoggingConfiguration get_NewConfiguration();
    [CompilerGeneratedAttribute]
private void set_NewConfiguration(LoggingConfiguration value);
}
internal class NLog.Config.LoggingConfigurationReloadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public bool Succeeded { get; private set; }
    public Exception Exception { get; private set; }
    internal LoggingConfigurationReloadedEventArgs(bool succeeded, Exception exception);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
private void set_Succeeded(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
[NLogConfigurationItemAttribute]
internal class NLog.Config.LoggingRule : object {
    private Boolean[] logLevels;
    private string loggerNamePattern;
    private MatchMode loggerNameMatchMode;
    private string loggerNameMatchArgument;
    [CompilerGeneratedAttribute]
private IList`1<Target> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LoggingRule> <ChildRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Filter> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Final>k__BackingField;
    public IList`1<Target> Targets { get; private set; }
    public IList`1<LoggingRule> ChildRules { get; private set; }
    public IList`1<Filter> Filters { get; private set; }
    public bool Final { get; public set; }
    public string LoggerNamePattern { get; public set; }
    public ReadOnlyCollection`1<LogLevel> Levels { get; }
    public LoggingRule(string loggerNamePattern, LogLevel minLevel, Target target);
    public LoggingRule(string loggerNamePattern, Target target);
    [CompilerGeneratedAttribute]
public IList`1<Target> get_Targets();
    [CompilerGeneratedAttribute]
private void set_Targets(IList`1<Target> value);
    [CompilerGeneratedAttribute]
public IList`1<LoggingRule> get_ChildRules();
    [CompilerGeneratedAttribute]
private void set_ChildRules(IList`1<LoggingRule> value);
    [CompilerGeneratedAttribute]
public IList`1<Filter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(IList`1<Filter> value);
    [CompilerGeneratedAttribute]
public bool get_Final();
    [CompilerGeneratedAttribute]
public void set_Final(bool value);
    public string get_LoggerNamePattern();
    public void set_LoggerNamePattern(string value);
    public ReadOnlyCollection`1<LogLevel> get_Levels();
    public void EnableLoggingForLevel(LogLevel level);
    public void DisableLoggingForLevel(LogLevel level);
    public virtual string ToString();
    public bool IsLoggingEnabledForLevel(LogLevel level);
    public bool NameMatches(string loggerName);
}
internal class NLog.Config.MethodFactory`2 : object {
    private Dictionary`2<string, MethodInfo> nameToMethodInfo;
    public IDictionary`2<string, MethodInfo> AllRegisteredItems { get; }
    public IDictionary`2<string, MethodInfo> get_AllRegisteredItems();
    public sealed virtual void ScanAssembly(Assembly theAssembly, string prefix);
    public sealed virtual void RegisterType(Type type, string itemNamePrefix);
    public sealed virtual void Clear();
    public sealed virtual void RegisterDefinition(string name, MethodInfo methodInfo);
    public sealed virtual bool TryCreateInstance(string name, MethodInfo& result);
    public sealed virtual MethodInfo CreateInstance(string name);
    public sealed virtual bool TryGetDefinition(string name, MethodInfo& result);
}
internal abstract class NLog.Config.NameBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    protected NameBaseAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("4")]
internal class NLog.Config.NLogConfigurationItemAttribute : Attribute {
}
internal class NLog.Config.NLogXmlElement : object {
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AttributeValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NLogXmlElement> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string LocalName { get; private set; }
    public Dictionary`2<string, string> AttributeValues { get; private set; }
    public IList`1<NLogXmlElement> Children { get; private set; }
    public string Value { get; private set; }
    public NLogXmlElement(string inputUri);
    public NLogXmlElement(XmlReader reader);
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
private void set_LocalName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AttributeValues();
    [CompilerGeneratedAttribute]
private void set_AttributeValues(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IList`1<NLogXmlElement> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<NLogXmlElement> value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public IEnumerable`1<NLogXmlElement> Elements(string elementName);
    public string GetRequiredAttribute(string attributeName);
    public bool GetOptionalBooleanAttribute(string attributeName, bool defaultValue);
    public string GetOptionalAttribute(string attributeName, string defaultValue);
    public void AssertName(String[] allowedNames);
    private void Parse(XmlReader reader);
}
[AttributeUsageAttribute("128")]
internal class NLog.Config.RequiredParameterAttribute : Attribute {
}
internal static class NLog.Config.SimpleConfigurator : object {
    public static void ConfigureForConsoleLogging();
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public static void ConfigureForConsoleLogging(LogLevel minLevel);
    public static void ConfigureForTargetLogging(Target target);
    public static void ConfigureForTargetLogging(Target target, LogLevel minLevel);
    public static void ConfigureForFileLogging(string fileName);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public static void ConfigureForFileLogging(string fileName, LogLevel minLevel);
}
internal enum NLog.Config.StackTraceUsage : Enum {
    public int value__;
    public static StackTraceUsage None;
    public static StackTraceUsage WithoutSource;
    public static StackTraceUsage WithSource;
    public static StackTraceUsage Max;
}
[AttributeUsageAttribute("4")]
internal class NLog.Config.ThreadAgnosticAttribute : Attribute {
}
internal class NLog.Config.XmlLoggingConfiguration : LoggingConfiguration {
    private ConfigurationItemFactory configurationItemFactory;
    private Dictionary`2<string, bool> visitedFile;
    private Dictionary`2<string, string> variables;
    private string originalFileName;
    [CompilerGeneratedAttribute]
private bool <AutoReload>k__BackingField;
    public static LoggingConfiguration AppConfig { get; }
    public bool AutoReload { get; public set; }
    public IEnumerable`1<string> FileNamesToWatch { get; }
    public XmlLoggingConfiguration(string fileName);
    public XmlLoggingConfiguration(string fileName, bool ignoreErrors);
    public XmlLoggingConfiguration(XmlReader reader, string fileName);
    public XmlLoggingConfiguration(XmlReader reader, string fileName, bool ignoreErrors);
    internal XmlLoggingConfiguration(XmlElement element, string fileName);
    internal XmlLoggingConfiguration(XmlElement element, string fileName, bool ignoreErrors);
    public static LoggingConfiguration get_AppConfig();
    [CompilerGeneratedAttribute]
public bool get_AutoReload();
    [CompilerGeneratedAttribute]
public void set_AutoReload(bool value);
    public virtual IEnumerable`1<string> get_FileNamesToWatch();
    public virtual LoggingConfiguration Reload();
    private static bool IsTargetElement(string name);
    private static bool IsTargetRefElement(string name);
    private static string CleanWhitespace(string s);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private static Target WrapWithAsyncTargetWrapper(Target target);
    private void Initialize(XmlReader reader, string fileName, bool ignoreErrors);
    private void ConfigureFromFile(string fileName);
    private void ParseTopLevel(NLogXmlElement content, string baseDirectory);
    private void ParseConfigurationElement(NLogXmlElement configurationElement, string baseDirectory);
    private void ParseNLogElement(NLogXmlElement nlogElement, string baseDirectory);
    private void ParseRulesElement(NLogXmlElement rulesElement, IList`1<LoggingRule> rulesCollection);
    private void ParseLoggerElement(NLogXmlElement loggerElement, IList`1<LoggingRule> rulesCollection);
    private void ParseFilters(LoggingRule rule, NLogXmlElement filtersElement);
    private void ParseVariableElement(NLogXmlElement variableElement);
    private void ParseTargetsElement(NLogXmlElement targetsElement);
    private void ParseTargetElement(Target target, NLogXmlElement targetElement);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods")]
private void ParseExtensionsElement(NLogXmlElement extensionsElement, string baseDirectory);
    private void ParseIncludeElement(NLogXmlElement includeElement, string baseDirectory);
    private void SetPropertyFromElement(object o, NLogXmlElement element);
    private bool AddArrayItemFromElement(object o, NLogXmlElement element);
    private void ConfigureObjectFromAttributes(object targetObject, NLogXmlElement element, bool ignoreType);
    private bool SetLayoutFromElement(object o, NLogXmlElement layoutElement);
    private void ConfigureObjectFromElement(object targetObject, NLogXmlElement element);
    private Target WrapWithDefaultWrapper(Target t, NLogXmlElement defaultParameters);
    private string ExpandVariables(string input);
}
[FilterAttribute("when")]
internal class NLog.Filters.ConditionBasedFilter : Filter {
    private static object boxedTrue;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    private static ConditionBasedFilter();
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
internal abstract class NLog.Filters.Filter : object {
    [CompilerGeneratedAttribute]
private FilterResult <Action>k__BackingField;
    [RequiredParameterAttribute]
public FilterResult Action { get; public set; }
    [CompilerGeneratedAttribute]
public FilterResult get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(FilterResult value);
    internal FilterResult GetFilterResult(LogEventInfo logEvent);
    protected abstract virtual FilterResult Check(LogEventInfo logEvent);
}
[AttributeUsageAttribute("4")]
internal class NLog.Filters.FilterAttribute : NameBaseAttribute {
    public FilterAttribute(string name);
}
internal enum NLog.Filters.FilterResult : Enum {
    public int value__;
    public static FilterResult Neutral;
    public static FilterResult Log;
    public static FilterResult Ignore;
    public static FilterResult LogFinal;
    public static FilterResult IgnoreFinal;
}
internal abstract class NLog.Filters.LayoutBasedFilter : Filter {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
}
[FilterAttribute("whenContains")]
internal class NLog.Filters.WhenContainsFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Substring>k__BackingField;
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    [RequiredParameterAttribute]
public string Substring { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public string get_Substring();
    [CompilerGeneratedAttribute]
public void set_Substring(string value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenEqual")]
internal class NLog.Filters.WhenEqualFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompareTo>k__BackingField;
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    [RequiredParameterAttribute]
public string CompareTo { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public string get_CompareTo();
    [CompilerGeneratedAttribute]
public void set_CompareTo(string value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenNotContains")]
internal class NLog.Filters.WhenNotContainsFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private string <Substring>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [RequiredParameterAttribute]
public string Substring { get; public set; }
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Substring();
    [CompilerGeneratedAttribute]
public void set_Substring(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[FilterAttribute("whenNotEqual")]
internal class NLog.Filters.WhenNotEqualFilter : LayoutBasedFilter {
    [CompilerGeneratedAttribute]
private string <CompareTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [RequiredParameterAttribute]
public string CompareTo { get; public set; }
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CompareTo();
    [CompilerGeneratedAttribute]
public void set_CompareTo(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    protected virtual FilterResult Check(LogEventInfo logEvent);
}
[ObsoleteAttribute("Use GlobalDiagnosticsContext instead")]
internal static class NLog.GDC : object {
    public static void Set(string item, string value);
    public static string Get(string item);
    public static bool Contains(string item);
    public static void Remove(string item);
    public static void Clear();
}
internal static class NLog.GlobalDiagnosticsContext : object {
    private static Dictionary`2<string, string> dict;
    private static GlobalDiagnosticsContext();
    public static void Set(string item, string value);
    public static string Get(string item);
    public static bool Contains(string item);
    public static void Remove(string item);
    public static void Clear();
}
internal class NLog.Internal.AspHelper : object {
    private static Guid IID_IObjectContext;
    private static AspHelper();
    public static ISessionObject GetSessionObject();
    public static IApplicationObject GetApplicationObject();
    public static IRequest GetRequestObject();
    public static IResponse GetResponseObject();
    public static object GetComDefaultProperty(object o);
}
internal class NLog.Internal.CurrentTimeGetter : object {
    private static int lastTicks;
    private static DateTime lastDateTime;
    public static DateTime Now { get; }
    private static CurrentTimeGetter();
    public static DateTime get_Now();
}
[DefaultMemberAttribute("Item")]
internal class NLog.Internal.DictionaryAdapter`2 : object {
    private IDictionary`2<TKey, TValue> implementation;
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public object Item { get; public set; }
    public DictionaryAdapter`2(IDictionary`2<TKey, TValue> implementation);
    public sealed virtual ICollection get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class NLog.Internal.EnumerableHelpers : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> OfType(IEnumerable enumerable);
    [ExtensionAttribute]
public static IEnumerable`1<T> Reverse(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> enumerable, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static List`1<T> ToList(IEnumerable`1<T> enumerable);
}
internal static class NLog.Internal.EnvironmentHelper : object {
    internal static string NewLine { get; }
    internal static string get_NewLine();
    internal static string GetSafeEnvironmentVariable(string name);
}
[ExtensionAttribute]
internal static class NLog.Internal.ExceptionHelper : object {
    [ExtensionAttribute]
public static bool MustBeRethrown(Exception exception);
}
internal class NLog.Internal.FactoryHelper : object {
    private static Type[] emptyTypes;
    private static Object[] emptyParams;
    private static FactoryHelper();
    internal static object CreateInstance(Type t);
}
internal abstract class NLog.Internal.FileAppenders.BaseFileAppender : object {
    private Random random;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <OpenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ICreateFileParameters <CreateFileParameters>k__BackingField;
    public string FileName { get; private set; }
    public DateTime LastWriteTime { get; private set; }
    public DateTime OpenTime { get; private set; }
    public ICreateFileParameters CreateFileParameters { get; private set; }
    public BaseFileAppender(string fileName, ICreateFileParameters createParameters);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastWriteTime();
    [CompilerGeneratedAttribute]
private void set_LastWriteTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_OpenTime();
    [CompilerGeneratedAttribute]
private void set_OpenTime(DateTime value);
    [CompilerGeneratedAttribute]
public ICreateFileParameters get_CreateFileParameters();
    [CompilerGeneratedAttribute]
private void set_CreateFileParameters(ICreateFileParameters value);
    public abstract virtual void Write(Byte[] bytes);
    public abstract virtual void Flush();
    public abstract virtual void Close();
    public abstract virtual bool GetFileInfo(DateTime& lastWriteTime, Int64& fileLength);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void FileTouched();
    protected void FileTouched(DateTime dateTime);
    protected FileStream CreateFileStream(bool allowConcurrentWrite);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private FileStream WindowsCreateFile(string fileName, bool allowConcurrentWrite);
    private FileStream TryCreateFileStream(bool allowConcurrentWrite);
}
internal class NLog.Internal.FileAppenders.CountingSingleProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream file;
    private long currentFileLength;
    public CountingSingleProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static CountingSingleProcessFileAppender();
    public virtual void Close();
    public virtual void Flush();
    public virtual bool GetFileInfo(DateTime& lastWriteTime, Int64& fileLength);
    public virtual void Write(Byte[] bytes);
}
internal interface NLog.Internal.FileAppenders.ICreateFileParameters {
    public int ConcurrentWriteAttemptDelay { get; }
    public int ConcurrentWriteAttempts { get; }
    public bool ConcurrentWrites { get; }
    public bool CreateDirs { get; }
    public bool EnableFileDelete { get; }
    public int BufferSize { get; }
    public Win32FileAttributes FileAttributes { get; }
    public abstract virtual int get_ConcurrentWriteAttemptDelay();
    public abstract virtual int get_ConcurrentWriteAttempts();
    public abstract virtual bool get_ConcurrentWrites();
    public abstract virtual bool get_CreateDirs();
    public abstract virtual bool get_EnableFileDelete();
    public abstract virtual int get_BufferSize();
    public abstract virtual Win32FileAttributes get_FileAttributes();
}
internal interface NLog.Internal.FileAppenders.IFileAppenderFactory {
    public abstract virtual BaseFileAppender Open(string fileName, ICreateFileParameters parameters);
}
internal class NLog.Internal.FileAppenders.MutexMultiProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream file;
    private Mutex mutex;
    public MutexMultiProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static MutexMultiProcessFileAppender();
    public virtual void Write(Byte[] bytes);
    public virtual void Close();
    public virtual void Flush();
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods")]
public virtual bool GetFileInfo(DateTime& lastWriteTime, Int64& fileLength);
    private static string GetMutexName(string fileName);
}
internal class NLog.Internal.FileAppenders.RetryingMultiProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    public RetryingMultiProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static RetryingMultiProcessFileAppender();
    public virtual void Write(Byte[] bytes);
    public virtual void Flush();
    public virtual void Close();
    public virtual bool GetFileInfo(DateTime& lastWriteTime, Int64& fileLength);
}
internal class NLog.Internal.FileAppenders.SingleProcessFileAppender : BaseFileAppender {
    public static IFileAppenderFactory TheFactory;
    private FileStream file;
    public SingleProcessFileAppender(string fileName, ICreateFileParameters parameters);
    private static SingleProcessFileAppender();
    public virtual void Write(Byte[] bytes);
    public virtual void Flush();
    public virtual void Close();
    public virtual bool GetFileInfo(DateTime& lastWriteTime, Int64& fileLength);
}
internal abstract class NLog.Internal.FileInfoHelper : object {
    [CompilerGeneratedAttribute]
private static FileInfoHelper <Helper>k__BackingField;
    internal static FileInfoHelper Helper { get; private set; }
    private static FileInfoHelper();
    [CompilerGeneratedAttribute]
internal static FileInfoHelper get_Helper();
    [CompilerGeneratedAttribute]
private static void set_Helper(FileInfoHelper value);
    public abstract virtual bool GetFileInfo(string fileName, IntPtr fileHandle, DateTime& lastWriteTime, Int64& fileLength);
}
internal class NLog.Internal.FormHelper : object {
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
internal static RichTextBox CreateRichTextBox(string name, Form parentForm);
    internal static Control FindControl(string name, Control searchControl);
    internal static TControl FindControl(string name, Control searchControl);
    [SuppressMessageAttribute("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
[SuppressMessageAttribute("Microsoft.Globalization", "CA1303:Do not pass literals as localized parameters")]
[SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
internal static Form CreateForm(string name, int width, int height, bool show, bool showMinimized, bool toolWindow);
    private static Icon GetNLogIcon();
}
internal interface NLog.Internal.IRenderable {
    public abstract virtual string Render(LogEventInfo logEvent);
}
internal interface NLog.Internal.ISmtpClient {
    public string Host { get; public set; }
    public int Port { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public bool EnableSsl { get; public set; }
    public abstract virtual string get_Host();
    public abstract virtual void set_Host(string value);
    public abstract virtual int get_Port();
    public abstract virtual void set_Port(int value);
    public abstract virtual ICredentialsByHost get_Credentials();
    public abstract virtual void set_Credentials(ICredentialsByHost value);
    public abstract virtual bool get_EnableSsl();
    public abstract virtual void set_EnableSsl(bool value);
    public abstract virtual void Send(MailMessage msg);
}
internal interface NLog.Internal.ISupportsInitialize {
    public abstract virtual void Initialize(LoggingConfiguration configuration);
    public abstract virtual void Close();
}
internal interface NLog.Internal.IUsesStackTrace {
    public StackTraceUsage StackTraceUsage { get; }
    public abstract virtual StackTraceUsage get_StackTraceUsage();
}
internal class NLog.Internal.LoggerConfiguration : object {
    private TargetWithFilterChain[] targetsByLevel;
    public LoggerConfiguration(TargetWithFilterChain[] targetsByLevel);
    public TargetWithFilterChain GetTargetsForLevel(LogLevel level);
    public bool IsEnabled(LogLevel level);
}
internal class NLog.Internal.MessageBoxHelper : object {
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1300:SpecifyMessageBoxOptions")]
public static void Show(string message, string caption);
}
internal class NLog.Internal.MultiFileWatcher : object {
    private List`1<FileSystemWatcher> watchers;
    private EventHandler OnChange;
    public void add_OnChange(EventHandler value);
    public void remove_OnChange(EventHandler value);
    public sealed virtual void Dispose();
    public void StopWatching();
    public void Watch(IEnumerable`1<string> fileNames);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
internal void Watch(string fileName);
    private void OnWatcherChanged(object source, FileSystemEventArgs e);
}
internal class NLog.Internal.MySmtpClient : SmtpClient {
    private sealed virtual override string NLog.Internal.ISmtpClient.get_Host();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Host(string );
    private sealed virtual override int NLog.Internal.ISmtpClient.get_Port();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Port(int );
    private sealed virtual override ICredentialsByHost NLog.Internal.ISmtpClient.get_Credentials();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_Credentials(ICredentialsByHost );
    private sealed virtual override bool NLog.Internal.ISmtpClient.get_EnableSsl();
    private sealed virtual override void NLog.Internal.ISmtpClient.set_EnableSsl(bool );
    private sealed virtual override void NLog.Internal.ISmtpClient.Send(MailMessage );
}
internal static class NLog.Internal.NativeMethods : object {
    internal static bool LogonUser(string pszUsername, string pszDomain, string pszPassword, int dwLogonType, int dwLogonProvider, IntPtr& phToken);
    internal static bool CloseHandle(IntPtr handle);
    internal static bool DuplicateToken(IntPtr existingTokenHandle, int impersonationLevel, IntPtr& duplicateTokenHandle);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api")]
internal static void OutputDebugString(string message);
    internal static bool QueryPerformanceCounter(UInt64& lpPerformanceCount);
    internal static bool QueryPerformanceFrequency(UInt64& lpPerformanceFrequency);
    internal static int GetCurrentProcessId();
    [SuppressMessageAttribute("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation")]
internal static UInt32 GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
    internal static int CoGetObjectContext(Guid& iid, IObjectContext& g);
}
internal class NLog.Internal.NetworkSenders.HttpNetworkSender : NetworkSender {
    public HttpNetworkSender(string url);
    protected virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
}
internal interface NLog.Internal.NetworkSenders.INetworkSenderFactory {
    public abstract virtual NetworkSender Create(string url);
}
internal interface NLog.Internal.NetworkSenders.ISocket {
    public abstract virtual bool ConnectAsync(SocketAsyncEventArgs args);
    public abstract virtual void Close();
    public abstract virtual bool SendAsync(SocketAsyncEventArgs args);
    public abstract virtual bool SendToAsync(SocketAsyncEventArgs args);
}
internal abstract class NLog.Internal.NetworkSenders.NetworkSender : object {
    private static int currentSendTime;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastSendTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static AsyncContinuation CS$<>9__CachedAnonymousMethodDelegate1;
    public string Address { get; private set; }
    public int LastSendTime { get; private set; }
    protected NetworkSender(string url);
    protected virtual void Finalize();
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(string value);
    [CompilerGeneratedAttribute]
public int get_LastSendTime();
    [CompilerGeneratedAttribute]
private void set_LastSendTime(int value);
    public void Initialize();
    public void Close(AsyncContinuation continuation);
    public void FlushAsync(AsyncContinuation continuation);
    public void Send(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    public sealed virtual void Dispose();
    protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    protected virtual void DoFlush(AsyncContinuation continuation);
    protected abstract virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    protected virtual EndPoint ParseEndpointAddress(Uri uri, AddressFamily addressFamily);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private static void <Dispose>b__0(Exception ex);
}
internal class NLog.Internal.NetworkSenders.NetworkSenderFactory : object {
    public static INetworkSenderFactory Default;
    private static NetworkSenderFactory();
    public sealed virtual NetworkSender Create(string url);
}
internal class NLog.Internal.NetworkSenders.SocketProxy : object {
    private Socket socket;
    internal SocketProxy(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public sealed virtual void Close();
    public sealed virtual bool ConnectAsync(SocketAsyncEventArgs args);
    public sealed virtual bool SendAsync(SocketAsyncEventArgs args);
    public sealed virtual bool SendToAsync(SocketAsyncEventArgs args);
    public sealed virtual void Dispose();
}
internal class NLog.Internal.NetworkSenders.TcpNetworkSender : NetworkSender {
    private Queue`1<SocketAsyncEventArgs> pendingRequests;
    private ISocket socket;
    private Exception pendingError;
    private bool asyncOperationInProgress;
    private AsyncContinuation closeContinuation;
    private AsyncContinuation flushContinuation;
    [CompilerGeneratedAttribute]
private AddressFamily <AddressFamily>k__BackingField;
    internal AddressFamily AddressFamily { get; internal set; }
    public TcpNetworkSender(string url, AddressFamily addressFamily);
    [CompilerGeneratedAttribute]
internal AddressFamily get_AddressFamily();
    [CompilerGeneratedAttribute]
internal void set_AddressFamily(AddressFamily value);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected internal virtual ISocket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    protected virtual void DoFlush(AsyncContinuation continuation);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    private void CloseSocket(AsyncContinuation continuation);
    private void SocketOperationCompleted(object sender, SocketAsyncEventArgs e);
    private void ProcessNextQueuedItem();
}
internal class NLog.Internal.NetworkSenders.UdpNetworkSender : NetworkSender {
    private ISocket socket;
    private EndPoint endpoint;
    [CompilerGeneratedAttribute]
private AddressFamily <AddressFamily>k__BackingField;
    internal AddressFamily AddressFamily { get; internal set; }
    public UdpNetworkSender(string url, AddressFamily addressFamily);
    [CompilerGeneratedAttribute]
internal AddressFamily get_AddressFamily();
    [CompilerGeneratedAttribute]
internal void set_AddressFamily(AddressFamily value);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected internal virtual ISocket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    protected virtual void DoInitialize();
    protected virtual void DoClose(AsyncContinuation continuation);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
protected virtual void DoSend(Byte[] bytes, int offset, int length, AsyncContinuation asyncContinuation);
    private void SocketOperationCompleted(object sender, SocketAsyncEventArgs e);
}
internal class NLog.Internal.ObjectGraphScanner : object {
    public static T[] FindReachableObjects(Object[] rootObjects);
    private static void ScanProperties(List`1<T> result, object o, int level, Dictionary`2<object, int> visitedObjects);
}
internal static class NLog.Internal.ParameterUtils : object {
    public static void AssertNotNull(object value, string parameterName);
}
internal static class NLog.Internal.PlatformDetector : object {
    private static RuntimeOS currentOS;
    public static RuntimeOS CurrentOS { get; }
    public static bool IsDesktopWin32 { get; }
    public static bool IsWin32 { get; }
    public static bool IsUnix { get; }
    private static PlatformDetector();
    public static RuntimeOS get_CurrentOS();
    public static bool get_IsDesktopWin32();
    public static bool get_IsWin32();
    public static bool get_IsUnix();
    private static RuntimeOS GetCurrentRuntimeOS();
}
internal class NLog.Internal.PortableFileInfoHelper : FileInfoHelper {
    public virtual bool GetFileInfo(string fileName, IntPtr fileHandle, DateTime& lastWriteTime, Int64& fileLength);
}
internal class NLog.Internal.PortableThreadIDHelper : ThreadIDHelper {
    private static string UnknownProcessName;
    private int currentProcessID;
    private string currentProcessName;
    private string currentProcessBaseName;
    public int CurrentThreadID { get; }
    public int CurrentProcessID { get; }
    public string CurrentProcessName { get; }
    public string CurrentProcessBaseName { get; }
    public virtual int get_CurrentThreadID();
    public virtual int get_CurrentProcessID();
    public virtual string get_CurrentProcessName();
    public virtual string get_CurrentProcessBaseName();
    private void GetProcessName();
}
internal static class NLog.Internal.PropertyHelper : object {
    private static Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> parameterInfoCache;
    private static PropertyHelper();
    internal static void SetPropertyFromString(object o, string name, string value, ConfigurationItemFactory configurationItemFactory);
    internal static bool IsArrayProperty(Type t, string name);
    internal static bool TryGetPropertyInfo(object o, string propertyName, PropertyInfo& result);
    internal static Type GetArrayItemType(PropertyInfo propInfo);
    internal static IEnumerable`1<PropertyInfo> GetAllReadableProperties(Type type);
    internal static void CheckRequiredParameters(object o);
    private static bool TryImplicitConversion(Type resultType, string value, Object& result);
    private static bool TryNLogSpecificConversion(Type propertyType, string value, Object& newValue, ConfigurationItemFactory configurationItemFactory);
    private static bool TryGetEnumValue(Type resultType, string value, Object& result);
    private static bool TrySpecialConversion(Type type, string value, Object& newValue);
    private static bool TryGetPropertyInfo(Type targetType, string propertyName, PropertyInfo& result);
    private static Dictionary`2<string, PropertyInfo> BuildPropertyInfoDictionary(Type t);
}
[ExtensionAttribute]
internal static class NLog.Internal.ReflectionHelpers : object {
    [ExtensionAttribute]
public static Type[] SafeGetTypes(Assembly assembly);
}
internal enum NLog.Internal.RuntimeOS : Enum {
    public int value__;
    public static RuntimeOS Any;
    public static RuntimeOS Unix;
    public static RuntimeOS WindowsCE;
    public static RuntimeOS Windows;
    public static RuntimeOS WindowsNT;
    public static RuntimeOS Unknown;
}
internal class NLog.Internal.SimpleStringReader : object {
    private string text;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Position { get; internal set; }
    internal string Text { get; }
    public SimpleStringReader(string text);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    internal string get_Text();
    internal int Peek();
    internal int Read();
    internal string Substring(int p0, int p1);
}
internal class NLog.Internal.SingleCallContinuation : object {
    private AsyncContinuation asyncContinuation;
    public SingleCallContinuation(AsyncContinuation asyncContinuation);
    public void Function(Exception exception);
    private static void ReportExceptionInHandler(Exception exception);
}
[ExtensionAttribute]
internal static class NLog.Internal.SortHelpers : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, List`1<TValue>> BucketSort(IEnumerable`1<TValue> inputs, KeySelector`2<TValue, TKey> keySelector);
}
internal class NLog.Internal.StackTraceUsageUtils : object {
    internal static StackTraceUsage Max(StackTraceUsage u1, StackTraceUsage u2);
}
[NLogConfigurationItemAttribute]
internal class NLog.Internal.TargetWithFilterChain : object {
    private StackTraceUsage stackTraceUsage;
    [CompilerGeneratedAttribute]
private Target <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Filter> <FilterChain>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetWithFilterChain <NextInChain>k__BackingField;
    public Target Target { get; private set; }
    public IList`1<Filter> FilterChain { get; private set; }
    public TargetWithFilterChain NextInChain { get; public set; }
    public TargetWithFilterChain(Target target, IList`1<Filter> filterChain);
    [CompilerGeneratedAttribute]
public Target get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(Target value);
    [CompilerGeneratedAttribute]
public IList`1<Filter> get_FilterChain();
    [CompilerGeneratedAttribute]
private void set_FilterChain(IList`1<Filter> value);
    [CompilerGeneratedAttribute]
public TargetWithFilterChain get_NextInChain();
    [CompilerGeneratedAttribute]
public void set_NextInChain(TargetWithFilterChain value);
    public StackTraceUsage GetStackTraceUsage();
    internal void PrecalculateStackTraceUsage();
}
internal abstract class NLog.Internal.ThreadIDHelper : object {
    [CompilerGeneratedAttribute]
private static ThreadIDHelper <Instance>k__BackingField;
    public static ThreadIDHelper Instance { get; private set; }
    public int CurrentThreadID { get; }
    public int CurrentProcessID { get; }
    public string CurrentProcessName { get; }
    public string CurrentProcessBaseName { get; }
    private static ThreadIDHelper();
    [CompilerGeneratedAttribute]
public static ThreadIDHelper get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(ThreadIDHelper value);
    public abstract virtual int get_CurrentThreadID();
    public abstract virtual int get_CurrentProcessID();
    public abstract virtual string get_CurrentProcessName();
    public abstract virtual string get_CurrentProcessBaseName();
}
internal static class NLog.Internal.ThreadLocalStorageHelper : object {
    public static object AllocateDataSlot();
    public static T GetDataForSlot(object slot);
}
internal class NLog.Internal.TimeoutContinuation : object {
    private AsyncContinuation asyncContinuation;
    private Timer timeoutTimer;
    public TimeoutContinuation(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public void Function(Exception exception);
    public sealed virtual void Dispose();
    private static void ReportExceptionInHandler(Exception exception);
    private void StopTimer();
    private void TimerElapsed(object state);
}
internal class NLog.Internal.UrlHelper : object {
    private static string safeUrlPunctuation;
    private static string hexChars;
    private static UrlHelper();
    internal static string UrlEncode(string str, bool spaceAsPlus);
    private static bool IsSafeUrlCharacter(char ch);
}
internal class NLog.Internal.Win32FileInfoHelper : FileInfoHelper {
    public virtual bool GetFileInfo(string fileName, IntPtr fileHandle, DateTime& lastWriteTime, Int64& fileLength);
}
internal static class NLog.Internal.Win32FileNativeMethods : object {
    public static int FILE_SHARE_READ;
    public static int FILE_SHARE_WRITE;
    public static int FILE_SHARE_DELETE;
    public static IntPtr CreateFile(string lpFileName, FileAccess dwDesiredAccess, int dwShareMode, IntPtr lpSecurityAttributes, CreationDisposition dwCreationDisposition, Win32FileAttributes dwFlagsAndAttributes, IntPtr hTemplateFile);
    public static bool GetFileInformationByHandle(IntPtr hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
}
internal class NLog.Internal.Win32ThreadIDHelper : ThreadIDHelper {
    private int currentProcessID;
    private string currentProcessName;
    private string currentProcessBaseName;
    public int CurrentThreadID { get; }
    public int CurrentProcessID { get; }
    public string CurrentProcessName { get; }
    public string CurrentProcessBaseName { get; }
    public virtual int get_CurrentThreadID();
    public virtual int get_CurrentProcessID();
    public virtual string get_CurrentProcessName();
    public virtual string get_CurrentProcessBaseName();
}
[AttributeUsageAttribute("4")]
internal class NLog.LayoutRenderers.AmbientPropertyAttribute : NameBaseAttribute {
    public AmbientPropertyAttribute(string name);
}
[LayoutRendererAttribute("asp-application")]
internal class NLog.LayoutRenderers.AspApplicationValueLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Variable { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("asp-request")]
internal class NLog.LayoutRenderers.AspRequestValueLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Form>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Cookie>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerVariable>k__BackingField;
    [DefaultParameterAttribute]
public string Item { get; public set; }
    public string QueryString { get; public set; }
    public string Form { get; public set; }
    public string Cookie { get; public set; }
    public string ServerVariable { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public string get_QueryString();
    [CompilerGeneratedAttribute]
public void set_QueryString(string value);
    [CompilerGeneratedAttribute]
public string get_Form();
    [CompilerGeneratedAttribute]
public void set_Form(string value);
    [CompilerGeneratedAttribute]
public string get_Cookie();
    [CompilerGeneratedAttribute]
public void set_Cookie(string value);
    [CompilerGeneratedAttribute]
public string get_ServerVariable();
    [CompilerGeneratedAttribute]
public void set_ServerVariable(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static string GetItem(IRequestDictionary dict, string key);
}
[LayoutRendererAttribute("asp-session")]
internal class NLog.LayoutRenderers.AspSessionValueLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Variable { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("basedir")]
[AppDomainFixedOutputAttribute]
internal class NLog.LayoutRenderers.BaseDirLayoutRenderer : LayoutRenderer {
    private string baseDir;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("callsite")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.CallSiteLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSourcePath>k__BackingField;
    [DefaultValueAttribute("True")]
public bool ClassName { get; public set; }
    [DefaultValueAttribute("True")]
public bool MethodName { get; public set; }
    [DefaultValueAttribute("False")]
public bool FileName { get; public set; }
    [DefaultValueAttribute("True")]
public bool IncludeSourcePath { get; public set; }
    private StackTraceUsage NLog.Internal.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public bool get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(bool value);
    [CompilerGeneratedAttribute]
public bool get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(bool value);
    [CompilerGeneratedAttribute]
public bool get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSourcePath();
    [CompilerGeneratedAttribute]
public void set_IncludeSourcePath(bool value);
    private sealed virtual override StackTraceUsage NLog.Internal.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("counter")]
internal class NLog.LayoutRenderers.CounterLayoutRenderer : LayoutRenderer {
    private static Dictionary`2<string, int> sequences;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sequence>k__BackingField;
    [DefaultValueAttribute("1")]
public int Value { get; public set; }
    [DefaultValueAttribute("1")]
public int Increment { get; public set; }
    public string Sequence { get; public set; }
    private static CounterLayoutRenderer();
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    [CompilerGeneratedAttribute]
public int get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(int value);
    [CompilerGeneratedAttribute]
public string get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static int GetNextSequenceValue(string sequenceName, int defaultValue, int increment);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("date")]
internal class NLog.LayoutRenderers.DateLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniversalTime>k__BackingField;
    public CultureInfo Culture { get; public set; }
    [DefaultParameterAttribute]
public string Format { get; public set; }
    [DefaultValueAttribute("False")]
public bool UniversalTime { get; public set; }
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public bool get_UniversalTime();
    [CompilerGeneratedAttribute]
public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("environment")]
internal class NLog.LayoutRenderers.EnvironmentLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [RequiredParameterAttribute]
[DefaultParameterAttribute]
public string Variable { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("event-context")]
internal class NLog.LayoutRenderers.EventContextLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Item { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("exception")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.ExceptionLayoutRenderer : LayoutRenderer {
    private string format;
    private string innerFormat;
    private ExceptionDataTarget[] exceptionDataTargets;
    private ExceptionDataTarget[] innerExceptionDataTargets;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxInnerExceptionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InnerExceptionSeparator>k__BackingField;
    [DefaultParameterAttribute]
public string Format { get; public set; }
    public string InnerFormat { get; public set; }
    [DefaultValueAttribute(" ")]
public string Separator { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxInnerExceptionLevel { get; public set; }
    public string InnerExceptionSeparator { get; public set; }
    public string get_Format();
    public void set_Format(string value);
    public string get_InnerFormat();
    public void set_InnerFormat(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public int get_MaxInnerExceptionLevel();
    [CompilerGeneratedAttribute]
public void set_MaxInnerExceptionLevel(int value);
    [CompilerGeneratedAttribute]
public string get_InnerExceptionSeparator();
    [CompilerGeneratedAttribute]
public void set_InnerExceptionSeparator(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void AppendMessage(StringBuilder sb, Exception ex);
    private static void AppendMethod(StringBuilder sb, Exception ex);
    private static void AppendStackTrace(StringBuilder sb, Exception ex);
    private static void AppendToString(StringBuilder sb, Exception ex);
    private static void AppendType(StringBuilder sb, Exception ex);
    private static void AppendShortType(StringBuilder sb, Exception ex);
    private static ExceptionDataTarget[] CompileFormat(string formatSpecifier);
}
[LayoutRendererAttribute("file-contents")]
internal class NLog.LayoutRenderers.FileContentsLayoutRenderer : LayoutRenderer {
    private string lastFileName;
    private string currentFileContents;
    [CompilerGeneratedAttribute]
private Layout <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [DefaultParameterAttribute]
public Layout FileName { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(Layout value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private string ReadFileContents(string fileName);
}
[LayoutRendererAttribute("gc")]
internal class NLog.LayoutRenderers.GarbageCollectorInfoLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private GarbageCollectorProperty <Property>k__BackingField;
    [DefaultValueAttribute("TotalMemory")]
public GarbageCollectorProperty Property { get; public set; }
    [CompilerGeneratedAttribute]
public GarbageCollectorProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(GarbageCollectorProperty value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
internal enum NLog.LayoutRenderers.GarbageCollectorProperty : Enum {
    public int value__;
    public static GarbageCollectorProperty TotalMemory;
    public static GarbageCollectorProperty TotalMemoryForceCollection;
    public static GarbageCollectorProperty CollectionCount0;
    public static GarbageCollectorProperty CollectionCount1;
    public static GarbageCollectorProperty CollectionCount2;
    public static GarbageCollectorProperty MaxGeneration;
}
[LayoutRendererAttribute("gdc")]
internal class NLog.LayoutRenderers.GdcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Item { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("guid")]
internal class NLog.LayoutRenderers.GuidLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [DefaultValueAttribute("N")]
public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("identity")]
internal class NLog.LayoutRenderers.IdentityLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AuthType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAuthenticated>k__BackingField;
    [DefaultValueAttribute(":")]
public string Separator { get; public set; }
    [DefaultValueAttribute("True")]
public bool Name { get; public set; }
    [DefaultValueAttribute("True")]
public bool AuthType { get; public set; }
    [DefaultValueAttribute("True")]
public bool IsAuthenticated { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(bool value);
    [CompilerGeneratedAttribute]
public bool get_AuthType();
    [CompilerGeneratedAttribute]
public void set_AuthType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAuthenticated();
    [CompilerGeneratedAttribute]
public void set_IsAuthenticated(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("install-context")]
internal class NLog.LayoutRenderers.InstallContextLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Parameter>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
internal abstract class NLog.LayoutRenderers.LayoutRenderer : object {
    private static int MaxInitialRenderBufferLength;
    private int maxRenderedLength;
    private bool isInitialized;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    protected LoggingConfiguration LoggingConfiguration { get; private set; }
    [CompilerGeneratedAttribute]
protected LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    public virtual string ToString();
    public sealed virtual void Dispose();
    public sealed virtual string Render(LogEventInfo logEvent);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    internal void Initialize(LoggingConfiguration configuration);
    internal void Close();
    internal void Render(StringBuilder builder, LogEventInfo logEvent);
    protected abstract virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Dispose(bool disposing);
}
[AttributeUsageAttribute("4")]
internal class NLog.LayoutRenderers.LayoutRendererAttribute : NameBaseAttribute {
    public LayoutRendererAttribute(string name);
}
[LayoutRendererAttribute("level")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.LevelLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[AppDomainFixedOutputAttribute]
[LayoutRendererAttribute("literal")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.LiteralLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public LiteralLayoutRenderer(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("log4jxmlevent")]
internal class NLog.LayoutRenderers.Log4JXmlEventLayoutRenderer : LayoutRenderer {
    private static DateTime log4jDateBase;
    private static string dummyNamespace;
    private static string dummyNLogNamespace;
    [CompilerGeneratedAttribute]
private bool <IncludeNLogData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentXml>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeCallSite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSourceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeMdc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNdc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NdcItemSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NLogViewerParameterInfo> <Parameters>k__BackingField;
    [DefaultValueAttribute("True")]
public bool IncludeNLogData { get; public set; }
    public bool IndentXml { get; public set; }
    public string AppInfo { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeSourceInfo { get; public set; }
    public bool IncludeMdc { get; public set; }
    public bool IncludeNdc { get; public set; }
    [DefaultValueAttribute(" ")]
public string NdcItemSeparator { get; public set; }
    private StackTraceUsage NLog.Internal.IUsesStackTrace.StackTraceUsage { get; }
    internal IList`1<NLogViewerParameterInfo> Parameters { get; internal set; }
    private static Log4JXmlEventLayoutRenderer();
    [CompilerGeneratedAttribute]
public bool get_IncludeNLogData();
    [CompilerGeneratedAttribute]
public void set_IncludeNLogData(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentXml();
    [CompilerGeneratedAttribute]
public void set_IndentXml(bool value);
    [CompilerGeneratedAttribute]
public string get_AppInfo();
    [CompilerGeneratedAttribute]
public void set_AppInfo(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeCallSite();
    [CompilerGeneratedAttribute]
public void set_IncludeCallSite(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSourceInfo();
    [CompilerGeneratedAttribute]
public void set_IncludeSourceInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeMdc();
    [CompilerGeneratedAttribute]
public void set_IncludeMdc(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNdc();
    [CompilerGeneratedAttribute]
public void set_IncludeNdc(bool value);
    [CompilerGeneratedAttribute]
public string get_NdcItemSeparator();
    [CompilerGeneratedAttribute]
public void set_NdcItemSeparator(string value);
    private sealed virtual override StackTraceUsage NLog.Internal.IUsesStackTrace.get_StackTraceUsage();
    [CompilerGeneratedAttribute]
internal IList`1<NLogViewerParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IList`1<NLogViewerParameterInfo> value);
    internal void AppendToStringBuilder(StringBuilder sb, LogEventInfo logEvent);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("logger")]
internal class NLog.LayoutRenderers.LoggerNameLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <ShortName>k__BackingField;
    [DefaultValueAttribute("False")]
public bool ShortName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("longdate")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.LongDateLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <UniversalTime>k__BackingField;
    [DefaultValueAttribute("False")]
public bool UniversalTime { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UniversalTime();
    [CompilerGeneratedAttribute]
public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void Append2DigitsZeroPadded(StringBuilder builder, int number);
    private static void Append4DigitsZeroPadded(StringBuilder builder, int number);
}
[LayoutRendererAttribute("machinename")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.MachineNameLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    internal string MachineName { get; private set; }
    [CompilerGeneratedAttribute]
internal string get_MachineName();
    [CompilerGeneratedAttribute]
private void set_MachineName(string value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("mdc")]
internal class NLog.LayoutRenderers.MdcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [DefaultParameterAttribute]
[RequiredParameterAttribute]
public string Item { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("message")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.MessageLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <WithException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionSeparator>k__BackingField;
    public bool WithException { get; public set; }
    public string ExceptionSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WithException();
    [CompilerGeneratedAttribute]
public void set_WithException(bool value);
    [CompilerGeneratedAttribute]
public string get_ExceptionSeparator();
    [CompilerGeneratedAttribute]
public void set_ExceptionSeparator(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("ndc")]
internal class NLog.LayoutRenderers.NdcLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public int TopFrames { get; public set; }
    public int BottomFrames { get; public set; }
    public string Separator { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public int get_BottomFrames();
    [CompilerGeneratedAttribute]
public void set_BottomFrames(int value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("newline")]
internal class NLog.LayoutRenderers.NewLineLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("nlogdir")]
internal class NLog.LayoutRenderers.NLogDirLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NLogDir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    private static string NLogDir { get; private set; }
    private static NLogDirLayoutRenderer();
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    [CompilerGeneratedAttribute]
private static string get_NLogDir();
    [CompilerGeneratedAttribute]
private static void set_NLogDir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("performancecounter")]
internal class NLog.LayoutRenderers.PerformanceCounterLayoutRenderer : LayoutRenderer {
    private PerformanceCounter perfCounter;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [RequiredParameterAttribute]
public string Category { get; public set; }
    [RequiredParameterAttribute]
public string Counter { get; public set; }
    public string Instance { get; public set; }
    public string MachineName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Counter();
    [CompilerGeneratedAttribute]
public void set_Counter(string value);
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("processid")]
internal class NLog.LayoutRenderers.ProcessIdLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("processinfo")]
internal class NLog.LayoutRenderers.ProcessInfoLayoutRenderer : LayoutRenderer {
    private Process process;
    private PropertyInfo propertyInfo;
    [CompilerGeneratedAttribute]
private ProcessInfoProperty <Property>k__BackingField;
    [DefaultValueAttribute("Id")]
[DefaultParameterAttribute]
public ProcessInfoProperty Property { get; public set; }
    [CompilerGeneratedAttribute]
public ProcessInfoProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(ProcessInfoProperty value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
internal enum NLog.LayoutRenderers.ProcessInfoProperty : Enum {
    public int value__;
    public static ProcessInfoProperty BasePriority;
    public static ProcessInfoProperty ExitCode;
    public static ProcessInfoProperty ExitTime;
    public static ProcessInfoProperty Handle;
    public static ProcessInfoProperty HandleCount;
    public static ProcessInfoProperty HasExited;
    public static ProcessInfoProperty Id;
    public static ProcessInfoProperty MachineName;
    public static ProcessInfoProperty MainWindowHandle;
    public static ProcessInfoProperty MainWindowTitle;
    public static ProcessInfoProperty MaxWorkingSet;
    public static ProcessInfoProperty MinWorkingSet;
    public static ProcessInfoProperty NonPagedSystemMemorySize;
    public static ProcessInfoProperty NonPagedSystemMemorySize64;
    public static ProcessInfoProperty PagedMemorySize;
    public static ProcessInfoProperty PagedMemorySize64;
    public static ProcessInfoProperty PagedSystemMemorySize;
    public static ProcessInfoProperty PagedSystemMemorySize64;
    public static ProcessInfoProperty PeakPagedMemorySize;
    public static ProcessInfoProperty PeakPagedMemorySize64;
    public static ProcessInfoProperty PeakVirtualMemorySize;
    public static ProcessInfoProperty PeakVirtualMemorySize64;
    public static ProcessInfoProperty PeakWorkingSet;
    public static ProcessInfoProperty PeakWorkingSet64;
    public static ProcessInfoProperty PriorityBoostEnabled;
    public static ProcessInfoProperty PriorityClass;
    public static ProcessInfoProperty PrivateMemorySize;
    public static ProcessInfoProperty PrivateMemorySize64;
    public static ProcessInfoProperty PrivilegedProcessorTime;
    public static ProcessInfoProperty ProcessName;
    public static ProcessInfoProperty Responding;
    public static ProcessInfoProperty SessionId;
    public static ProcessInfoProperty StartTime;
    public static ProcessInfoProperty TotalProcessorTime;
    public static ProcessInfoProperty UserProcessorTime;
    public static ProcessInfoProperty VirtualMemorySize;
    public static ProcessInfoProperty VirtualMemorySize64;
    public static ProcessInfoProperty WorkingSet;
    public static ProcessInfoProperty WorkingSet64;
}
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("processname")]
internal class NLog.LayoutRenderers.ProcessNameLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <FullName>k__BackingField;
    [DefaultValueAttribute("False")]
public bool FullName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("processtime")]
internal class NLog.LayoutRenderers.ProcessTimeLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("qpc")]
internal class NLog.LayoutRenderers.QueryPerformanceCounterLayoutRenderer : LayoutRenderer {
    private bool raw;
    private ulong firstQpcValue;
    private ulong lastQpcValue;
    private double frequency;
    [CompilerGeneratedAttribute]
private bool <Normalize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Difference>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignDecimalPoint>k__BackingField;
    [DefaultValueAttribute("True")]
public bool Normalize { get; public set; }
    [DefaultValueAttribute("False")]
public bool Difference { get; public set; }
    [DefaultValueAttribute("True")]
public bool Seconds { get; public set; }
    [DefaultValueAttribute("4")]
public int Precision { get; public set; }
    [DefaultValueAttribute("True")]
public bool AlignDecimalPoint { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Normalize();
    [CompilerGeneratedAttribute]
public void set_Normalize(bool value);
    [CompilerGeneratedAttribute]
public bool get_Difference();
    [CompilerGeneratedAttribute]
public void set_Difference(bool value);
    public bool get_Seconds();
    public void set_Seconds(bool value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(int value);
    [CompilerGeneratedAttribute]
public bool get_AlignDecimalPoint();
    [CompilerGeneratedAttribute]
public void set_AlignDecimalPoint(bool value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("registry")]
internal class NLog.LayoutRenderers.RegistryLayoutRenderer : LayoutRenderer {
    private string key;
    private RegistryKey rootKey;
    private string subKey;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public string Value { get; public set; }
    public string DefaultValue { get; public set; }
    [RequiredParameterAttribute]
public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(string value);
    public string get_Key();
    public void set_Key(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("shortdate")]
internal class NLog.LayoutRenderers.ShortDateLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <UniversalTime>k__BackingField;
    [DefaultValueAttribute("False")]
public bool UniversalTime { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UniversalTime();
    [CompilerGeneratedAttribute]
public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("specialfolder")]
[AppDomainFixedOutputAttribute]
internal class NLog.LayoutRenderers.SpecialFolderLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private SpecialFolder <Folder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    [DefaultParameterAttribute]
public SpecialFolder Folder { get; public set; }
    public string File { get; public set; }
    public string Dir { get; public set; }
    [CompilerGeneratedAttribute]
public SpecialFolder get_Folder();
    [CompilerGeneratedAttribute]
public void set_Folder(SpecialFolder value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
internal enum NLog.LayoutRenderers.StackTraceFormat : Enum {
    public int value__;
    public static StackTraceFormat Raw;
    public static StackTraceFormat Flat;
    public static StackTraceFormat DetailedFlat;
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("stacktrace")]
internal class NLog.LayoutRenderers.StackTraceLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private StackTraceFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TopFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [DefaultValueAttribute("Flat")]
public StackTraceFormat Format { get; public set; }
    [DefaultValueAttribute("3")]
public int TopFrames { get; public set; }
    [DefaultValueAttribute(" => ")]
public string Separator { get; public set; }
    private StackTraceUsage NLog.Internal.IUsesStackTrace.StackTraceUsage { get; }
    [CompilerGeneratedAttribute]
public StackTraceFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(StackTraceFormat value);
    [CompilerGeneratedAttribute]
public int get_TopFrames();
    [CompilerGeneratedAttribute]
public void set_TopFrames(int value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    private sealed virtual override StackTraceUsage NLog.Internal.IUsesStackTrace.get_StackTraceUsage();
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("tempdir")]
[AppDomainFixedOutputAttribute]
internal class NLog.LayoutRenderers.TempDirLayoutRenderer : LayoutRenderer {
    private static string tempDir;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dir>k__BackingField;
    public string File { get; public set; }
    public string Dir { get; public set; }
    private static TempDirLayoutRenderer();
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Dir();
    [CompilerGeneratedAttribute]
public void set_Dir(string value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("threadid")]
internal class NLog.LayoutRenderers.ThreadIdLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("threadname")]
internal class NLog.LayoutRenderers.ThreadNameLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[LayoutRendererAttribute("ticks")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.TicksLayoutRenderer : LayoutRenderer {
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("time")]
internal class NLog.LayoutRenderers.TimeLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <UniversalTime>k__BackingField;
    [DefaultValueAttribute("False")]
public bool UniversalTime { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UniversalTime();
    [CompilerGeneratedAttribute]
public void set_UniversalTime(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    private static void Append2DigitsZeroPadded(StringBuilder builder, int number);
    private static void Append4DigitsZeroPadded(StringBuilder builder, int number);
}
[LayoutRendererAttribute("windows-identity")]
internal class NLog.LayoutRenderers.WindowsIdentityLayoutRenderer : LayoutRenderer {
    [CompilerGeneratedAttribute]
private bool <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserName>k__BackingField;
    [DefaultValueAttribute("True")]
public bool Domain { get; public set; }
    [DefaultValueAttribute("True")]
public bool UserName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(bool value);
    [CompilerGeneratedAttribute]
public bool get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(bool value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
}
[AmbientPropertyAttribute("Cached")]
[LayoutRendererAttribute("cached")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.Wrappers.CachedLayoutRendererWrapper : WrapperLayoutRendererBase {
    private string cachedValue;
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [DefaultValueAttribute("True")]
public bool Cached { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public void set_Cached(bool value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual void CloseLayoutRenderer();
    protected virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
[AmbientPropertyAttribute("FSNormalize")]
[LayoutRendererAttribute("filesystem-normalize")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.Wrappers.FileSystemNormalizeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <FSNormalize>k__BackingField;
    [DefaultValueAttribute("True")]
public bool FSNormalize { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FSNormalize();
    [CompilerGeneratedAttribute]
public void set_FSNormalize(bool value);
    protected virtual string Transform(string text);
    private static bool IsSafeCharacter(char c);
}
[LayoutRendererAttribute("json-encode")]
[ThreadAgnosticAttribute]
[AmbientPropertyAttribute("JsonEncode")]
internal class NLog.LayoutRenderers.Wrappers.JsonEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <JsonEncode>k__BackingField;
    [DefaultValueAttribute("True")]
public bool JsonEncode { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_JsonEncode();
    [CompilerGeneratedAttribute]
public void set_JsonEncode(bool value);
    protected virtual string Transform(string text);
    private static string DoJsonEscape(string text);
    private static bool NeedsEscaping(char ch);
}
[LayoutRendererAttribute("lowercase")]
[AmbientPropertyAttribute("Lowercase")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.Wrappers.LowercaseLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <Lowercase>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [DefaultValueAttribute("True")]
public bool Lowercase { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Lowercase();
    [CompilerGeneratedAttribute]
public void set_Lowercase(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual string Transform(string text);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("onexception")]
internal class NLog.LayoutRenderers.Wrappers.OnExceptionLayoutRendererWrapper : WrapperLayoutRendererBase {
    protected virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
[AmbientPropertyAttribute("PadCharacter")]
[AmbientPropertyAttribute("Padding")]
[LayoutRendererAttribute("pad")]
[AmbientPropertyAttribute("FixedLength")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.Wrappers.PaddingLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private char <PadCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixedLength>k__BackingField;
    public int Padding { get; public set; }
    [DefaultValueAttribute(" ")]
public char PadCharacter { get; public set; }
    [DefaultValueAttribute("False")]
public bool FixedLength { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(int value);
    [CompilerGeneratedAttribute]
public char get_PadCharacter();
    [CompilerGeneratedAttribute]
public void set_PadCharacter(char value);
    [CompilerGeneratedAttribute]
public bool get_FixedLength();
    [CompilerGeneratedAttribute]
public void set_FixedLength(bool value);
    protected virtual string Transform(string text);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("replace")]
internal class NLog.LayoutRenderers.Wrappers.ReplaceLayoutRendererWrapper : WrapperLayoutRendererBase {
    private Regex regex;
    [CompilerGeneratedAttribute]
private string <SearchFor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceWith>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WholeWords>k__BackingField;
    public string SearchFor { get; public set; }
    public bool Regex { get; public set; }
    public string ReplaceWith { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool WholeWords { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SearchFor();
    [CompilerGeneratedAttribute]
public void set_SearchFor(string value);
    [CompilerGeneratedAttribute]
public bool get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(bool value);
    [CompilerGeneratedAttribute]
public string get_ReplaceWith();
    [CompilerGeneratedAttribute]
public void set_ReplaceWith(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_WholeWords();
    [CompilerGeneratedAttribute]
public void set_WholeWords(bool value);
    protected virtual void InitializeLayoutRenderer();
    protected virtual string Transform(string text);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("rot13")]
[AppDomainFixedOutputAttribute]
internal class NLog.LayoutRenderers.Wrappers.Rot13LayoutRendererWrapper : WrapperLayoutRendererBase {
    public Layout Text { get; public set; }
    public Layout get_Text();
    public void set_Text(Layout value);
    public static string DecodeRot13(string encodedValue);
    protected virtual string Transform(string text);
    private static char DecodeRot13Char(char c);
}
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("trim-whitespace")]
[AmbientPropertyAttribute("TrimWhiteSpace")]
internal class NLog.LayoutRenderers.Wrappers.TrimWhiteSpaceLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <TrimWhiteSpace>k__BackingField;
    [DefaultValueAttribute("True")]
public bool TrimWhiteSpace { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TrimWhiteSpace();
    [CompilerGeneratedAttribute]
public void set_TrimWhiteSpace(bool value);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("uppercase")]
[ThreadAgnosticAttribute]
[AmbientPropertyAttribute("Uppercase")]
internal class NLog.LayoutRenderers.Wrappers.UppercaseLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <Uppercase>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [DefaultValueAttribute("True")]
public bool Uppercase { get; public set; }
    public CultureInfo Culture { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Uppercase();
    [CompilerGeneratedAttribute]
public void set_Uppercase(bool value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("url-encode")]
[ThreadAgnosticAttribute]
internal class NLog.LayoutRenderers.Wrappers.UrlEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <SpaceAsPlus>k__BackingField;
    public bool SpaceAsPlus { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SpaceAsPlus();
    [CompilerGeneratedAttribute]
public void set_SpaceAsPlus(bool value);
    protected virtual string Transform(string text);
}
[LayoutRendererAttribute("whenEmpty")]
[ThreadAgnosticAttribute]
[AmbientPropertyAttribute("WhenEmpty")]
internal class NLog.LayoutRenderers.Wrappers.WhenEmptyLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private Layout <WhenEmpty>k__BackingField;
    [RequiredParameterAttribute]
public Layout WhenEmpty { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_WhenEmpty();
    [CompilerGeneratedAttribute]
public void set_WhenEmpty(Layout value);
    protected virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
[AmbientPropertyAttribute("When")]
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("when")]
internal class NLog.LayoutRenderers.Wrappers.WhenLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private ConditionExpression <When>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression When { get; public set; }
    [CompilerGeneratedAttribute]
public ConditionExpression get_When();
    [CompilerGeneratedAttribute]
public void set_When(ConditionExpression value);
    protected virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
internal abstract class NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase : LayoutRenderer {
    [CompilerGeneratedAttribute]
private Layout <Inner>k__BackingField;
    [DefaultParameterAttribute]
public Layout Inner { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Inner();
    [CompilerGeneratedAttribute]
public void set_Inner(Layout value);
    protected virtual void Append(StringBuilder builder, LogEventInfo logEvent);
    protected abstract virtual string Transform(string text);
    protected virtual string RenderInner(LogEventInfo logEvent);
}
[AmbientPropertyAttribute("XmlEncode")]
[ThreadAgnosticAttribute]
[LayoutRendererAttribute("xml-encode")]
internal class NLog.LayoutRenderers.Wrappers.XmlEncodeLayoutRendererWrapper : WrapperLayoutRendererBase {
    [CompilerGeneratedAttribute]
private bool <XmlEncode>k__BackingField;
    [DefaultValueAttribute("True")]
public bool XmlEncode { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_XmlEncode();
    [CompilerGeneratedAttribute]
public void set_XmlEncode(bool value);
    protected virtual string Transform(string text);
    private static string DoXmlEscape(string text);
}
[ThreadAgnosticAttribute]
[NLogConfigurationItemAttribute]
internal class NLog.Layouts.CsvColumn : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public CsvColumn(string name, Layout layout);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
}
internal enum NLog.Layouts.CsvColumnDelimiterMode : Enum {
    public int value__;
    public static CsvColumnDelimiterMode Auto;
    public static CsvColumnDelimiterMode Comma;
    public static CsvColumnDelimiterMode Semicolon;
    public static CsvColumnDelimiterMode Tab;
    public static CsvColumnDelimiterMode Pipe;
    public static CsvColumnDelimiterMode Space;
    public static CsvColumnDelimiterMode Custom;
}
[LayoutAttribute("CsvLayout")]
[ThreadAgnosticAttribute]
[AppDomainFixedOutputAttribute]
internal class NLog.Layouts.CsvLayout : LayoutWithHeaderAndFooter {
    private string actualColumnDelimiter;
    private string doubleQuoteChar;
    private Char[] quotableCharacters;
    [CompilerGeneratedAttribute]
private IList`1<CsvColumn> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private CsvColumnDelimiterMode <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private CsvQuotingMode <Quoting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QuoteChar>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomColumnDelimiter>k__BackingField;
    [ArrayParameterAttribute("NLog.Layouts.CsvColumn", "column")]
public IList`1<CsvColumn> Columns { get; private set; }
    public bool WithHeader { get; public set; }
    [DefaultValueAttribute("Auto")]
public CsvColumnDelimiterMode Delimiter { get; public set; }
    [DefaultValueAttribute("Auto")]
public CsvQuotingMode Quoting { get; public set; }
    [DefaultValueAttribute(""")]
public string QuoteChar { get; public set; }
    public string CustomColumnDelimiter { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<CsvColumn> get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(IList`1<CsvColumn> value);
    [CompilerGeneratedAttribute]
public bool get_WithHeader();
    [CompilerGeneratedAttribute]
public void set_WithHeader(bool value);
    [CompilerGeneratedAttribute]
public CsvColumnDelimiterMode get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(CsvColumnDelimiterMode value);
    [CompilerGeneratedAttribute]
public CsvQuotingMode get_Quoting();
    [CompilerGeneratedAttribute]
public void set_Quoting(CsvQuotingMode value);
    [CompilerGeneratedAttribute]
public string get_QuoteChar();
    [CompilerGeneratedAttribute]
public void set_QuoteChar(string value);
    [CompilerGeneratedAttribute]
public string get_CustomColumnDelimiter();
    [CompilerGeneratedAttribute]
public void set_CustomColumnDelimiter(string value);
    protected virtual void InitializeLayout();
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    private string GetHeader();
}
internal enum NLog.Layouts.CsvQuotingMode : Enum {
    public int value__;
    public static CsvQuotingMode All;
    public static CsvQuotingMode Nothing;
    public static CsvQuotingMode Auto;
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
[NLogConfigurationItemAttribute]
internal abstract class NLog.Layouts.Layout : object {
    private bool isInitialized;
    private bool threadAgnostic;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    internal bool IsThreadAgnostic { get; }
    protected LoggingConfiguration LoggingConfiguration { get; private set; }
    internal bool get_IsThreadAgnostic();
    [CompilerGeneratedAttribute]
protected LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    public static Layout op_Implicit(string text);
    public static Layout FromString(string layoutText);
    public static Layout FromString(string layoutText, ConfigurationItemFactory configurationItemFactory);
    public virtual void Precalculate(LogEventInfo logEvent);
    public sealed virtual string Render(LogEventInfo logEvent);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    internal void Initialize(LoggingConfiguration configuration);
    internal void Close();
    protected virtual void InitializeLayout();
    protected virtual void CloseLayout();
    protected abstract virtual string GetFormattedMessage(LogEventInfo logEvent);
}
[AttributeUsageAttribute("4")]
internal class NLog.Layouts.LayoutAttribute : NameBaseAttribute {
    public LayoutAttribute(string name);
}
internal class NLog.Layouts.LayoutParser : object {
    internal static LayoutRenderer[] CompileLayout(ConfigurationItemFactory configurationItemFactory, SimpleStringReader sr, bool isNested, String& text);
    private static string ParseLayoutRendererName(SimpleStringReader sr);
    private static string ParseParameterName(SimpleStringReader sr);
    private static string ParseParameterValue(SimpleStringReader sr);
    private static LayoutRenderer ParseLayoutRenderer(ConfigurationItemFactory configurationItemFactory, SimpleStringReader sr);
    private static LayoutRenderer ApplyWrappers(ConfigurationItemFactory configurationItemFactory, LayoutRenderer lr, List`1<LayoutRenderer> orderedWrappers);
    private static bool CanBeConvertedToLiteral(LayoutRenderer lr);
    private static void MergeLiterals(List`1<LayoutRenderer> list);
    private static LayoutRenderer ConvertToLiteral(LayoutRenderer renderer);
}
[ThreadAgnosticAttribute]
[LayoutAttribute("LayoutWithHeaderAndFooter")]
internal class NLog.Layouts.LayoutWithHeaderAndFooter : Layout {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Footer>k__BackingField;
    public Layout Layout { get; public set; }
    public Layout Header { get; public set; }
    public Layout Footer { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(Layout value);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
}
[LayoutAttribute("Log4JXmlEventLayout")]
internal class NLog.Layouts.Log4JXmlEventLayout : Layout {
    [CompilerGeneratedAttribute]
private Log4JXmlEventLayoutRenderer <Renderer>k__BackingField;
    public Log4JXmlEventLayoutRenderer Renderer { get; private set; }
    [CompilerGeneratedAttribute]
public Log4JXmlEventLayoutRenderer get_Renderer();
    [CompilerGeneratedAttribute]
private void set_Renderer(Log4JXmlEventLayoutRenderer value);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
}
[LayoutAttribute("SimpleLayout")]
[AppDomainFixedOutputAttribute]
[ThreadAgnosticAttribute]
internal class NLog.Layouts.SimpleLayout : Layout {
    private static int MaxInitialRenderBufferLength;
    private int maxRenderedLength;
    private string fixedText;
    private string layoutText;
    private ConfigurationItemFactory configurationItemFactory;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<LayoutRenderer> <Renderers>k__BackingField;
    public string Text { get; public set; }
    public ReadOnlyCollection`1<LayoutRenderer> Renderers { get; private set; }
    public SimpleLayout(string txt);
    public SimpleLayout(string txt, ConfigurationItemFactory configurationItemFactory);
    internal SimpleLayout(LayoutRenderer[] renderers, string text, ConfigurationItemFactory configurationItemFactory);
    public string get_Text();
    public void set_Text(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<LayoutRenderer> get_Renderers();
    [CompilerGeneratedAttribute]
private void set_Renderers(ReadOnlyCollection`1<LayoutRenderer> value);
    public static SimpleLayout op_Implicit(string text);
    public static string Escape(string text);
    public static string Evaluate(string text, LogEventInfo logEvent);
    public static string Evaluate(string text);
    public virtual string ToString();
    internal void SetRenderers(LayoutRenderer[] renderers, string text);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
}
internal class NLog.LogEventInfo : object {
    public static DateTime ZeroDate;
    private static int globalSequenceId;
    private string formattedMessage;
    private IDictionary`2<Layout, string> layoutCache;
    private IDictionary`2<object, object> properties;
    private IDictionary eventContextAdapter;
    [CompilerGeneratedAttribute]
private int <SequenceID>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserStackFrameNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private StackTrace <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
public int SequenceID { get; private set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
public DateTime TimeStamp { get; public set; }
    public LogLevel Level { get; public set; }
    public bool HasStackTrace { get; }
    public StackFrame UserStackFrame { get; }
    public int UserStackFrameNumber { get; private set; }
    public StackTrace StackTrace { get; private set; }
    public Exception Exception { get; public set; }
    public string LoggerName { get; public set; }
    [ObsoleteAttribute("This property should not be used.")]
public string LoggerShortName { get; }
    public string Message { get; public set; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays")]
public Object[] Parameters { get; public set; }
    public IFormatProvider FormatProvider { get; public set; }
    public string FormattedMessage { get; }
    public IDictionary`2<object, object> Properties { get; }
    [ObsoleteAttribute("Use LogEventInfo.Properties instead.", "True")]
public IDictionary Context { get; }
    public LogEventInfo(LogLevel level, string loggerName, string message);
    public LogEventInfo(LogLevel level, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters);
    public LogEventInfo(LogLevel level, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters, Exception exception);
    private static LogEventInfo();
    [CompilerGeneratedAttribute]
public int get_SequenceID();
    [CompilerGeneratedAttribute]
private void set_SequenceID(int value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(LogLevel value);
    public bool get_HasStackTrace();
    public StackFrame get_UserStackFrame();
    [CompilerGeneratedAttribute]
public int get_UserStackFrameNumber();
    [CompilerGeneratedAttribute]
private void set_UserStackFrameNumber(int value);
    [CompilerGeneratedAttribute]
public StackTrace get_StackTrace();
    [CompilerGeneratedAttribute]
private void set_StackTrace(StackTrace value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    public string get_LoggerShortName();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Object[] value);
    [CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
public void set_FormatProvider(IFormatProvider value);
    public string get_FormattedMessage();
    public IDictionary`2<object, object> get_Properties();
    public IDictionary get_Context();
    public static LogEventInfo CreateNullEvent();
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, string message);
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, IFormatProvider formatProvider, string message, Object[] parameters);
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, IFormatProvider formatProvider, object message);
    public static LogEventInfo Create(LogLevel logLevel, string loggerName, string message, Exception exception);
    public AsyncLogEventInfo WithContinuation(AsyncContinuation asyncContinuation);
    public virtual string ToString();
    public void SetStackTrace(StackTrace stackTrace, int userStackFrame);
    internal string AddCachedLayoutValue(Layout layout, string value);
    internal bool TryGetCachedLayoutValue(Layout layout, String& value);
    private static bool NeedToPreformatMessage(Object[] parameters);
    private static bool IsSafeToDeferFormatting(object value);
    private void CalcFormattedMessage();
    private void InitEventContext();
}
internal class NLog.LogFactory : object {
    private static int ReconfigAfterFileChangedTimeout;
    private MultiFileWatcher watcher;
    private Dictionary`2<LoggerCacheKey, WeakReference> loggerCache;
    private static TimeSpan defaultFlushTimeout;
    private Timer reloadTimer;
    private LoggingConfiguration config;
    private LogLevel globalThreshold;
    private bool configLoaded;
    private int logsEnabled;
    private EventHandler`1<LoggingConfigurationChangedEventArgs> ConfigurationChanged;
    private EventHandler`1<LoggingConfigurationReloadedEventArgs> ConfigurationReloaded;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptions>k__BackingField;
    public bool ThrowExceptions { get; public set; }
    public LoggingConfiguration Configuration { get; public set; }
    public LogLevel GlobalThreshold { get; public set; }
    public LogFactory(LoggingConfiguration config);
    private static LogFactory();
    public void add_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public void remove_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public void add_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    public void remove_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptions(bool value);
    public LoggingConfiguration get_Configuration();
    public void set_Configuration(LoggingConfiguration value);
    public LogLevel get_GlobalThreshold();
    public void set_GlobalThreshold(LogLevel value);
    public sealed virtual void Dispose();
    public Logger CreateNullLogger();
    public Logger GetCurrentClassLogger();
    public Logger GetCurrentClassLogger(Type loggerType);
    public Logger GetLogger(string name);
    public Logger GetLogger(string name, Type loggerType);
    public void ReconfigExistingLoggers();
    public void Flush();
    public void Flush(TimeSpan timeout);
    public void Flush(int timeoutMilliseconds);
    public void Flush(AsyncContinuation asyncContinuation);
    public void Flush(AsyncContinuation asyncContinuation, int timeoutMilliseconds);
    public void Flush(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public IDisposable DisableLogging();
    public void EnableLogging();
    public bool IsLoggingEnabled();
    internal void ReloadConfigOnTimer(object state);
    internal void ReconfigExistingLoggers(LoggingConfiguration configuration);
    internal void GetTargetsByLevelForLogger(string name, IList`1<LoggingRule> rules, TargetWithFilterChain[] targetsByLevel, TargetWithFilterChain[] lastTargetsByLevel);
    internal LoggerConfiguration GetConfigurationForLogger(string name, LoggingConfiguration configuration);
    protected virtual void Dispose(bool disposing);
    private static IEnumerable`1<string> GetCandidateFileNames();
    private static void Dump(LoggingConfiguration config);
    private Logger GetLogger(LoggerCacheKey cacheKey);
    private void ConfigFileChanged(object sender, EventArgs args);
}
internal class NLog.LogFactory`1 : LogFactory {
    public T GetLogger(string name);
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public T GetCurrentClassLogger();
}
[CLSCompliantAttribute("True")]
internal class NLog.Logger : object {
    private Type loggerType;
    private LoggerConfiguration modreq(System.Runtime.CompilerServices.IsVolatile) configuration;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isTraceEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isDebugEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isInfoEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isWarnEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isErrorEnabled;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isFatalEnabled;
    private EventHandler`1<EventArgs> LoggerReconfigured;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LogFactory <Factory>k__BackingField;
    public string Name { get; private set; }
    public LogFactory Factory { get; private set; }
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public void add_LoggerReconfigured(EventHandler`1<EventArgs> value);
    public void remove_LoggerReconfigured(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public LogFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(LogFactory value);
    public bool get_IsTraceEnabled();
    public bool get_IsDebugEnabled();
    public bool get_IsInfoEnabled();
    public bool get_IsWarnEnabled();
    public bool get_IsErrorEnabled();
    public bool get_IsFatalEnabled();
    public bool IsEnabled(LogLevel level);
    public void Log(LogEventInfo logEvent);
    public void Log(Type wrapperType, LogEventInfo logEvent);
    public void Log(LogLevel level, T value);
    public void Log(LogLevel level, IFormatProvider formatProvider, T value);
    public void Log(LogLevel level, LogMessageGenerator messageFunc);
    public void LogException(LogLevel level, string message, Exception exception);
    public void Log(LogLevel level, IFormatProvider formatProvider, string message, Object[] args);
    public void Log(LogLevel level, string message);
    public void Log(LogLevel level, string message, Object[] args);
    public void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument argument);
    public void Log(LogLevel level, string message, TArgument argument);
    public void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2);
    public void Log(LogLevel level, IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Log(LogLevel level, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Trace(T value);
    public void Trace(IFormatProvider formatProvider, T value);
    public void Trace(LogMessageGenerator messageFunc);
    public void TraceException(string message, Exception exception);
    public void Trace(IFormatProvider formatProvider, string message, Object[] args);
    public void Trace(string message);
    public void Trace(string message, Object[] args);
    public void Trace(IFormatProvider formatProvider, string message, TArgument argument);
    public void Trace(string message, TArgument argument);
    public void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Trace(string message, TArgument1 argument1, TArgument2 argument2);
    public void Trace(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Trace(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Debug(T value);
    public void Debug(IFormatProvider formatProvider, T value);
    public void Debug(LogMessageGenerator messageFunc);
    public void DebugException(string message, Exception exception);
    public void Debug(IFormatProvider formatProvider, string message, Object[] args);
    public void Debug(string message);
    public void Debug(string message, Object[] args);
    public void Debug(IFormatProvider formatProvider, string message, TArgument argument);
    public void Debug(string message, TArgument argument);
    public void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Debug(string message, TArgument1 argument1, TArgument2 argument2);
    public void Debug(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Debug(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Info(T value);
    public void Info(IFormatProvider formatProvider, T value);
    public void Info(LogMessageGenerator messageFunc);
    public void InfoException(string message, Exception exception);
    public void Info(IFormatProvider formatProvider, string message, Object[] args);
    public void Info(string message);
    public void Info(string message, Object[] args);
    public void Info(IFormatProvider formatProvider, string message, TArgument argument);
    public void Info(string message, TArgument argument);
    public void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Info(string message, TArgument1 argument1, TArgument2 argument2);
    public void Info(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Info(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Warn(T value);
    public void Warn(IFormatProvider formatProvider, T value);
    public void Warn(LogMessageGenerator messageFunc);
    public void WarnException(string message, Exception exception);
    public void Warn(IFormatProvider formatProvider, string message, Object[] args);
    public void Warn(string message);
    public void Warn(string message, Object[] args);
    public void Warn(IFormatProvider formatProvider, string message, TArgument argument);
    public void Warn(string message, TArgument argument);
    public void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Warn(string message, TArgument1 argument1, TArgument2 argument2);
    public void Warn(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Warn(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Error(T value);
    public void Error(IFormatProvider formatProvider, T value);
    public void Error(LogMessageGenerator messageFunc);
    public void ErrorException(string message, Exception exception);
    public void Error(IFormatProvider formatProvider, string message, Object[] args);
    public void Error(string message);
    public void Error(string message, Object[] args);
    public void Error(IFormatProvider formatProvider, string message, TArgument argument);
    public void Error(string message, TArgument argument);
    public void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Error(string message, TArgument1 argument1, TArgument2 argument2);
    public void Error(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Error(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Fatal(T value);
    public void Fatal(IFormatProvider formatProvider, T value);
    public void Fatal(LogMessageGenerator messageFunc);
    public void FatalException(string message, Exception exception);
    public void Fatal(IFormatProvider formatProvider, string message, Object[] args);
    public void Fatal(string message);
    public void Fatal(string message, Object[] args);
    public void Fatal(IFormatProvider formatProvider, string message, TArgument argument);
    public void Fatal(string message, TArgument argument);
    public void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2);
    public void Fatal(string message, TArgument1 argument1, TArgument2 argument2);
    public void Fatal(IFormatProvider formatProvider, string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    public void Fatal(string message, TArgument1 argument1, TArgument2 argument2, TArgument3 argument3);
    internal void Initialize(string name, LoggerConfiguration loggerConfiguration, LogFactory factory);
    internal void WriteToTargets(LogLevel level, IFormatProvider formatProvider, string message, Object[] args);
    internal void WriteToTargets(LogLevel level, IFormatProvider formatProvider, T value);
    internal void WriteToTargets(LogLevel level, string message, Exception ex);
    internal void WriteToTargets(LogLevel level, string message, Object[] args);
    internal void WriteToTargets(LogEventInfo logEvent);
    internal void WriteToTargets(Type wrapperType, LogEventInfo logEvent);
    internal void SetConfiguration(LoggerConfiguration newConfiguration);
    private TargetWithFilterChain GetTargetsForLevel(LogLevel level);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, object value);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, object argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Log(LogLevel level, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Log(LogLevel level, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Log(LogLevel level, IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Log(LogLevel level, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Trace(object value);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Trace(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Trace(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Trace(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Trace(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Trace(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Trace(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Trace(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Debug(object value);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Debug(string message, object argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Debug(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Debug(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Debug(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Debug(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Debug(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Debug(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Info(object value);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Info(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Info(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Info(string message, object argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Info(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Info(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Info(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Info(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Info(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Warn(object value);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Warn(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Warn(string message, object argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Warn(IFormatProvider formatProvider, string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Warn(string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Warn(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Warn(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Warn(IFormatProvider formatProvider, string message, ulong argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Warn(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Error(object value);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Error(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Error(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Error(string message, object argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Error(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Error(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Error(IFormatProvider formatProvider, string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Error(string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Error(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Error(string message, ulong argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(object value);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, object value);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, object arg1, object arg2);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, object arg1, object arg2, object arg3);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, bool argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, char argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, byte argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, string argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, int argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, long argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, float argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, double argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, decimal argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, object argument);
    [EditorBrowsableAttribute("1")]
public void Fatal(string message, object argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Fatal(IFormatProvider formatProvider, string message, sbyte argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Fatal(string message, sbyte argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, UInt32 argument);
    [EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public void Fatal(string message, UInt32 argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Fatal(IFormatProvider formatProvider, string message, ulong argument);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public void Fatal(string message, ulong argument);
}
internal static class NLog.LoggerImpl : object {
    private static int StackTraceSkipMethods;
    private static Assembly nlogAssembly;
    private static Assembly mscorlibAssembly;
    private static Assembly systemAssembly;
    private static LoggerImpl();
    [SuppressMessageAttribute("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
internal static void Write(Type loggerType, TargetWithFilterChain targets, LogEventInfo logEvent, LogFactory factory);
    private static int FindCallingMethodOnStackTrace(StackTrace stackTrace, Type loggerType);
    private static bool SkipAssembly(Assembly assembly);
    private static bool WriteToTargetWithFilterChain(TargetWithFilterChain targetListHead, LogEventInfo logEvent, AsyncContinuation onException);
    private static FilterResult GetFilterResult(IEnumerable`1<Filter> filterChain, LogEventInfo logEvent);
}
internal class NLog.LogLevel : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Trace;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Debug;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Info;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Warn;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Error;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Fatal;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static LogLevel Off;
    private int ordinal;
    private string name;
    public string Name { get; }
    internal static LogLevel MaxLevel { get; }
    internal static LogLevel MinLevel { get; }
    internal int Ordinal { get; }
    private LogLevel(string name, int ordinal);
    private static LogLevel();
    public string get_Name();
    internal static LogLevel get_MaxLevel();
    internal static LogLevel get_MinLevel();
    internal int get_Ordinal();
    public static bool op_Equality(LogLevel level1, LogLevel level2);
    public static bool op_Inequality(LogLevel level1, LogLevel level2);
    public static bool op_GreaterThan(LogLevel level1, LogLevel level2);
    public static bool op_GreaterThanOrEqual(LogLevel level1, LogLevel level2);
    public static bool op_LessThan(LogLevel level1, LogLevel level2);
    public static bool op_LessThanOrEqual(LogLevel level1, LogLevel level2);
    public static LogLevel FromOrdinal(int ordinal);
    public static LogLevel FromString(string levelName);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(object obj);
}
internal class NLog.LogManager : object {
    private static LogFactory globalFactory;
    public static bool ThrowExceptions { get; public set; }
    public static LoggingConfiguration Configuration { get; public set; }
    public static LogLevel GlobalThreshold { get; public set; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
private static LogManager();
    public static void add_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public static void remove_ConfigurationChanged(EventHandler`1<LoggingConfigurationChangedEventArgs> value);
    public static void add_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    public static void remove_ConfigurationReloaded(EventHandler`1<LoggingConfigurationReloadedEventArgs> value);
    public static bool get_ThrowExceptions();
    public static void set_ThrowExceptions(bool value);
    public static LoggingConfiguration get_Configuration();
    public static void set_Configuration(LoggingConfiguration value);
    public static LogLevel get_GlobalThreshold();
    public static void set_GlobalThreshold(LogLevel value);
    public static Logger GetCurrentClassLogger();
    public static Logger GetCurrentClassLogger(Type loggerType);
    public static Logger CreateNullLogger();
    public static Logger GetLogger(string name);
    public static Logger GetLogger(string name, Type loggerType);
    public static void ReconfigExistingLoggers();
    public static void Flush();
    public static void Flush(TimeSpan timeout);
    public static void Flush(int timeoutMilliseconds);
    public static void Flush(AsyncContinuation asyncContinuation);
    public static void Flush(AsyncContinuation asyncContinuation, TimeSpan timeout);
    public static void Flush(AsyncContinuation asyncContinuation, int timeoutMilliseconds);
    public static IDisposable DisableLogging();
    public static void EnableLogging();
    public static bool IsLoggingEnabled();
    private static void SetupTerminationEvents();
    private static void TurnOffLogging(object sender, EventArgs args);
}
internal class NLog.LogMessageGenerator : MulticastDelegate {
    public LogMessageGenerator(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[ServiceContractAttribute]
internal interface NLog.LogReceiverService.ILogReceiverClient {
    [OperationContractAttribute]
public abstract virtual IAsyncResult BeginProcessLogMessages(NLogEvents events, AsyncCallback callback, object asyncState);
    public abstract virtual void EndProcessLogMessages(IAsyncResult result);
}
[ServiceContractAttribute]
internal interface NLog.LogReceiverService.ILogReceiverServer {
    [OperationContractAttribute]
public abstract virtual void ProcessLogMessages(NLogEvents events);
}
internal class NLog.LogReceiverService.LogReceiverForwardingService : object {
    private LogFactory logFactory;
    public LogReceiverForwardingService(LogFactory logFactory);
    public sealed virtual void ProcessLogMessages(NLogEvents events);
    protected virtual void ProcessLogMessages(LogEventInfo[] logEvents);
}
internal static class NLog.LogReceiverService.LogReceiverServiceConfig : object {
    internal static string WebServiceNamespace;
}
[DataContractAttribute]
[DebuggerDisplayAttribute("Event ID = {Id} Level={LevelName} Values={Values.Count}")]
[XmlTypeAttribute]
internal class NLog.LogReceiverService.NLogEvent : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LevelOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoggerOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <ValueIndexes>k__BackingField;
    [XmlElementAttribute("id")]
[DataMemberAttribute]
public int Id { get; public set; }
    [DataMemberAttribute]
[XmlElementAttribute("lv")]
public int LevelOrdinal { get; public set; }
    [DataMemberAttribute]
[XmlElementAttribute("lg")]
public int LoggerOrdinal { get; public set; }
    [XmlElementAttribute("ts")]
[DataMemberAttribute]
public long TimeDelta { get; public set; }
    [XmlElementAttribute("m")]
[DataMemberAttribute]
public int MessageOrdinal { get; public set; }
    [XmlElementAttribute("val")]
[DataMemberAttribute]
public string Values { get; public set; }
    [IgnoreDataMemberAttribute]
[XmlIgnoreAttribute]
internal IList`1<int> ValueIndexes { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_LevelOrdinal();
    [CompilerGeneratedAttribute]
public void set_LevelOrdinal(int value);
    [CompilerGeneratedAttribute]
public int get_LoggerOrdinal();
    [CompilerGeneratedAttribute]
public void set_LoggerOrdinal(int value);
    [CompilerGeneratedAttribute]
public long get_TimeDelta();
    [CompilerGeneratedAttribute]
public void set_TimeDelta(long value);
    [CompilerGeneratedAttribute]
public int get_MessageOrdinal();
    [CompilerGeneratedAttribute]
public void set_MessageOrdinal(int value);
    public string get_Values();
    public void set_Values(string value);
    [CompilerGeneratedAttribute]
internal IList`1<int> get_ValueIndexes();
    [CompilerGeneratedAttribute]
private void set_ValueIndexes(IList`1<int> value);
    internal LogEventInfo ToEventInfo(NLogEvents context, string loggerNamePrefix);
}
[DebuggerDisplayAttribute("Count = {Events.Length}")]
[DataContractAttribute]
[XmlTypeAttribute]
[XmlRootAttribute("events")]
internal class NLog.LogReceiverService.NLogEvents : object {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BaseTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private StringCollection <LayoutNames>k__BackingField;
    [CompilerGeneratedAttribute]
private StringCollection <Strings>k__BackingField;
    [CompilerGeneratedAttribute]
private NLogEvent[] <Events>k__BackingField;
    [XmlElementAttribute("cli")]
[DataMemberAttribute]
public string ClientName { get; public set; }
    [DataMemberAttribute]
[XmlElementAttribute("bts")]
public long BaseTimeUtc { get; public set; }
    [SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayItemAttribute("l")]
[DataMemberAttribute]
[XmlArrayAttribute("lts")]
public StringCollection LayoutNames { get; public set; }
    [XmlArrayAttribute("str")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[DataMemberAttribute]
[XmlArrayItemAttribute("l")]
public StringCollection Strings { get; public set; }
    [DataMemberAttribute]
[SuppressMessageAttribute("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayAttribute("ev")]
[XmlArrayItemAttribute("e")]
public NLogEvent[] Events { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public long get_BaseTimeUtc();
    [CompilerGeneratedAttribute]
public void set_BaseTimeUtc(long value);
    [CompilerGeneratedAttribute]
public StringCollection get_LayoutNames();
    [CompilerGeneratedAttribute]
public void set_LayoutNames(StringCollection value);
    [CompilerGeneratedAttribute]
public StringCollection get_Strings();
    [CompilerGeneratedAttribute]
public void set_Strings(StringCollection value);
    [CompilerGeneratedAttribute]
public NLogEvent[] get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(NLogEvent[] value);
    public IList`1<LogEventInfo> ToEventInfo(string loggerNamePrefix);
    public IList`1<LogEventInfo> ToEventInfo();
}
[CollectionDataContractAttribute]
internal class NLog.LogReceiverService.StringCollection : Collection`1<string> {
}
internal class NLog.LogReceiverService.WcfLogReceiverClient : ClientBase`1<ILogReceiverClient> {
    private EventHandler`1<AsyncCompletedEventArgs> ProcessLogMessagesCompleted;
    private EventHandler`1<AsyncCompletedEventArgs> OpenCompleted;
    private EventHandler`1<AsyncCompletedEventArgs> CloseCompleted;
    public WcfLogReceiverClient(string endpointConfigurationName);
    public WcfLogReceiverClient(string endpointConfigurationName, string remoteAddress);
    public WcfLogReceiverClient(string endpointConfigurationName, EndpointAddress remoteAddress);
    public WcfLogReceiverClient(Binding binding, EndpointAddress remoteAddress);
    public void add_ProcessLogMessagesCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void remove_ProcessLogMessagesCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void add_OpenCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void remove_OpenCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void add_CloseCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void remove_CloseCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public void OpenAsync();
    public void OpenAsync(object userState);
    public void CloseAsync();
    public void CloseAsync(object userState);
    public void ProcessLogMessagesAsync(NLogEvents events);
    public void ProcessLogMessagesAsync(NLogEvents events, object userState);
    private sealed virtual override IAsyncResult NLog.LogReceiverService.ILogReceiverClient.BeginProcessLogMessages(NLogEvents events, AsyncCallback callback, object asyncState);
    private sealed virtual override void NLog.LogReceiverService.ILogReceiverClient.EndProcessLogMessages(IAsyncResult result);
    private IAsyncResult OnBeginProcessLogMessages(Object[] inValues, AsyncCallback callback, object asyncState);
    private Object[] OnEndProcessLogMessages(IAsyncResult result);
    private void OnProcessLogMessagesCompleted(object state);
    private IAsyncResult OnBeginOpen(Object[] inValues, AsyncCallback callback, object asyncState);
    private Object[] OnEndOpen(IAsyncResult result);
    private void OnOpenCompleted(object state);
    private IAsyncResult OnBeginClose(Object[] inValues, AsyncCallback callback, object asyncState);
    private Object[] OnEndClose(IAsyncResult result);
    private void OnCloseCompleted(object state);
}
internal static class NLog.MappedDiagnosticsContext : object {
    private static object dataSlot;
    internal static IDictionary`2<string, string> ThreadDictionary { get; }
    private static MappedDiagnosticsContext();
    internal static IDictionary`2<string, string> get_ThreadDictionary();
    public static void Set(string item, string value);
    public static string Get(string item);
    public static bool Contains(string item);
    public static void Remove(string item);
    public static void Clear();
}
[ObsoleteAttribute("Use MappedDiagnosticsContext instead")]
internal static class NLog.MDC : object {
    public static void Set(string item, string value);
    public static string Get(string item);
    public static bool Contains(string item);
    public static void Remove(string item);
    public static void Clear();
}
[ObsoleteAttribute("Use NestedDiagnosticsContext")]
internal static class NLog.NDC : object {
    public static string TopMessage { get; }
    public static string get_TopMessage();
    public static IDisposable Push(string text);
    public static string Pop();
    public static void Clear();
    public static String[] GetAllMessages();
}
internal static class NLog.NestedDiagnosticsContext : object {
    private static object dataSlot;
    public static string TopMessage { get; }
    private static Stack`1<string> ThreadStack { get; }
    private static NestedDiagnosticsContext();
    public static string get_TopMessage();
    private static Stack`1<string> get_ThreadStack();
    public static IDisposable Push(string text);
    public static string Pop();
    public static void Clear();
    public static String[] GetAllMessages();
}
internal class NLog.NLogConfigurationException : Exception {
    public NLogConfigurationException(string message);
    public NLogConfigurationException(string message, Exception innerException);
    protected NLogConfigurationException(SerializationInfo info, StreamingContext context);
}
internal class NLog.NLogRuntimeException : Exception {
    public NLogRuntimeException(string message);
    public NLogRuntimeException(string message, Exception innerException);
    protected NLogRuntimeException(SerializationInfo info, StreamingContext context);
}
internal class NLog.NLogTraceListener : TraceListener {
    private static Assembly systemAssembly;
    private LogFactory logFactory;
    private LogLevel defaultLogLevel;
    private bool attributesLoaded;
    private bool autoLoggerName;
    private LogLevel forceLogLevel;
    public LogFactory LogFactory { get; public set; }
    public LogLevel DefaultLogLevel { get; public set; }
    public LogLevel ForceLogLevel { get; public set; }
    public bool IsThreadSafe { get; }
    public bool AutoLoggerName { get; public set; }
    private static NLogTraceListener();
    public LogFactory get_LogFactory();
    public void set_LogFactory(LogFactory value);
    public LogLevel get_DefaultLogLevel();
    public void set_DefaultLogLevel(LogLevel value);
    public LogLevel get_ForceLogLevel();
    public void set_ForceLogLevel(LogLevel value);
    public virtual bool get_IsThreadSafe();
    public bool get_AutoLoggerName();
    public void set_AutoLoggerName(bool value);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void Close();
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void Flush();
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    protected virtual String[] GetSupportedAttributes();
    private static LogLevel TranslateLogLevel(TraceEventType eventType);
    private void ProcessLogEventInfo(LogLevel logLevel, string loggerName, string message, Object[] arguments, Nullable`1<int> eventId);
    private void InitAttributes();
}
internal enum NLog.Targets.ArchiveNumberingMode : Enum {
    public int value__;
    public static ArchiveNumberingMode Sequence;
    public static ArchiveNumberingMode Rolling;
}
[TargetAttribute("AspResponse")]
internal class NLog.Targets.AspResponseTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private bool <AddComments>k__BackingField;
    public bool AddComments { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AddComments();
    [CompilerGeneratedAttribute]
public void set_AddComments(bool value);
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("Chainsaw")]
internal class NLog.Targets.ChainsawTarget : NLogViewerTarget {
}
[TargetAttribute("ColoredConsole")]
internal class NLog.Targets.ColoredConsoleTarget : TargetWithLayoutHeaderAndFooter {
    private static IList`1<ConsoleRowHighlightingRule> defaultConsoleRowHighlightingRules;
    [CompilerGeneratedAttribute]
private bool <ErrorStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDefaultRowHighlightingRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConsoleRowHighlightingRule> <RowHighlightingRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConsoleWordHighlightingRule> <WordHighlightingRules>k__BackingField;
    [DefaultValueAttribute("False")]
public bool ErrorStream { get; public set; }
    [DefaultValueAttribute("True")]
public bool UseDefaultRowHighlightingRules { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.ConsoleRowHighlightingRule", "highlight-row")]
public IList`1<ConsoleRowHighlightingRule> RowHighlightingRules { get; private set; }
    [ArrayParameterAttribute("NLog.Targets.ConsoleWordHighlightingRule", "highlight-word")]
public IList`1<ConsoleWordHighlightingRule> WordHighlightingRules { get; private set; }
    private static ColoredConsoleTarget();
    [CompilerGeneratedAttribute]
public bool get_ErrorStream();
    [CompilerGeneratedAttribute]
public void set_ErrorStream(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultRowHighlightingRules();
    [CompilerGeneratedAttribute]
public void set_UseDefaultRowHighlightingRules(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ConsoleRowHighlightingRule> get_RowHighlightingRules();
    [CompilerGeneratedAttribute]
private void set_RowHighlightingRules(IList`1<ConsoleRowHighlightingRule> value);
    [CompilerGeneratedAttribute]
public IList`1<ConsoleWordHighlightingRule> get_WordHighlightingRules();
    [CompilerGeneratedAttribute]
private void set_WordHighlightingRules(IList`1<ConsoleWordHighlightingRule> value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private static void ColorizeEscapeSequences(TextWriter output, string message, ColorPair startingColor, ColorPair defaultColor);
    private void Output(LogEventInfo logEvent, string message);
}
internal enum NLog.Targets.ConsoleOutputColor : Enum {
    public int value__;
    public static ConsoleOutputColor Black;
    public static ConsoleOutputColor DarkBlue;
    public static ConsoleOutputColor DarkGreen;
    public static ConsoleOutputColor DarkCyan;
    public static ConsoleOutputColor DarkRed;
    public static ConsoleOutputColor DarkMagenta;
    public static ConsoleOutputColor DarkYellow;
    public static ConsoleOutputColor Gray;
    public static ConsoleOutputColor DarkGray;
    public static ConsoleOutputColor Blue;
    public static ConsoleOutputColor Green;
    public static ConsoleOutputColor Cyan;
    public static ConsoleOutputColor Red;
    public static ConsoleOutputColor Magenta;
    public static ConsoleOutputColor Yellow;
    public static ConsoleOutputColor White;
    public static ConsoleOutputColor NoChange;
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.ConsoleRowHighlightingRule : object {
    [CompilerGeneratedAttribute]
private static ConsoleRowHighlightingRule <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <BackgroundColor>k__BackingField;
    public static ConsoleRowHighlightingRule Default { get; private set; }
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    [DefaultValueAttribute("NoChange")]
public ConsoleOutputColor ForegroundColor { get; public set; }
    [DefaultValueAttribute("NoChange")]
public ConsoleOutputColor BackgroundColor { get; public set; }
    private static ConsoleRowHighlightingRule();
    public ConsoleRowHighlightingRule(ConditionExpression condition, ConsoleOutputColor foregroundColor, ConsoleOutputColor backgroundColor);
    [CompilerGeneratedAttribute]
public static ConsoleRowHighlightingRule get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(ConsoleRowHighlightingRule value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(ConsoleOutputColor value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(ConsoleOutputColor value);
    public bool CheckCondition(LogEventInfo logEvent);
}
[TargetAttribute("Console")]
internal class NLog.Targets.ConsoleTarget : TargetWithLayoutHeaderAndFooter {
    [CompilerGeneratedAttribute]
private bool <Error>k__BackingField;
    [DefaultValueAttribute("False")]
public bool Error { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(bool value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private void Output(string s);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.ConsoleWordHighlightingRule : object {
    private Regex compiledRegex;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WholeWords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleOutputColor <BackgroundColor>k__BackingField;
    public string Regex { get; public set; }
    public string Text { get; public set; }
    [DefaultValueAttribute("False")]
public bool WholeWords { get; public set; }
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    public Regex CompiledRegex { get; }
    [DefaultValueAttribute("NoChange")]
public ConsoleOutputColor ForegroundColor { get; public set; }
    [DefaultValueAttribute("NoChange")]
public ConsoleOutputColor BackgroundColor { get; public set; }
    public ConsoleWordHighlightingRule(string text, ConsoleOutputColor foregroundColor, ConsoleOutputColor backgroundColor);
    [CompilerGeneratedAttribute]
public string get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public bool get_WholeWords();
    [CompilerGeneratedAttribute]
public void set_WholeWords(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    public Regex get_CompiledRegex();
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(ConsoleOutputColor value);
    [CompilerGeneratedAttribute]
public ConsoleOutputColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(ConsoleOutputColor value);
    internal string MatchEvaluator(Match m);
    internal string ReplaceWithEscapeSequences(string message);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.DatabaseCommandInfo : object {
    [CompilerGeneratedAttribute]
private CommandType <CommandType>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DatabaseParameterInfo> <Parameters>k__BackingField;
    [RequiredParameterAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CommandType CommandType { get; public set; }
    public Layout ConnectionString { get; public set; }
    [RequiredParameterAttribute]
public Layout Text { get; public set; }
    public bool IgnoreFailures { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.DatabaseParameterInfo", "parameter")]
public IList`1<DatabaseParameterInfo> Parameters { get; private set; }
    [CompilerGeneratedAttribute]
public CommandType get_CommandType();
    [CompilerGeneratedAttribute]
public void set_CommandType(CommandType value);
    [CompilerGeneratedAttribute]
public Layout get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(Layout value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailures();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailures(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DatabaseParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<DatabaseParameterInfo> value);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.DatabaseParameterInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Scale>k__BackingField;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [DefaultValueAttribute("0")]
public int Size { get; public set; }
    [DefaultValueAttribute("0")]
public byte Precision { get; public set; }
    [DefaultValueAttribute("0")]
public byte Scale { get; public set; }
    public DatabaseParameterInfo(string parameterName, Layout parameterLayout);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public byte get_Precision();
    [CompilerGeneratedAttribute]
public void set_Precision(byte value);
    [CompilerGeneratedAttribute]
public byte get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(byte value);
}
[TargetAttribute("Database")]
internal class NLog.Targets.DatabaseTarget : Target {
    private static Assembly systemDataAssembly;
    private IDbConnection activeConnection;
    private string activeConnectionString;
    [CompilerGeneratedAttribute]
private string <DBProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <InstallConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DatabaseCommandInfo> <InstallDdlCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DatabaseCommandInfo> <UninstallDdlCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <DBHost>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <DBUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <DBPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <DBDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DatabaseParameterInfo> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DbProviderFactory <ProviderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionStringSettingsCollection <ConnectionStringsSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConnectionType>k__BackingField;
    [DefaultValueAttribute("sqlserver")]
[RequiredParameterAttribute]
public string DBProvider { get; public set; }
    public string ConnectionStringName { get; public set; }
    public Layout ConnectionString { get; public set; }
    public Layout InstallConnectionString { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.DatabaseCommandInfo", "install-command")]
public IList`1<DatabaseCommandInfo> InstallDdlCommands { get; private set; }
    [ArrayParameterAttribute("NLog.Targets.DatabaseCommandInfo", "uninstall-command")]
public IList`1<DatabaseCommandInfo> UninstallDdlCommands { get; private set; }
    [DefaultValueAttribute("True")]
public bool KeepConnection { get; public set; }
    [DefaultValueAttribute("False")]
public bool UseTransactions { get; public set; }
    public Layout DBHost { get; public set; }
    public Layout DBUserName { get; public set; }
    public Layout DBPassword { get; public set; }
    public Layout DBDatabase { get; public set; }
    [RequiredParameterAttribute]
public Layout CommandText { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.DatabaseParameterInfo", "parameter")]
public IList`1<DatabaseParameterInfo> Parameters { get; private set; }
    internal DbProviderFactory ProviderFactory { get; internal set; }
    internal ConnectionStringSettingsCollection ConnectionStringsSettings { get; internal set; }
    internal Type ConnectionType { get; internal set; }
    private static DatabaseTarget();
    [CompilerGeneratedAttribute]
public string get_DBProvider();
    [CompilerGeneratedAttribute]
public void set_DBProvider(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public Layout get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_InstallConnectionString();
    [CompilerGeneratedAttribute]
public void set_InstallConnectionString(Layout value);
    [CompilerGeneratedAttribute]
public IList`1<DatabaseCommandInfo> get_InstallDdlCommands();
    [CompilerGeneratedAttribute]
private void set_InstallDdlCommands(IList`1<DatabaseCommandInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<DatabaseCommandInfo> get_UninstallDdlCommands();
    [CompilerGeneratedAttribute]
private void set_UninstallDdlCommands(IList`1<DatabaseCommandInfo> value);
    [CompilerGeneratedAttribute]
public bool get_KeepConnection();
    [CompilerGeneratedAttribute]
public void set_KeepConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseTransactions();
    [CompilerGeneratedAttribute]
public void set_UseTransactions(bool value);
    [CompilerGeneratedAttribute]
public Layout get_DBHost();
    [CompilerGeneratedAttribute]
public void set_DBHost(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_DBUserName();
    [CompilerGeneratedAttribute]
public void set_DBUserName(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_DBPassword();
    [CompilerGeneratedAttribute]
public void set_DBPassword(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_DBDatabase();
    [CompilerGeneratedAttribute]
public void set_DBDatabase(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_CommandText();
    [CompilerGeneratedAttribute]
public void set_CommandText(Layout value);
    [CompilerGeneratedAttribute]
public IList`1<DatabaseParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<DatabaseParameterInfo> value);
    [CompilerGeneratedAttribute]
internal DbProviderFactory get_ProviderFactory();
    [CompilerGeneratedAttribute]
internal void set_ProviderFactory(DbProviderFactory value);
    [CompilerGeneratedAttribute]
internal ConnectionStringSettingsCollection get_ConnectionStringsSettings();
    [CompilerGeneratedAttribute]
internal void set_ConnectionStringsSettings(ConnectionStringSettingsCollection value);
    [CompilerGeneratedAttribute]
internal Type get_ConnectionType();
    [CompilerGeneratedAttribute]
internal void set_ConnectionType(Type value);
    public sealed virtual void Install(InstallationContext installationContext);
    public sealed virtual void Uninstall(InstallationContext installationContext);
    public sealed virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
    internal IDbConnection OpenConnection(string connectionString);
    [SuppressMessageAttribute("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    [SuppressMessageAttribute("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities")]
private void WriteEventToDatabase(LogEventInfo logEvent);
    private string BuildConnectionString(LogEventInfo logEvent);
    private void EnsureConnectionOpen(string connectionString);
    private void CloseConnection();
    [SuppressMessageAttribute("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities")]
private void RunInstallCommands(InstallationContext installationContext, IEnumerable`1<DatabaseCommandInfo> commands);
    [CompilerGeneratedAttribute]
private string <Write>b__0(AsyncLogEventInfo c);
}
[TargetAttribute("Debugger")]
internal class NLog.Targets.DebuggerTarget : TargetWithLayoutHeaderAndFooter {
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("Debug")]
internal class NLog.Targets.DebugTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private int <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastMessage>k__BackingField;
    public int Counter { get; private set; }
    public string LastMessage { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(int value);
    [CompilerGeneratedAttribute]
public string get_LastMessage();
    [CompilerGeneratedAttribute]
private void set_LastMessage(string value);
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("EventLog")]
internal class NLog.Targets.EventLogTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Log>k__BackingField;
    [DefaultValueAttribute(".")]
public string MachineName { get; public set; }
    public Layout EventId { get; public set; }
    public Layout Category { get; public set; }
    public string Source { get; public set; }
    [DefaultValueAttribute("Application")]
public string Log { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public Layout get_EventId();
    [CompilerGeneratedAttribute]
public void set_EventId(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(Layout value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(string value);
    public sealed virtual void Install(InstallationContext installationContext);
    public sealed virtual void Uninstall(InstallationContext installationContext);
    public sealed virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
    protected virtual void InitializeTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private void CreateEventSourceIfNeeded();
}
internal enum NLog.Targets.FileArchivePeriod : Enum {
    public int value__;
    public static FileArchivePeriod None;
    public static FileArchivePeriod Year;
    public static FileArchivePeriod Month;
    public static FileArchivePeriod Day;
    public static FileArchivePeriod Hour;
    public static FileArchivePeriod Minute;
}
[TargetAttribute("File")]
internal class NLog.Targets.FileTarget : TargetWithLayoutHeaderAndFooter {
    private Dictionary`2<string, DateTime> initializedFiles;
    private LineEndingMode lineEndingMode;
    private IFileAppenderFactory appenderFactory;
    private BaseFileAppender[] recentAppenders;
    private Timer autoClosingTimer;
    private int initializedFilesCounter;
    [CompilerGeneratedAttribute]
private Layout <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteOldFileOnStartup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceFileContentsOnEachWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepFileOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableFileDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private Win32FileAttributes <FileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenFileCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenFileCacheTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConcurrentWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NetworkWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConcurrentWriteAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConcurrentWriteAttemptDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ArchiveAboveSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileArchivePeriod <ArchiveEvery>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <ArchiveFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxArchiveFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchiveNumberingMode <ArchiveNumbering>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLineChars>k__BackingField;
    [RequiredParameterAttribute]
public Layout FileName { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("True")]
public bool CreateDirs { get; public set; }
    [DefaultValueAttribute("False")]
public bool DeleteOldFileOnStartup { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("False")]
public bool ReplaceFileContentsOnEachWrite { get; public set; }
    [DefaultValueAttribute("False")]
public bool KeepFileOpen { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableFileDelete { get; public set; }
    [AdvancedAttribute]
public Win32FileAttributes FileAttributes { get; public set; }
    [AdvancedAttribute]
public LineEndingMode LineEnding { get; public set; }
    [DefaultValueAttribute("True")]
public bool AutoFlush { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("5")]
public int OpenFileCacheSize { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("-1")]
public int OpenFileCacheTimeout { get; public set; }
    [DefaultValueAttribute("32768")]
public int BufferSize { get; public set; }
    public Encoding Encoding { get; public set; }
    [DefaultValueAttribute("True")]
public bool ConcurrentWrites { get; public set; }
    [DefaultValueAttribute("False")]
public bool NetworkWrites { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("10")]
public int ConcurrentWriteAttempts { get; public set; }
    [AdvancedAttribute]
[DefaultValueAttribute("1")]
public int ConcurrentWriteAttemptDelay { get; public set; }
    public long ArchiveAboveSize { get; public set; }
    public FileArchivePeriod ArchiveEvery { get; public set; }
    public Layout ArchiveFileName { get; public set; }
    [DefaultValueAttribute("9")]
public int MaxArchiveFiles { get; public set; }
    public ArchiveNumberingMode ArchiveNumbering { get; public set; }
    protected internal string NewLineChars { get; private set; }
    [CompilerGeneratedAttribute]
public Layout get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(Layout value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CreateDirs();
    [CompilerGeneratedAttribute]
public void set_CreateDirs(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteOldFileOnStartup();
    [CompilerGeneratedAttribute]
public void set_DeleteOldFileOnStartup(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReplaceFileContentsOnEachWrite();
    [CompilerGeneratedAttribute]
public void set_ReplaceFileContentsOnEachWrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepFileOpen();
    [CompilerGeneratedAttribute]
public void set_KeepFileOpen(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableFileDelete();
    [CompilerGeneratedAttribute]
public void set_EnableFileDelete(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Win32FileAttributes get_FileAttributes();
    [CompilerGeneratedAttribute]
public void set_FileAttributes(Win32FileAttributes value);
    public LineEndingMode get_LineEnding();
    public void set_LineEnding(LineEndingMode value);
    [CompilerGeneratedAttribute]
public bool get_AutoFlush();
    [CompilerGeneratedAttribute]
public void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public int get_OpenFileCacheSize();
    [CompilerGeneratedAttribute]
public void set_OpenFileCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_OpenFileCacheTimeout();
    [CompilerGeneratedAttribute]
public void set_OpenFileCacheTimeout(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConcurrentWrites();
    [CompilerGeneratedAttribute]
public void set_ConcurrentWrites(bool value);
    [CompilerGeneratedAttribute]
public bool get_NetworkWrites();
    [CompilerGeneratedAttribute]
public void set_NetworkWrites(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ConcurrentWriteAttempts();
    [CompilerGeneratedAttribute]
public void set_ConcurrentWriteAttempts(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ConcurrentWriteAttemptDelay();
    [CompilerGeneratedAttribute]
public void set_ConcurrentWriteAttemptDelay(int value);
    [CompilerGeneratedAttribute]
public long get_ArchiveAboveSize();
    [CompilerGeneratedAttribute]
public void set_ArchiveAboveSize(long value);
    [CompilerGeneratedAttribute]
public FileArchivePeriod get_ArchiveEvery();
    [CompilerGeneratedAttribute]
public void set_ArchiveEvery(FileArchivePeriod value);
    [CompilerGeneratedAttribute]
public Layout get_ArchiveFileName();
    [CompilerGeneratedAttribute]
public void set_ArchiveFileName(Layout value);
    [CompilerGeneratedAttribute]
public int get_MaxArchiveFiles();
    [CompilerGeneratedAttribute]
public void set_MaxArchiveFiles(int value);
    [CompilerGeneratedAttribute]
public ArchiveNumberingMode get_ArchiveNumbering();
    [CompilerGeneratedAttribute]
public void set_ArchiveNumbering(ArchiveNumberingMode value);
    [CompilerGeneratedAttribute]
protected internal string get_NewLineChars();
    [CompilerGeneratedAttribute]
private void set_NewLineChars(string value);
    public void CleanupInitializedFiles();
    public void CleanupInitializedFiles(DateTime cleanupThreshold);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    protected virtual string GetFormattedMessage(LogEventInfo logEvent);
    protected virtual Byte[] GetBytesToWrite(LogEventInfo logEvent);
    protected virtual Byte[] TransformBytes(Byte[] value);
    private static string ReplaceNumber(string pattern, int value);
    private void FlushCurrentFileWrites(string currentFileName, LogEventInfo firstLogEvent, MemoryStream ms, List`1<AsyncContinuation> pendingContinuations);
    private void RecursiveRollingRename(string fileName, string pattern, int archiveNumber);
    private void SequentialArchive(string fileName, string pattern);
    private void DoAutoArchive(string fileName, LogEventInfo ev);
    private bool ShouldAutoArchive(string fileName, LogEventInfo ev, int upcomingWriteSize);
    private void AutoClosingTimerCallback(object state);
    private void WriteToFile(string fileName, Byte[] bytes, bool justData);
    private Byte[] GetHeaderBytes();
    private Byte[] GetFooterBytes();
    private void WriteFooterAndUninitialize(string fileName);
    private bool GetFileInfo(string fileName, DateTime& lastWriteTime, Int64& fileLength);
    private void InvalidateCacheItem(string fileName);
    [CompilerGeneratedAttribute]
private string <Write>b__0(AsyncLogEventInfo c);
}
[TargetAttribute("FormControl")]
internal class NLog.Targets.FormControlTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private string <ControlName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Append>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormName>k__BackingField;
    [RequiredParameterAttribute]
public string ControlName { get; public set; }
    [DefaultValueAttribute("True")]
public bool Append { get; public set; }
    public string FormName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ControlName();
    [CompilerGeneratedAttribute]
public void set_ControlName(string value);
    [CompilerGeneratedAttribute]
public bool get_Append();
    [CompilerGeneratedAttribute]
public void set_Append(bool value);
    [CompilerGeneratedAttribute]
public string get_FormName();
    [CompilerGeneratedAttribute]
public void set_FormName(string value);
    protected virtual void Write(LogEventInfo logEvent);
    private void FindControlAndSendTheMessage(string logMessage);
    private void SendTheMessageToFormControl(Control ctrl, string logMessage);
}
internal enum NLog.Targets.LineEndingMode : Enum {
    public int value__;
    public static LineEndingMode Default;
    public static LineEndingMode CRLF;
    public static LineEndingMode CR;
    public static LineEndingMode LF;
    public static LineEndingMode None;
}
[TargetAttribute("LogReceiverService")]
internal class NLog.Targets.LogReceiverWebServiceTarget : Target {
    private LogEventInfoBuffer buffer;
    private bool inCall;
    [CompilerGeneratedAttribute]
private string <EndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBinaryEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MethodCallParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEventProperties>k__BackingField;
    [RequiredParameterAttribute]
public string EndpointAddress { get; public set; }
    public string EndpointConfigurationName { get; public set; }
    public bool UseBinaryEncoding { get; public set; }
    public Layout ClientId { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.MethodCallParameter", "parameter")]
public IList`1<MethodCallParameter> Parameters { get; private set; }
    public bool IncludeEventProperties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EndpointAddress();
    [CompilerGeneratedAttribute]
public void set_EndpointAddress(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointConfigurationName();
    [CompilerGeneratedAttribute]
public void set_EndpointConfigurationName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseBinaryEncoding();
    [CompilerGeneratedAttribute]
public void set_UseBinaryEncoding(bool value);
    [CompilerGeneratedAttribute]
public Layout get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(Layout value);
    [CompilerGeneratedAttribute]
public IList`1<MethodCallParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<MethodCallParameter> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEventProperties();
    [CompilerGeneratedAttribute]
public void set_IncludeEventProperties(bool value);
    protected internal virtual bool OnSend(NLogEvents events, IEnumerable`1<AsyncLogEventInfo> asyncContinuations);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    private static int GetStringOrdinal(NLogEvents context, Dictionary`2<string, int> stringTable, string value);
    private NLogEvents TranslateLogEvents(AsyncLogEventInfo[] logEvents);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private void Send(NLogEvents events, IEnumerable`1<AsyncLogEventInfo> asyncContinuations);
    private void SendBufferedEvents();
    private NLogEvent TranslateEvent(LogEventInfo eventInfo, NLogEvents context, Dictionary`2<string, int> stringTable);
}
[TargetAttribute("Mail")]
internal class NLog.Targets.MailTarget : TargetWithLayoutHeaderAndFooter {
    [CompilerGeneratedAttribute]
private Layout <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <To>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <CC>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Bcc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddNewLines>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Html>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpServer>k__BackingField;
    [CompilerGeneratedAttribute]
private SmtpAuthenticationMode <SmtpAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <SmtpPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSsl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SmtpPort>k__BackingField;
    [RequiredParameterAttribute]
public Layout From { get; public set; }
    [RequiredParameterAttribute]
public Layout To { get; public set; }
    public Layout CC { get; public set; }
    public Layout Bcc { get; public set; }
    public bool AddNewLines { get; public set; }
    [DefaultValueAttribute("Message from NLog on ${machinename}")]
[RequiredParameterAttribute]
public Layout Subject { get; public set; }
    [DefaultValueAttribute("${message}")]
public Layout Body { get; public set; }
    [DefaultValueAttribute("UTF8")]
public Encoding Encoding { get; public set; }
    [DefaultValueAttribute("False")]
public bool Html { get; public set; }
    [RequiredParameterAttribute]
public Layout SmtpServer { get; public set; }
    [DefaultValueAttribute("None")]
public SmtpAuthenticationMode SmtpAuthentication { get; public set; }
    public Layout SmtpUserName { get; public set; }
    public Layout SmtpPassword { get; public set; }
    [DefaultValueAttribute("False")]
public bool EnableSsl { get; public set; }
    [DefaultValueAttribute("25")]
public int SmtpPort { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_From();
    [CompilerGeneratedAttribute]
public void set_From(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_To();
    [CompilerGeneratedAttribute]
public void set_To(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_CC();
    [CompilerGeneratedAttribute]
public void set_CC(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_Bcc();
    [CompilerGeneratedAttribute]
public void set_Bcc(Layout value);
    [CompilerGeneratedAttribute]
public bool get_AddNewLines();
    [CompilerGeneratedAttribute]
public void set_AddNewLines(bool value);
    [CompilerGeneratedAttribute]
public Layout get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(Layout value);
    public Layout get_Body();
    public void set_Body(Layout value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_Html();
    [CompilerGeneratedAttribute]
public void set_Html(bool value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpServer();
    [CompilerGeneratedAttribute]
public void set_SmtpServer(Layout value);
    [CompilerGeneratedAttribute]
public SmtpAuthenticationMode get_SmtpAuthentication();
    [CompilerGeneratedAttribute]
public void set_SmtpAuthentication(SmtpAuthenticationMode value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpUserName();
    [CompilerGeneratedAttribute]
public void set_SmtpUserName(Layout value);
    [CompilerGeneratedAttribute]
public Layout get_SmtpPassword();
    [CompilerGeneratedAttribute]
public void set_SmtpPassword(Layout value);
    [CompilerGeneratedAttribute]
public bool get_EnableSsl();
    [CompilerGeneratedAttribute]
public void set_EnableSsl(bool value);
    [CompilerGeneratedAttribute]
public int get_SmtpPort();
    [CompilerGeneratedAttribute]
public void set_SmtpPort(int value);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
internal virtual ISmtpClient CreateSmtpClient();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    private void ProcessSingleMailMessage(List`1<AsyncLogEventInfo> events);
    private string GetSmtpSettingsKey(LogEventInfo logEvent);
    private void SetupMailMessage(MailMessage msg, LogEventInfo logEvent);
    [CompilerGeneratedAttribute]
private string <Write>b__0(AsyncLogEventInfo c);
}
[TargetAttribute("Memory")]
internal class NLog.Targets.MemoryTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private IList`1<string> <Logs>k__BackingField;
    public IList`1<string> Logs { get; private set; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_Logs();
    [CompilerGeneratedAttribute]
private void set_Logs(IList`1<string> value);
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("MessageBox")]
internal class NLog.Targets.MessageBoxTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private Layout <Caption>k__BackingField;
    public Layout Caption { get; public set; }
    [CompilerGeneratedAttribute]
public Layout get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(Layout value);
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1300:SpecifyMessageBoxOptions")]
protected virtual void Write(LogEventInfo logEvent);
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1300:SpecifyMessageBoxOptions")]
protected virtual void Write(AsyncLogEventInfo[] logEvents);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.MethodCallParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    public string Name { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods")]
public Type Type { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public MethodCallParameter(Layout layout);
    public MethodCallParameter(string parameterName, Layout layout);
    public MethodCallParameter(string name, Layout layout, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
    internal object GetValue(LogEventInfo logEvent);
}
[TargetAttribute("MethodCall")]
internal class NLog.Targets.MethodCallTarget : MethodCallTargetBase {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public string ClassName { get; public set; }
    public string MethodName { get; public set; }
    private MethodInfo Method { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
private MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    protected virtual void InitializeTarget();
    protected virtual void DoInvoke(Object[] parameters);
}
internal abstract class NLog.Targets.MethodCallTargetBase : Target {
    [CompilerGeneratedAttribute]
private IList`1<MethodCallParameter> <Parameters>k__BackingField;
    [ArrayParameterAttribute("NLog.Targets.MethodCallParameter", "parameter")]
public IList`1<MethodCallParameter> Parameters { get; private set; }
    [CompilerGeneratedAttribute]
public IList`1<MethodCallParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<MethodCallParameter> value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void DoInvoke(Object[] parameters, AsyncContinuation continuation);
    protected abstract virtual void DoInvoke(Object[] parameters);
}
[TargetAttribute("Network")]
internal class NLog.Targets.NetworkTarget : TargetWithLayout {
    private Dictionary`2<string, NetworkSender> currentSenderCache;
    private List`1<NetworkSender> openNetworkSenders;
    [CompilerGeneratedAttribute]
private Layout <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkTargetOverflowAction <OnOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private INetworkSenderFactory <SenderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private static AsyncContinuation CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static AsyncContinuation CS$<>9__CachedAnonymousMethodDelegate19;
    public Layout Address { get; public set; }
    [DefaultValueAttribute("True")]
public bool KeepConnection { get; public set; }
    [DefaultValueAttribute("False")]
public bool NewLine { get; public set; }
    [DefaultValueAttribute("65000")]
public int MaxMessageSize { get; public set; }
    [DefaultValueAttribute("5")]
public int ConnectionCacheSize { get; public set; }
    public NetworkTargetOverflowAction OnOverflow { get; public set; }
    [DefaultValueAttribute("utf-8")]
public Encoding Encoding { get; public set; }
    internal INetworkSenderFactory SenderFactory { get; internal set; }
    [CompilerGeneratedAttribute]
public Layout get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(Layout value);
    [CompilerGeneratedAttribute]
public bool get_KeepConnection();
    [CompilerGeneratedAttribute]
public void set_KeepConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_NewLine();
    [CompilerGeneratedAttribute]
public void set_NewLine(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxMessageSize(int value);
    [CompilerGeneratedAttribute]
public int get_ConnectionCacheSize();
    [CompilerGeneratedAttribute]
public void set_ConnectionCacheSize(int value);
    [CompilerGeneratedAttribute]
public NetworkTargetOverflowAction get_OnOverflow();
    [CompilerGeneratedAttribute]
public void set_OnOverflow(NetworkTargetOverflowAction value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
internal INetworkSenderFactory get_SenderFactory();
    [CompilerGeneratedAttribute]
internal void set_SenderFactory(INetworkSenderFactory value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void CloseTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual Byte[] GetBytesToWrite(LogEventInfo logEvent);
    private NetworkSender GetCachedNetworkSender(string address);
    private void ReleaseCachedConnection(NetworkSender sender);
    [SuppressMessageAttribute("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
private void ChunkedSend(NetworkSender sender, Byte[] buffer, AsyncContinuation continuation);
    [CompilerGeneratedAttribute]
private static void <CloseTarget>b__5(Exception ex);
    [CompilerGeneratedAttribute]
private static void <ReleaseCachedConnection>b__18(Exception ex);
}
internal enum NLog.Targets.NetworkTargetOverflowAction : Enum {
    public int value__;
    public static NetworkTargetOverflowAction Error;
    public static NetworkTargetOverflowAction Split;
    public static NetworkTargetOverflowAction Discard;
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.NLogViewerParameterInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [RequiredParameterAttribute]
public string Name { get; public set; }
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Layout get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(Layout value);
}
[TargetAttribute("NLogViewer")]
internal class NLog.Targets.NLogViewerTarget : NetworkTarget {
    private Log4JXmlEventLayout layout;
    [CompilerGeneratedAttribute]
private IList`1<NLogViewerParameterInfo> <Parameters>k__BackingField;
    public bool IncludeNLogData { get; public set; }
    public string AppInfo { get; public set; }
    public bool IncludeCallSite { get; public set; }
    public bool IncludeSourceInfo { get; public set; }
    public bool IncludeMdc { get; public set; }
    public bool IncludeNdc { get; public set; }
    public string NdcItemSeparator { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.NLogViewerParameterInfo", "parameter")]
public IList`1<NLogViewerParameterInfo> Parameters { get; private set; }
    public Log4JXmlEventLayoutRenderer Renderer { get; }
    public Layout Layout { get; public set; }
    public bool get_IncludeNLogData();
    public void set_IncludeNLogData(bool value);
    public string get_AppInfo();
    public void set_AppInfo(string value);
    public bool get_IncludeCallSite();
    public void set_IncludeCallSite(bool value);
    public bool get_IncludeSourceInfo();
    public void set_IncludeSourceInfo(bool value);
    public bool get_IncludeMdc();
    public void set_IncludeMdc(bool value);
    public bool get_IncludeNdc();
    public void set_IncludeNdc(bool value);
    public string get_NdcItemSeparator();
    public void set_NdcItemSeparator(string value);
    [CompilerGeneratedAttribute]
public IList`1<NLogViewerParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<NLogViewerParameterInfo> value);
    public Log4JXmlEventLayoutRenderer get_Renderer();
    public virtual Layout get_Layout();
    public virtual void set_Layout(Layout value);
}
[TargetAttribute("Null")]
internal class NLog.Targets.NullTarget : TargetWithLayout {
    [CompilerGeneratedAttribute]
private bool <FormatMessage>k__BackingField;
    [DefaultValueAttribute("False")]
public bool FormatMessage { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FormatMessage();
    [CompilerGeneratedAttribute]
public void set_FormatMessage(bool value);
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("OutputDebugString")]
internal class NLog.Targets.OutputDebugStringTarget : TargetWithLayout {
    protected virtual void Write(LogEventInfo logEvent);
}
[TargetAttribute("PerfCounter")]
internal class NLog.Targets.PerformanceCounterTarget : Target {
    private PerformanceCounter perfCounter;
    private bool initialized;
    private bool created;
    [CompilerGeneratedAttribute]
private bool <AutoCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CategoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceCounterType <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySelector`2<PerformanceCounterTarget, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Predicate`1<PerformanceCounterTarget> CS$<>9__CachedAnonymousMethodDelegate3;
    public bool AutoCreate { get; public set; }
    [RequiredParameterAttribute]
public string CategoryName { get; public set; }
    [RequiredParameterAttribute]
public string CounterName { get; public set; }
    public string InstanceName { get; public set; }
    public string CounterHelp { get; public set; }
    [DefaultValueAttribute]
public PerformanceCounterType CounterType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutoCreate();
    [CompilerGeneratedAttribute]
public void set_AutoCreate(bool value);
    [CompilerGeneratedAttribute]
public string get_CategoryName();
    [CompilerGeneratedAttribute]
public void set_CategoryName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    [CompilerGeneratedAttribute]
public string get_InstanceName();
    [CompilerGeneratedAttribute]
public void set_InstanceName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterHelp();
    [CompilerGeneratedAttribute]
public void set_CounterHelp(string value);
    [CompilerGeneratedAttribute]
public PerformanceCounterType get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(PerformanceCounterType value);
    public sealed virtual void Install(InstallationContext installationContext);
    public sealed virtual void Uninstall(InstallationContext installationContext);
    public sealed virtual Nullable`1<bool> IsInstalled(InstallationContext installationContext);
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void CloseTarget();
    private static CounterCreationDataCollection GetCounterCreationDataCollection(IEnumerable`1<PerformanceCounterTarget> countersInCategory, PerformanceCounterCategoryType& categoryType);
    private bool EnsureInitialized();
    [CompilerGeneratedAttribute]
private static string <Install>b__0(PerformanceCounterTarget c);
    [CompilerGeneratedAttribute]
private static bool <Install>b__1(PerformanceCounterTarget c);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.RichTextBoxRowColoringRule : object {
    [CompilerGeneratedAttribute]
private static RichTextBoxRowColoringRule <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <Style>k__BackingField;
    public static RichTextBoxRowColoringRule Default { get; private set; }
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    [DefaultValueAttribute("Empty")]
public string FontColor { get; public set; }
    [DefaultValueAttribute("Empty")]
public string BackgroundColor { get; public set; }
    public FontStyle Style { get; public set; }
    private static RichTextBoxRowColoringRule();
    public RichTextBoxRowColoringRule(string condition, string fontColor, string backColor, FontStyle fontStyle);
    public RichTextBoxRowColoringRule(string condition, string fontColor, string backColor);
    [CompilerGeneratedAttribute]
public static RichTextBoxRowColoringRule get_Default();
    [CompilerGeneratedAttribute]
private static void set_Default(RichTextBoxRowColoringRule value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    [CompilerGeneratedAttribute]
public string get_FontColor();
    [CompilerGeneratedAttribute]
public void set_FontColor(string value);
    [CompilerGeneratedAttribute]
public string get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(string value);
    [CompilerGeneratedAttribute]
public FontStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(FontStyle value);
    public bool CheckCondition(LogEventInfo logEvent);
}
[TargetAttribute("RichTextBox")]
internal class NLog.Targets.RichTextBoxTarget : TargetWithLayout {
    private int lineCount;
    [CompilerGeneratedAttribute]
private static ReadOnlyCollection`1<RichTextBoxRowColoringRule> <DefaultRowColoringRules>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ControlName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDefaultRowColoringRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<RichTextBoxRowColoringRule> <RowColoringRules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<RichTextBoxWordColoringRule> <WordColoringRules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ToolWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowMinimized>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoScroll>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLines>k__BackingField;
    [CompilerGeneratedAttribute]
private Form <TargetForm>k__BackingField;
    [CompilerGeneratedAttribute]
private RichTextBox <TargetRichTextBox>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreatedForm>k__BackingField;
    public static ReadOnlyCollection`1<RichTextBoxRowColoringRule> DefaultRowColoringRules { get; private set; }
    public string ControlName { get; public set; }
    public string FormName { get; public set; }
    [DefaultValueAttribute("False")]
public bool UseDefaultRowColoringRules { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.RichTextBoxRowColoringRule", "row-coloring")]
public IList`1<RichTextBoxRowColoringRule> RowColoringRules { get; private set; }
    [ArrayParameterAttribute("NLog.Targets.RichTextBoxWordColoringRule", "word-coloring")]
public IList`1<RichTextBoxWordColoringRule> WordColoringRules { get; private set; }
    [DefaultValueAttribute("True")]
public bool ToolWindow { get; public set; }
    public bool ShowMinimized { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool AutoScroll { get; public set; }
    public int MaxLines { get; public set; }
    internal Form TargetForm { get; internal set; }
    internal RichTextBox TargetRichTextBox { get; internal set; }
    internal bool CreatedForm { get; internal set; }
    private static RichTextBoxTarget();
    [CompilerGeneratedAttribute]
public static ReadOnlyCollection`1<RichTextBoxRowColoringRule> get_DefaultRowColoringRules();
    [CompilerGeneratedAttribute]
private static void set_DefaultRowColoringRules(ReadOnlyCollection`1<RichTextBoxRowColoringRule> value);
    [CompilerGeneratedAttribute]
public string get_ControlName();
    [CompilerGeneratedAttribute]
public void set_ControlName(string value);
    [CompilerGeneratedAttribute]
public string get_FormName();
    [CompilerGeneratedAttribute]
public void set_FormName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultRowColoringRules();
    [CompilerGeneratedAttribute]
public void set_UseDefaultRowColoringRules(bool value);
    [CompilerGeneratedAttribute]
public IList`1<RichTextBoxRowColoringRule> get_RowColoringRules();
    [CompilerGeneratedAttribute]
private void set_RowColoringRules(IList`1<RichTextBoxRowColoringRule> value);
    [CompilerGeneratedAttribute]
public IList`1<RichTextBoxWordColoringRule> get_WordColoringRules();
    [CompilerGeneratedAttribute]
private void set_WordColoringRules(IList`1<RichTextBoxWordColoringRule> value);
    [CompilerGeneratedAttribute]
public bool get_ToolWindow();
    [CompilerGeneratedAttribute]
public void set_ToolWindow(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowMinimized();
    [CompilerGeneratedAttribute]
public void set_ShowMinimized(bool value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public bool get_AutoScroll();
    [CompilerGeneratedAttribute]
public void set_AutoScroll(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxLines();
    [CompilerGeneratedAttribute]
public void set_MaxLines(int value);
    [CompilerGeneratedAttribute]
internal Form get_TargetForm();
    [CompilerGeneratedAttribute]
internal void set_TargetForm(Form value);
    [CompilerGeneratedAttribute]
internal RichTextBox get_TargetRichTextBox();
    [CompilerGeneratedAttribute]
internal void set_TargetRichTextBox(RichTextBox value);
    [CompilerGeneratedAttribute]
internal bool get_CreatedForm();
    [CompilerGeneratedAttribute]
internal void set_CreatedForm(bool value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(LogEventInfo logEvent);
    private static Color GetColorFromString(string color, Color defaultColor);
    private void SendTheMessageToRichTextBox(string logMessage, RichTextBoxRowColoringRule rule);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.RichTextBoxWordColoringRule : object {
    private Regex compiledRegex;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WholeWords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackgroundColor>k__BackingField;
    public string Regex { get; public set; }
    public string Text { get; public set; }
    [DefaultValueAttribute("False")]
public bool WholeWords { get; public set; }
    [DefaultValueAttribute("False")]
public bool IgnoreCase { get; public set; }
    public FontStyle Style { get; public set; }
    public Regex CompiledRegex { get; }
    [DefaultValueAttribute("Empty")]
public string FontColor { get; public set; }
    [DefaultValueAttribute("Empty")]
public string BackgroundColor { get; public set; }
    public RichTextBoxWordColoringRule(string text, string fontColor, string backgroundColor);
    public RichTextBoxWordColoringRule(string text, string textColor, string backgroundColor, FontStyle fontStyle);
    [CompilerGeneratedAttribute]
public string get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public bool get_WholeWords();
    [CompilerGeneratedAttribute]
public void set_WholeWords(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public FontStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(FontStyle value);
    public Regex get_CompiledRegex();
    [CompilerGeneratedAttribute]
public string get_FontColor();
    [CompilerGeneratedAttribute]
public void set_FontColor(string value);
    [CompilerGeneratedAttribute]
public string get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(string value);
}
internal enum NLog.Targets.SmtpAuthenticationMode : Enum {
    public int value__;
    public static SmtpAuthenticationMode None;
    public static SmtpAuthenticationMode Basic;
    public static SmtpAuthenticationMode Ntlm;
}
[NLogConfigurationItemAttribute]
internal abstract class NLog.Targets.Target : object {
    private object lockObject;
    private List`1<Layout> allLayouts;
    private Exception initializeException;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfiguration <LoggingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public string Name { get; public set; }
    protected object SyncRoot { get; }
    protected LoggingConfiguration LoggingConfiguration { get; private set; }
    protected bool IsInitialized { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected object get_SyncRoot();
    [CompilerGeneratedAttribute]
protected LoggingConfiguration get_LoggingConfiguration();
    [CompilerGeneratedAttribute]
private void set_LoggingConfiguration(LoggingConfiguration value);
    [CompilerGeneratedAttribute]
protected bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Initialize(LoggingConfiguration configuration);
    private sealed virtual override void NLog.Internal.ISupportsInitialize.Close();
    public sealed virtual void Dispose();
    public void Flush(AsyncContinuation asyncContinuation);
    public void PrecalculateVolatileLayouts(LogEventInfo logEvent);
    public virtual string ToString();
    public void WriteAsyncLogEvent(AsyncLogEventInfo logEvent);
    public void WriteAsyncLogEvents(AsyncLogEventInfo[] logEvents);
    internal void Initialize(LoggingConfiguration configuration);
    internal void Close();
    internal void WriteAsyncLogEvents(AsyncLogEventInfo[] logEventInfos, AsyncContinuation continuation);
    protected virtual void Dispose(bool disposing);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    private Exception CreateInitException();
    private void GetAllLayouts();
}
[AttributeUsageAttribute("4")]
internal class NLog.Targets.TargetAttribute : NameBaseAttribute {
    [CompilerGeneratedAttribute]
private bool <IsWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompound>k__BackingField;
    public bool IsWrapper { get; public set; }
    public bool IsCompound { get; public set; }
    public TargetAttribute(string name);
    [CompilerGeneratedAttribute]
public bool get_IsWrapper();
    [CompilerGeneratedAttribute]
public void set_IsWrapper(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCompound();
    [CompilerGeneratedAttribute]
public void set_IsCompound(bool value);
}
internal abstract class NLog.Targets.TargetWithLayout : Target {
    [CompilerGeneratedAttribute]
private Layout <Layout>k__BackingField;
    [DefaultValueAttribute("${longdate}|${level:uppercase=true}|${logger}|${message}")]
[RequiredParameterAttribute]
public Layout Layout { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Layout get_Layout();
    [CompilerGeneratedAttribute]
public virtual void set_Layout(Layout value);
}
internal abstract class NLog.Targets.TargetWithLayoutHeaderAndFooter : TargetWithLayout {
    [RequiredParameterAttribute]
public Layout Layout { get; public set; }
    public Layout Footer { get; public set; }
    public Layout Header { get; public set; }
    private LayoutWithHeaderAndFooter LHF { get; private set; }
    public virtual Layout get_Layout();
    public virtual void set_Layout(Layout value);
    public Layout get_Footer();
    public void set_Footer(Layout value);
    public Layout get_Header();
    public void set_Header(Layout value);
    private LayoutWithHeaderAndFooter get_LHF();
    private void set_LHF(LayoutWithHeaderAndFooter value);
}
[TargetAttribute("Trace")]
internal class NLog.Targets.TraceTarget : TargetWithLayout {
    protected virtual void Write(LogEventInfo logEvent);
}
internal enum NLog.Targets.WebServiceProtocol : Enum {
    public int value__;
    public static WebServiceProtocol Soap11;
    public static WebServiceProtocol Soap12;
    public static WebServiceProtocol HttpPost;
    public static WebServiceProtocol HttpGet;
}
[TargetAttribute("WebService")]
internal class NLog.Targets.WebServiceTarget : MethodCallTargetBase {
    private static string SoapEnvelopeNamespace;
    private static string Soap12EnvelopeNamespace;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private WebServiceProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Uri Url { get; public set; }
    public string MethodName { get; public set; }
    public string Namespace { get; public set; }
    [DefaultValueAttribute("Soap11")]
public WebServiceProtocol Protocol { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Uri value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public WebServiceProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(WebServiceProtocol value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    protected virtual void DoInvoke(Object[] parameters);
    protected virtual void DoInvoke(Object[] parameters, AsyncContinuation continuation);
    private Byte[] PrepareSoap11Request(HttpWebRequest request, Object[] parameters);
    private Byte[] PrepareSoap12Request(HttpWebRequest request, Object[] parameterValues);
    private Byte[] PreparePostRequest(HttpWebRequest request, Object[] parameterValues);
}
[FlagsAttribute]
[SuppressMessageAttribute("Microsoft.Usage", "CA2217:DoNotMarkEnumsWithFlags")]
internal enum NLog.Targets.Win32FileAttributes : Enum {
    public int value__;
    public static Win32FileAttributes ReadOnly;
    public static Win32FileAttributes Hidden;
    public static Win32FileAttributes System;
    public static Win32FileAttributes Archive;
    public static Win32FileAttributes Device;
    public static Win32FileAttributes Normal;
    public static Win32FileAttributes Temporary;
    public static Win32FileAttributes SparseFile;
    public static Win32FileAttributes ReparsePoint;
    public static Win32FileAttributes Compressed;
    public static Win32FileAttributes NotContentIndexed;
    public static Win32FileAttributes Encrypted;
    public static Win32FileAttributes WriteThrough;
    public static Win32FileAttributes NoBuffering;
    public static Win32FileAttributes DeleteOnClose;
    public static Win32FileAttributes PosixSemantics;
}
internal class NLog.Targets.Wrappers.AsyncRequestQueue : object {
    private Queue`1<AsyncLogEventInfo> logEventInfoQueue;
    [CompilerGeneratedAttribute]
private int <RequestLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncTargetWrapperOverflowAction <OnOverflow>k__BackingField;
    public int RequestLimit { get; public set; }
    public AsyncTargetWrapperOverflowAction OnOverflow { get; public set; }
    public int RequestCount { get; }
    public AsyncRequestQueue(int requestLimit, AsyncTargetWrapperOverflowAction overflowAction);
    [CompilerGeneratedAttribute]
public int get_RequestLimit();
    [CompilerGeneratedAttribute]
public void set_RequestLimit(int value);
    [CompilerGeneratedAttribute]
public AsyncTargetWrapperOverflowAction get_OnOverflow();
    [CompilerGeneratedAttribute]
public void set_OnOverflow(AsyncTargetWrapperOverflowAction value);
    public int get_RequestCount();
    public void Enqueue(AsyncLogEventInfo logEventInfo);
    public AsyncLogEventInfo[] DequeueBatch(int count);
    public void Clear();
}
[TargetAttribute("AsyncWrapper")]
internal class NLog.Targets.Wrappers.AsyncTargetWrapper : WrapperTargetBase {
    private object lockObject;
    private Timer lazyWriterTimer;
    private AsyncContinuation flushAllContinuation;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeToSleepBetweenBatches>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncRequestQueue <RequestQueue>k__BackingField;
    [DefaultValueAttribute("100")]
public int BatchSize { get; public set; }
    [DefaultValueAttribute("50")]
public int TimeToSleepBetweenBatches { get; public set; }
    [DefaultValueAttribute("Discard")]
public AsyncTargetWrapperOverflowAction OverflowAction { get; public set; }
    [DefaultValueAttribute("10000")]
public int QueueLimit { get; public set; }
    internal AsyncRequestQueue RequestQueue { get; private set; }
    public AsyncTargetWrapper(Target wrappedTarget);
    public AsyncTargetWrapper(Target wrappedTarget, int queueLimit, AsyncTargetWrapperOverflowAction overflowAction);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_TimeToSleepBetweenBatches();
    [CompilerGeneratedAttribute]
public void set_TimeToSleepBetweenBatches(int value);
    public AsyncTargetWrapperOverflowAction get_OverflowAction();
    public void set_OverflowAction(AsyncTargetWrapperOverflowAction value);
    public int get_QueueLimit();
    public void set_QueueLimit(int value);
    [CompilerGeneratedAttribute]
internal AsyncRequestQueue get_RequestQueue();
    [CompilerGeneratedAttribute]
private void set_RequestQueue(AsyncRequestQueue value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void StartLazyWriterTimer();
    protected virtual void StopLazyWriterThread();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private void ProcessPendingEvents(object state);
}
internal enum NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction : Enum {
    public int value__;
    public static AsyncTargetWrapperOverflowAction Grow;
    public static AsyncTargetWrapperOverflowAction Discard;
    public static AsyncTargetWrapperOverflowAction Block;
}
[TargetAttribute("AutoFlushWrapper")]
internal class NLog.Targets.Wrappers.AutoFlushTargetWrapper : WrapperTargetBase {
    public AutoFlushTargetWrapper(Target wrappedTarget);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("BufferingWrapper")]
internal class NLog.Targets.Wrappers.BufferingTargetWrapper : WrapperTargetBase {
    private LogEventInfoBuffer buffer;
    private Timer flushTimer;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FlushTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SlidingTimeout>k__BackingField;
    [DefaultValueAttribute("100")]
public int BufferSize { get; public set; }
    [DefaultValueAttribute("-1")]
public int FlushTimeout { get; public set; }
    [DefaultValueAttribute("True")]
public bool SlidingTimeout { get; public set; }
    public BufferingTargetWrapper(Target wrappedTarget);
    public BufferingTargetWrapper(Target wrappedTarget, int bufferSize);
    public BufferingTargetWrapper(Target wrappedTarget, int bufferSize, int flushTimeout);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_FlushTimeout();
    [CompilerGeneratedAttribute]
public void set_FlushTimeout(int value);
    [CompilerGeneratedAttribute]
public bool get_SlidingTimeout();
    [CompilerGeneratedAttribute]
public void set_SlidingTimeout(bool value);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    private void FlushCallback(object state);
}
internal abstract class NLog.Targets.Wrappers.CompoundTargetBase : Target {
    [CompilerGeneratedAttribute]
private IList`1<Target> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private static AsynchronousAction`1<Target> CS$<>9__CachedAnonymousMethodDelegate1;
    public IList`1<Target> Targets { get; private set; }
    protected CompoundTargetBase(Target[] targets);
    [CompilerGeneratedAttribute]
public IList`1<Target> get_Targets();
    [CompilerGeneratedAttribute]
private void set_Targets(IList`1<Target> value);
    public virtual string ToString();
    protected virtual void Write(LogEventInfo logEvent);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    [CompilerGeneratedAttribute]
private static void <FlushAsync>b__0(Target t, AsyncContinuation c);
}
[TargetAttribute("FallbackGroup")]
internal class NLog.Targets.Wrappers.FallbackGroupTarget : CompoundTargetBase {
    private int currentTarget;
    private object lockObject;
    [CompilerGeneratedAttribute]
private bool <ReturnToFirstOnSuccess>k__BackingField;
    public bool ReturnToFirstOnSuccess { get; public set; }
    public FallbackGroupTarget(Target[] targets);
    [CompilerGeneratedAttribute]
public bool get_ReturnToFirstOnSuccess();
    [CompilerGeneratedAttribute]
public void set_ReturnToFirstOnSuccess(bool value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[NLogConfigurationItemAttribute]
internal class NLog.Targets.Wrappers.FilteringRule : object {
    [CompilerGeneratedAttribute]
private ConditionExpression <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionExpression <Filter>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression Exists { get; public set; }
    [RequiredParameterAttribute]
public ConditionExpression Filter { get; public set; }
    public FilteringRule(ConditionExpression whenExistsExpression, ConditionExpression filterToApply);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(ConditionExpression value);
    [CompilerGeneratedAttribute]
public ConditionExpression get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(ConditionExpression value);
}
[TargetAttribute("FilteringWrapper")]
internal class NLog.Targets.Wrappers.FilteringTargetWrapper : WrapperTargetBase {
    private static object boxedBooleanTrue;
    [CompilerGeneratedAttribute]
private ConditionExpression <Condition>k__BackingField;
    [RequiredParameterAttribute]
public ConditionExpression Condition { get; public set; }
    public FilteringTargetWrapper(Target wrappedTarget, ConditionExpression condition);
    private static FilteringTargetWrapper();
    [CompilerGeneratedAttribute]
public ConditionExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(ConditionExpression value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("ImpersonatingWrapper")]
internal class NLog.Targets.Wrappers.ImpersonatingTargetWrapper : WrapperTargetBase {
    private WindowsIdentity newIdentity;
    private IntPtr duplicateTokenHandle;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityLogOnType <LogOnType>k__BackingField;
    [CompilerGeneratedAttribute]
private LogOnProviderType <LogOnProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityImpersonationLevel <ImpersonationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RevertToSelf>k__BackingField;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    [DefaultValueAttribute(".")]
public string Domain { get; public set; }
    public SecurityLogOnType LogOnType { get; public set; }
    public LogOnProviderType LogOnProvider { get; public set; }
    public SecurityImpersonationLevel ImpersonationLevel { get; public set; }
    [DefaultValueAttribute("False")]
public bool RevertToSelf { get; public set; }
    public ImpersonatingTargetWrapper(Target wrappedTarget);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public SecurityLogOnType get_LogOnType();
    [CompilerGeneratedAttribute]
public void set_LogOnType(SecurityLogOnType value);
    [CompilerGeneratedAttribute]
public LogOnProviderType get_LogOnProvider();
    [CompilerGeneratedAttribute]
public void set_LogOnProvider(LogOnProviderType value);
    [CompilerGeneratedAttribute]
public SecurityImpersonationLevel get_ImpersonationLevel();
    [CompilerGeneratedAttribute]
public void set_ImpersonationLevel(SecurityImpersonationLevel value);
    [CompilerGeneratedAttribute]
public bool get_RevertToSelf();
    [CompilerGeneratedAttribute]
public void set_RevertToSelf(bool value);
    protected virtual void InitializeTarget();
    protected virtual void CloseTarget();
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    private IDisposable DoImpersonate();
    private WindowsIdentity CreateWindowsIdentity(IntPtr& handle);
}
internal enum NLog.Targets.Wrappers.LogOnProviderType : Enum {
    public int value__;
    public static LogOnProviderType Default;
}
[TargetAttribute("PostFilteringWrapper")]
internal class NLog.Targets.Wrappers.PostFilteringTargetWrapper : WrapperTargetBase {
    private static object boxedTrue;
    [CompilerGeneratedAttribute]
private ConditionExpression <DefaultFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FilteringRule> <Rules>k__BackingField;
    public ConditionExpression DefaultFilter { get; public set; }
    [ArrayParameterAttribute("NLog.Targets.Wrappers.FilteringRule", "when")]
public IList`1<FilteringRule> Rules { get; private set; }
    private static PostFilteringTargetWrapper();
    [CompilerGeneratedAttribute]
public ConditionExpression get_DefaultFilter();
    [CompilerGeneratedAttribute]
public void set_DefaultFilter(ConditionExpression value);
    [CompilerGeneratedAttribute]
public IList`1<FilteringRule> get_Rules();
    [CompilerGeneratedAttribute]
private void set_Rules(IList`1<FilteringRule> value);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
}
[TargetAttribute("RandomizeGroup")]
internal class NLog.Targets.Wrappers.RandomizeGroupTarget : CompoundTargetBase {
    private Random random;
    public RandomizeGroupTarget(Target[] targets);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("RepeatingWrapper")]
internal class NLog.Targets.Wrappers.RepeatingTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private int <RepeatCount>k__BackingField;
    [DefaultValueAttribute("3")]
public int RepeatCount { get; public set; }
    public RepeatingTargetWrapper(Target wrappedTarget, int repeatCount);
    [CompilerGeneratedAttribute]
public int get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(int value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("RetryingWrapper")]
internal class NLog.Targets.Wrappers.RetryingTargetWrapper : WrapperTargetBase {
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [DefaultValueAttribute("3")]
public int RetryCount { get; public set; }
    [DefaultValueAttribute("100")]
public int RetryDelayMilliseconds { get; public set; }
    public RetryingTargetWrapper(Target wrappedTarget, int retryCount, int retryDelayMilliseconds);
    [CompilerGeneratedAttribute]
public int get_RetryCount();
    [CompilerGeneratedAttribute]
public void set_RetryCount(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
[TargetAttribute("RoundRobinGroup")]
internal class NLog.Targets.Wrappers.RoundRobinGroupTarget : CompoundTargetBase {
    private int currentTarget;
    private object lockObject;
    public RoundRobinGroupTarget(Target[] targets);
    protected virtual void Write(AsyncLogEventInfo logEvent);
}
internal enum NLog.Targets.Wrappers.SecurityImpersonationLevel : Enum {
    public int value__;
    public static SecurityImpersonationLevel Anonymous;
    public static SecurityImpersonationLevel Identification;
    public static SecurityImpersonationLevel Impersonation;
    public static SecurityImpersonationLevel Delegation;
}
[SuppressMessageAttribute("Microsoft.Design", "CA1008:EnumsShouldHaveZeroValue")]
internal enum NLog.Targets.Wrappers.SecurityLogOnType : Enum {
    public int value__;
    public static SecurityLogOnType Interactive;
    public static SecurityLogOnType Network;
    public static SecurityLogOnType Batch;
    public static SecurityLogOnType Service;
    public static SecurityLogOnType NetworkClearText;
    public static SecurityLogOnType NewCredentials;
}
[TargetAttribute("SplitGroup")]
internal class NLog.Targets.Wrappers.SplitGroupTarget : CompoundTargetBase {
    public SplitGroupTarget(Target[] targets);
    protected virtual void Write(AsyncLogEventInfo logEvent);
    protected virtual void Write(AsyncLogEventInfo[] logEvents);
    private static AsyncContinuation CountedWrap(AsyncContinuation originalContinuation, int counter);
}
internal abstract class NLog.Targets.Wrappers.WrapperTargetBase : Target {
    [CompilerGeneratedAttribute]
private Target <WrappedTarget>k__BackingField;
    [RequiredParameterAttribute]
public Target WrappedTarget { get; public set; }
    [CompilerGeneratedAttribute]
public Target get_WrappedTarget();
    [CompilerGeneratedAttribute]
public void set_WrappedTarget(Target value);
    public virtual string ToString();
    protected virtual void FlushAsync(AsyncContinuation asyncContinuation);
    protected sealed virtual void Write(LogEventInfo logEvent);
}
internal class Tavis.UriTemplates.UriTemplate : object {
    private static string _UriReservedSymbols;
    private static string _UriUnreservedSymbols;
    private static Dictionary`2<char, OperatorInfo> _Operators;
    private string _template;
    private Dictionary`2<string, object> _Parameters;
    private bool _ErrorDetected;
    private StringBuilder _Result;
    private List`1<string> _ParameterNames;
    public UriTemplate(string template);
    private static UriTemplate();
    public void SetParameter(string name, object value);
    public void SetParameter(string name, string value);
    public void SetParameter(string name, IEnumerable`1<string> value);
    public void SetParameter(string name, IDictionary`2<string, string> value);
    public IEnumerable`1<string> GetParameterNames();
    public string Resolve();
    private void ProcessExpression(StringBuilder currentExpression);
    private bool ProcessVariable(VarSpec varSpec);
    private void AppendDictionary(OperatorInfo op, bool explode, IDictionary`2<string, string> dictionary);
    private void AppendList(OperatorInfo op, bool explode, string variable, IEnumerable`1<string> list);
    private void AppendValue(string value, int prefixLength, bool allowReserved);
    private void AppendName(string variable, OperatorInfo op, bool valueIsEmpty);
    private static string Encode(string p, bool allowReserved);
    private static OperatorInfo GetOperator(char operatorIndicator);
}
