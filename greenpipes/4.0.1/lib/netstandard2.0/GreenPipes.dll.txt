public class GreenPipes.Agents.ActivePipeContext`1 : object {
    private Task`1<TContext> _context;
    private PipeContextHandle`1<TContext> _contextHandle;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.Context { get; }
    public ActivePipeContext`1(PipeContextHandle`1<TContext> contextHandle, Task`1<TContext> context);
    public ActivePipeContext`1(PipeContextHandle`1<TContext> contextHandle, TContext context);
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.get_Context();
    [AsyncStateMachineAttribute("GreenPipes.Agents.ActivePipeContext`1/<GreenPipes-Agents-ActivePipeContextHandle<TContext>-Faulted>d__8")]
private sealed virtual override Task GreenPipes.Agents.ActivePipeContextHandle<TContext>.Faulted(Exception exception);
    public sealed virtual ValueTask DisposeAsync();
}
public class GreenPipes.Agents.ActivePipeContextAgent`1 : Agent {
    private static string _caption;
    private ActivePipeContextHandle`1<TContext> _contextHandle;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.Context { get; }
    public ActivePipeContextAgent`1(ActivePipeContextHandle`1<TContext> context);
    private static ActivePipeContextAgent`1();
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override Task GreenPipes.Agents.ActivePipeContextHandle<TContext>.Faulted(Exception exception);
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    [AsyncStateMachineAttribute("GreenPipes.Agents.ActivePipeContextAgent`1/<StopAgent>d__9")]
protected virtual Task StopAgent(StopContext context);
    public virtual string ToString();
}
public interface GreenPipes.Agents.ActivePipeContextHandle`1 {
    public abstract virtual Task Faulted(Exception exception);
}
public class GreenPipes.Agents.Agent : object {
    private TaskCompletionSource`1<bool> _completed;
    private TaskCompletionSource`1<bool> _ready;
    private Lazy`1<CancellationTokenSource> _stopped;
    private Lazy`1<CancellationTokenSource> _stopping;
    private bool _isStopped;
    private bool _isStopping;
    private TaskCompletionSource`1<bool> _setCompleted;
    private CancellationTokenSource _setCompletedCancel;
    private TaskCompletionSource`1<bool> _setReady;
    private CancellationTokenSource _setReadyCancel;
    protected bool IsStopping { get; }
    protected bool IsStopped { get; }
    protected bool IsAlreadyReady { get; }
    protected bool IsAlreadyCompleted { get; }
    public Task Ready { get; }
    public Task Completed { get; }
    public CancellationToken Stopping { get; }
    public CancellationToken Stopped { get; }
    protected bool get_IsStopping();
    protected bool get_IsStopped();
    protected bool get_IsAlreadyReady();
    protected bool get_IsAlreadyCompleted();
    public sealed virtual Task get_Ready();
    public sealed virtual Task get_Completed();
    public sealed virtual CancellationToken get_Stopping();
    public sealed virtual CancellationToken get_Stopped();
    [AsyncStateMachineAttribute("GreenPipes.Agents.Agent/<Stop>d__27")]
public sealed virtual Task Stop(StopContext context);
    protected virtual Task StopAgent(StopContext context);
    public virtual void SetReady();
    public virtual void SetNotReady(Exception exception);
    protected void SetReady(Task readyTask);
    protected void SetCompleted(Task completedTask);
    public virtual string ToString();
    protected void SetFaulted(Task task);
    [CompilerGeneratedAttribute]
private CancellationTokenSource <.ctor>b__10_0();
    [CompilerGeneratedAttribute]
private CancellationTokenSource <.ctor>b__10_1();
}
[ExtensionAttribute]
public static class GreenPipes.Agents.AgentExtensions : object {
    [ExtensionAttribute]
public static bool IsReady(IAgent agent);
    [ExtensionAttribute]
public static bool IsCompleted(IAgent agent);
}
public class GreenPipes.Agents.AsyncPipeContextAgent`1 : object {
    private IPipeContextAgent`1<TContext> _agent;
    private TaskCompletionSource`1<TContext> _context;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.Context { get; }
    private Task GreenPipes.Agents.IAgent.Ready { get; }
    private Task GreenPipes.Agents.IAgent.Completed { get; }
    private CancellationToken GreenPipes.Agents.IAgent.Stopping { get; }
    private CancellationToken GreenPipes.Agents.IAgent.Stopped { get; }
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private sealed virtual override Task GreenPipes.Agents.IAgent.get_Ready();
    private sealed virtual override Task GreenPipes.Agents.IAgent.get_Completed();
    private sealed virtual override CancellationToken GreenPipes.Agents.IAgent.get_Stopping();
    private sealed virtual override CancellationToken GreenPipes.Agents.IAgent.get_Stopped();
    private sealed virtual override Task GreenPipes.Agents.IAgent.Stop(StopContext context);
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.Created(TContext context);
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.CreateCanceled();
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.CreateFaulted(Exception exception);
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.Faulted(Exception exception);
    public virtual string ToString();
}
public class GreenPipes.Agents.AsyncPipeContextFilter`1 : object {
    private IAsyncPipeContextAgent`1<TContext> _agent;
    public AsyncPipeContextFilter`1(IAsyncPipeContextAgent`1<TContext> agent);
    [AsyncStateMachineAttribute("GreenPipes.Agents.AsyncPipeContextFilter`1/<Send>d__2")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class GreenPipes.Agents.AsyncPipeContextPipe`1 : object {
    private IAsyncPipeContextAgent`1<TContext> _agent;
    private IPipe`1<TContext> _pipe;
    public AsyncPipeContextPipe`1(IAsyncPipeContextAgent`1<TContext> agent, IPipe`1<TContext> pipe);
    [AsyncStateMachineAttribute("GreenPipes.Agents.AsyncPipeContextPipe`1/<Send>d__3")]
public sealed virtual Task Send(TContext context);
    public sealed virtual void Probe(ProbeContext context);
}
public interface GreenPipes.Agents.IActivePipeContextAgent`1 {
}
public interface GreenPipes.Agents.IAgent {
    public Task Ready { get; }
    public Task Completed { get; }
    public CancellationToken Stopping { get; }
    public CancellationToken Stopped { get; }
    public abstract virtual Task get_Ready();
    public abstract virtual Task get_Completed();
    public abstract virtual CancellationToken get_Stopping();
    public abstract virtual CancellationToken get_Stopped();
    public abstract virtual Task Stop(StopContext context);
}
public interface GreenPipes.Agents.IAgent`1 {
}
public interface GreenPipes.Agents.IAsyncPipeContextAgent`1 {
}
public interface GreenPipes.Agents.IPipeContextAgent`1 {
}
public interface GreenPipes.Agents.IPipeContextFactory`1 {
    public abstract virtual IPipeContextAgent`1<TContext> CreateContext(ISupervisor supervisor);
    public abstract virtual IActivePipeContextAgent`1<TContext> CreateActiveContext(ISupervisor supervisor, PipeContextHandle`1<TContext> context, CancellationToken cancellationToken);
}
public interface GreenPipes.Agents.ISupervisor {
    public int PeakActiveCount { get; }
    public long TotalCount { get; }
    public abstract virtual int get_PeakActiveCount();
    public abstract virtual long get_TotalCount();
    public abstract virtual void Add(IAgent agent);
}
public interface GreenPipes.Agents.ISupervisor`1 {
}
public class GreenPipes.Agents.PipeContextAgent`1 : Agent {
    private Task`1<TContext> _context;
    private TaskCompletionSource`1<DateTime> _inactive;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.Context { get; }
    public PipeContextAgent`1(TContext context);
    public PipeContextAgent`1(Task`1<TContext> context);
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.get_Context();
    [AsyncStateMachineAttribute("GreenPipes.Agents.PipeContextAgent`1/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("GreenPipes.Agents.PipeContextAgent`1/<StopAgent>d__9")]
protected virtual Task StopAgent(StopContext context);
}
public class GreenPipes.Agents.PipeContextSupervisor`1 : Supervisor {
    private ISupervisor _activeSupervisor;
    private IPipeContextFactory`1<TContext> _contextFactory;
    private object _contextLock;
    private PipeContextHandle`1<TContext> _context;
    protected bool HasContext { get; }
    public PipeContextSupervisor`1(IPipeContextFactory`1<TContext> contextFactory);
    protected bool get_HasContext();
    [AsyncStateMachineAttribute("GreenPipes.Agents.PipeContextSupervisor`1/<GreenPipes-IPipeContextSource<TContext>-Send>d__7")]
private sealed virtual override Task GreenPipes.IPipeContextSource<TContext>.Send(IPipe`1<TContext> pipe, CancellationToken cancellationToken);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Agents.PipeContextSupervisor`1/<StopSupervisor>d__9")]
protected virtual Task StopSupervisor(StopSupervisorContext context);
    [AsyncStateMachineAttribute("GreenPipes.Agents.PipeContextSupervisor`1/<ActiveAndActualAgentsCompleted>d__10")]
private Task ActiveAndActualAgentsCompleted(StopSupervisorContext context);
    private IActivePipeContextAgent`1<TContext> CreateActiveContext(CancellationToken cancellationToken);
    private PipeContextHandle`1<TContext> GetContext();
}
public interface GreenPipes.Agents.StopContext {
    public string Reason { get; }
    public abstract virtual string get_Reason();
}
public interface GreenPipes.Agents.StopSupervisorContext {
    public IAgent[] Agents { get; }
    public abstract virtual IAgent[] get_Agents();
}
public class GreenPipes.Agents.Supervisor : Agent {
    private Dictionary`2<long, IAgent> _agents;
    private long _nextId;
    private int _peakActiveCount;
    private long _totalCount;
    public int PeakActiveCount { get; }
    public long TotalCount { get; }
    public sealed virtual void Add(IAgent agent);
    public sealed virtual int get_PeakActiveCount();
    public sealed virtual long get_TotalCount();
    public virtual void SetReady();
    protected virtual Task StopAgent(StopContext context);
    [AsyncStateMachineAttribute("GreenPipes.Agents.Supervisor/<StopSupervisor>d__12")]
protected virtual Task StopSupervisor(StopSupervisorContext context);
    private void Remove(long id);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class GreenPipes.AsyncPipeContextHandleExtensions : object {
    [ExtensionAttribute]
public static Task Notify(IAsyncPipeContextHandle`1<T> handle, Task`1<T> task);
}
public abstract class GreenPipes.BasePipeContext : object {
    private IPayloadCache _payloadCache;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    protected IPayloadCache PayloadCache { get; }
    protected BasePipeContext(Object[] payloads);
    protected BasePipeContext(CancellationToken cancellationToken);
    protected BasePipeContext(CancellationToken cancellationToken, Object[] payloads);
    protected BasePipeContext(IPayloadCache payloadCache);
    protected BasePipeContext(IPayloadCache payloadCache, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    protected IPayloadCache get_PayloadCache();
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
[ExtensionAttribute]
public static class GreenPipes.BindConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseBind(IPipeConfigurator`1<TLeft> configurator, Action`1<IBindConfigurator`1<TLeft>> configure);
}
public interface GreenPipes.BindContext`2 {
    public TLeft Left { get; }
    public TRight Right { get; }
    public abstract virtual TLeft get_Left();
    public abstract virtual TRight get_Right();
}
public interface GreenPipes.Builders.IBuildPipeConfigurator`1 {
    public abstract virtual IPipe`1<TContext> Build();
}
public interface GreenPipes.Builders.IBuildRequestPipeConfigurator`2 {
    public abstract virtual IRequestPipe`1<TRequest> Build(IPipe`1<ResultContext> resultPipe);
}
public interface GreenPipes.Builders.IBuildResultPipeConfigurator`2 {
    public abstract virtual IRequestPipe`2<TRequest, TResult> Build();
}
public class GreenPipes.Builders.PipeBuilder`1 : object {
    private List`1<IFilter`1<TContext>> _filters;
    public PipeBuilder`1(int capacity);
    public PipeBuilder`1(IFilter`1[] filters);
    public sealed virtual void AddFilter(IFilter`1<TContext> filter);
    public IPipe`1<TContext> Build();
}
public class GreenPipes.Caching.CacheSettings : object {
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinAge>k__BackingField;
    [CompilerGeneratedAttribute]
private CurrentTimeProvider <NowProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeSlots>k__BackingField;
    public int Capacity { get; public set; }
    public TimeSpan MaxAge { get; public set; }
    public TimeSpan MinAge { get; public set; }
    public CurrentTimeProvider NowProvider { get; public set; }
    public int BucketCount { get; public set; }
    public int TimeSlots { get; public set; }
    public CacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge, CurrentTimeProvider nowProvider);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    [CompilerGeneratedAttribute]
public void set_Capacity(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MinAge();
    [CompilerGeneratedAttribute]
public void set_MinAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public CurrentTimeProvider get_NowProvider();
    [CompilerGeneratedAttribute]
public void set_NowProvider(CurrentTimeProvider value);
    [CompilerGeneratedAttribute]
public int get_BucketCount();
    [CompilerGeneratedAttribute]
public void set_BucketCount(int value);
    [CompilerGeneratedAttribute]
public int get_TimeSlots();
    [CompilerGeneratedAttribute]
public void set_TimeSlots(int value);
    private static DateTime CurrentTime();
}
public class GreenPipes.Caching.CurrentTimeProvider : MulticastDelegate {
    public CurrentTimeProvider(object object, IntPtr method);
    public virtual DateTime Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
public class GreenPipes.Caching.GreenCache`1 : object {
    private IDictionary`2<string, ICacheIndex`1<TValue>> _indices;
    private INodeTracker`1<TValue> _nodeTracker;
    public CacheStatistics Statistics { get; }
    public GreenCache`1(CacheSettings settings);
    public CacheStatistics get_Statistics();
    public sealed virtual IIndex`2<TKey, TValue> AddIndex(string name, KeyProvider`2<TKey, TValue> keyProvider, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public sealed virtual IIndex`2<TKey, TValue> GetIndex(string name);
    public sealed virtual void Add(TValue value);
    public sealed virtual void Clear();
    public sealed virtual IEnumerable`1<Task`1<TValue>> GetAll();
    public sealed virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
}
public interface GreenPipes.Caching.ICache`1 {
    public abstract virtual IIndex`2<TKey, TValue> AddIndex(string name, KeyProvider`2<TKey, TValue> keyProvider, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public abstract virtual IIndex`2<TKey, TValue> GetIndex(string name);
    public abstract virtual void Add(TValue value);
    public abstract virtual IEnumerable`1<Task`1<TValue>> GetAll();
    public abstract virtual void Clear();
}
public interface GreenPipes.Caching.ICacheValueObserver`1 {
    public abstract virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public abstract virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public abstract virtual void CacheCleared();
}
public interface GreenPipes.Caching.IConnectCacheValueObserver`1 {
    public abstract virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
}
public interface GreenPipes.Caching.IIndex`2 {
    public abstract virtual Task`1<TValue> Get(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public abstract virtual bool Remove(TKey key);
}
public interface GreenPipes.Caching.INode`1 {
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual bool get_HasValue();
    public abstract virtual bool get_IsValid();
    public abstract virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
}
public interface GreenPipes.Caching.INotifyValueUsed {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Used(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Used(Action value);
}
public class GreenPipes.Caching.Internals.Bucket`1 : object {
    private INodeTracker`1<TValue> _tracker;
    private int _count;
    private IBucketNode`1<TValue> _head;
    private DateTime _startTime;
    private Nullable`1<DateTime> _stopTime;
    public IBucketNode`1<TValue> Head { get; }
    public int Count { get; }
    public Bucket`1(INodeTracker`1<TValue> tracker);
    public IBucketNode`1<TValue> get_Head();
    public int get_Count();
    public bool HasExpired(DateTime expirationTime);
    public bool IsOldEnough(DateTime agedTime);
    public void Clear();
    public void Stop(DateTime now);
    public void Start(DateTime now);
    public void Push(IBucketNode`1<TValue> node);
    public void Used(IBucketNode`1<TValue> node);
}
[DefaultMemberAttribute("Item")]
public class GreenPipes.Caching.Internals.BucketCollection`1 : object {
    private Bucket`1[] _buckets;
    public Bucket`1<TValue> Item { get; }
    public int Count { get; }
    public BucketCollection`1(INodeTracker`1<TValue> nodeTracker, int capacity);
    public Bucket`1<TValue> get_Item(int index);
    public int get_Count();
    public void Empty();
}
public class GreenPipes.Caching.Internals.BucketNode`1 : object {
    private Bucket`1<TValue> _bucket;
    private IBucketNode`1<TValue> _next;
    private Task`1<TValue> _value;
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public Bucket`1<TValue> Bucket { get; }
    public IBucketNode`1<TValue> Next { get; }
    public BucketNode`1(TValue value);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsValid();
    public sealed virtual Bucket`1<TValue> get_Bucket();
    public sealed virtual IBucketNode`1<TValue> get_Next();
    public sealed virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
    public sealed virtual void SetBucket(Bucket`1<TValue> bucket, IBucketNode`1<TValue> next);
    public sealed virtual void AssignToBucket(Bucket`1<TValue> bucket);
    public sealed virtual void Evict();
    public sealed virtual IBucketNode`1<TValue> Pop();
    private void Used();
}
public class GreenPipes.Caching.Internals.CacheStatistics : object {
    private int _count;
    private int _createFaults;
    private long _hits;
    private long _misses;
    private int _totalCount;
    [CompilerGeneratedAttribute]
private TimeSpan <ValidityCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinAge>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BucketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldestBucketIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentBucketIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public TimeSpan ValidityCheckInterval { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinAge { get; }
    public int BucketSize { get; }
    public int BucketCount { get; }
    public int OldestBucketIndex { get; private set; }
    public int CurrentBucketIndex { get; private set; }
    public int Capacity { get; }
    public int Count { get; }
    public int TotalCount { get; }
    public long Misses { get; }
    public long Hits { get; }
    public int CreateFaults { get; }
    public CacheStatistics(int capacity, int bucketCount, int bucketSize, TimeSpan minAge, TimeSpan maxAge, TimeSpan validityCheckInterval);
    [CompilerGeneratedAttribute]
public TimeSpan get_ValidityCheckInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public TimeSpan get_MinAge();
    [CompilerGeneratedAttribute]
public int get_BucketSize();
    [CompilerGeneratedAttribute]
public int get_BucketCount();
    [CompilerGeneratedAttribute]
public int get_OldestBucketIndex();
    [CompilerGeneratedAttribute]
private void set_OldestBucketIndex(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentBucketIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentBucketIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public int get_Count();
    public int get_TotalCount();
    public long get_Misses();
    public long get_Hits();
    public int get_CreateFaults();
    public void Reset();
    internal void ValueAdded();
    internal void ValueRemoved();
    internal void Miss();
    internal void Hit();
    public virtual string ToString();
    internal void SetBucketIndices(int oldestBucketIndex, int currentBucketIndex);
    public void CreateFaulted();
}
internal class GreenPipes.Caching.Internals.CacheValueObservable`1 : object {
    private Dictionary`2<long, ICacheValueObserver`1<TValue>> _connections;
    private ICacheValueObserver`1[] _connected;
    private long _nextId;
    public sealed virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public sealed virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public sealed virtual void CacheCleared();
    public ConnectHandle Connect(ICacheValueObserver`1<TValue> connection);
    public void ForEach(Action`1<ICacheValueObserver`1<TValue>> callback);
    private void Disconnect(long id);
}
public class GreenPipes.Caching.Internals.FactoryNode`1 : object {
    private INodeValueFactory`1<TValue> _nodeValueFactory;
    public Task`1<TValue> Value { get; }
    public bool HasValue { get; }
    public bool IsValid { get; }
    public FactoryNode`1(INodeValueFactory`1<TValue> nodeValueFactory);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual bool get_HasValue();
    public sealed virtual bool get_IsValid();
    public sealed virtual Task`1<TValue> GetValue(IPendingValue`1<TValue> pendingValue);
}
public interface GreenPipes.Caching.Internals.IBucketNode`1 {
    public Bucket`1<TValue> Bucket { get; }
    public IBucketNode`1<TValue> Next { get; }
    public abstract virtual Bucket`1<TValue> get_Bucket();
    public abstract virtual IBucketNode`1<TValue> get_Next();
    public abstract virtual void SetBucket(Bucket`1<TValue> bucket, IBucketNode`1<TValue> next);
    public abstract virtual void AssignToBucket(Bucket`1<TValue> bucket);
    public abstract virtual void Evict();
    public abstract virtual IBucketNode`1<TValue> Pop();
}
public interface GreenPipes.Caching.Internals.ICacheIndex`1 {
    public Type KeyType { get; }
    public abstract virtual Type get_KeyType();
    public abstract virtual void Clear();
    public abstract virtual Task`1<bool> Add(INode`1<TValue> node);
    public abstract virtual bool TryGetExistingNode(TValue value, INode`1& node);
}
public class GreenPipes.Caching.Internals.Index`2 : object {
    private KeyProvider`2<TKey, TValue> _keyProvider;
    private object _lock;
    private INodeTracker`1<TValue> _nodeTracker;
    private Dictionary`2<TKey, WeakReference`1<INode`1<TValue>>> _index;
    private Type GreenPipes.Caching.Internals.ICacheIndex<TValue>.KeyType { get; }
    public Index`2(INodeTracker`1<TValue> nodeTracker, KeyProvider`2<TKey, TValue> keyProvider);
    private sealed virtual override Type GreenPipes.Caching.Internals.ICacheIndex<TValue>.get_KeyType();
    public sealed virtual void Clear();
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.Index`2/<Add>d__8")]
public sealed virtual Task`1<bool> Add(INode`1<TValue> node);
    public sealed virtual bool TryGetExistingNode(TValue value, INode`1& node);
    public sealed virtual void ValueAdded(INode`1<TValue> node, TValue value);
    public sealed virtual void ValueRemoved(INode`1<TValue> node, TValue value);
    public sealed virtual void CacheCleared();
    public sealed virtual Task`1<TValue> Get(TKey key, MissingValueFactory`2<TKey, TValue> missingValueFactory);
    public sealed virtual bool Remove(TKey key);
    private bool TryGetExistingNode(TKey key, INode`1& existingNode);
    private void Rebuild();
    [CompilerGeneratedAttribute]
private TKey <Rebuild>b__16_0(INode`1<TValue> node);
}
public interface GreenPipes.Caching.Internals.INodeTracker`1 {
    public CacheStatistics Statistics { get; }
    public abstract virtual CacheStatistics get_Statistics();
    public abstract virtual void Add(INodeValueFactory`1<TValue> nodeValueFactory);
    public abstract virtual void Add(TValue value);
    public abstract virtual void Rebucket(IBucketNode`1<TValue> node);
    public abstract virtual void Remove(INode`1<TValue> existingNode);
    public abstract virtual IEnumerable`1<INode`1<TValue>> GetAll();
    public abstract virtual void Clear();
}
public interface GreenPipes.Caching.Internals.INodeValueFactory`1 {
    public Task`1<TValue> Value { get; }
    public abstract virtual Task`1<TValue> get_Value();
    public abstract virtual void Add(IPendingValue`1<TValue> pendingValue);
    public abstract virtual Task`1<TValue> CreateValue();
}
public class GreenPipes.Caching.Internals.NodeTracker`1 : object {
    private static double MaxAgeUpperLimit;
    private int _bucketCount;
    private int _bucketSize;
    private object _lock;
    private TimeSpan _maxAge;
    private TimeSpan _minAge;
    private CurrentTimeProvider _nowProvider;
    private CacheValueObservable`1<TValue> _observers;
    private TimeSpan _validityCheckInterval;
    private BucketCollection`1<TValue> _buckets;
    private DateTime _cacheResetTime;
    private bool _cleanupScheduled;
    private Bucket`1<TValue> _currentBucket;
    private int _currentBucketIndex;
    private DateTime _nextValidityCheck;
    private int _oldestBucketIndex;
    [CompilerGeneratedAttribute]
private CacheStatistics <Statistics>k__BackingField;
    private int OldestBucketIndex { get; private set; }
    private int CurrentBucketIndex { get; private set; }
    private bool AreLowOnBuckets { get; }
    private bool IsCurrentBucketOldest { get; }
    public CacheStatistics Statistics { get; }
    public NodeTracker`1(CacheSettings settings);
    private int get_OldestBucketIndex();
    private void set_OldestBucketIndex(int value);
    private int get_CurrentBucketIndex();
    private void set_CurrentBucketIndex(int value);
    private bool get_AreLowOnBuckets();
    private bool get_IsCurrentBucketOldest();
    [CompilerGeneratedAttribute]
public sealed virtual CacheStatistics get_Statistics();
    public sealed virtual void Add(INodeValueFactory`1<TValue> nodeValueFactory);
    public sealed virtual void Add(TValue value);
    public sealed virtual void Remove(INode`1<TValue> node);
    [IteratorStateMachineAttribute("GreenPipes.Caching.Internals.NodeTracker`1/<GetAll>d__33")]
public sealed virtual IEnumerable`1<INode`1<TValue>> GetAll();
    public sealed virtual void Clear();
    public sealed virtual void Rebucket(IBucketNode`1<TValue> node);
    public sealed virtual ConnectHandle Connect(ICacheValueObserver`1<TValue> observer);
    private bool IsCleanupRequired(DateTime now);
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.NodeTracker`1/<AddNode>d__38")]
private Task AddNode(INodeValueFactory`1<TValue> nodeValueFactory);
    private void AddValue(TValue value);
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.NodeTracker`1/<RemoveNode>d__40")]
private Task RemoveNode(INode`1<TValue> node);
    private void OpenBucket(int index);
    private void CheckCacheStatus();
    private void Cleanup(DateTime now);
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.NodeTracker`1/<EvictNode>d__44")]
private Task EvictNode(IBucketNode`1<TValue> node);
}
public class GreenPipes.Caching.Internals.NodeValueFactory`1 : object {
    private BlockingCollection`1<IPendingValue`1<TValue>> _pendingCollection;
    private int _timeout;
    private TaskCompletionSource`1<TValue> _value;
    public Task`1<TValue> Value { get; }
    public NodeValueFactory`1(IPendingValue`1<TValue> initialPendingValue, int timeoutInMilliseconds);
    public sealed virtual Task`1<TValue> get_Value();
    public sealed virtual void Add(IPendingValue`1<TValue> pendingValue);
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.NodeValueFactory`1/<CreateValue>d__7")]
public sealed virtual Task`1<TValue> CreateValue();
    private void CompletePendingValues();
}
public class GreenPipes.Caching.Internals.PendingValue`2 : object {
    private MissingValueFactory`2<TKey, TValue> _factory;
    private TKey _key;
    private TaskCompletionSource`1<TValue> _source;
    public Task`1<TValue> Value { get; }
    public PendingValue`2(TKey key, MissingValueFactory`2<TKey, TValue> factory);
    public Task`1<TValue> get_Value();
    [AsyncStateMachineAttribute("GreenPipes.Caching.Internals.PendingValue`2/<CreateValue>d__6")]
public sealed virtual Task`1<TValue> CreateValue();
    public sealed virtual void SetValue(Task`1<TValue> value);
    private static Task`1<TValue> DefaultMissingValueFactory(TKey key);
}
public interface GreenPipes.Caching.IPendingValue`1 {
    public abstract virtual void SetValue(Task`1<TValue> value);
    public abstract virtual Task`1<TValue> CreateValue();
}
public class GreenPipes.Caching.KeyProvider`2 : MulticastDelegate {
    public KeyProvider`2(object object, IntPtr method);
    public virtual TKey Invoke(TValue value);
    public virtual IAsyncResult BeginInvoke(TValue value, AsyncCallback callback, object object);
    public virtual TKey EndInvoke(IAsyncResult result);
}
public class GreenPipes.Caching.MissingValueFactory`2 : MulticastDelegate {
    public MissingValueFactory`2(object object, IntPtr method);
    public virtual Task`1<TValue> Invoke(TKey key);
    public virtual IAsyncResult BeginInvoke(TKey key, AsyncCallback callback, object object);
    public virtual Task`1<TValue> EndInvoke(IAsyncResult result);
}
public class GreenPipes.Caching.TestCacheSettings : CacheSettings {
    private TestTimeProvider _provider;
    public DateTime CurrentTime { get; public set; }
    public TestCacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge);
    private TestCacheSettings(int capacity, Nullable`1<TimeSpan> minAge, Nullable`1<TimeSpan> maxAge, TestTimeProvider provider);
    public DateTime get_CurrentTime();
    public void set_CurrentTime(DateTime value);
}
[ExtensionAttribute]
public static class GreenPipes.CircuitBreakerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseCircuitBreaker(IPipeConfigurator`1<T> configurator, Action`1<ICircuitBreakerConfigurator`1<T>> configure);
}
[ExtensionAttribute]
public static class GreenPipes.CommandExtensions : object {
    [ExtensionAttribute]
public static Task SendCommand(IPipe`1<CommandContext> pipe, T command);
}
[ExtensionAttribute]
public static class GreenPipes.ConcurrencyLimitConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseConcurrencyLimit(IPipeConfigurator`1<T> configurator, int concurrencyLimit, IPipeRouter router);
}
[ExtensionAttribute]
public static class GreenPipes.ConcurrencyLimitExtensions : object {
    [ExtensionAttribute]
public static Task SetConcurrencyLimit(IPipe`1<CommandContext> pipe, int concurrencyLimit);
}
public class GreenPipes.Configurators.BindConfigurator`1 : object {
    private IPipeConfigurator`1<TLeft> _configurator;
    public BindConfigurator`1(IPipeConfigurator`1<TLeft> configurator);
    private sealed virtual override void GreenPipes.Configurators.IBindConfigurator<TLeft>.Source(IPipeContextSource`2<T, TLeft> source, Action`1<IBindConfigurator`2<TLeft, T>> configureTarget);
}
public interface GreenPipes.Configurators.IBindConfigurator`1 {
    public abstract virtual void Source(IPipeContextSource`2<T, TLeft> source, Action`1<IBindConfigurator`2<TLeft, T>> configureTarget);
}
public interface GreenPipes.Configurators.IBindConfigurator`2 {
    public IPipeConfigurator`1<TLeft> ContextPipe { get; }
    public abstract virtual IPipeConfigurator`1<TLeft> get_ContextPipe();
}
public interface GreenPipes.Configurators.ICircuitBreakerConfigurator`1 {
    unknown TimeSpan TrackingPeriod {public set; }
    unknown int TripThreshold {public set; }
    unknown int ActiveThreshold {public set; }
    unknown TimeSpan ResetInterval {public set; }
    unknown IPipeRouter Router {public set; }
    public abstract virtual void set_TrackingPeriod(TimeSpan value);
    public abstract virtual void set_TripThreshold(int value);
    public abstract virtual void set_ActiveThreshold(int value);
    public abstract virtual void set_ResetInterval(TimeSpan value);
    public abstract virtual void set_Router(IPipeRouter value);
}
public interface GreenPipes.Configurators.IDispatchConfigurator`1 {
    public abstract virtual void Pipe(Action`1<IPipeConfigurator`1<T>> configurePipe);
}
public interface GreenPipes.Configurators.IExceptionConfigurator {
    public abstract virtual void Handle(Type[] exceptionTypes);
    public abstract virtual void Handle();
    public abstract virtual void Handle(Func`2<T, bool> filter);
    public abstract virtual void Ignore(Type[] exceptionTypes);
    public abstract virtual void Ignore();
    public abstract virtual void Ignore(Func`2<T, bool> filter);
}
public interface GreenPipes.Configurators.IRequestConfigurator {
    public abstract virtual IRequestPipe`1<TRequest> Request(Func`2[] configure);
    public abstract virtual IRequestPipe`2<TRequest, TResult> Request(Action`1<IResultConfigurator`2<TRequest, TResult>> configureRequest);
}
public interface GreenPipes.Configurators.IRequestConfigurator`1 {
    public abstract virtual IRequestPipe`1<TRequest> Result(Action`1<IRequestConfigurator`2<TRequest, TResult>> configure);
}
public interface GreenPipes.Configurators.IRequestConfigurator`2 {
}
public interface GreenPipes.Configurators.IRescueConfigurator`2 {
    public IPipeConfigurator`1<TContext> ContextPipe { get; }
    public abstract virtual IPipeConfigurator`1<TContext> get_ContextPipe();
}
public interface GreenPipes.Configurators.IResultConfigurator`2 {
}
public interface GreenPipes.Configurators.IRetryConfigurator {
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetRetryPolicy(RetryPolicyFactory factory);
}
public class GreenPipes.Configurators.PipeConfigurator`1 : object {
    private List`1<IPipeSpecification`1<TContext>> _specifications;
    private sealed virtual override IEnumerable`1<ValidationResult> GreenPipes.ISpecification.Validate();
    private sealed virtual override void GreenPipes.IPipeConfigurator<TContext>.AddPipeSpecification(IPipeSpecification`1<TContext> specification);
    public sealed virtual IPipe`1<TContext> Build();
}
public class GreenPipes.Configurators.RequestConfigurator : object {
    private IPipe`1<RequestContext> _pipe;
    public RequestConfigurator(IPipe`1<RequestContext> pipe);
    public sealed virtual IRequestPipe`1<TRequest> Request(Func`2[] configure);
    public sealed virtual IRequestPipe`2<TRequest, TResult> Request(Action`1<IResultConfigurator`2<TRequest, TResult>> configureRequest);
}
public class GreenPipes.Configurators.RequestConfigurator`1 : object {
    private IPipe`1<RequestContext> _pipe;
    private IBuildPipeConfigurator`1<ResultContext> _resultPipeConfigurator;
    private DynamicRouter`1<ResultContext> _router;
    public RequestConfigurator`1(IPipe`1<RequestContext> pipe);
    private sealed virtual override IRequestPipe`1<TRequest> GreenPipes.Configurators.IRequestConfigurator<TRequest>.Result(Action`1<IRequestConfigurator`2<TRequest, TResult>> configure);
    private sealed virtual override void GreenPipes.IPipeConfigurator<GreenPipes.ResultContext>.AddPipeSpecification(IPipeSpecification`1<ResultContext> specification);
    public IRequestPipe`1<TRequest> Build();
}
public class GreenPipes.Configurators.RequestConfigurator`2 : object {
    private IPipe`1<RequestContext> _pipe;
    private IBuildPipeConfigurator`1<ResultContext`2<TRequest, TResult>> _pipeConfigurator;
    public RequestConfigurator`2(IPipe`1<RequestContext> pipe);
    public sealed virtual IRequestPipe`1<TRequest> Build(IPipe`1<ResultContext> resultPipe);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void Connect(IPipeConnector connector);
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ResultContext`2<TRequest, TResult>> specification);
}
public class GreenPipes.Configurators.ResultConfigurator`2 : object {
    private IPipe`1<RequestContext> _pipe;
    private IBuildPipeConfigurator`1<ResultContext`2<TRequest, TResult>> _pipeConfigurator;
    public ResultConfigurator`2(IPipe`1<RequestContext> pipe);
    private sealed virtual override IPipe`1<ResultContext`2<TRequest, TResult>> GreenPipes.Builders.IBuildPipeConfigurator<GreenPipes.ResultContext<TRequest,TResult>>.Build();
    public sealed virtual IRequestPipe`2<TRequest, TResult> Build();
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<ResultContext`2<TRequest, TResult>> specification);
}
public class GreenPipes.Configurators.RetryPolicyFactory : MulticastDelegate {
    public RetryPolicyFactory(object object, IntPtr method);
    public virtual IRetryPolicy Invoke(IExceptionFilter filter);
    public virtual IAsyncResult BeginInvoke(IExceptionFilter filter, AsyncCallback callback, object object);
    public virtual IRetryPolicy EndInvoke(IAsyncResult result);
}
public interface GreenPipes.ConnectHandle {
    public abstract virtual void Disconnect();
}
[ExtensionAttribute]
public static class GreenPipes.ContextAgentExtensions : object {
    [ExtensionAttribute]
public static Task Stop(IAgent agent, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Stop(IAgent agent, string reason, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class GreenPipes.ContextFilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseContextFilter(IPipeConfigurator`1<T> configurator, Func`2<T, Task`1<bool>> filter);
}
public class GreenPipes.Contexts.AsyncPipeContextHandle`1 : object {
    private TaskCompletionSource`1<TContext> _context;
    private TaskCompletionSource`1<DateTime> _inactive;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    private Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.Context { get; }
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    private sealed virtual override Task`1<TContext> GreenPipes.PipeContextHandle<TContext>.get_Context();
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.Created(TContext context);
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.CreateCanceled();
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.CreateFaulted(Exception exception);
    private sealed virtual override Task GreenPipes.IAsyncPipeContextHandle<TContext>.Faulted(Exception exception);
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
}
public class GreenPipes.Contexts.BindContextProxy`2 : object {
    private TLeft _left;
    private TRight _right;
    private TLeft GreenPipes.BindContext<TLeft,TRight>.Left { get; }
    private TRight GreenPipes.BindContext<TLeft,TRight>.Right { get; }
    private CancellationToken GreenPipes.PipeContext.CancellationToken { get; }
    public BindContextProxy`2(TLeft left, TRight source);
    private sealed virtual override TLeft GreenPipes.BindContext<TLeft,TRight>.get_Left();
    private sealed virtual override TRight GreenPipes.BindContext<TLeft,TRight>.get_Right();
    private sealed virtual override CancellationToken GreenPipes.PipeContext.get_CancellationToken();
    private sealed virtual override bool GreenPipes.PipeContext.HasPayloadType(Type payloadType);
    private sealed virtual override bool GreenPipes.PipeContext.TryGetPayload(T& payload);
    private sealed virtual override T GreenPipes.PipeContext.GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    private sealed virtual override T GreenPipes.PipeContext.AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public class GreenPipes.Contexts.ConstantPipeContextHandle`1 : object {
    private TContext _context;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Task`1<TContext> <Context>k__BackingField;
    private bool GreenPipes.PipeContextHandle<TContext>.IsDisposed { get; }
    public Task`1<TContext> Context { get; }
    public ConstantPipeContextHandle`1(TContext context);
    [AsyncStateMachineAttribute("GreenPipes.Contexts.ConstantPipeContextHandle`1/<System-IAsyncDisposable-DisposeAsync>d__3")]
private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private sealed virtual override bool GreenPipes.PipeContextHandle<TContext>.get_IsDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<TContext> get_Context();
}
public class GreenPipes.Contexts.MultipleResultRequestContext`1 : BasePipeContext {
    private IPipe`1<ResultContext> _resultPipe;
    private TaskCompletionSource`1<Task`1<ResultContext>> _resultTask;
    [CompilerGeneratedAttribute]
private TRequest <Request>k__BackingField;
    public Task`1<ResultContext> Result { get; }
    public TRequest Request { get; }
    public bool IsCompleted { get; }
    public MultipleResultRequestContext`1(TRequest request, IPipe`1<ResultContext> resultPipe);
    public Task`1<ResultContext> get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual TRequest get_Request();
    public sealed virtual bool TrySetResult(T result);
    public sealed virtual bool TrySetException(Exception exception);
    public sealed virtual bool TrySetCanceled();
    public sealed virtual bool get_IsCompleted();
    [AsyncStateMachineAttribute("GreenPipes.Contexts.MultipleResultRequestContext`1/<GetResult>d__13")]
private Task`1<ResultContext> GetResult();
}
public class GreenPipes.Contexts.PipeContextConverterFactory : object {
    private sealed virtual override IPipeContextConverter`2<PipeContext, TOutput> GreenPipes.Filters.IPipeContextConverterFactory<GreenPipes.PipeContext>.GetConverter();
}
public class GreenPipes.Contexts.PipeResultContext`2 : BasePipeContext {
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private TRequest <Request>k__BackingField;
    public TResult Result { get; }
    public TRequest Request { get; }
    public PipeResultContext`2(TRequest request, TResult result);
    [CompilerGeneratedAttribute]
public sealed virtual TResult get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual TRequest get_Request();
    private sealed virtual override T GreenPipes.ResultContext.GetResult();
    private sealed virtual override bool GreenPipes.ResultContext.TryGetResult(T& result);
}
public class GreenPipes.Contexts.RequestConverterFactory : object {
    private sealed virtual override IPipeContextConverter`2<PipeContext, TOutput> GreenPipes.Filters.IPipeContextConverterFactory<GreenPipes.PipeContext>.GetConverter();
}
public class GreenPipes.Contexts.ResultConverterFactory : object {
    private sealed virtual override IPipeContextConverter`2<ResultContext, TOutput> GreenPipes.Filters.IPipeContextConverterFactory<GreenPipes.ResultContext>.GetConverter();
}
public class GreenPipes.Contexts.SingleResultRequestContext`2 : BasePipeContext {
    private IPipe`1<ResultContext`2<TRequest, TResult>> _resultPipe;
    private TaskCompletionSource`1<Task`1<ResultContext`1<TResult>>> _resultTask;
    [CompilerGeneratedAttribute]
private TRequest <Request>k__BackingField;
    public Task`1<ResultContext`1<TResult>> Result { get; }
    public TRequest Request { get; }
    public bool IsCompleted { get; }
    public SingleResultRequestContext`2(TRequest request, IPipe`1<ResultContext`2<TRequest, TResult>> resultPipe);
    public Task`1<ResultContext`1<TResult>> get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual TRequest get_Request();
    private sealed virtual override bool GreenPipes.RequestContext.TrySetResult(T result);
    public sealed virtual bool TrySetException(Exception exception);
    public sealed virtual bool TrySetCanceled();
    public sealed virtual bool get_IsCompleted();
    [AsyncStateMachineAttribute("GreenPipes.Contexts.SingleResultRequestContext`2/<GetResultContext>d__13")]
private Task`1<ResultContext`1<TResult>> GetResultContext();
    private bool SetResult(TResult result);
}
public interface GreenPipes.Contracts.CircuitBreakerClosed {
}
public interface GreenPipes.Contracts.CircuitBreakerOpened {
    public Exception Exception { get; }
    public abstract virtual Exception get_Exception();
}
public interface GreenPipes.Contracts.CommandContext {
    public DateTime Timestamp { get; }
    public abstract virtual DateTime get_Timestamp();
}
public interface GreenPipes.Contracts.CommandContext`1 {
    public T Command { get; }
    public abstract virtual T get_Command();
}
public interface GreenPipes.Contracts.EventContext {
    public DateTime Timestamp { get; }
    public abstract virtual DateTime get_Timestamp();
}
public interface GreenPipes.Contracts.EventContext`1 {
    public T Event { get; }
    public abstract virtual T get_Event();
}
public interface GreenPipes.Contracts.ProfileData {
    public long Id { get; }
    public DateTime Timestamp { get; }
    public TimeSpan Elapsed { get; }
    public abstract virtual long get_Id();
    public abstract virtual DateTime get_Timestamp();
    public abstract virtual TimeSpan get_Elapsed();
}
public interface GreenPipes.Contracts.ProfileData`1 {
    public T Context { get; }
    public abstract virtual T get_Context();
}
public interface GreenPipes.Contracts.SetConcurrencyLimit {
    public int ConcurrencyLimit { get; }
    public abstract virtual int get_ConcurrencyLimit();
}
public interface GreenPipes.Contracts.SetRateLimit {
    public int RateLimit { get; }
    public abstract virtual int get_RateLimit();
}
[ExtensionAttribute]
public static class GreenPipes.DelegateConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseExecute(IPipeConfigurator`1<TContext> configurator, Action`1<TContext> callback);
    [ExtensionAttribute]
public static void UseExecuteAsync(IPipeConfigurator`1<TContext> configurator, Func`2<TContext, Task> callback);
}
[ExtensionAttribute]
public static class GreenPipes.DispatchConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseDispatch(IPipeConfigurator`1<T> configurator, IPipeContextConverterFactory`1<T> pipeContextProviderFactory, Action`1<IDispatchConfigurator`1<T>> configure);
}
public class GreenPipes.DuplicateKeyPipeConfigurationException : PipeConfigurationException {
    public DuplicateKeyPipeConfigurationException(string message);
    public DuplicateKeyPipeConfigurationException(string message, Exception innerException);
    protected DuplicateKeyPipeConfigurationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class GreenPipes.EventExtensions : object {
    [ExtensionAttribute]
public static Task PublishEvent(IPipe`1<EventContext> pipe, T message);
}
[ExtensionAttribute]
public static class GreenPipes.FilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseFilter(IPipeConfigurator`1<T> configurator, IFilter`1<T> filter);
    [ExtensionAttribute]
public static void UseFilters(IPipeConfigurator`1<T> configurator, IEnumerable`1<IFilter`1<T>> filters);
    [ExtensionAttribute]
public static void UseFilters(IPipeConfigurator`1<T> configurator, IFilter`1[] filters);
    [ExtensionAttribute]
public static void UseFilter(IPipeConfigurator`1<TContext> configurator, IFilter`1<TFilter> filter, MergeFilterContextProvider`2<TContext, TFilter> contextProvider, FilterContextProvider`2<TFilter, TContext> inputContextProvider);
}
public class GreenPipes.FilterContextProvider`2 : MulticastDelegate {
    public FilterContextProvider`2(object object, IntPtr method);
    public virtual TInput Invoke(TSplit context);
    public virtual IAsyncResult BeginInvoke(TSplit context, AsyncCallback callback, object object);
    public virtual TInput EndInvoke(IAsyncResult result);
}
public class GreenPipes.Filters.AsyncDelegateFilter`1 : object {
    private Func`2<TContext, Task> _callback;
    public AsyncDelegateFilter`1(Func`2<TContext, Task> callback);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
[ExtensionAttribute]
public static class GreenPipes.Filters.CircuitBreaker.CircuitBreakerEventExtensions : object {
    [ExtensionAttribute]
public static Task PublishCircuitBreakerOpened(IPipe`1<EventContext> pipe, Exception exception);
    [ExtensionAttribute]
public static Task PublishCircuitBreakerClosed(IPipe`1<EventContext> pipe);
}
public interface GreenPipes.Filters.CircuitBreaker.CircuitBreakerSettings {
    public TimeSpan TrackingPeriod { get; }
    public IEnumerable`1<TimeSpan> ResetTimeout { get; }
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public IPipeRouter Router { get; }
    public abstract virtual TimeSpan get_TrackingPeriod();
    public abstract virtual IEnumerable`1<TimeSpan> get_ResetTimeout();
    public abstract virtual int get_TripThreshold();
    public abstract virtual int get_ActiveThreshold();
    public abstract virtual IPipeRouter get_Router();
}
internal class GreenPipes.Filters.CircuitBreaker.ClosedBehavior : object {
    private ICircuitBreaker _breaker;
    private Timer _timer;
    private int _attemptCount;
    private int _failureCount;
    private int _successCount;
    private bool IsActive { get; }
    public ClosedBehavior(ICircuitBreaker breaker);
    private bool get_IsActive();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    [AsyncStateMachineAttribute("GreenPipes.Filters.CircuitBreaker.ClosedBehavior/<GreenPipes-Filters-CircuitBreaker-ICircuitBreakerBehavior-SendFault>d__10")]
private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private bool TripThresholdExceeded(int failureCount);
    private void Reset(object state);
}
internal class GreenPipes.Filters.CircuitBreaker.HalfOpenBehavior : object {
    private ICircuitBreaker _breaker;
    private Exception _exception;
    private IEnumerator`1<TimeSpan> _timeoutEnumerator;
    private int _attemptCount;
    private bool IsActive { get; }
    public HalfOpenBehavior(ICircuitBreaker breaker, Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private bool get_IsActive();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    [AsyncStateMachineAttribute("GreenPipes.Filters.CircuitBreaker.HalfOpenBehavior/<GreenPipes-Filters-CircuitBreaker-ICircuitBreakerBehavior-PostSend>d__8")]
private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public interface GreenPipes.Filters.CircuitBreaker.ICircuitBreaker {
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public TimeSpan OpenDuration { get; }
    public abstract virtual int get_TripThreshold();
    public abstract virtual int get_ActiveThreshold();
    public abstract virtual TimeSpan get_OpenDuration();
    public abstract virtual Task Open(Exception exception, ICircuitBreakerBehavior behavior, IEnumerator`1<TimeSpan> timeoutEnumerator);
    public abstract virtual Task ClosePartially(Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator, ICircuitBreakerBehavior behavior);
    public abstract virtual Task Close(ICircuitBreakerBehavior behavior);
}
public interface GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior {
    public abstract virtual Task PreSend();
    public abstract virtual Task PostSend();
    public abstract virtual Task SendFault(Exception exception);
}
internal class GreenPipes.Filters.CircuitBreaker.OpenBehavior : object {
    private ICircuitBreaker _breaker;
    private Stopwatch _elapsed;
    private Exception _exception;
    private IEnumerator`1<TimeSpan> _timeoutEnumerator;
    private Timer _timer;
    public OpenBehavior(ICircuitBreaker breaker, Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PreSend();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.PostSend();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreakerBehavior.SendFault(Exception exception);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private Timer GetTimer(IEnumerator`1<TimeSpan> timeoutEnumerator);
    private void PartiallyCloseCircuit(object state);
}
public class GreenPipes.Filters.CircuitBreakerFilter`1 : object {
    private IExceptionFilter _exceptionFilter;
    private CircuitBreakerSettings _settings;
    private ICircuitBreakerBehavior _behavior;
    public TimeSpan OpenDuration { get; }
    public int TripThreshold { get; }
    public int ActiveThreshold { get; }
    public CircuitBreakerFilter`1(CircuitBreakerSettings settings, IExceptionFilter exceptionFilter);
    public sealed virtual TimeSpan get_OpenDuration();
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.Open(Exception exception, ICircuitBreakerBehavior behavior, IEnumerator`1<TimeSpan> timeoutEnumerator);
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.Close(ICircuitBreakerBehavior behavior);
    private sealed virtual override Task GreenPipes.Filters.CircuitBreaker.ICircuitBreaker.ClosePartially(Exception exception, IEnumerator`1<TimeSpan> timeoutEnumerator, ICircuitBreakerBehavior behavior);
    public sealed virtual int get_TripThreshold();
    public sealed virtual int get_ActiveThreshold();
    [AsyncStateMachineAttribute("GreenPipes.Filters.CircuitBreakerFilter`1/<Send>d__13")]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public class GreenPipes.Filters.ConcurrencyLimitFilter`1 : Agent {
    private int _concurrencyLimit;
    private SemaphoreSlim _limit;
    public ConcurrencyLimitFilter`1(int concurrencyLimit);
    public sealed virtual void Dispose();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.ConcurrencyLimitFilter`1/<Send>d__5")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("GreenPipes.Filters.ConcurrencyLimitFilter`1/<Send>d__6")]
public sealed virtual Task Send(CommandContext`1<SetConcurrencyLimit> context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.ConcurrencyLimitFilter`1/<StopAgent>d__7")]
protected virtual Task StopAgent(StopContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class GreenPipes.Filters.ContextFilter`1 : object {
    private Func`2<TContext, Task`1<bool>> _filter;
    public ContextFilter`1(Func`2<TContext, Task`1<bool>> filter);
    public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual void Probe(ProbeContext context);
}
public class GreenPipes.Filters.DelegateFilter`1 : object {
    private Action`1<TContext> _callback;
    public DelegateFilter`1(Action`1<TContext> callback);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class GreenPipes.Filters.DynamicFilter`1 : object {
    private IPipe`1<TInput> _empty;
    private Dictionary`2<Type, IOutputFilter<TInput>> _outputPipes;
    protected IPipeContextConverterFactory`1<TInput> ConverterFactory;
    protected FilterObservable Observers;
    private IOutputFilter[] _outputPipeArray;
    public DynamicFilter`1(IPipeContextConverterFactory`1<TInput> converterFactory);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver observer);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TInput context, IPipe`1<TInput> next);
    protected TResult GetPipe();
    protected IOutputFilter<TInput> GetPipe();
    protected virtual IOutputFilter<TInput> CreateOutputPipe();
}
public class GreenPipes.Filters.DynamicFilter`2 : DynamicFilter`1<TInput> {
    private KeyAccessor`2<TInput, TKey> _keyAccessor;
    public DynamicFilter`2(IPipeContextConverterFactory`1<TInput> converterFactory, KeyAccessor`2<TInput, TKey> keyAccessor);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    protected virtual IOutputFilter<TInput> CreateOutputPipe();
}
public class GreenPipes.Filters.ForkFilter`1 : object {
    private IPipe`1<TContext> _pipe;
    public ForkFilter`1(IPipe`1<TContext> pipe);
    private sealed virtual override Task GreenPipes.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public interface GreenPipes.Filters.IDynamicFilter`1 {
}
public interface GreenPipes.Filters.IDynamicFilter`2 {
}
public interface GreenPipes.Filters.IInsertFilter`1 {
    public abstract virtual void Add(IFilter`1<T> filter);
    public abstract virtual void Insert(IFilter`1<T> filter);
}
public interface GreenPipes.Filters.ILatestFilter`1 {
    public Task`1<T> Latest { get; }
    public abstract virtual Task`1<T> get_Latest();
}
public class GreenPipes.Filters.InlineFilter`1 : object {
    private InlineFilterMethod`1<TContext> _filterMethod;
    public InlineFilter`1(InlineFilterMethod`1<TContext> filterMethod);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class GreenPipes.Filters.InterceptFilter`1 : object {
    private IPipe`1<TContext> _pipe;
    public InterceptFilter`1(IPipe`1<TContext> pipe);
    [AsyncStateMachineAttribute("GreenPipes.Filters.InterceptFilter`1/<GreenPipes-IFilter<TContext>-Send>d__2")]
private sealed virtual override Task GreenPipes.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public interface GreenPipes.Filters.IOutputPipeFilter`2 {
}
public interface GreenPipes.Filters.IOutputPipeFilter`3 {
}
public interface GreenPipes.Filters.IPipeContextConverter`2 {
    public abstract virtual bool TryConvert(TInput input, TOutput& output);
}
public interface GreenPipes.Filters.IPipeContextConverterFactory`1 {
    public abstract virtual IPipeContextConverter`2<TInput, TOutput> GetConverter();
}
public interface GreenPipes.Filters.ITeeFilter`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public interface GreenPipes.Filters.ITeeFilter`2 {
}
public class GreenPipes.Filters.KeyFilter`2 : object {
    private KeyAccessor`2<TContext, TKey> _keyAccessor;
    private ConcurrentDictionary`2<TKey, IPipe`1<TContext>> _pipes;
    public KeyFilter`2(KeyAccessor`2<TContext, TKey> keyAccessor);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.KeyFilter`2/<Send>d__4")]
[DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    private void RemovePipe(TKey key);
}
public class GreenPipes.Filters.LatestFilter`1 : object {
    private TaskCompletionSource`1<bool> _hasValue;
    private T _latest;
    private Task`1<T> GreenPipes.Filters.ILatestFilter<T>.Latest { get; }
    private sealed virtual override Task GreenPipes.IFilter<T>.Send(T context, IPipe`1<T> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task`1<T> GreenPipes.Filters.ILatestFilter<T>.get_Latest();
    [AsyncStateMachineAttribute("GreenPipes.Filters.LatestFilter`1/<GetLatest>d__7")]
private Task`1<T> GetLatest();
}
public class GreenPipes.Filters.OutputPipeFilter`2 : object {
    private IPipeContextConverter`2<TInput, TOutput> _contextConverter;
    private FilterObservable`1<TOutput> _observers;
    private FilterObservable _outerObservers;
    private ITeeFilter`1<TOutput> _output;
    public OutputPipeFilter`2(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, ITeeFilter`1<TOutput> outputFilter);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task GreenPipes.IFilter<TInput>.Send(TInput context, IPipe`1<TInput> next);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector<TOutput>.ConnectObserver(IFilterObserver`1<TOutput> observer);
    private sealed virtual override ConnectHandle GreenPipes.IPipeConnector<TOutput>.ConnectPipe(IPipe`1<TOutput> pipe);
    [AsyncStateMachineAttribute("GreenPipes.Filters.OutputPipeFilter`2/<SendToOutput>d__9")]
private Task SendToOutput(IPipe`1<TInput> next, TOutput pipeContext);
}
public class GreenPipes.Filters.OutputPipeFilter`3 : OutputPipeFilter`2<TInput, TOutput> {
    private ITeeFilter`2<TOutput, TKey> _outputFilter;
    public OutputPipeFilter`3(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, KeyAccessor`2<TInput, TKey> keyAccessor);
    protected OutputPipeFilter`3(IPipeContextConverter`2<TInput, TOutput> contextConverter, FilterObservable observers, ITeeFilter`2<TOutput, TKey> outputFilter);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
}
public class GreenPipes.Filters.PartitionFilter`1 : object {
    private IPartitioner`1<TContext> _partitioner;
    public PartitionFilter`1(PartitionKeyProvider`1<TContext> keyProvider, IPartitioner partitioner);
    private sealed virtual override Task GreenPipes.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public class GreenPipes.Filters.PipeContextSourceBindFilter`2 : object {
    private IPipe`1<BindContext`2<TLeft, TRight>> _output;
    private IPipeContextSource`2<TRight, TLeft> _source;
    public PipeContextSourceBindFilter`2(IPipe`1<BindContext`2<TLeft, TRight>> output, IPipeContextSource`2<TRight, TLeft> source);
    private sealed virtual override Task GreenPipes.IFilter<TLeft>.Send(TLeft context, IPipe`1<TLeft> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public class GreenPipes.Filters.RateLimitFilter`1 : object {
    private TimeSpan _interval;
    private SemaphoreSlim _limit;
    private Timer _timer;
    private int _count;
    private int _rateLimit;
    public RateLimitFilter`1(int rateLimit, TimeSpan interval);
    public sealed virtual void Dispose();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("GreenPipes.Filters.RateLimitFilter`1/<Send>d__9")]
public sealed virtual Task Send(CommandContext`1<SetRateLimit> context);
    private void Reset(object state);
}
public class GreenPipes.Filters.RepeatFilter`1 : object {
    private CancellationToken _cancellationToken;
    public RepeatFilter`1(CancellationToken cancellationToken);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.RepeatFilter`1/<Send>d__3")]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class GreenPipes.Filters.RescueContextFactory`2 : MulticastDelegate {
    public RescueContextFactory`2(object object, IntPtr method);
    public virtual TRescueContext Invoke(TContext context, Exception exception);
    public virtual IAsyncResult BeginInvoke(TContext context, Exception exception, AsyncCallback callback, object object);
    public virtual TRescueContext EndInvoke(IAsyncResult result);
}
public class GreenPipes.Filters.RescueFilter`2 : object {
    private IExceptionFilter _exceptionFilter;
    private RescueContextFactory`2<TContext, TRescueContext> _rescueContextFactory;
    private IPipe`1<TRescueContext> _rescuePipe;
    public RescueFilter`2(IPipe`1<TRescueContext> rescuePipe, IExceptionFilter exceptionFilter, RescueContextFactory`2<TContext, TRescueContext> rescueContextFactory);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.RescueFilter`2/<GreenPipes-IFilter<TContext>-Send>d__5")]
[DebuggerNonUserCodeAttribute]
private sealed virtual override Task GreenPipes.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
}
public class GreenPipes.Filters.RetryFilter`1 : object {
    private RetryObservable _observers;
    private IRetryPolicy _retryPolicy;
    public RetryFilter`1(IRetryPolicy retryPolicy, RetryObservable observers);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Filters.RetryFilter`1/<GreenPipes-IFilter<TContext>-Send>d__4")]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
private sealed virtual override Task GreenPipes.IFilter<TContext>.Send(TContext context, IPipe`1<TContext> next);
    [AsyncStateMachineAttribute("GreenPipes.Filters.RetryFilter`1/<Attempt>d__5")]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
private Task Attempt(TContext context, RetryContext`1<TContext> retryContext, IPipe`1<TContext> next);
}
public class GreenPipes.Filters.SplitFilter`2 : object {
    private MergeFilterContextProvider`2<TInput, TSplit> _contextProvider;
    private FilterContextProvider`2<TSplit, TInput> _inputContextProvider;
    private IFilter`1<TSplit> _split;
    public SplitFilter`2(IFilter`1<TSplit> split, MergeFilterContextProvider`2<TInput, TSplit> contextProvider, FilterContextProvider`2<TSplit, TInput> inputContextProvider);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TInput context, IPipe`1<TInput> next);
}
public class GreenPipes.Filters.TeeFilter`1 : object {
    private Connectable`1<IPipe`1<TContext>> _connections;
    public int Count { get; }
    public sealed virtual int get_Count();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerNonUserCodeAttribute]
public sealed virtual Task Send(TContext context, IPipe`1<TContext> next);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<TContext> pipe);
}
public class GreenPipes.Filters.TeeFilter`2 : TeeFilter`1<TContext> {
    private KeyAccessor`2<TContext, TKey> _keyAccessor;
    private Lazy`1<IKeyPipeConnector`1<TKey>> _keyConnections;
    public TeeFilter`2(KeyAccessor`2<TContext, TKey> keyAccessor);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    private IKeyPipeConnector`1<TKey> ConnectKeyFilter();
}
[ExtensionAttribute]
public static class GreenPipes.ForkConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseFork(IPipeConfigurator`1<T> configurator, IPipe`1<T> pipe);
}
public interface GreenPipes.IAsyncPipeContextHandle`1 {
    public abstract virtual Task Created(TContext context);
    public abstract virtual Task CreateCanceled();
    public abstract virtual Task CreateFaulted(Exception exception);
    public abstract virtual Task Faulted(Exception exception);
}
public interface GreenPipes.IDynamicRouter`1 {
}
public interface GreenPipes.IDynamicRouter`2 {
}
public interface GreenPipes.IExceptionFilter {
    public abstract virtual bool Match(Exception exception);
}
public interface GreenPipes.IFilter`1 {
    public abstract virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public interface GreenPipes.IFilterObserver {
    public abstract virtual Task PreSend(T context);
    public abstract virtual Task PostSend(T context);
    public abstract virtual Task SendFault(T context, Exception exception);
}
public interface GreenPipes.IFilterObserver`1 {
    public abstract virtual Task PreSend(TContext context);
    public abstract virtual Task PostSend(TContext context);
    public abstract virtual Task SendFault(TContext context, Exception exception);
}
public interface GreenPipes.IKeyPipeConnector`1 {
    public abstract virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
}
public interface GreenPipes.ILatestConfigurator`1 {
    unknown LatestFilterCreated`1<T> Created {public set; }
    public abstract virtual void set_Created(LatestFilterCreated`1<T> value);
}
[ExtensionAttribute]
public static class GreenPipes.InlineFilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInlineFilter(IPipeConfigurator`1<T> configurator, InlineFilterMethod`1<T> inlineFilterMethod);
}
public class GreenPipes.InlineFilterMethod`1 : MulticastDelegate {
    public InlineFilterMethod`1(object object, IntPtr method);
    public virtual Task Invoke(T context, IPipe`1<T> next);
    public virtual IAsyncResult BeginInvoke(T context, IPipe`1<T> next, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class GreenPipes.InterceptConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseIntercept(IPipeConfigurator`1<T> configurator, IPipe`1<T> pipe);
}
[ExtensionAttribute]
public static class GreenPipes.Internals.Extensions.ExpressionExtensions : object {
    [ExtensionAttribute]
public static string GetMemberName(Expression`1<Func`2<T, TMember>> expression);
    [ExtensionAttribute]
public static string GetMemberName(Expression`1<Action`1<T>> expression);
    [ExtensionAttribute]
public static string GetMemberName(Expression`1<Func`1<T>> expression);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TMember>> expression);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(Expression`1<Func`1<T>> expression);
    [ExtensionAttribute]
public static MemberInfo GetMemberInfo(Expression`1<Action`1<T>> expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(Expression`1<Func`2<T, TMember>> expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(Expression`1<Action`1<T>> expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(Expression`1<Func`1<T>> expression);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(Expression`1<Action`2<T1, T2>> expression);
    private static MemberExpression GetMemberExpression(Expression body);
}
[ExtensionAttribute]
public static class GreenPipes.Internals.Extensions.InterfaceExtensions : object {
    private static InterfaceReflectionCache _cache;
    private static InterfaceExtensions();
    [ExtensionAttribute]
public static bool HasInterface(Type type);
    [ExtensionAttribute]
public static bool HasInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static Type GetInterface(Type type);
    [ExtensionAttribute]
public static Type GetInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool ClosesType(Type type, Type openType);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetClosingArguments(Type type, Type openType);
}
public interface GreenPipes.Internals.Extensions.ITypeCache`1 {
    public string ShortName { get; }
    public IReadOnlyPropertyCache`1<T> ReadOnlyPropertyCache { get; }
    public IReadWritePropertyCache`1<T> ReadWritePropertyCache { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual IReadOnlyPropertyCache`1<T> get_ReadOnlyPropertyCache();
    public abstract virtual IReadWritePropertyCache`1<T> get_ReadWritePropertyCache();
    public abstract virtual T InitializeFromObject(object values);
}
[ExtensionAttribute]
public static class GreenPipes.Internals.Extensions.TaskExtensions : object {
    private static TimeSpan _defaultTimeout;
    private static TaskExtensions();
    [ExtensionAttribute]
public static Task TrySetResultOnThreadPool(TaskCompletionSource`1<T> source, T result);
    [ExtensionAttribute]
public static Task TrySetExceptionOnThreadPool(TaskCompletionSource`1<T> source, Exception exception);
    [ExtensionAttribute]
public static Task TrySetCanceledOnThreadPool(TaskCompletionSource`1<T> source);
    [ExtensionAttribute]
public static Task OrCanceled(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> OrCanceled(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task OrTimeout(Task task, int ms, int s, int m, int h, int d, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
public static Task OrTimeout(Task task, TimeSpan timeout, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
private static Task OrTimeoutInternal(Task task, TimeSpan timeout, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
public static Task`1<T> OrTimeout(Task`1<T> task, int ms, int s, int m, int h, int d, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
public static Task`1<T> OrTimeout(Task`1<T> task, TimeSpan timeout, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
private static Task`1<T> OrTimeoutInternal(Task`1<T> task, TimeSpan timeout, CancellationToken cancellationToken, string memberName, string filePath, Nullable`1<int> lineNumber);
    private static string FormatTimeoutMessage(string memberName, string filePath, Nullable`1<int> lineNumber);
    [ExtensionAttribute]
public static bool IsCompletedSuccessfully(Task task);
    [ExtensionAttribute]
public static void IgnoreUnobservedExceptions(Task task);
}
public static class GreenPipes.Internals.Extensions.TypeCache : object {
    internal static IDictionaryConverterCache DictionaryConverterCache;
    internal static IObjectConverterCache ObjectConverterCache;
    public static IImplementationBuilder ImplementationBuilder { get; }
    private static TypeCache();
    public static IImplementationBuilder get_ImplementationBuilder();
    private static CachedType GetOrAdd(Type type);
    public static string GetShortName(Type type);
    public static Type GetImplementationType(Type type);
}
public class GreenPipes.Internals.Extensions.TypeCache`1 : object {
    private Lazy`1<IObjectConverter> _converter;
    private Lazy`1<ReadOnlyPropertyCache`1<T>> _readPropertyCache;
    private string _shortName;
    private Lazy`1<ReadWritePropertyCache`1<T>> _writePropertyCache;
    public static IReadOnlyPropertyCache`1<T> ReadOnlyPropertyCache { get; }
    public static IReadWritePropertyCache`1<T> ReadWritePropertyCache { get; }
    public static string ShortName { get; }
    private IReadOnlyPropertyCache`1<T> GreenPipes.Internals.Extensions.ITypeCache<T>.ReadOnlyPropertyCache { get; }
    private IReadWritePropertyCache`1<T> GreenPipes.Internals.Extensions.ITypeCache<T>.ReadWritePropertyCache { get; }
    private string GreenPipes.Internals.Extensions.ITypeCache<T>.ShortName { get; }
    public static IReadOnlyPropertyCache`1<T> get_ReadOnlyPropertyCache();
    public static IReadWritePropertyCache`1<T> get_ReadWritePropertyCache();
    public static string get_ShortName();
    private sealed virtual override IReadOnlyPropertyCache`1<T> GreenPipes.Internals.Extensions.ITypeCache<T>.get_ReadOnlyPropertyCache();
    private sealed virtual override IReadWritePropertyCache`1<T> GreenPipes.Internals.Extensions.ITypeCache<T>.get_ReadWritePropertyCache();
    private sealed virtual override T GreenPipes.Internals.Extensions.ITypeCache<T>.InitializeFromObject(object values);
    private sealed virtual override string GreenPipes.Internals.Extensions.ITypeCache<T>.get_ShortName();
    public static T InitializeFromObject(object values);
}
[ExtensionAttribute]
public static class GreenPipes.Internals.Extensions.TypeExtensions : object {
    private static TypeNameFormatter _typeNameFormatter;
    private static TypeExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    [IteratorStateMachineAttribute("GreenPipes.Internals.Extensions.TypeExtensions/<GetAllProperties>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetAllProperties(TypeInfo typeInfo);
    [IteratorStateMachineAttribute("GreenPipes.Internals.Extensions.TypeExtensions/<GetAllStaticProperties>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetAllStaticProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetStaticProperties(Type type);
    [ExtensionAttribute]
public static bool IsConcrete(Type type);
    [ExtensionAttribute]
public static bool IsConcreteAndAssignableTo(Type type, Type assignableType);
    [ExtensionAttribute]
public static bool IsConcreteAndAssignableTo(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type, Type& underlyingType);
    [ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [ExtensionAttribute]
public static bool CanBeNull(Type type);
    [ExtensionAttribute]
public static string GetTypeName(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAttribute(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static bool IsAnonymousType(Type type);
    [ExtensionAttribute]
public static bool IsInNamespace(Type type, string nameSpace);
}
public class GreenPipes.Internals.Mapping.DictionaryConverterCache : object {
    private ConcurrentDictionary`2<Type, IDictionaryConverter> _cache;
    public sealed virtual IDictionaryConverter GetConverter(Type type);
    private IDictionaryConverter CreateMissingConverter(Type key);
}
public class GreenPipes.Internals.Mapping.DictionaryObjectValueProvider : object {
    private IDictionary`2<string, object> _dictionary;
    public DictionaryObjectValueProvider(IDictionary`2<string, object> dictionary);
    public sealed virtual bool TryGetValue(string name, Object& value);
    public sealed virtual bool TryGetValue(string name, T& value);
}
public class GreenPipes.Internals.Mapping.DynamicObjectConverter`2 : object {
    private IObjectConverterCache _cache;
    private IObjectMapper`1[] _converters;
    public DynamicObjectConverter`2(IObjectConverterCache cache);
    public sealed virtual object GetObject(IObjectValueProvider valueProvider);
    private IObjectMapper`1<TImplementation> GetDictionaryToObjectConverter(ReadWriteProperty`1<TImplementation> property, Type valueType);
    [CompilerGeneratedAttribute]
private IObjectMapper`1<TImplementation> <.ctor>b__2_0(ReadWriteProperty`1<TImplementation> property);
}
public class GreenPipes.Internals.Mapping.DynamicObjectConverterCache : object {
    private ConcurrentDictionary`2<Type, IObjectConverter> _cache;
    private IImplementationBuilder _implementationBuilder;
    public DynamicObjectConverterCache(IImplementationBuilder implementationBuilder);
    public sealed virtual IObjectConverter GetConverter(Type type);
    private IObjectConverter CreateMissingConverter(Type type);
}
public class GreenPipes.Internals.Mapping.EnumDictionaryMapper`1 : object {
    private ReadOnlyProperty`1<T> _property;
    public EnumDictionaryMapper`1(ReadOnlyProperty`1<T> property);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.EnumObjectMapper`1 : object {
    private ReadWriteProperty`1<T> _property;
    public EnumObjectMapper`1(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public interface GreenPipes.Internals.Mapping.IArrayValueProvider {
    public abstract virtual bool TryGetValue(int index, Object& value);
    public abstract virtual bool TryGetValue(int index, T& value);
}
public interface GreenPipes.Internals.Mapping.IDictionaryConverter {
    public abstract virtual IDictionary`2<string, object> GetDictionary(object obj);
}
public interface GreenPipes.Internals.Mapping.IDictionaryConverterCache {
    public abstract virtual IDictionaryConverter GetConverter(Type type);
}
public interface GreenPipes.Internals.Mapping.IDictionaryMapper`1 {
    public abstract virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public interface GreenPipes.Internals.Mapping.IObjectConverter {
    public abstract virtual object GetObject(IObjectValueProvider valueProvider);
}
public interface GreenPipes.Internals.Mapping.IObjectConverterCache {
    public abstract virtual IObjectConverter GetConverter(Type type);
}
public interface GreenPipes.Internals.Mapping.IObjectMapper`1 {
    public abstract virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public interface GreenPipes.Internals.Mapping.IObjectMapperCache {
    public abstract virtual IObjectConverter GetObjectConverter(Type type);
    public abstract virtual IDictionaryConverter GetDictionaryConverter(Type type);
}
public interface GreenPipes.Internals.Mapping.IObjectValueProvider {
    public abstract virtual bool TryGetValue(string name, Object& value);
    public abstract virtual bool TryGetValue(string name, T& value);
}
public class GreenPipes.Internals.Mapping.NullableValueDictionaryMapper`2 : object {
    private ReadOnlyProperty`1<T> _property;
    public NullableValueDictionaryMapper`2(ReadOnlyProperty`1<T> property);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.NullableValueObjectMapper`2 : object {
    private ReadWriteProperty`1<T> _property;
    public NullableValueObjectMapper`2(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ObjectArrayDictionaryMapper`2 : object {
    private IDictionaryConverter _elementConverter;
    private ReadOnlyProperty`1<T> _property;
    public ObjectArrayDictionaryMapper`2(ReadOnlyProperty`1<T> property, IDictionaryConverter elementConverter);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.ObjectArrayObjectMapper`2 : object {
    private IObjectConverter _converter;
    private ReadWriteProperty`1<T> _property;
    public ObjectArrayObjectMapper`2(ReadWriteProperty`1<T> property, IObjectConverter converter);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ObjectArrayValueProvider : object {
    private Array _values;
    public ObjectArrayValueProvider(Array values);
    public sealed virtual bool TryGetValue(int index, Object& value);
    public sealed virtual bool TryGetValue(int index, T& value);
}
[ExtensionAttribute]
public static class GreenPipes.Internals.Mapping.ObjectConverterExtensions : object {
    [ExtensionAttribute]
public static object GetObject(IObjectConverter converter, IDictionary`2<string, object> dictionary);
}
public class GreenPipes.Internals.Mapping.ObjectDictionaryConverter`1 : object {
    private DictionaryConverterCache _cache;
    private IDictionaryMapper`1[] _mappers;
    public ObjectDictionaryConverter`1(DictionaryConverterCache cache);
    public sealed virtual IDictionary`2<string, object> GetDictionary(object obj);
    private IDictionaryMapper`1<T> GetDictionaryMapper(ReadOnlyProperty`1<T> property, Type valueType);
    [CompilerGeneratedAttribute]
private IDictionaryMapper`1<T> <.ctor>b__2_0(ReadOnlyProperty`1<T> property);
}
public class GreenPipes.Internals.Mapping.ObjectDictionaryMapper`1 : object {
    private IDictionaryConverter _converter;
    private ReadOnlyProperty`1<T> _property;
    public ObjectDictionaryMapper`1(ReadOnlyProperty`1<T> property, IDictionaryConverter converter);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.ObjectListDictionaryMapper`2 : object {
    private IDictionaryConverter _elementConverter;
    private ReadOnlyProperty`1<T> _property;
    public ObjectListDictionaryMapper`2(ReadOnlyProperty`1<T> property, IDictionaryConverter elementConverter);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.ObjectListObjectMapper`2 : object {
    private IObjectConverter _converter;
    private ReadWriteProperty`1<T> _property;
    public ObjectListObjectMapper`2(ReadWriteProperty`1<T> property, IObjectConverter converter);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ObjectObjectMapper`1 : object {
    private IObjectConverter _converter;
    private ReadWriteProperty`1<T> _property;
    private TypeConverter _typeConverter;
    public ObjectObjectMapper`1(ReadWriteProperty`1<T> property, IObjectConverter converter);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ValueArrayObjectMapper`2 : object {
    private ReadWriteProperty`1<T> _property;
    public ValueArrayObjectMapper`2(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ValueDictionaryMapper`1 : object {
    private ReadOnlyProperty`1<T> _property;
    public ValueDictionaryMapper`1(ReadOnlyProperty`1<T> property);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.ValueListObjectMapper`2 : object {
    private ReadWriteProperty`1<T> _property;
    public ValueListObjectMapper`2(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public static class GreenPipes.Internals.Mapping.ValueObject : object {
    public static bool IsValueObjectType(Type valueType);
}
public class GreenPipes.Internals.Mapping.ValueObjectDictionaryDictionaryMapper`3 : object {
    private IDictionaryConverter _elementConverter;
    private ReadOnlyProperty`1<T> _property;
    public ValueObjectDictionaryDictionaryMapper`3(ReadOnlyProperty`1<T> property, IDictionaryConverter elementConverter);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
    [CompilerGeneratedAttribute]
private Object[] <WritePropertyToDictionary>b__3_0(KeyValuePair`2<TKey, TValue> element);
}
public class GreenPipes.Internals.Mapping.ValueObjectDictionaryObjectMapper`3 : object {
    private ReadWriteProperty`1<T> _property;
    private IObjectConverter _valueConverter;
    public ValueObjectDictionaryObjectMapper`3(ReadWriteProperty`1<T> property, IObjectConverter valueConverter);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ValueObjectMapper`1 : object {
    private ReadWriteProperty`1<T> _property;
    private TypeConverter _typeConverter;
    public ValueObjectMapper`1(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Mapping.ValueValueDictionaryDictionaryMapper`3 : object {
    private ReadOnlyProperty`1<T> _property;
    public ValueValueDictionaryDictionaryMapper`3(ReadOnlyProperty`1<T> property);
    public sealed virtual void WritePropertyToDictionary(IDictionary`2<string, object> dictionary, T obj);
}
public class GreenPipes.Internals.Mapping.ValueValueDictionaryObjectMapper`3 : object {
    private ReadWriteProperty`1<T> _property;
    public ValueValueDictionaryObjectMapper`3(ReadWriteProperty`1<T> property);
    public sealed virtual void ApplyTo(T obj, IObjectValueProvider valueProvider);
}
public class GreenPipes.Internals.Reflection.DynamicImplementationBuilder : object {
    private static MethodAttributes PropertyAccessMethodAttributes;
    private ConcurrentDictionary`2<string, ModuleBuilder> _moduleBuilders;
    private string _proxyNamespaceSuffix;
    private ConcurrentDictionary`2<Type, Lazy`1<Type>> _proxyTypes;
    public sealed virtual Type GetImplementationType(Type interfaceType);
    private Type CreateImplementation(Type interfaceType);
    private Type CreateTypeFromInterface(ModuleBuilder builder, Type interfaceType);
    private MethodBuilder GetGetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private MethodBuilder GetSetMethodBuilder(PropertyInfo propertyInfo, TypeBuilder typeBuilder, FieldBuilder fieldBuilder);
    private TResult GetModuleBuilderForType(Type interfaceType, Func`2<ModuleBuilder, TResult> callback);
    [CompilerGeneratedAttribute]
private Lazy`1<Type> <GetImplementationType>b__5_0(Type x);
}
public interface GreenPipes.Internals.Reflection.IImplementationBuilder {
    public abstract virtual Type GetImplementationType(Type interfaceType);
}
public class GreenPipes.Internals.Reflection.InterfaceReflectionCache : object {
    private ConcurrentDictionary`2<Type, ConcurrentDictionary`2<Type, Type>> _cache;
    public Type GetGenericInterface(Type type, TypeInfo interfaceType);
    public Type Get(Type type, TypeInfo interfaceType);
    private Type GetInterfaceInternal(Type type, TypeInfo interfaceType);
}
public interface GreenPipes.Internals.Reflection.IReadOnlyPropertyCache`1 {
    public abstract virtual bool TryGetValue(string key, ReadOnlyProperty`1& value);
}
[DefaultMemberAttribute("Item")]
public interface GreenPipes.Internals.Reflection.IReadWritePropertyCache`1 {
    public ReadWriteProperty`1<T> Item { get; }
    public abstract virtual ReadWriteProperty`1<T> get_Item(string name);
    public abstract virtual bool TryGetValue(string key, ReadWriteProperty`1& value);
    public abstract virtual bool TryGetProperty(string propertyName, ReadWriteProperty`1& property);
}
public class GreenPipes.Internals.Reflection.ReadOnlyProperty : object {
    public Func`2<object, object> GetProperty;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; private set; }
    public ReadOnlyProperty(PropertyInfo property);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    public object Get(object instance);
    private static Func`2<object, object> GetGetMethod(PropertyInfo property);
}
public class GreenPipes.Internals.Reflection.ReadOnlyProperty`1 : object {
    public Func`2<T, object> GetProperty;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; private set; }
    public ReadOnlyProperty`1(Expression`1<Func`2<T, object>> propertyExpression);
    public ReadOnlyProperty`1(PropertyInfo property);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    public object Get(T instance);
    private static Func`2<T, object> GetGetMethod(PropertyInfo property);
}
public class GreenPipes.Internals.Reflection.ReadOnlyProperty`2 : object {
    public Func`2<T, TProperty> GetProperty;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; private set; }
    public ReadOnlyProperty`2(Expression`1<Func`2<T, object>> propertyExpression);
    public ReadOnlyProperty`2(PropertyInfo property);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    public TProperty Get(T instance);
    private static Func`2<T, TProperty> GetGetMethod(PropertyInfo property);
}
public class GreenPipes.Internals.Reflection.ReadOnlyPropertyCache`1 : object {
    private IDictionary`2<string, ReadOnlyProperty`1<T>> _properties;
    public sealed virtual IEnumerator`1<ReadOnlyProperty`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(string key, ReadOnlyProperty`1& value);
    private static IDictionary`2<string, ReadOnlyProperty`1<T>> CreatePropertyCache();
    public object Get(Expression`1<Func`2<T, object>> propertyExpression, T instance);
}
public class GreenPipes.Internals.Reflection.ReadWriteProperty : ReadOnlyProperty {
    public Action`2<object, object> SetProperty;
    public ReadWriteProperty(PropertyInfo property);
    public void Set(object instance, object value);
    private static Action`2<object, object> GetSetMethod(PropertyInfo property);
}
public class GreenPipes.Internals.Reflection.ReadWriteProperty`1 : ReadOnlyProperty`1<T> {
    public Action`2<T, object> SetProperty;
    public ReadWriteProperty`1(Expression`1<Func`2<T, object>> propertyExpression);
    public ReadWriteProperty`1(Expression`1<Func`2<T, object>> propertyExpression, bool includeNonPublic);
    public ReadWriteProperty`1(PropertyInfo property);
    public void Set(T instance, object value);
    private static Action`2<T, object> GetSetMethod(PropertyInfo property);
}
public class GreenPipes.Internals.Reflection.ReadWriteProperty`2 : ReadOnlyProperty`2<T, TProperty> {
    public Action`2<T, TProperty> SetProperty;
    public ReadWriteProperty`2(Expression`1<Func`2<T, object>> propertyExpression);
    public ReadWriteProperty`2(Expression`1<Func`2<T, object>> propertyExpression, bool includeNonPublic);
    public ReadWriteProperty`2(PropertyInfo property);
    public void Set(T instance, TProperty value);
    private static Action`2<T, TProperty> GetSetMethod(PropertyInfo property);
}
[DefaultMemberAttribute("Item")]
public class GreenPipes.Internals.Reflection.ReadWritePropertyCache`1 : object {
    private IDictionary`2<string, ReadWriteProperty`1<T>> _properties;
    public ReadWriteProperty`1<T> Item { get; }
    public ReadWritePropertyCache`1(bool includeNonPublic);
    public sealed virtual ReadWriteProperty`1<T> get_Item(string name);
    public sealed virtual IEnumerator`1<ReadWriteProperty`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(string key, ReadWriteProperty`1& value);
    public sealed virtual bool TryGetProperty(string propertyName, ReadWriteProperty`1& property);
    private static IDictionary`2<string, ReadWriteProperty`1<T>> CreatePropertyCache(bool includeNonPublic);
    public void Set(Expression`1<Func`2<T, object>> propertyExpression, T instance, object value);
    public object Get(Expression`1<Func`2<T, object>> propertyExpression, T instance);
}
public class GreenPipes.Internals.Reflection.TypeNameFormatter : object {
    private ConcurrentDictionary`2<Type, string> _cache;
    private string _genericArgumentSeparator;
    private string _genericClose;
    private string _genericOpen;
    private string _namespaceSeparator;
    private string _nestedTypeSeparator;
    public TypeNameFormatter(string genericArgumentSeparator, string genericOpen, string genericClose, string namespaceSeparator, string nestedTypeSeparator);
    public string GetTypeName(Type type);
    private string FormatTypeName(Type type);
    private string FormatTypeName(StringBuilder sb, Type type, string scope);
}
public class GreenPipes.Introspection.GreenPipesHostInfo : object {
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GreenPipesVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystemVersion>k__BackingField;
    public string MachineName { get; private set; }
    public string ProcessName { get; private set; }
    public int ProcessId { get; private set; }
    public string Assembly { get; private set; }
    public string AssemblyVersion { get; private set; }
    public string FrameworkVersion { get; private set; }
    public string GreenPipesVersion { get; private set; }
    public string OperatingSystemVersion { get; private set; }
    public GreenPipesHostInfo(bool initialize);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MachineName();
    [CompilerGeneratedAttribute]
private void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProcessName();
    [CompilerGeneratedAttribute]
private void set_ProcessName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    [CompilerGeneratedAttribute]
private void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyVersion();
    [CompilerGeneratedAttribute]
private void set_AssemblyVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_GreenPipesVersion();
    [CompilerGeneratedAttribute]
private void set_GreenPipesVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
private void set_OperatingSystemVersion(string value);
    private static string GetAssemblyFileVersion(Assembly assembly);
}
public interface GreenPipes.Introspection.IProbeResultBuilder {
    public abstract virtual ProbeResult Build();
}
public interface GreenPipes.Introspection.ProbeHostInfo {
    public string MachineName { get; }
    public string ProcessName { get; }
    public int ProcessId { get; }
    public string Assembly { get; }
    public string AssemblyVersion { get; }
    public string FrameworkVersion { get; }
    public string GreenPipesVersion { get; }
    public string OperatingSystemVersion { get; }
    public abstract virtual string get_MachineName();
    public abstract virtual string get_ProcessName();
    public abstract virtual int get_ProcessId();
    public abstract virtual string get_Assembly();
    public abstract virtual string get_AssemblyVersion();
    public abstract virtual string get_FrameworkVersion();
    public abstract virtual string get_GreenPipesVersion();
    public abstract virtual string get_OperatingSystemVersion();
}
public static class GreenPipes.Introspection.ProbeHostInfoCache : object {
    public static ProbeHostInfo Host { get; }
    public static ProbeHostInfo get_Host();
}
public interface GreenPipes.Introspection.ProbeResult {
    public Guid ResultId { get; }
    public Guid ProbeId { get; }
    public DateTime StartTimestamp { get; }
    public TimeSpan Duration { get; }
    public ProbeHostInfo Host { get; }
    public IDictionary`2<string, object> Results { get; }
    public abstract virtual Guid get_ResultId();
    public abstract virtual Guid get_ProbeId();
    public abstract virtual DateTime get_StartTimestamp();
    public abstract virtual TimeSpan get_Duration();
    public abstract virtual ProbeHostInfo get_Host();
    public abstract virtual IDictionary`2<string, object> get_Results();
}
public class GreenPipes.Introspection.ProbeResultBuilder : ScopeProbeContext {
    private ProbeHostInfo _host;
    private Guid _probeId;
    private Guid _resultId;
    private DateTime _startTimestamp;
    public ProbeResultBuilder(Guid probeId, CancellationToken cancellationToken);
    private sealed virtual override ProbeResult GreenPipes.Introspection.IProbeResultBuilder.Build();
}
public class GreenPipes.Introspection.ScopeProbeContext : object {
    private CancellationToken _cancellationToken;
    private IDictionary`2<string, object> _variables;
    private CancellationToken GreenPipes.ProbeContext.CancellationToken { get; }
    protected ScopeProbeContext(CancellationToken cancellationToken);
    private sealed virtual override CancellationToken GreenPipes.ProbeContext.get_CancellationToken();
    private sealed virtual override void GreenPipes.ProbeContext.Add(string key, string value);
    private sealed virtual override void GreenPipes.ProbeContext.Add(string key, object value);
    public sealed virtual void Set(object values);
    public sealed virtual void Set(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public sealed virtual ProbeContext CreateScope(string key);
    protected IDictionary`2<string, object> Build();
    private void SetVariablesFromDictionary(IEnumerable`1<KeyValuePair`2<string, object>> values);
    private static IEnumerable`1<KeyValuePair`2<string, object>> GetObjectAsDictionary(object values);
}
[ExtensionAttribute]
public static class GreenPipes.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static ProbeResult GetProbeResult(IProbeSite probeSite, CancellationToken cancellationToken);
}
public interface GreenPipes.IObserverConnector {
    public abstract virtual ConnectHandle ConnectObserver(IFilterObserver`1<T> observer);
    public abstract virtual ConnectHandle ConnectObserver(IFilterObserver observer);
}
public interface GreenPipes.IObserverConnector`1 {
    public abstract virtual ConnectHandle ConnectObserver(IFilterObserver`1<TContext> observer);
}
public interface GreenPipes.IPipe`1 {
    public abstract virtual Task Send(TContext context);
}
public interface GreenPipes.IPipeBuilder`1 {
    public abstract virtual void AddFilter(IFilter`1<TContext> filter);
}
public interface GreenPipes.IPipeConfigurationResult {
    public bool ContainsFailure { get; }
    public abstract virtual bool get_ContainsFailure();
    public abstract virtual string GetMessage(string header);
    public abstract virtual bool Any();
}
public interface GreenPipes.IPipeConfigurator`1 {
    [EditorBrowsableAttribute("1")]
public abstract virtual void AddPipeSpecification(IPipeSpecification`1<TContext> specification);
}
public interface GreenPipes.IPipeConnector {
    public abstract virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
}
public interface GreenPipes.IPipeConnector`1 {
    public abstract virtual ConnectHandle ConnectPipe(IPipe`1<TContext> pipe);
}
public interface GreenPipes.IPipeConnectorSpecification {
    public abstract virtual void Connect(IPipeConnector connector);
}
public interface GreenPipes.IPipeContextSource`1 {
    public abstract virtual Task Send(IPipe`1<TContext> pipe, CancellationToken cancellationToken);
}
public interface GreenPipes.IPipeContextSource`2 {
    public abstract virtual Task Send(TInput context, IPipe`1<TContext> pipe);
}
public interface GreenPipes.IPipeRouter {
}
public interface GreenPipes.IPipeSpecification`1 {
    public abstract virtual void Apply(IPipeBuilder`1<TContext> builder);
}
public interface GreenPipes.IProbeSite {
    public abstract virtual void Probe(ProbeContext context);
}
public interface GreenPipes.IRequestPipe`1 {
    public abstract virtual Task`1<ResultContext> Send(TRequest context);
}
public interface GreenPipes.IRequestPipe`2 {
    public abstract virtual Task`1<ResultContext`1<TResult>> Send(TRequest request);
}
public interface GreenPipes.IRetryObserver {
    public abstract virtual Task PostCreate(RetryPolicyContext`1<T> context);
    public abstract virtual Task PostFault(RetryContext`1<T> context);
    public abstract virtual Task PreRetry(RetryContext`1<T> context);
    public abstract virtual Task RetryFault(RetryContext`1<T> context);
    public abstract virtual Task RetryComplete(RetryContext`1<T> context);
}
public interface GreenPipes.IRetryObserverConnector {
    public abstract virtual ConnectHandle ConnectRetryObserver(IRetryObserver observer);
}
public interface GreenPipes.IRetryPolicy {
    public abstract virtual RetryPolicyContext`1<T> CreatePolicyContext(T context);
    public abstract virtual bool IsHandled(Exception exception);
}
public interface GreenPipes.ISpecification {
    [EditorBrowsableAttribute("1")]
public abstract virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.KeyAccessor`2 : MulticastDelegate {
    public KeyAccessor`2(object object, IntPtr method);
    public virtual TKey Invoke(TContext context);
    public virtual IAsyncResult BeginInvoke(TContext context, AsyncCallback callback, object object);
    public virtual TKey EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class GreenPipes.LatestConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseLatest(IPipeConfigurator`1<T> configurator, Action`1<ILatestConfigurator`1<T>> configure);
}
public class GreenPipes.LatestFilterCreated`1 : MulticastDelegate {
    public LatestFilterCreated`1(object object, IntPtr method);
    public virtual void Invoke(ILatestFilter`1<T> filter);
    public virtual IAsyncResult BeginInvoke(ILatestFilter`1<T> filter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class GreenPipes.MergeFilterContextProvider`2 : MulticastDelegate {
    public MergeFilterContextProvider`2(object object, IntPtr method);
    public virtual TInput Invoke(TInput inputContext, TSplit context);
    public virtual IAsyncResult BeginInvoke(TInput inputContext, TSplit context, AsyncCallback callback, object object);
    public virtual TInput EndInvoke(IAsyncResult result);
}
public class GreenPipes.Observers.FilterObservable : Connectable`1<IFilterObserver> {
    public sealed virtual Task PreSend(T context);
    public sealed virtual Task PostSend(T context);
    public sealed virtual Task SendFault(T context, Exception exception);
}
public class GreenPipes.Observers.FilterObservable`1 : Connectable`1<IFilterObserver`1<TContext>> {
    public sealed virtual Task PreSend(TContext context);
    public sealed virtual Task PostSend(TContext context);
    public sealed virtual Task SendFault(TContext context, Exception exception);
}
public class GreenPipes.Observers.ObservableAdapter`1 : object {
    private IFilterObserver _observer;
    public ObservableAdapter`1(IFilterObserver observer);
    public sealed virtual Task PreSend(TContext context);
    public sealed virtual Task PostSend(TContext context);
    public sealed virtual Task SendFault(TContext context, Exception exception);
}
[DefaultMemberAttribute("Item")]
public class GreenPipes.Observers.RetryFaultObserverCache : object {
    private ConcurrentDictionary`2<Type, Lazy`1<IRetryFaultObserver>> _types;
    private IRetryFaultObserver Item { get; }
    private IRetryFaultObserver get_Item(Type type);
    public static Task RetryFault(IRetryObserver observer, RetryContext context, Type contextType);
    private static Lazy`1<IRetryFaultObserver> CreateTypeConverter(Type type);
    private static IRetryFaultObserver CreateConverter(Type type);
}
public class GreenPipes.Observers.RetryObservable : Connectable`1<IRetryObserver> {
    public sealed virtual Task PostCreate(RetryPolicyContext`1<T> context);
    public sealed virtual Task PostFault(RetryContext`1<T> context);
    public sealed virtual Task PreRetry(RetryContext`1<T> context);
    public sealed virtual Task RetryFault(RetryContext`1<T> context);
    public sealed virtual Task RetryComplete(RetryContext`1<T> context);
    public Task RetryFault(RetryContext context);
}
[ExtensionAttribute]
public static class GreenPipes.PartitionerConfigurationExtensions : object {
    [ExtensionAttribute]
public static IPartitioner CreatePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, Guid> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, string> keyProvider, Encoding encoding);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, long> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, long> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, int partitionCount, Func`2<T, Byte[]> keyProvider);
    [ExtensionAttribute]
public static void UsePartitioner(IPipeConfigurator`1<T> configurator, IPartitioner partitioner, Func`2<T, Byte[]> keyProvider);
}
public interface GreenPipes.Partitioning.IHashGenerator {
    public abstract virtual UInt32 Hash(Byte[] data);
}
public interface GreenPipes.Partitioning.IPartitioner {
    public abstract virtual IPartitioner`1<T> GetPartitioner(PartitionKeyProvider`1<T> keyProvider);
}
public interface GreenPipes.Partitioning.IPartitioner`1 {
    public abstract virtual Task Send(TContext context, IPipe`1<TContext> next);
}
public class GreenPipes.Partitioning.Murmur3UnsafeHashGenerator : object {
    private static UInt32 Seed;
    private static UInt32 C1;
    private static UInt32 C2;
    public sealed virtual UInt32 Hash(Byte[] data);
    public UInt32 Hash(string s);
    public UInt32 Hash(Byte[] data, int offset, UInt32 count, UInt32 seed);
    private static UInt32 Hash(Byte* data, UInt32 len, UInt32 seed);
    private static UInt32 Rotl32(UInt32 x, int r);
}
public class GreenPipes.Partitioning.Partition : Agent {
    private int _index;
    private SemaphoreSlim _limit;
    private long _attemptCount;
    private long _failureCount;
    private long _successCount;
    public Partition(int index);
    public sealed virtual void Dispose();
    public void Probe(ProbeContext context);
    [AsyncStateMachineAttribute("GreenPipes.Partitioning.Partition/<Send>d__8`1")]
public Task Send(T context, IPipe`1<T> next);
    [AsyncStateMachineAttribute("GreenPipes.Partitioning.Partition/<StopAgent>d__9")]
protected virtual Task StopAgent(StopContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(StopContext context);
}
public class GreenPipes.Partitioning.Partitioner : Supervisor {
    private IHashGenerator _hashGenerator;
    private string _id;
    private int _partitionCount;
    private Partition[] _partitions;
    public Partitioner(int partitionCount, IHashGenerator hashGenerator);
    private sealed virtual override IPartitioner`1<T> GreenPipes.Partitioning.IPartitioner.GetPartitioner(PartitionKeyProvider`1<T> keyProvider);
    public sealed virtual void Probe(ProbeContext context);
    private Task Send(Byte[] key, T context, IPipe`1<T> next);
}
public class GreenPipes.Partitioning.PartitionKeyProvider`1 : MulticastDelegate {
    public PartitionKeyProvider`1(object object, IntPtr method);
    public virtual Byte[] Invoke(TContext context);
    public virtual IAsyncResult BeginInvoke(TContext context, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class GreenPipes.PayloadException : Exception {
    public PayloadException(string message);
    public PayloadException(string message, Exception innerException);
    protected PayloadException(SerializationInfo info, StreamingContext context);
}
public class GreenPipes.PayloadFactory`1 : MulticastDelegate {
    public PayloadFactory`1(object object, IntPtr method);
    public virtual TPayload Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TPayload EndInvoke(IAsyncResult result);
}
public class GreenPipes.PayloadFactoryException : PayloadException {
    public PayloadFactoryException(string message);
    public PayloadFactoryException(string message, Exception innerException);
    protected PayloadFactoryException(SerializationInfo info, StreamingContext context);
}
public class GreenPipes.PayloadNotFoundException : PayloadException {
    public PayloadNotFoundException(string message);
    public PayloadNotFoundException(string message, Exception innerException);
    protected PayloadNotFoundException(SerializationInfo info, StreamingContext context);
}
public interface GreenPipes.Payloads.IPayloadCache {
    public abstract virtual bool HasPayloadType(Type payloadType);
    public abstract virtual bool TryGetPayload(TPayload& payload);
    public abstract virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public abstract virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public class GreenPipes.Payloads.ListPayloadCache : object {
    private IList`1<object> _cache;
    public ListPayloadCache(Object[] payloads);
    public sealed virtual bool HasPayloadType(Type payloadType);
    public sealed virtual bool TryGetPayload(TPayload& payload);
    public sealed virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public sealed virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
[ExtensionAttribute]
public static class GreenPipes.Pipe : object {
    public static IPipe`1<T> New(Action`1<IPipeConfigurator`1<T>> callback);
    public static IPipe`1<T> New(Action`1<IPipeConfigurator`1<T>> callback, bool validate);
    public static IPipe`1<T> Execute(Action`1<T> action);
    public static IPipe`1<T> ExecuteAsync(Func`2<T, Task> action);
    public static IPipe`1<T> Empty();
    [ExtensionAttribute]
public static IPipe`1<T> ToPipe(IFilter`1<T> filter);
    [ExtensionAttribute]
public static IPipe`1<T> ToPipe(IFilter`1[] filters);
}
public class GreenPipes.PipeConfigurationException : Exception {
    public PipeConfigurationException(string message);
    public PipeConfigurationException(string message, Exception innerException);
    protected PipeConfigurationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class GreenPipes.PipeConfiguratorExtensions : object {
    [ExtensionAttribute]
public static void ValidatePipeConfiguration(IBuildPipeConfigurator`1<T> configurator);
}
public interface GreenPipes.PipeContext {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual bool HasPayloadType(Type payloadType);
    public abstract virtual bool TryGetPayload(T& payload);
    public abstract virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public abstract virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public interface GreenPipes.PipeContextHandle`1 {
    public bool IsDisposed { get; }
    public Task`1<TContext> Context { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual Task`1<TContext> get_Context();
}
[ExtensionAttribute]
public static class GreenPipes.PipeExtensions : object {
    [ExtensionAttribute]
public static bool IsNotEmpty(IPipe`1<T> pipe);
    [ExtensionAttribute]
public static TPayload GetPayload(PipeContext context);
    [AsyncStateMachineAttribute("GreenPipes.PipeExtensions/<OneTimeSetup>d__2`1")]
[ExtensionAttribute]
public static Task OneTimeSetup(PipeContext context, Func`2<T, Task> setupMethod, PayloadFactory`1<T> payloadFactory);
}
public class GreenPipes.Pipes.DynamicRouter`1 : object {
    private IDynamicFilter`1<TContext> _filter;
    private IPipe`1<TContext> _pipe;
    public DynamicRouter`1(IPipeContextConverterFactory`1<TContext> converterFactory);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task GreenPipes.IPipe<TContext>.Send(TContext context);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver observer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(IPipeConfigurator`1<TContext> x);
}
public class GreenPipes.Pipes.DynamicRouter`2 : object {
    private IDynamicFilter`2<TContext, TKey> _filter;
    private IPipe`1<TContext> _pipe;
    public DynamicRouter`2(IPipeContextConverterFactory`1<TContext> converterFactory, KeyAccessor`2<TContext, TKey> keyAccessor);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task GreenPipes.IPipe<TContext>.Send(TContext context);
    public sealed virtual ConnectHandle ConnectPipe(IPipe`1<T> pipe);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver`1<T> observer);
    private sealed virtual override ConnectHandle GreenPipes.IObserverConnector.ConnectObserver(IFilterObserver observer);
    public sealed virtual ConnectHandle ConnectPipe(TKey key, IPipe`1<T> pipe);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(IPipeConfigurator`1<TContext> x);
}
public class GreenPipes.Pipes.EmptyPipe`1 : object {
    [DebuggerNonUserCodeAttribute]
private sealed virtual override Task GreenPipes.IPipe<TContext>.Send(TContext context);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public class GreenPipes.Pipes.FilterPipe`1 : object {
    private IFilter`1<TContext> _filter;
    private IPipe`1<TContext> _next;
    public FilterPipe`1(IFilter`1<TContext> filter, IPipe`1<TContext> next);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerStepThroughAttribute]
private sealed virtual override Task GreenPipes.IPipe<TContext>.Send(TContext context);
}
public class GreenPipes.Pipes.InsertPipe`1 : object {
    private IFilter`1<T> _filter;
    private IPipe`1<T> _next;
    public InsertPipe`1(IFilter`1<T> filter, IPipe`1<T> next);
    private sealed virtual override Task GreenPipes.IPipe<T>.Send(T context);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
}
public class GreenPipes.Pipes.LastPipe`1 : object {
    private IFilter`1<TContext> _filter;
    public LastPipe`1(IFilter`1<TContext> filter);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    [DebuggerStepThroughAttribute]
public sealed virtual Task Send(TContext context);
}
public class GreenPipes.Pipes.MergePipe`2 : object {
    private MergeFilterContextProvider`2<TInput, TSplit> _contextProvider;
    private TInput _input;
    private IPipe`1<TInput> _next;
    public MergePipe`2(IPipe`1<TInput> next, TInput input, MergeFilterContextProvider`2<TInput, TSplit> contextProvider);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override Task GreenPipes.IPipe<TSplit>.Send(TSplit context);
}
public class GreenPipes.Pipes.MultipleResultRequestPipe`1 : object {
    private IPipe`1<RequestContext> _requestPipe;
    private IPipe`1<ResultContext> _resultPipe;
    public MultipleResultRequestPipe`1(IPipe`1<RequestContext> requestPipe, IPipe`1<ResultContext> resultPipe);
    public sealed virtual Task`1<ResultContext> Send(TRequest request);
    public sealed virtual void Probe(ProbeContext context);
    private void SendRequest(RequestContext context);
}
public class GreenPipes.Pipes.PipeRouter : DynamicRouter`1<PipeContext> {
}
public class GreenPipes.Pipes.SingleResultRequestPipe`2 : object {
    private IPipe`1<RequestContext> _requestPipe;
    private IPipe`1<ResultContext`2<TRequest, TResult>> _resultPipe;
    public SingleResultRequestPipe`2(IPipe`1<RequestContext> requestPipe, IPipe`1<ResultContext`2<TRequest, TResult>> resultPipe);
    public sealed virtual Task`1<ResultContext`1<TResult>> Send(TRequest request);
    public sealed virtual void Probe(ProbeContext context);
    private void SendRequest(RequestContext context);
}
public class GreenPipes.Policies.BaseRetryContext`1 : object {
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    public TContext Context { get; }
    public CancellationToken CancellationToken { get; }
    public Exception Exception { get; }
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public Nullable`1<TimeSpan> Delay { get; }
    private Type GreenPipes.RetryContext.ContextType { get; }
    protected BaseRetryContext`1(TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual TContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RetryCount();
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override Type GreenPipes.RetryContext.get_ContextType();
    public virtual Task PreRetry();
    public virtual Task RetryFaulted(Exception exception);
}
public abstract class GreenPipes.Policies.BaseRetryPolicyContext`1 : object {
    private IRetryPolicy _policy;
    private CancellationTokenSource _cancellationTokenSource;
    private CancellationTokenRegistration _registration;
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    protected CancellationToken CancellationToken { get; }
    public TContext Context { get; }
    protected BaseRetryPolicyContext`1(IRetryPolicy policy, TContext context);
    protected CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual TContext get_Context();
    public virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    private sealed virtual override Task GreenPipes.RetryPolicyContext<TContext>.RetryFaulted(Exception exception);
    public sealed virtual void Cancel();
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
    private CancellationToken CreateCancellationToken();
}
public class GreenPipes.Policies.ExceptionFilters.AllExceptionFilter : object {
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool GreenPipes.IExceptionFilter.Match(Exception exception);
}
internal class GreenPipes.Policies.ExceptionFilters.CompositeExceptionFilter : object {
    private CompositeFilter`1<Exception> _filter;
    public CompositeExceptionFilter(CompositeFilter`1<Exception> filter);
    public sealed virtual void Probe(ProbeContext context);
    public sealed virtual bool Match(Exception exception);
}
internal class GreenPipes.Policies.ExceptionFilters.CompositeFilter`1 : object {
    private CompositePredicate`1<T> _excludes;
    private CompositePredicate`1<T> _includes;
    public CompositePredicate`1<T> Includes { get; public set; }
    public CompositePredicate`1<T> Excludes { get; public set; }
    public CompositePredicate`1<T> get_Includes();
    public void set_Includes(CompositePredicate`1<T> value);
    public CompositePredicate`1<T> get_Excludes();
    public void set_Excludes(CompositePredicate`1<T> value);
    public bool Matches(T target);
}
internal class GreenPipes.Policies.ExceptionFilters.CompositePredicate`1 : object {
    private List`1<Func`2<T, bool>> _list;
    private Func`2<T, bool> _matchesAll;
    private Func`2<T, bool> _matchesAny;
    private Func`2<T, bool> _matchesNone;
    public void Add(Func`2<T, bool> filter);
    public static CompositePredicate`1<T> op_Addition(CompositePredicate`1<T> invokes, Func`2<T, bool> filter);
    public bool MatchesAll(T target);
    public bool MatchesAny(T target);
    public bool MatchesNone(T target);
    public bool DoesNotMatchAny(T target);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_0(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_1(T x);
    [CompilerGeneratedAttribute]
private bool <Add>b__4_2(T x);
}
public class GreenPipes.Policies.ExceptionFilters.FilterExceptionFilter`1 : object {
    private Func`2<T, bool> _filter;
    public FilterExceptionFilter`1(Func`2<T, bool> filter);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool GreenPipes.IExceptionFilter.Match(Exception exception);
}
public class GreenPipes.Policies.ExceptionFilters.HandleExceptionFilter : object {
    private Type[] _exceptionTypes;
    public HandleExceptionFilter(Type[] exceptionTypes);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool GreenPipes.IExceptionFilter.Match(Exception exception);
}
public class GreenPipes.Policies.ExceptionFilters.IgnoreExceptionFilter : object {
    private Type[] _exceptionTypes;
    public IgnoreExceptionFilter(Type[] exceptionTypes);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override bool GreenPipes.IExceptionFilter.Match(Exception exception);
}
public class GreenPipes.Policies.ExponentialRetryContext`1 : BaseRetryContext`1<TContext> {
    private ExponentialRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public ExponentialRetryContext`1(ExponentialRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool GreenPipes.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class GreenPipes.Policies.ExponentialRetryPolicy : object {
    private IExceptionFilter _filter;
    private int _highInterval;
    private TimeSpan[] _intervals;
    private int _lowInterval;
    private int _maxInterval;
    private int _minInterval;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    public int RetryLimit { get; }
    public ExponentialRetryPolicy(IExceptionFilter filter, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> GreenPipes.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
    public TimeSpan GetRetryInterval(int retryCount);
    [IteratorStateMachineAttribute("GreenPipes.Policies.ExponentialRetryPolicy/<CalculateIntervals>d__14")]
private IEnumerable`1<TimeSpan> CalculateIntervals();
    public virtual string ToString();
}
public class GreenPipes.Policies.ExponentialRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private ExponentialRetryPolicy _policy;
    public ExponentialRetryPolicyContext`1(ExponentialRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class GreenPipes.Policies.ImmediateRetryContext`1 : BaseRetryContext`1<TContext> {
    private ImmediateRetryPolicy _policy;
    public ImmediateRetryContext`1(ImmediateRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    private sealed virtual override bool GreenPipes.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class GreenPipes.Policies.ImmediateRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    public int RetryLimit { get; }
    public ImmediateRetryPolicy(IExceptionFilter filter, int retryLimit);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> GreenPipes.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class GreenPipes.Policies.ImmediateRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private ImmediateRetryPolicy _policy;
    public ImmediateRetryPolicyContext`1(ImmediateRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class GreenPipes.Policies.IncrementalRetryContext`1 : BaseRetryContext`1<TContext> {
    private TimeSpan _delay;
    private TimeSpan _delayIncrement;
    private IncrementalRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public IncrementalRetryContext`1(IncrementalRetryPolicy policy, TContext context, Exception exception, int retryCount, TimeSpan delay, TimeSpan delayIncrement, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool GreenPipes.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class GreenPipes.Policies.IncrementalRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InitialInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IntervalIncrement>k__BackingField;
    public int RetryLimit { get; }
    public TimeSpan InitialInterval { get; }
    public TimeSpan IntervalIncrement { get; }
    public IncrementalRetryPolicy(IExceptionFilter filter, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
    [CompilerGeneratedAttribute]
public int get_RetryLimit();
    [CompilerGeneratedAttribute]
public TimeSpan get_InitialInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_IntervalIncrement();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> GreenPipes.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
}
public class GreenPipes.Policies.IncrementalRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private IncrementalRetryPolicy _policy;
    public IncrementalRetryPolicyContext`1(IncrementalRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class GreenPipes.Policies.IntervalRetryContext`1 : BaseRetryContext`1<TContext> {
    private IntervalRetryPolicy _policy;
    public Nullable`1<TimeSpan> Delay { get; }
    public IntervalRetryContext`1(IntervalRetryPolicy policy, TContext context, Exception exception, int retryCount, CancellationToken cancellationToken);
    public virtual Nullable`1<TimeSpan> get_Delay();
    private sealed virtual override bool GreenPipes.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class GreenPipes.Policies.IntervalRetryPolicy : object {
    private IExceptionFilter _filter;
    [CompilerGeneratedAttribute]
private TimeSpan[] <Intervals>k__BackingField;
    public TimeSpan[] Intervals { get; }
    public IntervalRetryPolicy(IExceptionFilter filter, TimeSpan[] intervals);
    public IntervalRetryPolicy(IExceptionFilter filter, Int32[] intervals);
    [CompilerGeneratedAttribute]
public TimeSpan[] get_Intervals();
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> GreenPipes.IRetryPolicy.CreatePolicyContext(T context);
    public sealed virtual bool IsHandled(Exception exception);
    public virtual string ToString();
}
public class GreenPipes.Policies.IntervalRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    private IntervalRetryPolicy _policy;
    public IntervalRetryPolicyContext`1(IntervalRetryPolicy policy, TContext context);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public class GreenPipes.Policies.NoRetryContext`1 : BaseRetryContext`1<TContext> {
    public NoRetryContext`1(TContext context, Exception exception, CancellationToken cancellationToken);
    private sealed virtual override bool GreenPipes.RetryContext<TContext>.CanRetry(Exception exception, RetryContext`1& retryContext);
}
public class GreenPipes.Policies.NoRetryPolicy : object {
    private IExceptionFilter _filter;
    public NoRetryPolicy(IExceptionFilter filter);
    private sealed virtual override void GreenPipes.IProbeSite.Probe(ProbeContext context);
    private sealed virtual override RetryPolicyContext`1<T> GreenPipes.IRetryPolicy.CreatePolicyContext(T context);
    private sealed virtual override bool GreenPipes.IRetryPolicy.IsHandled(Exception exception);
    public virtual string ToString();
}
public class GreenPipes.Policies.NoRetryPolicyContext`1 : BaseRetryPolicyContext`1<TContext> {
    public NoRetryPolicyContext`1(IRetryPolicy policy, TContext context);
    public virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    protected virtual RetryContext`1<TContext> CreateRetryContext(Exception exception, CancellationToken cancellationToken);
}
public interface GreenPipes.ProbeContext {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual void Add(string key, string value);
    public abstract virtual void Add(string key, object value);
    public abstract virtual void Set(object values);
    public abstract virtual void Set(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public abstract virtual ProbeContext CreateScope(string key);
}
[ExtensionAttribute]
public static class GreenPipes.ProbeContextExtensions : object {
    [ExtensionAttribute]
public static ProbeContext CreateFilterScope(ProbeContext context, string filterType);
}
public abstract class GreenPipes.ProxyPipeContext : object {
    private PipeContext _parentContext;
    public CancellationToken CancellationToken { get; }
    protected ProxyPipeContext(PipeContext parentContext);
    public virtual CancellationToken get_CancellationToken();
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
[ExtensionAttribute]
public static class GreenPipes.RateLimitConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRateLimit(IPipeConfigurator`1<T> configurator, int rateLimit, IPipeRouter router);
    [ExtensionAttribute]
public static void UseRateLimit(IPipeConfigurator`1<T> configurator, int rateLimit, TimeSpan interval, IPipeRouter router);
}
[ExtensionAttribute]
public static class GreenPipes.RateLimitExtensions : object {
    [ExtensionAttribute]
public static Task SetRateLimit(IPipe`1<CommandContext> pipe, int rateLimit);
}
[ExtensionAttribute]
public static class GreenPipes.RepeatPipeConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRepeat(IPipeConfigurator`1<T> configurator, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class GreenPipes.RequestConfigurationExtensions : object {
    [ExtensionAttribute]
public static IRequestPipe`1<TRequest> CreateRequestPipe(IPipe`1<RequestContext> requestPipe, Func`2[] configureResults);
    [ExtensionAttribute]
public static IRequestPipe`2<TRequest, TResult> CreateRequestPipe(IPipe`1<RequestContext> requestPipe, Action`1<IResultConfigurator`2<TRequest, TResult>> configure);
    [ExtensionAttribute]
public static void Handle(IDispatchConfigurator`1<RequestContext> configurator, Action`1<IPipeConfigurator`1<RequestContext`1<TRequest>>> configure);
}
public interface GreenPipes.RequestContext {
    public bool IsCompleted { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool TrySetResult(T result);
    public abstract virtual bool TrySetException(Exception exception);
    public abstract virtual bool TrySetCanceled();
}
public interface GreenPipes.RequestContext`1 {
    public TRequest Request { get; }
    public abstract virtual TRequest get_Request();
}
[ExtensionAttribute]
public static class GreenPipes.RescueConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<TContext> configurator, IPipe`1<TRescue> rescuePipe, RescueContextFactory`2<TContext, TRescue> rescueContextFactory, Action`1<IRescueConfigurator`2<TContext, TRescue>> configure);
    [ExtensionAttribute]
public static void UseRescue(IPipeConfigurator`1<TContext> configurator, RescueContextFactory`2<TContext, TRescue> rescueContextFactory, Action`1<IRescueConfigurator`2<TContext, TRescue>> configure);
}
public interface GreenPipes.ResultContext {
    public abstract virtual T GetResult();
    public abstract virtual bool TryGetResult(T& result);
}
public interface GreenPipes.ResultContext`1 {
    public TResult Result { get; }
    public abstract virtual TResult get_Result();
}
public interface GreenPipes.ResultContext`2 {
    public TRequest Request { get; }
    public abstract virtual TRequest get_Request();
}
[ExtensionAttribute]
public static class GreenPipes.ResultExtensions : object {
    [AsyncStateMachineAttribute("GreenPipes.ResultExtensions/<Result>d__0`1")]
[ExtensionAttribute]
public static Task`1<TResult> Result(Task`1<ResultContext> result);
    [AsyncStateMachineAttribute("GreenPipes.ResultExtensions/<Result>d__1`1")]
[ExtensionAttribute]
public static Task`1<TResult> Result(Task`1<ResultContext`1<TResult>> result);
}
[ExtensionAttribute]
public static class GreenPipes.RetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseRetry(IPipeConfigurator`1<T> configurator, Action`1<IRetryConfigurator> configure);
    [ExtensionAttribute]
public static IRetryConfigurator None(IRetryConfigurator configurator);
    [ExtensionAttribute]
public static IRetryConfigurator Immediate(IRetryConfigurator configurator, int retryLimit);
    [ExtensionAttribute]
public static IRetryConfigurator Intervals(IRetryConfigurator configurator, TimeSpan[] intervals);
    [ExtensionAttribute]
public static IRetryConfigurator Intervals(IRetryConfigurator configurator, Int32[] intervals);
    [ExtensionAttribute]
public static IRetryConfigurator Interval(IRetryConfigurator configurator, int retryCount, TimeSpan interval);
    [ExtensionAttribute]
public static IRetryConfigurator Interval(IRetryConfigurator configurator, int retryCount, int interval);
    [ExtensionAttribute]
public static IRetryConfigurator Exponential(IRetryConfigurator configurator, int retryLimit, TimeSpan minInterval, TimeSpan maxInterval, TimeSpan intervalDelta);
    [ExtensionAttribute]
public static IRetryConfigurator Incremental(IRetryConfigurator configurator, int retryLimit, TimeSpan initialInterval, TimeSpan intervalIncrement);
}
public interface GreenPipes.RetryContext {
    public CancellationToken CancellationToken { get; }
    public Exception Exception { get; }
    public int RetryAttempt { get; }
    public int RetryCount { get; }
    public Nullable`1<TimeSpan> Delay { get; }
    public Type ContextType { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual Exception get_Exception();
    public abstract virtual int get_RetryAttempt();
    public abstract virtual int get_RetryCount();
    public abstract virtual Nullable`1<TimeSpan> get_Delay();
    public abstract virtual Type get_ContextType();
    public abstract virtual Task RetryFaulted(Exception exception);
    public abstract virtual Task PreRetry();
}
public interface GreenPipes.RetryContext`1 {
    public TContext Context { get; }
    public abstract virtual TContext get_Context();
    public abstract virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
}
public interface GreenPipes.RetryPolicyContext`1 {
    public TContext Context { get; }
    public abstract virtual TContext get_Context();
    public abstract virtual bool CanRetry(Exception exception, RetryContext`1& retryContext);
    public abstract virtual Task RetryFaulted(Exception exception);
    public abstract virtual void Cancel();
}
public class GreenPipes.ScopePipeContext : object {
    private PipeContext _context;
    private IPayloadCache _payloadCache;
    public CancellationToken CancellationToken { get; }
    private IPayloadCache PayloadCache { get; }
    protected ScopePipeContext(PipeContext context);
    protected ScopePipeContext(PipeContext context, Object[] payloads);
    public virtual CancellationToken get_CancellationToken();
    private IPayloadCache get_PayloadCache();
    public virtual bool HasPayloadType(Type payloadType);
    public virtual bool TryGetPayload(T& payload);
    public virtual T GetOrAddPayload(PayloadFactory`1<T> payloadFactory);
    public virtual T AddOrUpdatePayload(PayloadFactory`1<T> addFactory, UpdatePayloadFactory`1<T> updateFactory);
}
public class GreenPipes.Specifications.AsyncDelegatePipeSpecification`1 : object {
    private Func`2<T, Task> _callback;
    public AsyncDelegatePipeSpecification`1(Func`2<T, Task> callback);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.AsyncDelegatePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.BindPipeSpecification`2 : object {
    private IPipeConfigurator`1<TLeft> _contextPipeConfigurator;
    private IBuildPipeConfigurator`1<BindContext`2<TLeft, TRight>> _pipeConfigurator;
    private IPipeContextSource`2<TRight, TLeft> _source;
    private IPipeConfigurator`1<TLeft> GreenPipes.Configurators.IBindConfigurator<TLeft,TRight>.ContextPipe { get; }
    public BindPipeSpecification`2(IPipeContextSource`2<TRight, TLeft> source);
    private sealed virtual override IPipeConfigurator`1<TLeft> GreenPipes.Configurators.IBindConfigurator<TLeft,TRight>.get_ContextPipe();
    private sealed virtual override void GreenPipes.IPipeConfigurator<GreenPipes.BindContext<TLeft,TRight>>.AddPipeSpecification(IPipeSpecification`1<BindContext`2<TLeft, TRight>> specification);
    private sealed virtual override void GreenPipes.IPipeSpecification<TLeft>.Apply(IPipeBuilder`1<TLeft> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.BindPipeSpecification`2/<GreenPipes-ISpecification-Validate>d__8")]
private sealed virtual override IEnumerable`1<ValidationResult> GreenPipes.ISpecification.Validate();
}
public class GreenPipes.Specifications.CircuitBreakerPipeSpecification`1 : ExceptionSpecification {
    private Settings<T> _settings;
    unknown TimeSpan TrackingPeriod {public set; }
    unknown int TripThreshold {public set; }
    unknown int ActiveThreshold {public set; }
    unknown TimeSpan ResetInterval {public set; }
    unknown IPipeRouter Router {public set; }
    public sealed virtual void set_TrackingPeriod(TimeSpan value);
    public sealed virtual void set_TripThreshold(int value);
    public sealed virtual void set_ActiveThreshold(int value);
    public sealed virtual void set_ResetInterval(TimeSpan value);
    public sealed virtual void set_Router(IPipeRouter value);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.CircuitBreakerPipeSpecification`1/<Validate>d__13")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    [IteratorStateMachineAttribute("GreenPipes.Specifications.CircuitBreakerPipeSpecification`1/<IntervalTimeout>d__14")]
private IEnumerable`1<TimeSpan> IntervalTimeout(TimeSpan interval);
}
public class GreenPipes.Specifications.ConcurrencyLimitPipeSpecification`1 : object {
    private int _concurrencyLimit;
    private IPipeRouter _router;
    public ConcurrencyLimitPipeSpecification`1(int concurrencyLimit, IPipeRouter router);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.ConcurrencyLimitPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.ConfiguratorPipeConnectorSpecification`1 : object {
    private IBuildPipeConfigurator`1<TContext> _configurator;
    public sealed virtual void AddPipeSpecification(IPipeSpecification`1<TContext> specification);
    public sealed virtual void Connect(IPipeConnector connector);
    public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.ContextFilterPipeSpecification`1 : object {
    private Func`2<TContext, Task`1<bool>> _filter;
    public ContextFilterPipeSpecification`1(Func`2<TContext, Task`1<bool>> filter);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.ContextFilterPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.DelegatePipeSpecification`1 : object {
    private Action`1<T> _callback;
    public DelegatePipeSpecification`1(Action`1<T> callback);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.DelegatePipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.DispatchPipeSpecification`1 : object {
    private IPipeContextConverterFactory`1<TInput> _pipeContextConverterFactory;
    private IList`1<IPipeConnectorSpecification> _specifications;
    public DispatchPipeSpecification`1(IPipeContextConverterFactory`1<TInput> pipeContextConverterFactory);
    private sealed virtual override void GreenPipes.Configurators.IDispatchConfigurator<TInput>.Pipe(Action`1<IPipeConfigurator`1<T>> configurePipe);
    public sealed virtual void Apply(IPipeBuilder`1<TInput> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.DispatchPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public abstract class GreenPipes.Specifications.ExceptionSpecification : object {
    private CompositeFilter`1<Exception> _exceptionFilter;
    [CompilerGeneratedAttribute]
private IExceptionFilter <Filter>k__BackingField;
    protected IExceptionFilter Filter { get; }
    [CompilerGeneratedAttribute]
protected IExceptionFilter get_Filter();
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Handle(Type[] exceptionTypes);
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Handle();
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Handle(Func`2<T, bool> filter);
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Ignore(Type[] exceptionTypes);
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Ignore();
    private sealed virtual override void GreenPipes.Configurators.IExceptionConfigurator.Ignore(Func`2<T, bool> filter);
    private static bool Match(Exception exception, Type[] exceptionTypes);
    private static bool Match(Exception exception, Func`2<T, bool> filter);
}
public class GreenPipes.Specifications.FilterPipeSpecification`1 : object {
    private IFilter`1<TContext> _filter;
    public FilterPipeSpecification`1(IFilter`1<TContext> filter);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.FilterPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.ForkPipeSpecification`1 : object {
    private IPipe`1<TContext> _pipe;
    public ForkPipeSpecification`1(IPipe`1<TContext> pipe);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.ForkPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.InlineFilterPipeSpecification`1 : object {
    private InlineFilterMethod`1<TContext> _filterMethod;
    public InlineFilterPipeSpecification`1(InlineFilterMethod`1<TContext> filterMethod);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.InlineFilterPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.InterceptPipeSpecification`1 : object {
    private IPipe`1<TContext> _pipe;
    public InterceptPipeSpecification`1(IPipe`1<TContext> pipe);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.InterceptPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.LatestPipeSpecification`1 : object {
    private LatestFilterCreated`1<T> _created;
    unknown LatestFilterCreated`1<T> GreenPipes.ILatestConfigurator<T>.Created {private set; }
    private sealed virtual override void GreenPipes.ILatestConfigurator<T>.set_Created(LatestFilterCreated`1<T> value);
    private sealed virtual override void GreenPipes.IPipeSpecification<T>.Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.LatestPipeSpecification`1/<GreenPipes-ISpecification-Validate>d__4")]
private sealed virtual override IEnumerable`1<ValidationResult> GreenPipes.ISpecification.Validate();
}
public class GreenPipes.Specifications.PartitionerPipeSpecification`1 : object {
    private PartitionKeyProvider`1<T> _keyProvider;
    private int _partitionCount;
    private IPartitioner _partitioner;
    public PartitionerPipeSpecification`1(PartitionKeyProvider`1<T> keyProvider, int partitionCount);
    public PartitionerPipeSpecification`1(PartitionKeyProvider`1<T> keyProvider, IPartitioner partitioner);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.PartitionerPipeSpecification`1/<Validate>d__6")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.RateLimitPipeSpecification`1 : object {
    private TimeSpan _interval;
    private int _rateLimit;
    private IPipeRouter _router;
    public RateLimitPipeSpecification`1(int rateLimit, TimeSpan interval, IPipeRouter router);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.RateLimitPipeSpecification`1/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.RepeatPipeSpecification`1 : object {
    private CancellationToken _cancellationToken;
    public RepeatPipeSpecification`1(CancellationToken cancellationToken);
    public sealed virtual void Apply(IPipeBuilder`1<T> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.RepeatPipeSpecification`1/<Validate>d__3")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
public class GreenPipes.Specifications.RescuePipeSpecification`2 : ExceptionSpecification {
    private IPipeConfigurator`1<TContext> _contextPipeConfigurator;
    private IBuildPipeConfigurator`1<TRescue> _pipeConfigurator;
    private RescueContextFactory`2<TContext, TRescue> _rescueContextFactory;
    private IPipeConfigurator`1<TContext> GreenPipes.Configurators.IRescueConfigurator<TContext,TRescue>.ContextPipe { get; }
    public RescuePipeSpecification`2(RescueContextFactory`2<TContext, TRescue> rescueContextFactory);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.RescuePipeSpecification`2/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    private sealed virtual override IPipeConfigurator`1<TContext> GreenPipes.Configurators.IRescueConfigurator<TContext,TRescue>.get_ContextPipe();
    private sealed virtual override void GreenPipes.IPipeConfigurator<TRescue>.AddPipeSpecification(IPipeSpecification`1<TRescue> specification);
}
public class GreenPipes.Specifications.RetryPipeSpecification`1 : ExceptionSpecification {
    private RetryObservable _observers;
    private RetryPolicyFactory _policyFactory;
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.RetryPipeSpecification`1/<Validate>d__4")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
    public sealed virtual void SetRetryPolicy(RetryPolicyFactory factory);
    private sealed virtual override ConnectHandle GreenPipes.IRetryObserverConnector.ConnectRetryObserver(IRetryObserver observer);
}
public class GreenPipes.Specifications.SplitFilterPipeSpecification`2 : object {
    private MergeFilterContextProvider`2<TContext, TFilter> _contextProvider;
    private FilterContextProvider`2<TFilter, TContext> _inputContextProvider;
    private IPipeSpecification`1<TFilter> _specification;
    public SplitFilterPipeSpecification`2(IPipeSpecification`1<TFilter> specification, MergeFilterContextProvider`2<TContext, TFilter> contextProvider, FilterContextProvider`2<TFilter, TContext> inputContextProvider);
    public sealed virtual void Apply(IPipeBuilder`1<TContext> builder);
    [IteratorStateMachineAttribute("GreenPipes.Specifications.SplitFilterPipeSpecification`2/<Validate>d__5")]
public sealed virtual IEnumerable`1<ValidationResult> Validate();
}
[ExtensionAttribute]
public static class GreenPipes.SupervisorExtensions : object {
    [ExtensionAttribute]
public static IPipeContextAgent`1<T> AddContext(ISupervisor supervisor, T context);
    [ExtensionAttribute]
public static IPipeContextAgent`1<T> AddContext(ISupervisor supervisor, Task`1<T> context);
    [ExtensionAttribute]
public static IActivePipeContextAgent`1<T> AddActiveContext(ISupervisor supervisor, PipeContextHandle`1<T> contextHandle, Task`1<T> context);
    [ExtensionAttribute]
public static IActivePipeContextAgent`1<T> AddActiveContext(ISupervisor supervisor, PipeContextHandle`1<T> contextHandle, T context);
    [ExtensionAttribute]
public static IAsyncPipeContextAgent`1<T> AddAsyncContext(ISupervisor supervisor);
}
public class GreenPipes.UpdatePayloadFactory`1 : MulticastDelegate {
    public UpdatePayloadFactory`1(object object, IntPtr method);
    public virtual TPayload Invoke(TPayload existing);
    public virtual IAsyncResult BeginInvoke(TPayload existing, AsyncCallback callback, object object);
    public virtual TPayload EndInvoke(IAsyncResult result);
}
public class GreenPipes.Util.Connectable`1 : object {
    private Dictionary`2<long, T> _connections;
    private T[] _connected;
    private long _nextId;
    public int Count { get; }
    public int get_Count();
    public ConnectHandle Connect(T connection);
    public Task ForEachAsync(Func`2<T, Task> callback);
    public bool All(Func`2<T, bool> callback);
    private void Disconnect(long id);
}
public class GreenPipes.Util.EmptyConnectHandle : object {
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void GreenPipes.ConnectHandle.Disconnect();
}
[ExtensionAttribute]
public static class GreenPipes.Util.TaskUtil : object {
    internal static Task Canceled { get; }
    public static Task Completed { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<bool> True { get; }
    internal static Task get_Canceled();
    public static Task get_Completed();
    public static Task`1<bool> get_False();
    public static Task`1<bool> get_True();
    public static Task`1<T> Default();
    public static Task`1<T> Faulted(Exception exception);
    public static Task`1<T> Cancelled();
    public static TaskCompletionSource`1<T> GetTask(TaskCreationOptions options);
    public static TaskCompletionSource`1<bool> GetTask(TaskCreationOptions options);
    [ExtensionAttribute]
public static CancellationTokenRegistration RegisterTask(CancellationToken cancellationToken, Task& cancelTask);
    private static void SetCompleted(object obj);
    [ExtensionAttribute]
public static CancellationTokenRegistration RegisterIfCanBeCanceled(CancellationToken cancellationToken, CancellationTokenSource source);
    private static void Cancel(object obj);
    [ExtensionAttribute]
public static void SetCompleted(TaskCompletionSource`1<bool> source);
}
public class GreenPipes.Validation.ConfigurationValidationResult : object {
    [CompilerGeneratedAttribute]
private ValidationResultDisposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public ValidationResultDisposition Disposition { get; }
    public string Key { get; }
    public string Value { get; }
    public string Message { get; }
    public ConfigurationValidationResult(ValidationResultDisposition disposition, string key, string value, string message);
    public ConfigurationValidationResult(ValidationResultDisposition disposition, string key, string message);
    public ConfigurationValidationResult(ValidationResultDisposition disposition, string message);
    [CompilerGeneratedAttribute]
public sealed virtual ValidationResultDisposition get_Disposition();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    public virtual string ToString();
}
public class GreenPipes.Validation.PipeConfigurationResult : object {
    private List`1<ValidationResult> _results;
    public bool ContainsFailure { get; }
    public PipeConfigurationResult(IEnumerable`1<ValidationResult> results);
    public sealed virtual bool get_ContainsFailure();
    public sealed virtual string GetMessage(string header);
    public sealed virtual bool Any();
}
public interface GreenPipes.ValidationResult {
    public ValidationResultDisposition Disposition { get; }
    public string Message { get; }
    public string Key { get; }
    public string Value { get; }
    public abstract virtual ValidationResultDisposition get_Disposition();
    public abstract virtual string get_Message();
    public abstract virtual string get_Key();
    public abstract virtual string get_Value();
}
public enum GreenPipes.ValidationResultDisposition : Enum {
    public int value__;
    public static ValidationResultDisposition Success;
    public static ValidationResultDisposition Warning;
    public static ValidationResultDisposition Failure;
}
[ExtensionAttribute]
public static class GreenPipes.ValidationResultExtensions : object {
    [ExtensionAttribute]
public static ValidationResult Failure(ISpecification configurator, string message);
    [ExtensionAttribute]
public static ValidationResult Failure(ISpecification configurator, string key, string message);
    [ExtensionAttribute]
public static ValidationResult Failure(ISpecification configurator, string key, string value, string message);
    [ExtensionAttribute]
public static ValidationResult Warning(ISpecification configurator, string message);
    [ExtensionAttribute]
public static ValidationResult Warning(ISpecification configurator, string key, string message);
    [ExtensionAttribute]
public static ValidationResult Warning(ISpecification configurator, string key, string value, string message);
    [ExtensionAttribute]
public static ValidationResult Success(ISpecification configurator, string message);
    [ExtensionAttribute]
public static ValidationResult Success(ISpecification configurator, string key, string message);
    [ExtensionAttribute]
public static ValidationResult Success(ISpecification configurator, string key, string value, string message);
    [ExtensionAttribute]
public static ValidationResult WithParentKey(ValidationResult result, string parentKey);
}
public class GreenPipes.ValueFactoryException : Exception {
    public ValueFactoryException(string message);
    protected ValueFactoryException(SerializationInfo info, StreamingContext context);
    public ValueFactoryException(string message, Exception innerException);
}
