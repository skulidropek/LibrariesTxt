[DataContractAttribute]
public class GSF.Adapters.Adapter : MarshalByRefObject {
    private DateTime m_created;
    private string m_hostFile;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private bool m_enabled;
    private bool m_disposed;
    private bool m_initialized;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<UpdateType, string>> StatusUpdate;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<string, Exception>> ExecutionException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public string TypeName { get; public set; }
    [XmlIgnoreAttribute]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public string HostFile { get; public set; }
    [XmlIgnoreAttribute]
public bool Enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool IsDisposed { get; }
    [XmlIgnoreAttribute]
public bool PersistSettings { get; public set; }
    [XmlIgnoreAttribute]
public string SettingsCategory { get; public set; }
    public double MemoryUsage { get; }
    public double ProcessorUsage { get; }
    public string Name { get; }
    public string Status { get; }
    public AppDomain Domain { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusUpdate(EventHandler`1<EventArgs`2<UpdateType, string>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusUpdate(EventHandler`1<EventArgs`2<UpdateType, string>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ExecutionException(EventHandler`1<EventArgs`2<string, Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ExecutionException(EventHandler`1<EventArgs`2<string, Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    public virtual string get_HostFile();
    public virtual void set_HostFile(string value);
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public virtual bool get_PersistSettings();
    public virtual void set_PersistSettings(bool value);
    public virtual string get_SettingsCategory();
    public virtual void set_SettingsCategory(string value);
    public sealed virtual double get_MemoryUsage();
    public sealed virtual double get_ProcessorUsage();
    public virtual string get_Name();
    public virtual string get_Status();
    public virtual AppDomain get_Domain();
    public sealed virtual void Dispose();
    public virtual void Initialize();
    public virtual void SaveSettings();
    public virtual void LoadSettings();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnStatusUpdate(UpdateType updateType, string updateMessage, Object[] args);
    protected virtual void OnExecutionException(string activityDescription, Exception encounteredException);
    protected virtual void OnDisposed();
}
public enum GSF.Adapters.AdapterFileFormat : Enum {
    public int value__;
    public static AdapterFileFormat Assembly;
    public static AdapterFileFormat SerializedBin;
    public static AdapterFileFormat SerializedXml;
}
public class GSF.Adapters.AdapterLoader`1 : object {
    public static string DefaultAdapterDirectory;
    public static string DefaultAdapterFileExtension;
    public static AdapterFileFormat DefaultAdapterFileFormat;
    public static bool DefaultWatchForAdapters;
    public static bool DefaultIsolateAdapters;
    public static bool DefaultMonitorAdapters;
    public static double DefaultAllowableProcessMemoryUsage;
    public static double DefaultAllowableProcessProcessorUsage;
    public static double DefaultAllowableAdapterMemoryUsage;
    public static double DefaultAllowableAdapterProcessorUsage;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> AdapterCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> AdapterLoaded;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> AdapterUnloaded;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> AdapterResourceUsageExceeded;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> AdapterLoadException;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<T, Exception>> OperationExecutionException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private string m_adapterDirectory;
    private string m_adapterFileExtension;
    private AdapterFileFormat m_adapterFileFormat;
    private bool m_watchForAdapters;
    private bool m_isolateAdapters;
    private bool m_monitorAdapters;
    private double m_allowableProcessMemoryUsage;
    private double m_allowableProcessProcessorUsage;
    private double m_allowableAdapterMemoryUsage;
    private double m_allowableAdapterProcessorUsage;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private ObservableCollection`1<T> m_adapters;
    private SafeFileWatcher m_adapterWatcher;
    private AsyncQueue`1<object> m_operationQueue;
    private Dictionary`2<Type, bool> m_enabledStates;
    private bool m_enabled;
    private bool m_disposed;
    private bool m_initialized;
    private Thread m_adapterMonitoringThread;
    public string AdapterDirectory { get; public set; }
    public string AdapterFileExtension { get; public set; }
    public AdapterFileFormat AdapterFileFormat { get; public set; }
    public bool WatchForAdapters { get; public set; }
    public bool IsolateAdapters { get; public set; }
    public bool MonitorAdapters { get; public set; }
    public double AllowableProcessMemoryUsage { get; public set; }
    public double AllowableProcessProcessorUsage { get; public set; }
    public double AllowableAdapterMemoryUsage { get; public set; }
    public double AllowableAdapterProcessorUsage { get; public set; }
    public bool PersistSettings { get; public set; }
    public string SettingsCategory { get; public set; }
    public bool Enabled { get; public set; }
    public bool IsDisposed { get; }
    public string Name { get; }
    public string Status { get; }
    public IList`1<T> Adapters { get; }
    protected SafeFileWatcher AdapterWatcher { get; }
    protected AsyncQueue`1<object> OperationQueue { get; }
    [CompilerGeneratedAttribute]
public void add_AdapterCreated(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_AdapterCreated(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_AdapterLoaded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_AdapterLoaded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_AdapterUnloaded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_AdapterUnloaded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_AdapterResourceUsageExceeded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_AdapterResourceUsageExceeded(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_AdapterLoadException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_AdapterLoadException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void add_OperationExecutionException(EventHandler`1<EventArgs`2<T, Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_OperationExecutionException(EventHandler`1<EventArgs`2<T, Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public string get_AdapterDirectory();
    public void set_AdapterDirectory(string value);
    public string get_AdapterFileExtension();
    public void set_AdapterFileExtension(string value);
    public AdapterFileFormat get_AdapterFileFormat();
    public void set_AdapterFileFormat(AdapterFileFormat value);
    public bool get_WatchForAdapters();
    public void set_WatchForAdapters(bool value);
    public bool get_IsolateAdapters();
    public void set_IsolateAdapters(bool value);
    public bool get_MonitorAdapters();
    public void set_MonitorAdapters(bool value);
    public double get_AllowableProcessMemoryUsage();
    public void set_AllowableProcessMemoryUsage(double value);
    public double get_AllowableProcessProcessorUsage();
    public void set_AllowableProcessProcessorUsage(double value);
    public double get_AllowableAdapterMemoryUsage();
    public void set_AllowableAdapterMemoryUsage(double value);
    public double get_AllowableAdapterProcessorUsage();
    public void set_AllowableAdapterProcessorUsage(double value);
    public sealed virtual bool get_PersistSettings();
    public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public sealed virtual string get_Name();
    public sealed virtual string get_Status();
    public IList`1<T> get_Adapters();
    protected SafeFileWatcher get_AdapterWatcher();
    protected AsyncQueue`1<object> get_OperationQueue();
    public sealed virtual void Dispose();
    public virtual void Initialize();
    public virtual void Initialize(IEnumerable`1<Type> adapterTypes);
    public sealed virtual void SaveSettings();
    public sealed virtual void LoadSettings();
    protected virtual void ProcessAdapter(string adapterFile);
    protected virtual void ProcessAdapter(Type adapterType);
    protected virtual void MonitorAdapterResources();
    protected virtual double GetMemoryUsage(Process process);
    protected virtual double GetProcessorUsage(Process process);
    protected virtual void ExecuteAdapterOperation(T adapter, object data);
    protected virtual void Dispose(bool disposing);
    protected virtual void OnAdapterCreated(T adapter);
    protected virtual void OnAdapterLoaded(T adapter);
    protected virtual void OnAdapterUnloaded(T adapter);
    protected virtual void OnAdapterResourceUsageExceeded(T adapter);
    protected virtual void OnAdapterLoadException(T adapter, Exception exception);
    protected virtual void OnOperationExecutionException(T adapter, Exception exception);
    private static string GetAdapterFilePath(T adapter);
    private static bool SetAdapterFilePath(T adapter, string adapterFile);
    private void SaveCurrentState();
    private void ExecuteOperation(object data);
    private void AdapterWatcher_Events(object sender, FileSystemEventArgs e);
    private void Adapters_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public interface GSF.Adapters.IAdapter {
    public string TypeName { get; public set; }
    public string HostFile { get; public set; }
    public AppDomain Domain { get; }
    public double MemoryUsage { get; }
    public double ProcessorUsage { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_StatusUpdate(EventHandler`1<EventArgs`2<UpdateType, string>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StatusUpdate(EventHandler`1<EventArgs`2<UpdateType, string>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ExecutionException(EventHandler`1<EventArgs`2<string, Exception>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ExecutionException(EventHandler`1<EventArgs`2<string, Exception>> value);
    public abstract virtual string get_TypeName();
    public abstract virtual void set_TypeName(string value);
    public abstract virtual string get_HostFile();
    public abstract virtual void set_HostFile(string value);
    public abstract virtual AppDomain get_Domain();
    public abstract virtual double get_MemoryUsage();
    public abstract virtual double get_ProcessorUsage();
}
[CompilerGeneratedAttribute]
internal class GSF.Adapters.NamespaceDoc : object {
}
[AttributeUsageAttribute("2112")]
public class GSF.Annotations.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [NotNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2176")]
public class GSF.Annotations.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcAreaAttribute : PathReferenceAttribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [NotNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    public AspMvcAreaMasterLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcAreaViewLocationFormatAttribute : Attribute {
    public AspMvcAreaViewLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("2112")]
public class GSF.Annotations.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [NotNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcMasterLocationFormatAttribute : Attribute {
    public AspMvcMasterLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class GSF.Annotations.AspMvcPartialViewAttribute : PathReferenceAttribute {
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcPartialViewLocationFormatAttribute : Attribute {
    public AspMvcPartialViewLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("68")]
public class GSF.Annotations.AspMvcSupressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class GSF.Annotations.AspMvcViewAttribute : PathReferenceAttribute {
}
[AttributeUsageAttribute("1")]
public class GSF.Annotations.AspMvcViewLocationFormatAttribute : Attribute {
    public AspMvcViewLocationFormatAttribute(string format);
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
public class GSF.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("6592")]
public class GSF.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class GSF.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class GSF.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("2432")]
public class GSF.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("2432")]
public class GSF.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[FlagsAttribute]
public enum GSF.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
public enum GSF.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class GSF.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("4")]
public class GSF.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("64")]
public class GSF.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("6592")]
public class GSF.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class GSF.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [NotNullAttribute]
public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[MeansImplicitUseAttribute]
public class GSF.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [NotNullAttribute]
public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
public class GSF.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class GSF.Annotations.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class GSF.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[AttributeUsageAttribute("32767")]
public class GSF.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
public enum GSF.ApplicationType : Enum {
    public int value__;
    public static ApplicationType Unknown;
    public static ApplicationType Native;
    public static ApplicationType WindowsGui;
    public static ApplicationType WindowsCui;
    public static ApplicationType OS2Cui;
    public static ApplicationType PosixCui;
    public static ApplicationType NativeWindows;
    public static ApplicationType WindowsCEGui;
    public static ApplicationType Web;
}
[ExtensionAttribute]
public static class GSF.ArrayExtensions : object {
    [ExtensionAttribute]
public static void ValidateParameters(T[] array, int startIndex, int length);
    private static void RaiseValidationError(T[] array, int startIndex, int length);
    [ExtensionAttribute]
public static T[] BlockCopy(T[] array, int startIndex, int length);
    [ExtensionAttribute]
public static T[] Combine(T[] source, T[] other);
    [ExtensionAttribute]
public static T[] Combine(T[] source, int sourceOffset, int sourceCount, T[] other, int otherOffset, int otherCount);
    [ExtensionAttribute]
public static T[] Combine(T[] source, T[] other1, T[] other2);
    [ExtensionAttribute]
public static T[] Combine(T[] source, T[] other1, T[] other2, T[] other3);
    [ExtensionAttribute]
public static T[] Combine(T[] source, T[] other1, T[] other2, T[] other3, T[] other4);
    [ExtensionAttribute]
public static T[] Combine(T[][] arrays);
    [ExtensionAttribute]
public static int IndexOfSequence(T[] array, T[] sequenceToFind);
    [ExtensionAttribute]
public static int IndexOfSequence(T[] array, T[] sequenceToFind, int startIndex);
    [ExtensionAttribute]
public static int IndexOfSequence(T[] array, T[] sequenceToFind, int startIndex, int length);
    [ExtensionAttribute]
public static int CompareTo(T[] source, T[] other);
    [ExtensionAttribute]
public static int CompareTo(T[] source, int sourceOffset, T[] other, int otherOffset, int count);
    [ExtensionAttribute]
public static Byte[] Combine(Byte[] source, Byte[] other1, Byte[] other2);
    [ExtensionAttribute]
public static Byte[] Combine(Byte[] source, Byte[] other1, Byte[] other2, Byte[] other3);
    [ExtensionAttribute]
public static Byte[] Combine(Byte[] source, Byte[] other1, Byte[] other2, Byte[] other3, Byte[] other4);
    [ExtensionAttribute]
public static Byte[] Combine(Byte[][] buffers);
    [ExtensionAttribute]
public static T ReadStructure(Byte[] bytes);
    [ExtensionAttribute]
public static T ReadStructure(BinaryReader reader);
}
public enum GSF.BaselineTimeInterval : Enum {
    public int value__;
    public static BaselineTimeInterval Second;
    public static BaselineTimeInterval Minute;
    public static BaselineTimeInterval Hour;
    public static BaselineTimeInterval Day;
    public static BaselineTimeInterval Month;
    public static BaselineTimeInterval Year;
}
public class GSF.BigBinaryValue : BinaryValueBase`1<BigEndianOrder> {
    public BigBinaryValue(Byte[] buffer, int startIndex, int length);
    public BigBinaryValue(Byte[] buffer);
    public BigBinaryValue(TypeCode typeCode, Byte[] buffer, int startIndex, int length);
    public BigBinaryValue(TypeCode typeCode, Byte[] buffer);
    private static BigBinaryValue();
    public virtual string ToString();
    public BigBinaryValue ConvertToType(TypeCode typeCode);
    public static byte op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(byte value);
    public static short op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(short value);
    public static ushort op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(ushort value);
    public static Int24 op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(Int24 value);
    public static UInt24 op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(UInt24 value);
    public static int op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(int value);
    public static UInt32 op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(UInt32 value);
    public static long op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(long value);
    public static ulong op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(ulong value);
    public static float op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(float value);
    public static double op_Implicit(BigBinaryValue value);
    public static BigBinaryValue op_Implicit(double value);
}
public static class GSF.BigEndian : object {
    public static bool ToBoolean(Byte* buffer);
    public static char ToChar(Byte* buffer);
    public static double ToDouble(Byte* buffer);
    public static short ToInt16(Byte* buffer);
    public static Int24 ToInt24(Byte* buffer);
    public static int ToInt32(Byte* buffer);
    public static long ToInt64(Byte* buffer);
    public static float ToSingle(Byte* buffer);
    public static ushort ToUInt16(Byte* buffer);
    public static UInt24 ToUInt24(Byte* buffer);
    public static UInt32 ToUInt32(Byte* buffer);
    public static ulong ToUInt64(Byte* buffer);
    public static decimal ToDecimal(Byte* buffer);
    public static bool ToBoolean(Byte[] buffer, int startIndex);
    public static char ToChar(Byte[] buffer, int startIndex);
    public static double ToDouble(Byte[] buffer, int startIndex);
    public static short ToInt16(Byte[] buffer, int startIndex);
    public static Int24 ToInt24(Byte[] buffer, int startIndex);
    public static int ToInt32(Byte[] buffer, int startIndex);
    public static long ToInt64(Byte[] buffer, int startIndex);
    public static float ToSingle(Byte[] buffer, int startIndex);
    public static ushort ToUInt16(Byte[] buffer, int startIndex);
    public static UInt24 ToUInt24(Byte[] buffer, int startIndex);
    public static UInt32 ToUInt32(Byte[] buffer, int startIndex);
    public static ulong ToUInt64(Byte[] buffer, int startIndex);
    public static decimal ToDecimal(Byte[] buffer, int startIndex);
    public static Byte[] GetBytes(T value);
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(Int24 value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(float value);
    public static Byte[] GetBytes(ushort value);
    public static Byte[] GetBytes(UInt24 value);
    public static Byte[] GetBytes(UInt32 value);
    public static Byte[] GetBytes(ulong value);
    public static Byte[] GetBytes(decimal value);
    public static int CopyBytes(T value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(bool value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(char value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(double value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(short value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(Int24 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(int value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(long value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(float value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(ushort value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(UInt24 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(UInt32 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(ulong value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(decimal value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(T value, Byte* destination);
    public static int CopyBytes(bool value, Byte* destination);
    public static int CopyBytes(char value, Byte* destination);
    public static int CopyBytes(double value, Byte* destination);
    public static int CopyBytes(short value, Byte* destination);
    public static int CopyBytes(Int24 value, Byte* destination);
    public static int CopyBytes(int value, Byte* destination);
    public static int CopyBytes(long value, Byte* destination);
    public static int CopyBytes(float value, Byte* destination);
    public static int CopyBytes(ushort value, Byte* destination);
    public static int CopyBytes(UInt24 value, Byte* destination);
    public static int CopyBytes(UInt32 value, Byte* destination);
    public static int CopyBytes(ulong value, Byte* destination);
    public static int CopyBytes(decimal value, Byte* destination);
}
public class GSF.BigEndianOrder : EndianOrder {
    private static BigEndianOrder s_endianOrder;
    public static BigEndianOrder Default { get; }
    private static BigEndianOrder();
    public static BigEndianOrder get_Default();
}
public static class GSF.BinaryCodedDecimal : object {
    private static byte TenP1;
    private static ushort TenP2;
    private static UInt32 TenP4;
    private static ulong TenP8;
    public static byte Decode(byte bcd);
    public static ushort Decode(ushort bcd);
    public static UInt32 Decode(UInt32 bcd);
    public static ulong Decode(ulong bcd);
    public static byte Encode(byte value);
    public static ushort Encode(ushort value);
    public static UInt32 Encode(UInt32 value);
    public static ulong Encode(ulong value);
}
public abstract class GSF.BinaryValueBase`1 : object {
    private TypeCode m_typeCode;
    private Byte[] m_buffer;
    protected static TEndianOrder s_endianOrder;
    public TypeCode TypeCode { get; public set; }
    public Byte[] Buffer { get; public set; }
    protected BinaryValueBase`1(TypeCode typeCode, Byte[] buffer, int startIndex, int length);
    public TypeCode get_TypeCode();
    public void set_TypeCode(TypeCode value);
    public Byte[] get_Buffer();
    public void set_Buffer(Byte[] value);
    public byte ToByte();
    public short ToInt16();
    public ushort ToUInt16();
    public Int24 ToInt24();
    public UInt24 ToUInt24();
    public int ToInt32();
    public UInt32 ToUInt32();
    public long ToInt64();
    public ulong ToUInt64();
    public float ToSingle();
    public double ToDouble();
    private void ValidateBufferLength(TypeCode typeCode, int size);
}
[ExtensionAttribute]
public static class GSF.BitExtensions : object {
    public static Bits BitVal(int bit);
    [ExtensionAttribute]
public static sbyte SetBits(sbyte source, Bits bits);
    [ExtensionAttribute]
public static sbyte SetBits(sbyte source, sbyte bits);
    [ExtensionAttribute]
public static byte SetBits(byte source, Bits bits);
    [ExtensionAttribute]
public static byte SetBits(byte source, byte bits);
    [ExtensionAttribute]
public static short SetBits(short source, Bits bits);
    [ExtensionAttribute]
public static short SetBits(short source, short bits);
    [ExtensionAttribute]
public static ushort SetBits(ushort source, Bits bits);
    [ExtensionAttribute]
public static ushort SetBits(ushort source, ushort bits);
    [ExtensionAttribute]
public static Int24 SetBits(Int24 source, Bits bits);
    [ExtensionAttribute]
public static Int24 SetBits(Int24 source, Int24 bits);
    [ExtensionAttribute]
public static UInt24 SetBits(UInt24 source, Bits bits);
    [ExtensionAttribute]
public static UInt24 SetBits(UInt24 source, UInt24 bits);
    [ExtensionAttribute]
public static int SetBits(int source, Bits bits);
    [ExtensionAttribute]
public static int SetBits(int source, int bits);
    [ExtensionAttribute]
public static UInt32 SetBits(UInt32 source, Bits bits);
    [ExtensionAttribute]
public static UInt32 SetBits(UInt32 source, UInt32 bits);
    [ExtensionAttribute]
public static long SetBits(long source, Bits bits);
    [ExtensionAttribute]
public static long SetBits(long source, long bits);
    [ExtensionAttribute]
public static ulong SetBits(ulong source, Bits bits);
    [ExtensionAttribute]
public static ulong SetBits(ulong source, ulong bits);
    [ExtensionAttribute]
public static sbyte ClearBits(sbyte source, Bits bits);
    [ExtensionAttribute]
public static sbyte ClearBits(sbyte source, sbyte bits);
    [ExtensionAttribute]
public static byte ClearBits(byte source, Bits bits);
    [ExtensionAttribute]
public static byte ClearBits(byte source, byte bits);
    [ExtensionAttribute]
public static short ClearBits(short source, Bits bits);
    [ExtensionAttribute]
public static short ClearBits(short source, short bits);
    [ExtensionAttribute]
public static ushort ClearBits(ushort source, Bits bits);
    [ExtensionAttribute]
public static ushort ClearBits(ushort source, ushort bits);
    [ExtensionAttribute]
public static Int24 ClearBits(Int24 source, Bits bits);
    [ExtensionAttribute]
public static Int24 ClearBits(Int24 source, Int24 bits);
    [ExtensionAttribute]
public static UInt24 ClearBits(UInt24 source, Bits bits);
    [ExtensionAttribute]
public static UInt24 ClearBits(UInt24 source, UInt24 bits);
    [ExtensionAttribute]
public static int ClearBits(int source, Bits bits);
    [ExtensionAttribute]
public static int ClearBits(int source, int bits);
    [ExtensionAttribute]
public static UInt32 ClearBits(UInt32 source, Bits bits);
    [ExtensionAttribute]
public static UInt32 ClearBits(UInt32 source, UInt32 bits);
    [ExtensionAttribute]
public static long ClearBits(long source, Bits bits);
    [ExtensionAttribute]
public static long ClearBits(long source, long bits);
    [ExtensionAttribute]
public static ulong ClearBits(ulong source, Bits bits);
    [ExtensionAttribute]
public static ulong ClearBits(ulong source, ulong bits);
    [ExtensionAttribute]
public static bool CheckBits(sbyte source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(sbyte source, sbyte bits);
    [ExtensionAttribute]
public static bool CheckBits(sbyte source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(sbyte source, sbyte bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(byte source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(byte source, byte bits);
    [ExtensionAttribute]
public static bool CheckBits(byte source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(byte source, byte bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(short source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(short source, short bits);
    [ExtensionAttribute]
public static bool CheckBits(short source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(short source, short bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(ushort source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(ushort source, ushort bits);
    [ExtensionAttribute]
public static bool CheckBits(ushort source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(ushort source, ushort bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(Int24 source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(Int24 source, Int24 bits);
    [ExtensionAttribute]
public static bool CheckBits(Int24 source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(Int24 source, Int24 bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(UInt24 source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(UInt24 source, UInt24 bits);
    [ExtensionAttribute]
public static bool CheckBits(UInt24 source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(UInt24 source, UInt24 bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(int source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(int source, int bits);
    [ExtensionAttribute]
public static bool CheckBits(int source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(int source, int bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(UInt32 source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(UInt32 source, UInt32 bits);
    [ExtensionAttribute]
public static bool CheckBits(UInt32 source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(UInt32 source, UInt32 bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(long source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(long source, long bits);
    [ExtensionAttribute]
public static bool CheckBits(long source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(long source, long bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(ulong source, Bits bits);
    [ExtensionAttribute]
public static bool CheckBits(ulong source, ulong bits);
    [ExtensionAttribute]
public static bool CheckBits(ulong source, Bits bits, bool allBits);
    [ExtensionAttribute]
public static bool CheckBits(ulong source, ulong bits, bool allBits);
    [ExtensionAttribute]
public static sbyte ToggleBits(sbyte source, Bits bits);
    [ExtensionAttribute]
public static sbyte ToggleBits(sbyte source, sbyte bits);
    [ExtensionAttribute]
public static byte ToggleBits(byte source, Bits bits);
    [ExtensionAttribute]
public static byte ToggleBits(byte source, byte bits);
    [ExtensionAttribute]
public static short ToggleBits(short source, Bits bits);
    [ExtensionAttribute]
public static short ToggleBits(short source, short bits);
    [ExtensionAttribute]
public static ushort ToggleBits(ushort source, Bits bits);
    [ExtensionAttribute]
public static ushort ToggleBits(ushort source, ushort bits);
    [ExtensionAttribute]
public static Int24 ToggleBits(Int24 source, Bits bits);
    [ExtensionAttribute]
public static Int24 ToggleBits(Int24 source, Int24 bits);
    [ExtensionAttribute]
public static UInt24 ToggleBits(UInt24 source, Bits bits);
    [ExtensionAttribute]
public static UInt24 ToggleBits(UInt24 source, UInt24 bits);
    [ExtensionAttribute]
public static int ToggleBits(int source, Bits bits);
    [ExtensionAttribute]
public static int ToggleBits(int source, int bits);
    [ExtensionAttribute]
public static UInt32 ToggleBits(UInt32 source, Bits bits);
    [ExtensionAttribute]
public static UInt32 ToggleBits(UInt32 source, UInt32 bits);
    [ExtensionAttribute]
public static long ToggleBits(long source, Bits bits);
    [ExtensionAttribute]
public static long ToggleBits(long source, long bits);
    [ExtensionAttribute]
public static ulong ToggleBits(ulong source, Bits bits);
    [ExtensionAttribute]
public static ulong ToggleBits(ulong source, ulong bits);
    [ExtensionAttribute]
public static sbyte GetMaskedValue(sbyte source, Bits bitmask);
    [ExtensionAttribute]
public static sbyte GetMaskedValue(sbyte source, sbyte bitmask);
    [ExtensionAttribute]
public static byte GetMaskedValue(byte source, Bits bitmask);
    [ExtensionAttribute]
public static byte GetMaskedValue(byte source, byte bitmask);
    [ExtensionAttribute]
public static short GetMaskedValue(short source, Bits bitmask);
    [ExtensionAttribute]
public static short GetMaskedValue(short source, short bitmask);
    [ExtensionAttribute]
public static ushort GetMaskedValue(ushort source, Bits bitmask);
    [ExtensionAttribute]
public static ushort GetMaskedValue(ushort source, ushort bitmask);
    [ExtensionAttribute]
public static Int24 GetMaskedValue(Int24 source, Bits bitmask);
    [ExtensionAttribute]
public static Int24 GetMaskedValue(Int24 source, Int24 bitmask);
    [ExtensionAttribute]
public static UInt24 GetMaskedValue(UInt24 source, Bits bitmask);
    [ExtensionAttribute]
public static UInt24 GetMaskedValue(UInt24 source, UInt24 bitmask);
    [ExtensionAttribute]
public static int GetMaskedValue(int source, Bits bitmask);
    [ExtensionAttribute]
public static int GetMaskedValue(int source, int bitmask);
    [ExtensionAttribute]
public static UInt32 GetMaskedValue(UInt32 source, Bits bitmask);
    [ExtensionAttribute]
public static UInt32 GetMaskedValue(UInt32 source, UInt32 bitmask);
    [ExtensionAttribute]
public static long GetMaskedValue(long source, Bits bitmask);
    [ExtensionAttribute]
public static long GetMaskedValue(long source, long bitmask);
    [ExtensionAttribute]
public static ulong GetMaskedValue(ulong source, Bits bitmask);
    [ExtensionAttribute]
public static ulong GetMaskedValue(ulong source, ulong bitmask);
    [ExtensionAttribute]
public static sbyte SetMaskedValue(sbyte source, Bits bitmask, sbyte value);
    [ExtensionAttribute]
public static sbyte SetMaskedValue(sbyte source, sbyte bitmask, sbyte value);
    [ExtensionAttribute]
public static byte SetMaskedValue(byte source, Bits bitmask, byte value);
    [ExtensionAttribute]
public static byte SetMaskedValue(byte source, byte bitmask, byte value);
    [ExtensionAttribute]
public static short SetMaskedValue(short source, Bits bitmask, short value);
    [ExtensionAttribute]
public static short SetMaskedValue(short source, short bitmask, short value);
    [ExtensionAttribute]
public static ushort SetMaskedValue(ushort source, Bits bitmask, ushort value);
    [ExtensionAttribute]
public static ushort SetMaskedValue(ushort source, ushort bitmask, ushort value);
    [ExtensionAttribute]
public static Int24 SetMaskedValue(Int24 source, Bits bitmask, Int24 value);
    [ExtensionAttribute]
public static Int24 SetMaskedValue(Int24 source, Int24 bitmask, Int24 value);
    [ExtensionAttribute]
public static UInt24 SetMaskedValue(UInt24 source, Bits bitmask, UInt24 value);
    [ExtensionAttribute]
public static UInt24 SetMaskedValue(UInt24 source, UInt24 bitmask, UInt24 value);
    [ExtensionAttribute]
public static int SetMaskedValue(int source, Bits bitmask, int value);
    [ExtensionAttribute]
public static int SetMaskedValue(int source, int bitmask, int value);
    [ExtensionAttribute]
public static UInt32 SetMaskedValue(UInt32 source, Bits bitmask, UInt32 value);
    [ExtensionAttribute]
public static UInt32 SetMaskedValue(UInt32 source, UInt32 bitmask, UInt32 value);
    [ExtensionAttribute]
public static long SetMaskedValue(long source, Bits bitmask, long value);
    [ExtensionAttribute]
public static long SetMaskedValue(long source, long bitmask, long value);
    [ExtensionAttribute]
public static ulong SetMaskedValue(ulong source, Bits bitmask, ulong value);
    [ExtensionAttribute]
public static ulong SetMaskedValue(ulong source, ulong bitmask, ulong value);
    [ExtensionAttribute]
public static byte BitRotL(byte value, int rotations);
    [ExtensionAttribute]
public static sbyte BitRotL(sbyte value, int rotations);
    [ExtensionAttribute]
public static short BitRotL(short value, int rotations);
    [ExtensionAttribute]
public static ushort BitRotL(ushort value, int rotations);
    [ExtensionAttribute]
public static Int24 BitRotL(Int24 value, int rotations);
    [ExtensionAttribute]
public static UInt24 BitRotL(UInt24 value, int rotations);
    [ExtensionAttribute]
public static int BitRotL(int value, int rotations);
    [ExtensionAttribute]
public static UInt32 BitRotL(UInt32 value, int rotations);
    [ExtensionAttribute]
public static long BitRotL(long value, int rotations);
    [ExtensionAttribute]
public static ulong BitRotL(ulong value, int rotations);
    [ExtensionAttribute]
public static byte BitRotR(byte value, int rotations);
    [ExtensionAttribute]
public static sbyte BitRotR(sbyte value, int rotations);
    [ExtensionAttribute]
public static short BitRotR(short value, int rotations);
    [ExtensionAttribute]
public static ushort BitRotR(ushort value, int rotations);
    [ExtensionAttribute]
public static Int24 BitRotR(Int24 value, int rotations);
    [ExtensionAttribute]
public static UInt24 BitRotR(UInt24 value, int rotations);
    [ExtensionAttribute]
public static int BitRotR(int value, int rotations);
    [ExtensionAttribute]
public static UInt32 BitRotR(UInt32 value, int rotations);
    [ExtensionAttribute]
public static long BitRotR(long value, int rotations);
    [ExtensionAttribute]
public static ulong BitRotR(ulong value, int rotations);
    private static string RemoveSign(string value);
    [ExtensionAttribute]
public static string ToBinaryString(sbyte value);
    [ExtensionAttribute]
public static string ToBinaryString(byte value);
    [ExtensionAttribute]
public static string ToBinaryString(short value);
    [ExtensionAttribute]
public static string ToBinaryString(ushort value);
    [ExtensionAttribute]
public static string ToBinaryString(Int24 value);
    [ExtensionAttribute]
public static string ToBinaryString(UInt24 value);
    [ExtensionAttribute]
public static string ToBinaryString(int value);
    [ExtensionAttribute]
public static string ToBinaryString(UInt32 value);
    [ExtensionAttribute]
public static string ToBinaryString(long value);
    [ExtensionAttribute]
public static string ToBinaryString(ulong value);
}
public static class GSF.BitMath : object {
    public static bool IsPowerOfTwo(int value);
    public static bool IsPowerOfTwo(long value);
    public static bool IsPowerOfTwo(UInt32 value);
    public static bool IsPowerOfTwo(ulong value);
    public static int CountBitsSet(UInt32 value);
    public static int CountBitsSet(ulong value);
    public static int CountBitsCleared(UInt32 value);
    public static int CountBitsCleared(ulong value);
    public static ulong RoundUpToNearestPowerOfTwo(ulong value);
    public static UInt32 RoundUpToNearestPowerOfTwo(UInt32 value);
    public static ulong RoundDownToNearestPowerOfTwo(ulong value);
    public static UInt32 RoundDownToNearestPowerOfTwo(UInt32 value);
    public static ulong CreateBitMask(int bitCount);
    public static int CountTrailingZeros(UInt32 value);
    public static int CountTrailingZeros(ulong value);
    public static int CountLeadingZeros(UInt32 value);
    public static int CountLeadingZeros(ulong value);
    public static int CountTrailingOnes(UInt32 value);
    public static int CountTrailingOnes(ulong value);
    public static int CountLeadingOnes(UInt32 value);
    public static int CountLeadingOnes(ulong value);
    [IteratorStateMachineAttribute("GSF.BitMath/<GetSetBitPositions>d__21")]
public static IEnumerable`1<int> GetSetBitPositions(ulong value);
    [IteratorStateMachineAttribute("GSF.BitMath/<GetSetBitPositions>d__22")]
public static IEnumerable`1<int> GetSetBitPositions(UInt32 value);
    public static IEnumerable`1<int> GetClearedBitPositions(UInt32 value);
    public static IEnumerable`1<int> GetClearedBitPositions(ulong value);
}
[FlagsAttribute]
public enum GSF.Bits : Enum {
    public ulong value__;
    public static Bits Nil;
    public static Bits Bit00;
    public static Bits Bit01;
    public static Bits Bit02;
    public static Bits Bit03;
    public static Bits Bit04;
    public static Bits Bit05;
    public static Bits Bit06;
    public static Bits Bit07;
    public static Bits Bit08;
    public static Bits Bit09;
    public static Bits Bit10;
    public static Bits Bit11;
    public static Bits Bit12;
    public static Bits Bit13;
    public static Bits Bit14;
    public static Bits Bit15;
    public static Bits Bit16;
    public static Bits Bit17;
    public static Bits Bit18;
    public static Bits Bit19;
    public static Bits Bit20;
    public static Bits Bit21;
    public static Bits Bit22;
    public static Bits Bit23;
    public static Bits Bit24;
    public static Bits Bit25;
    public static Bits Bit26;
    public static Bits Bit27;
    public static Bits Bit28;
    public static Bits Bit29;
    public static Bits Bit30;
    public static Bits Bit31;
    public static Bits Bit32;
    public static Bits Bit33;
    public static Bits Bit34;
    public static Bits Bit35;
    public static Bits Bit36;
    public static Bits Bit37;
    public static Bits Bit38;
    public static Bits Bit39;
    public static Bits Bit40;
    public static Bits Bit41;
    public static Bits Bit42;
    public static Bits Bit43;
    public static Bits Bit44;
    public static Bits Bit45;
    public static Bits Bit46;
    public static Bits Bit47;
    public static Bits Bit48;
    public static Bits Bit49;
    public static Bits Bit50;
    public static Bits Bit51;
    public static Bits Bit52;
    public static Bits Bit53;
    public static Bits Bit54;
    public static Bits Bit55;
    public static Bits Bit56;
    public static Bits Bit57;
    public static Bits Bit58;
    public static Bits Bit59;
    public static Bits Bit60;
    public static Bits Bit61;
    public static Bits Bit62;
    public static Bits Bit63;
}
public static class GSF.BitwiseCast : object {
    public static short ToInt16(ushort unsignedInt);
    public static Int24 ToInt24(UInt24 unsignedInt);
    public static int ToInt32(UInt32 unsignedInt);
    public static long ToInt64(ulong unsignedInt);
    public static ushort ToUInt16(short signedInt);
    public static UInt24 ToUInt24(Int24 signedInt);
    public static UInt32 ToUInt32(int signedInt);
    public static ulong ToUInt64(long signedInt);
}
[ObsoleteAttribute("It is not recommended to use this class because the need for pooling is rare and implementations of pooling can be dangerous.")]
public static class GSF.BufferPool : object {
    private static BufferManager s_bufferManager;
    private static BufferPool();
    public static Byte[] TakeBuffer(int bufferSize);
    public static void ReturnBuffer(Byte[] buffer);
    public static void Clear();
}
public abstract class GSF.ByteEncoding : object {
    public static char NoSpacing;
    private static ByteEncoding s_hexadecimalEncoding;
    private static ByteEncoding s_decimalEncoding;
    private static ByteEncoding s_bigEndianBinaryEncoding;
    private static ByteEncoding s_littleEndianBinaryEncoding;
    private static ByteEncoding s_base64Encoding;
    private static ByteEncoding s_asciiEncoding;
    public static ByteEncoding Hexadecimal { get; }
    public static ByteEncoding Decimal { get; }
    public static ByteEncoding BigEndianBinary { get; }
    public static ByteEncoding LittleEndianBinary { get; }
    public static ByteEncoding Base64 { get; }
    public static ByteEncoding ASCII { get; }
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, char spacingCharacter);
    public virtual string GetString(Byte[] bytes, int offset, int length);
    public abstract virtual string GetString(Byte[] bytes, int offset, int length, char spacingCharacter);
    public virtual Byte[] GetBytes(string value);
    public abstract virtual Byte[] GetBytes(string value, char spacingCharacter);
    public static ByteEncoding get_Hexadecimal();
    public static ByteEncoding get_Decimal();
    public static ByteEncoding get_BigEndianBinary();
    public static ByteEncoding get_LittleEndianBinary();
    public static ByteEncoding get_Base64();
    public static ByteEncoding get_ASCII();
    internal static string BytesToString(Byte[] bytes, int offset, int length, char spacingCharacter, string format);
}
[ExtensionAttribute]
public static class GSF.CharExtensions : object {
    private static Char[] wordSeperators;
    private static Char[] numericValues;
    private static CharExtensions();
    [ExtensionAttribute]
public static string RegexEncode(char item);
    [ExtensionAttribute]
public static bool IsWordTerminator(char value);
    [ExtensionAttribute]
public static bool IsNumeric(char value);
    [ExtensionAttribute]
public static bool IsAnyOf(char value, IEnumerable`1<char> testChars);
    [ExtensionAttribute]
public static bool IsInRange(char value, char startOfRange, char endOfRange);
    [ExtensionAttribute]
public static char ToLower(char value);
    [ExtensionAttribute]
public static char ToUpper(char value);
    [ExtensionAttribute]
public static bool IsHex(char value);
    [ExtensionAttribute]
public static int ConvertHexToInt(char value);
    [ExtensionAttribute]
public static BitArray ConvertHexToBitArray(char value);
}
public class GSF.Collections.AsyncDoubleBufferedQueue`1 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    private AsyncQueue`1<IEnumerable`1<T>> m_asyncQueue;
    private DoubleBufferedQueue`1<T> m_doubleBufferedQueue;
    public Action`1<IList`1<T>> ProcessItemsFunction { get; public set; }
    public int Count { get; }
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    public Action`1<IList`1<T>> get_ProcessItemsFunction();
    public void set_ProcessItemsFunction(Action`1<IList`1<T>> value);
    public int get_Count();
    public void Enqueue(IEnumerable`1<T> items);
    private void OnProcessException(Exception ex);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(IEnumerable`1<T> item);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_1(object sender, EventArgs`1<Exception> args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_2(object sender, EventArgs`1<Exception> args);
}
public class GSF.Collections.AsyncQueue`1 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    private ConcurrentQueue`1<T> m_asyncQueue;
    private Action`1<T> m_processItemFunction;
    private ISynchronizedOperation m_processItemOperation;
    private int m_enabled;
    public int Count { get; }
    public Action`1<T> ProcessItemFunction { get; public set; }
    public bool Enabled { get; public set; }
    public AsyncQueue`1(SynchronizedOperationType synchronizedOperationType);
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    public int get_Count();
    public Action`1<T> get_ProcessItemFunction();
    public void set_ProcessItemFunction(Action`1<T> value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public void Enqueue(T item);
    private void TryProcessItem();
    private void OnProcessException(Exception ex);
}
[ExtensionAttribute]
public static class GSF.Collections.CollectionExtensions : object {
    [IteratorStateMachineAttribute("GSF.Collections.CollectionExtensions/<GetRow>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetRow(T[0...,0...] source, int rowIndex);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetColumn(T[0...,0...] source, int columnIndex);
    [IteratorStateMachineAttribute("GSF.Collections.CollectionExtensions/<GetColumnIterator>d__2`1")]
private static IEnumerable`1<T> GetColumnIterator(T[0...,0...] source, int columnIndex);
    [ExtensionAttribute]
public static PagedList`1<T> ToPagedList(IEnumerable`1<T> source, int page, int pageSize, int count);
    [ExtensionAttribute]
public static T Merge(T source, IDictionary`2[] others);
    [ExtensionAttribute]
public static T Merge(T source, bool overwriteExisting, IDictionary`2[] others);
    [ExtensionAttribute]
public static TValue GetOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> defaultValueFactory);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> valueFactory);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue AddOrUpdate(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    [ExtensionAttribute]
public static TValue AddOrUpdate(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    [ExtensionAttribute]
public static TValue AddOrUpdate(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> valueFactory);
    [ExtensionAttribute]
public static TValue AddOrUpdate(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToDictionary(NameValueCollection collection);
    [ExtensionAttribute]
public static bool Any(BitArray source, bool value);
    [ExtensionAttribute]
public static bool All(BitArray source, bool value);
    [ExtensionAttribute]
public static bool AllParallel(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, ParallelOptions options);
    [ExtensionAttribute]
public static T[] Median(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static TSource MajorityBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, bool forwardSearch, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource MajorityBy(IEnumerable`1<TSource> source, TSource defaultValue, Func`2<TSource, TKey> keySelector, bool forwardSearch, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static T Majority(IEnumerable`1<T> source, bool forwardSearch, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static T Majority(IEnumerable`1<T> source, T defaultValue, bool forwardSearch, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static TSource MinorityBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, bool forwardSearch, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static TSource MinorityBy(IEnumerable`1<TSource> source, TSource defaultValue, Func`2<TSource, TKey> keySelector, bool forwardSearch, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static T Minority(IEnumerable`1<T> source, bool forwardSearch, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static T Minority(IEnumerable`1<T> source, T defaultValue, bool forwardSearch, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void UpdateRange(IList`1<T> collection, int index, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IList`1<T> GetRange(IList`1<T> collection, int index, int count);
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T[] Copy(T[] source, int startIndex, int length);
    [ExtensionAttribute]
public static TSource MinBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source, Func`3<TSource, TSource, int> comparer);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static TSource MaxBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source, Func`3<TSource, TSource, int> comparer);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DistinctBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, bool forwardSearch);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source, char delimiter);
    [ExtensionAttribute]
public static string ToDelimitedString(IEnumerable`1<TSource> source, string delimiter);
    private static string ToDelimitedString(IEnumerable`1<TSource> source, TDelimiter delimiter);
    [ExtensionAttribute]
public static void LoadDelimitedString(IList`1<TSource> destination, string delimitedString, Func`2<string, TSource> convertFromString);
    [ExtensionAttribute]
public static void LoadDelimitedString(IList`1<TSource> destination, string delimitedString, char delimiter, Func`2<string, TSource> convertFromString);
    [ExtensionAttribute]
public static void LoadDelimitedString(IList`1<TSource> destination, string delimitedString, String[] delimiters, Func`2<string, TSource> convertFromString);
    [ExtensionAttribute]
public static void Scramble(IList`1<TSource> source);
    [ExtensionAttribute]
public static void Scramble(IList`1<TSource> source, int seed);
    [ExtensionAttribute]
public static void Unscramble(IList`1<TSource> source, int seed);
    [ExtensionAttribute]
public static int CompareTo(TSource[] array1, TSource[] array2, bool orderIsImportant);
    [ExtensionAttribute]
private static int CompareTo(Array array1, Array array2, IComparer comparer, bool orderIsImportant);
}
public class GSF.Collections.ConcurrentIsolatedQueue`1 : object {
    private static DynamicObjectPool`1<IsolatedNode<T>> Pool;
    private static int NodeSize;
    private static int ShiftBits;
    private static int BitMask;
    private IsolatedNode<T> m_currentHead;
    private IsolatedNode<T> m_currentTail;
    private long m_enqueueCount;
    private long m_dequeueCount;
    public int Count { get; }
    private static ConcurrentIsolatedQueue`1();
    public int get_Count();
    public void Enqueue(T item);
    private void Grow(IsolatedNode<T> currentNode);
    public bool TryDequeue(T& item);
    public void Enqueue(T[] items, int offset, int length);
    public int Dequeue(T[] items, int startingIndex, int length);
}
internal class GSF.Collections.DictionaryDebugView`2 : object {
    private IDictionary`2<TK, TV> m_dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryDebugView`2(IDictionary`2<TK, TV> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class GSF.Collections.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> m_collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.DictionaryList`2 : object {
    private SortedList`2<TKey, TValue> m_list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public KeyValuePair`2<TKey, TValue> Item { get; public set; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Item(int index);
    public sealed virtual void set_Item(int index, KeyValuePair`2<TKey, TValue> value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int IndexOf(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
internal class GSF.Collections.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> m_collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
public class GSF.Collections.DoubleBufferedQueue`1 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    private int m_listIndex;
    private List`1[] m_lists;
    private SpinLock m_swapLock;
    private int m_count;
    private Action`1<IList`1<T>> m_processItemsFunction;
    private ISynchronizedOperation m_processItemsOperation;
    private static IList`1<T> EmptyList;
    public Action`1<IList`1<T>> ProcessItemsFunction { get; public set; }
    public int Count { get; }
    private static DoubleBufferedQueue`1();
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    public Action`1<IList`1<T>> get_ProcessItemsFunction();
    public void set_ProcessItemsFunction(Action`1<IList`1<T>> value);
    public int get_Count();
    public void Enqueue(IEnumerable`1<T> items);
    public IList`1<T> Dequeue();
    public void Clear();
    public bool TryEnqueue(IEnumerable`1<T> items);
    public int TryDequeue(IList`1& items);
    public bool TryClear();
    private void TryProcessItems();
    private void OnProcessException(Exception ex);
}
public class GSF.Collections.DoubleBufferedQueueManager`1 : object {
    private ShortSynchronizedOperation m_itemHandlingOperation;
    private Action m_itemHandler;
    private List`1<DoubleBufferedQueue`1<T>> m_queues;
    private List`1<T> m_dequeuedItems;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_itemsLeft;
    private object m_queuesLock;
    private static IList`1<T> EmptyList;
    public bool ItemsLeft { get; }
    public DoubleBufferedQueueManager`1(Action itemHandler);
    public DoubleBufferedQueueManager`1(Action`1<IList`1<T>> itemHandler);
    public DoubleBufferedQueueManager`1(Action itemHandler, Action`1<Exception> exceptionHandler);
    public DoubleBufferedQueueManager`1(Action`1<IList`1<T>> itemHandler, Action`1<Exception> exceptionHandler);
    private static DoubleBufferedQueueManager`1();
    public bool get_ItemsLeft();
    public DoubleBufferedQueueProducer`1<T> GetProducer();
    public IList`1<T> Dequeue();
    internal void SignalItemHandler();
    internal void ReturnQueue(DoubleBufferedQueue`1<T> queue);
    private void CallItemHandler();
}
public class GSF.Collections.DoubleBufferedQueueProducer`1 : object {
    private DoubleBufferedQueueManager`1<T> m_manager;
    private DoubleBufferedQueue`1<T> m_queue;
    private bool m_disposed;
    internal DoubleBufferedQueueProducer`1(DoubleBufferedQueueManager`1<T> manager, DoubleBufferedQueue`1<T> queue);
    protected virtual override void Finalize();
    public void Produce(IEnumerable`1<T> items);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class GSF.Collections.DynamicObjectPool`1 : object {
    private static LogPublisher Log;
    private ScheduledTask m_collection;
    private ConcurrentQueue`1<T> m_queue;
    private Func`1<T> m_instanceObject;
    private Queue`1<int> m_countHistory;
    private int m_targetCount;
    private int m_objectsCreated;
    public DynamicObjectPool`1(Func`1<T> instance, int targetCount);
    private static DynamicObjectPool`1();
    private void CollectionRunning(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
    public T Dequeue();
    public void Enqueue(T resource);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.FileBackedDictionary`2 : object {
    private FileBackedLookupTable`2<TKey, TValue> m_lookupTable;
    public string FilePath { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Byte[] DefaultSignature { get; }
    public Byte[] Signature { get; public set; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public long CacheSize { get; public set; }
    public int FragmentationCount { get; }
    public FileBackedDictionary`2(string filePath);
    public FileBackedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public FileBackedDictionary`2(IEqualityComparer`1<TKey> keyComparer);
    public FileBackedDictionary`2(string filePath, IDictionary`2<TKey, TValue> dictionary);
    public FileBackedDictionary`2(string filePath, IEqualityComparer`1<TKey> keyComparer);
    public FileBackedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> keyComparer);
    public FileBackedDictionary`2(string filePath, IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> keyComparer);
    public string get_FilePath();
    public void set_FilePath(string value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Byte[] get_DefaultSignature();
    public Byte[] get_Signature();
    public void set_Signature(Byte[] value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public long get_CacheSize();
    public void set_CacheSize(long value);
    public int get_FragmentationCount();
    public void Open();
    public void OpenRead();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public IEnumerable`1<TKey> GetKeys();
    public IEnumerable`1<TValue> GetValues();
    public void Compact();
    public void Close();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class GSF.Collections.FileBackedHashSet`1 : object {
    private FileBackedLookupTable`2<T, object> m_lookupTable;
    public string FilePath { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Byte[] DefaultSignature { get; }
    public Byte[] Signature { get; public set; }
    public long CacheSize { get; public set; }
    public int FragmentationCount { get; }
    public FileBackedHashSet`1(string filePath);
    public FileBackedHashSet`1(IEqualityComparer`1<T> comparer);
    public FileBackedHashSet`1(IEnumerable`1<T> enumerable);
    public FileBackedHashSet`1(string filePath, IEqualityComparer`1<T> comparer);
    public FileBackedHashSet`1(string filePath, IEnumerable`1<T> enumerable);
    public FileBackedHashSet`1(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    public FileBackedHashSet`1(string filePath, IEnumerable`1<T> enumerable, IEqualityComparer`1<T> comparer);
    public string get_FilePath();
    public void set_FilePath(string value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Byte[] get_DefaultSignature();
    public Byte[] get_Signature();
    public void set_Signature(Byte[] value);
    public long get_CacheSize();
    public void set_CacheSize(long value);
    public int get_FragmentationCount();
    public void Open();
    public void OpenRead();
    public sealed virtual bool Add(T item);
    public sealed virtual bool Remove(T item);
    public int RemoveWhere(Predicate`1<T> match);
    public sealed virtual bool Contains(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Compact();
    public void Close();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class GSF.Collections.FileBackedLookupTable`2 : object {
    public static string DictionarySignature;
    public static string HashSetSignature;
    private static double MaximumLoadFactor;
    private static int MaximumChainedEmptyNodes;
    private HeaderNode<TKey, TValue> m_headerNode;
    private JournalNode<TKey, TValue> m_journalNode;
    private CachedFileStream m_fileStream;
    private BinaryWriter m_fileWriter;
    private BinaryReader m_fileReader;
    private string m_filePath;
    private IEqualityComparer`1<TKey> m_keyComparer;
    private int m_fragmentationCount;
    private LookupTableType m_lookupTableType;
    private static BindingFlags Flags;
    private static Type[] Types;
    private static BinaryFormatter Formatter;
    private static Action`2<Stream, TKey> WriteKeyAction;
    private static Action`2<Stream, TValue> WriteValueAction;
    private static Func`2<Stream, TKey> ReadKeyFunc;
    private static Func`2<Stream, TValue> ReadValueFunc;
    public string FilePath { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Byte[] Signature { get; public set; }
    public TValue Item { get; public set; }
    public long CacheSize { get; public set; }
    public int FragmentationCount { get; }
    private int LookupNodeSize { get; }
    public FileBackedLookupTable`2(LookupTableType lookupTableType);
    public FileBackedLookupTable`2(LookupTableType lookupTableType, string filePath);
    public FileBackedLookupTable`2(LookupTableType lookupTableType, IEqualityComparer`1<TKey> keyComparer);
    public FileBackedLookupTable`2(LookupTableType lookupTableType, string filePath, IEqualityComparer`1<TKey> keyComparer);
    private static FileBackedLookupTable`2();
    public string get_FilePath();
    public void set_FilePath(string value);
    public int get_Count();
    public bool get_IsReadOnly();
    public Byte[] get_Signature();
    public void set_Signature(Byte[] value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public long get_CacheSize();
    public void set_CacheSize(long value);
    public int get_FragmentationCount();
    private int get_LookupNodeSize();
    public void Open();
    public void OpenRead();
    public void Add(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    public bool Remove(TKey key);
    public bool TryMark(TKey key);
    public bool AllMarked();
    public void RemoveMarked();
    public void RemoveUnmarked();
    public void UnmarkAll();
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public void Clear();
    [IteratorStateMachineAttribute("GSF.Collections.FileBackedLookupTable`2/<GetEnumerator>d__57")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public IEnumerable`1<TKey> GetKeys();
    public void Compact();
    public void Close();
    public sealed virtual void Dispose();
    private void OpenImplicit();
    private void Grow();
    private long FindEndOfChain(int hashCode, long capacity);
    private void Find(TKey key, Int64& lookupPointer, Int64& itemPointer);
    private void Set(long lookupPointer, long itemPointer, long count);
    private void Delete(long lookupPointer, long count);
    private void GrowLookupSection(long itemSectionPointer, long endOfFilePointer, long newEndOfFilePointer);
    private void RebuildLookupTable(long capacity);
    private void WriteItemNodePointers(long lookupPointer, long itemPointer, long nextItemPointer);
    private void Truncate(long itemPointer);
    private void ClearJournalNode();
    private long GetPosition(long hashCode);
    private long GetPosition(long hashCode, long capacity);
    private long GetLookupPointer(long position);
    private void Write(HeaderNode<TKey, TValue> node);
    private void Write(JournalNode<TKey, TValue> node);
    private void Write(LookupNode<TKey, TValue> node);
    private void Write(ItemNode<TKey, TValue> node);
    private void WriteItemPointer(long lookupPointer, long itemPointer);
    private void WriteLookupPointer(long lookupPointer, long itemPointer);
    private void Read(HeaderNode<TKey, TValue> node);
    private void Read(JournalNode<TKey, TValue> node);
    private void Read(LookupNode<TKey, TValue> node);
    private void Read(ItemNode<TKey, TValue> node);
    private long ReadItemPointer(long lookupPointer);
    private long ReadLookupPointer(long itemPointer);
    private long ReadNextItemPointer(long itemPointer);
    private TKey ReadKey();
    private TValue ReadValue();
    private long GetFirstHash(int hashCode);
    private long GetCollisionOffset(int hashCode);
    [IteratorStateMachineAttribute("GSF.Collections.FileBackedLookupTable`2/<GetKeysEnumerator>d__93")]
private IEnumerator`1<TKey> GetKeysEnumerator();
    private void FailIfReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static Action`2<Stream, T> GetWriteMethod();
    private static Func`2<Stream, T> GetReadMethod();
    [CompilerGeneratedAttribute]
private void <OpenRead>g__InternalOpenRead|45_0();
}
internal static class GSF.Collections.HashHelpers : object {
    internal static Int32[] SizeOneIntArray;
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    public static Int32[] Primes;
    private static HashHelpers();
    internal static int PowerOf2(int v);
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.IndexedArray`1 : object {
    private T[] m_items;
    private object m_syncRoot;
    private T m_defaultValue;
    private bool m_defaultSet;
    public T Item { get; public set; }
    public IndexedArray`1(T defaultValue);
    public T get_Item(int index);
    public void set_Item(int index, T value);
    private void Grow(int index);
    public void Clear();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum GSF.Collections.InsertionBehavior : Enum {
    public int value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
public interface GSF.Collections.IPagedList {
    public int TotalCount { get; }
    public int PageCount { get; }
    public int Page { get; }
    public int PageSize { get; }
    public abstract virtual int get_TotalCount();
    public abstract virtual int get_PageCount();
    public abstract virtual int get_Page();
    public abstract virtual int get_PageSize();
}
public class GSF.Collections.IsolatedQueue`1 : object {
    private ConcurrentQueue`1<IsolatedNode<T>> m_blocks;
    private IsolatedNode<T> m_currentHead;
    private IsolatedNode<T> m_currentTail;
    private int m_unitCount;
    private int m_enqueueCount;
    private int m_dequeueCount;
    public int Count { get; }
    public int get_Count();
    public void Enqueue(T item);
    private void EnqueueSlower(T item);
    public bool TryDequeue(T& item);
    private bool TryDequeueSlower(T& item);
    public void Enqueue(T[] items, int offset, int length);
    public int Dequeue(T[] items, int startingIndex, int length);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.ListCollection`1 : Collection`1<T> {
    private List`1<T> m_list;
    public int Count { get; }
    public T Item { get; public set; }
    protected List`1<T> Items { get; }
    public ListCollection`1(List`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    protected List`1<T> get_Items();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    protected virtual void ClearItems();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public Enumerator<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private static void ThrowOutOfRangeException();
}
[ExtensionAttribute]
public static class GSF.Collections.ListExtensions : object {
    [ExtensionAttribute]
public static int RemoveWhere(List`1<T> list, Func`2<T, bool> shouldRemove);
}
internal enum GSF.Collections.LookupTableType : Enum {
    public int value__;
    public static LookupTableType Dictionary;
    public static LookupTableType HashSet;
}
[CompilerGeneratedAttribute]
internal class GSF.Collections.NamespaceDoc : object {
}
public class GSF.Collections.NullableArray`1 : object {
    private Int32[] m_notNullBits;
    private T[] m_items;
    public void Add(int index, T item);
    public bool TryGet(int index, T& item);
    private void Grow();
    public void Clear();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("GSF.Collections.DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class GSF.Collections.OrderedDictionary`2 : object {
    private static Entry[] s_initialEntries;
    private Int32[] m_buckets;
    private Entry[] m_entries;
    private int m_count;
    private int m_version;
    private IEqualityComparer`1<TKey> m_comparer;
    private KeyCollection<TKey, TValue> m_keys;
    private ValueCollection<TKey, TValue> m_values;
    public int Count { get; }
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    private KeyValuePair`2<TKey, TValue> System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Item { get; private set; }
    private KeyValuePair`2<TKey, TValue> System.Collections.Generic.IReadOnlyList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Item { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public OrderedDictionary`2(int capacity);
    public OrderedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public OrderedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public OrderedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public OrderedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    private static OrderedDictionary`2();
    public sealed virtual int get_Count();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public TValue get_Item(int index);
    public void set_Item(int index, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public int EnsureCapacity(int capacity);
    public Enumerator<TKey, TValue> GetEnumerator();
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue GetOrAdd(TKey key, Func`1<TValue> valueFactory);
    public int IndexOf(TKey key);
    public void Insert(int index, TKey key, TValue value);
    public void Move(int fromIndex, int toIndex);
    public void MoveRange(int fromIndex, int toIndex, int count);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual void RemoveAt(int index);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override KeyValuePair`2<TKey, TValue> System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.set_Item(int index, KeyValuePair`2<TKey, TValue> value);
    private sealed virtual override KeyValuePair`2<TKey, TValue> System.Collections.Generic.IReadOnlyList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Item(int index);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override int System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IndexOf(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Insert(int index, KeyValuePair`2<TKey, TValue> item);
    private Entry[] Resize(int newSize);
    private int IndexOf(TKey key, UInt32& hashCode);
    private bool TryInsert(Nullable`1<int> index, TKey key, TValue value, InsertionBehavior behavior);
    private void AddInternal(Nullable`1<int> index, TKey key, TValue value, UInt32 hashCode);
    private void AddEntryToBucket(Entry& entry, int entryIndex, Int32[] buckets);
    private void RemoveEntryFromBucket(int entryIndex);
    private void UpdateBucketIndex(int entryIndex, int incrementAmount);
}
public class GSF.Collections.PagedList`1 : List`1<T> {
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    public int TotalCount { get; }
    public int PageCount { get; }
    public int Page { get; }
    public int PageSize { get; }
    public PagedList`1(IEnumerable`1<T> source, int page, int pageSize, int count);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalCount();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageCount();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Page();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageSize();
    private int CalculatePageCount(int pageSize, int totalCount);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.PriorityQueue`1 : object {
    private PriorityQueueNode[] m_heap;
    private int m_count;
    private int m_insertionOrder;
    private int m_version;
    private static PriorityQueueNode[] EmptyHeap;
    public T Head { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PriorityQueue`1(int capacity);
    private static PriorityQueue`1();
    public T get_Head();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public void Enqueue(int priority, T item);
    public T Dequeue();
    public T Peek();
    public int GetPriority(int index);
    public void SetPriority(int index, int priority);
    public void AdjustPriority(int delta);
    [IteratorStateMachineAttribute("GSF.Collections.PriorityQueue`1/<GetEnumerator>d__22")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    private void FixHeapUp(int child);
    private void FixHeapDown(int parent);
    private int GetParent(int index);
    private int GetLeftChild(int index);
    private int GetRightChild(int index);
    private void Swap(int index1, int index2);
    private void IncreaseCapacity();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.ProcessDictionary`2 : ProcessQueue`1<KeyValuePair`2<TKey, TValue>> {
    private ProcessItemFunctionSignature<TKey, TValue> m_processItemFunction;
    private CanProcessItemFunctionSignature<TKey, TValue> m_canProcessItemFunction;
    private bool m_disposed;
    public ProcessItemFunctionSignature<TKey, TValue> ProcessItemFunction { get; public set; }
    public ProcessItemsFunctionSignature<KeyValuePair`2<TKey, TValue>> ProcessItemsFunction { get; public set; }
    public CanProcessItemFunctionSignature<TKey, TValue> CanProcessItemFunction { get; public set; }
    public string Name { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    protected DictionaryList`2<TKey, TValue> InternalDictionary { get; }
    public ProcessDictionary`2(ProcessItemFunctionSignature<TKey, TValue> processItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessDictionary`2(ProcessItemFunctionSignature<TKey, TValue> processItemFunction, CanProcessItemFunctionSignature<TKey, TValue> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessDictionary`2(ProcessItemsFunctionSignature<KeyValuePair`2<TKey, TValue>> processItemsFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessDictionary`2(ProcessItemsFunctionSignature<KeyValuePair`2<TKey, TValue>> processItemsFunction, CanProcessItemFunctionSignature<TKey, TValue> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public virtual ProcessItemFunctionSignature<TKey, TValue> get_ProcessItemFunction();
    public virtual void set_ProcessItemFunction(ProcessItemFunctionSignature<TKey, TValue> value);
    public virtual ProcessItemsFunctionSignature<KeyValuePair`2<TKey, TValue>> get_ProcessItemsFunction();
    public virtual void set_ProcessItemsFunction(ProcessItemsFunctionSignature<KeyValuePair`2<TKey, TValue>> value);
    public virtual CanProcessItemFunctionSignature<TKey, TValue> get_CanProcessItemFunction();
    public virtual void set_CanProcessItemFunction(CanProcessItemFunctionSignature<TKey, TValue> value);
    public virtual string get_Name();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    protected DictionaryList`2<TKey, TValue> get_InternalDictionary();
    protected virtual void Dispose(bool disposing);
    private void ProcessKeyedItem(KeyValuePair`2<TKey, TValue> item);
    private bool CanProcessKeyedItem(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue AddOrUpdate(TKey key, TValue value);
    [EditorBrowsableAttribute("1")]
public virtual int BinarySearch(KeyValuePair`2<TKey, TValue> item);
    [EditorBrowsableAttribute("1")]
public virtual int BinarySearch(KeyValuePair`2<TKey, TValue> item, IComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
    [EditorBrowsableAttribute("1")]
public virtual int BinarySearch(int index, int count, KeyValuePair`2<TKey, TValue> item, IComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
    [EditorBrowsableAttribute("1")]
public virtual int IndexOf(KeyValuePair`2<TKey, TValue> item);
    [EditorBrowsableAttribute("1")]
public virtual int IndexOf(KeyValuePair`2<TKey, TValue> item, int index, int count);
    [EditorBrowsableAttribute("1")]
public virtual int LastIndexOf(KeyValuePair`2<TKey, TValue> item);
    [EditorBrowsableAttribute("1")]
public virtual int LastIndexOf(KeyValuePair`2<TKey, TValue> item, int index);
    [EditorBrowsableAttribute("1")]
public virtual int LastIndexOf(KeyValuePair`2<TKey, TValue> item, int index, int count);
    [EditorBrowsableAttribute("1")]
public virtual void Sort();
    [EditorBrowsableAttribute("1")]
public virtual void Sort(IComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
    [EditorBrowsableAttribute("1")]
public virtual void Sort(Comparison`1<KeyValuePair`2<TKey, TValue>> comparison);
    [EditorBrowsableAttribute("1")]
public virtual void Sort(int index, int count, IComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.ProcessQueue`1 : object {
    public static int DefaultProcessInterval;
    public static int DefaultMaximumThreads;
    public static int DefaultProcessTimeout;
    public static bool DefaultRequeueOnTimeout;
    public static bool DefaultRequeueOnException;
    public static double RealTimeProcessInterval;
    public static RequeueMode DefaultRequeueModeOnTimeout;
    public static RequeueMode DefaultRequeueModeOnException;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> ItemProcessed;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T[]>> ItemsProcessed;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T>> ItemTimedOut;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<T[]>> ItemsTimedOut;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private ProcessItemFunctionSignature<T> m_processItemFunction;
    private ProcessItemsFunctionSignature<T> m_processItemsFunction;
    private CanProcessItemFunctionSignature<T> m_canProcessItemFunction;
    private ISynchronizedOperation m_synchronizedOperation;
    private SynchronizedOperationType m_synchronizedOperationType;
    private ThreadLocal`1<ICancellationToken> m_threadLocalCancellationToken;
    private IList`1<T> m_processList;
    private int m_maximumThreads;
    private int m_processTimeout;
    private bool m_processingIsRealTime;
    private bool m_requeueOnTimeout;
    private bool m_requeueOnException;
    private RequeueMode m_requeueModeOnTimeout;
    private RequeueMode m_requeueModeOnException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_enabled;
    private int m_threadCount;
    private long m_itemsBeingProcessed;
    private long m_totalProcessedItems;
    private long m_totalFunctionCalls;
    private long m_startTime;
    private long m_stopTime;
    private string m_name;
    private bool m_disposed;
    private Timer m_processTimer;
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public ProcessItemFunctionSignature<T> ProcessItemFunction { get; public set; }
    public ProcessItemsFunctionSignature<T> ProcessItemsFunction { get; public set; }
    public CanProcessItemFunctionSignature<T> CanProcessItemFunction { get; public set; }
    public bool ProcessingIsRealTime { get; }
    public QueueThreadingMode ThreadingMode { get; }
    public QueueProcessingStyle ProcessingStyle { get; }
    public double ProcessInterval { get; public set; }
    public int MaximumThreads { get; public set; }
    public int ProcessTimeout { get; public set; }
    public SynchronizedOperationType SynchronizedOperationType { get; public set; }
    public bool RequeueOnTimeout { get; public set; }
    public bool RequeueOnException { get; public set; }
    public RequeueMode RequeueModeOnTimeout { get; public set; }
    public RequeueMode RequeueModeOnException { get; public set; }
    public bool Enabled { get; public set; }
    public bool IsDisposed { get; }
    public bool IsProcessing { get; }
    public bool IsEmpty { get; }
    public long ItemsBeingProcessed { get; }
    public long TotalProcessedItems { get; }
    public long TotalFunctionCalls { get; }
    public int ThreadCount { get; }
    public Time RunTime { get; }
    public string Name { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public ICancellationToken CancellationToken { get; private set; }
    public ProcessQueueStatistics CurrentStatistics { get; }
    public string Status { get; }
    protected IEnumerable`1<T> InternalEnumerable { get; }
    public object SyncRoot { get; }
    protected IList`1<T> InternalList { get; }
    public ProcessQueue`1(ProcessItemFunctionSignature<T> processItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessQueue`1(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessQueue`1(ProcessItemsFunctionSignature<T> processItemsFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public ProcessQueue`1(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    protected ProcessQueue`1(ProcessItemFunctionSignature<T> processItemFunction, ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, IList`1<T> processList, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    [CompilerGeneratedAttribute]
public void add_ItemProcessed(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemProcessed(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_ItemsProcessed(EventHandler`1<EventArgs`1<T[]>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemsProcessed(EventHandler`1<EventArgs`1<T[]>> value);
    [CompilerGeneratedAttribute]
public void add_ItemTimedOut(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemTimedOut(EventHandler`1<EventArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public void add_ItemsTimedOut(EventHandler`1<EventArgs`1<T[]>> value);
    [CompilerGeneratedAttribute]
public void remove_ItemsTimedOut(EventHandler`1<EventArgs`1<T[]>> value);
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public bool TryTake(T& item);
    public bool TryTake(T[]& items);
    public virtual bool get_IsReadOnly();
    public virtual ProcessItemFunctionSignature<T> get_ProcessItemFunction();
    public virtual void set_ProcessItemFunction(ProcessItemFunctionSignature<T> value);
    public virtual ProcessItemsFunctionSignature<T> get_ProcessItemsFunction();
    public virtual void set_ProcessItemsFunction(ProcessItemsFunctionSignature<T> value);
    public virtual CanProcessItemFunctionSignature<T> get_CanProcessItemFunction();
    public virtual void set_CanProcessItemFunction(CanProcessItemFunctionSignature<T> value);
    public virtual bool get_ProcessingIsRealTime();
    public virtual QueueThreadingMode get_ThreadingMode();
    public virtual QueueProcessingStyle get_ProcessingStyle();
    public virtual double get_ProcessInterval();
    public virtual void set_ProcessInterval(double value);
    public virtual int get_MaximumThreads();
    public virtual void set_MaximumThreads(int value);
    public virtual int get_ProcessTimeout();
    public virtual void set_ProcessTimeout(int value);
    public virtual SynchronizedOperationType get_SynchronizedOperationType();
    public virtual void set_SynchronizedOperationType(SynchronizedOperationType value);
    public virtual bool get_RequeueOnTimeout();
    public virtual void set_RequeueOnTimeout(bool value);
    public virtual bool get_RequeueOnException();
    public virtual void set_RequeueOnException(bool value);
    public virtual RequeueMode get_RequeueModeOnTimeout();
    public virtual void set_RequeueModeOnTimeout(RequeueMode value);
    public virtual RequeueMode get_RequeueModeOnException();
    public virtual void set_RequeueModeOnException(RequeueMode value);
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public bool get_IsProcessing();
    public virtual bool get_IsEmpty();
    public long get_ItemsBeingProcessed();
    public long get_TotalProcessedItems();
    public long get_TotalFunctionCalls();
    public int get_ThreadCount();
    public virtual Time get_RunTime();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual int get_Count();
    public bool get_IsSynchronized();
    public ICancellationToken get_CancellationToken();
    private void set_CancellationToken(ICancellationToken value);
    public virtual ProcessQueueStatistics get_CurrentStatistics();
    public virtual string get_Status();
    private string GetProcessingFunctionName();
    protected IEnumerable`1<T> get_InternalEnumerable();
    public object get_SyncRoot();
    protected IList`1<T> get_InternalList();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void SignalDataModified();
    public virtual bool Contains(T item);
    public virtual T[] ToArray();
    public virtual IEnumerator`1<T> GetEnumerator();
    public virtual void Start();
    private sealed virtual override void GSF.ISupportLifecycle.Initialize();
    public virtual void Stop();
    public virtual void Flush();
    protected virtual void OnItemProcessed(T item);
    protected virtual void OnItemsProcessed(T[] items);
    protected virtual void OnItemTimedOut(T item);
    protected virtual void OnItemsTimedOut(T[] items);
    protected virtual void OnProcessException(Exception ex);
    protected virtual void DataAdded();
    protected virtual bool CanProcessItem(T item);
    protected virtual bool CanProcessItems(T[] items);
    protected virtual void RequeueItem(T item, RequeueReason reason);
    protected virtual void RequeueItems(T[] items, RequeueReason reason);
    public void AddRange(IEnumerable`1<T> collection);
    public virtual int BinarySearch(T item);
    public virtual int BinarySearch(T item, IComparer`1<T> comparer);
    public virtual int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public virtual List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public virtual bool Exists(Predicate`1<T> match);
    public virtual T Find(Predicate`1<T> match);
    public virtual List`1<T> FindAll(Predicate`1<T> match);
    public virtual int FindIndex(Predicate`1<T> match);
    public virtual int FindIndex(int startIndex, Predicate`1<T> match);
    public virtual int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public virtual T FindLast(Predicate`1<T> match);
    public virtual int FindLastIndex(Predicate`1<T> match);
    public virtual int FindLastIndex(int startIndex, Predicate`1<T> match);
    public virtual int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public virtual void ForEach(Action`1<T> action);
    public virtual List`1<T> GetRange(int index, int count);
    public virtual int IndexOf(T item, int index);
    public virtual int IndexOf(T item, int index, int count);
    public virtual void InsertRange(int index, IEnumerable`1<T> collection);
    public virtual int LastIndexOf(T item);
    public virtual int LastIndexOf(T item, int index);
    public virtual int LastIndexOf(T item, int index, int count);
    public virtual int RemoveAll(Predicate`1<T> match);
    public virtual void RemoveRange(int index, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void Sort();
    public virtual void Sort(IComparer`1<T> comparer);
    public virtual void Sort(int index, int count, IComparer`1<T> comparer);
    public virtual void Sort(Comparison`1<T> comparison);
    public virtual bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public virtual void Insert(int index, T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int IndexOf(T item);
    public sealed virtual void Clear();
    public virtual bool Remove(T item);
    public virtual void RemoveAt(int index);
    private void ProcessItem(T item);
    private void ProcessItems(T[] items);
    private void RealTimeThreadProc();
    private void ProcessTimerThreadProc(object sender, ElapsedEventArgs e);
    private void ProcessNextItem();
    private void ProcessNextItems();
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, int maximumThreads);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, int maximumThreads);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, double processInterval, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemFunctionSignature<T> processItemFunction);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemFunctionSignature<T> processItemFunction, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemFunctionSignature<T> processItemFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, int maximumThreads);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, int maximumThreads);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateAsynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int maximumThreads, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, double processInterval, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateSynchronousQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, double processInterval, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemsFunctionSignature<T> processItemsFunction);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemsFunctionSignature<T> processItemsFunction, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
    public static ProcessQueue`1<T> CreateRealTimeQueue(ProcessItemsFunctionSignature<T> processItemsFunction, CanProcessItemFunctionSignature<T> canProcessItemFunction, int processTimeout, bool requeueOnTimeout, bool requeueOnException);
}
public class GSF.Collections.ProcessQueueStatistics : ValueType {
    public bool IsEnabled;
    public bool IsProcessing;
    public double ProcessingInterval;
    public int ProcessTimeout;
    public QueueThreadingMode ThreadingMode;
    public QueueProcessingStyle ProcessingStyle;
    public Time RunTime;
    public int ActiveThreads;
    public int QueueCount;
    public long ItemsBeingProcessed;
    public long TotalProcessedItems;
}
public enum GSF.Collections.QueueProcessingStyle : Enum {
    public int value__;
    public static QueueProcessingStyle OneAtATime;
    public static QueueProcessingStyle ManyAtOnce;
}
public enum GSF.Collections.QueueThreadingMode : Enum {
    public int value__;
    public static QueueThreadingMode Asynchronous;
    public static QueueThreadingMode Synchronous;
}
public enum GSF.Collections.RequeueMode : Enum {
    public int value__;
    public static RequeueMode Prefix;
    public static RequeueMode Suffix;
}
public enum GSF.Collections.RequeueReason : Enum {
    public int value__;
    public static RequeueReason CannotProcess;
    public static RequeueReason Exception;
    public static RequeueReason Timeout;
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.RollingWindow`1 : object {
    private int m_windowSize;
    private T[] m_window;
    private int m_start;
    private int m_count;
    private int m_version;
    public int Count { get; }
    public int WindowSize { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public RollingWindow`1(int windowSize);
    public sealed virtual int get_Count();
    public int get_WindowSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("GSF.Collections.RollingWindow`1/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int WrapIndex(int index);
}
public class GSF.Collections.SettingsCollection : Dictionary`2<string, string> {
    private ValidationService m_validationService;
    public ValidationService Validation { get; }
    public SettingsCollection(IEqualityComparer`1<string> comparer);
    public SettingsCollection(IDictionary`2<string, string> dictionary);
    public SettingsCollection(IDictionary`2<string, string> dictionary, IEqualityComparer`1<string> comparer);
    public ValidationService get_Validation();
    public bool TryAdd(string key, string value);
    public virtual string ToString();
    private void Initialize();
    private object Lookup(string source);
    public static string op_Implicit(SettingsCollection value);
    public static SettingsCollection op_Implicit(string value);
}
[DefaultMemberAttribute("Item")]
public class GSF.Collections.SortedQueue`2 : object {
    private SortedList`2<TKey, TValue> m_list;
    public TValue Head { get; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public TValue get_Head();
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    public void Enqueue(TKey key, TValue value);
    public KeyValuePair`2<TKey, TValue> Dequeue();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
public static class GSF.Common : object {
    private static Nullable`1<ApplicationType> s_applicationType;
    private static string s_osPlatformName;
    private static PlatformID s_osPlatformID;
    public static bool IsPosixEnvironment;
    public static bool IsMono;
    public static double SystemTimer { get; }
    private static Common();
    public static ApplicationType GetApplicationType();
    public static PlatformID GetOSPlatformID();
    public static string GetOSProductName();
    public static long GetProcessMemory();
    public static ulong GetTotalPhysicalMemory();
    public static ulong GetAvailablePhysicalMemory();
    public static T IIf(bool expression, T truePart, T falsePart);
    public static T[] CreateArray(int length);
    public static T[] CreateArray(int length, T initialValue);
    [ExtensionAttribute]
public static string ToNonNullString(T value);
    [ExtensionAttribute]
public static string ToNonNullString(T value, string nonNullValue);
    [ExtensionAttribute]
public static string ToNonNullString(string value);
    [ExtensionAttribute]
public static string ToNonNullNorEmptyString(T value, string nonNullNorEmptyValue);
    [ExtensionAttribute]
public static string ToNonNullNorWhiteSpace(T value, string nonNullNorWhiteSpaceValue);
    public static string TypeConvertToString(object value);
    public static string TypeConvertToString(object value, CultureInfo culture);
    public static object TypeConvertFromString(string value, Type type);
    public static object TypeConvertFromString(string value, Type type, CultureInfo culture);
    public static double get_SystemTimer();
    public static bool IsDefaultValue(object item);
    public static bool IsReference(object item);
    public static bool IsNonStringReference(object item);
    public static bool IsNumericType(TypeCode typeCode);
    public static bool IsNumericType(Type type);
    public static bool IsNumericType();
    public static bool IsNumericType(object item);
    public static bool IsNumeric(object item);
    public static T Min(T[] itemList);
    public static T Max(T[] itemList);
    public static T Mid(T value1, T value2, T value3);
    public static object NotNull(object value, object nonNullValue);
}
public class GSF.ComplexNumber : ValueType {
    private Nullable`1<double> m_real;
    private Nullable`1<double> m_imaginary;
    private Nullable`1<double> m_angle;
    private Nullable`1<double> m_magnitude;
    public double Real { get; public set; }
    public double Imaginary { get; public set; }
    public double Magnitude { get; public set; }
    public Angle Angle { get; public set; }
    public ComplexNumber Conjugate { get; }
    public bool AllAssigned { get; }
    public bool NoneAssigned { get; }
    public ComplexNumber(double real, double imaginary);
    public ComplexNumber(Angle angle, double magnitude);
    public ComplexNumber(ComplexNumber z);
    public double get_Real();
    public void set_Real(double value);
    public double get_Imaginary();
    public void set_Imaginary(double value);
    public double get_Magnitude();
    public void set_Magnitude(double value);
    public Angle get_Angle();
    public void set_Angle(Angle value);
    public ComplexNumber get_Conjugate();
    public bool get_AllAssigned();
    public bool get_NoneAssigned();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ComplexNumber obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private void CalculateRectangularFromPolar();
    public static ComplexNumber op_Implicit(double value);
    public static Complex op_Implicit(ComplexNumber value);
    public static ComplexNumber op_Implicit(Complex value);
    public static bool op_Equality(ComplexNumber value1, ComplexNumber value2);
    public static bool op_Inequality(ComplexNumber value1, ComplexNumber value2);
    public static ComplexNumber op_UnaryNegation(ComplexNumber z);
    public static ComplexNumber op_Addition(ComplexNumber value1, ComplexNumber value2);
    public static ComplexNumber op_Subtraction(ComplexNumber value1, ComplexNumber value2);
    public static ComplexNumber op_Multiply(ComplexNumber value1, ComplexNumber value2);
    public static ComplexNumber op_Division(ComplexNumber value1, ComplexNumber value2);
    public static ComplexNumber Pow(ComplexNumber z, double y);
    [EditorBrowsableAttribute("2")]
public static ComplexNumber op_Exponent(ComplexNumber z, double y);
    public static ComplexNumber Parse(string str);
}
[AttributeUsageAttribute("2432")]
public class GSF.ComponentModel.DataAnnotations.AcronymValidationAttribute : RegularExpressionAttribute {
    public static string ValidationPattern;
    public static string DefaultErrorMessage;
}
[AttributeUsageAttribute("2432")]
public class GSF.ComponentModel.DataAnnotations.EmailValidationAttribute : RegularExpressionAttribute {
    public static string ValidationPattern;
    public static string DefaultErrorMessage;
}
[AttributeUsageAttribute("128")]
public class GSF.ComponentModel.DataAnnotations.InitialValueScriptAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InitialValueScript>k__BackingField;
    public string InitialValueScript { get; }
    public InitialValueScriptAttribute(string initialValueScript);
    [CompilerGeneratedAttribute]
public string get_InitialValueScript();
}
[AttributeUsageAttribute("4")]
public class GSF.ComponentModel.DataAnnotations.IsDeletedFlagAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldName { get; }
    public IsDeletedFlagAttribute(string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
}
[AttributeUsageAttribute("128")]
public class GSF.ComponentModel.DataAnnotations.LabelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public string Label { get; }
    public LabelAttribute(string label);
    [CompilerGeneratedAttribute]
public string get_Label();
}
[CompilerGeneratedAttribute]
internal class GSF.ComponentModel.DataAnnotations.NamespaceDoc : object {
}
[AttributeUsageAttribute("4")]
public class GSF.ComponentModel.DataAnnotations.PrimaryLabelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldName { get; }
    public PrimaryLabelAttribute(string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
}
[AttributeUsageAttribute("2432")]
public class GSF.ComponentModel.DataAnnotations.UrlValidationAttribute : RegularExpressionAttribute {
    public static string ValidationPattern;
    public static string DefaultErrorMessage;
}
[AttributeUsageAttribute("128")]
public class GSF.ComponentModel.DefaultValueExpressionAttribute : ValueExpressionAttributeBase {
    public DefaultValueExpressionAttribute(string expression);
}
public class GSF.ComponentModel.EvaluationOrderException : Exception {
    public EvaluationOrderException(string message);
}
public interface GSF.ComponentModel.IValueExpressionAttribute {
    public string Expression { get; }
    public bool Cached { get; public set; }
    public int EvaluationOrder { get; public set; }
    public TypeRegistry TypeRegistry { get; public set; }
    public abstract virtual string get_Expression();
    public abstract virtual bool get_Cached();
    public abstract virtual void set_Cached(bool value);
    public abstract virtual int get_EvaluationOrder();
    public abstract virtual void set_EvaluationOrder(int value);
    public abstract virtual TypeRegistry get_TypeRegistry();
    public abstract virtual void set_TypeRegistry(TypeRegistry value);
    public abstract virtual string GetPropertyUpdateValue(PropertyInfo property);
    public abstract virtual string GetExpressionUpdateValue(PropertyInfo property);
}
public interface GSF.ComponentModel.IValueExpressionScope`1 {
    public T Instance { get; public set; }
    public abstract virtual T get_Instance();
    public abstract virtual void set_Instance(T value);
}
[CompilerGeneratedAttribute]
internal class GSF.ComponentModel.NamespaceDoc : object {
}
[AttributeUsageAttribute("128")]
public class GSF.ComponentModel.TypeConvertedValueExpressionAttribute : ValueExpressionAttributeBase {
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type ReturnType { get; private set; }
    public TypeConvertedValueExpressionAttribute(string expression, Type returnType);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
    public virtual string GetPropertyUpdateValue(PropertyInfo property);
    public virtual string GetExpressionUpdateValue(PropertyInfo property);
    private void DeriveReturnType();
}
[ExtensionAttribute]
public static class GSF.ComponentModel.TypeRegistryExtensions : object {
    [ExtensionAttribute]
public static TypeRegistry Clone(TypeRegistry typeRegistry);
    [ExtensionAttribute]
public static TypeRegistry RegisterSymbols(IEnumerable`1<KeyValuePair`2<string, object>> symbols, TypeRegistry targetTypeRegistry);
}
[AttributeUsageAttribute("128")]
public class GSF.ComponentModel.UpdateValueExpressionAttribute : ValueExpressionAttributeBase {
    public UpdateValueExpressionAttribute(string expression);
}
[AttributeUsageAttribute("128")]
public abstract class GSF.ComponentModel.ValueExpressionAttributeBase : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EvaluationOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRegistry <TypeRegistry>k__BackingField;
    public string Expression { get; }
    public bool Cached { get; public set; }
    public int EvaluationOrder { get; public set; }
    public TypeRegistry TypeRegistry { get; public set; }
    protected ValueExpressionAttributeBase(string expression);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Cached();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Cached(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EvaluationOrder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EvaluationOrder(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TypeRegistry get_TypeRegistry();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeRegistry(TypeRegistry value);
    public virtual string GetPropertyUpdateValue(PropertyInfo property);
    public virtual string GetExpressionUpdateValue(PropertyInfo property);
}
public class GSF.ComponentModel.ValueExpressionParser : ValueExpressionParser`1<object> {
    private static TypeRegistry s_defaultTypeRegistry;
    private static Regex s_findThisKeywords;
    public static TypeRegistry DefaultTypeRegistry { get; }
    public ValueExpressionParser(string expression);
    public ValueExpressionParser(IValueExpressionAttribute valueExpressionAttribute, PropertyInfo property);
    private static ValueExpressionParser();
    public static TypeRegistry get_DefaultTypeRegistry();
    public static bool HasThisKeywords(string expression);
    public static string ReplaceThisKeywords(string expression, string fieldName);
    public static string DeriveExpression(string expression, IValueExpressionAttribute valueExpressionAttribute, MemberInfo member, string typeName);
}
public class GSF.ComponentModel.ValueExpressionParser`1 : CompiledExpression`1<T> {
    private static Dictionary`2<PropertyInfo, object> s_cachedExpressionValues;
    private static MethodInfo s_addCachedValueMethod;
    private static MethodInfo s_getCachedValueMethod;
    public ValueExpressionParser`1(string expression);
    public ValueExpressionParser`1(IValueExpressionAttribute valueExpressionAttribute, PropertyInfo property);
    private static ValueExpressionParser`1();
    public void Parse(Expression scope, TypeRegistry typeRegistry, bool isCall);
    public static bool InitializeType();
    public static Func`1<T> CreateInstance(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Func`1<T> CreateInstanceForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> ApplyDefaults(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> ApplyDefaultsForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> UpdateInstance(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> UpdateInstanceForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> UpdateExpressions(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> UpdateExpressionsForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<T> UpdateProperties(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Func`2<TExpressionScope, T> CreateInstance(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Func`2<TExpressionScope, T> CreateInstanceForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> ApplyDefaults(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> ApplyDefaultsForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> UpdateInstance(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> UpdateInstanceForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> UpdateExpressions(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    public static Action`1<TExpressionScope> UpdateExpressionsForType(IEnumerable`1<PropertyInfo> properties, TypeRegistry typeRegistry);
    private static Expression AssignParsedValueExpression(IValueExpressionAttribute valueExpressionAttribute, TypeRegistry typeRegistry, PropertyInfo property, ParameterExpression scopeParameter, ParameterExpression instance, String& expression);
    private static string DeriveExpression(string expression, IValueExpressionAttribute valueExpressionAttribute, PropertyInfo property);
    private static void AddCachedValue(PropertyInfo property, object value);
    private static Tuple`2<bool, object> GetCachedValue(PropertyInfo property);
}
public abstract class GSF.ComponentModel.ValueExpressionScopeBase`1 : object {
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    public T Instance { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual T get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Instance(T value);
}
public class GSF.CompoundValue`1 : Collection`1<Nullable`1<T>> {
    public bool AllAssigned { get; }
    public bool NoneAssigned { get; }
    public CompoundValue`1(int count);
    public CompoundValue`1(IEnumerable`1<T> values);
    public CompoundValue`1(IEnumerable`1<Nullable`1<T>> values);
    public bool get_AllAssigned();
    public bool get_NoneAssigned();
    public T[] ToArray();
}
public abstract class GSF.Configuration.AppSettingsBase : SettingsBase {
    private ConfigurationFile m_configFile;
    protected ConfigurationFile ConfigFile { get; protected set; }
    protected AppSettingsBase(ConfigurationFile configFile, bool requireSerializeSettingAttribute, bool initialize);
    protected ConfigurationFile get_ConfigFile();
    protected void set_ConfigFile(ConfigurationFile value);
    [EditorBrowsableAttribute("1")]
protected virtual void CreateSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual string RetrieveSetting(string name, string setting);
    [EditorBrowsableAttribute("1")]
protected virtual void StoreSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual void PersistSettings();
}
public abstract class GSF.Configuration.CategorizedSettingsBase : SettingsBase {
    private ConfigurationFile m_configFile;
    [CompilerGeneratedAttribute]
private string <CategoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCategoryAttributes>k__BackingField;
    protected ConfigurationFile ConfigFile { get; protected set; }
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public string CategoryName { get; public set; }
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public bool UseCategoryAttributes { get; public set; }
    protected CategorizedSettingsBase(string categoryName);
    protected CategorizedSettingsBase(string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute);
    protected CategorizedSettingsBase(ConfigurationFile configFile, string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, bool initialize);
    protected ConfigurationFile get_ConfigFile();
    protected void set_ConfigFile(ConfigurationFile value);
    [CompilerGeneratedAttribute]
public string get_CategoryName();
    [CompilerGeneratedAttribute]
public void set_CategoryName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCategoryAttributes();
    [CompilerGeneratedAttribute]
public void set_UseCategoryAttributes(bool value);
    [EditorBrowsableAttribute("1")]
protected virtual void CreateSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual string RetrieveSetting(string name, string setting);
    [EditorBrowsableAttribute("1")]
protected virtual void StoreSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual void PersistSettings();
    public string GetFieldCategoryName(string name);
    public string GetFieldDescription(string name);
    public SettingScope GetFieldSettingScope(string name);
}
public abstract class GSF.Configuration.CategorizedSettingsBase`1 : CategorizedSettingsBase`2<TypeConvertedValueExpressionAttribute, TCategorizedSettings> {
    protected CategorizedSettingsBase`1(string categoryName, TypeRegistry typeRegistry);
    protected CategorizedSettingsBase`1(string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, TypeRegistry typeRegistry);
    protected CategorizedSettingsBase`1(ConfigurationFile configFile, string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, bool initialize, TypeRegistry typeRegistry);
}
public abstract class GSF.Configuration.CategorizedSettingsBase`2 : CategorizedSettingsBase {
    private Action`1<TCategorizedSettings> m_updateExpressions;
    private Action`1<TCategorizedSettings> m_updateProperties;
    private TCategorizedSettings m_instance;
    protected CategorizedSettingsBase`2(string categoryName, TypeRegistry typeRegistry);
    protected CategorizedSettingsBase`2(string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, TypeRegistry typeRegistry);
    protected CategorizedSettingsBase`2(ConfigurationFile configFile, string categoryName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, bool initialize, TypeRegistry typeRegistry);
    public void UpdateProperties();
    public void UpdateExpressions();
}
public class GSF.Configuration.CategorizedSettingsElement : ConfigurationElement {
    public static string DefaultValue;
    public static string DefaultDescription;
    public static bool DefaultEncrypted;
    public static SettingScope DefaultScope;
    private static string DefaultCryptoKey;
    private static string EvalRegex;
    private static string EnvRegex;
    private string m_cryptoKey;
    [CompilerGeneratedAttribute]
private CategorizedSettingsElementCollection <Category>k__BackingField;
    private static Regex s_evalRegex;
    private static Regex s_envRegex;
    public CategorizedSettingsElementCollection Category { get; internal set; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("value")]
public string Value { get; public set; }
    [ConfigurationPropertyAttribute("description")]
public string Description { get; public set; }
    [ConfigurationPropertyAttribute("encrypted")]
public bool Encrypted { get; public set; }
    [ConfigurationPropertyAttribute("scope")]
public SettingScope Scope { get; public set; }
    public string SerializedValue { get; }
    unknown bool Modified {internal set; }
    internal CategorizedSettingsElement(CategorizedSettingsElementCollection category);
    internal CategorizedSettingsElement(CategorizedSettingsElementCollection category, string name);
    private static CategorizedSettingsElement();
    [CompilerGeneratedAttribute]
public CategorizedSettingsElementCollection get_Category();
    [CompilerGeneratedAttribute]
internal void set_Category(CategorizedSettingsElementCollection value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    public string get_Description();
    public void set_Description(string value);
    public bool get_Encrypted();
    public void set_Encrypted(bool value);
    public SettingScope get_Scope();
    public void set_Scope(SettingScope value);
    public string get_SerializedValue();
    internal void set_Modified(bool value);
    public void SetCryptoKey(string cryptoKey);
    public void Update(object value);
    public void Update(object value, string description);
    public void Update(object value, string description, bool encrypted);
    public void Update(object value, string description, bool encrypted, SettingScope scope);
    public T ValueAs();
    public T ValueAs(T defaultValue);
    public string ValueAsString();
    public string ValueAsString(string defaultValue);
    public bool ValueAsBoolean();
    public bool ValueAsBoolean(bool defaultValue);
    public byte ValueAsByte();
    public byte ValueAsByte(byte defaultValue);
    public sbyte ValueAsSByte();
    public sbyte ValueAsSByte(sbyte defaultValue);
    public char ValueAsChar();
    public char ValueAsChar(char defaultValue);
    public short ValueAsInt16();
    public short ValueAsInt16(short defaultValue);
    public int ValueAsInt32();
    public int ValueAsInt32(int defaultValue);
    public long ValueAsInt64();
    public long ValueAsInt64(long defaultValue);
    public ushort ValueAsUInt16();
    public ushort ValueAsUInt16(ushort defaultValue);
    public UInt32 ValueAsUInt32();
    public UInt32 ValueAsUInt32(UInt32 defaultValue);
    public ulong ValueAsUInt64();
    public ulong ValueAsUInt64(ulong defaultValue);
    public float ValueAsSingle();
    public float ValueAsSingle(float defaultValue);
    public double ValueAsDouble();
    public double ValueAsDouble(double defaultValue);
    public decimal ValueAsDecimal();
    public decimal ValueAsDecimal(decimal defaultValue);
    public DateTime ValueAsDateTime();
    public DateTime ValueAsDateTime(DateTime defaultValue);
    private string GetRawValue();
    private string EncryptValue(string value);
    private string DecryptValue(string value);
    private string EvaluateValue(string value);
    private static string GetEnvValue(string value);
}
[DefaultMemberAttribute("Item")]
public class GSF.Configuration.CategorizedSettingsElementCollection : ConfigurationElementCollection {
    private string m_cryptoKey;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CategorizedSettingsSection <Section>k__BackingField;
    public string Name { get; internal set; }
    public CategorizedSettingsSection Section { get; internal set; }
    public CategorizedSettingsElement Item { get; public set; }
    public CategorizedSettingsElement Item { get; }
    public CategorizedSettingsElement Item { get; }
    unknown bool Modified {internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public CategorizedSettingsSection get_Section();
    [CompilerGeneratedAttribute]
internal void set_Section(CategorizedSettingsSection value);
    public CategorizedSettingsElement get_Item(int index);
    public void set_Item(int index, CategorizedSettingsElement value);
    public CategorizedSettingsElement get_Item(string name);
    public CategorizedSettingsElement get_Item(string name, bool ensureExistance);
    internal void set_Modified(bool value);
    public void SetCryptoKey(string cryptoKey);
    public int IndexOf(CategorizedSettingsElement setting);
    public void Add(string name, object value);
    public void Add(string name, object value, string description);
    public void Add(string name, object value, string description, bool encryptValue);
    public void Add(string name, object value, string description, bool encryptValue, SettingScope scope);
    public void Add(CategorizedSettingsElement setting);
    public void Remove(string name);
    public void Remove(CategorizedSettingsElement setting);
    public void RemoveAt(int index);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual ConfigurationElement CreateNewElement(string elementName);
    protected virtual object GetElementKey(ConfigurationElement element);
}
[DefaultMemberAttribute("Item")]
public class GSF.Configuration.CategorizedSettingsSection : ConfigurationSection {
    private string m_cryptoKey;
    private Dictionary`2<string, CategorizedSettingsElementCollection> m_sections;
    [CompilerGeneratedAttribute]
private ConfigurationFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SectionLoaded>k__BackingField;
    public ConfigurationFile File { get; internal set; }
    public CategorizedSettingsElementCollection Item { get; }
    public CategorizedSettingsElementCollection General { get; }
    internal bool SectionLoaded { get; private set; }
    unknown bool Modified {internal set; }
    [CompilerGeneratedAttribute]
public ConfigurationFile get_File();
    [CompilerGeneratedAttribute]
internal void set_File(ConfigurationFile value);
    public CategorizedSettingsElementCollection get_Item(string name);
    public CategorizedSettingsElementCollection get_General();
    [CompilerGeneratedAttribute]
internal bool get_SectionLoaded();
    [CompilerGeneratedAttribute]
private void set_SectionLoaded(bool value);
    internal void set_Modified(bool value);
    public void SetCryptoKey(string cryptoKey);
    public void Remove(string name);
    protected virtual void DeserializeSection(XmlReader reader);
    protected virtual string SerializeSection(ConfigurationElement parentElement, string name, ConfigurationSaveMode saveMode);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ConfigurationPropertyCollection <>n__0();
}
public class GSF.Configuration.ConfigurationFile : object {
    private static string CustomSectionName;
    private static string CustomSectionType;
    private string m_cryptoKey;
    private CultureInfo m_culture;
    private ConfigurationSaveMode modreq(System.Runtime.CompilerServices.IsVolatile) m_saveMode;
    private LongSynchronizedOperation m_saveOperation;
    internal bool m_forceSave;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private UserConfigurationFile <UserSettings>k__BackingField;
    private static ConcurrentDictionary`2<string, ConfigurationFile> s_configFiles;
    public CultureInfo Culture { get; public set; }
    public Configuration Configuration { get; private set; }
    public CategorizedSettingsSection Settings { get; }
    internal UserConfigurationFile UserSettings { get; private set; }
    private string BackupConfigFilePath { get; }
    public static ConfigurationFile Current { get; }
    internal ConfigurationFile(string configFilePath);
    private static ConfigurationFile();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    public CategorizedSettingsSection get_Settings();
    [CompilerGeneratedAttribute]
internal UserConfigurationFile get_UserSettings();
    [CompilerGeneratedAttribute]
private void set_UserSettings(UserConfigurationFile value);
    private string get_BackupConfigFilePath();
    public void Save();
    public void Save(ConfigurationSaveMode saveMode);
    private void ExecuteConfigurationSave();
    public void SaveAs(string fileName);
    public void Reload();
    public void RestoreDefaultUserSettings();
    public void SetCryptoKey(string cryptoKey);
    private Configuration GetConfiguration(string configFilePath);
    private void CreateConfigurationFile(string configFilePath);
    private void ValidateConfigurationFile(string configFilePath);
    private static string TrimEnd(string stringToTrim, string textToTrim);
    public static ConfigurationFile get_Current();
    public static ConfigurationFile Open(string configFilePath);
}
public class GSF.Configuration.ConnectionStringParser : object {
    public static char DefaultParameterDelimiter;
    public static char DefaultKeyValueDelimiter;
    public static char DefaultStartValueDelimiter;
    public static char DefaultEndValueDelimiter;
    public static bool DefaultExplicitlySpecifyDefaults;
    public static bool DefaultSerializeUnspecifiedProperties;
    [CompilerGeneratedAttribute]
private char <ParameterDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <KeyValueDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <StartValueDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <EndValueDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitlySpecifyDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeUnspecifiedProperties>k__BackingField;
    private static ConcurrentDictionary`2<Type, ConnectionStringProperty[]> s_allPropertiesLookup;
    private static ConcurrentDictionary`2<Type, ConnectionStringProperty[]> s_explicitPropertiesLookup;
    private static Func`2<Type, ConnectionStringProperty[]> s_allPropertiesFactory;
    private static Func`2<Type, ConnectionStringProperty[]> s_explicitPropertiesFactory;
    public char ParameterDelimiter { get; public set; }
    public char KeyValueDelimiter { get; public set; }
    public char StartValueDelimiter { get; public set; }
    public char EndValueDelimiter { get; public set; }
    public bool ExplicitlySpecifyDefaults { get; public set; }
    public bool SerializeUnspecifiedProperties { get; public set; }
    private static ConnectionStringParser();
    [CompilerGeneratedAttribute]
public char get_ParameterDelimiter();
    [CompilerGeneratedAttribute]
public void set_ParameterDelimiter(char value);
    [CompilerGeneratedAttribute]
public char get_KeyValueDelimiter();
    [CompilerGeneratedAttribute]
public void set_KeyValueDelimiter(char value);
    [CompilerGeneratedAttribute]
public char get_StartValueDelimiter();
    [CompilerGeneratedAttribute]
public void set_StartValueDelimiter(char value);
    [CompilerGeneratedAttribute]
public char get_EndValueDelimiter();
    [CompilerGeneratedAttribute]
public void set_EndValueDelimiter(char value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitlySpecifyDefaults();
    [CompilerGeneratedAttribute]
public void set_ExplicitlySpecifyDefaults(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializeUnspecifiedProperties();
    [CompilerGeneratedAttribute]
public void set_SerializeUnspecifiedProperties(bool value);
    public virtual string ComposeConnectionString(object settingsObject);
    public virtual void ParseConnectionString(string connectionString, object settingsObject);
    protected virtual ConnectionStringProperty[] GetConnectionStringProperties(Type settingsObjectType);
    protected virtual object ConvertToPropertyType(string value, ConnectionStringProperty property);
    protected virtual string ConvertToString(object obj, ConnectionStringProperty property);
    public static string ToConnectionString(XElement element);
    public static XElement ToXML(string connectionString);
    private static void SetXMLContent(XElement parent, string connectionStringValue);
}
public class GSF.Configuration.ConnectionStringParser`1 : ConnectionStringParser {
    private static ConcurrentDictionary`2<Type, ConnectionStringProperty[]> s_connectionStringPropertiesLookup;
    private static TypeRegistry s_typeRegistry;
    private static Func`2<Type, ConnectionStringProperty[]> s_valueFactory;
    [EditorBrowsableAttribute("1")]
public bool SerializeUnspecifiedProperties { get; public set; }
    public static TypeRegistry TypeRegistry { get; public set; }
    private static ConnectionStringParser`1();
    public bool get_SerializeUnspecifiedProperties();
    public void set_SerializeUnspecifiedProperties(bool value);
    protected virtual ConnectionStringProperty[] GetConnectionStringProperties(Type settingsObjectType);
    public static TypeRegistry get_TypeRegistry();
    public static void set_TypeRegistry(TypeRegistry value);
}
public class GSF.Configuration.ConnectionStringParser`2 : ConnectionStringParser`1<TParameterAttribute> {
    public virtual string ComposeConnectionString(object settingsObject);
    public virtual void ParseConnectionString(string connectionString, object settingsObject);
    private static PropertyInfo[] GetNestedSettingsProperties(object settingsObject);
    private static String[] GetNames(PropertyInfo property);
}
[AttributeUsageAttribute("384")]
public class GSF.Configuration.EncryptSettingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Encrypt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrivateKey>k__BackingField;
    public bool Encrypt { get; }
    public string PrivateKey { get; public set; }
    public EncryptSettingAttribute(bool encrypt);
    [CompilerGeneratedAttribute]
public bool get_Encrypt();
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
}
public abstract class GSF.Configuration.IniSettingsBase : SettingsBase {
    private IniFile m_iniFile;
    [CompilerGeneratedAttribute]
private string <SectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCategoryAttributes>k__BackingField;
    protected IniFile IniFile { get; protected set; }
    public string SectionName { get; public set; }
    public bool UseCategoryAttributes { get; public set; }
    protected IniSettingsBase(string iniFileName, string sectionName);
    protected IniSettingsBase(string iniFileName, string sectionName, bool useCategoryAttributes, bool requireSerializeSettingAttribute);
    protected IniSettingsBase(IniFile iniFile, string sectionName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, bool initialize);
    protected IniFile get_IniFile();
    protected void set_IniFile(IniFile value);
    [CompilerGeneratedAttribute]
public string get_SectionName();
    [CompilerGeneratedAttribute]
public void set_SectionName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCategoryAttributes();
    [CompilerGeneratedAttribute]
public void set_UseCategoryAttributes(bool value);
    [EditorBrowsableAttribute("1")]
protected virtual void CreateSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual string RetrieveSetting(string name, string setting);
    [EditorBrowsableAttribute("1")]
protected virtual void StoreSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual void PersistSettings();
    public string GetFieldSectionName(string name);
}
public interface GSF.Configuration.IPersistSettings {
    public bool PersistSettings { get; public set; }
    public string SettingsCategory { get; public set; }
    public abstract virtual bool get_PersistSettings();
    public abstract virtual void set_PersistSettings(bool value);
    public abstract virtual string get_SettingsCategory();
    public abstract virtual void set_SettingsCategory(string value);
    public abstract virtual void SaveSettings();
    public abstract virtual void LoadSettings();
}
[CompilerGeneratedAttribute]
internal class GSF.Configuration.NamespaceDoc : object {
}
public abstract class GSF.Configuration.RegistrySettingsBase : SettingsBase {
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCategoryAttributes>k__BackingField;
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public string RootPath { get; public set; }
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public string KeyName { get; public set; }
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public bool UseCategoryAttributes { get; public set; }
    protected RegistrySettingsBase(string rootPath, string keyName);
    protected RegistrySettingsBase(string rootPath, string keyName, bool useCategoryAttributes, bool requireSerializeSettingAttribute, bool initialize);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public void set_RootPath(string value);
    [CompilerGeneratedAttribute]
public string get_KeyName();
    [CompilerGeneratedAttribute]
public void set_KeyName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCategoryAttributes();
    [CompilerGeneratedAttribute]
public void set_UseCategoryAttributes(bool value);
    [EditorBrowsableAttribute("1")]
protected virtual void CreateSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual string RetrieveSetting(string name, string setting);
    [EditorBrowsableAttribute("1")]
protected virtual void StoreSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("1")]
protected virtual void PersistSettings();
    public string GetFieldKeyName(string name);
}
[AttributeUsageAttribute("384")]
public class GSF.Configuration.SerializeSettingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Serialize>k__BackingField;
    public bool Serialize { get; }
    public SerializeSettingAttribute(bool serialize);
    [CompilerGeneratedAttribute]
public bool get_Serialize();
}
[AttributeUsageAttribute("384")]
public class GSF.Configuration.SettingNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    public string Name { get; }
    public String[] Names { get; }
    public SettingNameAttribute(String[] names);
    public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_Names();
}
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
public abstract class GSF.Configuration.SettingsBase : object {
    private CultureInfo m_culture;
    private BindingFlags m_memberAccessBindingFlags;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private bool <RequireSerializeSettingAttribute>k__BackingField;
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public CultureInfo Culture { get; public set; }
    [EditorBrowsableAttribute("2")]
protected BindingFlags MemberAccessBindingFlags { get; protected set; }
    [BrowsableAttribute("False")]
[SerializeSettingAttribute("False")]
public bool RequireSerializeSettingAttribute { get; public set; }
    public string Item { get; public set; }
    protected SettingsBase(bool requireSerializeSettingAttribute);
    protected virtual override void Finalize();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    protected virtual BindingFlags get_MemberAccessBindingFlags();
    protected virtual void set_MemberAccessBindingFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_RequireSerializeSettingAttribute();
    [CompilerGeneratedAttribute]
public void set_RequireSerializeSettingAttribute(bool value);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [EditorBrowsableAttribute("2")]
protected abstract virtual void CreateSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("2")]
protected abstract virtual string RetrieveSetting(string name, string setting);
    [EditorBrowsableAttribute("2")]
protected abstract virtual void StoreSetting(string name, string setting, string value);
    [EditorBrowsableAttribute("2")]
protected abstract virtual void PersistSettings();
    public string GetSettingName(string name);
    public object GetDefaultValue(string name);
    public bool GetEncryptStatus(string name);
    public string GetEncryptKey(string name);
    public void CreateValue(string name, object value);
    public void SetValue(string name, object value);
    public T GetValue(string name);
    public object GetValue(string name, Type type);
    public void GetValue(string name, T& value);
    private string EncryptValue(string name, string value);
    private string DecryptValue(string name, string value);
    protected virtual void Initialize();
    public virtual void RestoreDefaultSettings();
    [EditorBrowsableAttribute("2")]
protected object DeriveDefaultValue(string name, object value);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Load();
    public virtual void Save();
    [EditorBrowsableAttribute("2")]
protected void ExecuteActionForFields(Action`1<FieldInfo> fieldAction);
    [EditorBrowsableAttribute("2")]
protected void ExecuteActionForProperties(Action`1<PropertyInfo> propertyAction, BindingFlags isGetOrSet);
    private void ExecuteActionForMembers(Action`1<T> memberAction, T[] members);
    [EditorBrowsableAttribute("2")]
protected TValue GetAttributeValue(string name, TValue defaultValue, Func`2<TAttribute, TValue> attributeValue);
    [CompilerGeneratedAttribute]
private void <Initialize>b__35_0(FieldInfo field);
    [CompilerGeneratedAttribute]
private void <Initialize>b__35_1(PropertyInfo property);
    [CompilerGeneratedAttribute]
private void <RestoreDefaultSettings>b__36_0(FieldInfo field);
    [CompilerGeneratedAttribute]
private void <RestoreDefaultSettings>b__36_1(PropertyInfo property);
    [CompilerGeneratedAttribute]
private void <Load>b__40_0(FieldInfo field);
    [CompilerGeneratedAttribute]
private void <Load>b__40_1(PropertyInfo property);
    [CompilerGeneratedAttribute]
private void <Save>b__41_0(FieldInfo field);
    [CompilerGeneratedAttribute]
private void <Save>b__41_1(PropertyInfo property);
}
public enum GSF.Configuration.SettingScope : Enum {
    public int value__;
    public static SettingScope User;
    public static SettingScope Application;
}
[DefaultMemberAttribute("Item")]
public class GSF.Console.Arguments : object {
    public static string TokenRegex;
    public static string DefaultOrderedArgID;
    private string m_commandLine;
    private string m_orderedArgID;
    private int m_orderedArgCount;
    private Dictionary`2<string, string> m_arguments;
    private static Regex CompiledTokenRegex;
    public string Item { get; }
    public int Count { get; }
    public string OrderedArgID { get; }
    public int OrderedArgCount { get; }
    public String[] OrderedArgs { get; }
    public bool ContainsHelpRequest { get; }
    protected Dictionary`2<string, string> InternalDictionary { get; }
    public Arguments(string commandLine);
    public Arguments(string commandLine, bool skipFirstArgument);
    public Arguments(string commandLine, string orderedArgID);
    public Arguments(string commandLine, string orderedArgID, bool skipFirstArgument);
    protected Arguments(SerializationInfo info, StreamingContext context);
    private static Arguments();
    public virtual string get_Item(string argument);
    public virtual int get_Count();
    public virtual string get_OrderedArgID();
    public virtual int get_OrderedArgCount();
    public virtual String[] get_OrderedArgs();
    public virtual bool get_ContainsHelpRequest();
    protected Dictionary`2<string, string> get_InternalDictionary();
    public virtual bool TryGetValue(string argument, String& value);
    public virtual bool Exists(string argument);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static String[] ParseCommand(string command);
    public static String[] ToArgs(string command);
    public static string Escape(string arg);
    [CompilerGeneratedAttribute]
private string <get_OrderedArgs>b__20_0(int arg);
}
[ExtensionAttribute]
public static class GSF.Console.Command : object {
    public static CommandResponse Execute(string fileName, string arguments, int timeout);
    public static bool Execute(string fileName, string arguments, String& standardOutput, String& standardError, Int32& exitCode);
    public static bool Execute(string fileName, string arguments, String& standardOutput, String& standardError, Boolean& processCompleted, Int32& exitCode, int timeout);
    [ExtensionAttribute]
public static string ShellEncode(string parameter);
    [ExtensionAttribute]
public static string ShellDecode(string parameter);
}
public class GSF.Console.CommandException : Exception {
    private bool m_processCompleted;
    private int m_exitCode;
    public bool ProcessCompleted { get; }
    public int ExitCode { get; }
    public CommandException(string message, bool processCompleted, int exitCode, Exception innerException);
    public bool get_ProcessCompleted();
    public int get_ExitCode();
}
public class GSF.Console.CommandResponse : object {
    private string m_standardOutput;
    private int m_exitCode;
    public string StandardOutput { get; }
    public int ExitCode { get; }
    public CommandResponse(string standardOutput, int exitCode);
    public string get_StandardOutput();
    public int get_ExitCode();
}
public static class GSF.Console.Events : object {
    private static ConsoleWindowEventHandler s_handler;
    [CompilerGeneratedAttribute]
private static EventHandler`1<CancelEventArgs> CancelKeyPress;
    [CompilerGeneratedAttribute]
private static EventHandler`1<CancelEventArgs> BreakKeyPress;
    [CompilerGeneratedAttribute]
private static EventHandler`1<CancelEventArgs> ConsoleClosing;
    [CompilerGeneratedAttribute]
private static EventHandler UserLoggingOff;
    [CompilerGeneratedAttribute]
private static EventHandler SystemShutdown;
    private static bool SetConsoleWindowEventRaising(ConsoleWindowEventHandler handler, bool enable);
    [CompilerGeneratedAttribute]
public static void add_CancelKeyPress(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_CancelKeyPress(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_BreakKeyPress(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BreakKeyPress(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ConsoleClosing(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ConsoleClosing(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_UserLoggingOff(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_UserLoggingOff(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_SystemShutdown(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_SystemShutdown(EventHandler value);
    public static void EnableRaisingEvents();
    public static void DisableRaisingEvents();
    private static bool HandleConsoleWindowEvents(ConsoleEventType controlType);
}
[CompilerGeneratedAttribute]
internal class GSF.Console.NamespaceDoc : object {
}
public class GSF.Data.AdoDataConnection : object {
    private string m_connectionString;
    private Type m_connectionType;
    private bool m_disposeConnection;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private IDbConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <AdapterType>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseType <DatabaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultTimeout>k__BackingField;
    private static ConcurrentDictionary`2<string, AdoDataConnection> s_configuredConnections;
    public IDbConnection Connection { get; private set; }
    public Type AdapterType { get; }
    public DatabaseType DatabaseType { get; public set; }
    public int DefaultTimeout { get; public set; }
    public object UtcNow { get; }
    public IsolationLevel DefaultIsolationLevel { get; }
    public bool IsJetEngine { get; }
    public bool IsSQLServer { get; }
    public bool IsMySQL { get; }
    public bool IsOracle { get; }
    public bool IsSqlite { get; }
    public bool IsPostgreSQL { get; }
    public AdoDataConnection(string settingsCategory);
    public AdoDataConnection(string connectionString, string dataProviderString);
    public AdoDataConnection(string connectionString, Type connectionType, Type adapterType);
    public AdoDataConnection(IDbConnection connection, Type adapterType, bool disposeConnection);
    private AdoDataConnection(string connectionString, string dataProviderString, bool openConnection);
    private static AdoDataConnection();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public IDbConnection get_Connection();
    [CompilerGeneratedAttribute]
private void set_Connection(IDbConnection value);
    [CompilerGeneratedAttribute]
public Type get_AdapterType();
    [CompilerGeneratedAttribute]
public DatabaseType get_DatabaseType();
    [CompilerGeneratedAttribute]
public void set_DatabaseType(DatabaseType value);
    [CompilerGeneratedAttribute]
public int get_DefaultTimeout();
    [CompilerGeneratedAttribute]
public void set_DefaultTimeout(int value);
    public object get_UtcNow();
    public IsolationLevel get_DefaultIsolationLevel();
    public bool get_IsJetEngine();
    public bool get_IsSQLServer();
    public bool get_IsMySQL();
    public bool get_IsOracle();
    public bool get_IsSqlite();
    public bool get_IsPostgreSQL();
    public void ExecuteScript(string scriptPath);
    public void ExecuteScript(TextReader scriptReader);
    [StringFormatMethodAttribute("sqlFormat")]
public int ExecuteNonQuery(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public int ExecuteNonQuery(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public IDataReader ExecuteReader(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public IDataReader ExecuteReader(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public IDataReader ExecuteReader(CommandBehavior behavior, int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public T ExecuteScalar(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public T ExecuteScalar(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public T ExecuteScalar(T defaultValue, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public T ExecuteScalar(T defaultValue, int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(Type returnType, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(Type returnType, int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(Type returnType, object defaultValue, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(Type returnType, object defaultValue, int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public object ExecuteScalar(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataRow RetrieveRow(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataRow RetrieveRow(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataTable RetrieveData(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataTable RetrieveData(int timeout, string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataSet RetrieveDataSet(string sqlFormat, Object[] parameters);
    [StringFormatMethodAttribute("sqlFormat")]
public DataSet RetrieveDataSet(int timeout, string sqlFormat, Object[] parameters);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public string EscapeIdentifier(string identifier, bool useAnsiQuotes);
    public object Bool(bool value);
    public object Guid(Guid value);
    public Guid Guid(DataRow row, string fieldName);
    [StringFormatMethodAttribute("format")]
public string ParameterizedQueryString(string format, String[] parameterNames);
    private DatabaseType GetDatabaseType();
    private string GenericParameterizedQueryString(string sqlFormat, Object[] parameters);
    private Object[] ResolveParameters(Object[] parameters);
    public static void ReloadConfigurationSettings();
    public static string ToDataProviderString(Type connectionType, Type adapterType);
}
public abstract class GSF.Data.BulkDataOperationBase : object {
    protected Schema m_fromSchema;
    protected Schema m_toSchema;
    protected long m_overallProgress;
    protected long m_overallTotal;
    private int m_rowReportInterval;
    protected int m_timeout;
    protected Tables m_tableCollection;
    protected bool m_useFromSchemaRI;
    private List`1<string> m_excludedTables;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`4<string, bool, int, int>> TableProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`3<string, int, int>> RowProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<int, int>> OverallProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<string, Exception>> SQLFailure;
    public Schema FromSchema { get; public set; }
    public Schema ToSchema { get; public set; }
    public int RowReportInterval { get; public set; }
    public int Timeout { get; public set; }
    public bool UseFromSchemaReferentialIntegrity { get; public set; }
    public Tables WorkTables { get; }
    public List`1<string> ExcludedTables { get; }
    protected BulkDataOperationBase(string fromConnectString, string toConnectString);
    protected BulkDataOperationBase(Schema fromSchema, Schema toSchema);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TableProgress(EventHandler`1<EventArgs`4<string, bool, int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TableProgress(EventHandler`1<EventArgs`4<string, bool, int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RowProgress(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RowProgress(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OverallProgress(EventHandler`1<EventArgs`2<int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OverallProgress(EventHandler`1<EventArgs`2<int, int>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SQLFailure(EventHandler`1<EventArgs`2<string, Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SQLFailure(EventHandler`1<EventArgs`2<string, Exception>> value);
    public virtual Schema get_FromSchema();
    public virtual void set_FromSchema(Schema value);
    public virtual Schema get_ToSchema();
    public virtual void set_ToSchema(Schema value);
    public virtual int get_RowReportInterval();
    public virtual void set_RowReportInterval(int value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseFromSchemaReferentialIntegrity();
    public virtual void set_UseFromSchemaReferentialIntegrity(bool value);
    public virtual Tables get_WorkTables();
    public List`1<string> get_ExcludedTables();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Analyze();
    public abstract virtual void Execute();
    protected virtual void OnTableProgress(string TableName, bool Executed, int CurrentTable, int TotalTables);
    protected virtual void OnRowProgress(string TableName, int CurrentRow, int TotalRows);
    protected virtual void OnOverallProgress(int Current, int Total);
    protected virtual void OnSQLFailure(string SQL, Exception ex);
}
public enum GSF.Data.DatabaseType : Enum {
    public int value__;
    public static DatabaseType Access;
    public static DatabaseType SQLServer;
    public static DatabaseType MySQL;
    public static DatabaseType Oracle;
    public static DatabaseType SQLite;
    public static DatabaseType PostgreSQL;
    public static DatabaseType Other;
}
public class GSF.Data.DataDeleter : BulkDataOperationBase {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    public DataDeleter(string fromConnectString, string toConnectString);
    public DataDeleter(Schema fromSchema, Schema toSchema);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    public virtual void Close();
    public virtual void Execute();
    private void ExecuteDeletes(Table fromTable, Table toTable);
}
[ExtensionAttribute]
public static class GSF.Data.DataExtensions : object {
    public static int DefaultTimeoutDuration;
    private static String[] s_plsqlIdentifiers;
    private static Regex s_sqlParameterRegex;
    private static Regex s_sqlCommentRegex;
    private static Regex s_sqlIdentifierRegex;
    private static DataExtensions();
    [ExtensionAttribute]
public static string SQLEncode(string sql, DatabaseType databaseType);
    [ExtensionAttribute]
public static int ExecuteNonQuery(TConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(TConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OleDbConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OdbcConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(SqlConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(IDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(IDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OleDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(OdbcCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static int ExecuteNonQuery(SqlCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(TConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(TConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(TConnection connection, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static OleDbDataReader ExecuteReader(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static OleDbDataReader ExecuteReader(OleDbConnection connection, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static OdbcDataReader ExecuteReader(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static OdbcDataReader ExecuteReader(OdbcConnection connection, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static SqlDataReader ExecuteReader(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static SqlDataReader ExecuteReader(SqlConnection connection, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbCommand command, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static OleDbDataReader ExecuteReader(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static OleDbDataReader ExecuteReader(OleDbCommand command, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static OdbcDataReader ExecuteReader(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static OdbcDataReader ExecuteReader(OdbcCommand command, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static SqlDataReader ExecuteReader(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static SqlDataReader ExecuteReader(SqlCommand command, string sql, CommandBehavior behavior, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(TConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(TConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OleDbConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OdbcConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(SqlConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(IDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(IDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OleDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(OdbcCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static object ExecuteScalar(SqlCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static void ExecuteTSQLScript(IDbConnection connection, string scriptPath);
    [ExtensionAttribute]
public static void ExecuteTSQLScript(IDbConnection connection, TextReader scriptReader);
    [ExtensionAttribute]
public static void ExecuteMySQLScript(IDbConnection connection, string scriptPath);
    [ExtensionAttribute]
public static void ExecuteMySQLScript(IDbConnection connection, TextReader scriptReader);
    [ExtensionAttribute]
public static void ExecuteOracleScript(IDbConnection connection, string scriptPath);
    [ExtensionAttribute]
public static void ExecuteOracleScript(IDbConnection connection, TextReader scriptReader);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbConnection connection, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbConnection connection, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcConnection connection, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcConnection connection, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlConnection connection, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlConnection connection, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlConnection connection, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(IDbConnection connection, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(IDbConnection connection, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbCommand command, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbCommand command, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OleDbCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcCommand command, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcCommand command, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(OdbcCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlCommand command, string sql);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlCommand command, string sql, int timeout);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(SqlCommand command, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(IDbCommand command, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataRow RetrieveRow(IDbCommand command, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbConnection connection, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcConnection connection, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlConnection connection, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(IDbConnection connection, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(IDbConnection connection, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbCommand command, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OleDbCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcCommand command, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(OdbcCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlCommand command, string sql);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(SqlCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(IDbCommand command, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataTable RetrieveData(IDbCommand command, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbConnection connection, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcConnection connection, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlConnection connection, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlConnection connection, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlConnection connection, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlConnection connection, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(IDbConnection connection, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(IDbConnection connection, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbCommand command, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OleDbCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcCommand command, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(OdbcCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlCommand command, string sql);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlCommand command, string sql, int startRow, int maxRows, int timeout);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlCommand command, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(SqlCommand command, string sql, int startRow, int maxRows, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(IDbCommand command, Type dataAdapterType, string sql, Object[] parameters);
    [ExtensionAttribute]
public static DataSet RetrieveDataSet(IDbCommand command, Type dataAdapterType, string sql, int timeout, Object[] parameters);
    [ExtensionAttribute]
public static T ConvertField(DataRow row, string field);
    [ExtensionAttribute]
public static T ConvertField(DataRow row, string field, T defaultValue);
    [ExtensionAttribute]
public static object ConvertField(DataRow row, string field, Type type);
    [ExtensionAttribute]
public static object ConvertField(DataRow row, string field, Type type, object defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> ConvertNullableField(DataRow row, string field);
    [ExtensionAttribute]
public static Guid ConvertGuidField(DataRow row, string field, Nullable`1<Guid> defaultValue);
    [ExtensionAttribute]
public static int UpdateData(OleDbConnection connection, DataTable sourceData, string sourceSql);
    [ExtensionAttribute]
public static int UpdateData(OdbcConnection connection, DataTable sourceData, string sourceSql);
    [ExtensionAttribute]
public static int UpdateData(SqlConnection connection, DataTable sourceData, string sourceSql);
    [ExtensionAttribute]
public static void PopulateParameters(OleDbCommand command, object parameter1, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(OleDbCommand command, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(OdbcCommand command, object parameter1, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(OdbcCommand command, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(SqlCommand command, object parameter1, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(SqlCommand command, Object[] parameters);
    [ExtensionAttribute]
public static void PopulateParameters(TDbCommand command, Action`1<TDbCommand> deriveParameters, Object[] values);
    private static bool IsStoredProcedure(string sql);
    [ExtensionAttribute]
public static void AddParameterWithValue(IDbCommand command, string name, object value, ParameterDirection direction);
    [ExtensionAttribute]
public static void AddParametersWithValues(IDbCommand command, string sql, Object[] values);
    private static bool IsValidParameter(string token);
    [ExtensionAttribute]
public static IDbCommand CreateParameterizedCommand(IDbConnection connection, string sql, Object[] values);
    [ExtensionAttribute]
public static DataTable ToDataTable(string delimitedData, string delimiter, bool header);
    [ExtensionAttribute]
public static string ToDelimitedString(DataTable table, string delimiter, bool quoted, bool header);
}
public class GSF.Data.DataInserter : BulkDataOperationBase {
    private bool m_attemptBulkInsert;
    private bool m_forceBulkInsert;
    private string m_bulkInsertSettings;
    private Encoding m_bulkInsertEncoding;
    private string m_bulkInsertFilePath;
    private string m_delimiterReplacement;
    private bool m_clearDestinationTables;
    private bool m_attemptTruncateTable;
    private bool m_preserveAutoIncValues;
    private bool m_forceTruncateTable;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<string>> TableCleared;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<string>> BulkInsertExecuting;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`3<string, int, int>> BulkInsertCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`3<string, string, Exception>> BulkInsertException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    public bool AttemptBulkInsert { get; public set; }
    public bool ForceBulkInsert { get; public set; }
    public string BulkInsertSettings { get; public set; }
    public Encoding BulkInsertEncoding { get; public set; }
    public string BulkInsertFilePath { get; public set; }
    public string DelimiterReplacement { get; public set; }
    public bool ClearDestinationTables { get; public set; }
    public bool AttemptTruncateTable { get; public set; }
    public bool ForceTruncateTable { get; public set; }
    public bool PreserveAutoIncValues { get; public set; }
    public DataInserter(string FromConnectString, string ToConnectString);
    public DataInserter(Schema FromSchema, Schema ToSchema);
    [CompilerGeneratedAttribute]
public void add_TableCleared(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_TableCleared(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void add_BulkInsertExecuting(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_BulkInsertExecuting(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void add_BulkInsertCompleted(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public void remove_BulkInsertCompleted(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public void add_BulkInsertException(EventHandler`1<EventArgs`3<string, string, Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_BulkInsertException(EventHandler`1<EventArgs`3<string, string, Exception>> value);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    public bool get_AttemptBulkInsert();
    public void set_AttemptBulkInsert(bool value);
    public bool get_ForceBulkInsert();
    public void set_ForceBulkInsert(bool value);
    public string get_BulkInsertSettings();
    public void set_BulkInsertSettings(string value);
    public Encoding get_BulkInsertEncoding();
    public void set_BulkInsertEncoding(Encoding value);
    public string get_BulkInsertFilePath();
    public void set_BulkInsertFilePath(string value);
    public string get_DelimiterReplacement();
    public void set_DelimiterReplacement(string value);
    public bool get_ClearDestinationTables();
    public void set_ClearDestinationTables(bool value);
    public bool get_AttemptTruncateTable();
    public void set_AttemptTruncateTable(bool value);
    public bool get_ForceTruncateTable();
    public void set_ForceTruncateTable(bool value);
    public bool get_PreserveAutoIncValues();
    public void set_PreserveAutoIncValues(bool value);
    public virtual void Close();
    public virtual void Execute();
    private bool ClearTable(Table table);
    private void ResetAutoIncValues(Table table);
    private void ExecuteInserts(Table fromTable, Table toTable);
    private void InsertDestinationRecord(Table toTable, Fields fieldCollection, string insertSQLStub, string updateSQLStub, string countSQLStub, bool usingIdentityInsert, Table sourceTable, Field autoIncField, bool skipKeyValuePreservation, IDataReader fromReader);
    private void InsertOrUpdate(Table toTable, StringBuilder insertSQL, StringBuilder updateSQL, StringBuilder countSQL, StringBuilder whereSQL, bool addedFirstInsertField, bool addedFirstUpdateField);
    private bool SetupBulkInsert(Table toTable, Field autoIncField, String& bulkInsertFile, String& fieldTerminator, String& rowTerminator, FileStream& bulkInsertFileStream);
    private void WriteBulkInsertRecord(Table toTable, Fields fieldCollection, Table sourceTable, string fieldTerminator, string rowTerminator, FileStream bulkInsertFileStream, IDataReader fromReader);
    private void CompleteBulkInsert(Table toTable, int progressIndex, string bulkInsertFile, FileStream bulkInsertFileStream);
    internal object DereferenceValue(Table sourceTable, string fieldName, object value, ArrayList fieldStack);
    private void ParseBulkInsertSettings(String& fieldTerminator, String& rowTerminator);
    private string UnEncodeSetting(string setting);
    private string RemoveQuotes(string value);
}
[ExtensionAttribute]
public static class GSF.Data.DataRowExtensions : object {
    [ExtensionAttribute]
public static Byte[] AsByteArray(DataRow row, string columnName);
    [ExtensionAttribute]
public static Byte[] AsByteArray(DataRow row, int ordinal);
    [ExtensionAttribute]
public static Byte[] AsByteArray(DataRow row, string columnName, Byte[] valueIfNull);
    [ExtensionAttribute]
public static Byte[] AsByteArray(DataRow row, int ordinal, Byte[] valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<UInt32> AsUInt32(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<UInt32> AsUInt32(DataRow row, int ordinal);
    [ExtensionAttribute]
public static UInt32 AsUInt32(DataRow row, string columnName, UInt32 valueIfNull);
    [ExtensionAttribute]
public static UInt32 AsUInt32(DataRow row, int ordinal, UInt32 valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<int> AsInt32(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<int> AsInt32(DataRow row, int ordinal);
    [ExtensionAttribute]
public static int AsInt32(DataRow row, string columnName, int valueIfNull);
    [ExtensionAttribute]
public static int AsInt32(DataRow row, int ordinal, int valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<byte> AsByte(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<byte> AsByte(DataRow row, int ordinal);
    [ExtensionAttribute]
public static byte AsByte(DataRow row, string columnName, byte valueIfNull);
    [ExtensionAttribute]
public static byte AsByte(DataRow row, int ordinal, byte valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<short> AsInt16(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<short> AsInt16(DataRow row, int ordinal);
    [ExtensionAttribute]
public static short AsInt16(DataRow row, string columnName, short valueIfNull);
    [ExtensionAttribute]
public static short AsInt16(DataRow row, int ordinal, short valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<Guid> AsGuid(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<Guid> AsGuid(DataRow row, int ordinal);
    [ExtensionAttribute]
public static Guid AsGuid(DataRow row, string columnName, Guid valueIfNull);
    [ExtensionAttribute]
public static Guid AsGuid(DataRow row, int ordinal, Guid valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<long> AsInt64(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<long> AsInt64(DataRow row, int ordinal);
    [ExtensionAttribute]
public static long AsInt64(DataRow row, string columnName, long valueIfNull);
    [ExtensionAttribute]
public static long AsInt64(DataRow row, int ordinal, long valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<bool> AsBoolean(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<bool> AsBoolean(DataRow row, int ordinal);
    [ExtensionAttribute]
public static bool AsBoolean(DataRow row, string columnName, bool valueIfNull);
    [ExtensionAttribute]
public static bool AsBoolean(DataRow row, int ordinal, bool valueIfNull);
    [ExtensionAttribute]
public static string AsString(DataRow row, string columnName);
    [ExtensionAttribute]
public static string AsString(DataRow row, int ordinal);
    [ExtensionAttribute]
public static string AsString(DataRow row, string columnName, string valueIfNull);
    [ExtensionAttribute]
public static string AsString(DataRow row, int ordinal, string valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<DateTime> AsDateTime(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<DateTime> AsDateTime(DataRow row, int ordinal);
    [ExtensionAttribute]
public static DateTime AsDateTime(DataRow row, string columnName, DateTime valueIfNull);
    [ExtensionAttribute]
public static DateTime AsDateTime(DataRow row, int ordinal, DateTime valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<double> AsDouble(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<double> AsDouble(DataRow row, int ordinal);
    [ExtensionAttribute]
public static double AsDouble(DataRow row, string columnName, double valueIfNull);
    [ExtensionAttribute]
public static double AsDouble(DataRow row, int ordinal, double valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<decimal> AsDecimal(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<decimal> AsDecimal(DataRow row, int ordinal);
    [ExtensionAttribute]
public static decimal AsDecimal(DataRow row, string columnName, decimal valueIfNull);
    [ExtensionAttribute]
public static decimal AsDecimal(DataRow row, int ordinal, decimal valueIfNull);
    [ExtensionAttribute]
public static Nullable`1<float> AsSingle(DataRow row, string columnName);
    [ExtensionAttribute]
public static Nullable`1<float> AsSingle(DataRow row, int ordinal);
    [ExtensionAttribute]
public static float AsSingle(DataRow row, string columnName, float valueIfNull);
    [ExtensionAttribute]
public static float AsSingle(DataRow row, int ordinal, float valueIfNull);
}
public class GSF.Data.DataSetEqualityComparer : object {
    public static DataSetEqualityComparer Default;
    private static DataSetEqualityComparer();
    public sealed virtual bool Equals(DataSet x, DataSet y);
    public sealed virtual int GetHashCode(DataSet obj);
}
[ExtensionAttribute]
public static class GSF.Data.DataSetExtensions : object {
    private static Type[] s_supportedDataTypes;
    private static DataSetExtensions();
    [ExtensionAttribute]
public static void SerializeToStream(DataSet source, Stream destination, bool assumeStringForUnknownTypes, bool useNullableDataTypes);
    [ExtensionAttribute]
public static DataSet DeserializeToDataSet(Stream source);
    [ExtensionAttribute]
public static DataType GetDataType(Type objectType, bool assumeStringForUnknownTypes);
    [ExtensionAttribute]
public static Type DeriveColumnType(DataType dataType);
    [ExtensionAttribute]
private static string NotDBNullString(object value);
    [ExtensionAttribute]
private static T NotDBNull(object value, T defaultValue);
    [ExtensionAttribute]
private static T NotDBNull(object value);
}
public enum GSF.Data.DataType : Enum {
    public byte value__;
    public static DataType Boolean;
    public static DataType Byte;
    public static DataType Char;
    public static DataType DateTime;
    public static DataType Decimal;
    public static DataType Double;
    public static DataType Guid;
    public static DataType Int16;
    public static DataType Int32;
    public static DataType Int64;
    public static DataType SByte;
    public static DataType Single;
    public static DataType String;
    public static DataType TimeSpan;
    public static DataType UInt16;
    public static DataType UInt32;
    public static DataType UInt64;
    public static DataType Blob;
    public static DataType Object;
}
public class GSF.Data.DataUpdater : BulkDataOperationBase {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    public DataUpdater(string fromConnectString, string toConnectString);
    public DataUpdater(Schema fromSchema, Schema toSchema);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    public virtual void Close();
    public virtual void Execute();
    private void ExecuteUpdates(Table fromTable, Table toTable);
}
public class GSF.Data.Field : object {
    private Fields m_parent;
    private string m_name;
    private OleDbType m_dataType;
    private int m_ordinal;
    private bool m_allowsNulls;
    private bool m_autoIncrement;
    private int m_autoIncrementSeed;
    private int m_autoIncrementStep;
    private bool m_hasDefault;
    private object m_defaultValue;
    private int m_maxLength;
    private int m_numericPrecision;
    private int m_numericScale;
    private int m_dateTimePrecision;
    private bool m_readOnly;
    private bool m_unique;
    private string m_description;
    private Hashtable m_autoIncrementTranslations;
    private object m_value;
    private bool m_isPrimaryKey;
    private int m_primaryKeyOrdinal;
    private string m_primaryKeyName;
    private ForeignKeyFields m_foreignKeys;
    private Field m_referencedBy;
    public string Name { get; public set; }
    public string SQLEscapedName { get; }
    public OleDbType Type { get; public set; }
    public int Ordinal { get; public set; }
    public bool AllowsNulls { get; internal set; }
    public bool AutoIncrement { get; internal set; }
    public int AutoIncrementSeed { get; internal set; }
    public int AutoIncrementStep { get; internal set; }
    public bool HasDefault { get; internal set; }
    public object DefaultValue { get; internal set; }
    public int MaxLength { get; internal set; }
    public int NumericPrecision { get; internal set; }
    public int NumericScale { get; internal set; }
    public int DateTimePrecision { get; internal set; }
    public bool ReadOnly { get; internal set; }
    public bool Unique { get; internal set; }
    public string Description { get; internal set; }
    internal Hashtable AutoIncrementTranslations { get; internal set; }
    public object Value { get; public set; }
    public bool IsPrimaryKey { get; public set; }
    public int PrimaryKeyOrdinal { get; public set; }
    public string PrimaryKeyName { get; public set; }
    public ForeignKeyFields ForeignKeys { get; public set; }
    public Field ReferencedBy { get; internal set; }
    public bool IsForeignKey { get; }
    public Fields Parent { get; internal set; }
    public Table Table { get; }
    public string SQLEncodedValue { get; }
    public string NonNullNativeValue { get; }
    public Field(string Name, OleDbType Type);
    public string get_Name();
    public void set_Name(string value);
    public string get_SQLEscapedName();
    public OleDbType get_Type();
    public void set_Type(OleDbType value);
    public int get_Ordinal();
    public void set_Ordinal(int value);
    public bool get_AllowsNulls();
    internal void set_AllowsNulls(bool value);
    public bool get_AutoIncrement();
    internal void set_AutoIncrement(bool value);
    public int get_AutoIncrementSeed();
    internal void set_AutoIncrementSeed(int value);
    public int get_AutoIncrementStep();
    internal void set_AutoIncrementStep(int value);
    public bool get_HasDefault();
    internal void set_HasDefault(bool value);
    public object get_DefaultValue();
    internal void set_DefaultValue(object value);
    public int get_MaxLength();
    internal void set_MaxLength(int value);
    public int get_NumericPrecision();
    internal void set_NumericPrecision(int value);
    public int get_NumericScale();
    internal void set_NumericScale(int value);
    public int get_DateTimePrecision();
    internal void set_DateTimePrecision(int value);
    public bool get_ReadOnly();
    internal void set_ReadOnly(bool value);
    public bool get_Unique();
    internal void set_Unique(bool value);
    public string get_Description();
    internal void set_Description(string value);
    internal Hashtable get_AutoIncrementTranslations();
    internal void set_AutoIncrementTranslations(Hashtable value);
    public object get_Value();
    public void set_Value(object value);
    public bool get_IsPrimaryKey();
    public void set_IsPrimaryKey(bool value);
    public int get_PrimaryKeyOrdinal();
    public void set_PrimaryKeyOrdinal(int value);
    public string get_PrimaryKeyName();
    public void set_PrimaryKeyName(string value);
    public ForeignKeyFields get_ForeignKeys();
    public void set_ForeignKeys(ForeignKeyFields value);
    public Field get_ReferencedBy();
    internal void set_ReferencedBy(Field value);
    public bool get_IsForeignKey();
    public Fields get_Parent();
    internal void set_Parent(Fields value);
    public Table get_Table();
    public sealed virtual int CompareTo(object obj);
    public string get_SQLEncodedValue();
    public string get_NonNullNativeValue();
    internal static ReferentialAction GetReferentialAction(string action);
}
[DefaultMemberAttribute("Item")]
public class GSF.Data.Fields : object {
    private Table m_parent;
    private Dictionary`2<string, Field> m_fields;
    private List`1<Field> m_fieldList;
    public Table Parent { get; }
    internal Dictionary`2<string, Field> FieldDictionary { get; }
    internal List`1<Field> FieldList { get; }
    public Field Item { get; }
    public Field Item { get; }
    public int Count { get; }
    internal Fields(Table Parent);
    public Table get_Parent();
    internal Dictionary`2<string, Field> get_FieldDictionary();
    internal List`1<Field> get_FieldList();
    public Field get_Item(int index);
    public Field get_Item(string name);
    public int get_Count();
    public void Add(Field newField);
    public void Remove(Field field);
    public void Clear();
    public sealed virtual IEnumerator`1<Field> GetEnumerator();
    public string GetList(bool returnAutoInc, Func`2<string, string> sqlEscapeFunction);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class GSF.Data.ForeignKeyField : object {
    private ForeignKeyFields m_Parent;
    private Field m_primaryKey;
    private Field m_foreignKey;
    private int m_ordinal;
    private string m_keyName;
    private ReferentialAction m_updateRule;
    private ReferentialAction m_deleteRule;
    public ForeignKeyFields Parent { get; }
    public Field PrimaryKey { get; public set; }
    public Field ForeignKey { get; public set; }
    public int Ordinal { get; public set; }
    public string KeyName { get; public set; }
    public ReferentialAction UpdateRule { get; public set; }
    public ReferentialAction DeleteRule { get; public set; }
    internal ForeignKeyField(ForeignKeyFields Parent);
    public ForeignKeyFields get_Parent();
    public Field get_PrimaryKey();
    public void set_PrimaryKey(Field value);
    public Field get_ForeignKey();
    public void set_ForeignKey(Field value);
    public int get_Ordinal();
    public void set_Ordinal(int value);
    public string get_KeyName();
    public void set_KeyName(string value);
    public ReferentialAction get_UpdateRule();
    public void set_UpdateRule(ReferentialAction value);
    public ReferentialAction get_DeleteRule();
    public void set_DeleteRule(ReferentialAction value);
}
[DefaultMemberAttribute("Item")]
public class GSF.Data.ForeignKeyFields : object {
    private Field m_parent;
    private Dictionary`2<string, ForeignKeyField> m_fields;
    private List`1<ForeignKeyField> m_fieldList;
    public Field Parent { get; }
    internal Dictionary`2<string, ForeignKeyField> FieldDictionary { get; }
    internal List`1<ForeignKeyField> FieldsList { get; }
    public ForeignKeyField Item { get; }
    public ForeignKeyField Item { get; }
    public int Count { get; }
    internal ForeignKeyFields(Field Parent);
    public Field get_Parent();
    internal Dictionary`2<string, ForeignKeyField> get_FieldDictionary();
    internal List`1<ForeignKeyField> get_FieldsList();
    public ForeignKeyField get_Item(int index);
    public ForeignKeyField get_Item(string name);
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal void Add(ForeignKeyField newField);
    public string GetList();
}
public interface GSF.Data.IBulkDataOperation {
    public Tables WorkTables { get; }
    public Schema FromSchema { get; public set; }
    public Schema ToSchema { get; public set; }
    public int RowReportInterval { get; public set; }
    public int Timeout { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_TableProgress(EventHandler`1<EventArgs`4<string, bool, int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TableProgress(EventHandler`1<EventArgs`4<string, bool, int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RowProgress(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RowProgress(EventHandler`1<EventArgs`3<string, int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OverallProgress(EventHandler`1<EventArgs`2<int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OverallProgress(EventHandler`1<EventArgs`2<int, int>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SQLFailure(EventHandler`1<EventArgs`2<string, Exception>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SQLFailure(EventHandler`1<EventArgs`2<string, Exception>> value);
    public abstract virtual Tables get_WorkTables();
    public abstract virtual Schema get_FromSchema();
    public abstract virtual void set_FromSchema(Schema value);
    public abstract virtual Schema get_ToSchema();
    public abstract virtual void set_ToSchema(Schema value);
    public abstract virtual int get_RowReportInterval();
    public abstract virtual void set_RowReportInterval(int value);
    public abstract virtual int get_Timeout();
    public abstract virtual void set_Timeout(int value);
    public abstract virtual void Execute();
    public abstract virtual void Close();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.AdditionalFieldSearchAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalFieldTable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryKeyField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldKeyField>k__BackingField;
    public string Condition { get; }
    public string AdditionalFieldTable { get; }
    public string PrimaryKeyField { get; }
    public string ValueField { get; }
    public string FieldKeyField { get; }
    public AdditionalFieldSearchAttribute(string condition, string additionalFieldsTable, string primaryKeyCollumn, string valueCollumn, string fieldKeyCollumn);
    public AdditionalFieldSearchAttribute(string condition);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public string get_AdditionalFieldTable();
    [CompilerGeneratedAttribute]
public string get_PrimaryKeyField();
    [CompilerGeneratedAttribute]
public string get_ValueField();
    [CompilerGeneratedAttribute]
public string get_FieldKeyField();
}
public enum GSF.Data.Model.AffixPosition : Enum {
    public int value__;
    public static AffixPosition Prefix;
    public static AffixPosition Suffix;
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.AllowSearchAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AllowSearch>k__BackingField;
    public bool AllowSearch { get; }
    [CompilerGeneratedAttribute]
public bool get_AllowSearch();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.AmendExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AmendmentText>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetExpression <TargetExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private AffixPosition <AffixPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementTypes <StatementTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DatabaseType> <TargetDatabaseType>k__BackingField;
    public string AmendmentText { get; }
    public TargetExpression TargetExpression { get; public set; }
    public AffixPosition AffixPosition { get; public set; }
    public StatementTypes StatementTypes { get; public set; }
    public Nullable`1<DatabaseType> TargetDatabaseType { get; }
    public AmendExpressionAttribute(string amendmentText);
    public AmendExpressionAttribute(string amendmentText, DatabaseType targetDatabaseType);
    [CompilerGeneratedAttribute]
public string get_AmendmentText();
    [CompilerGeneratedAttribute]
public TargetExpression get_TargetExpression();
    [CompilerGeneratedAttribute]
public void set_TargetExpression(TargetExpression value);
    [CompilerGeneratedAttribute]
public AffixPosition get_AffixPosition();
    [CompilerGeneratedAttribute]
public void set_AffixPosition(AffixPosition value);
    [CompilerGeneratedAttribute]
public StatementTypes get_StatementTypes();
    [CompilerGeneratedAttribute]
public void set_StatementTypes(StatementTypes value);
    [CompilerGeneratedAttribute]
public Nullable`1<DatabaseType> get_TargetDatabaseType();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.ClaimAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Claim <Claim>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verb>k__BackingField;
    public Claim Claim { get; }
    public string Verb { get; }
    public ClaimAttribute(string verb, string type, string value);
    [CompilerGeneratedAttribute]
public Claim get_Claim();
    [CompilerGeneratedAttribute]
public string get_Verb();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.ConfigFileTableNamePrefixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string Prefix { get; }
    public ConfigFileTableNamePrefixAttribute(string setting);
    public ConfigFileTableNamePrefixAttribute(string settingsCategory, string setting);
    [CompilerGeneratedAttribute]
public string get_Prefix();
}
[AttributeUsageAttribute("2432")]
public class GSF.Data.Model.CSVExcludeFieldAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.CustomViewAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CustomView>k__BackingField;
    public string CustomView { get; }
    public CustomViewAttribute(string customView);
    [CompilerGeneratedAttribute]
public string get_CustomView();
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.DefaultSortOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Ascending>k__BackingField;
    public bool Ascending { get; }
    public DefaultSortOrderAttribute(bool ascending);
    [CompilerGeneratedAttribute]
public bool get_Ascending();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.DeleteRolesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Roles>k__BackingField;
    public string Roles { get; }
    public DeleteRolesAttribute(string roles);
    [CompilerGeneratedAttribute]
public string get_Roles();
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.EncryptDataAttribute : Attribute {
    public static string DefaultKeyReference;
    [CompilerGeneratedAttribute]
private string <KeyReference>k__BackingField;
    public string KeyReference { get; }
    public EncryptDataAttribute(string keyReference);
    [CompilerGeneratedAttribute]
public string get_KeyReference();
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.FieldDataTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DbType <FieldDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DatabaseType> <TargetDatabaseType>k__BackingField;
    public DbType FieldDataType { get; }
    public Nullable`1<DatabaseType> TargetDatabaseType { get; }
    public FieldDataTypeAttribute(DbType fieldDataType);
    public FieldDataTypeAttribute(DbType fieldDataType, DatabaseType targetDatabaseType);
    [CompilerGeneratedAttribute]
public DbType get_FieldDataType();
    [CompilerGeneratedAttribute]
public Nullable`1<DatabaseType> get_TargetDatabaseType();
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.FieldNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldName { get; }
    public FieldNameAttribute(string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.GetRolesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Roles>k__BackingField;
    public string Roles { get; }
    public GetRolesAttribute(string roles);
    [CompilerGeneratedAttribute]
public string get_Roles();
}
public interface GSF.Data.Model.ITableOperations {
    public string TableName { get; }
    public string UnescapedTableName { get; }
    public bool HasPrimaryKeyIdentityField { get; }
    public Action`1<Exception> ExceptionHandler { get; public set; }
    public bool UseCaseSensitiveFieldNames { get; public set; }
    public DataTable PrimaryKeyCache { get; public set; }
    public RecordRestriction RootQueryRestriction { get; public set; }
    public bool ApplyRootQueryRestrictionToUpdates { get; public set; }
    public bool ApplyRootQueryRestrictionToDeletes { get; public set; }
    public abstract virtual string get_TableName();
    public abstract virtual string get_UnescapedTableName();
    public abstract virtual bool get_HasPrimaryKeyIdentityField();
    public abstract virtual Action`1<Exception> get_ExceptionHandler();
    public abstract virtual void set_ExceptionHandler(Action`1<Exception> value);
    public abstract virtual bool get_UseCaseSensitiveFieldNames();
    public abstract virtual void set_UseCaseSensitiveFieldNames(bool value);
    public abstract virtual DataTable get_PrimaryKeyCache();
    public abstract virtual void set_PrimaryKeyCache(DataTable value);
    public abstract virtual RecordRestriction get_RootQueryRestriction();
    public abstract virtual void set_RootQueryRestriction(RecordRestriction value);
    public abstract virtual bool get_ApplyRootQueryRestrictionToUpdates();
    public abstract virtual void set_ApplyRootQueryRestrictionToUpdates(bool value);
    public abstract virtual bool get_ApplyRootQueryRestrictionToDeletes();
    public abstract virtual void set_ApplyRootQueryRestrictionToDeletes(bool value);
    public abstract virtual object NewRecord();
    public abstract virtual void ApplyRecordDefaults(object record);
    public abstract virtual void ApplyRecordUpdates(object record);
    public abstract virtual object QueryRecord(RecordRestriction restriction);
    public abstract virtual object QueryRecord(string orderByExpression, RecordRestriction restriction);
    public abstract virtual object QueryRecordWhere(string filterExpression, Object[] parameters);
    public abstract virtual IEnumerable QueryRecords(string orderByExpression, RecordRestriction restriction, int limit);
    public abstract virtual IEnumerable QueryRecords(RecordRestriction restriction);
    public abstract virtual IEnumerable QueryRecordsWhere(string filterExpression, Object[] parameters);
    public abstract virtual IEnumerable QueryRecords(string sortField, bool ascending, int page, int pageSize, string searchText);
    public abstract virtual IEnumerable QueryRecords(string sortField, bool ascending, int page, int pageSize, RecordRestriction restriction);
    public abstract virtual int QueryRecordCount(string searchText);
    public abstract virtual int QueryRecordCount(RecordRestriction restriction);
    public abstract virtual int QueryRecordCountWhere(string filterExpression, Object[] parameters);
    public abstract virtual Object[] SearchRecords(string sortField, bool ascending, string searchText, StringComparison comparison);
    public abstract virtual bool IsSearchMatch(object record, String[] searchValues);
    public abstract virtual bool IsSearchMatch(object record, StringComparison comparison, String[] searchValues);
    public abstract virtual IEnumerable GetPageOfRecords(Object[] records, int page, int pageSize);
    public abstract virtual object LoadRecord(Object[] primaryKeys);
    public abstract virtual object LoadRecord(DataRow row);
    public abstract virtual DataTable ToDataTable(IEnumerable records);
    public abstract virtual int DeleteRecord(Object[] primaryKeys);
    public abstract virtual int DeleteRecord(object record);
    public abstract virtual int DeleteRecord(DataRow row);
    public abstract virtual int DeleteRecord(RecordRestriction restriction, Nullable`1<bool> applyRootQueryRestriction);
    public abstract virtual int DeleteRecordWhere(string filterExpression, Object[] parameters);
    public abstract virtual int UpdateRecord(object record, RecordRestriction restriction, Nullable`1<bool> applyRootQueryRestriction);
    public abstract virtual int UpdateRecordWhere(object record, string filterExpression, Object[] parameters);
    public abstract virtual int UpdateRecord(DataRow row, RecordRestriction restriction);
    public abstract virtual int UpdateRecordWhere(DataRow row, string filterExpression, Object[] parameters);
    public abstract virtual int AddNewRecord(object record);
    public abstract virtual int AddNewRecord(DataRow row);
    public abstract virtual int AddNewOrUpdateRecord(object record);
    public abstract virtual Object[] GetPrimaryKeys(object record);
    public abstract virtual Object[] GetPrimaryKeys(DataRow row);
    public abstract virtual String[] GetFieldNames(bool escaped);
    public abstract virtual String[] GetPrimaryKeyFieldNames(bool escaped);
    public abstract virtual bool TryGetFieldAttribute(string fieldName, TAttribute& attribute);
    public abstract virtual bool TryGetFieldAttribute(string fieldName, Type attributeType, Attribute& attribute);
    public abstract virtual bool FieldHasAttribute(string fieldName);
    public abstract virtual bool FieldHasAttribute(string fieldName, Type attributeType);
    public abstract virtual object GetFieldValue(object record, string fieldName);
    public abstract virtual object GetInterpretedFieldValue(string fieldName, object value);
    public abstract virtual Type GetFieldType(string fieldName);
    public abstract virtual RecordRestriction GetSearchRestriction(string searchText);
    public abstract virtual int GetPrimaryKeyCacheSize();
    public abstract virtual void ClearPrimaryKeyCache();
}
[CompilerGeneratedAttribute]
internal class GSF.Data.Model.NamespaceDoc : object {
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.NonRecordFieldAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.ParentKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Model>k__BackingField;
    public Type Model { get; }
    public ParentKeyAttribute(Type model);
    [CompilerGeneratedAttribute]
public Type get_Model();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.PatchRolesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Roles>k__BackingField;
    public string Roles { get; }
    public PatchRolesAttribute(string roles);
    [CompilerGeneratedAttribute]
public string get_Roles();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.PostRolesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Roles>k__BackingField;
    public string Roles { get; }
    public PostRolesAttribute(string roles);
    [CompilerGeneratedAttribute]
public string get_Roles();
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.PrimaryKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsIdentity>k__BackingField;
    public bool IsIdentity { get; }
    public PrimaryKeyAttribute(bool isIdentity);
    [CompilerGeneratedAttribute]
public bool get_IsIdentity();
}
public enum GSF.Data.Model.RecordOperation : Enum {
    public int value__;
    public static RecordOperation QueryRecordCount;
    public static RecordOperation QueryRecords;
    public static RecordOperation DeleteRecord;
    public static RecordOperation CreateNewRecord;
    public static RecordOperation AddNewRecord;
    public static RecordOperation UpdateRecord;
}
[AttributeUsageAttribute("64")]
public class GSF.Data.Model.RecordOperationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ModelType>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordOperation <Operation>k__BackingField;
    public Type ModelType { get; }
    public RecordOperation Operation { get; }
    public RecordOperationAttribute(Type modelType, RecordOperation operation);
    [CompilerGeneratedAttribute]
public Type get_ModelType();
    [CompilerGeneratedAttribute]
public RecordOperation get_Operation();
}
[DefaultMemberAttribute("Item")]
public class GSF.Data.Model.RecordRestriction : object {
    public string FilterExpression;
    public Object[] Parameters;
    public object Item { get; public set; }
    public RecordRestriction(string filterExpression, Object[] parameters);
    public object get_Item(int index);
    public void set_Item(int index, object value);
    public RecordRestriction Clone();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RecordRestriction other);
    public virtual int GetHashCode();
    public static RecordRestriction op_Implicit(string value);
    public static bool op_Equality(RecordRestriction left, RecordRestriction right);
    public static bool op_Inequality(RecordRestriction left, RecordRestriction right);
    public static RecordRestriction op_Addition(RecordRestriction left, RecordRestriction right);
    public static RecordRestriction op_BitwiseAnd(RecordRestriction left, RecordRestriction right);
    public static RecordRestriction op_BitwiseOr(RecordRestriction left, RecordRestriction right);
    public static RecordRestriction Clone(RecordRestriction source);
    public static RecordRestriction CombineAnd(RecordRestriction left, RecordRestriction right);
    public static RecordRestriction CombineOr(RecordRestriction left, RecordRestriction right);
    private static RecordRestriction Combine(RecordRestriction left, RecordRestriction right, string operation);
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.ReturnLimitAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    public int Limit { get; }
    public ReturnLimitAttribute(int limit);
    [CompilerGeneratedAttribute]
public int get_Limit();
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.RootQueryRestrictionAttribute : Attribute {
    public string FilterExpression;
    public Object[] Parameters;
    public bool ApplyToUpdates;
    public bool ApplyToDeletes;
    public RootQueryRestrictionAttribute(string filterExpression, Object[] parameters);
}
[AttributeUsageAttribute("128")]
public class GSF.Data.Model.SearchableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SearchType <SearchType>k__BackingField;
    public SearchType SearchType { get; }
    public SearchableAttribute(SearchType searchType);
    [CompilerGeneratedAttribute]
public SearchType get_SearchType();
}
public enum GSF.Data.Model.SearchType : Enum {
    public int value__;
    public static SearchType Default;
    public static SearchType LikeExpression;
    public static SearchType FullValueMatch;
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.SettingsCategoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SettingsCategory>k__BackingField;
    public string SettingsCategory { get; }
    public SettingsCategoryAttribute(string settingsCategory);
    [CompilerGeneratedAttribute]
public string get_SettingsCategory();
}
public class GSF.Data.Model.SQLSearchFilter : object {
    private string m_operator;
    private string m_type;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SearchText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPivotColumn>k__BackingField;
    private static String[] s_validOperators;
    private static String[] s_validTypes;
    public string FieldName { get; public set; }
    public string SearchText { get; public set; }
    public string Operator { get; public set; }
    public string Type { get; public set; }
    public bool IsPivotColumn { get; public set; }
    private static SQLSearchFilter();
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_SearchText();
    [CompilerGeneratedAttribute]
public void set_SearchText(string value);
    public string get_Operator();
    public void set_Operator(string value);
    public string get_Type();
    public void set_Type(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPivotColumn();
    [CompilerGeneratedAttribute]
public void set_IsPivotColumn(bool value);
    public string GenerateConditional(List`1<object> parameters);
}
[AttributeUsageAttribute("64")]
public class GSF.Data.Model.SQLSearchModifierAttribute : Attribute {
}
[FlagsAttribute]
public enum GSF.Data.Model.StatementTypes : Enum {
    public int value__;
    public static StatementTypes Select;
    public static StatementTypes SelectCount;
    public static StatementTypes SelectSet;
    public static StatementTypes SelectRow;
    public static StatementTypes Insert;
    public static StatementTypes Update;
    public static StatementTypes Delete;
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.TableNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    public string TableName { get; }
    public TableNameAttribute(string tableName);
    [CompilerGeneratedAttribute]
public string get_TableName();
}
public class GSF.Data.Model.TableOperations`1 : object {
    private static string SelectCountSqlFormat;
    private static string SelectSetSqlFormat;
    private static string SelectSetWhereSqlFormat;
    private static string SelectRowSqlFormat;
    private static string AddNewSqlFormat;
    private static string UpdateSqlFormat;
    private static string DeleteSqlFormat;
    private static string TableNamePrefixToken;
    private static string TableNameSuffixToken;
    private static string FieldListPrefixToken;
    private static string FieldListSuffixToken;
    private string m_selectCountSql;
    private string m_selectSetSql;
    private string m_selectSetWhereSql;
    private string m_selectKeysSql;
    private string m_selectKeysWhereSql;
    private string m_selectRowSql;
    private string m_addNewSql;
    private string m_updateSql;
    private string m_updateWhereSql;
    private string m_deleteSql;
    private string m_deleteWhereSql;
    private string m_searchFilterSql;
    private string m_lastSortField;
    private RecordRestriction m_lastRestriction;
    [CompilerGeneratedAttribute]
private AdoDataConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <ExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCaseSensitiveFieldNames>k__BackingField;
    [CompilerGeneratedAttribute]
private DataTable <PrimaryKeyCache>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordRestriction <RootQueryRestriction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyRootQueryRestrictionToUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyRootQueryRestrictionToDeletes>k__BackingField;
    private static string s_tableName;
    private static Dictionary`2<string, PropertyInfo> s_properties;
    private static Dictionary`2<string, string> s_fieldNames;
    private static Dictionary`2<string, string> s_propertyNames;
    private static Dictionary`2<PropertyInfo, HashSet`1<Type>> s_attributes;
    private static PropertyInfo[] s_addNewProperties;
    private static PropertyInfo[] s_updateProperties;
    private static PropertyInfo[] s_primaryKeyProperties;
    private static Dictionary`2<PropertyInfo, Dictionary`2<DatabaseType, DbType>> s_fieldDataTypeTargets;
    private static Dictionary`2<PropertyInfo, string> s_encryptDataTargets;
    private static Dictionary`2<PropertyInfo, SearchType> s_searchTargets;
    private static List`1<PropertyInfo> s_encryptedSearchTargets;
    private static Dictionary`2<DatabaseType, bool> s_escapedTableNameTargets;
    private static Dictionary`2<string, Dictionary`2<DatabaseType, bool>> s_escapedFieldNameTargets;
    private static List`1<Tuple`5<DatabaseType, TargetExpression, StatementTypes, AffixPosition, string>> s_expressionAmendments;
    private static RootQueryRestrictionAttribute s_rootQueryRestrictionAttribute;
    private static string s_selectCountSql;
    private static string s_selectSetSql;
    private static string s_selectSetWhereSql;
    private static string s_selectKeysSql;
    private static string s_selectKeysWhereSql;
    private static string s_selectRowSql;
    private static string s_addNewSql;
    private static string s_updateSql;
    private static string s_updateWhereSql;
    private static string s_deleteSql;
    private static string s_deleteWhereSql;
    private static string s_primaryKeyFields;
    private static string s_searchFilterSql;
    private static bool s_hasPrimaryKeyIdentityField;
    private static Func`2<CurrentScope<T>, T> s_createRecordInstance;
    private static Action`1<CurrentScope<T>> s_updateRecordInstance;
    private static Action`1<CurrentScope<T>> s_applyRecordDefaults;
    private static TypeRegistry s_typeRegistry;
    public AdoDataConnection Connection { get; }
    public string TableName { get; }
    public string UnescapedTableName { get; }
    public bool HasPrimaryKeyIdentityField { get; }
    public Action`1<Exception> ExceptionHandler { get; public set; }
    public bool UseCaseSensitiveFieldNames { get; public set; }
    public DataTable PrimaryKeyCache { get; public set; }
    public RecordRestriction RootQueryRestriction { get; public set; }
    public bool ApplyRootQueryRestrictionToUpdates { get; public set; }
    public bool ApplyRootQueryRestrictionToDeletes { get; public set; }
    public static TypeRegistry TypeRegistry { get; public set; }
    public TableOperations`1(AdoDataConnection connection, IEnumerable`1<KeyValuePair`2<string, string>> customTokens);
    public TableOperations`1(AdoDataConnection connection, Action`1<Exception> exceptionHandler, IEnumerable`1<KeyValuePair`2<string, string>> customTokens);
    private static TableOperations`1();
    [CompilerGeneratedAttribute]
public AdoDataConnection get_Connection();
    public sealed virtual string get_TableName();
    public sealed virtual string get_UnescapedTableName();
    public sealed virtual bool get_HasPrimaryKeyIdentityField();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<Exception> get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseCaseSensitiveFieldNames();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseCaseSensitiveFieldNames(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual DataTable get_PrimaryKeyCache();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrimaryKeyCache(DataTable value);
    [CompilerGeneratedAttribute]
public sealed virtual RecordRestriction get_RootQueryRestriction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RootQueryRestriction(RecordRestriction value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ApplyRootQueryRestrictionToUpdates();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplyRootQueryRestrictionToUpdates(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ApplyRootQueryRestrictionToDeletes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplyRootQueryRestrictionToDeletes(bool value);
    public T NewRecord();
    private sealed virtual override object GSF.Data.Model.ITableOperations.NewRecord();
    public void ApplyRecordDefaults(T record);
    private sealed virtual override void GSF.Data.Model.ITableOperations.ApplyRecordDefaults(object value);
    public void ApplyRecordUpdates(T record);
    private sealed virtual override void GSF.Data.Model.ITableOperations.ApplyRecordUpdates(object value);
    public T QueryRecord(RecordRestriction restriction);
    private sealed virtual override object GSF.Data.Model.ITableOperations.QueryRecord(RecordRestriction restriction);
    public T QueryRecord(string orderByExpression, RecordRestriction restriction);
    private sealed virtual override object GSF.Data.Model.ITableOperations.QueryRecord(string orderByExpression, RecordRestriction restriction);
    public T QueryRecordWhere(string filterExpression, Object[] parameters);
    private sealed virtual override object GSF.Data.Model.ITableOperations.QueryRecordWhere(string filterExpression, Object[] parameters);
    public IEnumerable`1<T> QueryRecords(string orderByExpression, RecordRestriction restriction, int limit);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.QueryRecords(string orderByExpression, RecordRestriction restriction, int limit);
    public IEnumerable`1<T> QueryRecords(RecordRestriction restriction);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.QueryRecords(RecordRestriction restriction);
    public IEnumerable`1<T> QueryRecordsWhere(string filterExpression, Object[] parameters);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.QueryRecordsWhere(string filterExpression, Object[] parameters);
    public IEnumerable`1<T> QueryRecords(string sortField, bool ascending, int page, int pageSize, string searchText);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.QueryRecords(string sortField, bool ascending, int page, int pageSize, string searchText);
    public IEnumerable`1<T> QueryRecords(string sortField, bool ascending, int page, int pageSize, RecordRestriction restriction);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.QueryRecords(string sortField, bool ascending, int page, int pageSize, RecordRestriction restriction);
    public sealed virtual int QueryRecordCount(string searchText);
    public sealed virtual int QueryRecordCount(RecordRestriction restriction);
    public sealed virtual int QueryRecordCountWhere(string filterExpression, Object[] parameters);
    public T[] SearchRecords(string sortField, bool ascending, string searchText, StringComparison comparison);
    private sealed virtual override Object[] GSF.Data.Model.ITableOperations.SearchRecords(string sortField, bool ascending, string searchText, StringComparison comparison);
    public bool IsSearchMatch(T record, String[] searchValues);
    private sealed virtual override bool GSF.Data.Model.ITableOperations.IsSearchMatch(object record, String[] searchValues);
    public bool IsSearchMatch(T record, StringComparison comparison, String[] searchValues);
    private sealed virtual override bool GSF.Data.Model.ITableOperations.IsSearchMatch(object value, StringComparison comparison, String[] searchValues);
    public IEnumerable`1<T> GetPageOfRecords(T[] records, int page, int pageSize);
    private sealed virtual override IEnumerable GSF.Data.Model.ITableOperations.GetPageOfRecords(Object[] records, int page, int pageSize);
    public T LoadRecord(Object[] primaryKeys);
    private sealed virtual override object GSF.Data.Model.ITableOperations.LoadRecord(Object[] primaryKeys);
    private T LoadRecordFromCachedKeys(Object[] primaryKeys, IEnumerable`1<PropertyInfo> properties);
    public T LoadRecord(DataRow row);
    private T LoadRecord(DataRow row, IEnumerable`1<PropertyInfo> properties);
    private sealed virtual override object GSF.Data.Model.ITableOperations.LoadRecord(DataRow row);
    public DataTable ToDataTable(IEnumerable`1<T> records);
    private sealed virtual override DataTable GSF.Data.Model.ITableOperations.ToDataTable(IEnumerable records);
    public sealed virtual int DeleteRecord(Object[] primaryKeys);
    public int DeleteRecord(T record);
    private sealed virtual override int GSF.Data.Model.ITableOperations.DeleteRecord(object value);
    public sealed virtual int DeleteRecord(DataRow row);
    public sealed virtual int DeleteRecord(RecordRestriction restriction, Nullable`1<bool> applyRootQueryRestriction);
    public sealed virtual int DeleteRecordWhere(string filterExpression, Object[] parameters);
    public int UpdateRecord(T record, RecordRestriction restriction, Nullable`1<bool> applyRootQueryRestriction);
    private sealed virtual override int GSF.Data.Model.ITableOperations.UpdateRecord(object value, RecordRestriction restriction, Nullable`1<bool> applyRootQueryRestriction);
    public int UpdateRecordWhere(T record, string filterExpression, Object[] parameters);
    private sealed virtual override int GSF.Data.Model.ITableOperations.UpdateRecordWhere(object value, string filterExpression, Object[] parameters);
    public sealed virtual int UpdateRecord(DataRow row, RecordRestriction restriction);
    public sealed virtual int UpdateRecordWhere(DataRow row, string filterExpression, Object[] parameters);
    public int AddNewRecord(T record);
    private sealed virtual override int GSF.Data.Model.ITableOperations.AddNewRecord(object value);
    public sealed virtual int AddNewRecord(DataRow row);
    public int AddNewOrUpdateRecord(T record);
    private sealed virtual override int GSF.Data.Model.ITableOperations.AddNewOrUpdateRecord(object value);
    public Object[] GetPrimaryKeys(T record);
    private sealed virtual override Object[] GSF.Data.Model.ITableOperations.GetPrimaryKeys(object value);
    public sealed virtual Object[] GetPrimaryKeys(DataRow row);
    public sealed virtual String[] GetFieldNames(bool escaped);
    public sealed virtual String[] GetPrimaryKeyFieldNames(bool escaped);
    public sealed virtual bool TryGetFieldAttribute(string fieldName, TAttribute& attribute);
    public sealed virtual bool TryGetFieldAttribute(string fieldName, Type attributeType, Attribute& attribute);
    public sealed virtual bool FieldHasAttribute(string fieldName);
    public sealed virtual bool FieldHasAttribute(string fieldName, Type attributeType);
    public object GetFieldValue(T record, string fieldName);
    private sealed virtual override object GSF.Data.Model.ITableOperations.GetFieldValue(object value, string fieldName);
    public sealed virtual object GetInterpretedFieldValue(string fieldName, object value);
    public sealed virtual Type GetFieldType(string fieldName);
    public sealed virtual RecordRestriction GetSearchRestriction(string searchText);
    public sealed virtual int GetPrimaryKeyCacheSize();
    public sealed virtual void ClearPrimaryKeyCache();
    private Object[] GetInterpretedPrimaryKeys(Object[] primaryKeys, bool skipEncryption);
    private object GetInterpretedPropertyValue(PropertyInfo property, T record);
    private object GetInterpretedValue(PropertyInfo property, object value, bool skipEncryption);
    private string GetEscapedTableName();
    private string GetEscapedFieldName(string fieldName, Dictionary`2<DatabaseType, bool> escapedFieldNameTargets);
    private string GetUnescapedFieldName(string fieldName);
    private string UpdateFieldNames(string filterExpression);
    private bool FieldIsEncrypted(string fieldName);
    private IEnumerable`1<T> LocalOrderBy(IEnumerable`1<T> queryResults, string sortField, bool ascending, StringComparer comparer);
    public static TypeRegistry get_TypeRegistry();
    public static void set_TypeRegistry(TypeRegistry value);
    public static Func`2<DataRow, T> LoadRecordFunction();
    public static Func`1<T> NewRecordFunction();
    public static Action`1<T> ApplyRecordDefaultsFunction();
    public static Action`1<T> ApplyRecordUpdatesFunction();
    public static string GetTableName();
    private static string GetFieldName(PropertyInfo property);
    private static Dictionary`2<DatabaseType, DbType> DeriveFieldDataTypeTargets(FieldDataTypeAttribute[] fieldDataTypeAttributes);
    private static Dictionary`2<DatabaseType, bool> DeriveEscapedNameTargets(UseEscapedNameAttribute[] useEscapedNameAttributes);
    private static List`1<Tuple`5<DatabaseType, TargetExpression, StatementTypes, AffixPosition, string>> DeriveExpressionAmendments(AmendExpressionAttribute[] amendExpressionAttributes);
    private static string ValueList(IReadOnlyList`1<object> values);
    [CompilerGeneratedAttribute]
internal static string <.ctor>g__RemoveRemainingTokens|28_0(string sql);
    [CompilerGeneratedAttribute]
private T <QueryRecords>b__83_0(DataRow row);
    [CompilerGeneratedAttribute]
private string <GetFieldNames>b__124_0(string fieldName);
    [CompilerGeneratedAttribute]
private string <GetPrimaryKeyFieldNames>b__125_0(string fieldName);
    [CompilerGeneratedAttribute]
private string <GetPrimaryKeyFieldNames>b__125_1(string fieldName);
}
public enum GSF.Data.Model.TargetExpression : Enum {
    public int value__;
    public static TargetExpression TableName;
    public static TargetExpression FieldList;
}
[AttributeUsageAttribute("132")]
public class GSF.Data.Model.UseEscapedNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Nullable`1<DatabaseType> <TargetDatabaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAnsiQuotes>k__BackingField;
    public Nullable`1<DatabaseType> TargetDatabaseType { get; }
    public bool UseAnsiQuotes { get; public set; }
    public UseEscapedNameAttribute(DatabaseType targetDatabaseType);
    [CompilerGeneratedAttribute]
public Nullable`1<DatabaseType> get_TargetDatabaseType();
    [CompilerGeneratedAttribute]
public bool get_UseAnsiQuotes();
    [CompilerGeneratedAttribute]
public void set_UseAnsiQuotes(bool value);
}
[AttributeUsageAttribute("4")]
public class GSF.Data.Model.ViewOnlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ViewOnly>k__BackingField;
    public bool ViewOnly { get; }
    [CompilerGeneratedAttribute]
public bool get_ViewOnly();
}
[CompilerGeneratedAttribute]
internal class GSF.Data.NamespaceDoc : object {
}
public enum GSF.Data.ReferentialAction : Enum {
    public int value__;
    public static ReferentialAction Cascade;
    public static ReferentialAction SetNull;
    public static ReferentialAction SetDefault;
    public static ReferentialAction NoAction;
}
public class GSF.Data.Schema : object {
    private Tables m_tables;
    public static TableType NoRestriction;
    private IDbConnection m_schemaConnection;
    private string m_connectionString;
    private DatabaseType m_databaseType;
    private TableType m_restriction;
    private bool m_immediateClose;
    private bool m_allowTextNulls;
    private bool m_allowNumericNulls;
    public Tables Tables { get; public set; }
    public string ConnectionString { get; public set; }
    public TableType TableTypeRestriction { get; public set; }
    public bool ImmediateClose { get; public set; }
    public DatabaseType DataSourceType { get; public set; }
    public bool AllowTextNulls { get; public set; }
    public bool AllowNumericNulls { get; public set; }
    public IDbConnection Connection { get; public set; }
    public Schema(string connectionString, TableType tableTypeRestriction, bool immediateClose, bool analyzeNow);
    public Tables get_Tables();
    public void set_Tables(Tables value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public TableType get_TableTypeRestriction();
    public void set_TableTypeRestriction(TableType value);
    public bool get_ImmediateClose();
    public void set_ImmediateClose(bool value);
    public DatabaseType get_DataSourceType();
    public void set_DataSourceType(DatabaseType value);
    public bool get_AllowTextNulls();
    public void set_AllowTextNulls(bool value);
    public bool get_AllowNumericNulls();
    public void set_AllowNumericNulls(bool value);
    public IDbConnection get_Connection();
    public void set_Connection(IDbConnection value);
    public string SQLEscapeName(string name);
    public void Analyze();
    private void AnalyzeOleDbSchema();
    private void SchemaConnection_StateChange(object sender, StateChangeEventArgs e);
    public void Close();
    public static IDbConnection OpenConnection(string connectionString);
    public static IDbConnection OpenConnection(string connectionString, DatabaseType& databaseType, Schema& deserializedSchema, Boolean& isAdoConnection);
}
public class GSF.Data.Table : object {
    private Tables m_parent;
    private string m_catalog;
    private string m_schema;
    private string m_name;
    private TableType m_tableType;
    private string m_description;
    private int m_rows;
    private Fields m_fields;
    private string m_mapName;
    private bool m_process;
    private int m_priority;
    private string m_identitySQL;
    public Fields Fields { get; public set; }
    public string MapName { get; public set; }
    public bool Process { get; public set; }
    public int Priority { get; public set; }
    public string IdentitySQL { get; public set; }
    public string Name { get; public set; }
    public string SQLEscapedName { get; }
    public string FullName { get; }
    public string Catalog { get; public set; }
    public string Schema { get; public set; }
    public TableType Type { get; public set; }
    public string Description { get; public set; }
    public int RowCount { get; }
    public Tables Parent { get; internal set; }
    public IDbConnection Connection { get; }
    public bool IsView { get; }
    public bool IsSystem { get; }
    public bool IsTemporary { get; }
    public bool IsLinked { get; }
    public int PrimaryKeyFieldCount { get; }
    public bool ReferencedByForeignKeys { get; }
    public bool IsForeignKeyTable { get; }
    public bool HasAutoIncField { get; }
    public Field AutoIncField { get; }
    public Table(string name);
    public Table(string catalog, string schema, string name, string type, string description, int rows);
    public Fields get_Fields();
    public void set_Fields(Fields value);
    public string get_MapName();
    public void set_MapName(string value);
    public bool get_Process();
    public void set_Process(bool value);
    public int get_Priority();
    public void set_Priority(int value);
    public string get_IdentitySQL();
    public void set_IdentitySQL(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_SQLEscapedName();
    public string get_FullName();
    public string get_Catalog();
    public void set_Catalog(string value);
    public string get_Schema();
    public void set_Schema(string value);
    public TableType get_Type();
    public void set_Type(TableType value);
    public string get_Description();
    public void set_Description(string value);
    public int get_RowCount();
    public Tables get_Parent();
    internal void set_Parent(Tables value);
    public IDbConnection get_Connection();
    public bool get_IsView();
    public bool get_IsSystem();
    public bool get_IsTemporary();
    public bool get_IsLinked();
    public int get_PrimaryKeyFieldCount();
    public bool get_ReferencedByForeignKeys();
    public bool get_IsForeignKeyTable();
    public bool get_HasAutoIncField();
    public Field get_AutoIncField();
    public bool UsesDefaultSchema();
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Table other);
    internal bool IsReferencedBy(Table otherTable, List`1<Table> tableStack);
    public bool IsReferencedBy(Table otherTable);
    public bool IsReferencedVia(Table otherTable);
    public bool DefinePrimaryKey(string fieldName, int primaryKeyOrdinal, string primaryKeyName);
    public bool DefineForeignKey(string primaryKeyFieldName, string foreignKeyTableName, string foreignKeyFieldName, int foreignKeyOrdinal, string foreignKeyName, ReferentialAction foreignKeyUpdateRule, ReferentialAction foreignKeyDeleteRule);
    public void ReevalulateIdentitySQL();
    public void CalculateRowCount();
}
[DefaultMemberAttribute("Item")]
public class GSF.Data.Tables : object {
    private Schema m_parent;
    private Dictionary`2<string, Table> m_tables;
    private List`1<Table> m_tableList;
    internal Dictionary`2<string, Table> TableDictionary { get; }
    internal List`1<Table> TableList { get; }
    public int Count { get; }
    public Schema Parent { get; internal set; }
    public Table Item { get; }
    public Table Item { get; }
    internal Tables(Schema Parent);
    internal Dictionary`2<string, Table> get_TableDictionary();
    internal List`1<Table> get_TableList();
    public int get_Count();
    public Schema get_Parent();
    internal void set_Parent(Schema value);
    public void Add(Table table);
    public void Remove(Table table);
    public void Clear();
    public Table get_Item(int index);
    public Table get_Item(string name);
    public Table FindByMapName(string mapName);
    public sealed virtual IEnumerator`1<Table> GetEnumerator();
    public string GetList();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FlagsAttribute]
public enum GSF.Data.TableType : Enum {
    public int value__;
    public static TableType Table;
    public static TableType View;
    public static TableType SystemTable;
    public static TableType SystemView;
    public static TableType Alias;
    public static TableType Synonym;
    public static TableType GlobalTemp;
    public static TableType LocalTemp;
    public static TableType Link;
    public static TableType Undetermined;
}
[ExtensionAttribute]
public static class GSF.DateTimeExtensions : object {
    [ExtensionAttribute]
public static bool UtcTimeIsValid(DateTime utcTime, double lagTime, double leadTime);
    [ExtensionAttribute]
public static bool LocalTimeIsValid(DateTime localTime, double lagTime, double leadTime);
    [ExtensionAttribute]
public static bool TimeIsValid(DateTime testTime, DateTime currentTime, double lagTime, double leadTime);
    [ExtensionAttribute]
public static Ticks DistanceBeyondSecond(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime BaselinedTimestamp(DateTime timestamp, BaselineTimeInterval interval);
    [ExtensionAttribute]
public static DateTime LocalTimeToEasternTime(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime LocalTimeToCentralTime(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime LocalTimeToMountainTime(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime LocalTimeToPacificTime(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime LocalTimeToUniversalTime(DateTime timestamp);
    [ExtensionAttribute]
public static DateTime LocalTimeTo(DateTime timestamp, string destinationTimeZoneStandardName);
    [ExtensionAttribute]
public static DateTime LocalTimeTo(DateTime timestamp, TimeZoneInfo destinationTimeZone);
    [ExtensionAttribute]
public static DateTime UniversalTimeToEasternTime(DateTime universalTimestamp);
    [ExtensionAttribute]
public static DateTime UniversalTimeToCentralTime(DateTime universalTimestamp);
    [ExtensionAttribute]
public static DateTime UniversalTimeToMountainTime(DateTime universalTimestamp);
    [ExtensionAttribute]
public static DateTime UniversalTimeToPacificTime(DateTime universalTimestamp);
    [ExtensionAttribute]
public static DateTime UniversalTimeTo(DateTime universalTimestamp, string destinationTimeZoneStandardName);
    [ExtensionAttribute]
public static DateTime UniversalTimeTo(DateTime universalTimestamp, TimeZoneInfo destinationTimeZone);
    [ExtensionAttribute]
public static DateTime TimeZoneToTimeZone(DateTime timestamp, string sourceTimeZoneStandardName, string destinationTimeZoneStandardName);
    [ExtensionAttribute]
public static DateTime TimeZoneToTimeZone(DateTime timestamp, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    [ExtensionAttribute]
public static string AbbreviatedMonthName(DateTime timestamp);
    [ExtensionAttribute]
public static string MonthName(DateTime timestamp);
    [ExtensionAttribute]
public static string AbbreviatedWeekdayName(DateTime timestamp);
    [ExtensionAttribute]
public static string ShortWeekdayName(DateTime timestamp);
    [ExtensionAttribute]
public static string WeekdayName(DateTime timestamp);
}
public class GSF.DateTimeRounding : object {
    private int m_ticksPerInterval;
    private int m_ticksPerHalfInterval;
    private Int32[] m_distribution;
    private static Dictionary`2<int, DateTimeRounding> s_cache;
    private DateTimeRounding(int samplesPerSecond);
    private static DateTimeRounding();
    public DateTime Round(DateTime time);
    public long Round(long time);
    public static DateTimeRounding Create(int samplesPerSecond);
}
public class GSF.Diagnostics.ChildProcessManager : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> TerminationException;
    private List`1<WeakReference`1<Process>> m_childProcesses;
    private SafeJobHandle m_jobHandle;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
public void add_TerminationException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_TerminationException(EventHandler`1<EventArgs`1<Exception>> value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void AddProcess(Process process);
    private static IntPtr CreateJobObject(IntPtr hObject, string lpName);
    private static bool SetInformationJobObject(SafeJobHandle jobHandle, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);
    private static bool AssignProcessToJobObject(SafeJobHandle jobHandle, SafeProcessHandle process);
    [ReliabilityContractAttribute("3", "2")]
private static bool CloseHandle(IntPtr hObject);
}
public abstract class GSF.Diagnostics.DisposableLoggingClassBase : object {
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private LogPublisher <Log>k__BackingField;
    protected LogPublisher Log { get; private set; }
    protected DisposableLoggingClassBase(MessageClass messageClassification);
    [CompilerGeneratedAttribute]
protected LogPublisher get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(LogPublisher value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void CheckDisposed();
    private void ThrowDisposed();
}
public class GSF.Diagnostics.LogEventPublisher : object {
    private LogPublisher m_publisher;
    private LogEventPublisherInternal m_internalPublisher;
    public bool HasSubscribers { get; }
    public bool ShouldRaiseMessageSupressionNotifications { get; public set; }
    internal LogEventPublisher(LogPublisher publisher, LogEventPublisherInternal internalPublisher);
    public bool get_HasSubscribers();
    public bool get_ShouldRaiseMessageSupressionNotifications();
    public void set_ShouldRaiseMessageSupressionNotifications(bool value);
    public void Publish(string message, string details, Exception exception);
    public void Publish(MessageFlags flags, string message, string details, Exception exception);
}
public class GSF.Diagnostics.LogEventPublisherDetails : object {
    public PublisherTypeDefinition TypeData;
    public string EventName;
    private int m_hashCode;
    internal LogEventPublisherDetails(Stream stream, LogMessageSaveHelper helper);
    public LogEventPublisherDetails(PublisherTypeDefinition typeData, string eventName);
    private int ComputeHashCode();
    internal void Save(Stream stream, LogMessageSaveHelper helper);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LogEventPublisherDetails obj);
}
internal class GSF.Diagnostics.LogEventPublisherInternal : object {
    private static LogPublisher Log;
    private static LogEventPublisher MessageSuppressionIndication;
    private LogEventPublisherDetails m_owner;
    private LogSuppressionEngine m_supressionEngine;
    private LogPublisherInternal m_publisher;
    private LoggerInternal m_logger;
    private int m_stackTraceDepth;
    private LogMessageAttributes m_attributes;
    private ShortTime m_suppressionMessageNextPublishTime;
    private long m_messagesSuppressed;
    public bool ShouldRaiseMessageSupressionNotifications;
    public bool HasSubscribers { get; }
    public LogMessageAttributes DefaultAttributes { get; }
    internal LogEventPublisherInternal(LogMessageAttributes attributes, LogEventPublisherDetails owner, LogPublisherInternal publisher, LoggerInternal logger, int stackTraceDepth, double messagesPerSecond, int burstLimit);
    private static LogEventPublisherInternal();
    public bool get_HasSubscribers();
    public LogMessageAttributes get_DefaultAttributes();
    public void Publish(Nullable`1<LogMessageAttributes> overriddenAttributes, string message, string details, Exception exception, LogStackMessages initialStackMessage, LogStackTrace initialStackTrace);
}
public static class GSF.Diagnostics.LogFileCompactor : object {
    public static void Compact(ICollection`1<string> inputFileNames, string outputFileName);
}
public static class GSF.Diagnostics.LogFileReader : object {
    public static List`1<LogMessage> Read(string logFileName);
}
public class GSF.Diagnostics.LogFileWriter : object {
    private MemoryStream m_tmpStream;
    private object m_syncRoot;
    public string FileName;
    private FileStream m_stream;
    private DeflateStream m_zipStream;
    private LogMessageSaveHelper m_saveHelper;
    private int m_logCount;
    private Byte[] m_tmpBuffer;
    public int LogCount { get; }
    public long LogSize { get; }
    public LogFileWriter(string logFileName);
    public int get_LogCount();
    public long get_LogSize();
    public void Write(LogMessage log, bool autoFlush);
    public void Flush();
    public sealed virtual void Dispose();
}
public class GSF.Diagnostics.LogFileWriterInMemory : object {
    private MemoryStream m_tmpStream;
    private MemoryStream m_stream;
    private DeflateStream m_zipStream;
    private LogMessageSaveHelper m_saveHelper;
    private int m_logCount;
    private Byte[] m_tmpBuffer;
    public int LogCount { get; }
    public int get_LogCount();
    public void Write(LogMessage log);
    public Byte[] ToByteArray();
}
public static class GSF.Diagnostics.Logger : object {
    private static LoggerInternal s_logger;
    public static LogSubscriptionConsole Console;
    public static LogSubscriptionFileWriter FileWriter;
    private static LogPublisher Log;
    private static LogEventPublisher EventFirstChanceException;
    private static LogEventPublisher EventAppDomainException;
    private static LogEventPublisher EventSwallowedException;
    private static StackDisposal[] s_stackDisposalStackMessages;
    private static StackDisposal[] s_stackDisposalSuppressionFlags;
    private static object SyncRoot;
    internal static int PreviousFirstChanceExceptionSequenceNumber { get; }
    public static bool ShouldSuppressLogMessages { get; }
    public static bool ShouldSuppressFirstChanceLogMessages { get; }
    private static Logger();
    internal static void Initialize();
    internal static void Shutdown();
    internal static int get_PreviousFirstChanceExceptionSequenceNumber();
    public static bool get_ShouldSuppressLogMessages();
    public static bool get_ShouldSuppressFirstChanceLogMessages();
    private static void CurrentDomain_FirstChanceException(object sender, FirstChanceExceptionEventArgs e);
    private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e);
    public static LogPublisher CreatePublisher(Type type, MessageClass classification);
    public static LogSubscriber CreateSubscriber(VerboseLevel level);
    public static void SwallowException(Exception ex, string message, string details, MessageFlags additionalFlags);
    public static LogStackMessages GetStackMessages();
    public static IDisposable AppendStackMessages(LogStackMessages messages);
    public static IDisposable SuppressLogMessages();
    public static IDisposable SuppressFirstChanceExceptionLogMessages();
    public static IDisposable OverrideSuppressLogMessages();
    public static IDisposable AppendStackMessages(string key, string value);
    private static void GrowStackDisposal(int desiredSize);
    private static void DisposeStackMessage(int depth);
    private static void DisposeSuppressionFlags(int depth);
}
internal class GSF.Diagnostics.LoggerInternal : object {
    private bool m_disposing;
    private object m_syncRoot;
    private Dictionary`2<Type, LogPublisherInternal> m_typeIndexCache;
    private List`1<LogPublisherInternal> m_allPublishers;
    private List`1<NullableWeakReference> m_subscribers;
    private ConcurrentQueue`1<Tuple`2<LogMessage, LogPublisherInternal>> m_messages;
    private ScheduledTask m_routingTask;
    private ScheduledTask m_calculateRoutingTable;
    [CompilerGeneratedAttribute]
private bool <RoutingTablesValid>k__BackingField;
    public bool RoutingTablesValid { get; private set; }
    public LoggerInternal(LoggerInternal& loggerClass);
    [CompilerGeneratedAttribute]
public bool get_RoutingTablesValid();
    [CompilerGeneratedAttribute]
private void set_RoutingTablesValid(bool value);
    private void CalculateRoutingTable(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
    private void CalculateRoutingTableForPublisherSync(List`1<LogSubscriberInternal> subscribers, LogPublisherInternal publisher);
    private void RoutingTask(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
    public LogSubscriberInternal CreateSubscriber();
    private void RecalculateRoutingTable();
    public void OnNewMessage(LogMessage message, LogPublisherInternal publisher);
    public LogPublisherInternal CreateType(Type type);
    public sealed virtual void Dispose();
}
public class GSF.Diagnostics.LogMessage : object {
    public LogEventPublisherDetails EventPublisherDetails;
    public LogStackMessages InitialStackMessages;
    public LogStackTrace InitialStackTrace;
    public LogStackMessages CurrentStackMessages;
    public LogStackTrace CurrentStackTrace;
    public DateTime UtcTime;
    internal LogMessageAttributes LogMessageAttributes;
    public string Message;
    public string Details;
    public Exception Exception;
    public string ExceptionString;
    public int ManagedThreadID;
    public int PreviousFirstChanceExceptionSequenceNumber;
    public MessageClass Classification { get; }
    public MessageLevel Level { get; }
    public MessageFlags Flags { get; }
    public MessageSuppression MessageSuppression { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public ImmutableList`1<string> RelatedTypes { get; }
    public string EventName { get; }
    internal LogMessage(Stream stream, LogMessageSaveHelper saveHelper);
    internal LogMessage(LogEventPublisherDetails eventPublisherDetails, LogStackMessages initialStackMessages, LogStackTrace initialStackTrace, LogStackMessages currentStackMessages, LogStackTrace currentStackTrace, LogMessageAttributes flags, string message, string details, Exception exception);
    public MessageClass get_Classification();
    public MessageLevel get_Level();
    public MessageFlags get_Flags();
    public MessageSuppression get_MessageSuppression();
    public string get_TypeName();
    public string get_AssemblyName();
    public ImmutableList`1<string> get_RelatedTypes();
    public string get_EventName();
    public virtual string ToString();
    internal void Save(Stream stream, LogMessageSaveHelper saveHelper);
    public string GetMessage();
}
internal class GSF.Diagnostics.LogMessageAttributes : ValueType {
    public MessageClass Classification;
    public MessageLevel Level;
    public MessageSuppression MessageSuppression;
    public MessageFlags Flags;
    public LogMessageAttributes(MessageClass classification, MessageLevel level, MessageSuppression messageSuppression, MessageFlags flags);
    public LogMessageAttributes(Stream stream);
    public void Save(Stream stream);
    public static LogMessageAttributes op_Addition(LogMessageAttributes a, MessageSuppression b);
    public static LogMessageAttributes op_Addition(LogMessageAttributes a, MessageFlags b);
}
internal class GSF.Diagnostics.LogMessageSaveHelper : object {
    private static LogMessageSaveHelper Simple;
    private bool m_isSimple;
    private Dictionary`2<LogEventPublisherDetails, int> m_ownerSaveLookup;
    private List`1<LogEventPublisherDetails> m_ownerLoadLookup;
    private Dictionary`2<LogStackMessages, int> m_stackMessagesSaveLookup;
    private List`1<LogStackMessages> m_stackMessagesLoadLookup;
    private Dictionary`2<LogStackTrace, int> m_stackTraceSaveLookup;
    private List`1<LogStackTrace> m_stackTraceLoadLookup;
    private Dictionary`2<PublisherTypeDefinition, int> m_publisherTypeDefinitionSaveLookup;
    private List`1<PublisherTypeDefinition> m_publisherTypeDefinitionLoadLookup;
    private Dictionary`2<string, int> m_stringSaveLookup;
    private List`1<string> m_stringLoadLookup;
    private LogMessageSaveHelper(bool isSimple);
    private static LogMessageSaveHelper();
    public static LogMessageSaveHelper Create(bool isSimple);
    public void SaveEventPublisherDetails(Stream stream, LogEventPublisherDetails publisherDetails);
    public LogEventPublisherDetails LoadEventPublisherDetails(Stream stream);
    public void SavePublisherTypeDefinition(Stream stream, PublisherTypeDefinition publisherDetails);
    public PublisherTypeDefinition LoadPublisherTypeDefinition(Stream stream);
    public void SaveStackMessages(Stream stream, LogStackMessages message);
    public LogStackMessages LoadStackMessages(Stream stream);
    public void SaveStackTrace(Stream stream, LogStackTrace trace);
    public LogStackTrace LoadStackTrace(Stream stream);
    public void SaveString(Stream stream, string value);
    public string LoadString(Stream stream);
}
public class GSF.Diagnostics.LogPublisher : object {
    private LoggerInternal m_logger;
    private LogPublisherInternal m_publisherInstance;
    private MessageClass m_classification;
    public LogStackMessages InitialStackMessages;
    public LogStackTrace InitialStackTrace;
    [CompilerGeneratedAttribute]
private int <MaxDistinctEventPublisherCount>k__BackingField;
    private ConcurrentDictionary`2<Tuple`2<LogMessageAttributes, string>, LogEventPublisherInternal> m_lookupEventPublishers;
    private LogEventPublisherInternal m_excessivePublisherEventNames;
    public int MaxDistinctEventPublisherCount { get; public set; }
    internal LogPublisher(LoggerInternal logger, LogPublisherInternal publisherInstance, MessageClass classification);
    [CompilerGeneratedAttribute]
public int get_MaxDistinctEventPublisherCount();
    [CompilerGeneratedAttribute]
public void set_MaxDistinctEventPublisherCount(int value);
    public LogEventPublisher RegisterEvent(MessageLevel level, string eventName);
    public LogEventPublisher RegisterEvent(MessageLevel level, MessageFlags flags, string eventName);
    public LogEventPublisher RegisterEvent(MessageLevel level, string eventName, int stackTraceDepth, MessageRate messagesPerSecond, int burstLimit);
    public LogEventPublisher RegisterEvent(MessageLevel level, MessageFlags flags, string eventName, int stackTraceDepth, MessageRate messagesPerSecond, int burstLimit);
    public virtual string ToString();
    public void Publish(MessageLevel level, string eventName, string message, string details, Exception exception);
    public void Publish(MessageLevel level, MessageFlags flags, string eventName, string message, string details, Exception exception);
    private LogEventPublisherInternal InternalRegisterEvent(LogMessageAttributes attributes, string eventName);
    private LogEventPublisherInternal InternalRegisterEvent(LogMessageAttributes attributes, string eventName, int stackTraceDepth, MessageRate messagesPerSecond, int burstLimit);
    private LogEventPublisherInternal InternalRegisterNewEvent(LogMessageAttributes attributes, string eventName, int stackTraceDepth, double messagesPerSecond, int burstLimit);
}
internal class GSF.Diagnostics.LogPublisherInternal : object {
    private LoggerInternal m_logger;
    public PublisherTypeDefinition TypeData;
    public Type Type;
    public Assembly Assembly;
    internal MessageAttributeFilterCollection SubscriptionFilterCollection;
    public LogPublisherInternal(LoggerInternal logger, Type type);
    public bool HasSubscribers(LogMessageAttributes attributes);
}
public class GSF.Diagnostics.LogStackFrame : object {
    public string ClassName;
    public string MethodName;
    public string FileName;
    public int NativeOffset;
    public int LineNumber;
    public int ColumnNumber;
    public LogStackFrame(StackFrame frame);
    public LogStackFrame(Stream stream);
    public void Save(Stream stream);
    public virtual string ToString();
    public void ToString(StringBuilder stringBuilder);
    internal int ComputeHashCode();
    public sealed virtual bool Equals(LogStackFrame other);
}
[DefaultMemberAttribute("Item")]
public class GSF.Diagnostics.LogStackMessages : object {
    private SortedList`2<string, string> m_messages;
    private long m_hashCode;
    public static LogStackMessages Empty;
    public int Count { get; }
    public KeyValuePair`2<string, string> Item { get; }
    public string Item { get; }
    public LogStackMessages(String[] keyValuePairs);
    public LogStackMessages(string key, string value);
    public LogStackMessages(List`1<KeyValuePair`2<string, string>> messages);
    public LogStackMessages(List`1<LogStackMessages> messages);
    private LogStackMessages(LogStackMessages a, LogStackMessages b);
    public LogStackMessages(Stream stream);
    private LogStackMessages(LogStackMessages oldMessage, string key, string value);
    private static LogStackMessages();
    public int get_Count();
    public KeyValuePair`2<string, string> get_Item(int index);
    public string get_Item(string key);
    public LogStackMessages Union(string key, string value);
    public LogStackMessages Union(String[] keyValuePairs);
    public LogStackMessages Union(LogStackMessages stackMessage);
    public void Save(Stream stream);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LogStackMessages other);
    public virtual string ToString();
    private int ComputeHashCode();
    internal static void Initialize();
}
public class GSF.Diagnostics.LogStackTrace : object {
    private List`1<LogStackFrame> m_frames;
    public ReadOnlyCollection`1<LogStackFrame> Frames;
    private int m_hashCode;
    public static LogStackTrace Empty;
    public LogStackTrace(bool lookupFileInfo, int skipCount, int maxStackFrames);
    public LogStackTrace(Stream stream);
    private static LogStackTrace();
    private int ComputeHashCode();
    public void Save(Stream stream);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LogStackTrace other);
    internal static void Initialize();
}
public class GSF.Diagnostics.LogSubscriber : object {
    private LogSubscriberInternal m_subscriber;
    internal LogSubscriber(LogSubscriberInternal subscriber);
    public void add_NewLogMessage(NewLogMessageEventHandler value);
    public void remove_NewLogMessage(NewLogMessageEventHandler value);
    public void SubscribeToAll(VerboseLevel level);
    public void SubscribeToType(Type type, VerboseLevel level);
    public void SubscribeToType(string typeExpression, VerboseLevel level);
    public void SubscribeToAssembly(Assembly assembly, VerboseLevel level);
    public void SubscribeToAssembly(string assemblyExpression, VerboseLevel level);
    public void IgnoreAll(VerboseLevel level);
    public void IgnoreType(Type type, VerboseLevel level);
    public void IgnoreType(string typeExpression, VerboseLevel level);
    public void IgnoreAssembly(Assembly assembly, VerboseLevel level);
    public void IgnoreAssembly(string assemblyExpression, VerboseLevel level);
    public void Clear();
    public sealed virtual void Dispose();
}
internal class GSF.Diagnostics.LogSubscriberInternal : object {
    [CompilerGeneratedAttribute]
private NewLogMessageEventHandler NewLogMessage;
    private Action m_recalculateRoutingTable;
    private object m_syncRoot;
    private bool m_disposed;
    private List`1<SubscriptionInfo> m_allSubscriptions;
    public NullableWeakReference Reference;
    public static LogSubscriberInternal DisposedSubscriber;
    public LogSubscriberInternal(Action recalculateRoutingTable);
    private static LogSubscriberInternal();
    [CompilerGeneratedAttribute]
public void add_NewLogMessage(NewLogMessageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NewLogMessage(NewLogMessageEventHandler value);
    public void Clear();
    public void Subscribe(PublisherFilter publisherFilter, MessageAttributeFilter attributeFilter, bool isIgnoreSubscription);
    public void RaiseLogMessages(LogMessage log);
    public MessageAttributeFilter GetSubscription(LogPublisherInternal publisher);
    private void OnLog(LogMessage logMessage);
    public void Dispose();
}
public class GSF.Diagnostics.LogSubscriptionConsole : object {
    private LogSubscriber m_subscriber;
    private VerboseLevel m_verbose;
    public VerboseLevel Verbose { get; public set; }
    public VerboseLevel get_Verbose();
    public void set_Verbose(VerboseLevel value);
    private void SubscriberNewLogMessage(LogMessage logMessage);
}
public class GSF.Diagnostics.LogSubscriptionFileWriter : object {
    [CompilerGeneratedAttribute]
private Action`1<string> NewFileComplete;
    private object m_syncRoot;
    private ConcurrentQueue`1<LogMessage> m_messageQueue;
    private LogSubscriber m_subscriber;
    private int m_maxQueue;
    private string m_path;
    private VerboseLevel m_verbose;
    private LogFileWriter m_writer;
    private int m_maxFileCount;
    private Stopwatch m_fileAge;
    private ScheduledTask m_flushTask;
    private int m_fileSequenceNumber;
    private string m_processName;
    public VerboseLevel Verbose { get; public set; }
    public LogSubscriptionFileWriter(int messageLimit);
    [CompilerGeneratedAttribute]
public void add_NewFileComplete(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_NewFileComplete(Action`1<string> value);
    private void m_flushTask_Running(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
    public VerboseLevel get_Verbose();
    public void set_Verbose(VerboseLevel value);
    public void SetLoggingFileCount(int maxFileCount);
    public void SetPath(string logDirectory);
    public void SetPath(string logDirectory, VerboseLevel level);
    private void SubscriberNewLogMessage(LogMessage logMessage);
    private void WriteLogMessage(LogMessage log);
    public sealed virtual void Dispose();
    private void OnNewFileComplete(string fileName);
}
internal class GSF.Diagnostics.LogSuppressionEngine : object {
    private object m_syncRoot;
    private RateLimiter m_normal;
    private RateLimiter m_low;
    private RateLimiter m_med;
    private double m_messagesPerSecond;
    private int m_burstLimit;
    public LogSuppressionEngine(double messagesPerSecond, int burstLimit);
    public MessageSuppression IncrementPublishCount();
}
internal class GSF.Diagnostics.MessageAttributeFilter : object {
    private MessageLevelFlags m_componentLevel;
    private MessageSuppressionFlags m_componentMessageSuppression;
    private MessageFlags m_componentFlags;
    private MessageLevelFlags m_frameworkLevel;
    private MessageSuppressionFlags m_frameworkMessageSuppression;
    private MessageFlags m_frameworkFlags;
    private MessageLevelFlags m_applicationLevel;
    private MessageSuppressionFlags m_applicationMessageSuppression;
    private MessageFlags m_applicationFlags;
    private MessageAttributeFilter(VerboseLevel verbose);
    public bool IsSubscribedTo(LogMessageAttributes flags);
    public sealed virtual bool Equals(MessageAttributeFilter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Append(MessageAttributeFilter a);
    public void Remove(MessageAttributeFilter a);
    public static MessageAttributeFilter Create(VerboseLevel level);
}
internal class GSF.Diagnostics.MessageAttributeFilterCollection : MessageAttributeFilter {
    public List`1<Tuple`2<MessageAttributeFilter, NullableWeakReference>> Routes;
    public void Add(MessageAttributeFilter filter, LogSubscriberInternal subscriber);
}
public enum GSF.Diagnostics.MessageClass : Enum {
    public byte value__;
    public static MessageClass Component;
    public static MessageClass Framework;
    public static MessageClass Application;
}
[FlagsAttribute]
public enum GSF.Diagnostics.MessageFlags : Enum {
    public byte value__;
    public static MessageFlags None;
    public static MessageFlags UsageIssue;
    public static MessageFlags BugReport;
    public static MessageFlags PerformanceIssue;
    public static MessageFlags SecurityMessage;
    public static MessageFlags SystemHealth;
}
public enum GSF.Diagnostics.MessageLevel : Enum {
    public byte value__;
    public static MessageLevel NA;
    public static MessageLevel Debug;
    public static MessageLevel Info;
    public static MessageLevel Warning;
    public static MessageLevel Error;
    public static MessageLevel Critical;
}
[FlagsAttribute]
public enum GSF.Diagnostics.MessageLevelFlags : Enum {
    public byte value__;
    public static MessageLevelFlags NA;
    public static MessageLevelFlags Debug;
    public static MessageLevelFlags Info;
    public static MessageLevelFlags Warning;
    public static MessageLevelFlags Error;
    public static MessageLevelFlags Critical;
}
public class GSF.Diagnostics.MessageRate : ValueType {
    private double m_rate;
    public static MessageRate Default;
    private MessageRate(double rate);
    private static MessageRate();
    public static MessageRate PerSecond(double messagesPerSecond);
    public static MessageRate PerMinute(double messagesPerMinute);
    public static MessageRate PerHour(double messagesPerHour);
    public static MessageRate PerDay(double messagesPerDay);
    public static MessageRate EveryFewSeconds(double seperation);
    public static MessageRate EveryFewMinutes(double seperation);
    public static MessageRate EveryFewHours(double seperation);
    public static MessageRate EveryFewDays(double seperation);
    public static double op_Implicit(MessageRate rate);
}
public enum GSF.Diagnostics.MessageSuppression : Enum {
    public byte value__;
    public static MessageSuppression None;
    public static MessageSuppression Standard;
    public static MessageSuppression Heavy;
    public static MessageSuppression Severe;
}
[FlagsAttribute]
internal enum GSF.Diagnostics.MessageSuppressionFlags : Enum {
    public byte value__;
    public static MessageSuppressionFlags None;
    public static MessageSuppressionFlags Standard;
    public static MessageSuppressionFlags Heavy;
    public static MessageSuppressionFlags Severe;
}
[CompilerGeneratedAttribute]
internal class GSF.Diagnostics.NamespaceDoc : object {
}
public class GSF.Diagnostics.NewLogMessageEventHandler : MulticastDelegate {
    public NewLogMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(LogMessage logMessage);
    public virtual IAsyncResult BeginInvoke(LogMessage logMessage, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class GSF.Diagnostics.PerformanceCounter : object {
    public static string DefaultValueUnit;
    public static float DefaultValueDivisor;
    public static int DefaultSamplingWindow;
    private string m_aliasName;
    private string m_valueUnit;
    private float m_valueDivisor;
    private int m_samplingWindow;
    private PerformanceCounter m_counter;
    private object m_samplesLock;
    private List`1<float> m_samples;
    private float m_lifetimeMaximum;
    private decimal m_lifetimeTotal;
    private long m_lifetimeSampleCount;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private Func`2<float, float> <SampleAdjuster>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<float, bool> <SampleFilter>k__BackingField;
    public string AliasName { get; public set; }
    public string ValueUnit { get; public set; }
    public float ValueDivisor { get; public set; }
    public int SamplingWindow { get; public set; }
    public List`1<float> Samples { get; }
    public float LastValue { get; }
    public float MinimumValue { get; }
    public float MaximumValue { get; }
    public float AverageValue { get; }
    public float LifetimeMaximumValue { get; }
    public float LifetimeAverageValue { get; }
    public long LifetimeSampleCount { get; }
    public PerformanceCounter BaseCounter { get; }
    public Func`2<float, float> SampleAdjuster { get; public set; }
    public Func`2<float, bool> SampleFilter { get; public set; }
    public PerformanceCounter(string categoryName, string counterName, string instanceName);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, string aliasName);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, string aliasName, string valueUnit);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, string aliasName, string valueUnit, float valueDivisor, bool readOnly);
    internal PerformanceCounter(PerformanceCounter[] sources);
    protected virtual override void Finalize();
    public string get_AliasName();
    public void set_AliasName(string value);
    public string get_ValueUnit();
    public void set_ValueUnit(string value);
    public float get_ValueDivisor();
    public void set_ValueDivisor(float value);
    public int get_SamplingWindow();
    public void set_SamplingWindow(int value);
    public List`1<float> get_Samples();
    public float get_LastValue();
    public float get_MinimumValue();
    public float get_MaximumValue();
    public float get_AverageValue();
    public float get_LifetimeMaximumValue();
    public float get_LifetimeAverageValue();
    public long get_LifetimeSampleCount();
    public PerformanceCounter get_BaseCounter();
    [CompilerGeneratedAttribute]
public Func`2<float, float> get_SampleAdjuster();
    [CompilerGeneratedAttribute]
public void set_SampleAdjuster(Func`2<float, float> value);
    [CompilerGeneratedAttribute]
public Func`2<float, bool> get_SampleFilter();
    [CompilerGeneratedAttribute]
public void set_SampleFilter(Func`2<float, bool> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Sample();
    public void Reset();
}
public class GSF.Diagnostics.PerformanceMonitor : PerformanceMonitorBase {
    public static string ThreadPoolCountersCategoryName;
    private string m_processName;
    public string ProcessName { get; public set; }
    public PerformanceCounter CPUUsage { get; }
    public PerformanceCounter IPDataSendRate { get; }
    public PerformanceCounter IPDataReceiveRate { get; }
    public PerformanceCounter ThreadingContentionRate { get; }
    public PerformanceCounter MemoryUsage { get; }
    public PerformanceCounter IOUsage { get; }
    public PerformanceCounter IOActivity { get; }
    public PerformanceCounter HandleCount { get; }
    public PerformanceCounter ThreadCount { get; }
    public string Name { get; }
    public PerformanceMonitor(double samplingInterval, bool addDefaultCounters);
    public PerformanceMonitor(string processName, bool addDefaultCounters);
    public PerformanceMonitor(string processName, double samplingInterval, bool addDefaultCounters);
    private static PerformanceMonitor();
    protected virtual override void Finalize();
    public string get_ProcessName();
    public void set_ProcessName(string value);
    public PerformanceCounter get_CPUUsage();
    public PerformanceCounter get_IPDataSendRate();
    public PerformanceCounter get_IPDataReceiveRate();
    public PerformanceCounter get_ThreadingContentionRate();
    public PerformanceCounter get_MemoryUsage();
    public PerformanceCounter get_IOUsage();
    public PerformanceCounter get_IOActivity();
    public PerformanceCounter get_HandleCount();
    public PerformanceCounter get_ThreadCount();
    public virtual string get_Name();
    protected virtual void SampleCustomCounters();
}
public abstract class GSF.Diagnostics.PerformanceMonitorBase : object {
    public static double DefaultSamplingInterval;
    private List`1<PerformanceCounter> m_counters;
    private Timer m_samplingTimer;
    private bool m_disposed;
    public double SamplingInterval { get; public set; }
    public ReadOnlyCollection`1<PerformanceCounter> Counters { get; }
    public string Name { get; }
    public string Status { get; }
    public string LifetimeStatus { get; }
    protected PerformanceMonitorBase(double samplingInterval);
    protected virtual override void Finalize();
    public double get_SamplingInterval();
    public void set_SamplingInterval(double value);
    public ReadOnlyCollection`1<PerformanceCounter> get_Counters();
    public virtual string get_Name();
    public virtual string get_Status();
    public virtual string get_LifetimeStatus();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void AddCounter(string categoryName, string counterName, string instanceName);
    public void AddCounter(string categoryName, string counterName, string instanceName, string aliasName);
    public void AddCounter(string categoryName, string counterName, string instanceName, string aliasName, string valueUnit);
    public void AddCounter(string categoryName, string counterName, string instanceName, string aliasName, string valueUnit, float valueDivisor, bool readOnly, Func`2<float, float> sampleAdjuster, Func`2<float, bool> sampleFilter);
    public void AddCounter(PerformanceCounter counter);
    public void RemoveCounter(PerformanceCounter counter);
    public PerformanceCounter FindCounter(string counterName);
    public PerformanceCounter FindCounter(string categoryName, string counterName);
    public PerformanceCounter[] FindCounters(string counterName);
    public PerformanceCounter[] FindCounters(string categoryName, string counterName);
    public void SampleCounters();
    protected virtual void SampleCustomCounters();
    private void SamplingTimer_Elapsed(object sender, ElapsedEventArgs e);
}
public class GSF.Diagnostics.ProcessUtilizationCalculator : object {
    public static int DefaultUpdateInterval;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<string>> StatusMessage;
    private Timer m_updateUtilizationTimer;
    private List`1<ProcessReference> m_processReferences;
    private int m_updateInterval;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private double <Utilization>k__BackingField;
    public double Utilization { get; private set; }
    public int UpdateInterval { get; public set; }
    public Process[] AssociatedProcesses { get; }
    [CompilerGeneratedAttribute]
public void add_StatusMessage(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_StatusMessage(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public double get_Utilization();
    [CompilerGeneratedAttribute]
private void set_Utilization(double value);
    public int get_UpdateInterval();
    public void set_UpdateInterval(int value);
    public Process[] get_AssociatedProcesses();
    public sealed virtual void Dispose();
    public void Initialize(Process[] processes);
    public void Initialize(IEnumerable`1<Process> processes);
    public void Refresh();
    private void UpdateUtilizationTimerElapsed(object sender, ElapsedEventArgs e);
    private void OnStatusMessage(MessageLevel level, string status);
}
internal class GSF.Diagnostics.PublisherFilter : object {
    private FilterType m_filterType;
    private string m_text;
    private bool m_isExpression;
    private Regex m_regexMatch;
    private PublisherFilter(FilterType filterType);
    private PublisherFilter(FilterType filterType, string text);
    public bool ContainsPublisher(LogPublisherInternal publisher);
    public bool ContainsTheSameLogSearchCriteria(PublisherFilter other);
    public virtual string ToString();
    public static PublisherFilter CreateType(Type type);
    public static PublisherFilter CreateType(string name);
    private static string TrimAfterFullName(string name);
    public static PublisherFilter CreateAssembly(Assembly assembly);
    public static PublisherFilter CreateAssembly(string name);
    public static PublisherFilter CreateUniversal();
}
public class GSF.Diagnostics.PublisherTypeDefinition : object {
    public string TypeName;
    public string AssemblyName;
    public string AssemblyVersion;
    public ImmutableList`1<string> RelatedTypes;
    private int m_hashCode;
    public PublisherTypeDefinition(Type type);
    public PublisherTypeDefinition(Stream stream);
    internal PublisherTypeDefinition(string typeName, string assemblyName);
    private int ComputeHashCode();
    public void Save(Stream stream);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PublisherTypeDefinition obj);
    private static bool AreEqual(ImmutableList`1<string> a, ImmutableList`1<string> b);
    private static string TrimAfterFullName(string name);
}
public class GSF.Diagnostics.SystemPerformanceMonitor : PerformanceMonitorBase {
    private static SystemPerformanceMonitor s_systemPerformanceMonitor;
    public PerformanceCounter CPUUsage { get; }
    public PerformanceCounter AvailableMemory { get; }
    public static SystemPerformanceMonitor Default { get; }
    public SystemPerformanceMonitor(double samplingInterval);
    public PerformanceCounter get_CPUUsage();
    public PerformanceCounter get_AvailableMemory();
    public static SystemPerformanceMonitor get_Default();
}
public static class GSF.Diagnostics.ThreadPoolMonitor : object {
    private static LogPublisher Log;
    private static List`1<Monitor> s_monitors;
    private static ShortTime s_lastResetTime;
    private static ThreadPoolMonitor();
    public static void Initialize();
    private static void LoadingAdjustedTimestamp_OnHighLoad();
    private static void MonitorThreads();
}
public static class GSF.Diagnostics.ThreadPoolTrace : object {
    private static LogPublisher Log;
    [CompilerGeneratedAttribute]
private static bool <WorksInThisRuntime>k__BackingField;
    private static Type s_threadPoolType;
    private static MethodInfo s_threadPoolGetQueuedWorkItemsMethod;
    private static Type s_queueWorkerCallbackType;
    private static FieldInfo s_callbackField;
    private static FieldInfo s_stateField;
    private static Type s_timerQueueTimerType;
    private static FieldInfo s_timerQueueTimerTimerCallbackField;
    private static Type s_timerQueueType;
    private static MethodInfo s_timerQueueFireQueuedTimerCompletionMethod;
    private static Type s_timerType;
    private static FieldInfo s_timerOnIntervalElapsedField;
    public static bool WorksInThisRuntime { get; private set; }
    private static ThreadPoolTrace();
    [CompilerGeneratedAttribute]
public static bool get_WorksInThisRuntime();
    [CompilerGeneratedAttribute]
private static void set_WorksInThisRuntime(bool value);
    public static void GetTrace(StringBuilder sb);
    private static void ProcessIThreadPoolWorkItem(StringBuilder sb, object item);
    private static bool TryProcessThreadingTimerCallback(StringBuilder sb, WaitCallback callback, object state);
    private static bool TryProcessTimersTimerCallback(StringBuilder sb, TimerCallback timerCallback);
}
public static class GSF.Diagnostics.TimerTrace : object {
    private static LogPublisher Log;
    [CompilerGeneratedAttribute]
private static bool <WorksInThisRuntime>k__BackingField;
    private static Type s_timerQueueType;
    private static MethodInfo s_timerQueueInstanceMethod;
    private static FieldInfo s_timerQueueTimersField;
    private static Type s_timerQueueTimerType;
    private static FieldInfo s_timerQueueTimerTimerCallbackField;
    private static FieldInfo s_timerQueueTimerNextField;
    private static Type s_timerType;
    private static FieldInfo s_timerOnIntervalElapsedField;
    public static bool WorksInThisRuntime { get; private set; }
    private static TimerTrace();
    [CompilerGeneratedAttribute]
public static bool get_WorksInThisRuntime();
    [CompilerGeneratedAttribute]
private static void set_WorksInThisRuntime(bool value);
    public static void GetTrace(StringBuilder sb);
    private static void ProcessTimerQueueTimer(StringBuilder sb, object state);
    private static bool TryProcessTimersTimerCallback(StringBuilder sb, TimerCallback timerCallback);
}
public enum GSF.Diagnostics.VerboseLevel : Enum {
    public int value__;
    public static VerboseLevel None;
    public static VerboseLevel Low;
    public static VerboseLevel Medium;
    public static VerboseLevel High;
    public static VerboseLevel Ultra;
    public static VerboseLevel All;
}
[ExtensionAttribute]
public static class GSF.Drawing.BitmapExtensions : object {
    [ExtensionAttribute]
public static Bitmap Resize(Image originalImage, Size newSize);
    [ExtensionAttribute]
public static Bitmap Resize(Image originalImage, Size newSize, bool disposeOriginal);
    [ExtensionAttribute]
public static Bitmap Crop(Image originalImage, Rectangle croppedArea);
    [ExtensionAttribute]
public static Bitmap Crop(Image originalImage, Rectangle croppedArea, bool disposeOriginal);
    [ExtensionAttribute]
public static Bitmap ConvertTo(Image originalImage, ImageFormat newFormat);
    [ExtensionAttribute]
public static Bitmap ConvertTo(Image originalImage, ImageFormat newFormat, bool disposeOriginal);
    public static Bitmap FromPixelData(int width, UInt32[] pixelData);
    [ExtensionAttribute]
public static UInt32[] ToPixelData(Bitmap bitmap);
}
[CompilerGeneratedAttribute]
internal class GSF.Drawing.NamespaceDoc : object {
}
public class GSF.Drawing.Point : object {
    [CompilerGeneratedAttribute]
private double <X>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Y>k__BackingField;
    public double X { get; private set; }
    public double Y { get; private set; }
    public Point(double x, double y);
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
private void set_X(double value);
    [CompilerGeneratedAttribute]
public double get_Y();
    [CompilerGeneratedAttribute]
private void set_Y(double value);
}
public static class GSF.EmptyArray`1 : object {
    public static T[] Empty;
    private static EmptyArray`1();
}
public enum GSF.EnabledState : Enum {
    public int value__;
    public static EnabledState Auto;
    public static EnabledState On;
    public static EnabledState Off;
}
public static class GSF.Encoding7Bit : object {
    public static int GetSizeInt15(short value1);
    public static int MeasureInt15(Byte* stream);
    public static int Measure15(Byte* stream, int position);
    public static int Measure15(Byte[] stream, int position);
    public static int WriteInt15(Byte* stream, short value1);
    public static void WriteInt15(Byte* stream, Int32& position, short value1);
    public static void WriteInt15(Byte[] stream, Int32& position, short value1);
    public static void WriteInt15(Action`1<byte> stream, short value1);
    public static short ReadInt15(Byte* stream, Int32& position);
    public static short ReadInt15(Byte[] stream, Int32& position);
    public static short ReadInt15(Stream stream);
    public static short ReadInt15(Func`1<byte> stream);
    public static int GetSize(UInt32 value1);
    public static int MeasureUInt32(Byte* stream);
    public static int MeasureUInt32(Byte* stream, int position);
    public static int MeasureUInt32(Byte[] stream, int position);
    public static int Write(Byte* stream, UInt32 value1);
    public static void Write(Byte* stream, Int32& position, UInt32 value1);
    public static void Write(Byte[] stream, Int32& position, UInt32 value1);
    public static void Write(Action`1<byte> stream, UInt32 value1);
    public static UInt32 ReadUInt32(Byte* stream, Int32& position);
    public static UInt32 ReadUInt32(Byte[] stream, Int32& position);
    public static UInt32 ReadUInt32(Stream stream);
    public static UInt32 ReadUInt32(Func`1<byte> stream);
    public static int GetSize(ulong value1);
    public static int MeasureUInt64(Byte* stream);
    public static int MeasureUInt64(Byte* stream, int position);
    public static int MeasureUInt64(Byte[] stream, int position);
    public static int Write(Byte* stream, ulong value1);
    public static void Write(Byte* stream, Int32& position, ulong value1);
    public static void Write(Byte[] stream, Int32& position, ulong value1);
    public static void Write(Action`1<byte> stream, ulong value1);
    public static ulong ReadUInt64(Byte* stream, Int32& position);
    public static ulong ReadUInt64(Byte[] stream, Int32& position);
    public static ulong ReadUInt64(Stream stream);
    public static ulong ReadUInt64(Func`1<byte> stream);
}
public enum GSF.Endianness : Enum {
    public int value__;
    public static Endianness BigEndian;
    public static Endianness LittleEndian;
}
public class GSF.EndianOrder : object {
    private bool m_targetIsNativeEndian;
    private bool m_targetIsLittleEndian;
    private Endianness m_targetEndianness;
    private CopyBufferFunction m_copyBuffer;
    private CoerceByteOrderFunction m_coerceByteOrder;
    public static EndianOrder BigEndian;
    public static EndianOrder LittleEndian;
    public Endianness TargetEndianness { get; }
    protected EndianOrder(Endianness targetEndianness);
    private static EndianOrder();
    public Endianness get_TargetEndianness();
    private void BlockCopy(Byte[] sourceBuffer, int sourceIndex, Byte[] destinationBuffer, int destinationIndex, int length);
    private void SwapCopy(Byte[] sourceBuffer, int sourceIndex, Byte[] destinationBuffer, int destinationIndex, int length);
    private Byte[] PassThroughBuffer(Byte[] buffer);
    private Byte[] ReverseBuffer(Byte[] buffer);
    [ObsoleteAttribute("This method may be removed from future builds", "False")]
public void CopyBuffer(Byte[] sourceBuffer, int sourceIndex, Byte[] destinationBuffer, int destinationIndex, int length);
    [ObsoleteAttribute("This method may be removed from future builds", "False")]
public Byte[] CoerceByteOrder(Byte[] buffer);
    public bool ToBoolean(Byte[] value, int startIndex);
    public char ToChar(Byte[] value, int startIndex);
    public double ToDouble(Byte[] value, int startIndex);
    public short ToInt16(Byte[] value, int startIndex);
    public Int24 ToInt24(Byte[] value, int startIndex);
    public int ToInt32(Byte[] value, int startIndex);
    public long ToInt64(Byte[] value, int startIndex);
    public float ToSingle(Byte[] value, int startIndex);
    public ushort ToUInt16(Byte[] value, int startIndex);
    public UInt24 ToUInt24(Byte[] value, int startIndex);
    public UInt32 ToUInt32(Byte[] value, int startIndex);
    public ulong ToUInt64(Byte[] value, int startIndex);
    [ObsoleteAttribute("This method may be removed from future builds", "False")]
[EditorBrowsableAttribute("1")]
public Guid ToGuid(Byte[] value, int startIndex);
    public Byte[] GetBytes(T value);
    public Byte[] GetBytes(bool value);
    public Byte[] GetBytes(char value);
    public Byte[] GetBytes(double value);
    public Byte[] GetBytes(short value);
    public Byte[] GetBytes(Int24 value);
    public Byte[] GetBytes(int value);
    public Byte[] GetBytes(long value);
    public Byte[] GetBytes(float value);
    public Byte[] GetBytes(ushort value);
    public Byte[] GetBytes(UInt24 value);
    public Byte[] GetBytes(UInt32 value);
    public Byte[] GetBytes(ulong value);
    [ObsoleteAttribute("This method may be removed from future builds", "False")]
[EditorBrowsableAttribute("1")]
public Byte[] GetBytes(Guid value);
    public int CopyBytes(T value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(bool value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(char value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(double value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(short value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(Int24 value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(int value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(long value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(float value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(ushort value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(UInt24 value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(UInt32 value, Byte[] destinationArray, int destinationIndex);
    public int CopyBytes(ulong value, Byte[] destinationArray, int destinationIndex);
    [ObsoleteAttribute("This method may be removed from future builds", "False")]
[EditorBrowsableAttribute("1")]
public int CopyBytes(Guid value, Byte[] destinationArray, int destinationIndex);
}
[ExtensionAttribute]
public static class GSF.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(Enum enumeration, bool defaultToName);
    [ExtensionAttribute]
public static T GetEnumValueOrDefault(object value, object defaultValue);
    [ExtensionAttribute]
public static object GetEnumValueOrDefault(object value, Type type, object defaultValue);
    [ExtensionAttribute]
public static object GetEnumValueByDescription(string description, Type type, bool ignoreCase);
    [ExtensionAttribute]
public static object GetEnumValueByName(string name, Type type, bool ignoreCase);
    [ExtensionAttribute]
public static string GetFormattedName(Enum enumeration);
    [ExtensionAttribute]
private static string GetDescription(FieldInfo value);
}
[ToolboxBitmapAttribute("GSF.ErrorManagement.ErrorLogger")]
public class GSF.ErrorManagement.ErrorLogger : Component {
    public static bool DefaultLogToUI;
    public static bool DefaultLogToFile;
    public static bool DefaultLogToEmail;
    public static bool DefaultLogToEventLog;
    public static bool DefaultLogToDatabase;
    public static bool DefaultLogUserInfo;
    private static int DefaultDatabaseLogSize;
    public static string DefaultSmtpServer;
    public static string DefaultContactName;
    public static string DefaultContactEmail;
    public static string DefaultContactPhone;
    public static bool DefaultPersistSettings;
    public static string DefaultSettingsCategory;
    public static bool DefaultHandleUnhandledException;
    public static bool DefaultExitOnUnhandledException;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> LoggingException;
    private bool m_logToUI;
    private bool m_logToFile;
    private bool m_logToEmail;
    private bool m_logToEventLog;
    private bool m_logToDatabase;
    private bool m_logUserInfo;
    private int m_databaseLogSize;
    private string m_smtpServer;
    private string m_contactName;
    private string m_contactEmail;
    private string m_contactPhone;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private bool m_enabled;
    private bool m_handleUnhandledException;
    private bool m_exitOnUnhandledException;
    private LogFile m_errorLog;
    private Exception m_lastException;
    private ApplicationType m_appType;
    private Func`1<string> m_errorTextMethod;
    private Func`1<string> m_scopeTextMethod;
    private Func`1<string> m_actionTextMethod;
    private Func`1<string> m_moreInfoTextMethod;
    private List`1<Action`1<Exception>> m_loggers;
    private bool m_logToFileOK;
    private bool m_logToEmailOK;
    private bool m_logToEventLogOK;
    private bool m_logToDatabaseOK;
    private bool m_disposed;
    private bool m_initialized;
    private bool m_suppressInteractiveLogging;
    private ProcessQueue`1<Tuple`4<string, string, string, string>> m_databaseErrorQueue;
    private Timer m_tableSizeCurtailmentTimer;
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether Exception information is to be displayed on the application UI.")]
public bool LogToUI { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("True")]
[DescriptionAttribute("Indicates whether Exception information is to be written to the ErrorLog.")]
public bool LogToFile { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether Exception information is to be sent in an e-mail to the ContactEmail address.")]
public bool LogToEmail { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("True")]
[DescriptionAttribute("Indicates whether Exception information is to be written to the EventLog.")]
public bool LogToEventLog { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether Exception information is to be written to the database.")]
public bool LogToDatabase { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether information about a local user (for windows application) or remote user (for web application) is to be logged when logging an Exception.")]
public bool LogUserInfo { get; public set; }
    [CategoryAttribute("Logging")]
[DefaultValueAttribute("2000")]
[DescriptionAttribute("Defines the maximum exception log size to maintain when logging exceptions to the database.")]
public int DatabaseLogSize { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("localhost")]
[DescriptionAttribute("The SMTP server to be used for sending e-mail messages containing Exception information to the ContactEmail address.")]
public string SmtpServer { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("")]
[DescriptionAttribute("Name of the person who can be contacted by the end-user in case of an Exception.")]
public string ContactName { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("")]
[DescriptionAttribute("E-mail address where e-mail messages containing Exception information are to be sent when the LogToEmail property is set to true.")]
public string ContactEmail { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("")]
[DescriptionAttribute("Phone number that can be used by the end-user to communicate about an encountered Exception.")]
public string ContactPhone { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether the settings of ErrorLogger object are to be saved to the config file.")]
public bool PersistSettings { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("ErrorLogger")]
[DescriptionAttribute("Category under which the settings of ErrorLogger object are to be saved to the config file if the PersistSettings property is set to true.")]
public string SettingsCategory { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("True")]
[DescriptionAttribute("Indicates whether the ErrorLogger object must register itself to handle Exception that are not trapped inside of a try-catch block.")]
public bool HandleUnhandledException { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether the application will terminate after logging an unhandled Exception.")]
public bool ExitOnUnhandledException { get; public set; }
    [CategoryAttribute("Components")]
[DescriptionAttribute("Get the LogFile object used for logging Exception information to a file.")]
[DesignerSerializationVisibilityAttribute("2")]
public LogFile ErrorLog { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Enabled { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsDisposed { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Func`1<string> ErrorTextMethod { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Func`1<string> ScopeTextMethod { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Func`1<string> ActionTextMethod { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Func`1<string> MoreInfoTextMethod { get; public set; }
    public bool SuppressInteractiveLogging { get; protected set; }
    [BrowsableAttribute("False")]
public string ApplicationName { get; }
    [BrowsableAttribute("False")]
public ApplicationType ApplicationType { get; }
    [BrowsableAttribute("False")]
public Exception LastException { get; }
    [BrowsableAttribute("False")]
public List`1<Action`1<Exception>> Loggers { get; }
    [BrowsableAttribute("False")]
public string Name { get; }
    [BrowsableAttribute("False")]
public string Status { get; }
    public ErrorLogger(IContainer container);
    [CompilerGeneratedAttribute]
public void add_LoggingException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_LoggingException(EventHandler`1<EventArgs`1<Exception>> value);
    public bool get_LogToUI();
    public void set_LogToUI(bool value);
    public bool get_LogToFile();
    public void set_LogToFile(bool value);
    public bool get_LogToEmail();
    public void set_LogToEmail(bool value);
    public bool get_LogToEventLog();
    public void set_LogToEventLog(bool value);
    public bool get_LogToDatabase();
    public void set_LogToDatabase(bool value);
    public bool get_LogUserInfo();
    public void set_LogUserInfo(bool value);
    public int get_DatabaseLogSize();
    public void set_DatabaseLogSize(int value);
    public string get_SmtpServer();
    public void set_SmtpServer(string value);
    public string get_ContactName();
    public void set_ContactName(string value);
    public string get_ContactEmail();
    public void set_ContactEmail(string value);
    public string get_ContactPhone();
    public void set_ContactPhone(string value);
    public sealed virtual bool get_PersistSettings();
    public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public bool get_HandleUnhandledException();
    public void set_HandleUnhandledException(bool value);
    public bool get_ExitOnUnhandledException();
    public void set_ExitOnUnhandledException(bool value);
    public LogFile get_ErrorLog();
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public Func`1<string> get_ErrorTextMethod();
    public void set_ErrorTextMethod(Func`1<string> value);
    public Func`1<string> get_ScopeTextMethod();
    public void set_ScopeTextMethod(Func`1<string> value);
    public Func`1<string> get_ActionTextMethod();
    public void set_ActionTextMethod(Func`1<string> value);
    public Func`1<string> get_MoreInfoTextMethod();
    public void set_MoreInfoTextMethod(Func`1<string> value);
    public bool get_SuppressInteractiveLogging();
    protected void set_SuppressInteractiveLogging(bool value);
    public string get_ApplicationName();
    public ApplicationType get_ApplicationType();
    public Exception get_LastException();
    public List`1<Action`1<Exception>> get_Loggers();
    public sealed virtual string get_Name();
    public virtual string get_Status();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Initialize();
    [EditorBrowsableAttribute("1")]
public sealed virtual void BeginInit();
    [EditorBrowsableAttribute("1")]
public sealed virtual void EndInit();
    public virtual void SaveSettings();
    public virtual void LoadSettings();
    public void Log(Exception exception);
    public void Log(Exception exception, bool exitApplication);
    protected virtual bool Register();
    protected virtual bool Unregister();
    protected virtual void ExceptionToUI(Exception exception);
    protected virtual void ExceptionToWindowsGui();
    protected virtual void ExceptionToWindowsCui();
    protected virtual void ExceptionToWebPage();
    protected virtual void ExceptionToFile(Exception exception);
    protected virtual void ExceptionToEmail(Exception exception);
    protected virtual string GetEmailAttachments();
    protected virtual void ExceptionToEventLog(Exception exception);
    protected virtual void ExceptionToDatabase(Exception exception);
    private void ProcessExceptionsToDatabase(Tuple`4[] exceptions);
    private void m_tableSizeCurtailmentTimer_Elapsed(object sender, ElapsedEventArgs e);
    private void m_databaseErrorQueue_ProcessException(object sender, EventArgs`1<Exception> e);
    protected virtual void OnLoggingException(Exception exception);
    private string GetErrorText();
    private string GetScopeText();
    private string GetActionText();
    protected string GetMoreInfoText();
    protected virtual string GetExtendedMoreInfoText(string bullet);
    private void UnhandledException(object sender, UnhandledExceptionEventArgs e);
    public static string GetExceptionInfo(Exception ex, bool includeUserInfo);
    private static string GetSystemInfo(bool includeUserInfo);
    private static string GetApplicationInfo();
    private static string GetExceptionGeneralInfo(Exception ex);
    private static string GetExceptionStackTrace(Exception ex);
}
public class GSF.ErrorManagement.ErrorModule : object {
    private HttpApplication m_context;
    private static ErrorLogger s_logger;
    public static ErrorLogger Logger { get; }
    private static ErrorModule();
    public sealed virtual void Init(HttpApplication context);
    public sealed virtual void Dispose();
    private void OnError(object sender, EventArgs e);
    public static ErrorLogger get_Logger();
}
[CompilerGeneratedAttribute]
internal class GSF.ErrorManagement.NamespaceDoc : object {
}
public class GSF.ErrorManagement.SmtpTraceListener : TraceListener {
    private string m_sender;
    private string m_recipient;
    private string m_smtpServer;
    public SmtpTraceListener(string initializationData);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public class GSF.EventArgs`1 : EventArgs {
    public T Argument;
    public EventArgs`1(T argument);
}
public class GSF.EventArgs`2 : EventArgs {
    public T1 Argument1;
    public T2 Argument2;
    public EventArgs`2(T1 argument1, T2 argument2);
}
public class GSF.EventArgs`3 : EventArgs {
    public T1 Argument1;
    public T2 Argument2;
    public T3 Argument3;
    public EventArgs`3(T1 argument1, T2 argument2, T3 argument3);
}
public class GSF.EventArgs`4 : EventArgs {
    public T1 Argument1;
    public T2 Argument2;
    public T3 Argument3;
    public T4 Argument4;
    public EventArgs`4(T1 argument1, T2 argument2, T3 argument3, T4 argument4);
}
public static class GSF.FastObjectFactory : object {
    private static ConcurrentDictionary`2<int, Delegate> s_createObjectFunctions;
    private static FastObjectFactory();
    public static Func`1<object> GetCreateObjectFunction(Type type);
    public static Func`1<T> GetCreateObjectFunction(Type type);
}
public static class GSF.FastObjectFactory`1 : object {
    [CompilerGeneratedAttribute]
private static Func`1<T> <CreateObjectFunction>k__BackingField;
    public static Func`1<T> CreateObjectFunction { get; }
    private static FastObjectFactory`1();
    [CompilerGeneratedAttribute]
public static Func`1<T> get_CreateObjectFunction();
}
[ExtensionAttribute]
public static class GSF.FuzzyStrings.ComparisonMetrics : object {
    [ExtensionAttribute]
public static bool ApproximatelyEquals(string source, string target, FuzzyStringComparisonOptions options, FuzzyStringComparisonTolerance tolerance);
    [ExtensionAttribute]
public static int HammingDistance(string source, string target);
    [ExtensionAttribute]
public static double JaccardDistance(string source, string target);
    [ExtensionAttribute]
public static double JaccardIndex(string source, string target);
    [ExtensionAttribute]
public static double JaroDistance(string source, string target);
    [ExtensionAttribute]
public static double JaroWinklerDistance(string source, string target);
    public static double JaroWinklerDistanceWithPrefixScale(string source, string target, double p);
    private static double CommonPrefixLength(string source, string target);
    [ExtensionAttribute]
public static int LevenshteinDistance(string source, string target);
    [ExtensionAttribute]
public static double NormalizedLevenshteinDistance(string source, string target);
    [ExtensionAttribute]
public static int LevenshteinDistanceUpperBounds(string source, string target);
    [ExtensionAttribute]
public static int LevenshteinDistanceLowerBounds(string source, string target);
    [ExtensionAttribute]
public static string LongestCommonSubsequence(string source, string target);
    private static Int32[0...,0...] LongestCommonSubsequenceLengthTable(string source, string target);
    private static string Backtrack(Int32[0...,0...] C, string source, string target, int i, int j);
    [ExtensionAttribute]
public static string LongestCommonSubstring(string source, string target);
    [ExtensionAttribute]
public static double OverlapCoefficient(string source, string target);
    [ExtensionAttribute]
public static double RatcliffObershelpSimilarity(string source, string target);
    [ExtensionAttribute]
public static double SorensenDiceDistance(string source, string target);
    [ExtensionAttribute]
public static double SorensenDiceIndex(string source, string target);
    [ExtensionAttribute]
public static double TanimotoCoefficient(string source, string target);
}
[FlagsAttribute]
public enum GSF.FuzzyStrings.FuzzyStringComparisonOptions : Enum {
    public int value__;
    public static FuzzyStringComparisonOptions UseHammingDistance;
    public static FuzzyStringComparisonOptions UseJaccardDistance;
    public static FuzzyStringComparisonOptions UseJaroDistance;
    public static FuzzyStringComparisonOptions UseJaroWinklerDistance;
    public static FuzzyStringComparisonOptions UseLevenshteinDistance;
    public static FuzzyStringComparisonOptions UseLongestCommonSubsequence;
    public static FuzzyStringComparisonOptions UseLongestCommonSubstring;
    public static FuzzyStringComparisonOptions UseNormalizedLevenshteinDistance;
    public static FuzzyStringComparisonOptions UseOverlapCoefficient;
    public static FuzzyStringComparisonOptions UseRatcliffObershelpSimilarity;
    public static FuzzyStringComparisonOptions UseSorensenDiceDistance;
    public static FuzzyStringComparisonOptions UseTanimotoCoefficient;
    public static FuzzyStringComparisonOptions CaseSensitive;
}
public enum GSF.FuzzyStrings.FuzzyStringComparisonTolerance : Enum {
    public int value__;
    public static FuzzyStringComparisonTolerance Strong;
    public static FuzzyStringComparisonTolerance Normal;
    public static FuzzyStringComparisonTolerance Weak;
    public static FuzzyStringComparisonTolerance Manual;
}
[ExtensionAttribute]
public static class GSF.FuzzyStrings.Operations : object {
    [ExtensionAttribute]
public static string Capitalize(string source);
    public static String[] SplitIntoIndividualElements(string source);
    public static string MergeIndividualElementsIntoString(IEnumerable`1<string> source);
    [ExtensionAttribute]
public static List`1<string> ListPrefixes(string source);
    [ExtensionAttribute]
public static List`1<string> ListBigrams(string source);
    [ExtensionAttribute]
public static List`1<string> ListTriGrams(string source);
    [ExtensionAttribute]
public static List`1<string> ListNGrams(string source, int n);
}
[ExtensionAttribute]
public static class GSF.GuidExtensions : object {
    [ExtensionAttribute]
public static int ToRfcBytes(Guid guid, Byte[] buffer, int startingIndex);
    [ExtensionAttribute]
public static int ToRfcBytes(Guid guid, Byte* buffer);
    [ExtensionAttribute]
public static Byte[] ToRfcBytes(Guid guid);
    [ExtensionAttribute]
public static Guid ToRfcGuid(Byte[] buffer);
    public static Guid ToRfcGuid(Byte* buffer);
    [ExtensionAttribute]
public static Guid ToRfcGuid(Byte[] buffer, int startingIndex);
    public static Byte[] ToLittleEndianBytes(Guid guid);
    public static int CopyLittleEndianBytes(Guid guid, Byte[] buffer, int startingIndex);
    public static int CopyLittleEndianBytes(Guid guid, Byte* buffer);
    public static Guid ToLittleEndianGuid(Byte[] buffer);
    public static Guid ToLittleEndianGuid(Byte[] buffer, int startingIndex);
    public static Guid ToLittleEndianGuid(Byte* buffer);
    [ObsoleteAttribute("This method is for backwards compatibility only. Use ToRfcBytes from now on.", "False")]
[EditorBrowsableAttribute("1")]
public static Byte[] __ToBigEndianOrderBytes(Guid guid);
    [ObsoleteAttribute("This method is for backwards compatibility only. Use ToRfcBytes from now on.", "False")]
[EditorBrowsableAttribute("1")]
public static int __ToBigEndianOrderBytes(Guid guid, Byte[] buffer, int startingIndex);
    [ObsoleteAttribute("This method is for backwards compatibility only. Use ToRfcGuid from now on.", "False")]
[EditorBrowsableAttribute("1")]
public static Guid __ToBigEndianOrderGuid(Byte[] buffer);
    [ObsoleteAttribute("This method is for backwards compatibility only. Use ToRfcGuid from now on.", "False")]
[EditorBrowsableAttribute("1")]
public static Guid __ToBigEndianOrderGuid(Byte[] buffer, int startingIndex);
}
public class GSF.IdentifiableItem`2 : object {
    public TId ID;
    public TItem Item;
    public IdentifiableItem`2(TId id, TItem item);
}
internal interface GSF.Identity.IUserInfo {
    public bool DomainRespondsForUser { get; }
    public bool Exists { get; }
    public bool Enabled { get; public set; }
    public DateTime LastLogon { get; }
    public DateTime AccountCreationDate { get; }
    public DateTime NextPasswordChangeDate { get; }
    public int LocalUserAccountControl { get; }
    public Ticks MaximumPasswordAge { get; }
    public String[] Groups { get; }
    public String[] LocalGroups { get; }
    public string FullLocalUserName { get; }
    public bool IsLocalAccount { get; }
    public abstract virtual bool get_DomainRespondsForUser();
    public abstract virtual bool get_Exists();
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual DateTime get_LastLogon();
    public abstract virtual DateTime get_AccountCreationDate();
    public abstract virtual DateTime get_NextPasswordChangeDate();
    public abstract virtual int get_LocalUserAccountControl();
    public abstract virtual Ticks get_MaximumPasswordAge();
    public abstract virtual String[] get_Groups();
    public abstract virtual String[] get_LocalGroups();
    public abstract virtual string get_FullLocalUserName();
    public abstract virtual bool get_IsLocalAccount();
    public abstract virtual bool Initialize();
    public abstract virtual void ChangePassword(string oldPassword, string newPassword);
    public abstract virtual string GetUserPropertyValue(string propertyName);
}
[CompilerGeneratedAttribute]
internal class GSF.Identity.NamespaceDoc : object {
}
internal class GSF.Identity.UnixUserInfo : object {
    private static int MaxAccountNameLength;
    private static string ImportFileName;
    private UserInfo m_parent;
    private LdapConnection m_connection;
    private LdapEntry m_userEntry;
    private string m_ldapRoot;
    private bool m_domainRespondsForUser;
    private bool m_isLocalAccount;
    private bool m_enabled;
    private bool m_initialized;
    private bool m_disposed;
    private static String[] s_builtInLocalGroups;
    public bool DomainRespondsForUser { get; }
    public bool Exists { get; }
    public bool Enabled { get; public set; }
    public DateTime LastLogon { get; }
    public DateTime AccountCreationDate { get; }
    public DateTime NextPasswordChangeDate { get; }
    public int LocalUserAccountControl { get; }
    public Ticks MaximumPasswordAge { get; }
    public String[] Groups { get; }
    public String[] LocalGroups { get; }
    public string FullLocalUserName { get; }
    public bool IsLocalAccount { get; }
    public static bool MachineIsJoinedToDomain { get; }
    public UnixUserInfo(UserInfo parent);
    private static UnixUserInfo();
    protected virtual override void Finalize();
    public sealed virtual bool get_DomainRespondsForUser();
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual DateTime get_LastLogon();
    public sealed virtual DateTime get_AccountCreationDate();
    public sealed virtual DateTime get_NextPasswordChangeDate();
    public sealed virtual int get_LocalUserAccountControl();
    public sealed virtual Ticks get_MaximumPasswordAge();
    public sealed virtual String[] get_Groups();
    public sealed virtual String[] get_LocalGroups();
    public sealed virtual string get_FullLocalUserName();
    public sealed virtual bool get_IsLocalAccount();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual bool Initialize();
    private UnixIdentity GetUnixIdentity();
    private UnixIdentity AttemptAnonymousBinding(UnixIdentity unixIdentity);
    public sealed virtual void ChangePassword(string oldPassword, string newPassword);
    public String[] GetUserPropertyValueCollection(string propertyName);
    public sealed virtual string GetUserPropertyValue(string propertyName);
    public static bool get_MachineIsJoinedToDomain();
    public static String[] GetBuiltInLocalGroups();
    public static IPrincipal AuthenticateUser(string domain, string userName, string password, String& errorMessage);
    private static string GetLdapHost();
    public static WindowsImpersonationContext ImpersonateUser(string domain, string userName, string password);
    public static bool LocalUserExists(string userName);
    public static bool CreateLocalUser(string userName, string password, string userDescription);
    public static void SetLocalUserPassword(string userName, string password);
    private static string GetRandomSalt();
    public static bool RemoveLocalUser(string userName);
    public static bool LocalGroupExists(string groupName);
    public static bool CreateLocalGroup(string groupName);
    public static bool RemoveLocalGroup(string groupName);
    public static bool UserIsInLocalGroup(string groupName, string userName);
    public static bool AddUserToLocalGroup(string groupName, string userName);
    public static bool RemoveUserFromLocalGroup(string groupName, string userName);
    public static String[] GetLocalGroupUserList(string groupName);
    private static HashSet`1<string> GetLocalGroupUserSet(string groupName);
    public static string UserNameToSID(string userName);
    public static string GroupNameToSID(string groupName);
    public static string SIDToAccountName(string sid);
    public static bool IsUserSID(string sid);
    public static bool IsGroupSID(string sid);
    private static bool TryExtractAccountID(string sid, UInt32& accountID);
    private static String[] GetLocalUserGroups(string userName);
    private static int GetCachedLocalUserPasswordInformation(IPrincipal passthroughPrincipal, string userName, UserPasswordInformation& userPasswordInfo, AccountStatus& accountStatus);
    private static int GetLocalUserPasswordInformation(string userName, UserPasswordInformation& userPasswordInfo, AccountStatus& accountStatus);
    private static string GetPAMErrorMessage(int responseCode);
    private static string DecodeAccountName(string accountName);
    private static string EncodeAccountName(string accountName);
    private static string ValidateAccountName(string accountName);
    private static string ParseDNTokens(string dn, string token, char delimiter);
    private static string PtrToString(IntPtr p);
    private static String[] PtrToStringArray(IntPtr stringArray);
    private static int CountStrings(IntPtr stringArray);
    private static String[] PtrToStringArray(int count, IntPtr stringArray);
    private static int AuthenticateUser(string userName, string password);
    private static int ChangeUserPassword(string userName, string oldPassword, string newPassword);
    private static int GetLocalUserID(string userName, UInt32& userID);
    private static int GetLocalUserName(UInt32 uid, StringBuilder userName);
    private static IntPtr GetLocalUserGecos(string userName);
    private static int GetLocalUserPasswordInformation64(string userName, UserPasswordInformation& userPasswordInfo, AccountStatus& status);
    private static int GetLocalUserPasswordInformation32(string userName, UserPasswordInformation32& userPasswordInfo, AccountStatus& status);
    private static int GetLocalUserPasswordInformationMac(string userName, Int32& lastChangeDate, Int32& maxDaysForChange, Int32& accountExpirationDate);
    private static int SetLocalUserPassword(string userName, string password, string salt);
    private static IntPtr GetPasswordHash(string password, string salt);
    private static int GetLocalUserGroupCount(string userName);
    private static int GetLocalUserGroupIDs(string userName, int groupCount, UInt32[]& groupsIDs);
    private static int GetLocalGroupID(string groupName, UInt32& groupID);
    private static int GetLocalGroupName(UInt32 uid, StringBuilder groupName);
    private static int GetLocalGroupMembers(string groupName, IntPtr& groupMembers);
    private static void FreeLocalGroupMembers(IntPtr groupMembers);
}
public static class GSF.Identity.UserAccountControl : object {
    private static string UacRegistryKey;
    private static string UacRegistryValue;
    public static bool IsUserAdmin { get; }
    public static bool IsUacEnabled { get; }
    public static bool IsCurrentProcessVirtualized { get; }
    public static bool IsCurrentProcessElevated { get; }
    public static Process CreateProcessAsAdmin(string fileName, string arguments);
    public static Process CreateProcessAsStandardUser(string fileName, string arguments);
    public static bool get_IsUserAdmin();
    public static bool get_IsUacEnabled();
    public static bool get_IsCurrentProcessVirtualized();
    public static bool get_IsCurrentProcessElevated();
    public static void DisableUac();
    public static void DisableUacAndRestartWindows();
    public static void EnableUac();
    public static void EnableUacAndRestartWindows();
    private static TOKEN_ELEVATION_TYPE GetProcessTokenElevationType();
    private static void SetUacRegistryValue(bool enabled);
    private static void RestartWindows();
}
public class GSF.Identity.UserInfo : object {
    public static bool DefaultPersistSettings;
    public static string DefaultSettingsCategory;
    internal static string SecurityExceptionFormat;
    internal static string UnknownErrorFormat;
    internal static int ACCOUNTDISABLED;
    internal static int LOCKED;
    internal static int PASSWD_CANT_CHANGE;
    internal static int DONT_EXPIRE_PASSWORD;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private IUserInfo m_userInfo;
    private string m_settingsCategory;
    private int m_userAccountControl;
    private bool m_disposed;
    internal string m_ldapPath;
    internal string m_privilegedDomain;
    internal string m_privilegedUserName;
    internal string m_privilegedPassword;
    [CompilerGeneratedAttribute]
private bool <PersistSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrincipal <PassthroughPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    private static string s_lastUserID;
    private static UserInfo s_currentUserInfo;
    public static string BuiltInGroupName;
    public static string NTAuthorityGroupName;
    public static string NTServiceGroupName;
    private bool GSF.ISupportLifecycle.Enabled { get; private set; }
    private bool GSF.ISupportLifecycle.IsDisposed { get; }
    public bool PersistSettings { get; public set; }
    public string SettingsCategory { get; public set; }
    public IPrincipal PassthroughPrincipal { get; public set; }
    public string Domain { get; internal set; }
    public string UserName { get; }
    public string LdapPath { get; }
    public string LoginID { get; }
    public string LdapID { get; }
    public bool DomainRespondsForUser { get; }
    public bool Exists { get; }
    public DateTime LastLogon { get; }
    public DateTime AccountCreationDate { get; }
    public DateTime NextPasswordChangeDate { get; }
    public int UserAccountControl { get; internal set; }
    public bool AccountIsLockedOut { get; }
    public bool AccountIsDisabled { get; }
    public bool PasswordCannotChange { get; }
    public bool PasswordDoesNotExpire { get; }
    public Ticks MaximumPasswordAge { get; }
    public String[] Groups { get; }
    public String[] LocalGroups { get; }
    public string FirstName { get; }
    public string LastName { get; }
    public string DisplayName { get; }
    public string MiddleInitial { get; }
    public string FullName { get; }
    public string Email { get; }
    public string Webpage { get; }
    public string Description { get; }
    public string Telephone { get; }
    public string Title { get; }
    public string Company { get; }
    public string Office { get; }
    public string Department { get; }
    public string City { get; }
    public string Mailbox { get; }
    public bool IsLocalAccount { get; }
    public static string CurrentUserID { get; }
    public static UserInfo CurrentUserInfo { get; }
    public static string RemoteUserID { get; }
    public static UserInfo RemoteUserInfo { get; }
    public static bool MachineIsJoinedToDomain { get; }
    public UserInfo(string loginID);
    public UserInfo(string loginID, string ldapPath);
    private static UserInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    private sealed virtual override bool GSF.ISupportLifecycle.get_Enabled();
    private sealed virtual override void GSF.ISupportLifecycle.set_Enabled(bool value);
    private sealed virtual override bool GSF.ISupportLifecycle.get_IsDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PersistSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    [CompilerGeneratedAttribute]
public IPrincipal get_PassthroughPrincipal();
    [CompilerGeneratedAttribute]
public void set_PassthroughPrincipal(IPrincipal value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
internal void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    public string get_LdapPath();
    public string get_LoginID();
    public string get_LdapID();
    public bool get_DomainRespondsForUser();
    public bool get_Exists();
    public DateTime get_LastLogon();
    public DateTime get_AccountCreationDate();
    public DateTime get_NextPasswordChangeDate();
    public int get_UserAccountControl();
    internal void set_UserAccountControl(int value);
    public bool get_AccountIsLockedOut();
    public bool get_AccountIsDisabled();
    public bool get_PasswordCannotChange();
    public bool get_PasswordDoesNotExpire();
    public Ticks get_MaximumPasswordAge();
    public String[] get_Groups();
    public String[] get_LocalGroups();
    public string get_FirstName();
    public string get_LastName();
    public string get_DisplayName();
    public string get_MiddleInitial();
    public string get_FullName();
    public string get_Email();
    public string get_Webpage();
    public string get_Description();
    public string get_Telephone();
    public string get_Title();
    public string get_Company();
    public string get_Office();
    public string get_Department();
    public string get_City();
    public string get_Mailbox();
    public bool get_IsLocalAccount();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void Initialize();
    public sealed virtual void SaveSettings();
    public sealed virtual void LoadSettings();
    public void DefinePrivilegedAccount(string domain, string username, string password);
    public WindowsImpersonationContext ImpersonatePrivilegedAccount();
    public void ChangePassword(string oldPassword, string newPassword);
    public string GetUserPropertyValue(string propertyName);
    private static String[] GetNameElements(string displayName);
    public static string get_CurrentUserID();
    public static UserInfo get_CurrentUserInfo();
    public static string get_RemoteUserID();
    public static UserInfo get_RemoteUserInfo();
    public static bool get_MachineIsJoinedToDomain();
    public static String[] GetBuiltInLocalGroups();
    public static IPrincipal AuthenticateUser(string domain, string userName, string password);
    public static IPrincipal AuthenticateUser(string domain, string userName, string password, String& errorMessage);
    public static WindowsImpersonationContext ImpersonateUser(string domain, string userName, string password);
    public static void EndImpersonation(WindowsImpersonationContext impersonatedUser);
    public static bool IsLocalDomain(string domain);
    public static bool LocalUserExists(string userName);
    public static bool CreateLocalUser(string userName, string password, string userDescription);
    public static void SetLocalUserPassword(string userName, string password);
    public static bool RemoveLocalUser(string userName);
    public static bool LocalGroupExists(string groupName);
    public static bool CreateLocalGroup(string groupName, string groupDescription);
    public static bool RemoveLocalGroup(string groupName);
    public static bool UserIsInLocalGroup(string groupName, string userName);
    public static bool AddUserToLocalGroup(string groupName, string userName);
    public static bool RemoveUserFromLocalGroup(string groupName, string userName);
    public static String[] GetLocalGroupUserList(string groupName);
    public static string UserNameToSID(string userName);
    public static string GroupNameToSID(string groupName);
    public static string SIDToAccountName(string sid);
    public static bool IsUserSID(string sid);
    public static bool IsGroupSID(string sid);
    internal static string ValidateGroupName(string groupName);
}
internal class GSF.Identity.WindowsUserInfo : object {
    private static string LogonDomainRegistryKey;
    private static string LogonDomainRegistryValue;
    private UserInfo m_parent;
    private DirectoryEntry m_userEntry;
    private bool m_domainRespondsForUser;
    private bool m_useLegacyGroupLookups;
    private bool m_disposed;
    private bool m_initialized;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocalAccount>k__BackingField;
    private static String[] s_builtInLocalGroups;
    internal static string BuiltInGroupName;
    internal static string NTAuthorityGroupName;
    internal static string NTServiceGroupName;
    private static LogPublisher Log;
    public bool DomainRespondsForUser { get; }
    public bool Exists { get; }
    public bool Enabled { get; public set; }
    public DateTime LastLogon { get; }
    public DateTime AccountCreationDate { get; }
    public DateTime NextPasswordChangeDate { get; }
    public int LocalUserAccountControl { get; }
    public Ticks MaximumPasswordAge { get; }
    public String[] Groups { get; }
    public String[] LocalGroups { get; }
    public string FullLocalUserName { get; }
    public bool IsLocalAccount { get; private set; }
    public static bool MachineIsJoinedToDomain { get; }
    public WindowsUserInfo(UserInfo parent);
    private static WindowsUserInfo();
    protected virtual override void Finalize();
    public sealed virtual bool get_DomainRespondsForUser();
    public sealed virtual bool get_Exists();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Enabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Enabled(bool value);
    public sealed virtual DateTime get_LastLogon();
    public sealed virtual DateTime get_AccountCreationDate();
    public sealed virtual DateTime get_NextPasswordChangeDate();
    public sealed virtual int get_LocalUserAccountControl();
    public sealed virtual Ticks get_MaximumPasswordAge();
    public sealed virtual String[] get_Groups();
    public sealed virtual String[] get_LocalGroups();
    public sealed virtual string get_FullLocalUserName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLocalAccount();
    [CompilerGeneratedAttribute]
private void set_IsLocalAccount(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual bool Initialize();
    private void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e);
    public sealed virtual void ChangePassword(string oldPassword, string newPassword);
    public PropertyValueCollection GetUserPropertyValueCollection(string propertyName);
    public sealed virtual string GetUserPropertyValue(string propertyName);
    private DirectorySearcher CreateDirectorySearcher();
    public static bool get_MachineIsJoinedToDomain();
    private static long ConvertToLong(object largeInteger);
    public static String[] GetBuiltInLocalGroups();
    public static IPrincipal AuthenticateUser(string domain, string userName, string password, String& errorMessage);
    public static WindowsImpersonationContext ImpersonateUser(string domain, string userName, string password);
    private static bool LocalAccountExists(DirectoryEntry localMachine, string accountName, string schemaType, bool allowActiveDirectoryAccount, DirectoryEntry& accountEntry);
    public static bool LocalUserExists(string userName);
    public static bool CreateLocalUser(string userName, string password, string userDescription);
    public static void SetLocalUserPassword(string userName, string password);
    public static bool RemoveLocalUser(string userName);
    public static bool LocalGroupExists(string groupName);
    public static bool CreateLocalGroup(string groupName, string groupDescription);
    public static bool RemoveLocalGroup(string groupName);
    public static bool UserIsInLocalGroup(string groupName, string userName);
    public static bool AddUserToLocalGroup(string groupName, string userName);
    public static bool RemoveUserFromLocalGroup(string groupName, string userName);
    public static String[] GetLocalGroupUserList(string groupName);
    public static string AccountNameToSID(string accountName);
    public static string SIDToAccountName(string sid);
    public static bool IsUserSID(string sid);
    public static bool IsGroupSID(string sid);
    private static bool IsSchemaSID(string sid, string schemaClassName);
    private static string CleanSid(string sid);
    private String[] OldGetGroups();
    private String[] OldGetLocalGroups();
    [CompilerGeneratedAttribute]
internal static string <get_Groups>g__createGroupFilter|29_0(DirectoryEntry entry);
    [CompilerGeneratedAttribute]
internal static string <get_Groups>g__getName|29_1(SearchResult searchResult);
    [CompilerGeneratedAttribute]
internal static string <.cctor>g__getGroupPrefix|50_0(string accountName);
}
public interface GSF.IMergeable`1 {
    public abstract virtual T Merge(T other);
}
public interface GSF.Immutable.IImmutableObject {
    public bool IsReadOnly { get; public set; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void set_IsReadOnly(bool value);
    public abstract virtual object CloneEditable();
    public abstract virtual object CloneReadonly();
}
public interface GSF.Immutable.IImmutableObject`1 {
    public abstract virtual T CloneEditable();
    public abstract virtual T CloneReadonly();
}
[DefaultMemberAttribute("Item")]
public class GSF.Immutable.ImmutableArray`1 : ImmutableObjectBase`1<ImmutableArray`1<T>> {
    private bool m_isISupportsReadonlyType;
    private T[] m_array;
    private Func`2<T, T> m_formatter;
    public int Count { get; }
    public T Item { get; public set; }
    public ImmutableArray`1(int size, Func`2<T, T> formatter);
    public ImmutableArray`1(IEnumerable`1<T> items, Func`2<T, T> formatter);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    public sealed virtual int get_Count();
    protected virtual void SetMembersAsReadOnly();
    protected virtual void CloneMembersAsEditable();
    public sealed virtual int IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DefaultMemberAttribute("Item")]
public class GSF.Immutable.ImmutableDictionary`2 : ImmutableObjectBase`1<ImmutableDictionary`2<TKey, TValue>> {
    private bool m_isISupportsReadonlyKeyType;
    private bool m_isISupportsReadonlyValueType;
    private Dictionary`2<TKey, TValue> m_dictionary;
    public int Count { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ImmutableDictionary`2(int capacity);
    public ImmutableDictionary`2(Dictionary`2<TKey, TValue> baseDictionary);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    protected virtual void SetMembersAsReadOnly();
    protected virtual void CloneMembersAsEditable();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public class GSF.Immutable.ImmutableList`1 : ImmutableObjectBase`1<ImmutableList`1<T>> {
    private bool m_isISupportsReadonlyType;
    private List`1<T> m_list;
    private Func`2<T, T> m_formatter;
    public int Count { get; }
    public T Item { get; public set; }
    public ImmutableList`1(Func`2<T, T> formatter);
    public ImmutableList`1(int capacity, Func`2<T, T> formatter);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    protected virtual void SetMembersAsReadOnly();
    protected virtual void CloneMembersAsEditable();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
public abstract class GSF.Immutable.ImmutableObjectAutoBase`1 : ImmutableObjectBase`1<T> {
    private static List`1<FieldInfo> s_readonlyFields;
    private static ImmutableObjectAutoBase`1();
    protected virtual void SetMembersAsReadOnly();
    protected virtual void CloneMembersAsEditable();
}
public abstract class GSF.Immutable.ImmutableObjectBase`1 : object {
    private bool m_isReadOnly;
    public bool IsReadOnly { get; public set; }
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void set_IsReadOnly(bool value);
    protected void TestForEditable();
    private void ThrowReadOnly();
    protected abstract virtual void SetMembersAsReadOnly();
    protected abstract virtual void CloneMembersAsEditable();
    public virtual T CloneEditable();
    private sealed virtual override object GSF.Immutable.IImmutableObject.CloneReadonly();
    private sealed virtual override object GSF.Immutable.IImmutableObject.CloneEditable();
    public virtual T CloneReadonly();
    public sealed virtual object Clone();
}
public class GSF.InitializationException : Exception {
    public InitializationException(string message);
    public InitializationException(string message, Exception innerException);
}
public class GSF.Int24 : ValueType {
    private static int MaxValue32;
    private static int MinValue32;
    public static int BitMask;
    private int m_value;
    public static Int24 MaxValue;
    public static Int24 MinValue;
    public Int24(Int24 value);
    public Int24(int value);
    public Int24(Byte[] value, int startIndex);
    private static Int24();
    public Byte[] GetBytes();
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Int24 value);
    public sealed virtual int CompareTo(int value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Int24 obj);
    public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Int24 Parse(string s);
    public static Int24 Parse(string s, NumberStyles style);
    public static Int24 Parse(string s, IFormatProvider provider);
    public static Int24 Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int24& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int24& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Int24 value1, Int24 value2);
    public static bool op_Equality(int value1, Int24 value2);
    public static bool op_Equality(Int24 value1, int value2);
    public static bool op_Inequality(Int24 value1, Int24 value2);
    public static bool op_Inequality(int value1, Int24 value2);
    public static bool op_Inequality(Int24 value1, int value2);
    public static bool op_LessThan(Int24 value1, Int24 value2);
    public static bool op_LessThan(int value1, Int24 value2);
    public static bool op_LessThan(Int24 value1, int value2);
    public static bool op_LessThanOrEqual(Int24 value1, Int24 value2);
    public static bool op_LessThanOrEqual(int value1, Int24 value2);
    public static bool op_LessThanOrEqual(Int24 value1, int value2);
    public static bool op_GreaterThan(Int24 value1, Int24 value2);
    public static bool op_GreaterThan(int value1, Int24 value2);
    public static bool op_GreaterThan(Int24 value1, int value2);
    public static bool op_GreaterThanOrEqual(Int24 value1, Int24 value2);
    public static bool op_GreaterThanOrEqual(int value1, Int24 value2);
    public static bool op_GreaterThanOrEqual(Int24 value1, int value2);
    public static Int24 op_Explicit(Enum value);
    public static Int24 op_Explicit(string value);
    public static Int24 op_Explicit(decimal value);
    public static Int24 op_Explicit(double value);
    public static Int24 op_Explicit(float value);
    public static Int24 op_Explicit(long value);
    public static Int24 op_Explicit(int value);
    public static short op_Explicit(Int24 value);
    public static ushort op_Explicit(Int24 value);
    public static byte op_Explicit(Int24 value);
    public static Int24 op_Implicit(byte value);
    public static Int24 op_Implicit(char value);
    public static Int24 op_Implicit(short value);
    public static int op_Implicit(Int24 value);
    public static UInt32 op_Implicit(Int24 value);
    public static long op_Implicit(Int24 value);
    public static ulong op_Implicit(Int24 value);
    public static double op_Implicit(Int24 value);
    public static float op_Implicit(Int24 value);
    public static decimal op_Implicit(Int24 value);
    public static string op_Implicit(Int24 value);
    public static bool op_True(Int24 value);
    public static bool op_False(Int24 value);
    public static Int24 op_OnesComplement(Int24 value);
    public static Int24 op_BitwiseAnd(Int24 value1, Int24 value2);
    public static int op_BitwiseAnd(int value1, Int24 value2);
    public static int op_BitwiseAnd(Int24 value1, int value2);
    public static Int24 op_BitwiseOr(Int24 value1, Int24 value2);
    public static int op_BitwiseOr(int value1, Int24 value2);
    public static int op_BitwiseOr(Int24 value1, int value2);
    public static Int24 op_ExclusiveOr(Int24 value1, Int24 value2);
    public static int op_ExclusiveOr(int value1, Int24 value2);
    public static int op_ExclusiveOr(Int24 value1, int value2);
    public static Int24 op_RightShift(Int24 value, int shifts);
    public static Int24 op_LeftShift(Int24 value, int shifts);
    public static Int24 op_Modulus(Int24 value1, Int24 value2);
    public static int op_Modulus(int value1, Int24 value2);
    public static int op_Modulus(Int24 value1, int value2);
    public static Int24 op_Addition(Int24 value1, Int24 value2);
    public static int op_Addition(int value1, Int24 value2);
    public static int op_Addition(Int24 value1, int value2);
    public static Int24 op_Subtraction(Int24 value1, Int24 value2);
    public static int op_Subtraction(int value1, Int24 value2);
    public static int op_Subtraction(Int24 value1, int value2);
    public static Int24 op_Increment(Int24 value);
    public static Int24 op_Decrement(Int24 value);
    public static Int24 op_Multiply(Int24 value1, Int24 value2);
    public static int op_Multiply(int value1, Int24 value2);
    public static int op_Multiply(Int24 value1, int value2);
    public static Int24 op_Division(Int24 value1, Int24 value2);
    public static int op_Division(int value1, Int24 value2);
    public static int op_Division(Int24 value1, int value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Int24 value1, Int24 value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(int value1, Int24 value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Int24 value1, int value2);
    public static Byte[] GetBytes(Int24 value);
    public static Int24 GetValue(Byte[] value, int startIndex);
    private static void ValidateNumericRange(int value);
    private static int ApplyBitMask(int value);
}
[DefaultMemberAttribute("Item")]
public interface GSF.Interop.IIniFile {
    public string FileName { get; public set; }
    public string Item { get; }
    unknown string Item {public set; }
    public abstract virtual string get_FileName();
    public abstract virtual void set_FileName(string value);
    public abstract virtual string get_Item(string section, string entry, string defaultValue);
    public abstract virtual void set_Item(string section, string entry, string value);
    public abstract virtual String[] GetSectionKeys(string section);
    public abstract virtual String[] GetSectionNames();
}
[DefaultMemberAttribute("Item")]
public class GSF.Interop.IniFile : object {
    private IIniFile m_iniFile;
    public string FileName { get; public set; }
    public string Item { get; }
    public string Item { get; public set; }
    public IniFile(string fileName);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_Item(string section, string entry, string defaultValue);
    public string get_Item(string section, string entry);
    public void set_Item(string section, string entry, string value);
    public string GetKeyValue(string section, string entry);
    public string GetKeyValue(string section, string entry, string defaultValue);
    public void SetKeyValue(string section, string entry, string newValue);
    public String[] GetSectionKeys(string section);
    public String[] GetSectionNames();
    internal static string RemoveComments(string keyValue);
}
[CompilerGeneratedAttribute]
internal class GSF.Interop.NamespaceDoc : object {
}
[DefaultMemberAttribute("Item")]
internal class GSF.Interop.UnixIniFile : object {
    private string m_fileName;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, string>> m_iniData;
    public string FileName { get; public set; }
    public string Item { get; }
    unknown string Item {public set; }
    public UnixIniFile(string fileName);
    public sealed virtual string get_FileName();
    public sealed virtual void set_FileName(string value);
    public sealed virtual string get_Item(string section, string entry, string defaultValue);
    public sealed virtual void set_Item(string section, string entry, string value);
    public sealed virtual String[] GetSectionKeys(string section);
    public sealed virtual String[] GetSectionNames();
    private void Load();
    private void Save();
    private ConcurrentDictionary`2<string, string> CreateNewSection(string sectionName);
}
public class GSF.Interop.VBArrayDescriptor : object {
    private List`1<DimensionDescriptor> m_arrayDimensionDescriptors;
    public int BinaryLength { get; }
    public VBArrayDescriptor(Int32[] arrayLengths, Int32[] arrayLowerBounds);
    public sealed virtual int get_BinaryLength();
    public sealed virtual int GenerateBinaryImage(Byte[] buffer, int startIndex);
    private sealed virtual override int GSF.Parsing.ISupportBinaryImage.ParseBinaryImage(Byte[] buffer, int startIndex, int length);
    public static VBArrayDescriptor ZeroBasedOneDimensionalArray(int arrayLength);
    public static VBArrayDescriptor OneBasedOneDimensionalArray(int arrayLength);
    public static VBArrayDescriptor ZeroBasedTwoDimensionalArray(int dimensionOneLength, int dimensionTwoLength);
    public static VBArrayDescriptor OneBasedTwoDimensionalArray(int dimensionOneLength, int dimensionTwoLength);
}
public static class GSF.Interop.WindowsApi : object {
    public static int LOGON32_PROVIDER_DEFAULT;
    public static int LOGON32_LOGON_INTERACTIVE;
    public static int LOGON32_LOGON_NETWORK;
    public static int SECURITY_IMPERSONATION;
    public static int ERROR_ACCESS_DENIED;
    public static int CRYPT_OID_INFO_OID_KEY;
    public static int CRYPT_OID_INFO_NAME_KEY;
    public static UInt32 CRYPT_OID_DISABLE_SEARCH_DS_FLAG;
    public static int CRYPT_INSTALL_OID_INFO_BEFORE_FLAG;
    public static string SE_SERVICE_LOGON_NAME;
    public static string SE_ASSIGNPRIMARYTOKEN_NAME;
    public static string SE_AUDIT_NAME;
    public static string SE_BACKUP_NAME;
    public static string SE_CHANGE_NOTIFY_NAME;
    public static string SE_CREATE_GLOBAL_NAME;
    public static string SE_CREATE_PAGEFILE_NAME;
    public static string SE_CREATE_PERMANENT_NAME;
    public static string SE_CREATE_SYMBOLIC_LINK_NAME;
    public static string SE_CREATE_TOKEN_NAME;
    public static string SE_DEBUG_NAME;
    public static string SE_ENABLE_DELEGATION_NAME;
    public static string SE_IMPERSONATE_NAME;
    public static string SE_INC_BASE_PRIORITY_NAME;
    public static string SE_INCREASE_QUOTA_NAME;
    public static string SE_INC_WORKING_SET_NAME;
    public static string SE_LOAD_DRIVER_NAME;
    public static string SE_LOCK_MEMORY_NAME;
    public static string SE_MACHINE_ACCOUNT_NAME;
    public static string SE_MANAGE_VOLUME_NAME;
    public static string SE_PROF_SINGLE_PROCESS_NAME;
    public static string SE_RELABEL_NAME;
    public static string SE_REMOTE_SHUTDOWN_NAME;
    public static string SE_RESTORE_NAME;
    public static string SE_SECURITY_NAME;
    public static string SE_SHUTDOWN_NAME;
    public static string SE_SYNC_AGENT_NAME;
    public static string SE_SYSTEM_ENVIRONMENT_NAME;
    public static string SE_SYSTEM_PROFILE_NAME;
    public static string SE_SYSTEMTIME_NAME;
    public static string SE_TAKE_OWNERSHIP_NAME;
    public static string SE_TCB_NAME;
    public static string SE_TIME_ZONE_NAME;
    public static string SE_TRUSTED_CREDMAN_ACCESS_NAME;
    public static string SE_UNDOCK_NAME;
    public static string SE_UNSOLICITED_INPUT_NAME;
    public static UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    public static UInt32 SE_PRIVILEGE_ENABLED;
    public static UInt32 SE_PRIVILEGE_REMOVED;
    public static UInt32 SE_PRIVILEGE_USED_FOR_ACCESS;
    public static UInt32 STANDARD_RIGHTS_REQUIRED;
    public static UInt32 STANDARD_RIGHTS_READ;
    public static UInt32 TOKEN_ASSIGN_PRIMARY;
    public static UInt32 TOKEN_DUPLICATE;
    public static UInt32 TOKEN_IMPERSONATE;
    public static UInt32 TOKEN_QUERY;
    public static UInt32 TOKEN_QUERY_SOURCE;
    public static UInt32 TOKEN_ADJUST_PRIVILEGES;
    public static UInt32 TOKEN_ADJUST_GROUPS;
    public static UInt32 TOKEN_ADJUST_DEFAULT;
    public static UInt32 TOKEN_ADJUST_SESSIONID;
    public static UInt32 TOKEN_READ;
    public static UInt32 TOKEN_ALL_ACCESS;
    public static bool InitiateSystemShutdownEx(string lpMachineName, string lpMessage, UInt32 dwTimeout, bool bForceAppsClosed, bool bRebootAfterShutdown, ShutdownReason dwReason);
    public static IntPtr GetShellWindow();
    public static UInt32 GetWindowThreadProcessId(IntPtr hWnd, UInt32& lpdwProcessId);
    public static IntPtr OpenSCManager(string lpMachineName, string lpDatabaseName, int dwDesiredAccess);
    public static IntPtr OpenService(IntPtr hSCManager, string lpServiceName, int dwDesiredAccess);
    public static IntPtr LockServiceDatabase(IntPtr hSCManager);
    public static bool ChangeServiceConfig2(IntPtr hService, int dwInfoLevel, IntPtr lpInfo);
    public static bool ChangeServiceConfig2(IntPtr hService, int dwInfoLevel, SERVICE_DESCRIPTION& lpInfo);
    public static bool ChangeServiceConfig2(IntPtr hService, int dwInfoLevel, SERVICE_FAILURE_ACTIONS_FLAG& lpInfo);
    public static bool CloseServiceHandle(IntPtr hSCObject);
    public static bool UnlockServiceDatabase(IntPtr hSCManager);
    public static bool LookupAccountName(string lpSystemName, string lpAccountName, IntPtr psid, Int32& cbsid, StringBuilder domainName, Int32& cbdomainLength, Int32& use);
    public static UInt32 LsaOpenPolicy(LSA_UNICODE_STRING& SystemName, LSA_OBJECT_ATTRIBUTES& ObjectAttributes, int DesiredAccess, IntPtr& PolicyHandle);
    public static UInt32 LsaAddAccountRights(IntPtr PolicyHandle, IntPtr AccountSid, LSA_UNICODE_STRING[] UserRights, UInt32 CountOfRights);
    public static UInt32 LsaClose(IntPtr PolicyHandle);
    public static IntPtr FreeSid(IntPtr pSid);
    public static int GetLastError();
    public static bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, UInt32& TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    public static bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, TOKEN_ELEVATION_TYPE& TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    public static bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, IntPtr& phToken);
    public static bool CreateProcessWithTokenW(IntPtr hToken, LogonFlags dwLogonFlags, string lpApplicationName, string lpCommandLine, CreationFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    public static bool DuplicateToken(IntPtr existingTokenHandle, int securityImpersonationLevel, IntPtr& duplicateTokenHandle);
    public static bool DuplicateTokenEx(IntPtr hExistingToken, UInt32 dwDesiredAccess, SECURITY_ATTRIBUTES& lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, IntPtr& phNewToken);
    public static bool DuplicateTokenEx(IntPtr hExistingToken, UInt32 dwDesiredAccess, IntPtr lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, IntPtr& phNewToken);
    public static bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGES& NewState, int BufferLength, IntPtr PreviousState, Int32& ReturnLength);
    public static bool LookupPrivilegeValue(string lpSystemName, string lpName, Int64& lpLuid);
    public static bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, IntPtr& TokenHandle);
    public static IntPtr OpenProcess(ProcessAccessTypes dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);
    public static IntPtr GetCurrentProcess();
    public static bool CloseHandle(IntPtr hndl);
    internal static void CopyMemory(IntPtr destination, IntPtr source, UInt32 length);
    public static int FormatMessage(int dwFlags, IntPtr& lpSource, int dwMessageId, int dwLanguageId, String& lpBuffer, int nSize, IntPtr& Arguments);
    public static IntPtr CryptFindOIDInfo(int dwKeyType, string pvKey, UInt32 dwGroupId);
    public static bool CryptRegisterOIDInfo(IntPtr pInfo, int dwFlags);
    public static bool CryptUnregisterOIDInfo(IntPtr pInfo);
    public static bool IsWow64Process(IntPtr hProcess, Boolean& Wow64Process);
    public static string GetErrorMessage(int errorCode);
    public static string GetLastErrorMessage();
    public static bool GlobalMemoryStatusEx(MEMORYSTATUSEX lpBuffer);
    public static void FlushFileBuffers(SafeFileHandle handle);
}
[DefaultMemberAttribute("Item")]
public class GSF.Interop.WindowsIniFile : object {
    private static int BufferSize;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; public set; }
    public string Item { get; }
    public string Item { get; public set; }
    public WindowsIniFile(string fileName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileName(string value);
    public sealed virtual string get_Item(string section, string entry, string defaultValue);
    public string get_Item(string section, string entry);
    public sealed virtual void set_Item(string section, string entry, string value);
    public sealed virtual String[] GetSectionKeys(string section);
    public sealed virtual String[] GetSectionNames();
    private static int GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, StringBuilder lpReturnedString, int nSize, string lpFileName);
    private static int WritePrivateProfileString(string lpAppName, string lpKeyName, string lpString, string lpFileName);
    private static int GetPrivateProfileSection(string lpAppName, Byte[] lpszReturnBuffer, int nSize, string lpFileName);
    private static int GetPrivateProfileSectionNames(Byte[] lpszReturnBuffer, int nSize, string lpFileName);
}
public class GSF.IO.BlockAllocatedMemoryStream : Stream {
    private static int BlockSize;
    private static int ShiftBits;
    private static int BlockMask;
    private List`1<Byte[]> m_blocks;
    private long m_length;
    private long m_position;
    private long m_capacity;
    private bool m_disposed;
    private static DynamicObjectPool`1<Byte[]> MemoryBlockPool;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BlockAllocatedMemoryStream(Byte[] buffer);
    public BlockAllocatedMemoryStream(Byte[] buffer, int startIndex, int length);
    public BlockAllocatedMemoryStream(int capacity);
    private static BlockAllocatedMemoryStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public void Clear();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int startIndex, int length);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int startIndex, int length);
    public virtual void WriteByte(byte value);
    public Byte[] ToArray();
    public void ReadFrom(Stream source, long length);
    public void WriteTo(Stream destination);
    public virtual void Flush();
    private void EnsureCapacity(long length);
    private void InitializeToPosition(long position);
}
public class GSF.IO.CachedFileStream : Stream {
    public static int DefaultBlockSize;
    public static long DefaultCacheSize;
    private int m_blockSize;
    private long m_cacheSize;
    private long m_position;
    private long m_length;
    private FileStream m_fileStream;
    private Dictionary`2<long, Block> m_blockLookup;
    private Dictionary`2<long, Block> m_dirtyBlockLookup;
    private List`1<Block> m_queue;
    private bool m_disposed;
    public int BlockSize { get; }
    public long CacheSize { get; public set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public CachedFileStream(string path, FileMode mode);
    public CachedFileStream(string path, FileMode mode, FileAccess access);
    public CachedFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public CachedFileStream(string path, FileMode mode, FileAccess access, FileShare share, int blockSize);
    public CachedFileStream(string path, FileMode mode, FileAccess access, FileShare share, int blockSize, bool useAsync);
    public CachedFileStream(string path, FileMode mode, FileAccess access, FileShare share, int blockSize, FileOptions options);
    public CachedFileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int blockSize, FileOptions options);
    public CachedFileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int blockSize, FileOptions options, FileSecurity fileSecurity);
    private CachedFileStream(int blockSize);
    public int get_BlockSize();
    public long get_CacheSize();
    public void set_CacheSize(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public void Flush(bool flushToDisk);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    private Block GetBlock(long blockIndex);
    private void PurgeCache(long cacheSize);
    private void CleanQueue();
    private void WriteToFileStream(Block block);
    private void AddRef(Block block);
    private void RemoveRef(Block block);
}
public class GSF.IO.Checksums.Adler32 : object {
    private static UInt32 AdlerMod;
    private static int MaxLoops;
    private UInt32 m_a;
    private UInt32 m_b;
    private int m_loopCount;
    public UInt32 Value { get; public set; }
    public UInt32 get_Value();
    public void set_Value(UInt32 value);
    public void Reset();
    public void Update(byte value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
    private void ApplyMod();
}
[ExtensionAttribute]
public static class GSF.IO.Checksums.ChecksumExtensions : object {
    [ExtensionAttribute]
public static UInt32 Adler32Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static ushort Crc16Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static ushort CrcCCITTChecksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static ushort ModBusCrcChecksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static UInt32 Crc32Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static byte Xor8Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static ushort Xor16Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static UInt32 Xor32Checksum(Byte[] data, int startIndex, int length);
    [ExtensionAttribute]
public static ulong Xor64Checksum(Byte[] data, int startIndex, int length);
}
public enum GSF.IO.Checksums.ChecksumType : Enum {
    public int value__;
    public static ChecksumType Crc16;
    public static ChecksumType ModBus;
}
public class GSF.IO.Checksums.Crc16 : object {
    private static ushort Crc16Seed;
    private static ushort ModBusSeed;
    private ushort crc;
    private static UInt16[] CrcTable;
    public ushort Value { get; public set; }
    public Crc16(ChecksumType checksumType);
    private static Crc16();
    public ushort get_Value();
    public void set_Value(ushort value);
    public void Reset();
    public void Reset(ChecksumType checksumType);
    public void Update(byte value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
public class GSF.IO.Checksums.Crc32 : object {
    private static UInt32 CrcSeed;
    private UInt32 crc;
    private static UInt32[] CrcTable;
    public UInt32 Value { get; public set; }
    private static Crc32();
    public UInt32 get_Value();
    public void set_Value(UInt32 value);
    public void Reset();
    public void Update(int value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
    public static UInt32 Compute(Byte[] buffer, int offset, int count);
    internal static UInt32 ComputeCrc32(UInt32 oldCrc, byte value);
}
public class GSF.IO.Checksums.CrcCCITT : object {
    private static ushort CrcSeed;
    private ushort crc;
    private static UInt16[] CrcTable;
    public ushort Value { get; public set; }
    private static CrcCCITT();
    public ushort get_Value();
    public void set_Value(ushort value);
    public void Reset();
    public void Update(byte value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
[CompilerGeneratedAttribute]
internal class GSF.IO.Checksums.NamespaceDoc : object {
}
public class GSF.IO.Checksums.Xor16 : object {
    private ushort m_checksum;
    public ushort Value { get; }
    public ushort get_Value();
    public void Reset();
    public void Update(ushort value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
public class GSF.IO.Checksums.Xor32 : object {
    private UInt32 m_checksum;
    public UInt32 Value { get; }
    public UInt32 get_Value();
    public void Reset();
    public void Update(UInt32 value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
public class GSF.IO.Checksums.Xor64 : object {
    private ulong m_checksum;
    public ulong Value { get; }
    public ulong get_Value();
    public void Reset();
    public void Update(ulong value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
public class GSF.IO.Checksums.Xor8 : object {
    private byte m_checksum;
    public byte Value { get; }
    public byte get_Value();
    public void Reset();
    public void Update(byte value);
    public void Update(Byte[] buffer);
    public void Update(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
public static class GSF.IO.Compression.CompressionExtensions : object {
    public static int BufferSize;
    public static byte CompressionVersion;
    [ExtensionAttribute]
public static Byte[] Compress(Byte[] source);
    [ExtensionAttribute]
public static Byte[] Compress(Byte[] source, CompressionStrength strength);
    [ExtensionAttribute]
public static Byte[] Compress(Byte[] source, int startIndex, int length, CompressionStrength strength);
    [ExtensionAttribute]
private static Byte[] Compress(Byte[] source, int startIndex, int length, CompressionStrength strength, int compressionDepth);
    [ExtensionAttribute]
public static MemoryStream Compress(Stream source, CompressionStrength strength);
    [ExtensionAttribute]
public static void Compress(Stream source, Stream destination, CompressionStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    [ExtensionAttribute]
public static Byte[] Decompress(Byte[] source);
    [ExtensionAttribute]
public static Byte[] Decompress(Byte[] source, int startIndex, int length);
    [ExtensionAttribute]
public static MemoryStream Decompress(Stream source);
    [ExtensionAttribute]
public static void Decompress(Stream source, Stream destination, Action`1<ProcessProgress`1<long>> progressHandler);
}
public enum GSF.IO.Compression.CompressionStrength : Enum {
    public int value__;
    public static CompressionStrength NoCompression;
    public static CompressionStrength Standard;
    public static CompressionStrength MultiPass;
}
public static class GSF.IO.Compression.FileCompressor : object {
    public static void Compress(string sourceFileName, string destinationFileName);
    public static void Compress(string sourceFileName, string destinationFileName, CompressionStrength strength);
    public static void Compress(string sourceFileName, string destinationFileName, CompressionStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    public static void Decompress(string sourceFileName, string destinationFileName);
    public static void Decompress(string sourceFileName, string destinationFileName, Action`1<ProcessProgress`1<long>> progressHandler);
}
[CompilerGeneratedAttribute]
internal class GSF.IO.Compression.NamespaceDoc : object {
}
public class GSF.IO.Compression.PatternCompressor : object {
    private Byte[] m_compressedBuffer;
    private int m_compressedBufferLength;
    private int m_maxCompressedBufferLength;
    private UInt32[] m_backBuffer;
    private int m_backBufferStart;
    private int m_backBufferLength;
    private byte m_compressionStrength;
    public Byte[] CompressedBuffer { get; public set; }
    public int CompressedBufferLength { get; }
    public int MaxCompressedBufferLength { get; public set; }
    public byte CompressionStrength { get; public set; }
    public PatternCompressor(byte compressionStrength);
    public Byte[] get_CompressedBuffer();
    public void set_CompressedBuffer(Byte[] value);
    public int get_CompressedBufferLength();
    public int get_MaxCompressedBufferLength();
    public void set_MaxCompressedBufferLength(int value);
    public byte get_CompressionStrength();
    public void set_CompressionStrength(byte value);
    public int Compress(ISupportBinaryImage value);
    public int Compress(Byte[] buffer);
    public int Compress(Byte[] buffer, int length);
    public int Compress(Byte[] buffer, int offset, int length);
    public int Compress(double value);
    public int Compress(float value);
    public int Compress(long value);
    public int Compress(ulong value);
    public int Compress(int value);
    public int Compress(UInt32 value);
    public int Compress(short value);
    public int Compress(ushort value);
    public int Compress(byte value);
    public void EmptyCompressedBuffer();
    public void Reset();
    private int Compress(Byte* pValue);
    private int InsertFirstValue(UInt32 value);
    private int InsertCompressedValue(UInt32 value);
    private void InsertIntoBackBuffer(UInt32 value);
    private byte GetDecompressionKey(UInt32 value);
    public static int CompressBuffer(Byte[] source, int startIndex, int dataLength, int bufferLength, byte compressionStrength);
}
public class GSF.IO.Compression.PatternDecompressor : object {
    private Byte[] m_dataBuffer;
    private int m_dataBufferOffset;
    private int m_dataBufferEnd;
    private UInt32[] m_backBuffer;
    private int m_backBufferStart;
    private int m_backBufferLength;
    private byte m_compressionStrength;
    public byte CompressionStrength { get; private set; }
    public int DataBufferLength { get; }
    public byte get_CompressionStrength();
    private void set_CompressionStrength(byte value);
    public int get_DataBufferLength();
    public void AugmentBuffer(Byte[] data);
    public void AugmentBuffer(Byte[] data, int dataLength);
    public void AugmentBuffer(Byte[] data, int offset, int dataLength);
    public void Decompress(Byte[] buffer);
    public void Decompress(Byte[] buffer, int length);
    public void Decompress(Byte[] buffer, int offset, int length);
    public void Decompress(Double& value);
    public void Decompress(Single& value);
    public void Decompress(Int64& value);
    public void Decompress(UInt64& value);
    public void Decompress(Int32& value);
    public void Decompress(UInt32& value);
    public void Decompress(Int16& value);
    public void Decompress(UInt16& value);
    public void Decompress(Byte& value);
    public void Reset();
    public void EmptyBuffer();
    private UInt32 DecompressValue();
    private UInt32 GetFirstValue();
    private UInt32 GetDecompressedValue();
    private void InsertIntoBackBuffer(UInt32 value);
    public static int MaximumSizeDecompressed(int compressedLength);
    public static int DecompressBuffer(Byte[] source, int startIndex, int dataLength, int bufferLength);
}
public class GSF.IO.ExportDestination : object {
    private string m_destinationFile;
    private bool m_connectToShare;
    private string m_domain;
    private string m_userName;
    private string m_password;
    [EditorAttribute("System.Windows.Forms.Design.FileNameEditor", "System.Drawing.Design.UITypeEditor")]
public string DestinationFile { get; public set; }
    public bool ConnectToShare { get; public set; }
    public string Domain { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    [BrowsableAttribute("False")]
public string Share { get; }
    [BrowsableAttribute("False")]
public string FileName { get; }
    public ExportDestination(string destinationFile, bool connectToShare, string domain, string userName, string password);
    public string get_DestinationFile();
    public void set_DestinationFile(string value);
    public bool get_ConnectToShare();
    public void set_ConnectToShare(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Share();
    public string get_FileName();
    public virtual string ToString();
}
public enum GSF.IO.FileEnumerationStrategy : Enum {
    public int value__;
    public static FileEnumerationStrategy Sequential;
    public static FileEnumerationStrategy ParallelWatchDirectories;
    public static FileEnumerationStrategy ParallelSubdirectories;
    public static FileEnumerationStrategy None;
}
public static class GSF.IO.FilePath : object {
    private static int RESOURCETYPE_DISK;
    private static string s_directorySeparatorCharPattern;
    private static string s_fileNameCharPattern;
    private static FilePath();
    public static void ConnectToNetworkShare(string sharename, string userName, string password, string domain);
    public static void DisconnectFromNetworkShare(string sharename);
    public static void DisconnectFromNetworkShare(string sharename, bool force);
    public static bool GetAvailableFreeSpace(string pathName, Int64& freeSpace, Int64& totalSize);
    public static bool InApplicationPath(string filePath);
    public static string GetCommonApplicationDataFolder();
    public static string GetApplicationDataFolder();
    public static string GetAbsolutePath(string filePath);
    public static string GetUniqueFilePath(string originalFilePath);
    public static string GetUniqueFilePathWithBinarySearch(string originalFilePath);
    public static void ResetPermissions(string path);
    public static void CopyPermissions(string sourcePath, string targetPath);
    public static void CopyDirectoryPermissions(string sourcePath, string targetPath);
    public static void CopyFilePermissions(string sourcePath, string targetPath);
    public static void ApplyInheritablePermissions(string sourcePath, string targetPath);
    public static void ApplyInheritableDirectoryPermissions(string sourcePath, string targetPath);
    public static void ApplyInheritableFilePermissions(string sourcePath, string targetPath);
    private static int WNetAddConnection2(NETRESOURCE& lpNetResource, string lpPassword, string lpUsername, int dwFlags);
    private static int WNetCancelConnection2(string lpName, int dwFlags, bool fForce);
    private static bool GetDiskFreeSpaceEx(string lpDirectoryName, UInt64& lpFreeBytesAvailable, UInt64& lpTotalNumberOfBytes, UInt64& lpTotalNumberOfFreeBytes);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    [IteratorStateMachineAttribute("GSF.IO.FilePath/<EnumerateDirectories>d__26")]
public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    [IteratorStateMachineAttribute("GSF.IO.FilePath/<EnumerateFiles>d__28")]
public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    public static DirectoryInfo[] GetDirectories(DirectoryInfo directory, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    [IteratorStateMachineAttribute("GSF.IO.FilePath/<EnumerateDirectories>d__30")]
public static IEnumerable`1<DirectoryInfo> EnumerateDirectories(DirectoryInfo directory, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    public static FileInfo[] GetFiles(DirectoryInfo directory, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    [IteratorStateMachineAttribute("GSF.IO.FilePath/<EnumerateFiles>d__32")]
public static IEnumerable`1<FileInfo> EnumerateFiles(DirectoryInfo directory, string searchPattern, SearchOption searchOption, Action`1<Exception> exceptionHandler);
    public static void ValidatePathName(string filePath);
    public static bool IsFilePatternMatch(String[] fileSpecs, string filePath, bool ignoreCase);
    public static bool IsFilePatternMatch(string fileSpec, string filePath, bool ignoreCase);
    public static bool IsValidFileName(string filePath);
    public static string GetValidFileName(string fileName, char replaceWithCharacter);
    public static string GetValidFilePath(string filePath, char replaceWithCharacter);
    public static string GetFileName(string filePath);
    public static string GetExtension(string filePath);
    public static string GetFileNameWithoutExtension(string filePath);
    public static long GetFileLength(string fileName);
    public static String[] GetFileList(string path, Action`1<Exception> exceptionHandler);
    public static string GetFilePatternRegularExpression(string fileSpec);
    public static string GetDirectoryName(string filePath);
    public static string GetLastDirectoryName(string filePath);
    public static string AddPathSuffix(string filePath);
    public static string RemovePathSuffix(string filePath);
    public static string DropPathRoot(string filePath);
    public static string TrimFileName(string filePath, int length);
    public static T GetFileLock(string fileName, Func`2<string, T> lockFunction, double secondsToWait, int retryMilliseconds);
    public static bool TryGetReadLock(string fileName);
    public static bool TryGetReadLockExclusive(string fileName);
    public static bool TryGetWriteLock(string fileName);
    public static void WaitForReadLock(string fileName);
    public static void WaitForReadLock(string fileName, double secondsToWait);
    public static void WaitForReadLockExclusive(string fileName);
    public static void WaitForReadLockExclusive(string fileName, double secondsToWait);
    public static void WaitForWriteLock(string fileName);
    public static void WaitForWriteLock(string fileName, double secondsToWait);
    public static void WaitTillExists(string fileName);
    public static void WaitTillExists(string fileName, double secondsToWait);
    [CompilerGeneratedAttribute]
internal static void <ResetPermissions>g__ResetPermissions|12_0(ObjectSecurity objectSecurity);
}
public class GSF.IO.FileProcessor : object {
    public static string DefaultFilter;
    public static string DefaultFolderExclusion;
    public static bool DefaultTrackChanges;
    public static int DefaultInternalBufferSize;
    public static FileEnumerationStrategy DefaultEnumerationStrategy;
    [CompilerGeneratedAttribute]
private EventHandler`1<FileProcessorEventArgs> Processing;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    private string m_filter;
    private string m_folderExclusion;
    private bool m_trackChanges;
    private int m_internalBufferSize;
    private FileEnumerationStrategy m_enumerationStrategy;
    private bool m_orderedEnumeration;
    private object m_trackedDirectoriesLock;
    private List`1<TrackedDirectory> m_trackedDirectories;
    private TaskSynchronizedOperation m_enumerationOperation;
    private LogicalThreadScheduler m_threadScheduler;
    private LogicalThread m_processingThread;
    private LogicalThread m_watcherThread;
    private LogicalThread m_sequentialEnumerationThread;
    private Timer m_fileWatchTimer;
    private ManagedCancellationTokenSource m_requeueTokenSource;
    private Dictionary`2<string, DateTime> m_touchedFiles;
    private int m_processedFileCount;
    private int m_skippedFileCount;
    private int m_requeuedFileCount;
    private bool m_disposed;
    public string Filter { get; public set; }
    public string FolderExclusion { get; public set; }
    public bool TrackChanges { get; public set; }
    public int InternalBufferSize { get; public set; }
    public int MaxThreadCount { get; public set; }
    public FileEnumerationStrategy EnumerationStrategy { get; public set; }
    public bool OrderedEnumeration { get; public set; }
    public IList`1<string> TrackedDirectories { get; }
    public IList`1<string> ActivelyEnumeratedPaths { get; }
    public bool IsEnumerating { get; }
    public int ProcessedFileCount { get; }
    public int SkippedFileCount { get; }
    public int RequeuedFileCount { get; }
    [CompilerGeneratedAttribute]
public void add_Processing(EventHandler`1<FileProcessorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Processing(EventHandler`1<FileProcessorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public string get_Filter();
    public void set_Filter(string value);
    public string get_FolderExclusion();
    public void set_FolderExclusion(string value);
    public bool get_TrackChanges();
    public void set_TrackChanges(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    public int get_MaxThreadCount();
    public void set_MaxThreadCount(int value);
    public FileEnumerationStrategy get_EnumerationStrategy();
    public void set_EnumerationStrategy(FileEnumerationStrategy value);
    public bool get_OrderedEnumeration();
    public void set_OrderedEnumeration(bool value);
    public IList`1<string> get_TrackedDirectories();
    public IList`1<string> get_ActivelyEnumeratedPaths();
    public bool get_IsEnumerating();
    public int get_ProcessedFileCount();
    public int get_SkippedFileCount();
    public int get_RequeuedFileCount();
    public void AddTrackedDirectory(string path);
    public void RemoveTrackedDirectory(string path);
    public void EnumerateWatchDirectories();
    public bool MatchesFilter(string filePath);
    public bool MatchesFolderExclusion(string folderPath);
    public void StopEnumeration();
    public void ClearTrackedDirectories();
    public void ResetIndexAndStatistics();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("GSF.IO.FileProcessor/<EnumerateWatchDirectoriesAsync>d__75")]
private Task EnumerateWatchDirectoriesAsync();
    private void TouchAndProcess(string filePath, DateTime lastWriteTime, bool raisedByFileWatcher);
    private void TouchAndSkip(string filePath, DateTime lastWriteTime);
    [AsyncStateMachineAttribute("GSF.IO.FileProcessor/<RunProcessLoopAsync>d__78")]
private Task RunProcessLoopAsync(string filePath, bool raisedByFileWatcher);
    private void ProcessFile(FileProcessorEventArgs args);
    private void OnProcessing(FileProcessorEventArgs args);
    private void OnError(Exception ex);
    private void Watcher_Created(object sender, FileSystemEventArgs args);
    private void Watcher_Changed(object sender, FileSystemEventArgs args);
    private void Watcher_Renamed(object sender, RenamedEventArgs args);
    private void Watcher_Deleted(object sender, FileSystemEventArgs args);
    private void Watcher_Error(object sender, ErrorEventArgs args);
    private void FileWatchTimer_Elapsed(object sender, ElapsedEventArgs elapsedEventArgs);
    [CompilerGeneratedAttribute]
private void <.ctor>b__32_0(object sender, EventArgs`1<Exception> args);
    [CompilerGeneratedAttribute]
private void <ResetIndexAndStatistics>b__73_0();
    [AsyncStateMachineAttribute("GSF.IO.FileProcessor/<<EnumerateWatchDirectoriesAsync>g__ForEach|75_4>d")]
[CompilerGeneratedAttribute]
internal static Task <EnumerateWatchDirectoriesAsync>g__ForEach|75_4(IEnumerable`1<Task> tasks);
}
public class GSF.IO.FileProcessorEventArgs : EventArgs {
    private string m_fullPath;
    private bool m_raisedByFileWatcher;
    private Func`1<int> m_retryCounter;
    private bool m_requeue;
    public string FullPath { get; }
    public bool RaisedByFileWatcher { get; }
    public int RetryCount { get; }
    public bool Requeue { get; public set; }
    public FileProcessorEventArgs(string fullPath, bool raisedByFileWatcher, Func`1<int> retryCounter);
    public string get_FullPath();
    public bool get_RaisedByFileWatcher();
    public int get_RetryCount();
    public bool get_Requeue();
    public void set_Requeue(bool value);
}
public class GSF.IO.InterprocessCache : object {
    private static int WriteEvent;
    private static int ReadEvent;
    public static int DefaultMaximumRetryAttempts;
    public static double DefaultRetryDelayInterval;
    private string m_fileName;
    private Byte[] m_fileData;
    private LongSynchronizedOperation m_loadOperation;
    private LongSynchronizedOperation m_saveOperation;
    private InterprocessReaderWriterLock m_fileLock;
    private ManualResetEventSlim m_loadIsReady;
    private ManualResetEventSlim m_saveIsReady;
    private SafeFileWatcher m_fileWatcher;
    private BitArray m_retryQueue;
    private Timer m_retryTimer;
    private long m_lastRetryTime;
    private int m_retryCount;
    private bool m_disposed;
    [CompilerGeneratedAttribute]
private bool <AutoSave>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumConcurrentLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumRetryAttempts>k__BackingField;
    public string FileName { get; public set; }
    public Byte[] FileData { get; public set; }
    public bool AutoSave { get; public set; }
    public bool ReloadOnChange { get; public set; }
    public int MaximumConcurrentLocks { get; }
    public int MaximumRetryAttempts { get; public set; }
    public double RetryDelayInterval { get; public set; }
    public InterprocessCache(int maximumConcurrentLocks);
    protected virtual override void Finalize();
    public string get_FileName();
    public void set_FileName(string value);
    public Byte[] get_FileData();
    public void set_FileData(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_AutoSave();
    [CompilerGeneratedAttribute]
public void set_AutoSave(bool value);
    public bool get_ReloadOnChange();
    public void set_ReloadOnChange(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumConcurrentLocks();
    [CompilerGeneratedAttribute]
public int get_MaximumRetryAttempts();
    [CompilerGeneratedAttribute]
public void set_MaximumRetryAttempts(int value);
    public double get_RetryDelayInterval();
    public void set_RetryDelayInterval(double value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Save();
    public virtual void Load();
    public virtual void WaitForLoad();
    public virtual void WaitForLoad(int millisecondsTimeout);
    public virtual void WaitForSave();
    public virtual void WaitForSave(int millisecondsTimeout);
    protected virtual void SaveFileData(FileStream fileStream, Byte[] fileData);
    protected virtual Byte[] LoadFileData(FileStream fileStream);
    private void SynchronizedWrite();
    private void SynchronizedRead();
    private void RetrySynchronizedEvent(Exception ex, int eventType);
    private void m_retryTimer_Elapsed(object sender, ElapsedEventArgs e);
    private void m_fileWatcher_Changed(object sender, FileSystemEventArgs e);
}
public abstract class GSF.IO.IsamDataFileBase`1 : object {
    public static string DefaultFileName;
    public static FileAccess DefaultFileAccessMode;
    public static int DefaultAutoSaveInterval;
    public static bool DefaultLoadOnOpen;
    public static bool DefaultSaveOnClose;
    public static bool DefaultReloadOnModify;
    public static bool DefaultPersistSettings;
    public static string DefaultSettingsCategory;
    [CompilerGeneratedAttribute]
private EventHandler DataLoading;
    [CompilerGeneratedAttribute]
private EventHandler DataLoaded;
    [CompilerGeneratedAttribute]
private EventHandler DataSaving;
    [CompilerGeneratedAttribute]
private EventHandler DataSaved;
    [CompilerGeneratedAttribute]
private EventHandler FileModified;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private string m_fileName;
    private FileAccess m_fileAccessMode;
    private int m_autoSaveInterval;
    private bool m_loadOnOpen;
    private bool m_saveOnClose;
    private bool m_reloadOnModify;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private List`1<T> m_fileRecords;
    private Byte[] m_recordBuffer;
    private FileStream m_fileData;
    private object m_fileDataLock;
    private ManualResetEventSlim m_loadWaitHandle;
    private ManualResetEventSlim m_saveWaitHandle;
    private Timer m_autoSaveTimer;
    private SafeFileWatcher m_fileWatcher;
    private bool m_disposed;
    private bool m_initialized;
    public string FileName { get; public set; }
    public FileAccess FileAccessMode { get; public set; }
    public int AutoSaveInterval { get; public set; }
    public bool LoadOnOpen { get; public set; }
    public bool SaveOnClose { get; public set; }
    public bool ReloadOnModify { get; public set; }
    [XmlIgnoreAttribute]
public bool PersistSettings { get; public set; }
    [XmlIgnoreAttribute]
public string SettingsCategory { get; public set; }
    [XmlIgnoreAttribute]
public bool Enabled { get; public set; }
    [XmlIgnoreAttribute]
public bool IsDisposed { get; }
    public bool IsOpen { get; }
    public bool IsCorrupt { get; }
    public long MemoryUsage { get; }
    public int RecordsOnDisk { get; }
    public int RecordsInMemory { get; }
    public string Name { get; }
    public string Status { get; }
    protected FileStream FileData { get; }
    protected object FileDataLock { get; }
    protected ManualResetEventSlim LoadWaitHandle { get; }
    protected ManualResetEventSlim SaveWaitHandle { get; }
    [CompilerGeneratedAttribute]
public void add_DataLoading(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataLoading(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DataLoaded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataLoaded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DataSaving(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataSaving(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DataSaved(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataSaved(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_FileModified(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FileModified(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    public FileAccess get_FileAccessMode();
    public void set_FileAccessMode(FileAccess value);
    public int get_AutoSaveInterval();
    public void set_AutoSaveInterval(int value);
    public bool get_LoadOnOpen();
    public void set_LoadOnOpen(bool value);
    public bool get_SaveOnClose();
    public void set_SaveOnClose(bool value);
    public bool get_ReloadOnModify();
    public void set_ReloadOnModify(bool value);
    public sealed virtual bool get_PersistSettings();
    public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public bool get_IsOpen();
    public virtual bool get_IsCorrupt();
    public long get_MemoryUsage();
    public virtual int get_RecordsOnDisk();
    public virtual int get_RecordsInMemory();
    public sealed virtual string get_Name();
    public virtual string get_Status();
    protected FileStream get_FileData();
    protected object get_FileDataLock();
    protected ManualResetEventSlim get_LoadWaitHandle();
    protected ManualResetEventSlim get_SaveWaitHandle();
    protected abstract virtual int GetRecordSize();
    protected abstract virtual T CreateNewRecord(int recordIndex);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize();
    public virtual void SaveSettings();
    public virtual void LoadSettings();
    public virtual void Open();
    public virtual void Close();
    public virtual void Load();
    public virtual void Save();
    public virtual void Write(IEnumerable`1<T> records);
    public virtual void Write(int recordIndex, T record);
    public virtual IEnumerable`1<T> Read();
    public virtual T Read(int recordIndex);
    protected virtual void OnFileModified();
    protected virtual void OnDataLoading();
    protected virtual void OnDataLoaded();
    protected virtual void OnDataSaving();
    protected virtual void OnDataSaved();
    protected virtual void Dispose(bool disposing);
    private void ReOpen();
    private void WriteToDisk(IEnumerable`1<T> records);
    private void WriteToDisk(int recordIndex, T record);
    [IteratorStateMachineAttribute("GSF.IO.IsamDataFileBase`1/<ReadFromDisk>d__120")]
private IEnumerable`1<T> ReadFromDisk();
    private T ReadFromDisk(int recordIndex);
    private void m_autoSaveTimer_Elapsed(object sender, ElapsedEventArgs e);
    private void m_fileWatcher_Changed(object sender, FileSystemEventArgs e);
}
[ToolboxBitmapAttribute("GSF.IO.LogFile")]
public class GSF.IO.LogFile : Component {
    public static int MinFileSize;
    public static int MaxFileSize;
    public static string DefaultFileName;
    public static int DefaultFileSize;
    public static LogFileFullOperation DefaultFileFullOperation;
    public static bool DefaultPersistSettings;
    public static double DefaultLogFilesDuration;
    public static double DefaultFlushTimerInterval;
    public static string DefaultSettingsCategory;
    [CompilerGeneratedAttribute]
private EventHandler FileFull;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> LogException;
    private string m_fileName;
    private int m_fileSize;
    private FileStream m_fileStream;
    private object m_fileStreamLock;
    private ManualResetEvent m_operationWaitHandle;
    private ProcessQueue`1<string> m_logEntryQueue;
    private Timer m_flushTimer;
    private Encoding m_textEncoding;
    private bool m_initialized;
    private double m_flushTimerInterval;
    private Dictionary`2<DateTime, string> m_savedFilesWithTime;
    [CompilerGeneratedAttribute]
private LogFileFullOperation <FileFullOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LogFilesDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PersistSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("LogFile.txt")]
[DescriptionAttribute("Name of the LogFile, including the file extension.")]
public string FileName { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("3")]
[DescriptionAttribute("Size of the LogFile in MB.")]
public int FileSize { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DescriptionAttribute("Type of operation to be performed when the LogFile is full.")]
public LogFileFullOperation FileFullOperation { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("0")]
[DescriptionAttribute("Time duration in hours to save the log files.")]
public double LogFilesDuration { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("10")]
[DescriptionAttribute("Number of seconds of inactivity before the log file automatically flushes the file stream.")]
public double FlushTimerInterval { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether the settings of LogFile object are to be saved to the config file.")]
public bool PersistSettings { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("LogFile")]
[DescriptionAttribute("Category under which the settings of LogFile object are to be saved to the config file if the PersistSettings property is set to true.")]
public string SettingsCategory { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Encoding TextEncoding { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Enabled { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsDisposed { get; private set; }
    [BrowsableAttribute("False")]
public bool IsOpen { get; }
    [BrowsableAttribute("False")]
public string Name { get; private set; }
    [BrowsableAttribute("False")]
public string Status { get; }
    public LogFile(IContainer container);
    [CompilerGeneratedAttribute]
public void add_FileFull(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FileFull(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LogException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_LogException(EventHandler`1<EventArgs`1<Exception>> value);
    public string get_FileName();
    public void set_FileName(string value);
    public int get_FileSize();
    public void set_FileSize(int value);
    [CompilerGeneratedAttribute]
public LogFileFullOperation get_FileFullOperation();
    [CompilerGeneratedAttribute]
public void set_FileFullOperation(LogFileFullOperation value);
    [CompilerGeneratedAttribute]
public double get_LogFilesDuration();
    [CompilerGeneratedAttribute]
public void set_LogFilesDuration(double value);
    public double get_FlushTimerInterval();
    public void set_FlushTimerInterval(double value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PersistSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public virtual Encoding get_TextEncoding();
    public virtual void set_TextEncoding(Encoding value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual string get_Status();
    public sealed virtual void Initialize();
    [EditorBrowsableAttribute("1")]
public sealed virtual void BeginInit();
    [EditorBrowsableAttribute("1")]
public sealed virtual void EndInit();
    public sealed virtual void SaveSettings();
    public sealed virtual void LoadSettings();
    public void Open();
    public void Close();
    public void Close(bool flushQueuedEntries);
    public void Flush();
    public void Write(string text);
    public void WriteLine(string text);
    public void WriteTimestampedLine(string text);
    public string ReadText();
    public List`1<string> ReadLines(bool removeEmptyLines);
    protected virtual void OnFileFull();
    protected virtual void OnLogException(Exception ex);
    protected virtual void Dispose(bool disposing);
    private void ReOpen();
    private void WriteLogEntries(String[] items);
    private void FlushTimer_Elapsed(object sender, ElapsedEventArgs elapsedEventArgs);
    private void LogFile_FileFull(object sender, EventArgs e);
    private void ProcessExceptionHandler(object sender, EventArgs`1<Exception> e);
}
public enum GSF.IO.LogFileFullOperation : Enum {
    public int value__;
    public static LogFileFullOperation Truncate;
    public static LogFileFullOperation Rollover;
}
[ToolboxBitmapAttribute("GSF.IO.MultipleDestinationExporter")]
public class GSF.IO.MultipleDestinationExporter : Component {
    public static int DefaultExportTimeout;
    public static bool DefaultPersistSettings;
    public static string DefaultSettingsCategory;
    public static int DefaultMaximumRetryAttempts;
    public static int DefaultRetryDelayInterval;
    [CompilerGeneratedAttribute]
private EventHandler Initialized;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<string>> StatusMessage;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    private int m_exportTimeout;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private long m_totalExports;
    private long m_failedExportAttempts;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_fileData;
    private Encoding m_textEncoding;
    private List`1<ExportDestination> m_exportDestinations;
    private object m_exportDestinationsLock;
    private LongSynchronizedOperation m_exportOperation;
    private int m_maximumRetryAttempts;
    private int m_retryDelayInterval;
    private bool m_enabled;
    private bool m_disposed;
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("-1")]
[DescriptionAttribute("Total allowed time for each export to execute, in milliseconds. Set to -1 for no specific timeout.")]
public int ExportTimeout { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("4")]
[DescriptionAttribute("Maximum number of retries that will be attempted during an export if the export fails. Set to zero to only attempt export once.")]
public int MaximumRetryAttempts { get; public set; }
    [CategoryAttribute("Settings")]
[DefaultValueAttribute("1000")]
[DescriptionAttribute("Interval to wait, in milliseconds, before retrying an export if the export fails.")]
public int RetryDelayInterval { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("True")]
[DescriptionAttribute("Indicates whether the settings of MultipleDestinationExporter object are to be saved to the config file.")]
public bool PersistSettings { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("ExportDestinations")]
[DescriptionAttribute("Category under which the settings of MultipleDestinationExporter object are to be saved to the config file if the PersistSettings property is set to true.")]
public string SettingsCategory { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Encoding TextEncoding { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Enabled { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsDisposed { get; }
    [BrowsableAttribute("False")]
public long TotalExports { get; }
    [CategoryAttribute("Settings")]
[DesignerSerializationVisibilityAttribute("2")]
[DescriptionAttribute("Gets a list of all the defined export destinations to be used by the MultipleDestinationExporter.")]
public ReadOnlyCollection`1<ExportDestination> ExportDestinations { get; }
    [BrowsableAttribute("False")]
public string Name { get; }
    [BrowsableAttribute("False")]
public string Status { get; }
    public MultipleDestinationExporter(IContainer container);
    public MultipleDestinationExporter(string settingsCategory, int exportTimeout);
    [CompilerGeneratedAttribute]
public void add_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StatusMessage(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_StatusMessage(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    public int get_ExportTimeout();
    public void set_ExportTimeout(int value);
    public int get_MaximumRetryAttempts();
    public void set_MaximumRetryAttempts(int value);
    public int get_RetryDelayInterval();
    public void set_RetryDelayInterval(int value);
    public sealed virtual bool get_PersistSettings();
    public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public virtual Encoding get_TextEncoding();
    public virtual void set_TextEncoding(Encoding value);
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public long get_TotalExports();
    public ReadOnlyCollection`1<ExportDestination> get_ExportDestinations();
    public sealed virtual string get_Name();
    public sealed virtual string get_Status();
    protected virtual void Dispose(bool disposing);
    [EditorBrowsableAttribute("1")]
public sealed virtual void BeginInit();
    [EditorBrowsableAttribute("1")]
public sealed virtual void EndInit();
    public sealed virtual void SaveSettings();
    public sealed virtual void LoadSettings();
    public sealed virtual void Initialize();
    public void Initialize(IEnumerable`1<ExportDestination> defaultDestinations);
    private void InitializeExporter(object state);
    private void Shutdown();
    protected virtual void OnInitialized();
    protected virtual void OnStatusMessage(string status, Object[] args);
    protected virtual void OnProcessException(Exception ex);
    public void ExportData(string fileData);
    public void ExportData(Byte[] fileData);
    private void ExecuteExports();
    private void CopyFileToDestination(object state);
    private void DeleteTemporaryFile(string filename);
}
[CompilerGeneratedAttribute]
internal class GSF.IO.NamespaceDoc : object {
}
public class GSF.IO.Outage : Range`1<DateTimeOffset> {
    public Outage(Range`1<DateTimeOffset> range);
    public Outage(DateTimeOffset startTime, DateTimeOffset endTime);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Outage other);
    public virtual int GetHashCode();
    public static IEnumerable`1<Outage> MergeOverlapping(IEnumerable`1<Outage> outages);
}
public class GSF.IO.OutageLog : object {
    public static string DateTimeFormat;
    [CompilerGeneratedAttribute]
private EventHandler LogModified;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private List`1<Outage> m_outages;
    private SafeFileWatcher m_logFileWatcher;
    private string m_fileName;
    private int m_suppressFileWatcher;
    private long m_lastReadTime;
    private long m_totalReads;
    private long m_totalWrites;
    private bool m_disposed;
    public string FileName { get; public set; }
    public List`1<Outage> Outages { get; }
    public int Count { get; }
    public string Status { get; }
    public bool IsDisposed { get; }
    private SafeFileWatcher LogFileWatcher { get; private set; }
    private string GSF.IProvideStatus.Name { get; }
    [CompilerGeneratedAttribute]
public void add_LogModified(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LogModified(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public string get_FileName();
    public void set_FileName(string value);
    public List`1<Outage> get_Outages();
    public int get_Count();
    public virtual string get_Status();
    public bool get_IsDisposed();
    private SafeFileWatcher get_LogFileWatcher();
    private void set_LogFileWatcher(SafeFileWatcher value);
    private sealed virtual override string GSF.IProvideStatus.get_Name();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Initialize();
    public void Add(DateTimeOffset startTime, DateTimeOffset endTime);
    public void Add(Outage outage);
    public Outage First();
    public bool Remove(Outage outage);
    private List`1<Outage> ReadLog(StreamReader reader);
    private void WriteLog(StreamWriter writer);
    private T GetFileLock(Func`2<string, T> lockFunction);
    private void OnProcessException(Exception ex);
    private void m_logFileWatcher_Changed(object sender, FileSystemEventArgs e);
    private Outage Align(Outage outage);
    [CompilerGeneratedAttribute]
private void <m_logFileWatcher_Changed>b__48_0(object state);
}
public class GSF.IO.OutageLogProcessor : object {
    private OutageLog m_outageLog;
    private Action`1<Outage> m_processOutageFunction;
    private Func`2<Outage, bool> m_canProcessOutageFunction;
    private int m_processInterval;
    private LongSynchronizedOperation m_operation;
    private bool m_enabled;
    private bool m_disposed;
    public bool Enabled { get; public set; }
    public OutageLogProcessor(OutageLog outageLog, Action`1<Outage> processOutageFunction, Func`2<Outage, bool> canProcessOutageFunction, Action`1<Exception> processExceptionHandler, int processingInterval);
    protected virtual override void Finalize();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void outageLog_CollectionChanged(object sender, EventArgs e);
    private void ProcessNextItem();
}
public class GSF.IO.RunTimeLog : object {
    public static string DateTimeFormat;
    public static string LastStartTimeKey;
    public static string LastStopTimeKey;
    public static string LastRunningTimeKey;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ProcessException;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private Timer m_flushTimer;
    private object m_readerWriterLock;
    private string m_fileName;
    private DateTimeOffset m_startTime;
    private DateTimeOffset m_stopTime;
    private DateTimeOffset m_runningTime;
    private bool m_disposed;
    public string FileName { get; public set; }
    public DateTimeOffset StartTime { get; public set; }
    public DateTimeOffset StopTime { get; public set; }
    public DateTimeOffset RunningTime { get; public set; }
    public TimeSpan UpTime { get; }
    public bool Enabled { get; public set; }
    public bool IsDisposed { get; }
    private string GSF.IProvideStatus.Name { get; }
    public string Status { get; }
    [CompilerGeneratedAttribute]
public void add_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public string get_FileName();
    public void set_FileName(string value);
    public DateTimeOffset get_StartTime();
    public void set_StartTime(DateTimeOffset value);
    public DateTimeOffset get_StopTime();
    public void set_StopTime(DateTimeOffset value);
    public DateTimeOffset get_RunningTime();
    public void set_RunningTime(DateTimeOffset value);
    public TimeSpan get_UpTime();
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    private sealed virtual override string GSF.IProvideStatus.get_Name();
    public virtual string get_Status();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    protected void ReadLog();
    protected void WriteLog();
    protected virtual void OnProcessException(Exception ex);
    private void m_flushTimer_Elapsed(object sender, ElapsedEventArgs e);
}
[SecurityCriticalAttribute]
public class GSF.IO.SafeFileWatcher : object {
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Changed;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Created;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Deleted;
    [CompilerGeneratedAttribute]
private RenamedEventHandler Renamed;
    [CompilerGeneratedAttribute]
private ErrorEventHandler Error;
    private FileSystemWatcher m_fileSystemWatcher;
    private bool m_disposed;
    public string Path { get; public set; }
    public string Filter { get; public set; }
    public NotifyFilters NotifyFilter { get; public set; }
    public bool EnableRaisingEvents { get; public set; }
    public bool IncludeSubdirectories { get; public set; }
    public int InternalBufferSize { get; public set; }
    public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public ISite Site { get; public set; }
    public SafeFileWatcher(string path);
    public SafeFileWatcher(string path, string filter);
    [CompilerGeneratedAttribute]
public void add_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deleted(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deleted(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Renamed(RenamedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Renamed(RenamedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Error(ErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Error(ErrorEventHandler value);
    private void InitializeFileSystemWatcher();
    protected virtual override void Finalize();
    public string get_Path();
    public void set_Path(string value);
    public string get_Filter();
    public void set_Filter(string value);
    public NotifyFilters get_NotifyFilter();
    public void set_NotifyFilter(NotifyFilters value);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public bool get_IncludeSubdirectories();
    public void set_IncludeSubdirectories(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public ISite get_Site();
    public void set_Site(ISite value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
    public void BeginInit();
    public void EndInit();
    private void OnChanged(FileSystemEventArgs e);
    private void OnCreated(FileSystemEventArgs e);
    private void OnDeleted(FileSystemEventArgs e);
    private void OnRenamed(RenamedEventArgs e);
    private void OnError(ErrorEventArgs e);
    private static void OnChanged(WeakReference`1<SafeFileWatcher> reference, FileSystemEventArgs e);
    private static void OnCreated(WeakReference`1<SafeFileWatcher> reference, FileSystemEventArgs e);
    private static void OnDeleted(WeakReference`1<SafeFileWatcher> reference, FileSystemEventArgs e);
    private static void OnRenamed(WeakReference`1<SafeFileWatcher> reference, RenamedEventArgs e);
    private static void OnError(WeakReference`1<SafeFileWatcher> reference, ErrorEventArgs e);
}
[ExtensionAttribute]
public static class GSF.IO.StreamExtensions : object {
    private static int BufferSize;
    [ExtensionAttribute]
public static void CopyTo(Stream source, Stream destination, long length, Byte[] buffer);
    [ExtensionAttribute]
[ObsoleteAttribute("Since .NET 4.0, any class inheriting from Stream has a native "CopyTo" function; also, .NET 4.5 has a "CopyToAsync" method.")]
public static void CopyStream(Stream source, Stream destination);
    [ExtensionAttribute]
public static Byte[] ReadStream(Stream source);
    [ExtensionAttribute]
public static void WriteObject(Stream stream, object value);
    [ExtensionAttribute]
public static object ReadObject(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, byte value);
    [ExtensionAttribute]
public static byte ReadNextByte(Stream stream);
    [ExtensionAttribute]
public static bool ReadBoolean(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, bool value);
    [ExtensionAttribute]
public static void Write(Stream stream, sbyte value);
    [ExtensionAttribute]
public static sbyte ReadSByte(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, short value);
    [ExtensionAttribute]
public static void Write(Stream stream, ushort value);
    [ExtensionAttribute]
public static void Write(Stream stream, char value);
    [ExtensionAttribute]
public static short ReadInt16(Stream stream);
    [ExtensionAttribute]
public static ushort ReadUInt16(Stream stream);
    [ExtensionAttribute]
public static char ReadChar(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, int value);
    [ExtensionAttribute]
public static void Write(Stream stream, UInt32 value);
    [ExtensionAttribute]
public static void Write(Stream stream, float value);
    [ExtensionAttribute]
public static int ReadInt32(Stream stream);
    [ExtensionAttribute]
public static UInt32 ReadUInt32(Stream stream);
    [ExtensionAttribute]
public static float ReadSingle(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, long value);
    [ExtensionAttribute]
public static void Write(Stream stream, ulong value);
    [ExtensionAttribute]
public static void Write(Stream stream, double value);
    [ExtensionAttribute]
public static void Write(Stream stream, DateTime value);
    [ExtensionAttribute]
public static long ReadInt64(Stream stream);
    [ExtensionAttribute]
public static double ReadDouble(Stream stream);
    [ExtensionAttribute]
public static ulong ReadUInt64(Stream stream);
    [ExtensionAttribute]
public static DateTime ReadDateTime(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, decimal value);
    [ExtensionAttribute]
public static void Write(Stream stream, Guid value);
    [ExtensionAttribute]
public static decimal ReadDecimal(Stream stream);
    [ExtensionAttribute]
public static Guid ReadGuid(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, Byte[] value);
    [ExtensionAttribute]
public static void WriteWithLength(Stream stream, Byte[] value);
    [ExtensionAttribute]
public static Byte[] ReadBytes(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadBytes(Stream stream, int length);
    [ExtensionAttribute]
public static void ReadAll(Stream stream, Byte[] buffer, int position, int length);
    [ExtensionAttribute]
public static void Write(Stream stream, string value);
    [ExtensionAttribute]
public static void WriteCollection(Stream stream, ICollection`1<string> collection);
    [ExtensionAttribute]
public static void WriteCollection(Stream stream, ICollection`1<int> collection);
    [ExtensionAttribute]
public static void WriteNullable(Stream stream, string value);
    [ExtensionAttribute]
public static UInt32 Read7BitUInt32(Stream stream);
    [ExtensionAttribute]
public static string ReadString(Stream stream);
    [ExtensionAttribute]
public static string ReadNullableString(Stream stream);
    [ExtensionAttribute]
public static String[] ReadStringCollection(Stream stream);
    [ExtensionAttribute]
public static Int32[] ReadInt32Collection(Stream stream);
    private static void ThrowEOS();
}
public interface GSF.IProvideStatus {
    public string Name { get; }
    public string Status { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Status();
}
public interface GSF.ISupportLifecycle {
    public bool Enabled { get; public set; }
    public bool IsDisposed { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
    public abstract virtual void Initialize();
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual bool get_IsDisposed();
}
public interface GSF.ITrackable {
    public string PropertyName { get; }
    public object OriginalValue { get; }
    public object CurrentValue { get; }
    public abstract virtual string get_PropertyName();
    public abstract virtual object get_OriginalValue();
    public abstract virtual object get_CurrentValue();
    public abstract virtual void Revert();
    public abstract virtual void Reset();
}
public class GSF.LittleBinaryValue : BinaryValueBase`1<LittleEndianOrder> {
    public LittleBinaryValue(Byte[] buffer, int startIndex, int length);
    public LittleBinaryValue(Byte[] buffer);
    public LittleBinaryValue(TypeCode typeCode, Byte[] buffer, int startIndex, int length);
    public LittleBinaryValue(TypeCode typeCode, Byte[] buffer);
    private static LittleBinaryValue();
    public virtual string ToString();
    public LittleBinaryValue ConvertToType(TypeCode typeCode);
    public static byte op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(byte value);
    public static short op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(short value);
    public static ushort op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(ushort value);
    public static Int24 op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(Int24 value);
    public static UInt24 op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(UInt24 value);
    public static int op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(int value);
    public static UInt32 op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(UInt32 value);
    public static long op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(long value);
    public static ulong op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(ulong value);
    public static float op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(float value);
    public static double op_Implicit(LittleBinaryValue value);
    public static LittleBinaryValue op_Implicit(double value);
}
public static class GSF.LittleEndian : object {
    public static bool ToBoolean(Byte* buffer);
    public static char ToChar(Byte* buffer);
    public static double ToDouble(Byte* buffer);
    public static short ToInt16(Byte* buffer);
    public static Int24 ToInt24(Byte* buffer);
    public static int ToInt32(Byte* buffer);
    public static long ToInt64(Byte* buffer);
    public static float ToSingle(Byte* buffer);
    public static ushort ToUInt16(Byte* buffer);
    public static UInt24 ToUInt24(Byte* buffer);
    public static UInt32 ToUInt32(Byte* buffer);
    public static ulong ToUInt64(Byte* value);
    public static decimal ToDecimal(Byte* buffer);
    public static bool ToBoolean(Byte[] buffer, int startIndex);
    public static char ToChar(Byte[] buffer, int startIndex);
    public static double ToDouble(Byte[] buffer, int startIndex);
    public static short ToInt16(Byte[] buffer, int startIndex);
    public static Int24 ToInt24(Byte[] buffer, int startIndex);
    public static int ToInt32(Byte[] buffer, int startIndex);
    public static long ToInt64(Byte[] buffer, int startIndex);
    public static float ToSingle(Byte[] buffer, int startIndex);
    public static ushort ToUInt16(Byte[] buffer, int startIndex);
    public static UInt24 ToUInt24(Byte[] buffer, int startIndex);
    public static UInt32 ToUInt32(Byte[] buffer, int startIndex);
    public static ulong ToUInt64(Byte[] value, int startIndex);
    public static decimal ToDecimal(Byte[] buffer, int startIndex);
    public static Byte[] GetBytes(T value);
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(Int24 value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(float value);
    public static Byte[] GetBytes(ushort value);
    public static Byte[] GetBytes(UInt24 value);
    public static Byte[] GetBytes(UInt32 value);
    public static Byte[] GetBytes(ulong value);
    public static Byte[] GetBytes(decimal value);
    public static int CopyBytes(T value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(bool value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(char value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(double value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(short value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(Int24 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(int value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(long value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(float value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(ushort value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(UInt24 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(UInt32 value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(ulong value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(decimal value, Byte[] destinationArray, int destinationIndex);
    public static int CopyBytes(T value, Byte* destination);
    public static int CopyBytes(bool value, Byte* destination);
    public static int CopyBytes(char value, Byte* destination);
    public static int CopyBytes(double value, Byte* destination);
    public static int CopyBytes(short value, Byte* destination);
    public static int CopyBytes(Int24 value, Byte* destination);
    public static int CopyBytes(int value, Byte* destination);
    public static int CopyBytes(long value, Byte* destination);
    public static int CopyBytes(float value, Byte* destination);
    public static int CopyBytes(ushort value, Byte* destination);
    public static int CopyBytes(UInt24 value, Byte* destination);
    public static int CopyBytes(UInt32 value, Byte* destination);
    public static int CopyBytes(ulong value, Byte* destination);
    public static int CopyBytes(decimal value, Byte* destination);
}
public class GSF.LittleEndianOrder : EndianOrder {
    private static LittleEndianOrder s_endianOrder;
    public static LittleEndianOrder Default { get; }
    private static LittleEndianOrder();
    public static LittleEndianOrder get_Default();
}
[CompilerGeneratedAttribute]
internal class GSF.NamespaceDoc : object {
}
public class GSF.NativeBinaryValue : BinaryValueBase`1<NativeEndianOrder> {
    public NativeBinaryValue(Byte[] buffer, int startIndex, int length);
    public NativeBinaryValue(Byte[] buffer);
    public NativeBinaryValue(TypeCode typeCode, Byte[] buffer, int startIndex, int length);
    public NativeBinaryValue(TypeCode typeCode, Byte[] buffer);
    private static NativeBinaryValue();
    public virtual string ToString();
    public NativeBinaryValue ConvertToType(TypeCode typeCode);
    public static byte op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(byte value);
    public static short op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(short value);
    public static ushort op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(ushort value);
    public static Int24 op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(Int24 value);
    public static UInt24 op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(UInt24 value);
    public static int op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(int value);
    public static UInt32 op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(UInt32 value);
    public static long op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(long value);
    public static ulong op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(ulong value);
    public static float op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(float value);
    public static double op_Implicit(NativeBinaryValue value);
    public static NativeBinaryValue op_Implicit(double value);
}
public class GSF.NativeEndianOrder : EndianOrder {
    private static NativeEndianOrder s_endianOrder;
    public static NativeEndianOrder Default { get; }
    private static NativeEndianOrder();
    public static NativeEndianOrder get_Default();
}
public class GSF.Net.Security.CertificateGenerator : object {
    private string m_issuer;
    private String[] m_subjectNames;
    private string m_certificatePath;
    private List`1<string> m_debugLog;
    [CompilerGeneratedAttribute]
private int <ValidYears>k__BackingField;
    public string Issuer { get; public set; }
    public String[] SubjectNames { get; public set; }
    public string CertificatePath { get; public set; }
    public int ValidYears { get; public set; }
    public List`1<string> DebugLog { get; }
    public string get_Issuer();
    public void set_Issuer(string value);
    public String[] get_SubjectNames();
    public void set_SubjectNames(String[] value);
    public string get_CertificatePath();
    public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public int get_ValidYears();
    [CompilerGeneratedAttribute]
public void set_ValidYears(int value);
    public List`1<string> get_DebugLog();
    public X509Certificate2 GenerateCertificate();
    public void ExportCertificateWithPrivateKey(string exportPath, SecureString password);
    public void ImportCertificateWithPrivateKey(string importPath, SecureString password);
    private string GetCommonNameList();
    private static string GetDefaultIssuer();
    private static String[] GetDefaultSubjectNames();
    private string GetDefaultCertificatePath();
    private static void TryOpenStores(List`1<X509Store> stores, OpenFlags flags);
    private static void FindMatchingCertificates(List`1<X509Certificate2> certificates, X509Certificate2 certificate);
    private static bool CanAccessPrivateKey(X509Certificate2 certificate);
    private static void CloseStores(List`1<X509Store> stores);
}
public class GSF.Net.Security.CertificatePolicy : object {
    private SslPolicyErrors m_validPolicyErrors;
    private X509ChainStatusFlags m_validChainFlags;
    public SslPolicyErrors ValidPolicyErrors { get; public set; }
    public X509ChainStatusFlags ValidChainFlags { get; public set; }
    public SslPolicyErrors get_ValidPolicyErrors();
    public void set_ValidPolicyErrors(SslPolicyErrors value);
    public X509ChainStatusFlags get_ValidChainFlags();
    public void set_ValidChainFlags(X509ChainStatusFlags value);
}
public class GSF.Net.Security.CertificatePolicyChecker : object {
    private Dictionary`2<X509Certificate, CertificatePolicy> m_trustedCertificates;
    private CertificatePolicy m_defaultCertificatePolicy;
    private string m_reasonForFailure;
    public CertificatePolicy DefaultCertificatePolicy { get; }
    public string ReasonForFailure { get; }
    public CertificatePolicy get_DefaultCertificatePolicy();
    public sealed virtual string get_ReasonForFailure();
    public void Trust(X509Certificate certificate);
    public void Trust(X509Certificate certificate, CertificatePolicy policy);
    public void Distrust(X509Certificate certificate);
    public void DistrustAll();
    public sealed virtual bool ValidateRemoteCertificate(object sender, X509Certificate remoteCertificate, X509Chain chain, SslPolicyErrors errors);
    public X509Certificate GetTrustedCertificate(X509Certificate remoteCertificate);
}
public interface GSF.Net.Security.ICertificateChecker {
    public string ReasonForFailure { get; }
    public abstract virtual string get_ReasonForFailure();
    public abstract virtual bool ValidateRemoteCertificate(object sender, X509Certificate remoteCertificate, X509Chain chain, SslPolicyErrors errors);
}
public class GSF.Net.Security.SimpleCertificateChecker : object {
    private List`1<X509Certificate> m_trustedCertificates;
    private SslPolicyErrors m_validPolicyErrors;
    private X509ChainStatusFlags m_validChainFlags;
    private string m_reasonForFailure;
    public List`1<X509Certificate> TrustedCertificates { get; }
    public SslPolicyErrors ValidPolicyErrors { get; public set; }
    public X509ChainStatusFlags ValidChainFlags { get; public set; }
    public string ReasonForFailure { get; }
    public List`1<X509Certificate> get_TrustedCertificates();
    public SslPolicyErrors get_ValidPolicyErrors();
    public void set_ValidPolicyErrors(SslPolicyErrors value);
    public X509ChainStatusFlags get_ValidChainFlags();
    public void set_ValidChainFlags(X509ChainStatusFlags value);
    public sealed virtual string get_ReasonForFailure();
    public bool ValidateRemoteCertificate(X509Certificate remoteCertificate);
    public sealed virtual bool ValidateRemoteCertificate(object sender, X509Certificate remoteCertificate, X509Chain chain, SslPolicyErrors errors);
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <ValidateRemoteCertificate>b__16_0(X509ChainStatusFlags flags, X509ChainStatus status);
}
public class GSF.Net.Security.SimplePolicyChecker : object {
    private SslPolicyErrors m_validPolicyErrors;
    private X509ChainStatusFlags m_validChainFlags;
    private string m_reasonForFailure;
    public SslPolicyErrors ValidPolicyErrors { get; public set; }
    public X509ChainStatusFlags ValidChainFlags { get; public set; }
    public string ReasonForFailure { get; }
    public SslPolicyErrors get_ValidPolicyErrors();
    public void set_ValidPolicyErrors(SslPolicyErrors value);
    public X509ChainStatusFlags get_ValidChainFlags();
    public void set_ValidChainFlags(X509ChainStatusFlags value);
    public sealed virtual string get_ReasonForFailure();
    public sealed virtual bool ValidateRemoteCertificate(object sender, X509Certificate remoteCertificate, X509Chain chain, SslPolicyErrors errors);
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <ValidateRemoteCertificate>b__12_0(X509ChainStatusFlags flags, X509ChainStatus status);
}
public class GSF.Net.Smtp.Mail : object {
    public static string DefaultSmtpServer;
    private string m_from;
    private string m_toRecipients;
    private string m_ccRecipients;
    private string m_bccRecipients;
    private string m_subject;
    private string m_body;
    private string m_attachments;
    private bool m_isBodyHtml;
    private string m_username;
    private SecureString m_password;
    private bool m_enableSSL;
    private SmtpClient m_smtpClient;
    private bool m_disposed;
    public string From { get; public set; }
    public string ToRecipients { get; public set; }
    public string CcRecipients { get; public set; }
    public string BccRecipients { get; public set; }
    public string Subject { get; public set; }
    public string Body { get; public set; }
    public string SmtpServer { get; public set; }
    public string Attachments { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public SecureString SecurePassword { get; public set; }
    public bool EnableSSL { get; public set; }
    public SmtpClient Client { get; }
    public Mail(string from);
    public Mail(string from, string toRecipients);
    public Mail(string from, string toRecipients, string smtpServer);
    protected virtual override void Finalize();
    public string get_From();
    public void set_From(string value);
    public string get_ToRecipients();
    public void set_ToRecipients(string value);
    public string get_CcRecipients();
    public void set_CcRecipients(string value);
    public string get_BccRecipients();
    public void set_BccRecipients(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Body();
    public void set_Body(string value);
    public string get_SmtpServer();
    public void set_SmtpServer(string value);
    public string get_Attachments();
    public void set_Attachments(string value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public void set_SecurePassword(SecureString value);
    public bool get_EnableSSL();
    public void set_EnableSSL(bool value);
    public SmtpClient get_Client();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Send();
    private void ApplySecuritySettings();
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string smtpServer);
    public static void Send(string from, string toRecipients, string ccRecipients, string bccRecipients, string subject, string body, bool isBodyHtml, string smtpServer);
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string attachments, string smtpServer);
    public static void Send(string from, string toRecipients, string ccRecipients, string bccRecipients, string subject, string body, bool isBodyHtml, string attachments, string smtpServer);
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string smtpServer, string username, string password);
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string smtpServer, string username, SecureString password);
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string smtpServer, string username, string password, bool enableSSL);
    public static void Send(string from, string toRecipients, string subject, string body, bool isBodyHtml, string smtpServer, string username, SecureString password, bool enableSSL);
}
[CompilerGeneratedAttribute]
internal class GSF.Net.Smtp.NamespaceDoc : object {
}
public class GSF.NtpTimeTag : TimeTagBase {
    public static Ticks BaseTicks;
    public static Ticks AlternateBaseTicks;
    public ulong Timestamp { get; }
    public NtpTimeTag(decimal seconds);
    public NtpTimeTag(UInt32 seconds, UInt32 fraction);
    public NtpTimeTag(ulong timestamp);
    public NtpTimeTag(Ticks timestamp);
    protected NtpTimeTag(SerializationInfo info, StreamingContext context);
    private static NtpTimeTag();
    public ulong get_Timestamp();
    public static long GetBaseDateOffsetTicks(decimal seconds);
    public static long GetBaseDateOffsetTicks(Ticks timestamp);
    public static long GetBaseDateOffsetTicks(UInt32 seconds);
    public static ulong FromTicks(Ticks timestamp);
}
public class GSF.NullableWeakReference : WeakReference {
    private bool m_cleared;
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public NullableWeakReference(object target);
    public virtual bool get_IsAlive();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual void Clear();
}
public class GSF.NumericalAnalysis.AnalogFilter : object {
    private double m_gain;
    private Complex[] m_zeros;
    private Complex[] m_poles;
    public Double[] InputCoefficients { get; }
    public Double[] OutputCoefficients { get; }
    public int Order { get; }
    public AnalogFilter(Complex[] poles, Complex[] zeros, double gain);
    public Double[] get_InputCoefficients();
    public Double[] get_OutputCoefficients();
    public int get_Order();
    public DigitalFilter ContinuousToDiscrete(double fs, double fp);
    public double Filter(double value, double fs, FilterState initialState, FilterState& finalState);
    public Double[] Filter(Double[] signal, double fs);
    private Double[] PolesToPolynomial(Complex[] poles);
    private void LP2HP();
    public void Scale(double fc);
    private static AnalogFilter NormalButter(int order);
    public static AnalogFilter HPButterworth(double fc, int order);
    public static AnalogFilter LPButterworth(double fc, int order);
}
public static class GSF.NumericalAnalysis.CurveFit : object {
    public static Double[] Compute(int polynomialOrder, IEnumerable`1<Point> values);
    public static Double[] Compute(int polynomialOrder, IList`1<double> xValues, IList`1<double> yValues);
    public static void LeastSquares(Double[] zValues, Double[] xValues, Double[] yValues, Double& a, Double& b, Double& c);
}
public class GSF.NumericalAnalysis.DigitalFilter : object {
    private Double[] m_a;
    private Double[] m_b;
    private double m_gain;
    public Double[] InputCoefficients { get; }
    public Double[] OutputCoefficients { get; }
    public int Order { get; }
    public DigitalFilter(Double[] b, Double[] a);
    public DigitalFilter(Double[] b, Double[] a, double k);
    public Double[] get_InputCoefficients();
    public Double[] get_OutputCoefficients();
    public int get_Order();
    public Double[] Filter(Double[] signal);
    public double Filter(double value, FilterState initialState, FilterState& finalState);
    public Double[] FiltFilt(Double[] signal);
    [CompilerGeneratedAttribute]
private double <get_OutputCoefficients>b__6_0(double a);
}
[ExtensionAttribute]
public static class GSF.NumericalAnalysis.Euclidean : object {
    public static double Mod(double numerator, double denominator);
    public static double Wrap(double value, double minimum, double range);
    [ExtensionAttribute]
public static int GreatestCommonDenominator(IEnumerable`1<int> source);
    public static int GreatestCommonDenominator(Int32[] source);
    public static int GreatestCommonDenominator(int a, int b);
    [ExtensionAttribute]
public static long GreatestCommonDenominator(IEnumerable`1<long> source);
    public static long GreatestCommonDenominator(Int64[] source);
    public static long GreatestCommonDenominator(long a, long b);
    [ExtensionAttribute]
public static int LeastCommonMultiple(IEnumerable`1<int> source);
    public static int LeastCommonMultiple(Int32[] source);
    public static int LeastCommonMultiple(int a, int b);
    [ExtensionAttribute]
public static long LeastCommonMultiple(IEnumerable`1<long> source);
    public static long LeastCommonMultiple(Int64[] source);
    public static long LeastCommonMultiple(long a, long b);
}
public class GSF.NumericalAnalysis.FFT : object {
    [CompilerGeneratedAttribute]
private Complex[] <ComplexMagnitude>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Frequency>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FrequencyBinWidth>k__BackingField;
    public Complex[] ComplexMagnitude { get; }
    public Double[] Frequency { get; }
    public double FrequencyBinWidth { get; }
    public FFT(IReadOnlyList`1<double> data);
    [CompilerGeneratedAttribute]
public Complex[] get_ComplexMagnitude();
    [CompilerGeneratedAttribute]
public Double[] get_Frequency();
    [CompilerGeneratedAttribute]
public double get_FrequencyBinWidth();
    private static bool IsPower2(int value);
}
public class GSF.NumericalAnalysis.FilterState : object {
    [CompilerGeneratedAttribute]
private Double[] <StateValue>k__BackingField;
    public Double[] StateValue { get; public set; }
    [CompilerGeneratedAttribute]
public Double[] get_StateValue();
    [CompilerGeneratedAttribute]
public void set_StateValue(Double[] value);
}
public class GSF.NumericalAnalysis.GaussianDistribution : object {
    private Random m_random;
    private double m_mean;
    private double m_standardDeviation;
    private double m_min;
    private double m_max;
    private bool m_z1IsValid;
    private double m_z1;
    public GaussianDistribution(double mean, double standardDeviation, double min, double max);
    public double Next();
}
public class GSF.NumericalAnalysis.Interpolation.DistanceFunc : MulticastDelegate {
    public DistanceFunc(object object, IntPtr method);
    public virtual double Invoke(double x1, double y1, double x2, double y2);
    public virtual IAsyncResult BeginInvoke(double x1, double y1, double x2, double y2, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class GSF.NumericalAnalysis.Interpolation.IDWFunc : MulticastDelegate {
    public IDWFunc(object object, IntPtr method);
    public virtual double Invoke(double x, double y);
    public virtual IAsyncResult BeginInvoke(double x, double y, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class GSF.NumericalAnalysis.Interpolation.InverseDistanceWeightingFunction : object {
    private IDWFunc m_converter;
    [CompilerGeneratedAttribute]
private Double[] <XCoordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <YCoordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Power>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceFunc <DistanceFunction>k__BackingField;
    public Double[] XCoordinates { get; private set; }
    public Double[] YCoordinates { get; private set; }
    public Double[] Values { get; private set; }
    public double Power { get; private set; }
    public DistanceFunc DistanceFunction { get; private set; }
    [CompilerGeneratedAttribute]
public Double[] get_XCoordinates();
    [CompilerGeneratedAttribute]
private void set_XCoordinates(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_YCoordinates();
    [CompilerGeneratedAttribute]
private void set_YCoordinates(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(Double[] value);
    [CompilerGeneratedAttribute]
public double get_Power();
    [CompilerGeneratedAttribute]
private void set_Power(double value);
    [CompilerGeneratedAttribute]
public DistanceFunc get_DistanceFunction();
    [CompilerGeneratedAttribute]
private void set_DistanceFunction(DistanceFunc value);
    public InverseDistanceWeightingFunction SetXCoordinates(Double[] xCoordinates);
    public InverseDistanceWeightingFunction SetYCoordinates(Double[] yCoordinates);
    public InverseDistanceWeightingFunction SetValues(Double[] values);
    public InverseDistanceWeightingFunction SetPower(double power);
    public InverseDistanceWeightingFunction SetDistanceFunction(DistanceFunc distanceFunction);
    private IDWFunc GetConverter();
    public static IDWFunc op_Implicit(InverseDistanceWeightingFunction idwFunction);
    public static double DefaultDistanceFunction(double x1, double y1, double x2, double y2);
}
public class GSF.NumericalAnalysis.Interpolation.PiecewiseLinearFunction : object {
    private Func`2<double, double> m_converter;
    [CompilerGeneratedAttribute]
private Double[] <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Range>k__BackingField;
    public Double[] Domain { get; private set; }
    public Double[] Range { get; private set; }
    [CompilerGeneratedAttribute]
public Double[] get_Domain();
    [CompilerGeneratedAttribute]
private void set_Domain(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(Double[] value);
    public PiecewiseLinearFunction SetDomain(Double[] domain);
    public PiecewiseLinearFunction SetRange(Double[] range);
    private Func`2<double, double> GetConverter();
    public static Func`2<double, double> op_Implicit(PiecewiseLinearFunction func);
}
public class GSF.NumericalAnalysis.KalmanFilter : object {
    public static double DefaultProcessNoise;
    public static double DefaultMeasurementNoise;
    public static double DefaultEstimateError;
    private double Q;
    private double R;
    private double P;
    private double K;
    private double X;
    private bool m_initialized;
    public KalmanFilter(double processNoise, double measurementNoise, double estimatedError);
    public double Update(double measurement);
    public Double[] Filter(IReadOnlyList`1<double> measurements);
}
[CompilerGeneratedAttribute]
internal class GSF.NumericalAnalysis.NamespaceDoc : object {
}
[ExtensionAttribute]
public static class GSF.NumericalAnalysis.NumericalAnalysisExtensions : object {
    [ExtensionAttribute]
public static double StandardDeviation(IEnumerable`1<double> source, bool calculateForSample);
    [ExtensionAttribute]
public static double StandardDeviation(IEnumerable`1<T> source, Func`2<T, double> selector, bool calculateForSample);
    [ExtensionAttribute]
public static decimal StandardDeviation(IEnumerable`1<decimal> source, bool calculateForSample);
    [ExtensionAttribute]
public static decimal StandardDeviation(IEnumerable`1<T> source, Func`2<T, decimal> selector, bool calculateForSample);
    [ExtensionAttribute]
public static float StandardDeviation(IEnumerable`1<float> source, bool calculateForSample);
    [ExtensionAttribute]
public static float StandardDeviation(IEnumerable`1<T> source, Func`2<T, float> selector, bool calculateForSample);
}
public class GSF.NumericalAnalysis.RealTimeSlope : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<string>> Status;
    [CompilerGeneratedAttribute]
private EventHandler Recalculated;
    private int m_regressionInterval;
    private int m_pointCount;
    private List`1<double> m_xValues;
    private List`1<double> m_yValues;
    private double m_slope;
    private double m_lastSlope;
    private DateTime m_slopeRun;
    private bool m_calculating;
    public double Slope { get; }
    public Time RunTime { get; }
    public RealTimeSlope(int regressionInterval, double estimatedRefreshInterval);
    [CompilerGeneratedAttribute]
public void add_Status(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_Status(EventHandler`1<EventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public void add_Recalculated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Recalculated(EventHandler value);
    public double get_Slope();
    public Time get_RunTime();
    public void Calculate(double x, double y);
    public void Initialize(int regressionInterval, double estimatedRefreshInterval);
    private void PerformCalculation(object state);
}
public class GSF.NumericalAnalysis.SineWave : ValueType {
    public static double TwoPi;
    public double Amplitude;
    public double Frequency;
    public double Phase;
    public double Bias;
    public double CalculateY(double t);
}
public class GSF.NumericalAnalysis.Spline : object {
    [CompilerGeneratedAttribute]
private double <XValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    public double XValue { get; }
    public Double[] Coefficients { get; }
    public Spline(double xValue, Double[] coefficients);
    [CompilerGeneratedAttribute]
public double get_XValue();
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    public double CalculateY(double x);
}
public class GSF.NumericalAnalysis.SplineFit : object {
    [CompilerGeneratedAttribute]
private Spline[] <Splines>k__BackingField;
    public Spline[] Splines { get; }
    public SplineFit(Spline[] splines);
    [CompilerGeneratedAttribute]
public Spline[] get_Splines();
    public double CalculateY(double x);
    public static SplineFit ComputeCubicSplines(IList`1<double> xValues, IList`1<double> yValues);
}
public static class GSF.NumericalAnalysis.WaveFit : object {
    public static SineWave SineFit(Double[] yValues, Double[] tValues, double frequency);
}
[ExtensionAttribute]
public static class GSF.NumericExtensions : object {
    [ExtensionAttribute]
public static T NotZero(T source);
    [ExtensionAttribute]
public static T NotZero(T source, T nonZeroReturnValue);
    [ExtensionAttribute]
public static T NotEqualTo(T source, T notEqualToValue, T alternateValue);
    [ExtensionAttribute]
public static T NotLessThan(T source, T notLessThanValue);
    [ExtensionAttribute]
public static T NotLessThan(T source, T notLessThanValue, T alternateValue);
    [ExtensionAttribute]
public static T NotLessThanOrEqualTo(T source, T notLessThanOrEqualToValue, T alternateValue);
    [ExtensionAttribute]
public static T NotGreaterThan(T source, T notGreaterThanValue);
    [ExtensionAttribute]
public static T NotGreaterThan(T source, T notGreaterThanValue, T alternateValue);
    [ExtensionAttribute]
public static T NotGreaterThanOrEqualTo(T source, T notGreaterThanOrEqualToValue, T alternateValue);
    [ExtensionAttribute]
public static decimal Normalize(decimal value);
}
public class GSF.ObjectState`1 : object {
    private string m_objectName;
    private TState m_currentState;
    private TState m_previousState;
    public string ObjectName { get; public set; }
    public TState CurrentState { get; public set; }
    public TState PreviousState { get; public set; }
    public ObjectState`1(string objectName);
    public ObjectState`1(string objectName, TState currentState);
    public ObjectState`1(string objectName, TState currentState, TState previousState);
    public string get_ObjectName();
    public void set_ObjectName(string value);
    public TState get_CurrentState();
    public void set_CurrentState(TState value);
    public TState get_PreviousState();
    public void set_PreviousState(TState value);
}
public static class GSF.OptimizationOptions : object {
    private static LogPublisher Log;
    [CompilerGeneratedAttribute]
private static bool <DisableAsyncQueueInProtocolParsing>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <PreferDedicatedThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutingMethod <DefaultRoutingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <RoutingLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <RoutingBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <EnableThreadPoolMonitoring>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <EnableThreadStackDumping>k__BackingField;
    public static bool DisableAsyncQueueInProtocolParsing { get; private set; }
    public static bool PreferDedicatedThreads { get; private set; }
    public static RoutingMethod DefaultRoutingMethod { get; private set; }
    public static int RoutingLatency { get; private set; }
    public static int RoutingBatchSize { get; private set; }
    public static bool EnableThreadPoolMonitoring { get; private set; }
    public static bool EnableThreadStackDumping { get; private set; }
    private static OptimizationOptions();
    [CompilerGeneratedAttribute]
public static bool get_DisableAsyncQueueInProtocolParsing();
    [CompilerGeneratedAttribute]
private static void set_DisableAsyncQueueInProtocolParsing(bool value);
    [CompilerGeneratedAttribute]
public static bool get_PreferDedicatedThreads();
    [CompilerGeneratedAttribute]
private static void set_PreferDedicatedThreads(bool value);
    [CompilerGeneratedAttribute]
public static RoutingMethod get_DefaultRoutingMethod();
    [CompilerGeneratedAttribute]
private static void set_DefaultRoutingMethod(RoutingMethod value);
    [CompilerGeneratedAttribute]
public static int get_RoutingLatency();
    [CompilerGeneratedAttribute]
private static void set_RoutingLatency(int value);
    [CompilerGeneratedAttribute]
public static int get_RoutingBatchSize();
    [CompilerGeneratedAttribute]
private static void set_RoutingBatchSize(int value);
    [CompilerGeneratedAttribute]
public static bool get_EnableThreadPoolMonitoring();
    [CompilerGeneratedAttribute]
private static void set_EnableThreadPoolMonitoring(bool value);
    [CompilerGeneratedAttribute]
public static bool get_EnableThreadStackDumping();
    [CompilerGeneratedAttribute]
private static void set_EnableThreadStackDumping(bool value);
    private static void LoadThreadPoolMonitoring(Dictionary`2<string, string> optimizations);
    private static void LoadAsyncQueueInProtocolParsing(Dictionary`2<string, string> optimizations);
    private static void LoadPreferDedicatedThreads(Dictionary`2<string, string> optimizations);
    private static void LoadProcessorAffinity(Dictionary`2<string, string> optimizations);
    private static void LoadRoutingTable(Dictionary`2<string, string> optimizations);
}
public abstract class GSF.Parsing.BinaryImageBase : object {
    public int BinaryLength { get; }
    protected int HeaderLength { get; }
    protected int BodyLength { get; }
    protected int FooterLength { get; }
    public virtual int get_BinaryLength();
    protected virtual int get_HeaderLength();
    protected virtual int get_BodyLength();
    protected virtual int get_FooterLength();
    public virtual int ParseBinaryImage(Byte[] buffer, int startIndex, int length);
    protected virtual int ParseHeaderImage(Byte[] buffer, int startIndex, int length);
    protected virtual int ParseBodyImage(Byte[] buffer, int startIndex, int length);
    protected virtual int ParseFooterImage(Byte[] buffer, int startIndex, int length);
    public virtual int GenerateBinaryImage(Byte[] buffer, int startIndex);
    protected virtual int GenerateHeaderImage(Byte[] buffer, int startIndex);
    protected virtual int GenerateBodyImage(Byte[] buffer, int startIndex);
    protected virtual int GenerateFooterImage(Byte[] buffer, int startIndex);
}
public abstract class GSF.Parsing.BinaryImageParserBase : Stream {
    public static Byte[] DefaultProtocolSyncBytes;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Byte[]>> DataDiscarded;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> ParsingException;
    [CompilerGeneratedAttribute]
private EventHandler BufferParsed;
    protected bool StreamInitialized;
    protected Byte[] UnparsedBuffer;
    private Ticks m_startTime;
    private Ticks m_stopTime;
    private bool m_enabled;
    [CompilerGeneratedAttribute]
private Byte[] <ProtocolSyncBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalProcessedBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Enabled { get; public set; }
    public bool ProtocolUsesSyncBytes { get; }
    public Byte[] ProtocolSyncBytes { get; public set; }
    public Time RunTime { get; }
    public long TotalProcessedBuffers { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public string Status { get; }
    public string Name { get; public set; }
    [EditorBrowsableAttribute("1")]
public long Length { get; }
    [EditorBrowsableAttribute("1")]
public long Position { get; public set; }
    private static BinaryImageParserBase();
    [CompilerGeneratedAttribute]
public sealed virtual void add_DataDiscarded(EventHandler`1<EventArgs`1<Byte[]>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DataDiscarded(EventHandler`1<EventArgs`1<Byte[]>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ParsingException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ParsingException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void add_BufferParsed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BufferParsed(EventHandler value);
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public abstract virtual bool get_ProtocolUsesSyncBytes();
    [CompilerGeneratedAttribute]
public virtual Byte[] get_ProtocolSyncBytes();
    [CompilerGeneratedAttribute]
public virtual void set_ProtocolSyncBytes(Byte[] value);
    public Time get_RunTime();
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalProcessedBuffers();
    [CompilerGeneratedAttribute]
private void set_TotalProcessedBuffers(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual string get_Status();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    public virtual void Start();
    public virtual void Stop();
    public virtual void Parse(ISupportBinaryImage image);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    [EditorBrowsableAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    [EditorBrowsableAttribute("1")]
public virtual long Seek(long offset, SeekOrigin origin);
    [EditorBrowsableAttribute("1")]
public virtual void SetLength(long value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private void ParseBuffer(Byte[] buffer, int offset, int count);
    protected abstract virtual int ParseFrame(Byte[] buffer, int offset, int length);
    protected virtual void OnDataDiscarded(Byte[] buffer);
    protected virtual void OnParsingException(Exception ex);
    protected virtual void OnBufferParsed();
}
[DefaultMemberAttribute("Item")]
public class GSF.Parsing.BooleanExpression : object {
    private Dictionary`2<string, Variable> m_variables;
    private Func`1<bool> m_evaluate;
    public List`1<Variable> Variables { get; }
    public Variable Item { get; }
    public BooleanExpression(string expressionText);
    public BooleanExpression(string expressionText, IEqualityComparer`1<string> identifierComparer);
    public List`1<Variable> get_Variables();
    public Variable get_Item(string identifier);
    public bool Evaluate();
    public bool TryGetVariable(string identifier, Variable& variable);
    private Expression ParseExpression(StringBuilder builder);
    private Expression ParseSubexpression(StringBuilder builder);
    private Expression ParseIdentifier(StringBuilder builder);
    private void ShedWhitespace(StringBuilder builder);
}
public abstract class GSF.Parsing.CommonHeaderBase`1 : object {
    [CompilerGeneratedAttribute]
private TTypeIdentifier <TypeID>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public TTypeIdentifier TypeID { get; public set; }
    public object State { get; public set; }
    [CompilerGeneratedAttribute]
public virtual TTypeIdentifier get_TypeID();
    [CompilerGeneratedAttribute]
public virtual void set_TypeID(TTypeIdentifier value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_State();
    [CompilerGeneratedAttribute]
public sealed virtual void set_State(object value);
}
public abstract class GSF.Parsing.FrameImageParserBase`2 : BinaryImageParserBase {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<TOutputType>> DataParsed;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<TTypeIdentifier>> OutputTypeNotFound;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<Type, TTypeIdentifier>> DuplicateTypeHandlerEncountered;
    private Dictionary`2<TTypeIdentifier, TypeInfo<TTypeIdentifier, TOutputType>> m_outputTypes;
    private AsyncQueue`1<EventArgs`1<TOutputType>> m_outputQueue;
    private bool m_disposed;
    public int QueuedOutputs { get; }
    public bool Enabled { get; public set; }
    [BrowsableAttribute("False")]
public string Status { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_DataParsed(EventHandler`1<EventArgs`1<TOutputType>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DataParsed(EventHandler`1<EventArgs`1<TOutputType>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OutputTypeNotFound(EventHandler`1<EventArgs`1<TTypeIdentifier>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OutputTypeNotFound(EventHandler`1<EventArgs`1<TTypeIdentifier>> value);
    [CompilerGeneratedAttribute]
public void add_DuplicateTypeHandlerEncountered(EventHandler`1<EventArgs`2<Type, TTypeIdentifier>> value);
    [CompilerGeneratedAttribute]
public void remove_DuplicateTypeHandlerEncountered(EventHandler`1<EventArgs`2<Type, TTypeIdentifier>> value);
    public virtual int get_QueuedOutputs();
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public virtual string get_Status();
    protected virtual void Dispose(bool disposing);
    public virtual void Start();
    public virtual void Start(IEnumerable`1<Type> implementations);
    protected virtual int ParseFrame(Byte[] buffer, int offset, int length);
    private int ParseNextFrame(Byte[] buffer, int offset, int length);
    protected abstract virtual ICommonHeader`1<TTypeIdentifier> ParseCommonHeader(Byte[] buffer, int offset, int length);
    protected virtual void OnDataParsed(TOutputType output);
    protected virtual void PublishParsedOutput(EventArgs`1<TOutputType> outputArgs);
    protected virtual void OnOutputTypeNotFound(TTypeIdentifier id);
    protected virtual void OnDuplicateTypeHandlerEncountered(Type duplicateType, TTypeIdentifier id);
    private void m_parsedOutputQueue_ProcessException(object sender, EventArgs`1<Exception> e);
}
public interface GSF.Parsing.IBinaryImageParser {
    public bool Enabled { get; public set; }
    public long TotalProcessedBuffers { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DataDiscarded(EventHandler`1<EventArgs`1<Byte[]>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DataDiscarded(EventHandler`1<EventArgs`1<Byte[]>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ParsingException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ParsingException(EventHandler`1<EventArgs`1<Exception>> value);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual long get_TotalProcessedBuffers();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
}
public interface GSF.Parsing.ICommonHeader`1 {
    public TTypeIdentifier TypeID { get; }
    public object State { get; public set; }
    public abstract virtual TTypeIdentifier get_TypeID();
    public abstract virtual object get_State();
    public abstract virtual void set_State(object value);
}
public interface GSF.Parsing.IFrameImageParser`2 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_DataParsed(EventHandler`1<EventArgs`1<TOutputType>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DataParsed(EventHandler`1<EventArgs`1<TOutputType>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OutputTypeNotFound(EventHandler`1<EventArgs`1<TTypeIdentifier>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OutputTypeNotFound(EventHandler`1<EventArgs`1<TTypeIdentifier>> value);
}
public interface GSF.Parsing.ISupportBinaryImage {
    public int BinaryLength { get; }
    public abstract virtual int get_BinaryLength();
    public abstract virtual int ParseBinaryImage(Byte[] buffer, int startIndex, int length);
    public abstract virtual int GenerateBinaryImage(Byte[] buffer, int startIndex);
}
[ExtensionAttribute]
public static class GSF.Parsing.ISupportBinaryImageExtensions : object {
    [ExtensionAttribute]
public static Byte[] BinaryImage(ISupportBinaryImage imageSource);
    [ExtensionAttribute]
public static void CopyBinaryImageToStream(ISupportBinaryImage imageSource, Stream stream);
    [ExtensionAttribute]
public static int ParseBinaryImageFromStream(ISupportBinaryImage imageSource, Stream stream);
}
public interface GSF.Parsing.ISupportFrameImage`1 {
    public ICommonHeader`1<TTypeIdentifier> CommonHeader { get; public set; }
    public TTypeIdentifier TypeID { get; }
    public bool AllowQueuedPublication { get; }
    public abstract virtual ICommonHeader`1<TTypeIdentifier> get_CommonHeader();
    public abstract virtual void set_CommonHeader(ICommonHeader`1<TTypeIdentifier> value);
    public abstract virtual TTypeIdentifier get_TypeID();
    public abstract virtual bool get_AllowQueuedPublication();
}
public interface GSF.Parsing.ISupportSourceIdentifiableFrameImage`2 {
    public TSourceIdentifier Source { get; public set; }
    public abstract virtual TSourceIdentifier get_Source();
    public abstract virtual void set_Source(TSourceIdentifier value);
}
public abstract class GSF.Parsing.MultiSourceFrameImageParserBase`3 : FrameImageParserBase`2<TTypeIdentifier, TOutputType> {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`2<TSourceIdentifier, IList`1<TOutputType>>> SourceDataParsed;
    private AsyncDoubleBufferedQueue`1<SourceIdentifiableBuffer<TSourceIdentifier, TTypeIdentifier, TOutputType>> m_bufferQueue;
    private ConcurrentDictionary`2<TSourceIdentifier, bool> m_sourceInitialized;
    private ConcurrentDictionary`2<TSourceIdentifier, Byte[]> m_unparsedBuffers;
    private ConcurrentDictionary`2<TSourceIdentifier, List`1<TOutputType>> m_parsedSourceData;
    private TSourceIdentifier m_source;
    public int QueuedBuffers { get; }
    [CompilerGeneratedAttribute]
public void add_SourceDataParsed(EventHandler`1<EventArgs`2<TSourceIdentifier, IList`1<TOutputType>>> value);
    [CompilerGeneratedAttribute]
public void remove_SourceDataParsed(EventHandler`1<EventArgs`2<TSourceIdentifier, IList`1<TOutputType>>> value);
    public virtual int get_QueuedBuffers();
    public virtual void Start();
    public virtual void Start(IEnumerable`1<Type> implementations);
    public virtual void Parse(TSourceIdentifier source, Byte[] buffer);
    public virtual void Parse(TSourceIdentifier source, Byte[] buffer, int offset, int count);
    public virtual void Parse(TSourceIdentifier source, ISupportBinaryImage image);
    public virtual void PurgeBuffer(TSourceIdentifier source);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("MultiSourceFrameImageParserBase requires consumers call Parse overload that takes data source identifier as an argument", "True")]
public virtual void Parse(ISupportBinaryImage image);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("MultiSourceFrameImageParserBase requires consumers call Parse overload that takes data source identifier as an argument", "True")]
public virtual void Write(Byte[] buffer, int offset, int count);
    private void ParseQueuedBuffers(IList`1<SourceIdentifiableBuffer<TSourceIdentifier, TTypeIdentifier, TOutputType>> buffers);
    protected virtual void OnDataParsed(TOutputType output);
    protected virtual void OnSourceDataParsed(TSourceIdentifier source, IList`1<TOutputType> output);
    protected virtual void OnDataDiscarded(Byte[] buffer);
    private void ProcessExceptionHandler(object sender, EventArgs`1<Exception> e);
}
[CompilerGeneratedAttribute]
internal class GSF.Parsing.NamespaceDoc : object {
}
public static class GSF.Parsing.StringParser : object {
    private static char DoubleQuote;
    private static char Comma;
    private static int WorkingArraySize;
    public static string GetBetweenDelimiters(string inString, Int32& payloadIndex, char startToken, char endToken, int startIndex, bool matchCase, bool includeTokensInReturn);
    public static Int32[] IndicesOfToken(string inString, char token, int startIndex, bool matchCase);
    public static Int32[] IndicesOfToken(string inString, string token, int startIndex, bool matchCase);
    public static Int32[] IndicesOfTokens(string inString, Char[] tokens, int startIndex, bool matchCase);
    public static int IndexOfNextToken(string inString, char token, int startIndex, int occurrenceCount, bool matchCase);
    public static int IndexOfNextToken(string inString, string token, int startIndex, int occurrenceCount, bool matchCase);
    public static int IndexOfNextTokens(string inString, Char[] tokens, int startIndex, bool matchCase);
    public static int IndexOfPreviousToken(string inString, char token, int startIndex, int occurrenceCount, bool matchCase);
    public static int IndexOfPreviousToken(string inString, string token, int startIndex, int occurrenceCount, bool matchCase);
    public static int IndexOfMatchingCloseToken(string inString, string openToken, string closeToken, int startIndex, bool matchCase);
    public static int IndexOfMatchingCloseToken(string inString, char openToken, char closeToken, int startIndex, bool matchCase);
    public static String[] ParseStandardCSV(string inString, int startIndex, bool removeResultQuotes);
    public static String[] ParseLine(string inString, Char[] quoteChars, Char[] delimiters, int startIndex, bool removeResultQuotes);
    public static bool ParseCheck(String[] parsedStrings, TypeCode[] expectedTypeCodes, Object[]& values);
    public static bool ExpectedFieldNamesMatch(String[] expectedFieldNames, String[] actualFieldNames, bool matchCase, int length, int startIndex);
    public static int FindIndex(string fieldNameValueSought, String[] fieldNames, bool matchCase, bool contains);
}
public class GSF.Parsing.TemplatedExpressionParser : object {
    private static string ExpressionParser;
    private static string EvaluationParser;
    private Regex m_expressionParser;
    private Regex m_evaluationParser;
    private String[] m_escapedReservedSymbols;
    private String[] m_encodedReservedSymbols;
    private string m_templatedExpression;
    [CompilerGeneratedAttribute]
private Char[] <ReservedSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private char <StartTokenDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <EndTokenDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <StartExpressionDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <EndExpressionDelimiter>k__BackingField;
    private static String[] s_operatorSymbols;
    public string TemplatedExpression { get; public set; }
    public Char[] ReservedSymbols { get; }
    public char StartTokenDelimiter { get; }
    public char EndTokenDelimiter { get; }
    public char StartExpressionDelimiter { get; }
    public char EndExpressionDelimiter { get; }
    public TemplatedExpressionParser(char startTokenDelimiter, char endTokenDelimiter, char startExpressionDelimiter, char endExpressionDelimiter);
    private static TemplatedExpressionParser();
    public string get_TemplatedExpression();
    public void set_TemplatedExpression(string value);
    [CompilerGeneratedAttribute]
public Char[] get_ReservedSymbols();
    [CompilerGeneratedAttribute]
public char get_StartTokenDelimiter();
    [CompilerGeneratedAttribute]
public char get_EndTokenDelimiter();
    [CompilerGeneratedAttribute]
public char get_StartExpressionDelimiter();
    [CompilerGeneratedAttribute]
public char get_EndExpressionDelimiter();
    public string Execute(IDictionary`2<string, string> substitutions, bool ignoreCase, bool evaluateExpressions, bool escapeSubstitutionValues);
    private string EncodeEscapedReservedSymbols(string value);
    private string EscapeAndEncodeReservedSymbols(string value);
    private string DecodeReservedSymbols(string value);
    private List`1<Tuple`3<string, bool, string>> ParseExpressions(string fieldReplacedTemplatedExpression, bool ignoreCase);
    private CodeBinaryOperatorExpression ParseBinaryOperatorExpression(string expression, TypeCode& expressionType);
    private List`1<Tuple`2<string, string>> ParseEvaluations(string fieldReplacedTemplatedExpression);
}
public class GSF.PrecisionTimer : object {
    [CompilerGeneratedAttribute]
private EventHandler Started;
    [CompilerGeneratedAttribute]
private EventHandler Stopped;
    [CompilerGeneratedAttribute]
private EventHandler Tick;
    private Timer m_timer;
    private int m_timerID;
    private TimerProc m_timeProc;
    private TimerMode m_mode;
    private int m_period;
    private int m_resolution;
    private bool m_running;
    private bool m_disposed;
    private EventArgs m_eventArgs;
    private static TimerCapabilities s_capabilities;
    public int Period { get; public set; }
    public int Resolution { get; public set; }
    public bool AutoReset { get; public set; }
    public bool IsRunning { get; }
    public EventArgs EventArgs { get; }
    public static TimerCapabilities Capabilities { get; }
    private static PrecisionTimer();
    [CompilerGeneratedAttribute]
public void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Tick(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Tick(EventHandler value);
    protected virtual override void Finalize();
    public int get_Period();
    public void set_Period(int value);
    public int get_Resolution();
    public void set_Resolution(int value);
    public bool get_AutoReset();
    public void set_AutoReset(bool value);
    public bool get_IsRunning();
    public EventArgs get_EventArgs();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Start();
    public void Start(EventArgs userArgs);
    public void Stop();
    private void m_timer_Elapsed(object sender, ElapsedEventArgs e);
    private void TimerEventCallback(int id, int msg, int user, int param1, int param2);
    public static TimerCapabilities get_Capabilities();
    public static void SetMinimumTimerResolution(int period);
    public static void ClearMinimumTimerResolution(int period);
    private static int timeGetDevCaps(TimerCapabilities& caps, int sizeOfTimerCaps);
    private static int timeSetEvent(int delay, int resolution, TimerProc proc, IntPtr user, TimerMode mode);
    private static int timeKillEvent(int id);
    private static int timeBeginPeriod(int period);
    private static int timeEndPeriod(int period);
}
public class GSF.ProcessProgress`1 : object {
    private string m_processName;
    private string m_progressMessage;
    private TUnit m_total;
    private TUnit m_complete;
    public string ProcessName { get; public set; }
    public string ProgressMessage { get; public set; }
    public TUnit Total { get; public set; }
    public TUnit Complete { get; public set; }
    public ProcessProgress`1(string processName);
    public ProcessProgress`1(string processName, string processMessage, TUnit total, TUnit complete);
    public string get_ProcessName();
    public void set_ProcessName(string value);
    public string get_ProgressMessage();
    public void set_ProgressMessage(string value);
    public TUnit get_Total();
    public void set_Total(TUnit value);
    public TUnit get_Complete();
    public void set_Complete(TUnit value);
}
public class GSF.ProcessProgressHandler`1 : object {
    private Action`1<ProcessProgress`1<TUnit>> m_progressHandler;
    private ProcessProgress`1<TUnit> m_progressInstance;
    public ProcessProgress`1<TUnit> ProcessProgress { get; }
    public Action`1<ProcessProgress`1<TUnit>> ProgressHandler { get; public set; }
    public TUnit Complete { get; public set; }
    public TUnit Total { get; public set; }
    public ProcessProgressHandler`1(Action`1<ProcessProgress`1<TUnit>> progressHandler, string processName);
    public ProcessProgressHandler`1(Action`1<ProcessProgress`1<TUnit>> progressHandler, string processName, TUnit total);
    public ProcessProgress`1<TUnit> get_ProcessProgress();
    public Action`1<ProcessProgress`1<TUnit>> get_ProgressHandler();
    public void set_ProgressHandler(Action`1<ProcessProgress`1<TUnit>> value);
    public TUnit get_Complete();
    public void set_Complete(TUnit value);
    public TUnit get_Total();
    public void set_Total(TUnit value);
    public void UpdateProgress(TUnit completed);
}
public class GSF.RadixCodec : object {
    private static string InvalidType;
    public string Digits;
    private RadixIntegerCodec`1<short> m_int16;
    private RadixIntegerCodec`1<ushort> m_uint16;
    private RadixIntegerCodec`1<Int24> m_int24;
    private RadixIntegerCodec`1<UInt24> m_uint24;
    private RadixIntegerCodec`1<int> m_int32;
    private RadixIntegerCodec`1<UInt32> m_uint32;
    private RadixIntegerCodec`1<long> m_int64;
    private RadixIntegerCodec`1<ulong> m_uint64;
    private static RadixCodec s_radix2;
    private static RadixCodec s_radix8;
    private static RadixCodec s_radix16;
    private static RadixCodec s_radix32;
    private static RadixCodec s_radix36;
    private static RadixCodec s_radix64;
    private static RadixCodec s_radix64B;
    private static RadixCodec s_radix86;
    private static RadixCodec s_radix256;
    private static RadixCodec s_radix65535;
    public int Radix { get; }
    public static RadixCodec Radix2 { get; }
    public static RadixCodec Radix8 { get; }
    public static RadixCodec Radix16 { get; }
    public static RadixCodec Radix32 { get; }
    public static RadixCodec Radix36 { get; }
    public static RadixCodec Radix64 { get; }
    public static RadixCodec Radix64B { get; }
    public static RadixCodec Radix86 { get; }
    public static RadixCodec Radix256 { get; }
    public static RadixCodec Radix65535 { get; }
    public RadixCodec(string digits, bool caseSensitive);
    public int get_Radix();
    public string Encode(short value);
    public string Encode(ushort value);
    public string Encode(Int24 value);
    public string Encode(UInt24 value);
    public string Encode(int value);
    public string Encode(UInt32 value);
    public string Encode(long value);
    public string Encode(ulong value);
    public bool TryDecode(string radixValue, Int16& value);
    public bool TryDecode(string radixValue, UInt16& value);
    public bool TryDecode(string radixValue, Int24& value);
    public bool TryDecode(string radixValue, UInt24& value);
    public bool TryDecode(string radixValue, Int32& value);
    public bool TryDecode(string radixValue, UInt32& value);
    public bool TryDecode(string radixValue, Int64& value);
    public bool TryDecode(string radixValue, UInt64& value);
    public T Decode(string radixValue);
    public object Decode(Type type, string radixValue);
    public static RadixCodec get_Radix2();
    public static RadixCodec get_Radix8();
    public static RadixCodec get_Radix16();
    public static RadixCodec get_Radix32();
    public static RadixCodec get_Radix36();
    public static RadixCodec get_Radix64();
    public static RadixCodec get_Radix64B();
    public static RadixCodec get_Radix86();
    public static RadixCodec get_Radix256();
    public static RadixCodec get_Radix65535();
    private static string GenerateRadixDigits(int length);
}
public class GSF.Range`1 : object {
    [CompilerGeneratedAttribute]
private T <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private T <End>k__BackingField;
    public T Start { get; }
    public T End { get; }
    public Range`1(T start, T end);
    [CompilerGeneratedAttribute]
public T get_Start();
    [CompilerGeneratedAttribute]
public T get_End();
    public bool Contains(T value);
    public bool Contains(T value, IComparer`1<T> comparer);
    public bool Contains(T value, Comparison`1<T> comparison);
    public bool Contains(Range`1<T> range);
    public bool Contains(Range`1<T> range, IComparer`1<T> comparer);
    public bool Contains(Range`1<T> range, Comparison`1<T> comparison);
    public bool Overlaps(Range`1<T> range);
    public bool Overlaps(Range`1<T> range, IComparer`1<T> comparer);
    public bool Overlaps(Range`1<T> range, Comparison`1<T> comparison);
    public Range`1<T> Merge(Range`1<T> range);
    public Range`1<T> Merge(Range`1<T> range, IComparer`1<T> comparer);
    public Range`1<T> Merge(Range`1<T> range, Comparison`1<T> comparison);
    public static Range`1<T> Merge(IEnumerable`1<Range`1<T>> ranges);
    public static Range`1<T> Merge(IEnumerable`1<Range`1<T>> ranges, Comparer`1<T> comparer);
    public static Range`1<T> Merge(IEnumerable`1<Range`1<T>> ranges, Comparison`1<T> comparison);
    public static IEnumerable`1<Range`1<T>> MergeConsecutiveOverlapping(IEnumerable`1<Range`1<T>> ranges);
    public static IEnumerable`1<Range`1<T>> MergeConsecutiveOverlapping(IEnumerable`1<Range`1<T>> ranges, IComparer`1<T> comparer);
    [IteratorStateMachineAttribute("GSF.Range`1/<MergeConsecutiveOverlapping>d__24")]
public static IEnumerable`1<Range`1<T>> MergeConsecutiveOverlapping(IEnumerable`1<Range`1<T>> ranges, Comparison`1<T> comparison);
    public static IEnumerable`1<Range`1<T>> MergeAllOverlapping(IEnumerable`1<Range`1<T>> ranges);
    public static IEnumerable`1<Range`1<T>> MergeAllOverlapping(IEnumerable`1<Range`1<T>> ranges, Comparison`1<T> comparison);
    public static IEnumerable`1<Range`1<T>> MergeAllOverlapping(IEnumerable`1<Range`1<T>> ranges, IComparer`1<T> comparer);
}
public class GSF.Range`2 : object {
    [CompilerGeneratedAttribute]
private TRange <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private TRange <End>k__BackingField;
    [CompilerGeneratedAttribute]
private TState <State>k__BackingField;
    public TRange Start { get; }
    public TRange End { get; }
    public TState State { get; }
    public Range`2(TRange start, TRange end, TState state);
    [CompilerGeneratedAttribute]
public TRange get_Start();
    [CompilerGeneratedAttribute]
public TRange get_End();
    [CompilerGeneratedAttribute]
public TState get_State();
    public bool Contains(TRange value);
    public bool Contains(TRange value, IComparer`1<TRange> comparer);
    public bool Contains(TRange value, Comparison`1<TRange> comparison);
    public bool Contains(Range`2<TRange, TState> range);
    public bool Contains(Range`2<TRange, TState> range, IComparer`1<TRange> comparer);
    public bool Contains(Range`2<TRange, TState> range, Comparison`1<TRange> comparison);
    public bool Overlaps(Range`2<TRange, TState> range);
    public bool Overlaps(Range`2<TRange, TState> range, IComparer`1<TRange> comparer);
    public bool Overlaps(Range`2<TRange, TState> range, Comparison`1<TRange> comparison);
    public Range`2<TRange, TState> Merge(Range`2<TRange, TState> range);
    public Range`2<TRange, TState> Merge(Range`2<TRange, TState> range, IComparer`1<TRange> comparer);
    public Range`2<TRange, TState> Merge(Range`2<TRange, TState> range, Comparison`1<TRange> comparison);
    public static Range`2<TRange, TState> Merge(IEnumerable`1<Range`2<TRange, TState>> ranges);
    public static Range`2<TRange, TState> Merge(IEnumerable`1<Range`2<TRange, TState>> ranges, Comparer`1<TRange> comparer);
    public static Range`2<TRange, TState> Merge(IEnumerable`1<Range`2<TRange, TState>> ranges, Comparison`1<TRange> comparison);
    public static IEnumerable`1<Range`2<TRange, TState>> MergeConsecutiveOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges);
    public static IEnumerable`1<Range`2<TRange, TState>> MergeConsecutiveOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges, IComparer`1<TRange> comparer);
    [IteratorStateMachineAttribute("GSF.Range`2/<MergeConsecutiveOverlapping>d__27")]
public static IEnumerable`1<Range`2<TRange, TState>> MergeConsecutiveOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges, Comparison`1<TRange> comparison);
    public static IEnumerable`1<Range`2<TRange, TState>> MergeAllOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges);
    public static IEnumerable`1<Range`2<TRange, TState>> MergeAllOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges, Comparison`1<TRange> comparison);
    public static IEnumerable`1<Range`2<TRange, TState>> MergeAllOverlapping(IEnumerable`1<Range`2<TRange, TState>> ranges, IComparer`1<TRange> comparer);
}
public class GSF.Reflection.AppDomainTypeLookup : object {
    private static LogPublisher Log;
    private object m_syncRoot;
    private HashSet`1<Assembly> m_loadedAssemblies;
    private int m_assemblyVersionNumber;
    public bool HasChanged { get; }
    private static AppDomainTypeLookup();
    public bool get_HasChanged();
    public List`1<Type> FindTypes();
    private List`1<Type> LoadNewAssemblies();
    private static void FindAllModules(List`1<Type> types, Assembly assembly);
    private static void FindAllTypes(List`1<Type> newlyFoundObjects, Assembly assembly, Module module);
}
[ExtensionAttribute]
public static class GSF.Reflection.AssemblyExtensions : object {
    [ExtensionAttribute]
public static string ShortName(Assembly assemblyInstance);
    [ExtensionAttribute]
public static Stream GetEmbeddedResource(Assembly assemblyInstance, string resourceName);
    [ExtensionAttribute]
public static string Title(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Description(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Company(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Product(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Copyright(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Trademark(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Configuration(Assembly assemblyInstance);
    [ExtensionAttribute]
public static bool DelaySign(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string InformationalVersion(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string KeyFile(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string CultureName(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string SatelliteContractVersion(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string ComCompatibleVersion(Assembly assemblyInstance);
    [ExtensionAttribute]
public static bool ComVisible(Assembly assemblyInstance);
    [ExtensionAttribute]
public static bool Debuggable(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string Guid(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string TypeLibVersion(Assembly assemblyInstance);
    [ExtensionAttribute]
public static bool CLSCompliant(Assembly assemblyInstance);
    [ExtensionAttribute]
public static DateTime BuildDate(Assembly assemblyInstance);
    [ExtensionAttribute]
public static string RootNamespace(Assembly assemblyInstance);
    [ExtensionAttribute]
public static NameValueCollection GetAttributes(Assembly assemblyInstance);
    [ExtensionAttribute]
public static bool TryLoadAllReferences(Assembly assemblyInstance);
    private static bool TryLoadAllReferences(Assembly assembly, ISet`1<string> validNames);
}
public class GSF.Reflection.AssemblyInfo : object {
    private Assembly m_assemblyInstance;
    private static AssemblyInfo s_callingAssembly;
    private static AssemblyInfo s_entryAssembly;
    private static AssemblyInfo s_executingAssembly;
    private static Dictionary`2<string, Assembly> s_assemblyCache;
    private static bool s_addedResolver;
    private static Dictionary`2<string, Type> s_typeCache;
    private static AppDomainTypeLookup s_typeLookup;
    public Assembly Assembly { get; }
    public string Title { get; }
    public string Description { get; }
    public string Company { get; }
    public string Product { get; }
    public string Copyright { get; }
    public string Trademark { get; }
    public string Configuration { get; }
    public bool DelaySign { get; }
    public string InformationalVersion { get; }
    public string KeyFile { get; }
    public string CultureName { get; }
    public string SatelliteContractVersion { get; }
    public string ComCompatibleVersion { get; }
    public bool ComVisible { get; }
    public bool Debuggable { get; }
    public string Guid { get; }
    public string TypeLibVersion { get; }
    public bool CLSCompliant { get; }
    public string Location { get; }
    public string CodeBase { get; }
    public string FullName { get; }
    public string Name { get; }
    public Version Version { get; }
    public string ImageRuntimeVersion { get; }
    public bool GACLoaded { get; }
    public DateTime BuildDate { get; }
    public string RootNamespace { get; }
    public static AssemblyInfo CallingAssembly { get; }
    public static AssemblyInfo EntryAssembly { get; }
    public static AssemblyInfo ExecutingAssembly { get; }
    public AssemblyInfo(Assembly assemblyInstance);
    private static AssemblyInfo();
    public Assembly get_Assembly();
    public string get_Title();
    public string get_Description();
    public string get_Company();
    public string get_Product();
    public string get_Copyright();
    public string get_Trademark();
    public string get_Configuration();
    public bool get_DelaySign();
    public string get_InformationalVersion();
    public string get_KeyFile();
    public string get_CultureName();
    public string get_SatelliteContractVersion();
    public string get_ComCompatibleVersion();
    public bool get_ComVisible();
    public bool get_Debuggable();
    public string get_Guid();
    public string get_TypeLibVersion();
    public bool get_CLSCompliant();
    public string get_Location();
    public string get_CodeBase();
    public string get_FullName();
    public string get_Name();
    public Version get_Version();
    public string get_ImageRuntimeVersion();
    public bool get_GACLoaded();
    public DateTime get_BuildDate();
    public string get_RootNamespace();
    public NameValueCollection GetAttributes();
    public CustomAttributeData GetCustomAttribute(Type attributeType);
    public Stream GetEmbeddedResource(string resourceName);
    public static Type FindType(string typeName);
    public static AssemblyInfo get_CallingAssembly();
    public static AssemblyInfo get_EntryAssembly();
    public static AssemblyInfo get_ExecutingAssembly();
    [SecurityCriticalAttribute]
public static void LoadAssemblyFromResource(string assemblyName);
    private static Assembly ResolveAssemblyFromResource(object sender, ResolveEventArgs e);
}
public static class GSF.Reflection.AssemblyLoadedVersionNumber : object {
    private static int m_versionNumber;
    public static int VersionNumber { get; }
    private static AssemblyLoadedVersionNumber();
    public static int get_VersionNumber();
    private static void CurrentDomain_AssemblyLoad(object sender, AssemblyLoadEventArgs args);
}
[ExtensionAttribute]
public static class GSF.Reflection.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static string GetFriendlyClassName(TMemberInfo member);
    [ExtensionAttribute]
public static bool AttributeExists(TMemberInfo member);
    [ExtensionAttribute]
public static bool TryGetAttribute(TMemberInfo member, TAttribute& attribute);
    [ExtensionAttribute]
public static bool TryGetAttributes(TMemberInfo member, TAttribute[]& attributes);
    [ExtensionAttribute]
public static bool TryGetAttribute(TMemberInfo member, Type attributeType, Attribute& attribute);
    [ExtensionAttribute]
public static bool TryGetAttributes(TMemberInfo member, Type attributeType, Attribute[]& attributes);
    [ExtensionAttribute]
public static bool TryGetAttribute(TMemberInfo member, string attributeName, Attribute& attribute);
    [ExtensionAttribute]
public static bool TryGetAttributes(TMemberInfo member, string attributeName, Attribute[]& attributes);
}
[ExtensionAttribute]
public static class GSF.Reflection.MethodBaseExtensions : object {
    [ExtensionAttribute]
public static string GetFriendlyMethodName(MethodBase method);
    [ExtensionAttribute]
public static string GetFriendlyMethodNameWithClass(MethodBase method);
}
[ExtensionAttribute]
public static class GSF.Reflection.MethodInfoExtensions : object {
    private static Dictionary`2<MethodInfo, object> s_compiledCallbacks;
    private static MethodInfoExtensions();
    [ExtensionAttribute]
public static Action`1<object> CreateAction(MethodInfo method);
    [ExtensionAttribute]
public static Action`2<object, T1> CreateAction(MethodInfo method);
    [ExtensionAttribute]
public static Action`3<object, T1, T2> CreateAction(MethodInfo method);
    [ExtensionAttribute]
public static Action`4<object, T1, T2, T3> CreateAction(MethodInfo method);
    [ExtensionAttribute]
public static Func`2<object, TResult> CreateFunc(MethodInfo method);
    [ExtensionAttribute]
public static Func`3<object, T1, TResult> CreateFunc(MethodInfo method);
    [ExtensionAttribute]
public static Func`4<object, T1, T2, TResult> CreateFunc(MethodInfo method);
    [ExtensionAttribute]
public static Func`5<object, T1, T2, T3, TResult> CreateFunc(MethodInfo method);
}
[CompilerGeneratedAttribute]
internal class GSF.Reflection.NamespaceDoc : object {
}
[ObsoleteAttribute("It is not recommended to use this class because the need for pooling is rare and implementations of pooling can be dangerous.")]
public static class GSF.ReusableObjectPool : object {
    private static ConcurrentDictionary`2<Type, ConcurrentQueue`1<object>> s_objectPools;
    private static ReusableObjectPool();
    public static object TakeObject(Type type);
    public static T TakeObject(Type type);
    public static void ReturnObject(object item);
    public static void Clear(Type type);
    public static void SetPoolSize(Type type, int size);
    private static void LifecycleItem_Disposed(object sender, EventArgs e);
}
[ObsoleteAttribute("It is not recommended to use this class because the need for pooling is rare and implementations of pooling can be dangerous.")]
public class GSF.ReusableObjectPool`1 : object {
    private ConcurrentQueue`1<T> m_objectPool;
    public static ReusableObjectPool`1<T> Default;
    private static ReusableObjectPool`1();
    public T TakeObject();
    public void ReturnObject(T item);
    public void Clear();
    public void SetPoolSize(int size);
    public int GetPoolSize();
    private void LifecycleItem_Disposed(object sender, EventArgs e);
}
public enum GSF.Scheduling.DateTimePart : Enum {
    public int value__;
    public static DateTimePart Minute;
    public static DateTimePart Hour;
    public static DateTimePart Day;
    public static DateTimePart Month;
    public static DateTimePart DayOfWeek;
}
[CompilerGeneratedAttribute]
internal class GSF.Scheduling.NamespaceDoc : object {
}
public class GSF.Scheduling.Schedule : object {
    private string m_name;
    private string m_description;
    private bool m_useLocalTime;
    private SchedulePart m_minutePart;
    private SchedulePart m_hourPart;
    private SchedulePart m_dayPart;
    private SchedulePart m_monthPart;
    private SchedulePart m_dayOfWeekPart;
    private DateTime m_lastDueAt;
    private static int s_instances;
    public string Name { get; public set; }
    public string Rule { get; public set; }
    public string Description { get; public set; }
    public bool UseLocalTime { get; public set; }
    [BrowsableAttribute("False")]
public SchedulePart MinutePart { get; }
    [BrowsableAttribute("False")]
public SchedulePart HourPart { get; }
    [BrowsableAttribute("False")]
public SchedulePart DayPart { get; }
    [BrowsableAttribute("False")]
public SchedulePart MonthPart { get; }
    [BrowsableAttribute("False")]
public SchedulePart DaysOfWeekPart { get; }
    [BrowsableAttribute("False")]
public DateTime LastDueAt { get; }
    [BrowsableAttribute("False")]
public string Status { get; }
    public Schedule(string name);
    public Schedule(string name, string rule);
    public Schedule(string name, string rule, string description);
    public Schedule(string name, string rule, string description, bool useLocalTime);
    public string get_Name();
    public void set_Name(string value);
    public string get_Rule();
    public void set_Rule(string value);
    public string get_Description();
    public void set_Description(string value);
    public bool get_UseLocalTime();
    public void set_UseLocalTime(bool value);
    public SchedulePart get_MinutePart();
    public SchedulePart get_HourPart();
    public SchedulePart get_DayPart();
    public SchedulePart get_MonthPart();
    public SchedulePart get_DaysOfWeekPart();
    public DateTime get_LastDueAt();
    public string get_Status();
    public bool IsDue();
    public DateTime PreviousTimeDue(DateTime targetDateTime);
    public DateTime NextTimeDue(DateTime targetDateTime);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private DateTime ToScheduleTimeZone(DateTime dateTime);
    private static DateTime PreviousInterval(DateTime dt, TimeSpan interval);
    private static DateTime PreviousMonth(DateTime dt);
    private static DateTime PreviousDay(DateTime dt);
    private static DateTime PreviousHour(DateTime dt);
    private static DateTime PreviousMinute(DateTime dt);
    private static DateTime NextInterval(DateTime dt, TimeSpan interval);
    private static DateTime NextMonth(DateTime dt);
    private static DateTime NextDay(DateTime dt);
    private static DateTime NextHour(DateTime dt);
    private static DateTime NextMinute(DateTime dt);
    [CompilerGeneratedAttribute]
private bool <PreviousTimeDue>g__FindMatchingMonth|41_0(<>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private bool <PreviousTimeDue>g__FindMatchingDay|41_1(<>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private bool <PreviousTimeDue>g__FindMatchingHour|41_2(<>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private bool <PreviousTimeDue>g__FindMatchingMinute|41_3(<>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private bool <NextTimeDue>g__FindMatchingMonth|42_0(<>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
private bool <NextTimeDue>g__FindMatchingDay|42_1(<>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
private bool <NextTimeDue>g__FindMatchingHour|42_2(<>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
private bool <NextTimeDue>g__FindMatchingMinute|42_3(<>c__DisplayClass42_0& );
}
[ToolboxBitmapAttribute("GSF.Scheduling.ScheduleManager")]
public class GSF.Scheduling.ScheduleManager : Component {
    public static bool DefaultPersistSettings;
    public static string DefaultSettingsCategory;
    private static int TimerInterval;
    [CompilerGeneratedAttribute]
private EventHandler Starting;
    [CompilerGeneratedAttribute]
private EventHandler Started;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Schedule>> ScheduleDue;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Schedule>> ScheduleDueCheck;
    private bool m_persistSettings;
    private string m_settingsCategory;
    private List`1<Schedule> m_schedules;
    private Timer m_timer;
    private Thread m_startTimerThread;
    private bool m_disposed;
    private bool m_initialized;
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Indicates whether the settings of ScheduleManager object are to be saved to the config file.")]
public bool PersistSettings { get; public set; }
    [CategoryAttribute("Persistence")]
[DefaultValueAttribute("ScheduleManager")]
[DescriptionAttribute("Category under which the settings of ScheduleManager object are to be saved to the config file if the PersistSettings property is set to true.")]
public string SettingsCategory { get; public set; }
    [CategoryAttribute("Settings")]
[DesignerSerializationVisibilityAttribute("2")]
[DescriptionAttribute("Gets a list of all Schedule monitored by the ScheduleManager object.")]
public List`1<Schedule> Schedules { get; }
    [BrowsableAttribute("False")]
public bool IsRunning { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public bool Enabled { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsDisposed { get; }
    [BrowsableAttribute("False")]
public string Name { get; }
    [BrowsableAttribute("False")]
public string Status { get; }
    public ScheduleManager(IContainer container);
    [CompilerGeneratedAttribute]
public void add_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ScheduleDue(EventHandler`1<EventArgs`1<Schedule>> value);
    [CompilerGeneratedAttribute]
public void remove_ScheduleDue(EventHandler`1<EventArgs`1<Schedule>> value);
    [CompilerGeneratedAttribute]
public void add_ScheduleDueCheck(EventHandler`1<EventArgs`1<Schedule>> value);
    [CompilerGeneratedAttribute]
public void remove_ScheduleDueCheck(EventHandler`1<EventArgs`1<Schedule>> value);
    public sealed virtual bool get_PersistSettings();
    public sealed virtual void set_PersistSettings(bool value);
    public sealed virtual string get_SettingsCategory();
    public sealed virtual void set_SettingsCategory(string value);
    public List`1<Schedule> get_Schedules();
    public bool get_IsRunning();
    public sealed virtual bool get_Enabled();
    public sealed virtual void set_Enabled(bool value);
    public sealed virtual bool get_IsDisposed();
    public sealed virtual string get_Name();
    public sealed virtual string get_Status();
    public sealed virtual void Initialize();
    [EditorBrowsableAttribute("1")]
public sealed virtual void BeginInit();
    [EditorBrowsableAttribute("1")]
public sealed virtual void EndInit();
    public sealed virtual void SaveSettings();
    public sealed virtual void LoadSettings();
    public void Start();
    public void Stop();
    public void CheckAllSchedules();
    public bool AddSchedule(string scheduleName, string scheduleRule);
    public bool AddSchedule(string scheduleName, string scheduleRule, bool updateExisting);
    public bool AddSchedule(string scheduleName, string scheduleRule, string scheduleDescription);
    public bool AddSchedule(string scheduleName, string scheduleRule, string scheduleDescription, bool updateExisting);
    public bool RemoveSchedule(string scheduleName);
    public Schedule FindSchedule(string scheduleName);
    protected virtual void OnStarting();
    protected virtual void OnStarted();
    protected virtual void OnScheduleDue(Schedule schedule);
    protected virtual void OnScheduleDueCheck(EventArgs`1<Schedule> e);
    protected virtual void Dispose(bool disposing);
    private void StartTimer();
    private void m_timer_Elapsed(object sender, ElapsedEventArgs e);
}
public class GSF.Scheduling.SchedulePart : object {
    private string m_valueText;
    private DateTimePart m_dateTimePart;
    private SchedulePartTextSyntax m_valueTextSyntax;
    private List`1<int> m_values;
    public string ValueText { get; }
    public DateTimePart DateTimePart { get; }
    public SchedulePartTextSyntax ValueTextSyntax { get; }
    public string Description { get; }
    public List`1<int> Values { get; }
    public SchedulePart(string valueText, DateTimePart dateTimePart);
    public string get_ValueText();
    public DateTimePart get_DateTimePart();
    public SchedulePartTextSyntax get_ValueTextSyntax();
    public string get_Description();
    public List`1<int> get_Values();
    public bool Matches(DateTime dateTime);
    private bool ValidateAndPopulate(string schedulePart, DateTimePart dateTimePart);
    private void PopulateValues(int fromValue, int toValue, int stepValue);
}
public enum GSF.Scheduling.SchedulePartTextSyntax : Enum {
    public int value__;
    public static SchedulePartTextSyntax Any;
    public static SchedulePartTextSyntax EveryN;
    public static SchedulePartTextSyntax Range;
    public static SchedulePartTextSyntax Specific;
    public static SchedulePartTextSyntax RangeWithEveryN;
}
public class GSF.Searching.AsyncSearcher`1 : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<IEnumerable`1<TSearch>>> MatchesFound;
    [CompilerGeneratedAttribute]
private EventHandler SearchComplete;
    private string m_searchText;
    private ICollection`1<string> m_searchCategories;
    private bool m_ignoreCase;
    private bool m_useWildcards;
    private bool m_useRegex;
    private String[] m_tokens;
    private PropertyInfo[] m_searchProperties;
    private RegexOptions m_regexOptions;
    private bool m_usingWildcards;
    private ConcurrentQueue`1<IEnumerable`1<TSearch>> m_itemsToSearch;
    private int m_searching;
    private int m_cancel;
    public string SearchText { get; public set; }
    public ICollection`1<string> SearchCategories { get; }
    public bool IgnoreCase { get; public set; }
    public bool UseWildcards { get; public set; }
    public bool UseRegex { get; public set; }
    public bool Searching { get; }
    [CompilerGeneratedAttribute]
public void add_MatchesFound(EventHandler`1<EventArgs`1<IEnumerable`1<TSearch>>> value);
    [CompilerGeneratedAttribute]
public void remove_MatchesFound(EventHandler`1<EventArgs`1<IEnumerable`1<TSearch>>> value);
    [CompilerGeneratedAttribute]
public void add_SearchComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SearchComplete(EventHandler value);
    public string get_SearchText();
    public void set_SearchText(string value);
    public ICollection`1<string> get_SearchCategories();
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    public bool get_UseWildcards();
    public void set_UseWildcards(bool value);
    public bool get_UseRegex();
    public void set_UseRegex(bool value);
    public bool get_Searching();
    public void Add(IEnumerable`1<TSearch> itemsToSearch);
    public void Clear();
    public void Cancel();
    private void Search(IEnumerable`1<TSearch> itemsToSearch);
    private void OnMatchesFound(IEnumerable`1<TSearch> matches);
    private void OnSearchComplete();
    [CompilerGeneratedAttribute]
private void <Add>b__35_3(object state);
}
public class GSF.Security.Cryptography.CharacterGroup : object {
    private string m_characters;
    private int m_minOccurrence;
    public string Characters { get; public set; }
    public int MinOccurrence { get; public set; }
    public CharacterGroup(string characters);
    public CharacterGroup(string characters, int minOccurrence);
    public string get_Characters();
    public void set_Characters(string value);
    public int get_MinOccurrence();
    public void set_MinOccurrence(int value);
}
[ExtensionAttribute]
public static class GSF.Security.Cryptography.Cipher : object {
    private static int KeyIndex;
    private static int IVIndex;
    private static string DefaultCacheFileName;
    private static int DefaultMaximumRetryAttempts;
    private static double DefaultRetryDelayInterval;
    private static string CryptoServicesSettingsCategory;
    private static Lazy`1<KeyIVCache> s_keyIVCache;
    private static Encoding s_textEncoding;
    private static bool s_managedEncryption;
    private static KeyIVCache GlobalKeyIVCache { get; }
    public static bool SystemAllowsManagedEncryption { get; }
    private static Cipher();
    private static KeyIVCache get_GlobalKeyIVCache();
    public static void FlushCache(int millisecondsTimeout);
    public static void ReloadCache();
    public static bool KeyIVExists(string password, int keySize);
    public static void ImportKeyIV(string password, int keySize, string keyIVText);
    public static string ExportKeyIV(string password, int keySize);
    public static string GetPasswordHash(string password, int categoryID);
    [ExtensionAttribute]
public static string Encrypt(string source, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Encrypt(Byte[] source, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Encrypt(Byte[] source, int startIndex, int length, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Encrypt(Byte[] source, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Encrypt(Byte[] source, int startIndex, int length, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static MemoryStream Encrypt(Stream source, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static void Encrypt(Stream source, Stream destination, Byte[] key, Byte[] iv, CipherStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    public static void EncryptFile(string sourceFileName, string destinationFileName, string password, CipherStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    [ExtensionAttribute]
public static string Decrypt(string source, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Decrypt(Byte[] source, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Decrypt(Byte[] source, int startIndex, int length, string password, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Decrypt(Byte[] source, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static Byte[] Decrypt(Byte[] source, int startIndex, int length, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static MemoryStream Decrypt(Stream source, Byte[] key, Byte[] iv, CipherStrength strength);
    [ExtensionAttribute]
public static void Decrypt(Stream source, Stream destination, Byte[] key, Byte[] iv, CipherStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    public static void DecryptFile(string sourceFileName, string destinationFileName, string password, CipherStrength strength, Action`1<ProcessProgress`1<long>> progressHandler);
    public static bool get_SystemAllowsManagedEncryption();
    private static void OnCreated();
    public static SHA1 CreateSHA1();
    public static SHA256 CreateSHA256();
    public static SHA384 CreateSHA384();
    public static SHA512 CreateSHA512();
    public static Aes CreateAes();
}
public enum GSF.Security.Cryptography.CipherStrength : Enum {
    public int value__;
    public static CipherStrength None;
    public static CipherStrength Aes128;
    public static CipherStrength Aes256;
}
public class GSF.Security.Cryptography.DataProtection : object {
    public static Byte[] Protect(Byte[] userData, Byte[] optionalEntropy, DataProtectionScope scope);
    public static Byte[] Unprotect(Byte[] encryptedData, Byte[] optionalEntropy, DataProtectionScope scope);
}
[CompilerGeneratedAttribute]
internal class GSF.Security.Cryptography.NamespaceDoc : object {
}
public class GSF.Security.Cryptography.PasswordGenerator : object {
    private List`1<CharacterGroup> m_characterGroups;
    public static IReadOnlyList`1<CharacterGroup> DefaultCharacterGroups;
    public static PasswordGenerator Default;
    public List`1<CharacterGroup> CharacterGroups { get; }
    public string AllCharacters { get; }
    public int MinLength { get; }
    public PasswordGenerator(IEnumerable`1<CharacterGroup> characterGroups);
    private static PasswordGenerator();
    public List`1<CharacterGroup> get_CharacterGroups();
    public string get_AllCharacters();
    public int get_MinLength();
    public string GeneratePassword();
    public string GeneratePassword(int minLength, int maxLength);
    public string GeneratePassword(int length);
}
public static class GSF.Security.Cryptography.Random : object {
    private static RNGCryptoServiceProvider RandomNumberGenerator;
    public static double Number { get; }
    public static decimal Decimal { get; }
    public static bool Boolean { get; }
    public static byte Byte { get; }
    public static short Int16 { get; }
    public static ushort UInt16 { get; }
    public static Int24 Int24 { get; }
    public static UInt24 UInt24 { get; }
    public static int Int32 { get; }
    public static UInt32 UInt32 { get; }
    public static long Int64 { get; }
    public static ulong UInt64 { get; }
    private static Random();
    public static double get_Number();
    public static decimal get_Decimal();
    public static double Between(double startNumber, double stopNumber);
    public static void GetBytes(Byte[] buffer);
    public static bool get_Boolean();
    public static byte get_Byte();
    public static byte ByteBetween(byte startNumber, byte stopNumber);
    public static short get_Int16();
    public static short Int16Between(short startNumber, short stopNumber);
    public static ushort get_UInt16();
    public static ushort UInt16Between(ushort startNumber, ushort stopNumber);
    public static Int24 get_Int24();
    public static Int24 Int24Between(Int24 startNumber, Int24 stopNumber);
    public static UInt24 get_UInt24();
    public static UInt24 Int24Between(UInt24 startNumber, UInt24 stopNumber);
    public static int get_Int32();
    public static int Int32Between(int startNumber, int stopNumber);
    public static UInt32 get_UInt32();
    public static UInt32 UInt32Between(UInt32 startNumber, UInt32 stopNumber);
    public static long get_Int64();
    public static long Int64Between(long startNumber, long stopNumber);
    public static ulong get_UInt64();
    public static ulong UInt64Between(ulong startNumber, ulong stopNumber);
    private static UInt32 GetRandomNumberLessThan(UInt32 maxValue);
    private static ulong GetRandomNumberLessThan(ulong maxValue);
    private static long GetRandomNumberLessThan(long maxValue);
    private static int GetRandomNumberLessThan(int maxValue);
}
internal static class GSF.Security.Cryptography.Standard : object {
    public static int BufferSize;
}
[ExtensionAttribute]
public static class GSF.Security.Cryptography.SymmetricAlgorithmExtensions : object {
    [ExtensionAttribute]
public static Byte[] Encrypt(SymmetricAlgorithm algorithm, Byte[] data, int startIndex, int length, Byte[] key, Byte[] iv);
    [ExtensionAttribute]
public static void Encrypt(SymmetricAlgorithm algorithm, Stream source, Stream destination, Byte[] key, Byte[] iv);
    [ExtensionAttribute]
public static Byte[] Decrypt(SymmetricAlgorithm algorithm, Byte[] data, int startIndex, int length, Byte[] key, Byte[] iv);
    [ExtensionAttribute]
public static void Decrypt(SymmetricAlgorithm algorithm, Stream source, Stream destination, Byte[] key, Byte[] iv);
}
public static class GSF.Security.Cryptography.X509.CertificateMaker : object {
    public static X509Certificate2 GenerateSelfSignedCertificate(CertificateSigningMode mode, string subjectName, DateTime startDate, DateTime endDate);
}
public enum GSF.Security.Cryptography.X509.CertificateSigningMode : Enum {
    public int value__;
    public static CertificateSigningMode RSA_1024_SHA_1;
    public static CertificateSigningMode RSA_2048_SHA2_256;
    public static CertificateSigningMode RSA_3072_SHA2_256;
    public static CertificateSigningMode RSA_3072_SHA2_384;
    public static CertificateSigningMode RSA_4096_SHA2_256;
    public static CertificateSigningMode RSA_4096_SHA2_384;
    public static CertificateSigningMode RSA_7680_SHA2_384;
    public static CertificateSigningMode RSA_15360_SHA2_512;
    public static CertificateSigningMode ECDSA_256_SHA2_256;
    public static CertificateSigningMode ECDSA_384_SHA2_384;
    public static CertificateSigningMode ECDSA_521_SHA2_512;
}
public enum GSF.Security.Cryptography.X509.CipherEngine : Enum {
    public int value__;
    public static CipherEngine RSACryptoServiceProvider;
    public static CipherEngine RSACng;
    public static CipherEngine ECDsaCng;
}
internal class GSF.Security.Cryptography.X509.DerWriter : object {
    private Stack`1<MemoryStream> m_stack;
    private static int Integer;
    private static int BitString;
    private static int OctetString;
    private static int Null;
    private static int ObjectIdentifier;
    private static int Sequence;
    private static int Set;
    private static int GeneralizedTime;
    private static int Utf8String;
    private static int Constructed;
    private static int Tagged;
    private MemoryStream m_ms;
    private void EndSection(SectionMode mode);
    private void WriteLength(int length);
    private void WriteEncoded(int tag, Byte[] bytes);
    public void Write(Byte[] bitString);
    public void Write(DateTime time);
    public void WriteInteger(Byte[] bigInt);
    public void WriteInteger(long value);
    private static Byte[] ToBytes(long value);
    public void WriteNull();
    public IDisposable BeginTaggedObject(int tag);
    public IDisposable BeginSequence();
    public IDisposable BeginOctetString();
    public void WriteOctetString(Byte[] data);
    public IDisposable BeginBitString();
    public IDisposable BeginSet();
    public void WriteOID(string identifier);
    private void WriteField(MemoryStream stream, long fieldValue);
    private void WriteSequence(Byte[] data);
    private void WriteSet(Byte[] data);
    public void Write(string value);
    public Byte[] ToArray();
}
public class GSF.Security.Cryptography.X509.X509CertificateGenerator : object {
    private static string RsaEncryption;
    private static string Sha1WithRsaEncryption;
    private static string Sha256WithRsaEncryption;
    private static string Sha384WithRsaEncryption;
    private static string Sha512WithRsaEncryption;
    private static string Cn;
    private static string EcdsaWithSha256;
    private static string EcdsaWithSha384;
    private static string EcdsaWithSha512;
    private static string EcPublicKey;
    private static string Secp256r1;
    private static string Secp384r1;
    private static string Secp521r1;
    private static string PKCS7Data;
    private static string PKCS12KeyBag;
    private static string PKCS12LocalKeyID;
    private static string PKCS12CertBag;
    private static string PKCS12X509Certificate;
    public long SerialNumber;
    public string Issuer;
    public string Subject;
    public DateTime NotBefore;
    public DateTime NotAfter;
    public int KeySize;
    public int SignatureBits;
    public CipherEngine CipherEngine;
    private static X509CertificateGenerator();
    public X509Certificate2 Generate();
    public void GenerateFile(string fileName, string password);
    private Byte[] MakePFX(Byte[] cert, EncryptionMethod p);
    private static void OuterDataObject(Byte[] cert, EncryptionMethod p, DerWriter wr);
    private static void InnerDataObject1(EncryptionMethod p, DerWriter wr);
    private static void InnerDataObject2(Byte[] cert, EncryptionMethod p, DerWriter wr);
    private static void WriteCertBag(Byte[] cert, EncryptionMethod p, DerWriter wr);
    private static void WriteX509Cert(Byte[] cert, EncryptionMethod p, DerWriter wr);
    private static void WriteKeyBag(EncryptionMethod p, DerWriter wr);
}
[ExtensionAttribute]
public static class GSF.Serialization : object {
    public static SerializationBinder LegacyBinder;
    private static Serialization();
    [ObsoleteAttribute("This method will be removed in future builds.")]
public static T CloneObject(T sourceObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static T GetObject(string serializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static bool TryGetObject(string serializedObject, T& deserializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static T GetObject(Byte[] serializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static bool TryGetObject(Byte[] serializedObject, T& deserializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static object GetObject(Byte[] serializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Deserialize() method instead.")]
public static bool TryGetObject(Byte[] serializedObject, Object& deserializedObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Serialize() method instead.")]
public static string GetString(object serializableObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Serialize() method instead.")]
public static Byte[] GetBytes(object serializableObject);
    [ObsoleteAttribute("This method will be removed in future builds, use the Serialize() method instead.")]
public static MemoryStream GetStream(object serializableObject);
    public static Byte[] Serialize(T serializableObject, SerializationFormat serializationFormat);
    public static void Serialize(T serializableObject, SerializationFormat serializationFormat, Stream serializedOutput);
    public static T Deserialize(Byte[] serializedObject, SerializationFormat serializationFormat);
    public static T Deserialize(Stream serializedObject, SerializationFormat serializationFormat);
    public static bool TryDeserialize(Byte[] serializedObject, SerializationFormat serializationFormat, T& deserializedObject);
    public static bool TryDeserialize(Stream serializedObject, SerializationFormat serializationFormat, T& deserializedObject);
    [ExtensionAttribute]
public static T GetOrDefault(SerializationInfo info, string name, T defaultValue);
    [IteratorStateMachineAttribute("GSF.Serialization/<GetValues>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<SerializationEntry> GetValues(SerializationInfo info);
}
public enum GSF.SerializationFormat : Enum {
    public int value__;
    public static SerializationFormat Xml;
    public static SerializationFormat Json;
    public static SerializationFormat Binary;
}
public class GSF.ShortTime : ValueType {
    private long m_time;
    public DateTime UtcTime { get; }
    public static ShortTime Now { get; }
    private ShortTime(long time);
    public DateTime get_UtcTime();
    public double ElapsedSeconds();
    public double ElapsedMilliseconds();
    public double ElapsedMicroseconds();
    public double ElapsedTicks();
    public TimeSpan Elapsed();
    public double ElapsedSeconds(ShortTime futureTime);
    public double ElapsedMilliseconds(ShortTime futureTime);
    public double ElapsedMicroseconds(ShortTime futureTime);
    public double ElapsedTicks(ShortTime futureTime);
    public TimeSpan Elapsed(ShortTime futureTime);
    public ShortTime AddMilliseconds(double duration);
    public ShortTime AddSeconds(double duration);
    public ShortTime AddTicks(double duration);
    public ShortTime Add(TimeSpan duration);
    public static ShortTime get_Now();
    public static bool op_LessThan(ShortTime a, ShortTime b);
    public static bool op_GreaterThan(ShortTime a, ShortTime b);
    public static bool op_LessThanOrEqual(ShortTime a, ShortTime b);
    public static bool op_GreaterThanOrEqual(ShortTime a, ShortTime b);
    public static TimeSpan op_Subtraction(ShortTime a, ShortTime b);
    public static bool op_Equality(ShortTime a, ShortTime b);
    public static bool op_Inequality(ShortTime a, ShortTime b);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShortTime other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class GSF.ShortTimeFunctions : object {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static double SecondsPerCount;
    private static double MillisecondsPerCount;
    private static double MicrosecondsPerCount;
    private static double TicksPerCount;
    private static double CountsPerSecond;
    private static double CountsPerMillisecond;
    private static double CountsPerMicrosecond;
    private static double CountsPerTick;
    private static ShortTimeFunctions();
    public static long Now();
    public static long AddSeconds(long time, double value);
    public static long AddMilliseconds(long time, double value);
    public static long AddMicroseconds(long time, double value);
    public static long AddTicks(long time, double value);
    public static double ElapsedSeconds(long a, long b);
    public static double ElapsedMilliseconds(long a, long b);
    public static double ElapsedMicroseconds(long a, long b);
    public static double ElapsedTicks(long a, long b);
}
[ExtensionAttribute]
public static class GSF.StringExtensions : object {
    private static PluralizationService s_pluralizationService;
    private static Dictionary`2<StringComparison, StringComparer> s_comparisonComparers;
    private static StringExtensions();
    [ExtensionAttribute]
public static string ToSingular(string value);
    [ExtensionAttribute]
public static bool IsSingular(string value);
    [ExtensionAttribute]
public static string ToPlural(string value);
    [ExtensionAttribute]
public static bool IsPlural(string value);
    [ExtensionAttribute]
public static StringComparer GetComparer(StringComparison comparison);
    [ExtensionAttribute]
public static bool ParseBoolean(string value);
    [ExtensionAttribute]
public static T ConvertToType(string value);
    [ExtensionAttribute]
public static T ConvertToType(string value, CultureInfo culture);
    [ExtensionAttribute]
public static object ConvertToType(string value, Type type);
    [ExtensionAttribute]
public static object ConvertToType(string value, Type type, CultureInfo culture);
    [ExtensionAttribute]
public static Stream ToStream(string value, Encoding encoding);
    [AsyncStateMachineAttribute("GSF.StringExtensions/<ToStreamAsync>d__14")]
[ExtensionAttribute]
public static Task`1<Stream> ToStreamAsync(string value, Encoding encoding);
    [ExtensionAttribute]
public static String[] GetSegments(string value, int segmentSize);
    [ExtensionAttribute]
public static string JoinKeyValuePairs(IDictionary`2<string, string> pairs, char parameterDelimiter, char keyValueDelimiter, char startValueDelimiter, char endValueDelimiter);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ParseKeyValuePairs(string value, char parameterDelimiter, char keyValueDelimiter, char startValueDelimiter, char endValueDelimiter, bool ignoreDuplicateKeys);
    [ExtensionAttribute]
public static string NotEmpty(string testValue);
    [ExtensionAttribute]
public static string NotEmpty(string testValue, string nonEmptyReturnValue);
    [ExtensionAttribute]
public static string ReplaceCharacters(string value, char replacementCharacter, Func`2<char, bool> characterTestFunction);
    [ExtensionAttribute]
public static string RemoveCharacters(string value, Func`2<char, bool> characterTestFunction);
    [ExtensionAttribute]
public static string RemoveCharacter(string value, char characterToRemove);
    [ExtensionAttribute]
public static string RemoveWhiteSpace(string value);
    [ExtensionAttribute]
public static string ReplaceWhiteSpace(string value, char replacementCharacter);
    [ExtensionAttribute]
public static string RemoveControlCharacters(string value);
    [ExtensionAttribute]
public static string ReplaceControlCharacters(string value);
    [ExtensionAttribute]
public static string ReplaceControlCharacters(string value, char replacementCharacter);
    [ExtensionAttribute]
public static string RemoveCrLfs(string value);
    [ExtensionAttribute]
public static string ReplaceCrLfs(string value, char replacementCharacter);
    [ExtensionAttribute]
public static string RemoveDuplicates(string value, string duplicatedValue);
    [ExtensionAttribute]
public static string RemoveNull(string value);
    [ExtensionAttribute]
public static string RemoveDuplicateWhiteSpace(string value);
    [ExtensionAttribute]
public static string RemoveDuplicateWhiteSpace(string value, char spacingCharacter);
    [ExtensionAttribute]
public static string RemoveInvalidFileNameCharacters(string value);
    [ExtensionAttribute]
public static string ReplaceInvalidFileNameCharacters(string value, char replacementCharacter);
    [ExtensionAttribute]
public static string QuoteWrap(string value, char quoteChar);
    [ExtensionAttribute]
public static int CharCount(string value, char characterToCount);
    [ExtensionAttribute]
public static bool IsAllDigits(string value);
    [ExtensionAttribute]
public static bool IsAllNumbers(string value);
    [ExtensionAttribute]
public static bool IsAllUpper(string value);
    [ExtensionAttribute]
public static bool IsAllLower(string value);
    [ExtensionAttribute]
public static bool IsAllLetters(string value);
    [ExtensionAttribute]
public static bool IsAllLetters(string value, bool ignorePunctuation);
    [ExtensionAttribute]
public static bool IsAllLettersOrDigits(string value);
    [ExtensionAttribute]
public static bool IsAllLettersOrDigits(string value, bool ignorePunctuation);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static char RegexDecode(string value);
    [ExtensionAttribute]
public static string Base64Encode(string value);
    [ExtensionAttribute]
public static string Base64Decode(string value);
    [ExtensionAttribute]
public static SecureString ToSecureString(string value);
    [ExtensionAttribute]
public static string ToUnsecureString(SecureString value);
    [ExtensionAttribute]
public static string ToTitleCase(string value, CultureInfo culture);
    [ExtensionAttribute]
public static string ToPascalCase(string value);
    [ExtensionAttribute]
public static string ToCamelCase(string value);
    [ExtensionAttribute]
public static string TruncateLeft(string value, int maxLength);
    [ExtensionAttribute]
public static string TruncateRight(string value, int maxLength);
    [ExtensionAttribute]
public static string CenterText(string value, int maxLength);
    [ExtensionAttribute]
public static string CenterText(string value, int maxLength, char paddingCharacter);
    [ExtensionAttribute]
public static string ReplaceCaseInsensitive(string value, string fromText, string toText);
    [ExtensionAttribute]
public static string EnsureStart(string value, char startChar);
    [ExtensionAttribute]
public static string EnsureStart(string value, char startChar, bool removeRepeatingChar);
    [ExtensionAttribute]
public static string EnsureStart(string value, string startString);
    [ExtensionAttribute]
public static string EnsureEnd(string value, char endChar);
    [ExtensionAttribute]
public static string EnsureEnd(string value, char endChar, bool removeRepeatingChar);
    [ExtensionAttribute]
public static string EnsureEnd(string value, string endString);
    [ExtensionAttribute]
public static string Reverse(string value);
    [ExtensionAttribute]
public static int IndexOfRepeatedChar(string value, char characterToFind, int startIndex);
    [ExtensionAttribute]
public static int IndexOfRepeatedChar(string value, char characterToFind);
    [ExtensionAttribute]
public static int IndexOfRepeatedChar(string value);
    [ExtensionAttribute]
public static int IndexOfRepeatedChar(string value, int startIndex);
    private static int LastIndexOfRepeatedChar(string value, char characterToFind, int startIndex);
    [ExtensionAttribute]
public static string TrimWithEllipsisMiddle(string value, int length);
    [ExtensionAttribute]
public static string TrimWithEllipsisEnd(string value, int length);
    [ExtensionAttribute]
public static string UriEncode(string value);
    [ExtensionAttribute]
public static string RemoveLeadingString(string value, string stringToRemove, bool matchCase);
    [ExtensionAttribute]
public static string RemoveLeadingString(string value, char charToRemove, bool matchCase);
    [ExtensionAttribute]
public static string RemoveLeadingZeros(string value, bool AssureParseDouble);
    [ExtensionAttribute]
public static string RemoveTrailingString(string value, string stringToRemove, bool matchCase);
    [ExtensionAttribute]
public static string RemoveTrailingString(string value, char charToRemove, bool matchCase);
    [ExtensionAttribute]
public static string SubstringEnd(string value, int length);
    [ExtensionAttribute]
public static string SubstringPrevious(string value, int endIndex, int length);
    [ExtensionAttribute]
public static int IndexOfPrevious(string value, string testString, int startIndex, bool matchCase);
    [ExtensionAttribute]
public static int IndexOfPrevious(string value, char testChar, int startIndex);
    [ExtensionAttribute]
public static int IndexOfPrevious(string value, Func`2<char, bool> characterTestFunction, int startIndex);
    [ExtensionAttribute]
public static int IndexOfPreviousNot(string value, char testChar, int startIndex);
    [ExtensionAttribute]
public static int IndexOfPreviousNot(string value, Char[] anyOf, int startIndex);
    [ExtensionAttribute]
public static int IndexOfPreviousNot(string value, Func`2<char, bool> characterTestFunction, int startIndex);
    [ExtensionAttribute]
public static int IndexOfNot(string value, Char[] anyOf, int startIndex);
    [ExtensionAttribute]
public static int IndexOfNot(string value, char character, int startIndex);
    [ExtensionAttribute]
public static int IndexOfNot(string value, Func`2<char, bool> characterTestFunction, int startIndex);
    [ExtensionAttribute]
public static int StringCount(string value, string testString, int startIndex, bool matchCase);
    [ExtensionAttribute]
public static string QuoteUnwrap(string value, char quoteChar);
    [ExtensionAttribute]
public static string QuoteUnwrap(string value, Char[] quoteChars);
    [ExtensionAttribute]
public static string Interpolate(string format, T parameters);
    [ExtensionAttribute]
public static string Interpolate(string format, IEnumerable`1<KeyValuePair`2<string, object>> parameters);
}
[ExtensionAttribute]
internal static class GSF.Text.CompatibilityExtensions : object {
    [ExtensionAttribute]
public static List`1<T> Splice(List`1<T> input, int start, int count, T[] objects);
    [ExtensionAttribute]
public static string JavaSubstring(string s, int begin, int end);
}
public class GSF.Text.Diff : object {
    [CompilerGeneratedAttribute]
private Operation <Operation>k__BackingField;
    public string Text;
    public Operation Operation { get; public set; }
    public Diff(Operation operation, string text);
    [CompilerGeneratedAttribute]
public Operation get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(Operation value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(Diff obj);
    public virtual int GetHashCode();
}
public class GSF.Text.DiffMatchPatch : object {
    public float DiffTimeout;
    public short DiffEditCost;
    public float MatchThreshold;
    public int MatchDistance;
    public float PatchDeleteThreshold;
    public short PatchMargin;
    private short MatchMaxBits;
    private Regex BLANKLINEEND;
    private Regex BLANKLINESTART;
    public List`1<Diff> DiffMain(string text1, string text2);
    public List`1<Diff> DiffMain(string text1, string text2, bool checklines);
    private List`1<Diff> DiffMain(string text1, string text2, bool checklines, DateTime deadline);
    private List`1<Diff> DiffCompute(string text1, string text2, bool checklines, DateTime deadline);
    private List`1<Diff> DiffLineMode(string text1, string text2, DateTime deadline);
    protected List`1<Diff> DiffBisect(string text1, string text2, DateTime deadline);
    private List`1<Diff> DiffBisectSplit(string text1, string text2, int x, int y, DateTime deadline);
    protected Object[] DiffLinesToChars(string text1, string text2);
    private string DiffLinesToCharsMunge(string text, List`1<string> lineArray, Dictionary`2<string, int> lineHash, int maxLines);
    protected void DiffCharsToLines(ICollection`1<Diff> diffs, IList`1<string> lineArray);
    public int DiffCommonPrefix(string text1, string text2);
    public int DiffCommonSuffix(string text1, string text2);
    protected int DiffCommonOverlap(string text1, string text2);
    protected String[] DiffHalfMatch(string text1, string text2);
    private String[] DiffHalfMatchI(string longtext, string shorttext, int i);
    public void DiffCleanupSemantic(List`1<Diff> diffs);
    public void DiffCleanupSemanticLossless(List`1<Diff> diffs);
    private int DiffCleanupSemanticScore(string one, string two);
    public void DiffCleanupEfficiency(List`1<Diff> diffs);
    public void DiffCleanupMerge(List`1<Diff> diffs);
    public int DiffXIndex(List`1<Diff> diffs, int loc);
    public string DiffPrettyHtml(List`1<Diff> diffs);
    public string DiffText1(List`1<Diff> diffs);
    public string DiffText2(List`1<Diff> diffs);
    public int DiffLevenshtein(List`1<Diff> diffs);
    public string DiffToDelta(List`1<Diff> diffs);
    public List`1<Diff> DiffFromDelta(string text1, string delta);
    public int MatchMain(string text, string pattern, int loc);
    protected int MatchBitap(string text, string pattern, int loc);
    private double MatchBitapScore(int e, int x, int loc, string pattern);
    protected Dictionary`2<char, int> MatchAlphabet(string pattern);
    protected void PatchAddContext(Patch patch, string text);
    public List`1<Patch> PatchMake(string text1, string text2);
    public List`1<Patch> PatchMake(List`1<Diff> diffs);
    [ObsoleteAttribute("Prefer PatchMake(string text1, List<Diff> diffs).")]
public List`1<Patch> PatchMake(string text1, string text2, List`1<Diff> diffs);
    public List`1<Patch> PatchMake(string text1, List`1<Diff> diffs);
    public List`1<Patch> PatchDeepCopy(List`1<Patch> patches);
    public Object[] PatchApply(List`1<Patch> patches, string text);
    public string PatchAddPadding(List`1<Patch> patches);
    public void PatchSplitMax(List`1<Patch> patches);
    public string PatchToText(List`1<Patch> patches);
    public List`1<Patch> PatchFromText(string textline);
    public static string EncodeURI(string str);
}
public enum GSF.Text.Operation : Enum {
    public int value__;
    public static Operation DELETE;
    public static Operation INSERT;
    public static Operation EQUAL;
}
public class GSF.Text.Patch : object {
    [CompilerGeneratedAttribute]
private List`1<Diff> <Diffs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length2>k__BackingField;
    public List`1<Diff> Diffs { get; public set; }
    public int Start1 { get; public set; }
    public int Start2 { get; public set; }
    public int Length1 { get; public set; }
    public int Length2 { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Diff> get_Diffs();
    [CompilerGeneratedAttribute]
public void set_Diffs(List`1<Diff> value);
    [CompilerGeneratedAttribute]
public int get_Start1();
    [CompilerGeneratedAttribute]
public void set_Start1(int value);
    [CompilerGeneratedAttribute]
public int get_Start2();
    [CompilerGeneratedAttribute]
public void set_Start2(int value);
    [CompilerGeneratedAttribute]
public int get_Length1();
    [CompilerGeneratedAttribute]
public void set_Length1(int value);
    [CompilerGeneratedAttribute]
public int get_Length2();
    [CompilerGeneratedAttribute]
public void set_Length2(int value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class GSF.Threading.ActionExtensions : object {
    [ExtensionAttribute]
public static bool TryExecute(Action action, Action`1<Exception> exceptionHandler);
    [ExtensionAttribute]
public static void DelayAndExecute(Action action, WaitHandle waitObj, int delay);
    [ExtensionAttribute]
public static ICancellationToken DelayAndExecute(Action action, int delay);
}
public enum GSF.Threading.AsynchronousExecutionMode : Enum {
    public int value__;
    public static AsynchronousExecutionMode Short;
    public static AsynchronousExecutionMode Long;
}
public class GSF.Threading.CancellationToken : object {
    [CompilerGeneratedAttribute]
private EventHandler Cancelled;
    private int m_cancelled;
    public bool IsCancelled { get; }
    [CompilerGeneratedAttribute]
public void add_Cancelled(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Cancelled(EventHandler value);
    public sealed virtual bool get_IsCancelled();
    public sealed virtual bool Cancel();
    public static CancellationToken op_Implicit(CancellationToken token);
    public static CancellationTokenSource op_Implicit(CancellationToken token);
}
public class GSF.Threading.CompatibleCancellationToken : object {
    private CancellationTokenSource m_source;
    private CancellationToken m_token;
    private bool m_sourceIsLocal;
    public bool IsCancelled { get; }
    public CompatibleCancellationToken(CancellationTokenSource source);
    public CompatibleCancellationToken(CancellationToken token);
    public CompatibleCancellationToken(CancellationToken token);
    protected virtual override void Finalize();
    public virtual bool get_IsCancelled();
    public virtual bool Cancel();
    public CancellationTokenSource GetTokenSource();
    public CancellationToken GetToken();
    public static CompatibleCancellationToken op_Implicit(CancellationToken token);
    public static CompatibleCancellationToken op_Implicit(CancellationTokenSource source);
    public static CancellationToken op_Implicit(CompatibleCancellationToken token);
    public static CancellationTokenSource op_Implicit(CompatibleCancellationToken token);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(object sender, EventArgs e);
}
public class GSF.Threading.DedicatedSynchronizedOperation : SynchronizedOperationBase {
    private ScheduledTask m_task;
    public DedicatedSynchronizedOperation(Action action, bool isBackground);
    public DedicatedSynchronizedOperation(Action action, Action`1<Exception> exceptionAction, bool isBackground);
    protected virtual void ExecuteActionAsync();
    private void m_task_Running(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
}
public class GSF.Threading.DelayedSynchronizedOperation : SynchronizedOperationBase {
    public static int DefaultDelay;
    private Action m_delayedAction;
    [CompilerGeneratedAttribute]
private int <Delay>k__BackingField;
    public int Delay { get; public set; }
    public DelayedSynchronizedOperation(Action action);
    public DelayedSynchronizedOperation(Action action, Action`1<Exception> exceptionAction);
    [CompilerGeneratedAttribute]
public int get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(int value);
    protected virtual void ExecuteActionAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0();
}
public class GSF.Threading.DisposableCallback : ValueType {
    private Action m_callback;
    public DisposableCallback(Action callback);
    public sealed virtual void Dispose();
}
public class GSF.Threading.EventTimer : DisposableLoggingClassBase {
    [CompilerGeneratedAttribute]
private EventHandler Elapsed;
    private ScheduledTask m_timer;
    private TimeSpan m_period;
    private TimeSpan m_dayOffset;
    private bool m_started;
    private bool m_disposed;
    public TimeSpan TimeUntilNextExecution { get; }
    private EventTimer(TimeSpan period, TimeSpan dayOffset);
    [CompilerGeneratedAttribute]
public void add_Elapsed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Elapsed(EventHandler value);
    public TimeSpan get_TimeUntilNextExecution();
    public void ChangeTimer(TimeSpan period, TimeSpan dayOffset);
    private void TimerRunning(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
    public void RunNow();
    private void RestartTimer();
    public void Start(ThreadingMode mode);
    protected virtual void Dispose(bool disposing);
    public static EventTimer Create(TimeSpan period, TimeSpan dayOffset);
    public static EventTimer CreateSeconds(double periodInSecond, double dayOffsetInSecond);
    public static EventTimer CreateMinutes(double periodInMinutes, double dayOffsetInMinutes);
    public static EventTimer CreateHours(double periodInHours, double dayOffsetInHours);
}
public interface GSF.Threading.ICancellationToken {
    public bool IsCancelled { get; }
    public abstract virtual bool get_IsCancelled();
    public abstract virtual bool Cancel();
}
public static class GSF.Threading.InterprocessLock : object {
    private static int MutexHash;
    private static int SemaphoreHash;
    public static Mutex GetNamedMutex(bool perUser);
    public static Mutex GetNamedMutex(string name);
    public static Semaphore GetNamedSemaphore(bool perUser, int maximumCount, int initialCount);
    public static Semaphore GetNamedSemaphore(string name, int maximumCount, int initialCount);
}
public class GSF.Threading.InterprocessReaderWriterLock : object {
    public static int DefaultMaximumConcurrentLocks;
    private Mutex m_semaphoreLock;
    private Semaphore m_concurrencyLock;
    private int m_maximumConcurrentLocks;
    private bool m_disposed;
    public int MaximumConcurrentLocks { get; }
    public InterprocessReaderWriterLock(string name);
    public InterprocessReaderWriterLock(string name, int maximumConcurrentLocks);
    protected virtual override void Finalize();
    public int get_MaximumConcurrentLocks();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void EnterReadLock();
    public void EnterWriteLock();
    public int ExitReadLock();
    public void ExitWriteLock();
    public bool TryEnterReadLock(int millisecondsTimeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
}
public interface GSF.Threading.ISynchronizedOperation {
    public bool IsRunning { get; }
    public bool IsPending { get; }
    public abstract virtual bool get_IsRunning();
    public abstract virtual bool get_IsPending();
    public abstract virtual void Run();
    public abstract virtual void TryRun();
    public abstract virtual void RunOnce();
    public abstract virtual void RunOnceAsync();
    public abstract virtual void TryRunOnce();
    public abstract virtual void TryRunOnceAsync();
}
public static class GSF.Threading.LoadingAdjustedTimestamp : object {
    [CompilerGeneratedAttribute]
private static Action OnHighLoad;
    private static LogPublisher Log;
    private static LogEventPublisher LogLoadingClock;
    private static LogEventPublisher LogSmall;
    private static LogEventPublisher LogMedium;
    private static LogEventPublisher LogLarge;
    private static Thread MonitorHighThread;
    private static Thread MonitorNormalThread;
    private static Thread MonitorLowThread;
    private static long s_currentTime;
    private static ShortTime s_currentTimeSetTime;
    private static int s_highProcessCount;
    private static int s_normalProcessCount;
    private static int s_lowProcessCount;
    public static DateTime CurrentTime { get; }
    private static LoadingAdjustedTimestamp();
    [CompilerGeneratedAttribute]
internal static void add_OnHighLoad(Action value);
    [CompilerGeneratedAttribute]
internal static void remove_OnHighLoad(Action value);
    private static void Reset();
    private static void MonitorHighPriority();
    private static void MonitorNormalPriority();
    private static void MonitorLowPriority();
    private static void AdjustRealtime();
    public static DateTime get_CurrentTime();
}
public class GSF.Threading.LogicalThread : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> UnhandledException;
    private LogicalThreadScheduler m_scheduler;
    private ConcurrentQueue`1[] m_queues;
    private Dictionary`2<object, object> m_threadLocalStorage;
    private ICancellationToken m_nextExecutionToken;
    private int m_activePriority;
    private LogicalThreadStatistics m_statistics;
    private static LogicalThreadScheduler DefaultScheduler;
    private static ThreadLocal`1<LogicalThread> LocalThread;
    public int PriorityLevels { get; }
    public bool HasAction { get; }
    internal int ActivePriority { get; internal set; }
    internal int NextPriority { get; }
    internal ICancellationToken NextExecutionToken { get; internal set; }
    public static LogicalThread CurrentThread { get; internal set; }
    internal LogicalThread(LogicalThreadScheduler scheduler);
    private static LogicalThread();
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    public int get_PriorityLevels();
    public bool get_HasAction();
    internal int get_ActivePriority();
    internal void set_ActivePriority(int value);
    internal int get_NextPriority();
    internal ICancellationToken get_NextExecutionToken();
    internal void set_NextExecutionToken(ICancellationToken value);
    public void Push(Action action);
    public void Push(int priority, Action action);
    public void Clear();
    public LogicalThreadStatistics SampleStatistics();
    internal Action Pull();
    internal bool TryActivate(int priority);
    internal void Deactivate();
    internal object GetThreadLocal(object key);
    internal void SetThreadLocal(object key, object value);
    internal void UpdateStatistics(TimeSpan executionTime);
    internal bool OnUnhandledException(Exception ex);
    public static LogicalThread get_CurrentThread();
    internal static void set_CurrentThread(LogicalThread value);
}
[ExtensionAttribute]
public static class GSF.Threading.LogicalThreadExtensions : object {
    [ExtensionAttribute]
public static LogicalThreadAwaitable Join(LogicalThread thread);
    [ExtensionAttribute]
public static LogicalThreadAwaitable Join(LogicalThread thread, int priority);
    [ExtensionAttribute]
public static LogicalThreadAwaitable Yield(LogicalThread thread);
    [ExtensionAttribute]
public static LogicalThreadAwaitable Yield(LogicalThread thread, int priority);
}
public class GSF.Threading.LogicalThreadLocal`1 : object {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    private Func`1<T> m_newObjectFactory;
    private ThreadLocal`1<T> m_threadLocal;
    private int m_accessCount;
    private int m_disposed;
    public T Value { get; public set; }
    private bool IsDisposed { get; }
    public LogicalThreadLocal`1(Func`1<T> newObjectFactory);
    [CompilerGeneratedAttribute]
private void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_Disposed(EventHandler value);
    protected virtual override void Finalize();
    public T get_Value();
    public void set_Value(T value);
    private bool get_IsDisposed();
    public sealed virtual void Dispose();
    private void Access(Action action);
    private TResult Access(Func`1<TResult> func);
    private bool TryGetSlot(Slot& slot);
    private void Dispose(bool disposing);
    private void AttachToDisposed();
    private void OnDisposed(bool disposing);
}
public class GSF.Threading.LogicalThreadOperation : object {
    private static int NotRunning;
    private static int Running;
    private static int Pending;
    private LogicalThread m_thread;
    private Action m_action;
    private bool m_autoRunIfPending;
    private int m_priority;
    private int m_state;
    private int m_queuedPriority;
    private CancellationToken m_cancellationToken;
    public bool IsRunning { get; }
    public bool IsPending { get; }
    public bool AutoRunIfPending { get; }
    public int Priority { get; public set; }
    public LogicalThreadOperation(LogicalThread thread, Action action, bool autoRunIfPending);
    public LogicalThreadOperation(LogicalThread thread, Action action, int priority, bool autoRunIfPending);
    public bool get_IsRunning();
    public bool get_IsPending();
    public bool get_AutoRunIfPending();
    public int get_Priority();
    public void set_Priority(int value);
    public void RunOnce();
    public void RunOnceAsync();
    public void TryRunOnce();
    public void TryRunOnceAsync();
    public void RunIfPending();
    public void ExecuteAction(Action action);
    public void RequeueAction(int priority);
    private void ExecuteActionAsync(int priority);
    [CompilerGeneratedAttribute]
private void <ExecuteActionAsync>b__28_0();
}
public class GSF.Threading.LogicalThreadScheduler : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> UnhandledException;
    private ConcurrentQueue`1[] m_logicalThreadQueues;
    private int m_maxThreadCount;
    private int m_threadCount;
    private bool m_useBackgroundThreads;
    public int MaxThreadCount { get; public set; }
    public bool UseBackgroundThreads { get; public set; }
    public int PriorityLevels { get; }
    private int ThreadCount { get; }
    public LogicalThreadScheduler(int priorityLevels);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    public int get_MaxThreadCount();
    public void set_MaxThreadCount(int value);
    public bool get_UseBackgroundThreads();
    public void set_UseBackgroundThreads(bool value);
    public int get_PriorityLevels();
    private int get_ThreadCount();
    public LogicalThread CreateThread();
    internal void SignalItemHandler(LogicalThread thread, int priority);
    private void ActivatePhysicalThread();
    private void StartNewPhysicalThread();
    private void ProcessLogicalThreads();
    private void Enqueue(LogicalThread thread);
    private void TryExecute(Action action);
    private void DeactivatePhysicalThread();
    private bool TryHandleException(Exception unhandledException);
    private bool OnUnhandledException(Exception ex);
}
public class GSF.Threading.LogicalThreadStatistics : object {
    private TimeSpan m_maxExecutionTime;
    private TimeSpan m_minExecutionTime;
    private TimeSpan m_totalExecutionTime;
    private long m_executionCount;
    public TimeSpan MaxExecutionTime { get; }
    public TimeSpan MinExecutionTime { get; }
    public TimeSpan TotalExecutionTime { get; }
    public long ExecutionCount { get; }
    public TimeSpan get_MaxExecutionTime();
    public TimeSpan get_MinExecutionTime();
    public TimeSpan get_TotalExecutionTime();
    public long get_ExecutionCount();
    internal void UpdateStatistics(TimeSpan executionTime);
}
public class GSF.Threading.LongSynchronizedOperation : SynchronizedOperationBase {
    private bool m_isBackground;
    public bool IsBackground { get; public set; }
    public LongSynchronizedOperation(Action action);
    public LongSynchronizedOperation(Action action, Action`1<Exception> exceptionAction);
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    protected virtual void ExecuteActionAsync();
    [CompilerGeneratedAttribute]
private void <ExecuteActionAsync>b__6_0();
}
public class GSF.Threading.ManagedCancellationTokenSource : object {
    private static int NotDisposed;
    private static int Disposing;
    private static int Disposed;
    private int m_referenceCount;
    private int m_disposeState;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    private CancellationTokenSource CancellationTokenSource { get; }
    private bool IsCanceled { get; }
    public ManagedCancellationTokenSource(Func`1<CancellationTokenSource> cancellationTokenSourceFactory);
    public ManagedCancellationTokenSource(CancellationTokenSource underlyingTokenSource);
    [CompilerGeneratedAttribute]
private CancellationTokenSource get_CancellationTokenSource();
    private bool get_IsCanceled();
    public IDisposable RetrieveToken(CancellationToken& cancellationToken);
    public sealed virtual void Dispose();
    private void ReleaseReference();
}
public class GSF.Threading.ManagedThread : object {
    private Thread m_thread;
    private ThreadType m_type;
    private ThreadStatus m_status;
    private string m_name;
    private Ticks m_startTime;
    private Ticks m_stopTime;
    private ContextCallback m_ctxCallback;
    private ThreadStart m_tsCallback;
    private ParameterizedThreadStart m_ptsCallback;
    private ExecutionContext m_ctx;
    private object m_state;
    private object m_tag;
    public object State { get; public set; }
    public object Tag { get; public set; }
    public ThreadType Type { get; }
    public ThreadStatus Status { get; internal set; }
    public bool IsAlive { get; }
    public string Name { get; public set; }
    public Ticks StartTime { get; }
    public Ticks StopTime { get; }
    public Time RunTime { get; }
    public ThreadPriority Priority { get; public set; }
    internal Thread Thread { get; internal set; }
    public ManagedThread(ThreadStart callback);
    public ManagedThread(ParameterizedThreadStart callback);
    public ManagedThread(ContextCallback callback, ExecutionContext ctx);
    internal ManagedThread(ThreadType type, ThreadStart callback, object state, ExecutionContext ctx);
    internal ManagedThread(ThreadType type, ParameterizedThreadStart callback, object state, ExecutionContext ctx);
    internal ManagedThread(ThreadType type, ContextCallback callback, object state, ExecutionContext ctx);
    public object get_State();
    public void set_State(object value);
    public object get_Tag();
    public void set_Tag(object value);
    public ThreadType get_Type();
    public ThreadStatus get_Status();
    internal void set_Status(ThreadStatus value);
    public bool get_IsAlive();
    public string get_Name();
    public void set_Name(string value);
    public Ticks get_StartTime();
    public Ticks get_StopTime();
    public Time get_RunTime();
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    internal Thread get_Thread();
    internal void set_Thread(Thread value);
    public void Abort();
    public void Abort(object stateInfo);
    public void Start();
    public void Start(object parameter);
    public void Join();
    public bool Join(int millisecondsTimeout);
    public bool Join(TimeSpan timeout);
    internal void HandleItem();
}
public static class GSF.Threading.ManagedThreadPool : object {
    public static ManagedThread QueueUserWorkItem(ThreadStart callback);
    public static ManagedThread QueueUserWorkItem(ParameterizedThreadStart callback);
    public static ManagedThread QueueUserWorkItem(ParameterizedThreadStart callback, object state);
    public static ManagedThread QueueUserWorkItem(ContextCallback callback, ExecutionContext ctx);
    public static ManagedThread QueueUserWorkItem(ContextCallback callback, object state, ExecutionContext ctx);
    private static void HandleItem(object state);
}
public static class GSF.Threading.ManagedThreads : object {
    private static LinkedList`1<ManagedThread> s_queuedThreads;
    private static LinkedList`1<ManagedThread> s_activeThreads;
    public static string ActiveThreadStatus { get; }
    public static ManagedThread[] QueuedThreads { get; }
    private static ManagedThreads();
    internal static void Add(ManagedThread item);
    internal static void Remove(ManagedThread item);
    internal static void Queue(ManagedThread item);
    internal static ManagedThread Pop();
    public static string get_ActiveThreadStatus();
    private static string ThreadStatusText(ManagedThread item);
    public static ManagedThread[] get_QueuedThreads();
    public static void Cancel(ManagedThread item, bool allowAbort, object stateInfo);
}
public class GSF.Threading.MixedSynchronizedOperation : SynchronizedOperationBase {
    private int m_asynchronousExecutionMode;
    private AsynchronousExecutionMode m_currentExecutionMode;
    public AsynchronousExecutionMode AsynchronousExecutionMode { get; public set; }
    public AsynchronousExecutionMode CurrentExecutionMode { get; }
    public MixedSynchronizedOperation(Action action);
    public MixedSynchronizedOperation(Action action, Action`1<Exception> exceptionAction);
    public AsynchronousExecutionMode get_AsynchronousExecutionMode();
    public void set_AsynchronousExecutionMode(AsynchronousExecutionMode value);
    public AsynchronousExecutionMode get_CurrentExecutionMode();
    protected virtual void ExecuteActionAsync();
    private void ExecuteAsyncOnThreadPool();
    private void ExecuteAsyncOnDedicatedThread();
    [CompilerGeneratedAttribute]
private void <ExecuteAsyncOnThreadPool>b__10_0(object state);
    [CompilerGeneratedAttribute]
private void <ExecuteAsyncOnDedicatedThread>b__11_0();
}
[CompilerGeneratedAttribute]
internal class GSF.Threading.NamespaceDoc : object {
}
public class GSF.Threading.RateLimiter : object {
    private double m_maxTokens;
    private double m_tokens;
    private double m_tokenPerSecond;
    private ShortTime m_updateTime;
    public RateLimiter(double tokensPerSecond, int maxTokensQueue);
    public void UpdateLimits(double tokensPerSecond, int maxTokensQueue);
    public bool TryTakeToken();
}
public class GSF.Threading.ReaderWriterSpinLock : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_writer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_readers;
    public void EnterWriteLock();
    public void ExitWriteLock();
    public void EnterReadLock();
    public void ExitReadLock();
}
public class GSF.Threading.ScheduledTask : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<ScheduledTaskRunningReason>> Running;
    [CompilerGeneratedAttribute]
private EventHandler Disposing;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> UnhandledException;
    private int m_workerThreadID;
    private ThreadContainerBase m_thread;
    private ManualResetEvent m_waitForDispose;
    private object m_disposeSync;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_disposing;
    public ScheduledTask(ThreadingMode threadMode, ThreadPriority priority, bool disposeOnShutdown);
    [CompilerGeneratedAttribute]
public void add_Running(EventHandler`1<EventArgs`1<ScheduledTaskRunningReason>> value);
    [CompilerGeneratedAttribute]
public void remove_Running(EventHandler`1<EventArgs`1<ScheduledTaskRunningReason>> value);
    [CompilerGeneratedAttribute]
public void add_Disposing(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledException(EventHandler`1<EventArgs`1<Exception>> value);
    protected virtual override void Finalize();
    internal void IgnoreShutdownEvent();
    public void Start();
    public void Start(int delay);
    public sealed virtual void Dispose();
    private void InternalDisposeAllResources();
    private void OnRunningCallback(CallbackArgs args);
    private void TryCallback(ScheduledTaskRunningReason args);
}
public enum GSF.Threading.ScheduledTaskRunningReason : Enum {
    public int value__;
    public static ScheduledTaskRunningReason Running;
    public static ScheduledTaskRunningReason Disposing;
}
public class GSF.Threading.SharedTimer : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<DateTime>> Elapsed;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs`1<Exception>> UnhandledExceptions;
    private int m_interval;
    private bool m_enabled;
    private bool m_autoReset;
    private bool m_disposed;
    private Action`1<DateTime> m_callback;
    private SharedTimerScheduler m_scheduler;
    private WeakAction`1<DateTime> m_registeredCallback;
    private LogPublisher m_log;
    public bool AutoReset { get; public set; }
    public bool Enabled { get; public set; }
    public int Interval { get; public set; }
    [EditorBrowsableAttribute("1")]
internal SharedTimer(SharedTimerScheduler scheduler, int interval);
    [CompilerGeneratedAttribute]
public void add_Elapsed(EventHandler`1<EventArgs`1<DateTime>> value);
    [CompilerGeneratedAttribute]
public void remove_Elapsed(EventHandler`1<EventArgs`1<DateTime>> value);
    [CompilerGeneratedAttribute]
public void add_UnhandledExceptions(EventHandler`1<EventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
public void remove_UnhandledExceptions(EventHandler`1<EventArgs`1<Exception>> value);
    public bool get_AutoReset();
    public void set_AutoReset(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_Interval();
    public void set_Interval(int value);
    public void Close();
    public sealed virtual void Dispose();
    public void Start();
    public void Stop();
    private void TimerCallback(DateTime state);
}
public class GSF.Threading.SharedTimerScheduler : object {
    private Dictionary`2<int, SharedTimerInstance> m_schedulesByInterval;
    private object m_syncRoot;
    private LogPublisher m_log;
    private ScheduledTask m_reportStatus;
    private bool m_disposed;
    public bool IsDisposed { get; }
    public bool get_IsDisposed();
    public SharedTimer CreateTimer(int interval);
    [EditorBrowsableAttribute("1")]
internal WeakAction`1<DateTime> RegisterCallback(int interval, Action`1<DateTime> callback);
    private WeakAction`1<DateTime> RegisterCallback(int interval, WeakAction`1<DateTime> weakAction);
    public sealed virtual void Dispose();
    private void ReportStatus(object sender, EventArgs`1<ScheduledTaskRunningReason> e);
}
public class GSF.Threading.ShortSynchronizedOperation : SynchronizedOperationBase {
    public ShortSynchronizedOperation(Action action);
    public ShortSynchronizedOperation(Action action, Action`1<Exception> exceptionAction);
    protected virtual void ExecuteActionAsync();
    [CompilerGeneratedAttribute]
private void <ExecuteActionAsync>b__2_0(object state);
}
public static class GSF.Threading.ShutdownHandler : object {
    private static LogPublisher Log;
    [CompilerGeneratedAttribute]
private static bool <IsShuttingDown>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasShutdown>k__BackingField;
    private static List`1<WeakAction> s_onShutdownCallbackFirst;
    private static List`1<WeakAction> s_onShutdownCallbackDefault;
    private static List`1<WeakAction> s_onShutdownCallbackLast;
    private static object s_syncRoot;
    public static bool IsShuttingDown { get; private set; }
    public static bool HasShutdown { get; private set; }
    private static ShutdownHandler();
    [CompilerGeneratedAttribute]
public static bool get_IsShuttingDown();
    [CompilerGeneratedAttribute]
private static void set_IsShuttingDown(bool value);
    [CompilerGeneratedAttribute]
public static bool get_HasShutdown();
    [CompilerGeneratedAttribute]
private static void set_HasShutdown(bool value);
    public static void Initialize();
    public static bool TryRegisterCallback(Action callback, ShutdownHandlerOrder shutdownOrder);
    private static void InitiateSafeShutdown(object sender, EventArgs e);
    [EditorBrowsableAttribute("2")]
public static void InitiateSafeShutdown();
}
public enum GSF.Threading.ShutdownHandlerOrder : Enum {
    public int value__;
    public static ShutdownHandlerOrder First;
    public static ShutdownHandlerOrder Default;
    public static ShutdownHandlerOrder Last;
}
public class GSF.Threading.SingleOccurrenceAction : object {
    private StateMachine m_state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_blockerCount;
    private Action modreq(System.Runtime.CompilerServices.IsVolatile) m_callback;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isCallbackPendingOnBlocks;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_callbackThreadId;
    [CompilerGeneratedAttribute]
private bool <IsCallbackExecuting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSignalingCompleted>k__BackingField;
    public bool IsCallbackPendingOnBlocks { get; }
    public bool IsCallbackExecuting { get; private set; }
    public bool IsSignalingCompleted { get; private set; }
    public bool get_IsCallbackPendingOnBlocks();
    [CompilerGeneratedAttribute]
public bool get_IsCallbackExecuting();
    [CompilerGeneratedAttribute]
private void set_IsCallbackExecuting(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSignalingCompleted();
    [CompilerGeneratedAttribute]
private void set_IsSignalingCompleted(bool value);
    public void ExecuteAndWait(Action callback);
    public void ExecuteWithoutWait(Action callback);
    public DisposableCallback TryBlockAction(Boolean& success);
    public bool TryBlockAction(Action executeIfSuccessful);
    public void BlockAction(Action executeIfSuccessful, Action executeIfFailed);
    public T BlockAction(Func`1<T> executeIfSuccessful, Func`1<T> executeIfFailed);
    private void ExitSignalBlock();
    private void RaceForCallback();
}
public class GSF.Threading.StateMachine : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    public int State { get; }
    public StateMachine(int initialState);
    public bool TryChangeState(int prevState, int nextState);
    public int get_State();
    public void SetState(int state);
    public static int op_Implicit(StateMachine machine);
}
public abstract class GSF.Threading.SynchronizedOperationBase : object {
    private static int NotRunning;
    private static int Running;
    private static int Pending;
    private Action m_action;
    private Action`1<Exception> m_exceptionAction;
    private int m_state;
    public bool IsRunning { get; }
    public bool IsPending { get; }
    protected SynchronizedOperationBase(Action action);
    protected SynchronizedOperationBase(Action action, Action`1<Exception> exceptionAction);
    public sealed virtual bool get_IsRunning();
    public sealed virtual bool get_IsPending();
    public sealed virtual void Run();
    public sealed virtual void TryRun();
    public sealed virtual void RunOnce();
    public sealed virtual void RunOnceAsync();
    public sealed virtual void TryRunOnce();
    public sealed virtual void TryRunOnceAsync();
    protected bool ExecuteAction();
    protected abstract virtual void ExecuteActionAsync();
}
public enum GSF.Threading.SynchronizedOperationType : Enum {
    public int value__;
    public static SynchronizedOperationType Short;
    public static SynchronizedOperationType Long;
    public static SynchronizedOperationType LongBackground;
    public static SynchronizedOperationType Mixed;
    public static SynchronizedOperationType DedicatedForeground;
    public static SynchronizedOperationType DedicatedBackground;
}
public class GSF.Threading.TaskSynchronizedOperation : object {
    [CompilerGeneratedAttribute]
private SynchronizedOperation <InternalSynchronizedOperation>k__BackingField;
    public bool IsRunning { get; }
    public bool IsPending { get; }
    private SynchronizedOperation InternalSynchronizedOperation { get; }
    public TaskSynchronizedOperation(Func`1<Task> asyncAction);
    public TaskSynchronizedOperation(Func`1<Task> asyncAction, Action`1<Exception> exceptionAction);
    public sealed virtual bool get_IsRunning();
    public sealed virtual bool get_IsPending();
    [CompilerGeneratedAttribute]
private SynchronizedOperation get_InternalSynchronizedOperation();
    public sealed virtual void RunOnceAsync();
    public sealed virtual void TryRunOnceAsync();
    private sealed virtual override void GSF.Threading.ISynchronizedOperation.Run();
    private sealed virtual override void GSF.Threading.ISynchronizedOperation.TryRun();
    private sealed virtual override void GSF.Threading.ISynchronizedOperation.RunOnce();
    private sealed virtual override void GSF.Threading.ISynchronizedOperation.TryRunOnce();
}
internal abstract class GSF.Threading.ThreadContainerBase : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_runAgain;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_runAgainAfterDelay;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    private bool m_disposeOnShutdown;
    private WeakAction`1<CallbackArgs> m_callback;
    private WeakAction m_disposeAndWaitCallback;
    private CallbackArgs m_args;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_startDisposalCallSuccessful;
    private bool m_ignoreShutdownHandler;
    protected ThreadContainerBase(Action`1<CallbackArgs> callback, Action disposeAndWaitCallback, bool disposeOnShutdown);
    protected void OnRunning();
    public void StartDisposal();
    public void Start();
    private void StartSlower();
    public void Start(int delay);
    private void StartSlower(int delay);
    internal void IgnoreShutdownEvent();
    protected void Shutdown();
    protected abstract virtual void InternalStart_FromWorkerThread();
    protected abstract virtual void InternalStart_FromWorkerThread(int delay);
    protected abstract virtual void InternalDispose_FromWorkerThread();
    protected abstract virtual void InternalDoNothing_FromWorkerThread();
    protected abstract virtual void InternalStart();
    protected abstract virtual void InternalStart(int delay);
    protected abstract virtual void InternalCancelTimer();
}
internal class GSF.Threading.ThreadContainerDedicated : ThreadContainerBase {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_shouldReRunImmediately;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_shouldReRunAfterDelay;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_shouldReRunAfterDelayValue;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_shouldQuit;
    private Thread m_thread;
    private ManualResetEvent m_threadPausedWaitHandler;
    private ManualResetEvent m_threadSleepWaitHandler;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_sleepTime;
    private bool m_isBackground;
    public ThreadContainerDedicated(Action`1<CallbackArgs> callback, Action disposeAndWaitCallback, bool isBackground, ThreadPriority priority, bool disposeOnShutdown);
    private void ThreadLoop();
    private void Quit();
    protected virtual void InternalStart();
    protected virtual void InternalStart_FromWorkerThread();
    protected virtual void InternalStart(int delay);
    protected virtual void InternalStart_FromWorkerThread(int delay);
    protected virtual void InternalCancelTimer();
    protected virtual void InternalDoNothing_FromWorkerThread();
    protected virtual void InternalDispose_FromWorkerThread();
}
internal class GSF.Threading.ThreadContainerThreadpool : ThreadContainerBase {
    private RegisteredWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) m_registeredHandle;
    private ManualResetEvent m_waitObject;
    public ThreadContainerThreadpool(Action`1<CallbackArgs> callback, Action disposeAndWaitCallback, bool disposeOnShutdown);
    protected virtual void InternalStart(int delay);
    protected virtual void InternalStart_FromWorkerThread(int delay);
    private void BeginRunOnTimer(object state, bool isTimeout);
    protected virtual void InternalCancelTimer();
    protected virtual void InternalStart();
    protected virtual void InternalStart_FromWorkerThread();
    private void BeginRunImmediately(object state);
    protected virtual void InternalDispose_FromWorkerThread();
    protected virtual void InternalDoNothing_FromWorkerThread();
}
public enum GSF.Threading.ThreadingMode : Enum {
    public int value__;
    public static ThreadingMode DedicatedForeground;
    public static ThreadingMode DedicatedBackground;
    public static ThreadingMode ThreadPool;
}
public enum GSF.Threading.ThreadStatus : Enum {
    public int value__;
    public static ThreadStatus Unstarted;
    public static ThreadStatus Queued;
    public static ThreadStatus Started;
    public static ThreadStatus Executing;
    public static ThreadStatus Completed;
    public static ThreadStatus Aborted;
}
public enum GSF.Threading.ThreadType : Enum {
    public int value__;
    public static ThreadType StandardThread;
    public static ThreadType QueuedThread;
}
[ExtensionAttribute]
public static class GSF.Threading.WaitHandleExtensions : object {
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, int timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, int timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool WaitAll(IEnumerable`1<ManualResetEventSlim> resetEvents, TimeSpan timeout, CancellationToken cancellationToken);
}
public class GSF.Threading.WeakAction : NullableWeakReference {
    private bool m_isStatic;
    private Action`1<object> m_compiledMethod;
    public WeakAction(Action callback);
    public bool TryInvoke();
    public virtual void Clear();
}
public class GSF.Threading.WeakAction`1 : NullableWeakReference {
    private bool m_isStatic;
    private Action`2<object, T> m_compiledMethod;
    public WeakAction`1(Action`1<T> callback);
    public bool TryInvoke(T param1);
    public virtual void Clear();
}
public class GSF.Ticks : ValueType {
    public static long PerSecond;
    public static long PerMillisecond;
    public static long PerMicrosecond;
    public static long PerMinute;
    public static long PerHour;
    public static long PerDay;
    public long Value;
    public static Ticks MaxValue;
    public static Ticks MinValue;
    public Ticks(long value);
    public Ticks(DateTime value);
    public Ticks(TimeSpan value);
    private static Ticks();
    public double ToDays();
    public double ToHours();
    public double ToMinutes();
    public double ToSeconds();
    public double ToMilliseconds();
    public double ToMicroseconds();
    public bool UtcTimeIsValid(double lagTime, double leadTime);
    public bool UtcTimeIsValid(Ticks lagTime, Ticks leadTime);
    public bool LocalTimeIsValid(double lagTime, double leadTime);
    public bool LocalTimeIsValid(Ticks lagTime, Ticks leadTime);
    public bool TimeIsValid(Ticks currentTime, double lagTime, double leadTime);
    public bool TimeIsValid(Ticks currentTime, Ticks lagTime, Ticks leadTime);
    public Ticks DistanceBeyondSecond();
    public Ticks BaselinedTimestamp(BaselineTimeInterval interval);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public string ToElapsedTimeString();
    public string ToElapsedTimeString(int secondPrecision, double minimumSubSecondResolution);
    public string ToElapsedTimeString(int secondPrecision, String[] timeNames, double minimumSubSecondResolution);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Ticks value);
    public sealed virtual int CompareTo(DateTime value);
    public sealed virtual int CompareTo(TimeSpan value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Ticks obj);
    public sealed virtual bool Equals(DateTime obj);
    public sealed virtual bool Equals(TimeSpan obj);
    public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Ticks value1, Ticks value2);
    public static bool op_Inequality(Ticks value1, Ticks value2);
    public static bool op_LessThan(Ticks value1, Ticks value2);
    public static bool op_LessThanOrEqual(Ticks value1, Ticks value2);
    public static bool op_GreaterThan(Ticks value1, Ticks value2);
    public static bool op_GreaterThanOrEqual(Ticks value1, Ticks value2);
    public static Ticks op_Implicit(long value);
    public static Ticks op_Implicit(DateTime value);
    public static Ticks op_Implicit(TimeSpan value);
    public static Ticks op_Implicit(TimeTagBase value);
    public static long op_Implicit(Ticks value);
    public static DateTime op_Implicit(Ticks value);
    public static TimeSpan op_Implicit(Ticks value);
    public static NtpTimeTag op_Implicit(Ticks value);
    public static UnixTimeTag op_Implicit(Ticks value);
    public static bool op_True(Ticks value);
    public static bool op_False(Ticks value);
    public static Ticks op_OnesComplement(Ticks value);
    public static Ticks op_BitwiseAnd(Ticks value1, Ticks value2);
    public static Ticks op_BitwiseOr(Ticks value1, Ticks value2);
    public static Ticks op_ExclusiveOr(Ticks value1, Ticks value2);
    public static Ticks op_RightShift(Ticks value, int shifts);
    public static Ticks op_LeftShift(Ticks value, int shifts);
    public static Ticks op_Modulus(Ticks value1, Ticks value2);
    public static Ticks op_Addition(Ticks value1, Ticks value2);
    public static Ticks op_Subtraction(Ticks value1, Ticks value2);
    public static Ticks op_Multiply(Ticks value1, Ticks value2);
    public static Ticks op_Division(Ticks value1, Ticks value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Ticks value1, Ticks value2);
    public static double ToSeconds(Ticks value);
    public static double ToMilliseconds(Ticks value);
    public static double ToMicroseconds(Ticks value);
    public static Ticks FromSeconds(double value);
    public static Ticks FromMilliseconds(double value);
    public static Ticks FromMicroseconds(double value);
    public static Ticks Parse(string s);
    public static Ticks Parse(string s, NumberStyles style);
    public static Ticks Parse(string s, IFormatProvider provider);
    public static Ticks Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Ticks& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Ticks& result);
    public static Ticks[] SubsecondDistribution(int samplesPerSecond);
    public static Int32[] MillisecondDistribution(int samplesPerSecond);
    public static Int32[] MicrosecondDistribution(int samplesPerSecond);
    public static Ticks AlignToSubsecondDistribution(Ticks timestamp, int samplesPerSecond, long timeResolution);
    public static Ticks AlignToMillisecondDistribution(Ticks timestamp, int samplesPerSecond);
    public static Ticks AlignToMicrosecondDistribution(Ticks timestamp, int samplesPerSecond);
    public static Ticks RoundToSubsecondDistribution(Ticks timestamp, int samplesPerSecond);
    public static Ticks RoundToSecondDistribution(Ticks timestamp, double samplesPerSecond, Ticks Baseline);
    public static Ticks ToSecondDistribution(Ticks timestamp, double samplesPerSecond, Ticks baseline, int tolerance);
}
public class GSF.TimerCapabilities : ValueType {
    public int PeriodMinimum;
    public int PeriodMaximum;
}
public class GSF.TimerStartException : Exception {
    public TimerStartException(string message);
}
[ExtensionAttribute]
public static class GSF.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static string ToElapsedTimeString(TimeSpan value, int secondPrecision, double minimumSubSecondResolution);
}
public abstract class GSF.TimeTagBase : object {
    public static string DefaultFormat;
    private long m_baseDateOffsetTicks;
    private decimal m_seconds;
    public decimal Value { get; }
    public long BaseDateOffsetTicks { get; }
    protected TimeTagBase(long baseDateOffsetTicks, decimal seconds);
    protected TimeTagBase(long baseDateOffsetTicks, Ticks timestamp);
    protected TimeTagBase(SerializationInfo info, StreamingContext context);
    public virtual decimal get_Value();
    public virtual long get_BaseDateOffsetTicks();
    public virtual DateTime ToDateTime();
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual int CompareTo(TimeTagBase other);
    public sealed virtual int CompareTo(DateTime other);
    public virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TimeTagBase other);
    public sealed virtual bool Equals(DateTime other);
    public virtual int GetHashCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(TimeTagBase value1, TimeTagBase value2);
    public static bool op_Equality(DateTime value1, TimeTagBase value2);
    public static bool op_Equality(TimeTagBase value1, DateTime value2);
    public static bool op_Inequality(TimeTagBase value1, TimeTagBase value2);
    public static bool op_Inequality(DateTime value1, TimeTagBase value2);
    public static bool op_Inequality(TimeTagBase value1, DateTime value2);
    public static bool op_LessThan(TimeTagBase value1, TimeTagBase value2);
    public static bool op_LessThan(DateTime value1, TimeTagBase value2);
    public static bool op_LessThan(TimeTagBase value1, DateTime value2);
    public static bool op_LessThanOrEqual(TimeTagBase value1, TimeTagBase value2);
    public static bool op_LessThanOrEqual(DateTime value1, TimeTagBase value2);
    public static bool op_LessThanOrEqual(TimeTagBase value1, DateTime value2);
    public static bool op_GreaterThan(TimeTagBase value1, TimeTagBase value2);
    public static bool op_GreaterThan(DateTime value1, TimeTagBase value2);
    public static bool op_GreaterThan(TimeTagBase value1, DateTime value2);
    public static bool op_GreaterThanOrEqual(TimeTagBase value1, TimeTagBase value2);
    public static bool op_GreaterThanOrEqual(DateTime value1, TimeTagBase value2);
    public static bool op_GreaterThanOrEqual(TimeTagBase value1, DateTime value2);
}
public class GSF.Trackable`1 : object {
    private string m_propertyName;
    private T m_initialValue;
    private List`1<T> m_changeList;
    private bool m_autoTrack;
    public string PropertyName { get; }
    public T CurrentValue { get; public set; }
    public T OriginalValue { get; }
    public bool IsChanged { get; }
    public List`1<T> ChangeList { get; }
    private object GSF.ITrackable.OriginalValue { get; }
    private object GSF.ITrackable.CurrentValue { get; }
    public Trackable`1(string propertyName, bool autoTrack);
    public Trackable`1(string propertyName, T initialValue, bool autoTrack);
    public sealed virtual string get_PropertyName();
    public T get_CurrentValue();
    public void set_CurrentValue(T value);
    public T get_OriginalValue();
    public sealed virtual bool get_IsChanged();
    public List`1<T> get_ChangeList();
    private sealed virtual override object GSF.ITrackable.get_OriginalValue();
    private sealed virtual override object GSF.ITrackable.get_CurrentValue();
    public void SetCurrentValue(T value, bool overwrite);
    public sealed virtual void AcceptChanges();
    public sealed virtual void Revert();
    public sealed virtual void Reset();
    public virtual string ToString();
}
public class GSF.TransformEqualityComparer`1 : object {
    private Func`2<T, object> m_transformFunction;
    public TransformEqualityComparer`1(Func`2<T, object> transformFunction);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    private object Transform(T obj);
}
[ExtensionAttribute]
public static class GSF.TypeExtensions : object {
    private static Type[] s_numericTypes;
    private static Regex s_validCSharpIdentifierRegex;
    private static TypeExtensions();
    [ExtensionAttribute]
public static List`1<Type> LoadImplementations(Type type);
    [ExtensionAttribute]
public static List`1<Type> LoadImplementations(Type type, bool excludeAbstractTypes);
    [ExtensionAttribute]
public static List`1<Type> LoadImplementations(Type type, string binariesDirectory);
    [ExtensionAttribute]
public static List`1<Type> LoadImplementations(Type type, string binariesDirectory, bool excludeAbstractTypes, bool validateReferences, bool executeStaticConstructors);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static string GetFriendlyClassName(Type type);
    [ExtensionAttribute]
public static Type GetRootType(Type type);
    [ExtensionAttribute]
public static string GetReflectedTypeName(Type type, bool includeNamespaces);
    [ExtensionAttribute]
private static string GetReflectedTypeName(Type type, bool includeNamespaces, Stack`1<Type> genericArgs, StringBuilder arrayBrackets);
    [CompilerGeneratedAttribute]
internal static bool <GetReflectedTypeName>g__isValidCSharpIdentifier|10_0(char identifier);
}
public class GSF.UInt24 : ValueType {
    private static UInt32 MaxValue32;
    private static UInt32 MinValue32;
    public static UInt32 BitMask;
    private UInt32 m_value;
    public static UInt24 MaxValue;
    public static UInt24 MinValue;
    public UInt24(UInt24 value);
    public UInt24(UInt32 value);
    public UInt24(Byte[] value, int startIndex);
    private static UInt24();
    public Byte[] GetBytes();
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt24 value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt24 obj);
    public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static UInt24 Parse(string s);
    public static UInt24 Parse(string s, NumberStyles style);
    public static UInt24 Parse(string s, IFormatProvider provider);
    public static UInt24 Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, UInt24& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt24& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(UInt24 value1, UInt24 value2);
    public static bool op_Equality(UInt32 value1, UInt24 value2);
    public static bool op_Equality(UInt24 value1, UInt32 value2);
    public static bool op_Inequality(UInt24 value1, UInt24 value2);
    public static bool op_Inequality(UInt32 value1, UInt24 value2);
    public static bool op_Inequality(UInt24 value1, UInt32 value2);
    public static bool op_LessThan(UInt24 value1, UInt24 value2);
    public static bool op_LessThan(UInt32 value1, UInt24 value2);
    public static bool op_LessThan(UInt24 value1, UInt32 value2);
    public static bool op_LessThanOrEqual(UInt24 value1, UInt24 value2);
    public static bool op_LessThanOrEqual(UInt32 value1, UInt24 value2);
    public static bool op_LessThanOrEqual(UInt24 value1, UInt32 value2);
    public static bool op_GreaterThan(UInt24 value1, UInt24 value2);
    public static bool op_GreaterThan(UInt32 value1, UInt24 value2);
    public static bool op_GreaterThan(UInt24 value1, UInt32 value2);
    public static bool op_GreaterThanOrEqual(UInt24 value1, UInt24 value2);
    public static bool op_GreaterThanOrEqual(UInt32 value1, UInt24 value2);
    public static bool op_GreaterThanOrEqual(UInt24 value1, UInt32 value2);
    public static UInt24 op_Explicit(Enum value);
    public static UInt24 op_Explicit(string value);
    public static UInt24 op_Explicit(decimal value);
    public static UInt24 op_Explicit(double value);
    public static UInt24 op_Explicit(float value);
    public static UInt24 op_Explicit(ulong value);
    public static UInt24 op_Explicit(UInt32 value);
    public static UInt24 op_Explicit(Int24 value);
    public static Int24 op_Explicit(UInt24 value);
    public static short op_Explicit(UInt24 value);
    public static ushort op_Explicit(UInt24 value);
    public static byte op_Explicit(UInt24 value);
    public static UInt24 op_Implicit(byte value);
    public static UInt24 op_Implicit(char value);
    public static UInt24 op_Implicit(ushort value);
    public static int op_Implicit(UInt24 value);
    public static UInt32 op_Implicit(UInt24 value);
    public static long op_Implicit(UInt24 value);
    public static ulong op_Implicit(UInt24 value);
    public static double op_Implicit(UInt24 value);
    public static float op_Implicit(UInt24 value);
    public static decimal op_Implicit(UInt24 value);
    public static string op_Implicit(UInt24 value);
    public static bool op_True(UInt24 value);
    public static bool op_False(UInt24 value);
    public static UInt24 op_OnesComplement(UInt24 value);
    public static UInt24 op_BitwiseAnd(UInt24 value1, UInt24 value2);
    public static UInt32 op_BitwiseAnd(UInt32 value1, UInt24 value2);
    public static UInt32 op_BitwiseAnd(UInt24 value1, UInt32 value2);
    public static UInt24 op_BitwiseOr(UInt24 value1, UInt24 value2);
    public static UInt32 op_BitwiseOr(UInt32 value1, UInt24 value2);
    public static UInt32 op_BitwiseOr(UInt24 value1, UInt32 value2);
    public static UInt24 op_ExclusiveOr(UInt24 value1, UInt24 value2);
    public static UInt32 op_ExclusiveOr(UInt32 value1, UInt24 value2);
    public static UInt32 op_ExclusiveOr(UInt24 value1, UInt32 value2);
    public static UInt24 op_RightShift(UInt24 value, int shifts);
    public static UInt24 op_LeftShift(UInt24 value, int shifts);
    public static UInt24 op_Modulus(UInt24 value1, UInt24 value2);
    public static UInt32 op_Modulus(UInt32 value1, UInt24 value2);
    public static UInt32 op_Modulus(UInt24 value1, UInt32 value2);
    public static UInt24 op_Addition(UInt24 value1, UInt24 value2);
    public static UInt32 op_Addition(UInt32 value1, UInt24 value2);
    public static UInt32 op_Addition(UInt24 value1, UInt32 value2);
    public static UInt24 op_Subtraction(UInt24 value1, UInt24 value2);
    public static UInt32 op_Subtraction(UInt32 value1, UInt24 value2);
    public static UInt32 op_Subtraction(UInt24 value1, UInt32 value2);
    public static UInt24 op_Increment(UInt24 value);
    public static UInt24 op_Decrement(UInt24 value);
    public static UInt24 op_Multiply(UInt24 value1, UInt24 value2);
    public static UInt32 op_Multiply(UInt32 value1, UInt24 value2);
    public static UInt32 op_Multiply(UInt24 value1, UInt32 value2);
    public static UInt24 op_Division(UInt24 value1, UInt24 value2);
    public static UInt32 op_Division(UInt32 value1, UInt24 value2);
    public static UInt32 op_Division(UInt24 value1, UInt32 value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(UInt24 value1, UInt24 value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(int value1, UInt24 value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(UInt24 value1, int value2);
    public static Byte[] GetBytes(UInt24 value);
    public static UInt24 GetValue(Byte[] value, int startIndex);
    private static void ValidateNumericRange(UInt32 value);
    private static UInt32 ApplyBitMask(UInt32 value);
}
public class GSF.Units.Angle : ValueType {
    private static double DegreesFactor;
    private static double GradsFactor;
    private static double ArcMinutesFactor;
    private static double ArcSecondsFactor;
    private static double AngularMilFactor;
    private static double TwoPI;
    private double m_value;
    public static Angle MaxValue;
    public static Angle MinValue;
    public Angle(double value);
    private static Angle();
    public double ToDegrees();
    public double ToGrads();
    public double ToArcMinutes();
    public double ToArcSeconds();
    public double ToAngularMil();
    public double ConvertTo(AngleUnit targetUnit);
    public Angle ToRange(Angle minValue, bool inclusive);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Angle value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Angle obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Angle Parse(string s);
    public static Angle Parse(string s, NumberStyles style);
    public static Angle Parse(string s, IFormatProvider provider);
    public static Angle Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Angle& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Angle& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Angle value1, Angle value2);
    public static bool op_Inequality(Angle value1, Angle value2);
    public static bool op_LessThan(Angle value1, Angle value2);
    public static bool op_LessThanOrEqual(Angle value1, Angle value2);
    public static bool op_GreaterThan(Angle value1, Angle value2);
    public static bool op_GreaterThanOrEqual(Angle value1, Angle value2);
    public static Angle op_Implicit(double value);
    public static double op_Implicit(Angle value);
    public static Angle op_Modulus(Angle value1, Angle value2);
    public static Angle op_Addition(Angle value1, Angle value2);
    public static Angle op_Subtraction(Angle value1, Angle value2);
    public static Angle op_Multiply(Angle value1, Angle value2);
    public static Angle op_Division(Angle value1, Angle value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Angle value1, Angle value2);
    public static Angle FromDegrees(double value);
    public static Angle FromGrads(double value);
    public static Angle FromArcMinutes(double value);
    public static Angle FromArcSeconds(double value);
    public static Angle FromAngularMil(double value);
    public static Angle ConvertFrom(double value, AngleUnit sourceUnit);
    public static IEnumerable`1<Angle> Unwrap(IEnumerable`1<Angle> source);
    public static Angle Average(IEnumerable`1<Angle> source);
    private static Double[] Unwrap(Double[] sourceAngles);
}
public enum GSF.Units.AngleUnit : Enum {
    public int value__;
    public static AngleUnit Radians;
    public static AngleUnit Degrees;
    public static AngleUnit Grads;
    public static AngleUnit ArcMinutes;
    public static AngleUnit ArcSeconds;
    public static AngleUnit AngularMil;
}
public class GSF.Units.Charge : ValueType {
    private static double AmpereHoursFactor;
    private static double AbcoulombsFactor;
    private static double StatcoulombsFactor;
    private static double AtomicUnitsOfChargeFactor;
    private static double FaradayFactor;
    private double m_value;
    public static Charge MaxValue;
    public static Charge MinValue;
    public Charge(double value);
    private static Charge();
    public double ToAmpereHours();
    public double ToAbcoulombs();
    public double ToStatcoulombs();
    public double ToAtomicUnitsOfCharge();
    public double ToFaraday();
    public double ConvertTo(ChargeUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Charge value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Charge obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Charge Parse(string s);
    public static Charge Parse(string s, NumberStyles style);
    public static Charge Parse(string s, IFormatProvider provider);
    public static Charge Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Charge& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Charge& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Charge value1, Charge value2);
    public static bool op_Inequality(Charge value1, Charge value2);
    public static bool op_LessThan(Charge value1, Charge value2);
    public static bool op_LessThanOrEqual(Charge value1, Charge value2);
    public static bool op_GreaterThan(Charge value1, Charge value2);
    public static bool op_GreaterThanOrEqual(Charge value1, Charge value2);
    public static Charge op_Implicit(double value);
    public static double op_Implicit(Charge value);
    public static Charge op_Modulus(Charge value1, Charge value2);
    public static Charge op_Addition(Charge value1, Charge value2);
    public static Charge op_Subtraction(Charge value1, Charge value2);
    public static Charge op_Multiply(Charge value1, Charge value2);
    public static Charge op_Division(Charge value1, Charge value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Charge value1, Charge value2);
    public static Charge FromAmpereHours(double value);
    public static Charge FromAbcoulombs(double value);
    public static Charge FromStatcoulombs(double value);
    public static Charge FromAtomicUnitsOfCharge(double value);
    public static Charge FromFaraday(double value);
    public static Charge ConvertFrom(double value, ChargeUnit sourceUnit);
}
public enum GSF.Units.ChargeUnit : Enum {
    public int value__;
    public static ChargeUnit Coulombs;
    public static ChargeUnit AmpereHours;
    public static ChargeUnit Abcoulombs;
    public static ChargeUnit Statcoulombs;
    public static ChargeUnit AtomicUnitsOfCharge;
    public static ChargeUnit Faraday;
}
public class GSF.Units.Current : ValueType {
    private static double AbamperesFactor;
    private static double StatamperesFactor;
    private double m_value;
    public static Current MaxValue;
    public static Current MinValue;
    public Current(double value);
    private static Current();
    public double ToAbamperes();
    public double ToStatamperes();
    public double ConvertTo(CurrentUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Current value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Current obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Current Parse(string s);
    public static Current Parse(string s, NumberStyles style);
    public static Current Parse(string s, IFormatProvider provider);
    public static Current Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Current& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Current& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Current value1, Current value2);
    public static bool op_Inequality(Current value1, Current value2);
    public static bool op_LessThan(Current value1, Current value2);
    public static bool op_LessThanOrEqual(Current value1, Current value2);
    public static bool op_GreaterThan(Current value1, Current value2);
    public static bool op_GreaterThanOrEqual(Current value1, Current value2);
    public static Current op_Implicit(double value);
    public static double op_Implicit(Current value);
    public static Current op_Modulus(Current value1, Current value2);
    public static Current op_Addition(Current value1, Current value2);
    public static Current op_Subtraction(Current value1, Current value2);
    public static Current op_Multiply(Current value1, Current value2);
    public static Current op_Division(Current value1, Current value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Current value1, Current value2);
    public static Current FromAbamperes(double value);
    public static Current FromStatamperes(double value);
    public static Current ConvertFrom(double value, CurrentUnit sourceUnit);
}
public enum GSF.Units.CurrentUnit : Enum {
    public int value__;
    public static CurrentUnit Amperes;
    public static CurrentUnit Abamperes;
    public static CurrentUnit Statamperes;
}
public static class GSF.Units.EE.CommonVoltageLevels : object {
    public static String[] Values;
    private static CommonVoltageLevels();
}
public enum GSF.Units.EE.LineFrequency : Enum {
    public int value__;
    [DescriptionAttribute("Selects 50Hz as the nominal system frequency")]
public static LineFrequency Hz50;
    [DescriptionAttribute("Selects 60Hz as the nominal system frequency")]
public static LineFrequency Hz60;
}
[CompilerGeneratedAttribute]
internal class GSF.Units.EE.NamespaceDoc : object {
}
public class GSF.Units.EE.Phasor : ValueType {
    public PhasorType Type;
    public ComplexNumber Value;
    public ComplexNumber Conjugate { get; }
    public Phasor(PhasorType type, double real, double imaginary);
    public Phasor(PhasorType type, Angle angle, double magnitude);
    public Phasor(PhasorType type, ComplexNumber z);
    public ComplexNumber get_Conjugate();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Phasor obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ComplexNumber op_Implicit(Phasor phasor);
    public static Complex op_Implicit(Phasor phasor);
    public static bool op_Equality(Phasor phasor1, Phasor phasor2);
    public static bool op_Inequality(Phasor phasor1, Phasor phasor2);
    public static Phasor op_UnaryNegation(Phasor z);
    public static Phasor op_Addition(Phasor phasor1, Phasor phasor2);
    public static Phasor op_Subtraction(Phasor phasor1, Phasor phasor2);
    public static Phasor op_Multiply(Phasor phasor1, Phasor phasor2);
    public static Phasor op_Division(Phasor phasor1, Phasor phasor2);
    public static Phasor Pow(Phasor z, double y);
    [EditorBrowsableAttribute("2")]
public static Phasor op_Exponent(Phasor z, double y);
    public static Power CalculateActivePower(Phasor voltage, Phasor current);
    public static Power CalculateReactivePower(Phasor voltage, Phasor current);
    public static ComplexNumber CalculateComplexPower(Phasor voltage, Phasor current);
    public static Power CalculateApparentPower(Phasor voltage, Phasor current);
    public static Angle CalculateRelativePhase(Phasor voltage, Phasor current);
}
public enum GSF.Units.EE.PhasorType : Enum {
    public byte value__;
    public static PhasorType Voltage;
    public static PhasorType Current;
}
public enum GSF.Units.EE.SignalKind : Enum {
    public int value__;
    public static SignalKind Angle;
    public static SignalKind Magnitude;
    public static SignalKind Frequency;
    public static SignalKind DfDt;
    public static SignalKind Status;
    public static SignalKind Digital;
    public static SignalKind Analog;
    public static SignalKind Calculation;
    public static SignalKind Statistic;
    public static SignalKind Alarm;
    public static SignalKind Quality;
    public static SignalKind Unknown;
}
[ExtensionAttribute]
public static class GSF.Units.EE.SignalKindExtensions : object {
    [ExtensionAttribute]
public static string GetAcronym(SignalKind signal);
    [ExtensionAttribute]
public static SignalKind ParseSignalKind(string acronym);
}
public class GSF.Units.EE.SignalReference : ValueType {
    public string Acronym;
    public int Index;
    public SignalKind Kind;
    public int CellIndex;
    public SignalReference(string signal);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignalReference other);
    public sealed virtual int CompareTo(SignalReference other);
    public int CompareTo(object obj);
    public static bool op_Equality(SignalReference signal1, SignalReference signal2);
    public static bool op_Inequality(SignalReference signal1, SignalReference signal2);
    public static bool op_GreaterThan(SignalReference signal1, SignalReference signal2);
    public static bool op_GreaterThanOrEqual(SignalReference signal1, SignalReference signal2);
    public static bool op_LessThan(SignalReference signal1, SignalReference signal2);
    public static bool op_LessThanOrEqual(SignalReference signal1, SignalReference signal2);
    public static string ToString(string acronym, SignalKind type);
    public static string ToString(string acronym, SignalKind type, int index);
}
public enum GSF.Units.EE.SignalType : Enum {
    public int value__;
    public static SignalType IPHM;
    public static SignalType IPHA;
    public static SignalType VPHM;
    public static SignalType VPHA;
    public static SignalType FREQ;
    public static SignalType DFDT;
    public static SignalType ALOG;
    public static SignalType FLAG;
    public static SignalType DIGI;
    public static SignalType CALC;
    public static SignalType STAT;
    public static SignalType ALRM;
    public static SignalType QUAL;
    public static SignalType NONE;
}
[ExtensionAttribute]
public static class GSF.Units.EE.SignalTypeExtensions : object {
    [ExtensionAttribute]
public static string GetFormattedName(SignalType signalType);
}
public enum GSF.Units.EE.VoltageLevel : Enum {
    public byte value__;
    [DescriptionAttribute("44")]
public static VoltageLevel kV44;
    [DescriptionAttribute("69")]
public static VoltageLevel kV69;
    [DescriptionAttribute("115")]
public static VoltageLevel kV115;
    [DescriptionAttribute("138")]
public static VoltageLevel kV138;
    [DescriptionAttribute("161")]
public static VoltageLevel kV161;
    [DescriptionAttribute("169")]
public static VoltageLevel kV169;
    [DescriptionAttribute("230")]
public static VoltageLevel kV230;
    [DescriptionAttribute("345")]
public static VoltageLevel kV345;
    [DescriptionAttribute("500")]
public static VoltageLevel kV500;
    [DescriptionAttribute("765")]
public static VoltageLevel kV765;
    [DescriptionAttribute("1100")]
public static VoltageLevel kV1100;
}
[ExtensionAttribute]
public static class GSF.Units.EE.VoltageLevelExtensions : object {
    internal static Dictionary`2<VoltageLevel, int> VoltageLevelMap;
    private static VoltageLevelExtensions();
    [ExtensionAttribute]
public static int Value(VoltageLevel level);
    [ExtensionAttribute]
public static bool TryGetVoltageLevel(int value, VoltageLevel& level);
}
public class GSF.Units.Energy : ValueType {
    private static double WattHoursFactor;
    private static double BTUFactor;
    private static double CelsiusHeatUnitsFactor;
    private static double LitersAtmosphereFactor;
    private static double CaloriesFactor;
    private static double HorsepowerHoursFactor;
    private static double BarrelsOfOilFactor;
    private static double TonsOfCoalFactor;
    private double m_value;
    public static Energy MaxValue;
    public static Energy MinValue;
    public Energy(double value);
    private static Energy();
    public Charge ToCoulombs(Voltage volts);
    public double ToWattHours();
    public double ToBTU();
    public double ToCelsiusHeatUnits();
    public double ToLitersAtmosphere();
    public double ToCalories();
    public double ToHorsepowerHours();
    public double ToBarrelsOfOil();
    public double ToTonsOfCoal();
    public double ConvertTo(EnergyUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Energy value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Energy obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Energy Parse(string s);
    public static Energy Parse(string s, NumberStyles style);
    public static Energy Parse(string s, IFormatProvider provider);
    public static Energy Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Energy& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Energy& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Energy value1, Energy value2);
    public static bool op_Inequality(Energy value1, Energy value2);
    public static bool op_LessThan(Energy value1, Energy value2);
    public static bool op_LessThanOrEqual(Energy value1, Energy value2);
    public static bool op_GreaterThan(Energy value1, Energy value2);
    public static bool op_GreaterThanOrEqual(Energy value1, Energy value2);
    public static Energy op_Implicit(double value);
    public static double op_Implicit(Energy value);
    public static Energy op_Modulus(Energy value1, Energy value2);
    public static Energy op_Addition(Energy value1, Energy value2);
    public static Energy op_Subtraction(Energy value1, Energy value2);
    public static Energy op_Multiply(Energy value1, Energy value2);
    public static Energy op_Division(Energy value1, Energy value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Energy value1, Energy value2);
    public static Energy FromWattHours(double value);
    public static Energy FromBTU(double value);
    public static Energy FromCelsiusHeatUnits(double value);
    public static Energy FromLitersAtmosphere(double value);
    public static Energy FromCalories(double value);
    public static Energy FromHorsepowerHours(double value);
    public static Energy FromBarrelsOfOil(double value);
    public static Energy FromTonOfCoal(double value);
    public static Energy ConvertFrom(double value, EnergyUnit sourceUnit);
}
public enum GSF.Units.EnergyUnit : Enum {
    public int value__;
    public static EnergyUnit Joules;
    public static EnergyUnit WattHours;
    public static EnergyUnit BTU;
    public static EnergyUnit CelsiusHeatUnits;
    public static EnergyUnit LitersAtmosphere;
    public static EnergyUnit Calories;
    public static EnergyUnit HorsepowerHours;
    public static EnergyUnit BarrelsOfOil;
    public static EnergyUnit TonsOfCoal;
}
public class GSF.Units.Length : ValueType {
    private static double FeetFactor;
    private static double InchesFactor;
    private static double MilesFactor;
    private static double LightSecondsFactor;
    private static double USSurveyFeetFactor;
    private static double USSurveyMilesFactor;
    private static double NauticalMilesFactor;
    private static double YardsFactor;
    private double m_value;
    public static Length MaxValue;
    public static Length MinValue;
    public Length(double value);
    private static Length();
    public double ToFeet();
    public double ToYards();
    public double ToInches();
    public double ToMiles();
    public double ToLightSeconds();
    public double ToUSSurveyFeet();
    public double ToUSSurveyMiles();
    public double ToNauticalMiles();
    public double ConvertTo(LengthUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Length value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Length obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Length Parse(string s);
    public static Length Parse(string s, NumberStyles style);
    public static Length Parse(string s, IFormatProvider provider);
    public static Length Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Length& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Length& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Length value1, Length value2);
    public static bool op_Inequality(Length value1, Length value2);
    public static bool op_LessThan(Length value1, Length value2);
    public static bool op_LessThanOrEqual(Length value1, Length value2);
    public static bool op_GreaterThan(Length value1, Length value2);
    public static bool op_GreaterThanOrEqual(Length value1, Length value2);
    public static Length op_Implicit(double value);
    public static double op_Implicit(Length value);
    public static Length op_Modulus(Length value1, Length value2);
    public static Length op_Addition(Length value1, Length value2);
    public static Length op_Subtraction(Length value1, Length value2);
    public static Length op_Multiply(Length value1, Length value2);
    public static Length op_Division(Length value1, Length value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Length value1, Length value2);
    public static Length FromFeet(double value);
    public static Length FromYards(double value);
    public static Length FromInches(double value);
    public static Length FromMiles(double value);
    public static Length FromLightSeconds(double value);
    public static Length FromUSSurveyFeet(double value);
    public static Length FromUSSurveyMiles(double value);
    public static Length FromNauticalMiles(double value);
    public static Length ConvertFrom(double value, LengthUnit sourceUnit);
}
public enum GSF.Units.LengthUnit : Enum {
    public int value__;
    public static LengthUnit Meters;
    public static LengthUnit Feet;
    public static LengthUnit Inches;
    public static LengthUnit Miles;
    public static LengthUnit LightSeconds;
    public static LengthUnit USSurveyFeet;
    public static LengthUnit USSurveyMiles;
    public static LengthUnit NauticalMiles;
    public static LengthUnit Yards;
}
public class GSF.Units.Mass : ValueType {
    private static double OuncesFactor;
    private static double PoundsFactor;
    private static double MetricPoundsFactor;
    private static double TonsFactor;
    private static double MetricTonsFactor;
    private static double LongTonsFactor;
    private double m_value;
    public static Mass MaxValue;
    public static Mass MinValue;
    public Mass(double value);
    private static Mass();
    public double ToOunces();
    public double ToPounds();
    public double ToMetricPounds();
    public double ToTons();
    public double ToMetricTons();
    public double ToLongTons();
    public double ConvertTo(MassUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Mass value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Mass obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Mass Parse(string s);
    public static Mass Parse(string s, NumberStyles style);
    public static Mass Parse(string s, IFormatProvider provider);
    public static Mass Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Mass& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Mass& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Mass value1, Mass value2);
    public static bool op_Inequality(Mass value1, Mass value2);
    public static bool op_LessThan(Mass value1, Mass value2);
    public static bool op_LessThanOrEqual(Mass value1, Mass value2);
    public static bool op_GreaterThan(Mass value1, Mass value2);
    public static bool op_GreaterThanOrEqual(Mass value1, Mass value2);
    public static Mass op_Implicit(double value);
    public static double op_Implicit(Mass value);
    public static Mass op_Modulus(Mass value1, Mass value2);
    public static Mass op_Addition(Mass value1, Mass value2);
    public static Mass op_Subtraction(Mass value1, Mass value2);
    public static Mass op_Multiply(Mass value1, Mass value2);
    public static Mass op_Division(Mass value1, Mass value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Mass value1, Mass value2);
    public static Mass FromOunces(double value);
    public static Mass FromPounds(double value);
    public static Mass FromMetricPounds(double value);
    public static Mass FromTons(double value);
    public static Mass FromMetricTons(double value);
    public static Mass FromLongTons(double value);
    public static Mass ConvertFrom(double value, MassUnit sourceUnit);
}
public enum GSF.Units.MassUnit : Enum {
    public int value__;
    public static MassUnit Kilograms;
    public static MassUnit Ounces;
    public static MassUnit Pounds;
    public static MassUnit MetricPounds;
    public static MassUnit Tons;
    public static MassUnit MectricTons;
    public static MassUnit LongTons;
}
[CompilerGeneratedAttribute]
internal class GSF.Units.NamespaceDoc : object {
}
public class GSF.Units.Power : ValueType {
    private static double HorsepowerFactor;
    private static double MetricHorsepowerFactor;
    private static double BoilerHorsepowerFactor;
    private static double BTUPerSecondFactor;
    private static double CaloriesPerSecondFactor;
    private static double LitersAtmospherePerSecondFactor;
    private double m_value;
    public static Power MaxValue;
    public static Power MinValue;
    public Power(double value);
    private static Power();
    public double ToHorsepower();
    public double ToMetricHorsepower();
    public double ToBoilerHorsepower();
    public double ToBTUPerSecond();
    public double ToCaloriesPerSecond();
    public double ToLitersAtmospherePerSecond();
    public double ConvertTo(PowerUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Power value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Power obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Power Parse(string s);
    public static Power Parse(string s, NumberStyles style);
    public static Power Parse(string s, IFormatProvider provider);
    public static Power Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Power& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Power& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Power value1, Power value2);
    public static bool op_Inequality(Power value1, Power value2);
    public static bool op_LessThan(Power value1, Power value2);
    public static bool op_LessThanOrEqual(Power value1, Power value2);
    public static bool op_GreaterThan(Power value1, Power value2);
    public static bool op_GreaterThanOrEqual(Power value1, Power value2);
    public static Power op_Implicit(double value);
    public static double op_Implicit(Power value);
    public static Power op_Modulus(Power value1, Power value2);
    public static Power op_Addition(Power value1, Power value2);
    public static Power op_Subtraction(Power value1, Power value2);
    public static Power op_Multiply(Power value1, Power value2);
    public static Power op_Division(Power value1, Power value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Power value1, Power value2);
    public static Power FromHorsepower(double value);
    public static Power FromMetricHorsepower(double value);
    public static Power FromBoilerHorsepower(double value);
    public static Power FromBTUPerSecond(double value);
    public static Power FromCaloriesPerSecond(double value);
    public static Power FromLitersAtmospherePerSecond(double value);
    public static Power ConvertFrom(double value, PowerUnit sourceUnit);
}
public enum GSF.Units.PowerUnit : Enum {
    public int value__;
    public static PowerUnit Watts;
    public static PowerUnit Horsepower;
    public static PowerUnit MetricHorsepower;
    public static PowerUnit BoilerHorsepower;
    public static PowerUnit BTUPerSecond;
    public static PowerUnit CaloriesPerSecond;
    public static PowerUnit LitersAtmospherePerSecond;
}
public static class GSF.Units.SI : object {
    private static String[] s_names;
    private static String[] s_symbols;
    private static Double[] s_factors;
    public static double Yotta;
    public static double Zetta;
    public static double Exa;
    public static double Peta;
    public static double Tera;
    public static double Giga;
    public static double Mega;
    public static double Kilo;
    public static double Hecto;
    public static double Deca;
    public static double Deci;
    public static double Centi;
    public static double Milli;
    public static double Micro;
    public static double Nano;
    public static double Pico;
    public static double Femto;
    public static double Atto;
    public static double Zepto;
    public static double Yocto;
    public static String[] Names { get; }
    public static String[] Symbols { get; }
    public static Double[] Factors { get; }
    private static SI();
    public static String[] get_Names();
    public static String[] get_Symbols();
    public static Double[] get_Factors();
    public static string ToScaledString(double totalUnits, string unitName, String[] symbolNames, double minimumFactor, double maximumFactor);
    public static string ToScaledString(double totalUnits, string format, string unitName, double minimumFactor, double maximumFactor);
    public static string ToScaledString(double totalUnits, int decimalPlaces, string unitName, String[] symbolNames, double minimumFactor, double maximumFactor);
    public static string ToScaledString(double totalUnits, string format, string unitName, String[] symbolNames, int decimalPlaces, double minimumFactor, double maximumFactor);
    private static int GetFactorIndex(double factor);
}
public static class GSF.Units.SI2 : object {
    private static String[] s_names;
    private static String[] s_symbols;
    private static String[] s_iecNames;
    private static String[] s_iecSymbols;
    private static Int64[] s_factors;
    public static long Exa;
    public static long Exbi;
    public static long Peta;
    public static long Pebi;
    public static long Tera;
    public static long Tebi;
    public static long Giga;
    public static long Gibi;
    public static long Mega;
    public static long Mebi;
    public static long Kilo;
    public static long Kibi;
    public static String[] Names { get; }
    public static String[] Symbols { get; }
    public static String[] IECNames { get; }
    public static String[] IECSymbols { get; }
    public static Int64[] Factors { get; }
    private static SI2();
    public static String[] get_Names();
    public static String[] get_Symbols();
    public static String[] get_IECNames();
    public static String[] get_IECSymbols();
    public static Int64[] get_Factors();
    public static string ToScaledString(long totalUnits, string unitName, String[] symbolNames, long minimumFactor, long maximumFactor);
    public static string ToScaledString(long totalUnits, string format, string unitName, long minimumFactor, long maximumFactor);
    public static string ToScaledString(long totalUnits, int decimalPlaces, string unitName, String[] symbolNames, long minimumFactor, long maximumFactor);
    public static string ToScaledString(long totalUnits, string format, string unitName, String[] symbolNames, int decimalPlaces, long minimumFactor, long maximumFactor);
    private static int GetFactorIndex(long factor);
}
public class GSF.Units.Speed : ValueType {
    private static double MilesPerHourFactor;
    private static double KilometersPerHourFactor;
    private static double FeetPerMinuteFactor;
    private static double InchesPerSecondFactor;
    private static double KnotsFactor;
    private static double MachFactor;
    private double m_value;
    public static Speed MaxValue;
    public static Speed MinValue;
    public Speed(double value);
    private static Speed();
    public double ToMilesPerHour();
    public double ToKilometersPerHour();
    public double ToFeetPerMinute();
    public double ToInchesPerSecond();
    public double ToKnots();
    public double ToMach();
    public double ConvertTo(SpeedUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Speed value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Speed obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Speed Parse(string s);
    public static Speed Parse(string s, NumberStyles style);
    public static Speed Parse(string s, IFormatProvider provider);
    public static Speed Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Speed& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Speed& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Speed value1, Speed value2);
    public static bool op_Inequality(Speed value1, Speed value2);
    public static bool op_LessThan(Speed value1, Speed value2);
    public static bool op_LessThanOrEqual(Speed value1, Speed value2);
    public static bool op_GreaterThan(Speed value1, Speed value2);
    public static bool op_GreaterThanOrEqual(Speed value1, Speed value2);
    public static Speed op_Implicit(double value);
    public static double op_Implicit(Speed value);
    public static Speed op_Modulus(Speed value1, Speed value2);
    public static Speed op_Addition(Speed value1, Speed value2);
    public static Speed op_Subtraction(Speed value1, Speed value2);
    public static Speed op_Multiply(Speed value1, Speed value2);
    public static Speed op_Division(Speed value1, Speed value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Speed value1, Speed value2);
    public static Speed FromMilesPerHour(double value);
    public static Speed FromKilometersPerHour(double value);
    public static Speed FromFeetPerMinute(double value);
    public static Speed FromInchesPerSecond(double value);
    public static Speed FromKnots(double value);
    public static Speed FromMach(double value);
    public static Speed ConvertFrom(double value, SpeedUnit sourceUnit);
}
public enum GSF.Units.SpeedUnit : Enum {
    public int value__;
    public static SpeedUnit MetersPerSecond;
    public static SpeedUnit MilesPerHour;
    public static SpeedUnit KilometersPerHour;
    public static SpeedUnit FeetPerMinute;
    public static SpeedUnit InchesPerSecond;
    public static SpeedUnit Knots;
    public static SpeedUnit Mach;
}
public class GSF.Units.Temperature : ValueType {
    private static double CelsiusFactor;
    private static double CelsiusOffset;
    private static double CelsiusStep;
    private static double FahrenheitFactor;
    private static double FahrenheitOffset;
    private static double FahrenheitStep;
    private static double NewtonFactor;
    private static double NewtonOffset;
    private static double NewtonStep;
    private static double RankineFactor;
    private static double RankineOffset;
    private static double RankineStep;
    private static double DelisleFactor;
    private static double DelisleOffset;
    private static double DelisleStep;
    private static double RéaumurFactor;
    private static double RéaumurOffset;
    private static double RéaumurStep;
    private static double RømerFactor;
    private static double RømerOffset;
    private static double RømerStep;
    private double m_value;
    public static Temperature MaxValue;
    public static Temperature MinValue;
    public Temperature(double value);
    private static Temperature();
    public double ToCelsius();
    public double ToFahrenheit();
    public double ToNewton();
    public double ToRankine();
    public double ToDelisle();
    public double ToRéaumur();
    public double ToRømer();
    public double ConvertTo(TemperatureUnit targetUnit);
    private Temperature ToTemperature(double factor, double offset, double step);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Temperature value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Temperature obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Temperature Parse(string s);
    public static Temperature Parse(string s, NumberStyles style);
    public static Temperature Parse(string s, IFormatProvider provider);
    public static Temperature Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Temperature& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Temperature& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Temperature value1, Temperature value2);
    public static bool op_Inequality(Temperature value1, Temperature value2);
    public static bool op_LessThan(Temperature value1, Temperature value2);
    public static bool op_LessThanOrEqual(Temperature value1, Temperature value2);
    public static bool op_GreaterThan(Temperature value1, Temperature value2);
    public static bool op_GreaterThanOrEqual(Temperature value1, Temperature value2);
    public static Temperature op_Implicit(double value);
    public static double op_Implicit(Temperature value);
    public static Temperature op_Modulus(Temperature value1, Temperature value2);
    public static Temperature op_Addition(Temperature value1, Temperature value2);
    public static Temperature op_Subtraction(Temperature value1, Temperature value2);
    public static Temperature op_Multiply(Temperature value1, Temperature value2);
    public static Temperature op_Division(Temperature value1, Temperature value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Temperature value1, Temperature value2);
    public static Temperature FromCelsius(double value);
    public static Temperature FromFahrenheit(double value);
    public static Temperature FromNewton(double value);
    public static Temperature FromRankine(double value);
    public static Temperature FromDelisle(double value);
    public static Temperature FromRéaumur(double value);
    public static Temperature FromRømer(double value);
    public static Temperature ConvertFrom(double value, TemperatureUnit sourceUnit);
    private static Temperature FromTemperature(double value, double factor, double offset, double step);
}
public enum GSF.Units.TemperatureUnit : Enum {
    public int value__;
    public static TemperatureUnit Kelvin;
    public static TemperatureUnit Celsius;
    public static TemperatureUnit Fahrenheit;
    public static TemperatureUnit Newton;
    public static TemperatureUnit Rankine;
    public static TemperatureUnit Delisle;
    public static TemperatureUnit Réaumur;
    public static TemperatureUnit Rømer;
}
public class GSF.Units.Time : ValueType {
    private static double AtomicUnitsOfTimeFactor;
    private static double PlanckTimeFactor;
    private static double KeFactor;
    public static double SecondsPerTick;
    public static int SecondsPerMinute;
    public static int SecondsPerHour;
    public static int SecondsPerDay;
    public static int SecondsPerWeek;
    private double m_value;
    public static Time MaxValue;
    public static Time MinValue;
    public static String[] TimeNames;
    public Time(double value);
    public Time(TimeSpan value);
    private static Time();
    public double ToAtomicUnitsOfTime();
    public double ToPlanckTime();
    public double ToKe();
    public double ToMinutes();
    public double ToHours();
    public double ToDays();
    public double ToWeeks();
    public Ticks ToTicks();
    public double ConvertTo(TimeUnit targetUnit);
    public virtual string ToString();
    public string ToString(int secondPrecision, double minimumSubSecondResolution);
    public string ToString(int secondPrecision, String[] timeNames, double minimumSubSecondResolution);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Time value);
    public sealed virtual int CompareTo(TimeSpan value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Time obj);
    public sealed virtual bool Equals(TimeSpan obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Time Parse(string s);
    public static Time Parse(string s, NumberStyles style);
    public static Time Parse(string s, IFormatProvider provider);
    public static Time Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Time& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Time& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Time value1, Time value2);
    public static bool op_Inequality(Time value1, Time value2);
    public static bool op_LessThan(Time value1, Time value2);
    public static bool op_LessThanOrEqual(Time value1, Time value2);
    public static bool op_GreaterThan(Time value1, Time value2);
    public static bool op_GreaterThanOrEqual(Time value1, Time value2);
    public static Time op_Implicit(double value);
    public static Time op_Implicit(TimeSpan value);
    public static double op_Implicit(Time value);
    public static TimeSpan op_Implicit(Time value);
    public static Time op_Modulus(Time value1, Time value2);
    public static Time op_Addition(Time value1, Time value2);
    public static Time op_Subtraction(Time value1, Time value2);
    public static Time op_Multiply(Time value1, Time value2);
    public static Time op_Division(Time value1, Time value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Time value1, Time value2);
    public static Time FromAtomicUnitsOfTime(double value);
    public static Time FromPlanckTime(double value);
    public static Time FromKe(double value);
    public static Time FromMinutes(double value);
    public static Time FromHours(double value);
    public static Time FromDays(double value);
    public static Time FromWeeks(double value);
    public static Time FromTicks(Ticks value);
    public static Time ConvertFrom(double value, TimeUnit sourceUnit);
    public static int SecondsPerMonth(int year, int month);
    public static long SecondsPerYear(int year);
    public static string ToElapsedTimeString(double seconds, int secondPrecision, String[] timeNames, double minimumSubSecondResolution);
}
public enum GSF.Units.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Seconds;
    public static TimeUnit Minutes;
    public static TimeUnit Hours;
    public static TimeUnit Days;
    public static TimeUnit Weeks;
    public static TimeUnit Ticks;
    public static TimeUnit AtomicUnitsOfTime;
    public static TimeUnit PlanckTime;
    public static TimeUnit Ke;
}
[ExtensionAttribute]
public static class GSF.Units.UnitExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Angle> Unwrap(IEnumerable`1<Angle> source);
    [ExtensionAttribute]
public static Angle Average(IEnumerable`1<Angle> source);
}
public class GSF.Units.Voltage : ValueType {
    private static double AbvoltsFactor;
    private static double StatvoltsFactor;
    private double m_value;
    public static Voltage MaxValue;
    public static Voltage MinValue;
    public Voltage(double value);
    private static Voltage();
    public double ToAbvolts();
    public double ToStatvolts();
    public double ConvertTo(VoltageUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Voltage value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Voltage obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Voltage Parse(string s);
    public static Voltage Parse(string s, NumberStyles style);
    public static Voltage Parse(string s, IFormatProvider provider);
    public static Voltage Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Voltage& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Voltage& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Voltage value1, Voltage value2);
    public static bool op_Inequality(Voltage value1, Voltage value2);
    public static bool op_LessThan(Voltage value1, Voltage value2);
    public static bool op_LessThanOrEqual(Voltage value1, Voltage value2);
    public static bool op_GreaterThan(Voltage value1, Voltage value2);
    public static bool op_GreaterThanOrEqual(Voltage value1, Voltage value2);
    public static Voltage op_Implicit(double value);
    public static double op_Implicit(Voltage value);
    public static Voltage op_Modulus(Voltage value1, Voltage value2);
    public static Voltage op_Addition(Voltage value1, Voltage value2);
    public static Voltage op_Subtraction(Voltage value1, Voltage value2);
    public static Voltage op_Multiply(Voltage value1, Voltage value2);
    public static Voltage op_Division(Voltage value1, Voltage value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Voltage value1, Voltage value2);
    public static Voltage FromAbvolts(double value);
    public static Voltage FromStatvolts(double value);
    public static Voltage ConvertFrom(double value, VoltageUnit sourceUnit);
}
public enum GSF.Units.VoltageUnit : Enum {
    public int value__;
    public static VoltageUnit Volts;
    public static VoltageUnit Abvolts;
    public static VoltageUnit Statvolts;
}
public class GSF.Units.Volume : ValueType {
    private static double LitersFactor;
    private static double TeaspoonsFactor;
    private static double MetricTeaspoonsFactor;
    private static double TablespoonsFactor;
    private static double MetricTablespoonsFactor;
    private static double CupsFactor;
    private static double MetricCupsFactor;
    private static double FluidOuncesFactor;
    private static double PintsFactor;
    private static double QuartsFactor;
    private static double GallonsFactor;
    private static double CubicInchesFactor;
    private static double CubicFeetFactor;
    private double m_value;
    public static Volume MaxValue;
    public static Volume MinValue;
    public Volume(double value);
    private static Volume();
    public double ToLiters();
    public double ToTeaspoons();
    public double ToMetricTeaspoons();
    public double ToTablespoons();
    public double ToMetricTablespoons();
    public double ToCups();
    public double ToMetricCups();
    public double ToFluidOunces();
    public double ToPints();
    public double ToQuarts();
    public double ToGallons();
    public double ToCubicInches();
    public double ToCubicFeet();
    public double ConvertTo(VolumeUnit targetUnit);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Volume value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Volume obj);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static Volume Parse(string s);
    public static Volume Parse(string s, NumberStyles style);
    public static Volume Parse(string s, IFormatProvider provider);
    public static Volume Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Volume& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Volume& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool op_Equality(Volume value1, Volume value2);
    public static bool op_Inequality(Volume value1, Volume value2);
    public static bool op_LessThan(Volume value1, Volume value2);
    public static bool op_LessThanOrEqual(Volume value1, Volume value2);
    public static bool op_GreaterThan(Volume value1, Volume value2);
    public static bool op_GreaterThanOrEqual(Volume value1, Volume value2);
    public static Volume op_Implicit(double value);
    public static double op_Implicit(Volume value);
    public static Volume op_Modulus(Volume value1, Volume value2);
    public static Volume op_Addition(Volume value1, Volume value2);
    public static Volume op_Subtraction(Volume value1, Volume value2);
    public static Volume op_Multiply(Volume value1, Volume value2);
    public static Volume op_Division(Volume value1, Volume value2);
    [EditorBrowsableAttribute("2")]
public static double op_Exponent(Volume value1, Volume value2);
    public static Volume FromLiters(double value);
    public static Volume FromTeaspoons(double value);
    public static Volume FromMetricTeaspoons(double value);
    public static Volume FromTablespoons(double value);
    public static Volume FromMetricTablespoons(double value);
    public static Volume FromCups(double value);
    public static Volume FromMetricCups(double value);
    public static Volume FromFluidOunces(double value);
    public static Volume FromPints(double value);
    public static Volume FromQuarts(double value);
    public static Volume FromGallons(double value);
    public static Volume FromCubicInches(double value);
    public static Volume FromCubicFeet(double value);
    public static Volume ConvertFrom(double value, VolumeUnit sourceUnit);
}
public enum GSF.Units.VolumeUnit : Enum {
    public int value__;
    public static VolumeUnit CubicMeters;
    public static VolumeUnit Liters;
    public static VolumeUnit Teaspoons;
    public static VolumeUnit MetricTeaspoons;
    public static VolumeUnit Tablespoons;
    public static VolumeUnit MetricTablespoons;
    public static VolumeUnit Cups;
    public static VolumeUnit MetricCups;
    public static VolumeUnit FluidOunces;
    public static VolumeUnit Pints;
    public static VolumeUnit Quarts;
    public static VolumeUnit Gallons;
    public static VolumeUnit CubicInches;
    public static VolumeUnit CubicFeet;
}
public class GSF.UnixTimeTag : TimeTagBase {
    public static Ticks BaseTicks;
    public UnixTimeTag(decimal seconds);
    public UnixTimeTag(UInt32 seconds);
    public UnixTimeTag(Ticks timestamp);
    protected UnixTimeTag(SerializationInfo info, StreamingContext context);
    private static UnixTimeTag();
}
public enum GSF.UpdateType : Enum {
    public int value__;
    public static UpdateType Information;
    public static UpdateType Warning;
    public static UpdateType Alarm;
}
public static class GSF.USTimeZones : object {
    private static TimeZoneInfo s_atlanticTimeZone;
    private static TimeZoneInfo s_easternTimeZone;
    private static TimeZoneInfo s_centralTimeZone;
    private static TimeZoneInfo s_mountainTimeZone;
    private static TimeZoneInfo s_pacificTimeZone;
    private static TimeZoneInfo s_alaskanTimeZone;
    private static TimeZoneInfo s_hawaiianTimeZone;
    private static TimeZoneInfo s_westPacificTimeZone;
    private static TimeZoneInfo s_samoaTimeZone;
    public static TimeZoneInfo Atlantic { get; }
    public static TimeZoneInfo Eastern { get; }
    public static TimeZoneInfo Central { get; }
    public static TimeZoneInfo Mountain { get; }
    public static TimeZoneInfo Pacific { get; }
    public static TimeZoneInfo Alaskan { get; }
    public static TimeZoneInfo Hawaiian { get; }
    public static TimeZoneInfo WestPacific { get; }
    public static TimeZoneInfo Samoa { get; }
    public static TimeZoneInfo get_Atlantic();
    public static TimeZoneInfo get_Eastern();
    public static TimeZoneInfo get_Central();
    public static TimeZoneInfo get_Mountain();
    public static TimeZoneInfo get_Pacific();
    public static TimeZoneInfo get_Alaskan();
    public static TimeZoneInfo get_Hawaiian();
    public static TimeZoneInfo get_WestPacific();
    public static TimeZoneInfo get_Samoa();
}
public class GSF.Validation.EmailAddressValidator : object {
    private static string EmailAddressRegex;
    public sealed virtual bool Validate(object value, String& validationError);
}
public interface GSF.Validation.IValidator {
    public abstract virtual bool Validate(object value, String& validationError);
}
[CompilerGeneratedAttribute]
internal class GSF.Validation.NamespaceDoc : object {
}
public class GSF.Validation.NonNullStringValidator : object {
    public sealed virtual bool Validate(object value, String& validationError);
}
public class GSF.Validation.NumericRangeValidator : object {
    private decimal m_rangeMinimum;
    private decimal m_rangeMaximum;
    public NumericRangeValidator(decimal minimum, decimal maximum);
    public sealed virtual bool Validate(object value, String& validationError);
}
public class GSF.Validation.ValidationService : object {
    private Func`2<string, object> m_lookup;
    private Dictionary`2<string, IValidator> m_validations;
    public ValidationService(Func`2<string, object> valueLookupHandler);
    public void AddValidation(string source, IValidator validator);
    public bool Validate(String& validationErrors);
}
[ExtensionAttribute]
public static class GSF.Word : object {
    [ExtensionAttribute]
public static short AlignWord(short word);
    [ExtensionAttribute]
public static ushort AlignWord(ushort word);
    [ExtensionAttribute]
public static int AlignDoubleWord(int doubleWord);
    [ExtensionAttribute]
public static UInt32 AlignDoubleWord(UInt32 doubleWord);
    [ExtensionAttribute]
public static long AlignQuadWord(long quadWord);
    [ExtensionAttribute]
public static ulong AlignQuadWord(ulong quadWord);
    [ExtensionAttribute]
public static byte HighNibble(byte value);
    [ExtensionAttribute]
public static byte HighByte(ushort word);
    [ExtensionAttribute]
public static ushort HighWord(UInt32 doubleWord);
    [ExtensionAttribute]
public static UInt32 HighDoubleWord(ulong quadWord);
    [ExtensionAttribute]
public static byte LowNibble(byte value);
    [ExtensionAttribute]
public static byte LowByte(ushort word);
    [ExtensionAttribute]
public static ushort LowWord(UInt32 doubleWord);
    [ExtensionAttribute]
public static UInt32 LowDoubleWord(ulong quadWord);
    public static ushort MakeWord(byte high, byte low);
    public static UInt32 MakeDoubleWord(ushort high, ushort low);
    public static ulong MakeQuadWord(UInt32 high, UInt32 low);
}
[CompilerGeneratedAttribute]
internal class GSF.Xml.NamespaceDoc : object {
}
[ExtensionAttribute]
public static class GSF.Xml.XmlExtensions : object {
    [ExtensionAttribute]
public static XmlNode GetXmlNode(XmlDocument xmlDoc, string xpath);
    [ExtensionAttribute]
public static XmlNode GetXmlNode(XmlDocument xmlDoc, string xpath, Boolean& isDirty);
    [ExtensionAttribute]
public static XmlNode GetXmlNode(XmlNode parentNode, string xpath);
    [ExtensionAttribute]
public static XmlNode GetXmlNode(XmlNode parentNode, string xpath, Boolean& isDirty);
    [ExtensionAttribute]
public static string GetAttributeValue(XmlNode node, string name);
    [ExtensionAttribute]
public static void SetAttributeValue(XmlNode node, string name, string value);
    [ExtensionAttribute]
public static DataSet GetDataSet(string xmlData);
    [ExtensionAttribute]
public static string ApplyXSLTransform(string document, string transform);
    [ExtensionAttribute]
public static void TransformAll(XDocument document, XName name, Func`2<XElement, object> selector);
    [ExtensionAttribute]
public static void TransformAll(XDocument document, XName name, Func`3<XElement, int, object> selector);
    [ExtensionAttribute]
public static object Format(XElement element);
    [ExtensionAttribute]
public static IEnumerable`1<Tuple`2<XElement, string>> WhereAttribute(IEnumerable`1<XElement> source, string attributeName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> Is(IEnumerable`1<Tuple`2<XElement, string>> source, string attributeValue, bool ignoreCase);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000C")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class Ionic.Crc.CRC32 : object {
    private UInt32 dwPolynomial;
    private long _TotalBytesRead;
    private bool reverseBits;
    private UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _register;
    public long TotalBytesRead { get; }
    public int Crc32Result { get; }
    public CRC32(bool reverseBits);
    public CRC32(int polynomial, bool reverseBits);
    public long get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
    public void UpdateCRC(byte b);
    public void UpdateCRC(byte b, int n);
    private static UInt32 ReverseBits(UInt32 data);
    private static byte ReverseBits(byte data);
    private void GenerateLookupTable();
    private UInt32 gf2_matrix_times(UInt32[] matrix, UInt32 vec);
    private void gf2_matrix_square(UInt32[] square, UInt32[] mat);
    public void Combine(int crc, int length);
    public void Reset();
}
internal class Ionic.Crc.CrcCalculatorStream : Stream {
    private static long UnsetLengthLimit;
    private Stream _innerStream;
    private CRC32 _crc32;
    private long _lengthLimit;
    private bool _leaveOpen;
    public long TotalBytesSlurped { get; }
    public int Crc { get; }
    public bool LeaveOpen { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32);
    private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32);
    private static CrcCalculatorStream();
    public long get_TotalBytesSlurped();
    public int get_Crc();
    public bool get_LeaveOpen();
    public void set_LeaveOpen(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    private void InnerClose();
    public virtual void Close();
}
internal class Ionic.Zlib.Adler : object {
    private static UInt32 BASE;
    private static int NMAX;
    private static Adler();
    public static UInt32 Adler32(UInt32 adler, Byte[] buf, int index, int len);
}
internal enum Ionic.Zlib.BlockState : Enum {
    public int value__;
    public static BlockState NeedMore;
    public static BlockState BlockDone;
    public static BlockState FinishStarted;
    public static BlockState FinishDone;
}
internal enum Ionic.Zlib.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Level0;
    public static CompressionLevel BestSpeed;
    public static CompressionLevel Level1;
    public static CompressionLevel Level2;
    public static CompressionLevel Level3;
    public static CompressionLevel Level4;
    public static CompressionLevel Level5;
    public static CompressionLevel Default;
    public static CompressionLevel Level6;
    public static CompressionLevel Level7;
    public static CompressionLevel Level8;
    public static CompressionLevel BestCompression;
    public static CompressionLevel Level9;
}
internal enum Ionic.Zlib.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compress;
    public static CompressionMode Decompress;
}
internal enum Ionic.Zlib.CompressionStrategy : Enum {
    public int value__;
    public static CompressionStrategy Default;
    public static CompressionStrategy Filtered;
    public static CompressionStrategy HuffmanOnly;
}
internal enum Ionic.Zlib.DeflateFlavor : Enum {
    public int value__;
    public static DeflateFlavor Store;
    public static DeflateFlavor Fast;
    public static DeflateFlavor Slow;
}
internal class Ionic.Zlib.DeflateManager : object {
    private static int MEM_LEVEL_MAX;
    private static int MEM_LEVEL_DEFAULT;
    private CompressFunc DeflateFunction;
    private static String[] _ErrorMessage;
    private static int PRESET_DICT;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZlibCodec _codec;
    internal int status;
    internal Byte[] pending;
    internal int nextPending;
    internal int pendingCount;
    internal sbyte data_type;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    private Config config;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal CompressionLevel compressionLevel;
    internal CompressionStrategy compressionStrategy;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree treeLiterals;
    internal Tree treeDistances;
    internal Tree treeBitLengths;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal SByte[] depth;
    internal int _lengthOffset;
    internal int lit_bufsize;
    internal int last_lit;
    internal int _distanceOffset;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal short bi_buf;
    internal int bi_valid;
    private bool Rfc1950BytesEmitted;
    private bool _WantRfc1950HeaderBytes;
    internal bool WantRfc1950HeaderBytes { get; internal set; }
    private static DeflateManager();
    private void _InitializeLazyMatch();
    private void _InitializeTreeData();
    internal void _InitializeBlocks();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool _IsSmaller(Int16[] tree, int n, int m, SByte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    private void put_bytes(Byte[] p, int start, int len);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int value, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void send_compressed_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal BlockState DeflateNone(FlushType flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    private void _fillWindow();
    internal BlockState DeflateFast(FlushType flush);
    internal BlockState DeflateSlow(FlushType flush);
    internal int longest_match(int cur_match);
    internal bool get_WantRfc1950HeaderBytes();
    internal void set_WantRfc1950HeaderBytes(bool value);
    internal int Initialize(ZlibCodec codec, CompressionLevel level);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    internal void Reset();
    internal int End();
    private void SetDeflater();
    internal int SetParams(CompressionLevel level, CompressionStrategy strategy);
    internal int SetDictionary(Byte[] dictionary);
    internal int Deflate(FlushType flush);
}
internal class Ionic.Zlib.DeflateStream : Stream {
    internal ZlibBaseStream _baseStream;
    internal Stream _innerStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal enum Ionic.Zlib.FlushType : Enum {
    public int value__;
    public static FlushType None;
    public static FlushType Partial;
    public static FlushType Sync;
    public static FlushType Full;
    public static FlushType Finish;
}
internal class Ionic.Zlib.GZipStream : Stream {
    public Nullable`1<DateTime> LastModified;
    private int _headerByteCount;
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    private bool _firstReadDone;
    private string _FileName;
    private string _Comment;
    private int _Crc32;
    internal static DateTime _unixEpoch;
    internal static Encoding iso8859dash1;
    public string Comment { get; public set; }
    public string FileName { get; public set; }
    public int Crc32 { get; }
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    private static GZipStream();
    public string get_Comment();
    public void set_Comment(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public int get_Crc32();
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int EmitHeader();
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal class Ionic.Zlib.InflateBlocks : object {
    private static int MANY;
    internal static Int32[] border;
    private InflateBlockMode mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InflateCodes codes;
    internal int last;
    internal ZlibCodec _codec;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int readAt;
    internal int writeAt;
    internal object checkfn;
    internal UInt32 check;
    internal InfTree inftree;
    internal InflateBlocks(ZlibCodec codec, object checkfn, int w);
    private static InflateBlocks();
    internal UInt32 Reset();
    internal int Process(int r);
    internal void Free();
    internal void SetDictionary(Byte[] d, int start, int n);
    internal int SyncPoint();
    internal int Flush(int r);
}
internal class Ionic.Zlib.InflateCodes : object {
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    internal int mode;
    internal int len;
    internal Int32[] tree;
    internal int tree_index;
    internal int need;
    internal int lit;
    internal int bitsToGet;
    internal int dist;
    internal byte lbits;
    internal byte dbits;
    internal Int32[] ltree;
    internal int ltree_index;
    internal Int32[] dtree;
    internal int dtree_index;
    internal void Init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index);
    internal int Process(InflateBlocks blocks, int r);
    internal int InflateFast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InflateBlocks s, ZlibCodec z);
}
internal class Ionic.Zlib.InflateManager : object {
    private static int PRESET_DICT;
    private static int Z_DEFLATED;
    private InflateManagerMode mode;
    internal ZlibCodec _codec;
    internal int method;
    internal UInt32 computedCheck;
    internal UInt32 expectedCheck;
    internal int marker;
    private bool _handleRfc1950HeaderBytes;
    internal int wbits;
    internal InflateBlocks blocks;
    private static Byte[] mark;
    internal bool HandleRfc1950HeaderBytes { get; internal set; }
    public InflateManager(bool expectRfc1950HeaderBytes);
    private static InflateManager();
    internal bool get_HandleRfc1950HeaderBytes();
    internal void set_HandleRfc1950HeaderBytes(bool value);
    internal int Reset();
    internal int End();
    internal int Initialize(ZlibCodec codec, int w);
    internal int Inflate(FlushType flush);
    internal int SetDictionary(Byte[] dictionary);
    internal int Sync();
    internal int SyncPoint(ZlibCodec z);
}
internal class Ionic.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal static int BMAX;
    internal Int32[] hn;
    internal Int32[] v;
    internal Int32[] c;
    internal Int32[] r;
    internal Int32[] u;
    internal Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZlibCodec z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZlibCodec z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZlibCodec z);
    private void initWorkArea(int vsize);
}
internal static class Ionic.Zlib.InternalConstants : object {
    internal static int MAX_BITS;
    internal static int BL_CODES;
    internal static int D_CODES;
    internal static int LITERALS;
    internal static int LENGTH_CODES;
    internal static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    private static InternalConstants();
}
internal static class Ionic.Zlib.InternalInflateConstants : object {
    internal static Int32[] InflateMask;
    private static InternalInflateConstants();
}
internal class Ionic.Zlib.ParallelDeflateOutputStream : Stream {
    private static int IO_BUFFER_SIZE_DEFAULT;
    private static int BufferPairsPerCore;
    private List`1<WorkItem> _pool;
    private bool _leaveOpen;
    private bool emitting;
    private Stream _outStream;
    private int _maxBufferPairs;
    private int _bufferSize;
    private AutoResetEvent _newlyCompressedBlob;
    private object _outputLock;
    private bool _isClosed;
    private bool _firstWriteDone;
    private int _currentlyFilling;
    private int _lastFilled;
    private int _lastWritten;
    private int _latestCompressed;
    private int _Crc32;
    private CRC32 _runningCrc;
    private object _latestLock;
    private Queue`1<int> _toWrite;
    private Queue`1<int> _toFill;
    private long _totalBytesProcessed;
    private CompressionLevel _compressLevel;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _pendingException;
    private bool _handlingException;
    private object _eLock;
    private TraceBits _DesiredTrace;
    [CompilerGeneratedAttribute]
private CompressionStrategy <Strategy>k__BackingField;
    public CompressionStrategy Strategy { get; private set; }
    public int MaxBufferPairs { get; public set; }
    public int BufferSize { get; public set; }
    public int Crc32 { get; }
    public long BytesProcessed { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ParallelDeflateOutputStream(Stream stream);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level);
    public ParallelDeflateOutputStream(Stream stream, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, CompressionStrategy strategy, bool leaveOpen);
    private static ParallelDeflateOutputStream();
    [CompilerGeneratedAttribute]
public CompressionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
private void set_Strategy(CompressionStrategy value);
    public int get_MaxBufferPairs();
    public void set_MaxBufferPairs(int value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public int get_Crc32();
    public long get_BytesProcessed();
    private void _InitializePoolOfWorkItems();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void _FlushFinish();
    private void _Flush(bool lastInput);
    public virtual void Flush();
    public virtual void Close();
    private void InnerClose();
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset(Stream stream);
    private void EmitPendingBuffers(bool doAll, bool mustWait);
    private void _DeflateOne(object wi);
    private bool DeflateOneSegment(WorkItem workitem);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class Ionic.Zlib.SharedUtils : object {
    public static int URShift(int number, int bits);
    public static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
    internal static Byte[] ToByteArray(string sourceString);
    internal static Char[] ToCharArray(Byte[] byteArray);
}
internal class Ionic.Zlib.StaticTree : object {
    internal static Int16[] lengthAndLiteralsTreeCodes;
    internal static Int16[] distTreeCodes;
    internal static StaticTree Literals;
    internal static StaticTree Distances;
    internal static StaticTree BitLengths;
    internal Int16[] treeCodes;
    internal Int32[] extraBits;
    internal int extraBase;
    internal int elems;
    internal int maxLength;
    private StaticTree(Int16[] treeCodes, Int32[] extraBits, int extraBase, int elems, int maxLength);
    private static StaticTree();
}
internal class Ionic.Zlib.Tree : object {
    private static int HEAP_SIZE;
    internal static Int32[] ExtraLengthBits;
    internal static Int32[] ExtraDistanceBits;
    internal static Int32[] extra_blbits;
    internal static SByte[] bl_order;
    internal static int Buf_size;
    private static SByte[] _dist_code;
    internal static SByte[] LengthCode;
    internal static Int32[] LengthBase;
    internal static Int32[] DistanceBase;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree staticTree;
    private static Tree();
    internal static int DistanceCode(int dist);
    internal void gen_bitlen(DeflateManager s);
    internal void build_tree(DeflateManager s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
internal class Ionic.Zlib.WorkItem : object {
    public Byte[] buffer;
    public Byte[] compressed;
    public int crc;
    public int index;
    public int ordinal;
    public int inputBytesAvailable;
    public int compressedBytesAvailable;
    public ZlibCodec compressor;
    public WorkItem(int size, CompressionLevel compressLevel, CompressionStrategy strategy, int ix);
}
internal class Ionic.Zlib.ZlibBaseStream : Stream {
    protected internal ZlibCodec _z;
    protected internal StreamMode _streamMode;
    protected internal FlushType _flushMode;
    protected internal ZlibStreamFlavor _flavor;
    protected internal CompressionMode _compressionMode;
    protected internal CompressionLevel _level;
    protected internal bool _leaveOpen;
    protected internal Byte[] _workingBuffer;
    protected internal int _bufferSize;
    protected internal Byte[] _buf1;
    protected internal Stream _stream;
    protected internal CompressionStrategy Strategy;
    private CRC32 crc;
    protected internal string _GzipFileName;
    protected internal string _GzipComment;
    protected internal DateTime _GzipMtime;
    protected internal int _gzipHeaderByteCount;
    private bool nomoreinput;
    internal int Crc32 { get; }
    protected internal bool _wantCompress { get; }
    private ZlibCodec z { get; }
    private Byte[] workingBuffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen);
    internal int get_Crc32();
    protected internal bool get__wantCompress();
    private ZlibCodec get_z();
    private Byte[] get_workingBuffer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void finish();
    private void end();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private string ReadZeroTerminatedString();
    private int _ReadAndValidateGzipHeader();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static void CompressString(string s, Stream compressor);
    public static void CompressBuffer(Byte[] b, Stream compressor);
    public static string UncompressString(Byte[] compressed, Stream decompressor);
    public static Byte[] UncompressBuffer(Byte[] compressed, Stream decompressor);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000D")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class Ionic.Zlib.ZlibCodec : object {
    public Byte[] InputBuffer;
    public int NextIn;
    public int AvailableBytesIn;
    public long TotalBytesIn;
    public Byte[] OutputBuffer;
    public int NextOut;
    public int AvailableBytesOut;
    public long TotalBytesOut;
    public string Message;
    internal DeflateManager dstate;
    internal InflateManager istate;
    internal UInt32 _Adler32;
    public CompressionLevel CompressLevel;
    public int WindowBits;
    public CompressionStrategy Strategy;
    public int Adler32 { get; }
    public ZlibCodec(CompressionMode mode);
    public int get_Adler32();
    public int InitializeInflate();
    public int InitializeInflate(bool expectRfc1950Header);
    public int InitializeInflate(int windowBits);
    public int InitializeInflate(int windowBits, bool expectRfc1950Header);
    public int Inflate(FlushType flush);
    public int EndInflate();
    public int SyncInflate();
    public int InitializeDeflate();
    public int InitializeDeflate(CompressionLevel level);
    public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header);
    public int InitializeDeflate(CompressionLevel level, int bits);
    public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header);
    private int _InternalInitializeDeflate(bool wantRfc1950Header);
    public int Deflate(FlushType flush);
    public int EndDeflate();
    public void ResetDeflate();
    public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy);
    public int SetDictionary(Byte[] dictionary);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
}
internal static class Ionic.Zlib.ZlibConstants : object {
    public static int WindowBitsMax;
    public static int WindowBitsDefault;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_BUF_ERROR;
    public static int WorkingBufferSizeDefault;
    public static int WorkingBufferSizeMin;
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000E")]
internal class Ionic.Zlib.ZlibException : Exception {
    public ZlibException(string s);
}
internal class Ionic.Zlib.ZlibStream : Stream {
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibStream(Stream stream, CompressionMode mode);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public ZlibStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal enum Ionic.Zlib.ZlibStreamFlavor : Enum {
    public int value__;
    public static ZlibStreamFlavor ZLIB;
    public static ZlibStreamFlavor DEFLATE;
    public static ZlibStreamFlavor GZIP;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
