internal class Expressions.Shortcuts.BlockBuilder : ExpressionContainer {
    private Type _returnType;
    private List`1<Expression> _expressions;
    private HashSet`1<ParameterExpression> _parameters;
    public IEnumerable`1<ParameterExpression> Parameters { get; }
    public Expression Expression { get; }
    internal BlockBuilder(Type returnType);
    public IEnumerable`1<ParameterExpression> get_Parameters();
    public virtual Expression get_Expression();
    public BlockBuilder Parameter(Expression expression);
    public BlockBuilder Parameter(ExpressionContainer`1& parameter);
    public BlockBuilder Parameter(string name, ExpressionContainer`1& parameter);
    public BlockBuilder Parameter(ExpressionContainer`1& parameter, ExpressionContainer`1<T> value);
    public BlockBuilder Parameter(string name, ExpressionContainer`1& parameter, ExpressionContainer`1<T> value);
    public BlockBuilder Parameter(ExpressionContainer`1& parameter, T value);
    public BlockBuilder Parameter(string name, ExpressionContainer`1& parameter, T value);
    public BlockBuilder Parameter(ExpressionContainer`1<TV> expression, ExpressionContainer`1<TV> value);
    public BlockBuilder Parameter(ExpressionContainer`1<TV> expression, Expression value);
    public BlockBuilder Parameter(ParameterExpression e);
    public BlockBuilder Line(Expression e);
    public BlockBuilder Line(ExpressionContainer`1<TV> e);
    public BlockBuilder Lines(IEnumerable`1<Expression> e);
    public BlockBuilder Lines(Expression[] e);
    public ExpressionContainer`1<T> Invoke(ExpressionContainer[] parameters);
    public Expression`1<T> Lambda(ExpressionContainer[] parameters);
    public Expression`1<T> Lambda(IEnumerable`1<ParameterExpression> parameters);
}
internal class Expressions.Shortcuts.ConditionBuilder : ExpressionContainer {
    private Type _type;
    private Expression _condition;
    private Expression _then;
    private Expression _else;
    public Expression Expression { get; }
    internal ConditionBuilder(Type type);
    public ConditionBuilder If(Expression condition);
    public ConditionBuilder If(ExpressionContainer`1<bool> condition);
    public ConditionBuilder Then(Expression then);
    public ConditionBuilder Then(ExpressionContainer then);
    public ConditionBuilder Then(ExpressionContainer`1<T> then);
    public ConditionBuilder Then(Action`1<BlockBuilder> then);
    public ConditionBuilder Else(Expression then);
    public ConditionBuilder Else(ExpressionContainer then);
    public ConditionBuilder Else(ExpressionContainer`1<T> then);
    public ConditionBuilder Else(Action`1<BlockBuilder> then);
    public virtual Expression get_Expression();
}
internal class Expressions.Shortcuts.ExpressionContainer : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public ExpressionContainer(Expression expression);
    [CompilerGeneratedAttribute]
public virtual Expression get_Expression();
    public ExpressionContainer`1<T> Typed();
    public ExpressionContainer`1<bool> Is();
    public ExpressionContainer`1<bool> Is(Type type);
    public ExpressionContainer`1<TV> As();
    public UnaryExpression As(Type type);
    public ExpressionContainer`1<TV> Cast();
    public UnaryExpression Cast(Type type);
    public static Expression op_Implicit(ExpressionContainer expressionContainer);
    public static ExpressionContainer op_Implicit(Expression expression);
}
internal class Expressions.Shortcuts.ExpressionContainer`1 : ExpressionContainer {
    public ExpressionContainer`1(Expression expression);
    public static T op_Implicit(ExpressionContainer`1<T> _0);
}
internal class Expressions.Shortcuts.ExpressionExtractorVisitor : ExpressionVisitor {
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private static Expression ConvertToExpression(object value, Func`2<Expression, Expression> visit);
}
[ExtensionAttribute]
internal static class Expressions.Shortcuts.ExpressionShortcuts : object {
    [ExtensionAttribute]
public static ExpressionContainer`1<TV> Property(ExpressionContainer`1<T> instance, Expression`1<Func`2<T, TV>> propertyAccessor);
    [ExtensionAttribute]
public static ExpressionContainer`1<TV> Field(ExpressionContainer`1<T> instance, Expression`1<Func`2<T, TV>> propertyAccessor);
    [ExtensionAttribute]
public static ExpressionContainer`1<TV> Member(ExpressionContainer`1<T> instance, Expression`1<Func`2<T, TV>> propertyAccessor);
    [ExtensionAttribute]
public static ExpressionContainer Call(ExpressionContainer`1<T> instance, Expression`1<Action`1<T>> invocationExpression);
    [ExtensionAttribute]
public static ExpressionContainer`1<TV> Call(ExpressionContainer`1<T> instance, Expression`1<Func`2<T, TV>> invocationExpression);
    [ExtensionAttribute]
public static ExpressionContainer`1<TV> Code(ExpressionContainer`1<T> instance, Func`2<T, TV> code);
    [ExtensionAttribute]
public static ExpressionContainer Code(ExpressionContainer`1<T> instance, Action`1<T> code);
    [ExtensionAttribute]
public static ExpressionContainer Using(ExpressionContainer`1<T> instance, Action`2<ExpressionContainer`1<T>, BlockBuilder> blockBody);
    [ExtensionAttribute]
public static IEnumerable`1<Expression> Return(ExpressionContainer`1<T> instance);
    [ExtensionAttribute]
public static ExpressionContainer Assign(ExpressionContainer`1<T> target, ExpressionContainer`1<T> value);
    [ExtensionAttribute]
public static ExpressionContainer Assign(ExpressionContainer`1<T> target, T value);
    [ExtensionAttribute]
public static ExpressionContainer Assign(ExpressionContainer`1<T> target, Expression value);
    [ExtensionAttribute]
public static Expression TernaryAssign(ExpressionContainer`1<T> target, ExpressionContainer`1<bool> condition, ExpressionContainer`1<T> ifTrue, ExpressionContainer`1<T> ifFalse);
    public static ExpressionContainer`1<T> Arg(Expression expression);
    public static ExpressionContainer`1<T> Arg(T value);
    public static ExpressionContainer`1<T> Arg(Expression`1<T> expression);
    public static ExpressionContainer`1<T> Cast(Expression expression);
    public static ExpressionContainer`1<T> Var(string name);
    public static ExpressionContainer`1<T> Parameter(string name);
    public static ExpressionContainer`1<TV> Property(Expression instance, Expression`1<Func`2<T, TV>> propertyLambda);
    public static ExpressionContainer`1<TV> Property(Expression instance, string propertyName);
    public static ExpressionContainer`1<TV> Field(Expression instance, Expression`1<Func`2<T, TV>> propertyLambda);
    public static ExpressionContainer`1<TV> Field(Expression instance, string propertyName);
    public static ExpressionContainer`1<TV> Member(Expression instance, Expression`1<Func`2<T, TV>> propertyLambda);
    public static ExpressionContainer`1<TV> Member(Expression instance, string propertyName);
    public static ExpressionContainer`1<T[]> Array(IEnumerable`1<Expression> items);
    public static ExpressionContainer Call(Expression`1<Action> invocationExpression);
    public static ExpressionContainer`1<T> Call(Expression`1<Func`1<T>> invocationExpression);
    public static ExpressionContainer`1<T> New(Expression`1<Func`1<T>> invocationExpression);
    public static ExpressionContainer`1<T> New();
    public static BlockBuilder Block(Type returnType);
    public static ExpressionContainer`1<T> Null();
    public static ExpressionContainer Null(Type type);
    public static TryCatchFinallyBuilder Try();
    public static ExpressionContainer`1<T> Code(Func`1<T> code);
    public static ExpressionContainer Code(Action code);
    public static SwitchBuilder`1<T> Switch(ExpressionContainer`1<T> value);
    public static ConditionBuilder Condition(Type resultType);
}
internal static class Expressions.Shortcuts.ExpressionUtils : object {
    private static ExpressionExtractorVisitor ExtractorVisitor;
    private static ExpressionUtils();
    internal static IEnumerable`1<Expression> ReplaceParameters(IEnumerable`1<Expression> expressions, IList`1<Expression> newValues);
    internal static Expression ReplaceParameters(Expression expression, Expression[] newValues);
    internal static Expression ProcessPropertyLambda(Expression instance, LambdaExpression propertyLambda);
    internal static Expression ProcessFieldLambda(Expression instance, LambdaExpression propertyLambda);
    internal static Expression ProcessMemberLambda(Expression instance, LambdaExpression propertyLambda);
    internal static Expression ProcessCallLambda(LambdaExpression propertyLambda, Expression instance);
    internal static Expression ProcessCall(Expression propertyLambda, Expression instance);
    private static IReadOnlyCollection`1<Expression> ExtractArguments(IReadOnlyCollection`1<Expression> expressions);
    private static Expression ExtractArgument(Expression expr);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Expression> <ReplaceParameters>g__PerformReplacement|0_0(<>c__DisplayClass0_0& );
}
internal class Expressions.Shortcuts.ParameterReplacerVisitor : ExpressionVisitor {
    private ICollection`1<Expression> _replacements;
    private bool _addIfMiss;
    public ParameterReplacerVisitor(IEnumerable`1<Expression> replacements, bool addIfMiss);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
internal class Expressions.Shortcuts.SwitchBuilder`1 : ExpressionContainer {
    protected Expression DefaultCase;
    [CompilerGeneratedAttribute]
private List`1<SwitchCase> <Cases>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionContainer`1<T> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <ComparerMethod>k__BackingField;
    protected List`1<SwitchCase> Cases { get; protected set; }
    protected ExpressionContainer`1<T> Value { get; }
    protected MethodInfo ComparerMethod { get; protected set; }
    public Expression Expression { get; }
    internal SwitchBuilder`1(ExpressionContainer`1<T> value);
    [CompilerGeneratedAttribute]
protected List`1<SwitchCase> get_Cases();
    [CompilerGeneratedAttribute]
protected void set_Cases(List`1<SwitchCase> value);
    [CompilerGeneratedAttribute]
protected ExpressionContainer`1<T> get_Value();
    [CompilerGeneratedAttribute]
protected MethodInfo get_ComparerMethod();
    [CompilerGeneratedAttribute]
protected void set_ComparerMethod(MethodInfo value);
    public SwitchBuilder`2<T, TR> Default(ExpressionContainer`1<TR> expression);
    public SwitchBuilder`2<T, TR> Default(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder);
    public SwitchBuilder`1<T> Default(ExpressionContainer expression);
    public SwitchBuilder`1<T> Default(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder);
    public SwitchBuilder`2<T, TR> Case(ExpressionContainer`1<TR> expression, ExpressionContainer`1[] testValues);
    public SwitchBuilder`2<T, TR> Case(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder, ExpressionContainer`1[] testValues);
    public SwitchBuilder`1<T> Case(ExpressionContainer expression, ExpressionContainer`1[] testValues);
    public SwitchBuilder`1<T> Case(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder, ExpressionContainer`1[] testValues);
    public SwitchBuilder`1<T> Comparer(MethodInfo comparer);
    public virtual Expression get_Expression();
}
internal class Expressions.Shortcuts.SwitchBuilder`2 : SwitchBuilder`1<T> {
    internal SwitchBuilder`2(ExpressionContainer`1<T> value);
    public SwitchBuilder`2<T, TR> Default(ExpressionContainer`1<TR> expression);
    public SwitchBuilder`2<T, TR> Default(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder);
    public SwitchBuilder`2<T, TR> Case(ExpressionContainer`1<TR> expression, ExpressionContainer`1[] testValues);
    public SwitchBuilder`2<T, TR> Case(Action`2<ExpressionContainer`1<T>, BlockBuilder> builder, ExpressionContainer`1[] testValues);
    public SwitchBuilder`2<T, TR> Comparer(MethodInfo comparer);
}
internal class Expressions.Shortcuts.TryCatchFinallyBuilder : ExpressionContainer {
    private List`1<CatchBlock> _catchBlocks;
    private Expression _finallyBody;
    private Expression _body;
    public Expression Expression { get; }
    public TryCatchFinallyBuilder Body(Action`1<BlockBuilder> body);
    public TryCatchFinallyBuilder Body(Expression body);
    public TryCatchFinallyBuilder Catch(Action`2<ExpressionContainer`1<T>, BlockBuilder> catch);
    public TryCatchFinallyBuilder Catch(Func`2<ExpressionContainer`1<T>, Expression> catch);
    public TryCatchFinallyBuilder Catch(CatchBlock catch);
    public TryCatchFinallyBuilder Finally(Action`1<BlockBuilder> finally);
    public TryCatchFinallyBuilder Finally(Expression finally);
    public virtual Expression get_Expression();
    public TryCatchFinallyBuilder Catch(Action`2<ExpressionContainer`1<T>, BlockBuilder> catch, Func`2<ExpressionContainer`1<T>, ExpressionContainer`1<bool>> when);
    public TryCatchFinallyBuilder Catch(Func`2<ExpressionContainer`1<T>, Expression> catch, Func`2<ExpressionContainer`1<T>, ExpressionContainer`1<bool>> when);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.Arguments : ValueType {
    private Object[] _array;
    private bool _useArray;
    private object _element0;
    private object _element1;
    private object _element2;
    private object _element3;
    private object _element4;
    private object _element5;
    public int Length;
    public IReadOnlyDictionary`2<string, object> Hash { get; }
    public object Item { get; }
    public object Item { get; }
    internal Arguments(int dummy);
    public Arguments(object arg1);
    public Arguments(object arg1, object arg2);
    public Arguments(object arg1, object arg2, object arg3);
    public Arguments(object arg1, object arg2, object arg3, object arg4);
    public Arguments(object arg1, object arg2, object arg3, object arg4, object arg5);
    public Arguments(object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public Arguments(Object[] args);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<object> AsEnumerable();
    public IReadOnlyDictionary`2<string, object> get_Hash();
    public object get_Item(int index);
    public object get_Item(string name);
    public T At(Int32& index);
    public static Arguments op_Implicit(Object[] array);
    public sealed virtual bool Equals(Arguments other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class HandlebarsDotNet.BindingContext : object {
    internal EntryIndex`1[] WellKnownVariables;
    internal DeferredValue`2<BindingContext, ObjectDescriptor> Descriptor;
    [CompilerGeneratedAttribute]
private CascadeIndex`3<string, object, StringEqualityComparer> <Bag>k__BackingField;
    [CompilerGeneratedAttribute]
private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> <ContextDataObject>k__BackingField;
    [CompilerGeneratedAttribute]
private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> <BlockParamsObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompiledHandlebarsConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeIndex`3<string, Action`2<EncodedTextWriter, BindingContext>, StringEqualityComparer> <InlinePartialTemplates>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeIndex`3<string, IHelperDescriptor`1<HelperOptions>, StringEqualityComparer> <Helpers>k__BackingField;
    [CompilerGeneratedAttribute]
private CascadeIndex`3<string, IHelperDescriptor`1<BlockHelperOptions>, StringEqualityComparer> <BlockHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateDelegate <PartialBlockTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private short <PartialDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingContext <ParentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingContext <Root>k__BackingField;
    private static BindingContextPool Pool;
    internal CascadeIndex`3<string, object, StringEqualityComparer> Bag { get; }
    internal FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> ContextDataObject { get; }
    internal FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> BlockParamsObject { get; }
    internal ICompiledHandlebarsConfiguration Configuration { get; private set; }
    internal CascadeIndex`3<string, Action`2<EncodedTextWriter, BindingContext>, StringEqualityComparer> InlinePartialTemplates { get; }
    internal CascadeIndex`3<string, IHelperDescriptor`1<HelperOptions>, StringEqualityComparer> Helpers { get; }
    internal CascadeIndex`3<string, IHelperDescriptor`1<BlockHelperOptions>, StringEqualityComparer> BlockHelpers { get; }
    internal TemplateDelegate PartialBlockTemplate { get; internal set; }
    internal short PartialDepth { get; internal set; }
    public object Value { get; public set; }
    public DataValues Data { get; }
    public IIndexed`2<string, object> Extensions { get; }
    internal BindingContext ParentContext { get; private set; }
    internal BindingContext Root { get; private set; }
    private static BindingContext();
    [CompilerGeneratedAttribute]
internal CascadeIndex`3<string, object, StringEqualityComparer> get_Bag();
    [CompilerGeneratedAttribute]
internal FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> get_ContextDataObject();
    [CompilerGeneratedAttribute]
internal FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> get_BlockParamsObject();
    internal void SetDataObject(object data);
    private void Initialize();
    [CompilerGeneratedAttribute]
internal ICompiledHandlebarsConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(ICompiledHandlebarsConfiguration value);
    [CompilerGeneratedAttribute]
internal CascadeIndex`3<string, Action`2<EncodedTextWriter, BindingContext>, StringEqualityComparer> get_InlinePartialTemplates();
    [CompilerGeneratedAttribute]
internal CascadeIndex`3<string, IHelperDescriptor`1<HelperOptions>, StringEqualityComparer> get_Helpers();
    [CompilerGeneratedAttribute]
internal CascadeIndex`3<string, IHelperDescriptor`1<BlockHelperOptions>, StringEqualityComparer> get_BlockHelpers();
    [CompilerGeneratedAttribute]
internal TemplateDelegate get_PartialBlockTemplate();
    [CompilerGeneratedAttribute]
internal void set_PartialBlockTemplate(TemplateDelegate value);
    [CompilerGeneratedAttribute]
internal short get_PartialDepth();
    [CompilerGeneratedAttribute]
internal void set_PartialDepth(short value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public BlockParamsValues BlockParams(ChainSegment[] blockParamsVariables);
    public DataValues get_Data();
    public IIndexed`2<string, object> get_Extensions();
    [CompilerGeneratedAttribute]
internal BindingContext get_ParentContext();
    [CompilerGeneratedAttribute]
private void set_ParentContext(BindingContext value);
    [CompilerGeneratedAttribute]
internal BindingContext get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(BindingContext value);
    internal bool TryGetVariable(ChainSegment segment, Object& value);
    internal bool TryGetContextVariable(ChainSegment segment, Object& value);
    internal BindingContext CreateChildContext(object value, TemplateDelegate partialBlockTemplate);
    public BindingContext CreateFrame(object value);
    private static void PopulateHash(HashParameterDictionary hash, object from);
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetHelpers();
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetBlockHelpers();
    internal static BindingContext Create(ICompiledHandlebarsConfiguration configuration, object value);
    internal static BindingContext Create(ICompiledHandlebarsConfiguration configuration, object value, BindingContext parent, TemplateDelegate partialBlockTemplate);
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.BlockDecoratorOptions : ValueType {
    internal TemplateDelegate OriginalTemplate;
    [CompilerGeneratedAttribute]
private BindingContext <Frame>k__BackingField;
    public ChainSegment[] BlockVariables;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public BindingContext Frame { get; }
    public DataValues Data { get; }
    public PathInfo Name { get; }
    internal BlockDecoratorOptions(PathInfo name, TemplateDelegate template, ChainSegment[] blockParamsValues, BindingContext frame);
    [CompilerGeneratedAttribute]
public sealed virtual BindingContext get_Frame();
    public sealed virtual DataValues get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public BindingContext CreateFrame(object value);
    public BindingContext CreateFrame(Context value);
    public string Template();
    public void Template(EncodedTextWriter& writer, object context);
    public void Template(EncodedTextWriter& writer, Context& context);
    public void Template(EncodedTextWriter& writer, BindingContext context);
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetHelpers();
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetBlockHelpers();
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.BlockHelperOptions : ValueType {
    internal TemplateDelegate OriginalTemplate;
    internal TemplateDelegate OriginalInverse;
    [CompilerGeneratedAttribute]
private BindingContext <Frame>k__BackingField;
    public ChainSegment[] BlockVariables;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public BindingContext Frame { get; }
    public DataValues Data { get; }
    public PathInfo Name { get; }
    internal BlockHelperOptions(PathInfo name, TemplateDelegate template, TemplateDelegate inverse, ChainSegment[] blockParamsValues, BindingContext frame);
    [CompilerGeneratedAttribute]
public sealed virtual BindingContext get_Frame();
    public sealed virtual DataValues get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public string Template();
    public void Template(EncodedTextWriter& writer, object context);
    public void Template(EncodedTextWriter& writer, Context& context);
    public void Template(EncodedTextWriter& writer, BindingContext context);
    public string Inverse();
    public void Inverse(EncodedTextWriter& writer, object context);
    public void Inverse(EncodedTextWriter& writer, Context& context);
    public void Inverse(EncodedTextWriter& writer, BindingContext context);
    public BindingContext CreateFrame(object value);
    public BindingContext CreateFrame(Context value);
}
public class HandlebarsDotNet.Collections.AddedObservableEvent`1 : ObservableEvent`1<T> {
    public AddedObservableEvent`1(T value);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class HandlebarsDotNet.Collections.CascadeIndex`3 : object {
    private TComparer _comparer;
    [CompilerGeneratedAttribute]
private IReadOnlyIndexed`2<TKey, TValue> <Outer>k__BackingField;
    private DictionarySlim`3<TKey, TValue, TComparer> _inner;
    public IReadOnlyIndexed`2<TKey, TValue> Outer { get; public set; }
    public int Count { get; }
    public TValue Item { get; public set; }
    public CascadeIndex`3(TComparer comparer);
    public CascadeIndex`3(IReadOnlyIndexed`2<TKey, TValue> outer, TComparer comparer);
    [CompilerGeneratedAttribute]
public IReadOnlyIndexed`2<TKey, TValue> get_Outer();
    [CompilerGeneratedAttribute]
public void set_Outer(IReadOnlyIndexed`2<TKey, TValue> value);
    public sealed virtual int get_Count();
    public void AddOrReplace(TKey& key, TValue& value);
    public sealed virtual void Clear();
    public bool ContainsKey(TKey& key);
    public bool TryGetValue(TKey& key, TValue& value);
    public TValue get_Item(TKey& key);
    public void set_Item(TKey& key, TValue value);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.CascadeIndex`3/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.CascadeIndex`3/<InnerEnumerable>d__18")]
private IEnumerable`1<KeyValuePair`2<TKey, TValue>> InnerEnumerable();
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.CascadeIndex`3/<OuterEnumerable>d__19")]
private IEnumerable`1<KeyValuePair`2<TKey, TValue>> OuterEnumerable();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.AddOrReplace(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.set_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue value);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
}
internal class HandlebarsDotNet.Collections.DictionaryAddedObservableEvent`2 : ObservableEvent`1<TValue> {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    public TKey Key { get; }
    public DictionaryAddedObservableEvent`2(TKey key, TValue value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
}
internal class HandlebarsDotNet.Collections.DictionaryClearedObservableEvent`1 : ObservableEvent`1<TValue> {
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class HandlebarsDotNet.Collections.DictionarySlim`3 : object {
    private TComparer _comparer;
    private static Entry[] InitialEntries;
    private int _count;
    private int _freeList;
    private Int32[] _buckets;
    private Entry[] _entries;
    public int Count { get; }
    public TValue Item { get; public set; }
    public DictionarySlim`3(TComparer comparer);
    public DictionarySlim`3(int capacity, TComparer comparer);
    public DictionarySlim`3(IReadOnlyIndexed`2<TKey, TValue> other, TComparer comparer);
    public DictionarySlim`3(DictionarySlim`3<TKey, TValue, TComparer> other);
    private static DictionarySlim`3();
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public bool ContainsKey(TKey& key);
    public bool TryGetValue(TKey& key, TValue& value);
    public TValue get_Item(TKey& key);
    public void set_Item(TKey& key, TValue value);
    public void AddOrReplace(TKey& key, TValue& value);
    private void AddValue(TKey key, TValue value, int bucketIndex);
    private Entry[] Resize();
    public Enumerator<TKey, TValue, TComparer> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.AddOrReplace(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.set_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue value);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Index}")]
public class HandlebarsDotNet.Collections.EntryIndex`1 : ValueType {
    public int Index;
    public byte Version;
    public bool IsNotEmpty;
    internal EntryIndex`1(Int32& index, Byte& version);
    public sealed virtual bool Equals(EntryIndex`1<TKey> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class HandlebarsDotNet.Collections.EnumeratorValue`1 : ValueType {
    public T Value;
    public int Index;
    public bool IsFirst;
    public bool IsLast;
    public EnumeratorValue`1(T value, int index, bool isLast);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class HandlebarsDotNet.Collections.ExtendedEnumerator`1 : ValueType {
    private IEnumerator _enumerator;
    private T _next;
    private int _index;
    private bool _hasNext;
    public bool Any;
    [CompilerGeneratedAttribute]
private EnumeratorValue`1<T> <Current>k__BackingField;
    public EnumeratorValue`1<T> Current { get; private set; }
    public ExtendedEnumerator`1(IEnumerator enumerator);
    public static ExtendedEnumerator`1<T> Create(IEnumerator enumerator);
    public static ExtendedEnumerator`2<T, TEnumerator> Create(TEnumerator enumerator);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EnumeratorValue`1<T> get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(EnumeratorValue`1<T> value);
    public bool MoveNext();
    private void PerformIteration();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class HandlebarsDotNet.Collections.ExtendedEnumerator`2 : ValueType {
    private TEnumerator _enumerator;
    private T _next;
    private int _index;
    private bool _hasNext;
    public bool Any;
    [CompilerGeneratedAttribute]
private EnumeratorValue`1<T> <Current>k__BackingField;
    public EnumeratorValue`1<T> Current { get; private set; }
    public ExtendedEnumerator`2(TEnumerator enumerator);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EnumeratorValue`1<T> get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(EnumeratorValue`1<T> value);
    public bool MoveNext();
    private void PerformIteration();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class HandlebarsDotNet.Collections.FixedSizeDictionary`3 : object {
    private static int MaximumSize;
    private int _bucketMask;
    private int _bucketSize;
    private Entry[] _entries;
    private EntryIndex`1[] _indexes;
    private TComparer _comparer;
    private byte _version;
    private int _count;
    public int Count { get; }
    public int Capacity { get; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    private TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Item { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public FixedSizeDictionary`3(int bucketsCount, int bucketSize, TComparer comparer);
    public sealed virtual int get_Count();
    public int get_Capacity();
    public bool TryGetIndex(TKey key, EntryIndex`1& index);
    public bool ContainsKey(EntryIndex`1& keyIndex);
    public bool ContainsKey(TKey& key);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.ContainsKey(TKey key);
    public bool TryGetValue(EntryIndex`1& keyIndex, TValue& value);
    public bool TryGetValue(TKey& key, TValue& value);
    public TValue get_Item(TKey& key);
    public void set_Item(TKey& key, TValue value);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.AddOrReplace(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value);
    public void AddOrReplace(TKey& key, TValue& value, EntryIndex`1& index);
    public TValue get_Item(EntryIndex`1& entryIndex);
    public void set_Item(EntryIndex`1& entryIndex, TValue value);
    public void CopyTo(FixedSizeDictionary`3<TKey, TValue, TComparer> destination);
    public void AdjustIndexes(EntryIndex`1[] source, FixedSizeDictionary`3<TKey, TValue, TComparer> destination, EntryIndex`1[] target);
    public void Reset();
    public sealed virtual void Clear();
    public void OptionalClear();
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.FixedSizeDictionary`3/<GetEnumerator>d__32")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.TryGetValue(TKey key, TValue& value);
    private sealed virtual override TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Item(TKey key);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.FixedSizeDictionary`3/<System-Collections-Generic-IReadOnlyDictionary<TKey,TValue>-get_Keys>d__38")]
private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.FixedSizeDictionary`3/<System-Collections-Generic-IReadOnlyDictionary<TKey,TValue>-get_Values>d__40")]
private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override TValue HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.set_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue value);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
}
internal static class HandlebarsDotNet.Collections.HashHelper : object {
    internal static Int32[] SizeOneIntArray;
    public static Int32[] Primes;
    private static HashHelper();
    public static int FindClosestPrime(int bucketSize);
    public static int AlignBy2(int size);
    public static int PowerOf2(int v);
}
public interface HandlebarsDotNet.Collections.IAppendOnlyList`1 {
    public abstract virtual void Add(T value);
}
[DefaultMemberAttribute("Item")]
public interface HandlebarsDotNet.Collections.IIndexed`2 {
    public TValue Item { get; public set; }
    public abstract virtual void AddOrReplace(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value);
    public abstract virtual TValue get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    public abstract virtual void set_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue value);
    public abstract virtual void Clear();
}
[IsReadOnlyAttribute]
internal class HandlebarsDotNet.Collections.ImmutableStack`1 : ValueType {
    private Node<T> _container;
    private ImmutableStack`1(T value, Node<T> parent);
    private ImmutableStack`1(Node<T> container);
    public ImmutableStack`1<T> Push(T value);
    public T Peek();
    public ImmutableStack`1<T> Pop(T& value);
}
[DefaultMemberAttribute("Item")]
public interface HandlebarsDotNet.Collections.IReadOnlyIndexed`2 {
    public TValue Item { get; }
    public abstract virtual bool ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    public abstract virtual bool TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
    public abstract virtual TValue get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class HandlebarsDotNet.Collections.LookupSlim`3 : object {
    private TComparer _comparer;
    private DictionarySlim`3<TKey, TValue, TComparer> _inner;
    public int Count { get; }
    private TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.Item { get; }
    public LookupSlim`3(TComparer comparer);
    public bool ContainsKey(TKey& key);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, Func`3<TKey, TState, TValue> valueFactory, TState state);
    public bool TryGetValue(TKey& key, TValue& value);
    public sealed virtual int get_Count();
    public void Clear();
    private sealed virtual override TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.LookupSlim`3/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<TKey,TValue>>-GetEnumerator>d__12")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private TValue Write(TKey key, TValue value);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
}
public abstract class HandlebarsDotNet.Collections.ObservableEvent`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    protected ObservableEvent`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class HandlebarsDotNet.Collections.ObservableIndex`3 : object {
    private ReaderWriterLockSlim _observersLock;
    private ReaderWriterLockSlim _itemsLock;
    private WeakCollection`1<IObserver`1<ObservableEvent`1<TValue>>> _observers;
    private DictionarySlim`3<TKey, TValue, TComparer> _inner;
    public int Count { get; }
    public TValue Item { get; public set; }
    public ObservableIndex`3(TComparer comparer, IReadOnlyIndexed`2<TKey, TValue> outer);
    public sealed virtual IDisposable Subscribe(IObserver`1<ObservableEvent`1<TValue>> observer);
    private void Publish(ObservableEvent`1<TValue> event);
    public sealed virtual int get_Count();
    public void AddOrReplace(TKey& key, TValue& value);
    public bool ContainsKey(TKey& key);
    public bool TryGetValue(TKey& key, TValue& value);
    public TValue get_Item(TKey& key);
    public void set_Item(TKey& key, TValue value);
    public sealed virtual void Clear();
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.ObservableIndex`3/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ObservableEvent`1<TValue> value);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.AddOrReplace(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override void HandlebarsDotNet.Collections.IIndexed<TKey,TValue>.set_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue value);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.ContainsKey(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    private sealed virtual override bool HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.TryGetValue(TKey& modreq(System.Runtime.InteropServices.InAttribute) key, TValue& value);
    private sealed virtual override TValue HandlebarsDotNet.Collections.IReadOnlyIndexed<TKey,TValue>.get_Item(TKey& modreq(System.Runtime.InteropServices.InAttribute) key);
    [CompilerGeneratedAttribute]
private void <Subscribe>b__5_0(WeakCollection`1<IObserver`1<ObservableEvent`1<TValue>>> observers, ReaderWriterLockSlim lock);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class HandlebarsDotNet.Collections.ObservableList`1 : object {
    private ReaderWriterLockSlim _observersLock;
    private ReaderWriterLockSlim _itemsLock;
    private WeakCollection`1<IObserver`1<ObservableEvent`1<T>>> _observers;
    private List`1<T> _inner;
    public int Count { get; }
    public T Item { get; }
    public ObservableList`1(IEnumerable`1<T> list);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.ObservableList`1/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual IDisposable Subscribe(IObserver`1<ObservableEvent`1<T>> observer);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ObservableEvent`1<T> value);
    private void Publish(ObservableEvent`1<T> event);
    [CompilerGeneratedAttribute]
private void <Subscribe>b__12_0(WeakCollection`1<IObserver`1<ObservableEvent`1<T>>> observers, ReaderWriterLockSlim lock);
}
internal static class HandlebarsDotNet.Collections.ObserverBuilder`1 : object {
    public static ObserverBuilder`2<T, TState> Create(TState state);
}
internal class HandlebarsDotNet.Collections.ObserverBuilder`2 : object {
    private TState _state;
    private Dictionary`2<Type, List`1<Action`1<T>>> _handlers;
    public ObserverBuilder`2(TState state);
    public ObserverBuilder`2<T, TState> OnEvent(Action`2<TEvent, TState> handler, Func`2<TEvent, bool> predicate);
    public IObserver`1<T> Build();
}
public class HandlebarsDotNet.Collections.WeakCollection`1 : object {
    private List`1<WeakReference`1<T>> _store;
    private int _firstAvailableIndex;
    public int Size { get; }
    public int get_Size();
    public void Add(T value);
    public void Remove(T value);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Collections.WeakCollection`1/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class HandlebarsDotNet.Compatibility : object {
    [CompilerGeneratedAttribute]
private bool <SupportLastInObjectIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RelaxedHelperNaming>k__BackingField;
    [ObsoleteAttribute("@last is supported on Handlebarsjs, so it is always enabled, and the setting should be removed.")]
public bool SupportLastInObjectIterations { get; public set; }
    [ObsoleteAttribute("Toggle will be removed in the next major release")]
public bool RelaxedHelperNaming { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SupportLastInObjectIterations();
    [CompilerGeneratedAttribute]
public void set_SupportLastInObjectIterations(bool value);
    [CompilerGeneratedAttribute]
public bool get_RelaxedHelperNaming();
    [CompilerGeneratedAttribute]
public void set_RelaxedHelperNaming(bool value);
}
internal class HandlebarsDotNet.Compiler.BlockAccumulator : TokenConverter {
    private ICompiledHandlebarsConfiguration _configuration;
    private BlockAccumulator(ICompiledHandlebarsConfiguration configuration);
    public static IEnumerable`1<object> Accumulate(IEnumerable`1<object> tokens, ICompiledHandlebarsConfiguration configuration);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.BlockAccumulator/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private Expression AccumulateBlock(Expression parentItem, IEnumerator`1<object> enumerator, BlockAccumulatorContext context);
}
internal abstract class HandlebarsDotNet.Compiler.BlockAccumulatorContext : object {
    private static HashSet`1<string> ConditionHelpers;
    private static HashSet`1<string> IteratorHelpers;
    public string BlockName { get; protected set; }
    protected BlockAccumulatorContext(Expression startingNode);
    private static BlockAccumulatorContext();
    public static BlockAccumulatorContext Create(Expression item, Expression parentItem, ICompiledHandlebarsConfiguration configuration);
    public abstract virtual string get_BlockName();
    protected abstract virtual void set_BlockName(string value);
    private static bool IsConditionalBlock(Expression item);
    private static bool IsBlockHelper(Expression item, ICompiledHandlebarsConfiguration configuration);
    private static bool IsIteratorBlock(Expression item);
    private static bool IsPartialBlock(Expression item);
    private static bool IsDetachedClosingElement(Expression item, Expression parentItem, String& closingElement);
    private static bool IsClosingElementNotMatchOpenElement(string closingElement, string openElement);
    private static string GetItemElement(Expression item);
    protected static Expression UnwrapStatement(Expression item);
    public abstract virtual void HandleElement(Expression item);
    public abstract virtual bool IsClosingElement(Expression item);
    public abstract virtual Expression GetAccumulatedBlock();
}
internal class HandlebarsDotNet.Compiler.BlockHelperAccumulatorContext : BlockAccumulatorContext {
    private HelperExpression _startingNode;
    private bool _trimBefore;
    private bool _trimAfter;
    private Expression _accumulatedBody;
    private Expression _accumulatedInversion;
    private List`1<Expression> _body;
    public string BlockName { get; protected set; }
    public BlockHelperAccumulatorContext(Expression startingNode);
    public sealed virtual string get_BlockName();
    protected sealed virtual void set_BlockName(string value);
    public virtual void HandleElement(Expression item);
    private bool IsInversionBlock(Expression item);
    public virtual bool IsClosingElement(Expression item);
    private bool IsClosingNode(Expression item);
    public virtual Expression GetAccumulatedBlock();
    private Expression GetBlockBody();
}
internal enum HandlebarsDotNet.Compiler.BlockHelperDirection : Enum {
    public int value__;
    public static BlockHelperDirection Direct;
    public static BlockHelperDirection Inverse;
}
internal class HandlebarsDotNet.Compiler.BlockHelperExpression : HelperExpression {
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Inversion>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockParamsExpression <BlockParams>k__BackingField;
    public Expression Body { get; }
    public Expression Inversion { get; }
    public BlockParamsExpression BlockParams { get; }
    public ExpressionType NodeType { get; }
    public BlockHelperExpression(string helperName, IEnumerable`1<Expression> arguments, Expression body, Expression inversion, bool isRaw);
    public BlockHelperExpression(string helperName, IEnumerable`1<Expression> arguments, BlockParamsExpression blockParams, Expression body, Expression inversion, bool isRaw);
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public Expression get_Inversion();
    [CompilerGeneratedAttribute]
public BlockParamsExpression get_BlockParams();
    public virtual ExpressionType get_NodeType();
}
internal class HandlebarsDotNet.Compiler.BlockHelperFunctionBinder : HandlebarsExpressionVisitor {
    private List`1<DecoratorDefinition> _decorators;
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public BlockHelperFunctionBinder(CompilationContext compilationContext, List`1<DecoratorDefinition> decorators);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
    protected virtual Expression VisitBlockHelperExpression(BlockHelperExpression bhex);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.BlockHelperFunctionBinder/<VisitDecoratorBlockExpression>d__7")]
private IEnumerable`1<DecoratorDefinition> VisitDecoratorBlockExpression(BlockHelperExpression bhex);
}
internal class HandlebarsDotNet.Compiler.BlockParam : object {
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private ChainSegment[] <Parameters>k__BackingField;
    public string Action { get; public set; }
    public ChainSegment[] Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(string value);
    [CompilerGeneratedAttribute]
public ChainSegment[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ChainSegment[] value);
}
internal class HandlebarsDotNet.Compiler.BlockParamsConverter : TokenConverter {
    private static BlockParamsConverter Converter;
    private static BlockParamsConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static void ConvertBlockParam(BlockParameterToken blockParameterToken, List`1<object> result);
    private static void VerifyBlockParamsSyntax(BlockParameterToken blockParameterToken, PathExpression pathExpression);
    private static void BlockParamsFound(Boolean& foundBlockParams, BlockParameterToken blockParameterToken);
}
internal class HandlebarsDotNet.Compiler.BlockParamsExpression : HandlebarsExpression {
    public BlockParam BlockParam;
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    private BlockParamsExpression(BlockParam blockParam);
    public BlockParamsExpression(string action, string blockParams);
    public static BlockParamsExpression Empty();
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    protected virtual Expression Accept(ExpressionVisitor visitor);
}
internal class HandlebarsDotNet.Compiler.BoolishConverter : HandlebarsExpressionVisitor {
    private CompilationContext _compilationContext;
    public BoolishConverter(CompilationContext compilationContext);
    protected virtual Expression VisitBoolishExpression(BoolishExpression bex);
}
internal class HandlebarsDotNet.Compiler.BoolishExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    public Expression Condition { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public BoolishExpression(Expression condition);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
public class HandlebarsDotNet.Compiler.Closure : object {
    public PathInfo PI0;
    public PathInfo PI1;
    public PathInfo PI2;
    public PathInfo PI3;
    public PathInfo[] PIA;
    public Ref`1<IHelperDescriptor`1<HelperOptions>> HD0;
    public Ref`1<IHelperDescriptor`1<HelperOptions>> HD1;
    public Ref`1<IHelperDescriptor`1<HelperOptions>> HD2;
    public Ref`1<IHelperDescriptor`1<HelperOptions>> HD3;
    public Ref`1[] HDA;
    public Ref`1<IHelperDescriptor`1<BlockHelperOptions>> BHD0;
    public Ref`1<IHelperDescriptor`1<BlockHelperOptions>> BHD1;
    public Ref`1<IHelperDescriptor`1<BlockHelperOptions>> BHD2;
    public Ref`1<IHelperDescriptor`1<BlockHelperOptions>> BHD3;
    public Ref`1[] BHDA;
    public Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> DD0;
    public Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> DD1;
    public Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> DD2;
    public Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> DD3;
    public Ref`1[] DDA;
    public Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> BDD0;
    public Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> BDD1;
    public Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> BDD2;
    public Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> BDD3;
    public Ref`1[] BDDA;
    public TemplateDelegate TD0;
    public TemplateDelegate TD1;
    public TemplateDelegate TD2;
    public TemplateDelegate TD3;
    public TemplateDelegate[] TDA;
    public DecoratorDelegate DDD0;
    public DecoratorDelegate DDD1;
    public DecoratorDelegate DDD2;
    public DecoratorDelegate DDD3;
    public DecoratorDelegate[] DDDA;
    public ChainSegment[] BP0;
    public ChainSegment[][] BPA;
    public Object[] A;
    internal Closure(PathInfo pi0, PathInfo pi1, PathInfo pi2, PathInfo pi3, PathInfo[] pia, Ref`1<IHelperDescriptor`1<HelperOptions>> hd0, Ref`1<IHelperDescriptor`1<HelperOptions>> hd1, Ref`1<IHelperDescriptor`1<HelperOptions>> hd2, Ref`1<IHelperDescriptor`1<HelperOptions>> hd3, Ref`1[] hda, Ref`1<IHelperDescriptor`1<BlockHelperOptions>> bhd0, Ref`1<IHelperDescriptor`1<BlockHelperOptions>> bhd1, Ref`1<IHelperDescriptor`1<BlockHelperOptions>> bhd2, Ref`1<IHelperDescriptor`1<BlockHelperOptions>> bhd3, Ref`1[] bhda, TemplateDelegate td0, TemplateDelegate td1, TemplateDelegate td2, TemplateDelegate td3, TemplateDelegate[] tda, ChainSegment[] bp0, ChainSegment[][] bpa, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> dd0, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> dd1, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> dd2, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>> dd3, Ref`1[] dda, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> bdd0, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> bdd1, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> bdd2, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>> bdd3, Ref`1[] bdda, DecoratorDelegate ddd0, DecoratorDelegate ddd1, DecoratorDelegate ddd2, DecoratorDelegate ddd3, DecoratorDelegate[] ddda, Object[] a);
}
public class HandlebarsDotNet.Compiler.ClosureBuilder : object {
    private List`1<KeyValuePair`2<ConstantExpression, PathInfo>> _pathInfos;
    private List`1<KeyValuePair`2<ConstantExpression, TemplateDelegate>> _templateDelegates;
    private List`1<KeyValuePair`2<ConstantExpression, DecoratorDelegate>> _decoratorDelegates;
    private List`1<KeyValuePair`2<ConstantExpression, ChainSegment[]>> _blockParams;
    private List`1<KeyValuePair`2<ConstantExpression, Ref`1<IHelperDescriptor`1<HelperOptions>>>> _helpers;
    private List`1<KeyValuePair`2<ConstantExpression, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>>> _blockHelpers;
    private List`1<KeyValuePair`2<ConstantExpression, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>>> _decorators;
    private List`1<KeyValuePair`2<ConstantExpression, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>>> _blockDecorators;
    private List`1<KeyValuePair`2<ConstantExpression, object>> _other;
    private static ClosureBuilderPool Pool;
    private static ClosureBuilder();
    public void Add(ConstantExpression constantExpression);
    public KeyValuePair`2<ParameterExpression, Dictionary`2<Expression, Expression>> Build(Closure& closure);
    private static void BuildKnownValues(List`1<object> arguments, List`1<KeyValuePair`2<ConstantExpression, T>> knowValues, int fieldsCount);
    private static void BuildKnownValuesExpressions(Expression closure, Dictionary`2<Expression, Expression> expressions, List`1<KeyValuePair`2<ConstantExpression, T>> knowValues, string prefix, int fieldsCount);
    public static ClosureBuilder Create();
    public sealed virtual void Dispose();
}
internal class HandlebarsDotNet.Compiler.CommentAndLayoutConverter : TokenConverter {
    private static CommentAndLayoutConverter Converter;
    private static CommentAndLayoutConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static object Convert(object item);
}
internal class HandlebarsDotNet.Compiler.CommentExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ExpressionType NodeType { get; }
    public CommentExpression(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual ExpressionType get_NodeType();
}
internal class HandlebarsDotNet.Compiler.CommentVisitor : HandlebarsExpressionVisitor {
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
}
public class HandlebarsDotNet.Compiler.CompilationContext : object {
    [CompilerGeneratedAttribute]
private ICompiledHandlebarsConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <BindingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <EncodedWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationContextArgs <Args>k__BackingField;
    public ICompiledHandlebarsConfiguration Configuration { get; }
    public ParameterExpression BindingContext { get; }
    public ParameterExpression EncodedWriter { get; }
    internal CompilationContextArgs Args { get; }
    public CompilationContext(ICompiledHandlebarsConfiguration configuration);
    public CompilationContext(CompilationContext context);
    [CompilerGeneratedAttribute]
public ICompiledHandlebarsConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public ParameterExpression get_BindingContext();
    [CompilerGeneratedAttribute]
public ParameterExpression get_EncodedWriter();
    [CompilerGeneratedAttribute]
internal CompilationContextArgs get_Args();
}
internal class HandlebarsDotNet.Compiler.ConditionalBlockAccumulatorContext : BlockAccumulatorContext {
    private static HashSet`1<string> ValidHelperNames;
    private List`1<ConditionalExpression> _conditionalBlock;
    private Expression _currentCondition;
    private List`1<Expression> _bodyBuffer;
    [CompilerGeneratedAttribute]
private string <BlockName>k__BackingField;
    public string BlockName { get; protected set; }
    public ConditionalBlockAccumulatorContext(Expression startingNode);
    private static ConditionalBlockAccumulatorContext();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BlockName();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_BlockName(string value);
    public virtual void HandleElement(Expression item);
    public virtual bool IsClosingElement(Expression item);
    public virtual Expression GetAccumulatedBlock();
    private bool IsElseBlock(Expression item);
    private bool IsElseIfBlock(Expression item);
    private Expression GetElseIfTestExpression(Expression item);
    private bool IsClosingNode(Expression item);
    private static Expression SinglifyExpressions(IEnumerable`1<Expression> expressions);
}
internal static class HandlebarsDotNet.Compiler.ContextBinder : object {
    public static Expression`1<TemplateDelegate> Bind(CompilationContext context, Expression body);
}
[IsReadOnlyAttribute]
internal class HandlebarsDotNet.Compiler.DecoratorDefinition : ValueType {
    [CompilerGeneratedAttribute]
private Expression <Decorator>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionContainer`1<TemplateDelegate> <Function>k__BackingField;
    public Expression Decorator { get; }
    public ExpressionContainer`1<TemplateDelegate> Function { get; }
    public DecoratorDefinition(Expression decorator, ExpressionContainer`1<TemplateDelegate> function);
    [CompilerGeneratedAttribute]
public Expression get_Decorator();
    [CompilerGeneratedAttribute]
public ExpressionContainer`1<TemplateDelegate> get_Function();
    public DecoratorDelegate Compile(CompilationContext context);
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.Compiler.DecoratorDefinitionsExtensions : object {
    [ExtensionAttribute]
public static DecoratorDelegate Compile(IReadOnlyList`1<DecoratorDefinition> decoratorDefinitions, CompilationContext context);
}
public class HandlebarsDotNet.Compiler.DecoratorDelegate : MulticastDelegate {
    public DecoratorDelegate(object object, IntPtr method);
    public virtual TemplateDelegate Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, TemplateDelegate function);
    public virtual IAsyncResult BeginInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, TemplateDelegate function, AsyncCallback callback, object object);
    public virtual TemplateDelegate EndInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, IAsyncResult result);
}
internal static class HandlebarsDotNet.Compiler.ExpressionBuilder : object {
    public static IEnumerable`1<Expression> ConvertTokensToExpressions(IEnumerable`1<object> tokens, ICompiledHandlebarsConfiguration configuration);
}
internal class HandlebarsDotNet.Compiler.ExpressionScopeConverter : TokenConverter {
    private static ExpressionScopeConverter Converter;
    private static ExpressionScopeConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.ExpressionScopeConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal static class HandlebarsDotNet.Compiler.FunctionBinderHelpers : object {
    private static LookupSlim`3<int, GcDeferredValue`2<int, ConstructorInfo>, IntegerEqualityComparer> ArgumentsConstructorsMap;
    private static Func`2<int, GcDeferredValue`2<int, ConstructorInfo>> CtorFactory;
    private static FunctionBinderHelpers();
    public static ExpressionContainer`1<Arguments> CreateArguments(IEnumerable`1<Expression> expressions, CompilationContext compilationContext);
}
internal static class HandlebarsDotNet.Compiler.FunctionBuilder : object {
    private static TemplateDelegate EmptyTemplateLambda;
    private static FunctionBuilder();
    public static Expression Reduce(Expression expression, CompilationContext context, IReadOnlyList`1& decorators);
    public static ExpressionContainer`1<TemplateDelegate> CreateExpression(IEnumerable`1<Expression> expressions, CompilationContext compilationContext, IReadOnlyList`1& decorators);
    public static TemplateDelegate Compile(IEnumerable`1<Expression> expressions, CompilationContext compilationContext, IReadOnlyList`1& decorators);
}
internal static class HandlebarsDotNet.Compiler.HandlebarsCompiler : object {
    public static TemplateDelegate Compile(ExtendedStringReader source, CompilationContext compilationContext);
    internal static TemplateDelegate CompileView(ViewReaderFactory readerFactoryFactory, string templatePath, CompilationContext compilationContext);
}
internal abstract class HandlebarsDotNet.Compiler.HandlebarsExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <CanReduce>k__BackingField;
    public Type Type { get; }
    public bool CanReduce { get; }
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public virtual bool get_CanReduce();
    public static HelperExpression Helper(string helperName, bool isBlock, IEnumerable`1<Expression> arguments, bool isRaw);
    public static HelperExpression Helper(string helperName, bool isBlock, bool isRaw, IReaderContext context);
    public static BlockHelperExpression BlockHelper(string helperName, IEnumerable`1<Expression> arguments, BlockParamsExpression blockParams, Expression body, Expression inversion, bool isRaw);
    public static PathExpression Path(string path);
    public static BlockParamsExpression BlockParams(string action, string blockParams);
    public static StaticExpression Static(string value);
    public static StatementExpression Statement(Expression body, bool isEscaped, bool trimBefore, bool trimAfter);
    public static IteratorExpression Iterator(string helperName, Expression sequence, BlockParamsExpression blockParams, Expression template);
    public static IteratorExpression Iterator(string helperName, Expression sequence, BlockParamsExpression blockParams, Expression template, Expression ifEmpty);
    public static PartialExpression Partial(Expression partialName);
    public static PartialExpression Partial(Expression partialName, Expression argument);
    public static PartialExpression Partial(Expression partialName, Expression argument, Expression fallback);
    public static BoolishExpression Boolish(Expression condition);
    public static SubExpressionExpression SubExpression(Expression expression);
    public static HashParameterAssignmentExpression HashParameterAssignmentExpression(string name);
    public static HashParametersExpression HashParametersExpression(Dictionary`2<string, Expression> parameters);
    public static CommentExpression Comment(string value);
}
internal enum HandlebarsDotNet.Compiler.HandlebarsExpressionType : Enum {
    public int value__;
    public static HandlebarsExpressionType StaticExpression;
    public static HandlebarsExpressionType StatementExpression;
    public static HandlebarsExpressionType BlockExpression;
    public static HandlebarsExpressionType HelperExpression;
    public static HandlebarsExpressionType PathExpression;
    public static HandlebarsExpressionType IteratorExpression;
    public static HandlebarsExpressionType PartialExpression;
    public static HandlebarsExpressionType BoolishExpression;
    public static HandlebarsExpressionType SubExpression;
    public static HandlebarsExpressionType HashParameterAssignmentExpression;
    public static HandlebarsExpressionType HashParametersExpression;
    public static HandlebarsExpressionType CommentExpression;
    public static HandlebarsExpressionType BlockParamsExpression;
}
internal class HandlebarsDotNet.Compiler.HandlebarsExpressionVisitor : ExpressionVisitor {
    public virtual Expression Visit(Expression exp);
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
    protected virtual Expression VisitPathExpression(PathExpression pex);
    protected virtual Expression VisitHelperExpression(HelperExpression hex);
    protected virtual Expression VisitBlockHelperExpression(BlockHelperExpression bhex);
    protected virtual Expression VisitStaticExpression(StaticExpression stex);
    protected virtual Expression VisitIteratorExpression(IteratorExpression iex);
    protected virtual Expression VisitPartialExpression(PartialExpression pex);
    protected virtual Expression VisitBoolishExpression(BoolishExpression bex);
    protected virtual Expression VisitSubExpression(SubExpressionExpression subex);
    protected virtual Expression VisitHashParametersExpression(HashParametersExpression hpex);
    private IEnumerable`1<Expression> VisitExpressionList(IEnumerable`1<Expression> original);
}
public class HandlebarsDotNet.Compiler.HandlebarsUndefinedBindingException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MissingKey>k__BackingField;
    public string Path { get; }
    public string MissingKey { get; }
    public HandlebarsUndefinedBindingException(string path, string missingKey);
    public HandlebarsUndefinedBindingException(string path, UndefinedBindingResult undefined);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_MissingKey();
}
internal class HandlebarsDotNet.Compiler.HashParameterAssignmentExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public HashParameterAssignmentExpression(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
internal class HandlebarsDotNet.Compiler.HashParameterBinder : HandlebarsExpressionVisitor {
    protected virtual Expression VisitHashParametersExpression(HashParametersExpression hpex);
}
internal class HandlebarsDotNet.Compiler.HashParameterConverter : TokenConverter {
    private static HashParameterConverter Converter;
    private static HashParameterConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.HashParameterConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
public class HandlebarsDotNet.Compiler.HashParameterDictionary : Dictionary`2<string, object> {
    internal static IReadOnlyDictionary`2<string, object> Empty;
    private static HashParameterDictionary();
}
internal class HandlebarsDotNet.Compiler.HashParametersAccumulator : TokenConverter {
    private static HashParametersAccumulator Accumulator;
    private static HashParametersAccumulator();
    public static IEnumerable`1<object> Accumulate(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.HashParametersAccumulator/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private Dictionary`2<string, Expression> AccumulateParameters(IEnumerator`1<object> enumerator, Boolean& moveNext);
    private Expression Visit(Expression expression);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal class HandlebarsDotNet.Compiler.HashParametersExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Expression> <Parameters>k__BackingField;
    public Dictionary`2<string, Expression> Parameters { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public HashParametersExpression(Dictionary`2<string, Expression> parameters);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Expression> get_Parameters();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
internal class HandlebarsDotNet.Compiler.HelperArgumentAccumulator : TokenConverter {
    private static HelperArgumentAccumulator Accumulator;
    private static HelperArgumentAccumulator();
    public static IEnumerable`1<object> Accumulate(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.HelperArgumentAccumulator/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static List`1<Expression> AccumulateArguments(IEnumerator`1<object> enumerator);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal class HandlebarsDotNet.Compiler.HelperConverter : TokenConverter {
    private static HashSet`1<string> BuiltInHelpers;
    private ICompiledHandlebarsConfiguration _configuration;
    private HelperConverter(ICompiledHandlebarsConfiguration configuration);
    private static HelperConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence, ICompiledHandlebarsConfiguration configuration);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.HelperConverter/<ConvertTokens>d__4")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private bool IsRegisteredHelperName(string name);
    private bool IsRegisteredBlockHelperName(string name, bool isRaw);
    private bool IsUnregisteredBlockHelperName(string name, bool isRaw, IEnumerable`1<object> sequence);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal class HandlebarsDotNet.Compiler.HelperExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private string <HelperName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Expression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public string HelperName { get; }
    public bool IsRaw { get; }
    public bool IsBlock { get; public set; }
    public IEnumerable`1<Expression> Arguments { get; }
    public IReaderContext Context { get; }
    public HelperExpression(string helperName, bool isBlock, IEnumerable`1<Expression> arguments, bool isRaw, IReaderContext context);
    public HelperExpression(string helperName, bool isBlock, bool isRaw, IReaderContext context);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public string get_HelperName();
    [CompilerGeneratedAttribute]
public bool get_IsRaw();
    [CompilerGeneratedAttribute]
public bool get_IsBlock();
    [CompilerGeneratedAttribute]
public void set_IsBlock(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Expression> get_Arguments();
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
}
internal class HandlebarsDotNet.Compiler.HelperFunctionBinder : HandlebarsExpressionVisitor {
    private List`1<DecoratorDefinition> _decorators;
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public HelperFunctionBinder(CompilationContext compilationContext, List`1<DecoratorDefinition> decorators);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
    protected virtual Expression VisitHelperExpression(HelperExpression hex);
    private DecoratorDefinition VisitDecoratorExpression(HelperExpression hex);
}
internal static class HandlebarsDotNet.Compiler.Iterator : object {
    public static void Iterate(BindingContext context, EncodedTextWriter writer, ChainSegment[] blockParamsVariables, object target, TemplateDelegate template, TemplateDelegate ifEmpty);
}
internal class HandlebarsDotNet.Compiler.IteratorBinder : HandlebarsExpressionVisitor {
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public IteratorBinder(CompilationContext compilationContext);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitIteratorExpression(IteratorExpression iex);
}
internal class HandlebarsDotNet.Compiler.IteratorBlockAccumulatorContext : BlockAccumulatorContext {
    private HelperExpression _startingNode;
    private Expression _accumulatedExpression;
    private List`1<Expression> _body;
    public string BlockName { get; protected set; }
    public IteratorBlockAccumulatorContext(Expression startingNode);
    public sealed virtual string get_BlockName();
    protected sealed virtual void set_BlockName(string value);
    public virtual void HandleElement(Expression item);
    public virtual bool IsClosingElement(Expression item);
    public virtual Expression GetAccumulatedBlock();
    private static bool IsClosingNode(Expression item);
    private static bool IsElseBlock(Expression item);
}
internal class HandlebarsDotNet.Compiler.IteratorExpression : BlockHelperExpression {
    [CompilerGeneratedAttribute]
private Expression <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Template>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <IfEmpty>k__BackingField;
    public Expression Sequence { get; }
    public Expression Template { get; }
    public Expression IfEmpty { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public IteratorExpression(string helperName, Expression sequence, BlockParamsExpression blockParams, Expression template, Expression ifEmpty);
    [CompilerGeneratedAttribute]
public Expression get_Sequence();
    [CompilerGeneratedAttribute]
public Expression get_Template();
    [CompilerGeneratedAttribute]
public Expression get_IfEmpty();
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
}
internal class HandlebarsDotNet.Compiler.Lexer.AssignmentToken : Token {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public IReaderContext Context { get; }
    public TokenType Type { get; }
    public string Value { get; }
    public AssignmentToken(IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    public virtual TokenType get_Type();
    public virtual string get_Value();
}
internal class HandlebarsDotNet.Compiler.Lexer.BlockParameterToken : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public TokenType Type { get; }
    public string Value { get; }
    public IReaderContext Context { get; }
    public BlockParameterToken(string value, IReaderContext context);
    public virtual TokenType get_Type();
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
}
internal class HandlebarsDotNet.Compiler.Lexer.BlockParamsParser : Parser {
    public virtual Token Parse(ExtendedStringReader reader);
    private static string AccumulateWord(ExtendedStringReader reader);
}
internal class HandlebarsDotNet.Compiler.Lexer.BlockWordParser : Parser {
    private static HashSet`1<char> ValidBlockWordStartCharacters;
    private static BlockWordParser();
    public virtual Token Parse(ExtendedStringReader reader);
    private static bool IsBlockWord(ExtendedStringReader reader);
    private static string AccumulateBlockWord(ExtendedStringReader reader);
}
internal class HandlebarsDotNet.Compiler.Lexer.CommentParser : Parser {
    public virtual Token Parse(ExtendedStringReader reader);
    private static bool IsComment(ExtendedStringReader reader);
    private static string AccumulateComment(ExtendedStringReader reader, Boolean& isEscaped);
    private static bool IsClosed(ExtendedStringReader reader, StringBuilder buffer, bool isEscaped);
    private static bool CheckIfStatementClosed(ExtendedStringReader reader);
    private static bool CheckIfEscaped(ExtendedStringReader reader, StringBuilder buffer);
}
internal class HandlebarsDotNet.Compiler.Lexer.CommentToken : Token {
    private string _comment;
    public TokenType Type { get; }
    public string Value { get; }
    public CommentToken(string comment);
    public virtual TokenType get_Type();
    public virtual string get_Value();
}
internal class HandlebarsDotNet.Compiler.Lexer.EndExpressionToken : ExpressionScopeToken {
    [CompilerGeneratedAttribute]
private bool <IsEscaped>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimTrailingWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public bool IsEscaped { get; }
    public bool TrimTrailingWhitespace { get; }
    public bool IsRaw { get; }
    public IReaderContext Context { get; }
    public string Value { get; }
    public TokenType Type { get; }
    public EndExpressionToken(bool isEscaped, bool trimWhitespace, bool isRaw, IReaderContext context);
    [CompilerGeneratedAttribute]
public bool get_IsEscaped();
    [CompilerGeneratedAttribute]
public bool get_TrimTrailingWhitespace();
    [CompilerGeneratedAttribute]
public bool get_IsRaw();
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    public virtual string get_Value();
    public virtual TokenType get_Type();
}
internal class HandlebarsDotNet.Compiler.Lexer.EndSubExpressionToken : ExpressionScopeToken {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public IReaderContext Context { get; }
    public string Value { get; }
    public TokenType Type { get; }
    public EndSubExpressionToken(IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    public virtual TokenType get_Type();
}
internal abstract class HandlebarsDotNet.Compiler.Lexer.ExpressionScopeToken : Token {
}
internal abstract class HandlebarsDotNet.Compiler.Lexer.ExpressionToken : Token {
}
internal class HandlebarsDotNet.Compiler.Lexer.LayoutToken : Token {
    private string _layout;
    public TokenType Type { get; }
    public string Value { get; }
    public LayoutToken(string layout);
    public virtual TokenType get_Type();
    public virtual string get_Value();
}
internal class HandlebarsDotNet.Compiler.Lexer.LiteralExpressionToken : ExpressionToken {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public IReaderContext Context { get; }
    public bool IsDelimitedLiteral { get; }
    public string Delimiter { get; }
    public TokenType Type { get; }
    public string Value { get; }
    public LiteralExpressionToken(string value, string delimiter, IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    public bool get_IsDelimitedLiteral();
    [CompilerGeneratedAttribute]
public string get_Delimiter();
    public virtual TokenType get_Type();
    [CompilerGeneratedAttribute]
public virtual string get_Value();
}
internal class HandlebarsDotNet.Compiler.Lexer.LiteralParser : Parser {
    public virtual Token Parse(ExtendedStringReader reader);
    private static bool IsDelimitedLiteral(ExtendedStringReader reader);
    private static bool IsNonDelimitedLiteral(ExtendedStringReader reader);
    private static string AccumulateLiteral(ExtendedStringReader reader, bool captureDelimiter, Char[] delimiters);
}
internal abstract class HandlebarsDotNet.Compiler.Lexer.Parser : object {
    public abstract virtual Token Parse(ExtendedStringReader reader);
}
internal class HandlebarsDotNet.Compiler.Lexer.PartialParser : Parser {
    public virtual Token Parse(ExtendedStringReader reader);
}
internal class HandlebarsDotNet.Compiler.Lexer.PartialToken : Token {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public IReaderContext Context { get; }
    public TokenType Type { get; }
    public string Value { get; }
    public PartialToken(IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    public virtual TokenType get_Type();
    public virtual string get_Value();
}
internal class HandlebarsDotNet.Compiler.Lexer.StartExpressionToken : ExpressionScopeToken {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEscaped>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimPreceedingWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRaw>k__BackingField;
    public IReaderContext Context { get; }
    public bool IsEscaped { get; }
    public bool TrimPreceedingWhitespace { get; }
    public bool IsRaw { get; }
    public string Value { get; }
    public TokenType Type { get; }
    public StartExpressionToken(bool isEscaped, bool trimWhitespace, bool isRaw, IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    [CompilerGeneratedAttribute]
public bool get_IsEscaped();
    [CompilerGeneratedAttribute]
public bool get_TrimPreceedingWhitespace();
    [CompilerGeneratedAttribute]
public bool get_IsRaw();
    public virtual string get_Value();
    public virtual TokenType get_Type();
}
internal class HandlebarsDotNet.Compiler.Lexer.StartSubExpressionToken : ExpressionScopeToken {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public TokenType Type { get; }
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    public virtual TokenType get_Type();
}
internal class HandlebarsDotNet.Compiler.Lexer.StaticToken : Token {
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Original>k__BackingField;
    public IReaderContext Context { get; }
    public TokenType Type { get; }
    public string Value { get; }
    public string Original { get; }
    private StaticToken(string value, string original, IReaderContext context);
    internal StaticToken(string value, IReaderContext context);
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
    public virtual TokenType get_Type();
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    [CompilerGeneratedAttribute]
public string get_Original();
    public StaticToken GetModifiedToken(string value);
}
internal abstract class HandlebarsDotNet.Compiler.Lexer.Token : object {
    public TokenType Type { get; }
    public string Value { get; }
    public abstract virtual TokenType get_Type();
    public abstract virtual string get_Value();
    public sealed virtual string ToString();
    public static StaticToken Static(string value, IReaderContext context);
    public static LiteralExpressionToken Literal(string value, string delimiter, IReaderContext context);
    public static WordExpressionToken Word(string word, IReaderContext context);
    public static StartExpressionToken StartExpression(bool isEscaped, bool trimWhitespace, bool isRaw, IReaderContext context);
    public static EndExpressionToken EndExpression(bool isEscaped, bool trimWhitespace, bool isRaw, IReaderContext context);
    public static CommentToken Comment(string comment);
    public static PartialToken Partial(IReaderContext context);
    public static LayoutToken Layout(string layout);
    public static StartSubExpressionToken StartSubExpression();
    public static EndSubExpressionToken EndSubExpression(IReaderContext context);
    public static AssignmentToken Assignment(IReaderContext context);
    public static BlockParameterToken BlockParams(string blockParams, IReaderContext context);
}
internal static class HandlebarsDotNet.Compiler.Lexer.Tokenizer : object {
    private static Parser WordParser;
    private static Parser LiteralParser;
    private static Parser CommentParser;
    private static Parser PartialParser;
    private static Parser BlockWordParser;
    private static Parser BlockParamsParser;
    private static Tokenizer();
    public static IEnumerable`1<Token> Tokenize(ExtendedStringReader source);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.Lexer.Tokenizer/<Parse>d__7")]
private static IEnumerable`1<Token> Parse(ExtendedStringReader source);
}
internal enum HandlebarsDotNet.Compiler.Lexer.TokenType : Enum {
    public int value__;
    public static TokenType Static;
    public static TokenType StartExpression;
    public static TokenType EndExpression;
    public static TokenType Word;
    public static TokenType Literal;
    public static TokenType Structure;
    public static TokenType Comment;
    public static TokenType Partial;
    public static TokenType Layout;
    public static TokenType StartSubExpression;
    public static TokenType EndSubExpression;
    public static TokenType Assignment;
    public static TokenType BlockParams;
}
internal class HandlebarsDotNet.Compiler.Lexer.WordExpressionToken : ExpressionToken {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IReaderContext <Context>k__BackingField;
    public TokenType Type { get; }
    public string Value { get; }
    public IReaderContext Context { get; }
    public WordExpressionToken(string word, IReaderContext context);
    public virtual TokenType get_Type();
    [CompilerGeneratedAttribute]
public virtual string get_Value();
    [CompilerGeneratedAttribute]
public IReaderContext get_Context();
}
internal class HandlebarsDotNet.Compiler.Lexer.WordParser : Parser {
    private static string ValidWordStartCharactersString;
    private static HashSet`1<char> ValidWordStartCharacters;
    private static WordParser();
    public virtual Token Parse(ExtendedStringReader reader);
    private static bool IsWord(ExtendedStringReader reader);
    private static string AccumulateWord(ExtendedStringReader reader);
}
internal class HandlebarsDotNet.Compiler.LiteralConverter : TokenConverter {
    private static LiteralConverter Converter;
    private static LiteralConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.LiteralConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
}
internal class HandlebarsDotNet.Compiler.Middlewares.ClosureExpressionMiddleware : object {
    public sealed virtual Expression`1<T> Invoke(Expression`1<T> expression);
}
internal class HandlebarsDotNet.Compiler.Middlewares.ExpressionOptimizerMiddleware : object {
    public sealed virtual Expression`1<T> Invoke(Expression`1<T> expression);
}
internal class HandlebarsDotNet.Compiler.PartialBinder : HandlebarsExpressionVisitor {
    private static string SpecialPartialBlockName;
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public PartialBinder(CompilationContext compilationContext);
    private static PartialBinder();
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitBlockHelperExpression(BlockHelperExpression bhex);
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
    protected virtual Expression VisitPartialExpression(PartialExpression pex);
    private static void InvokePartialWithFallback(string partialName, BindingContext context, EncodedTextWriter writer, ICompiledHandlebarsConfiguration configuration);
    private static bool InvokePartial(string partialName, BindingContext context, EncodedTextWriter writer, ICompiledHandlebarsConfiguration configuration);
    [CompilerGeneratedAttribute]
internal static void <InvokePartial>g__IncreaseDepth|9_0(<>c__DisplayClass9_0& );
}
internal class HandlebarsDotNet.Compiler.PartialBlockAccumulatorContext : BlockAccumulatorContext {
    private PartialExpression _startingNode;
    private List`1<Expression> _body;
    [CompilerGeneratedAttribute]
private string <BlockName>k__BackingField;
    public string BlockName { get; protected set; }
    public PartialBlockAccumulatorContext(Expression startingNode);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BlockName();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_BlockName(string value);
    public virtual void HandleElement(Expression item);
    public virtual Expression GetAccumulatedBlock();
    public virtual bool IsClosingElement(Expression item);
    private bool IsClosingNode(Expression item);
    private PartialExpression ConvertToPartialExpression(Expression expression);
}
internal class HandlebarsDotNet.Compiler.PartialConverter : TokenConverter {
    private static PartialConverter Converter;
    private static PartialConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.PartialConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static List`1<Expression> AccumulateArguments(IEnumerator`1<object> enumerator);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal class HandlebarsDotNet.Compiler.PartialExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private Expression <PartialName>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Fallback>k__BackingField;
    public ExpressionType NodeType { get; }
    public Expression PartialName { get; }
    public Expression Argument { get; }
    public Expression Fallback { get; }
    public PartialExpression(Expression partialName, Expression argument, Expression fallback);
    public virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_PartialName();
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    [CompilerGeneratedAttribute]
public Expression get_Fallback();
}
internal class HandlebarsDotNet.Compiler.PathBinder : HandlebarsExpressionVisitor {
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public PathBinder(CompilationContext compilationContext);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
    protected virtual Expression VisitPathExpression(PathExpression pex);
}
internal class HandlebarsDotNet.Compiler.PathConverter : TokenConverter {
    private static PathConverter Converter;
    private static PathConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.PathConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
}
internal class HandlebarsDotNet.Compiler.PathExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolutionContext <Context>k__BackingField;
    public string Path { get; }
    public ResolutionContext Context { get; public set; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public PathExpression(string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public ResolutionContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ResolutionContext value);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
internal class HandlebarsDotNet.Compiler.RawHelperAccumulator : TokenConverter {
    private static RawHelperAccumulator Accumulator;
    private static RawHelperAccumulator();
    public static IEnumerable`1<object> Accumulate(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.RawHelperAccumulator/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.RawHelperAccumulator/<CollectParameters>d__4")]
private IEnumerable`1<object> CollectParameters(IEnumerator`1<object> enumerator, string rawHelperName);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.RawHelperAccumulator/<CollectBody>d__5")]
private IEnumerable`1<object> CollectBody(IEnumerator`1<object> enumerator, string rawHelperName);
    private bool IsClosingTag(StartExpressionToken startExpressionToken, object item, string helperName);
    private static string Stringify(object item, object precedingItem);
    private static string PrependWhitespaceWhereNeeded(string value, Token currToken, object precedingItem);
    private static string StringifyToken(Token token);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
public interface HandlebarsDotNet.Compiler.Resolvers.IExpressionNameResolver {
    public abstract virtual string ResolveExpressionName(object instance, string expressionName);
}
public class HandlebarsDotNet.Compiler.Resolvers.UpperCamelCaseExpressionNameResolver : object {
    public sealed virtual string ResolveExpressionName(object instance, string expressionName);
}
internal class HandlebarsDotNet.Compiler.StatementExpression : HandlebarsExpression {
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEscaped>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimAfter>k__BackingField;
    public Expression Body { get; }
    public bool IsEscaped { get; }
    public bool TrimBefore { get; }
    public bool TrimAfter { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public StatementExpression(Expression body, bool isEscaped, bool trimBefore, bool trimAfter);
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public bool get_IsEscaped();
    [CompilerGeneratedAttribute]
public bool get_TrimBefore();
    [CompilerGeneratedAttribute]
public bool get_TrimAfter();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
}
internal class HandlebarsDotNet.Compiler.StaticConverter : TokenConverter {
    private static StaticConverter Converter;
    private static StaticConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.StaticConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
}
internal class HandlebarsDotNet.Compiler.StaticExpression : HandlebarsExpression {
    private string _value;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public string Value { get; }
    public StaticExpression(string value);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public string get_Value();
}
internal class HandlebarsDotNet.Compiler.StaticReplacer : HandlebarsExpressionVisitor {
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public StaticReplacer(CompilationContext compilationContext);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitStaticExpression(StaticExpression stex);
}
internal class HandlebarsDotNet.Compiler.SubExpressionConverter : TokenConverter {
    private static SubExpressionConverter Converter;
    private static SubExpressionConverter();
    public static IEnumerable`1<object> Convert(IEnumerable`1<object> sequence);
    [IteratorStateMachineAttribute("HandlebarsDotNet.Compiler.SubExpressionConverter/<ConvertTokens>d__3")]
public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static SubExpressionExpression BuildSubExpression(IEnumerator`1<object> enumerator);
    private static IEnumerable`1<Expression> AccumulateSubExpression(IEnumerator`1<object> enumerator);
    private static object GetNext(IEnumerator`1<object> enumerator);
}
internal class HandlebarsDotNet.Compiler.SubExpressionVisitor : HandlebarsExpressionVisitor {
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public SubExpressionVisitor(CompilationContext compilationContext);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitSubExpression(SubExpressionExpression subex);
    private static Expression HandleMethodCallExpression(MethodCallExpression helperCall);
}
public class HandlebarsDotNet.Compiler.TemplateDelegate : MulticastDelegate {
    public TemplateDelegate(object object, IntPtr method);
    public virtual void Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context);
    public virtual IAsyncResult BeginInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, IAsyncResult result);
}
internal abstract class HandlebarsDotNet.Compiler.TokenConverter : object {
    public abstract virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
}
internal class HandlebarsDotNet.Compiler.UnencodedStatementVisitor : HandlebarsExpressionVisitor {
    [CompilerGeneratedAttribute]
private CompilationContext <CompilationContext>k__BackingField;
    private CompilationContext CompilationContext { get; }
    public UnencodedStatementVisitor(CompilationContext compilationContext);
    [CompilerGeneratedAttribute]
private CompilationContext get_CompilationContext();
    protected virtual Expression VisitStatementExpression(StatementExpression sex);
}
internal class HandlebarsDotNet.Compiler.WhitespaceRemover : TokenConverter {
    private static Regex MatchLastStartsWithWhitespace;
    private static Regex MatchStartsWithWhitespace;
    private static Regex TrimStartRegex;
    private static Regex MatchFirstEndsWithWhitespace;
    private static Regex MatchEndsWithWhitespace;
    private static Regex TrimEndRegex;
    private static WhitespaceRemover Remover;
    private static WhitespaceRemover();
    public static IEnumerable`1<object> Remove(IEnumerable`1<object> sequence);
    private static IList`1<object> ToList(IEnumerable`1<object> sequence);
    public virtual IEnumerable`1<object> ConvertTokens(IEnumerable`1<object> sequence);
    private static void ProcessTokens(IList`1<object> list);
    private static bool IsNextWhitespace(IList`1<object> list, int index);
    private static void TrimAfter(IList`1<object> list, int index, bool multipleLines);
    private static Token TrimStart(StaticToken token, bool multipleLines);
    private static bool IsPrevWhitespace(IList`1<object> list, int index);
    private static void TrimBefore(IList`1<object> list, int index, bool multipleLines);
    private static Token TrimEnd(StaticToken token, bool multipleLines);
    private static bool IsStandalone(StatementExpression statement);
    private static bool IsBlockStatement(StatementExpression statement);
    private static bool IsSectionOrClosingNode(PathExpression pathExpression);
    private static bool IsBlockHelperOrInversion(HelperExpression helperExpression);
}
public class HandlebarsDotNet.CompileTimeConfiguration : object {
    [CompilerGeneratedAttribute]
private IList`1<IExpressionMiddleware> <ExpressionMiddleware>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IFeatureFactory> <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionCompiler <ExpressionCompiler>k__BackingField;
    public IList`1<IExpressionMiddleware> ExpressionMiddleware { get; }
    public IList`1<IFeatureFactory> Features { get; }
    public IExpressionCompiler ExpressionCompiler { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<IExpressionMiddleware> get_ExpressionMiddleware();
    [CompilerGeneratedAttribute]
public IList`1<IFeatureFactory> get_Features();
    [CompilerGeneratedAttribute]
public IExpressionCompiler get_ExpressionCompiler();
    [CompilerGeneratedAttribute]
public void set_ExpressionCompiler(IExpressionCompiler value);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.Context : ValueType {
    private DeferredValue`2<BindingContext, ObjectDescriptor> _descriptor;
    public object Value;
    public IEnumerable`1<ChainSegment> Properties { get; }
    public object Item { get; }
    public Context(BindingContext context);
    public Context(BindingContext context, object value);
    public IEnumerable`1<ChainSegment> get_Properties();
    public object get_Item(ChainSegment segment);
    public T GetValue(ChainSegment segment);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.DecoratorOptions : ValueType {
    [CompilerGeneratedAttribute]
private BindingContext <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public BindingContext Frame { get; }
    public DataValues Data { get; }
    public PathInfo Name { get; }
    public DecoratorOptions(PathInfo name, BindingContext frame);
    [CompilerGeneratedAttribute]
public sealed virtual BindingContext get_Frame();
    public sealed virtual DataValues get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetHelpers();
    private sealed virtual override IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> HandlebarsDotNet.IHelpersRegistry.GetBlockHelpers();
}
public class HandlebarsDotNet.Decorators.DelegateBlockDecoratorDescriptor : object {
    private HandlebarsBlockDecorator _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateBlockDecoratorDescriptor(string name, HandlebarsBlockDecorator helper);
    public TemplateDelegate Invoke(TemplateDelegate& function, BlockDecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.BlockDecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Decorators.DelegateBlockDecoratorVoidDescriptor : object {
    private HandlebarsBlockDecoratorVoid _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateBlockDecoratorVoidDescriptor(string name, HandlebarsBlockDecoratorVoid helper);
    public TemplateDelegate Invoke(TemplateDelegate& function, BlockDecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.BlockDecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Decorators.DelegateDecoratorDescriptor : object {
    private HandlebarsDecorator _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateDecoratorDescriptor(string name, HandlebarsDecorator helper);
    public TemplateDelegate Invoke(TemplateDelegate& function, DecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.DecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Decorators.DelegateDecoratorVoidDescriptor : object {
    private HandlebarsDecoratorVoid _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateDecoratorVoidDescriptor(string name, HandlebarsDecoratorVoid helper);
    public TemplateDelegate Invoke(TemplateDelegate& function, DecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.DecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Decorators.EmptyBlockDecorator : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public EmptyBlockDecorator(PathInfo name);
    public TemplateDelegate Invoke(TemplateDelegate& function, BlockDecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.BlockDecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Decorators.EmptyDecorator : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public EmptyDecorator(PathInfo name);
    public TemplateDelegate Invoke(TemplateDelegate& function, DecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.DecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public interface HandlebarsDotNet.Decorators.IDecoratorDescriptor {
    public PathInfo Name { get; }
    public abstract virtual PathInfo get_Name();
}
public interface HandlebarsDotNet.Decorators.IDecoratorDescriptor`1 {
    public abstract virtual TemplateDelegate Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, TOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public interface HandlebarsDotNet.Decorators.IDecoratorOptions {
    public DataValues Data { get; }
    public PathInfo Name { get; }
    public abstract virtual DataValues get_Data();
    public abstract virtual PathInfo get_Name();
}
internal class HandlebarsDotNet.Decorators.InlineBlockDecoratorDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public TemplateDelegate Invoke(TemplateDelegate& function, BlockDecoratorOptions& options, Context& context, Arguments& arguments);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    private sealed virtual override TemplateDelegate HandlebarsDotNet.Decorators.IDecoratorDescriptor<HandlebarsDotNet.BlockDecoratorOptions>.Invoke(TemplateDelegate& modreq(System.Runtime.InteropServices.InAttribute) function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.DelegatedMemberAliasProvider : object {
    private Dictionary`2<Type, Dictionary`2<string, Func`2<object, object>>> _aliases;
    public DelegatedMemberAliasProvider AddAlias(Type type, string alias, Func`2<object, object> accessor);
    public DelegatedMemberAliasProvider AddAlias(string alias, Func`2<T, object> accessor);
    private sealed virtual override bool HandlebarsDotNet.IMemberAliasProvider<System.Object>.TryGetMemberByAlias(object instance, Type targetType, ChainSegment memberAlias, Object& value);
}
public class HandlebarsDotNet.DynamicViewModel : DynamicObject {
    private Object[] _objects;
    private static BindingFlags BindingFlags;
    public DynamicViewModel(Object[] objects);
    private static DynamicViewModel();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.EncodedTextWriter : ValueType {
    private IFormatterProvider _formatterProvider;
    private TextEncoderWrapper _encoder;
    internal TextWriter UnderlyingWriter;
    public bool SuppressEncoding { get; public set; }
    public Encoding Encoding { get; }
    public EncodedTextWriter(TextWriter writer, ITextEncoder encoder, IFormatterProvider formatterProvider, bool suppressEncoding);
    public bool get_SuppressEncoding();
    public void set_SuppressEncoding(bool value);
    public TextWriter CreateWrapper();
    public void Write(string value, bool encode);
    public void Write(StringBuilder value, bool encode);
    public void Write(Substring value, bool encode);
    public void Write(T value, bool encode);
    public void Write(string value);
    public void Write(string format, Object[] arguments);
    public void Write(char value);
    public void Write(object value);
    public void Write(T value);
    private void WriteFormatted(T value);
    public Encoding get_Encoding();
    public sealed virtual void Dispose();
    public virtual string ToString();
}
internal class HandlebarsDotNet.EncodedTextWriterWrapper : TextWriter {
    private static InternalObjectPool`2<EncodedTextWriterWrapper, Policy> Pool;
    [CompilerGeneratedAttribute]
private EncodedTextWriter <UnderlyingWriter>k__BackingField;
    public EncodedTextWriter UnderlyingWriter { get; private set; }
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    private static EncodedTextWriterWrapper();
    [CompilerGeneratedAttribute]
public EncodedTextWriter get_UnderlyingWriter();
    [CompilerGeneratedAttribute]
private void set_UnderlyingWriter(EncodedTextWriter value);
    public static TextWriter From(EncodedTextWriter& encodedTextWriter);
    public virtual IFormatProvider get_FormatProvider();
    public void Write(string value, bool encode);
    public void Write(StringBuilder value, bool encode);
    public virtual void Write(string value);
    public virtual void Write(char value);
    public virtual void Write(int value);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(decimal value);
    public virtual void Write(bool value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(UInt32 value);
    public virtual void Write(object value);
    public virtual Encoding get_Encoding();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool Any(IEnumerable builder);
    [ExtensionAttribute]
public static bool IsOneOf(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool IsMultiple(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("HandlebarsDotNet.EnumerableExtensions/<ApplyOn>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> ApplyOn(IEnumerable`1<T> source, Action`1<TV> mutator);
    [IteratorStateMachineAttribute("HandlebarsDotNet.EnumerableExtensions/<Append>d__4`2")]
[ExtensionAttribute]
public static IEnumerable`1<T> Append(TEnumerable source, T item);
    [ExtensionAttribute]
public static void AddOrUpdate(IDictionary`2<TK, TV> to, TK at, Func`2<TO, TV> add, Action`2<TO, TV> update, TO context);
    [ExtensionAttribute]
public static IIndexed`2<TKey, TValue> ToIndexed(IEnumerable`1<T> enumerable, Func`2<T, TKey> keySelector, Func`2<T, TValue> valueSelector, TComparer comparer);
    [ExtensionAttribute]
public static TValue Optional(IReadOnlyIndexed`2<TKey, TValue> indexed, TKey& key);
    [ExtensionAttribute]
public static SequenceOfOneClass`1<T> SequenceOfOne(T value);
    [ExtensionAttribute]
public static TList AddMany(TList list, IEnumerable`1<T> items);
}
[IsReadOnlyAttribute]
internal class HandlebarsDotNet.EqualityComparers.IntegerEqualityComparer : ValueType {
    public sealed virtual bool Equals(int x, int y);
    public sealed virtual int GetHashCode(int obj);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.EqualityComparers.ReferenceEqualityComparer`1 : ValueType {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[IsReadOnlyAttribute]
internal class HandlebarsDotNet.EqualityComparers.StringEqualityComparer : ValueType {
    private StringComparison _stringComparison;
    public StringEqualityComparer(StringComparison stringComparison);
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
}
internal class HandlebarsDotNet.ExtendedStringReader : TextReader {
    private int _linePos;
    private int _charPos;
    private int _matched;
    private TextReader _inner;
    public ExtendedStringReader(TextReader reader);
    public virtual int Peek();
    public virtual int Read();
    private void AdvancePosition(char c);
    public IReaderContext GetContext();
}
[ExtensionAttribute]
public static class HandlebarsDotNet.Extensions.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder Trim(StringBuilder builder, char char);
    [ExtensionAttribute]
public static StringBuilder TrimStart(StringBuilder builder, char char);
    [ExtensionAttribute]
public static StringBuilder TrimEnd(StringBuilder builder, char char);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder builder, Substring& substring);
}
[FeatureOrderAttribute("-2147483648")]
internal class HandlebarsDotNet.Features.BuildInHelpersFeature : object {
    private static WithBlockHelperDescriptor WithBlockHelperDescriptor;
    private static LookupReturnHelperDescriptor LookupReturnHelperDescriptor;
    private static InlineBlockDecoratorDescriptor InlineBlockHelperDescriptor;
    private static BuildInHelpersFeature();
    public sealed virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public sealed virtual void CompilationCompleted();
}
internal class HandlebarsDotNet.Features.BuildInHelpersFeatureFactory : object {
    public sealed virtual IFeature CreateFeature();
}
[ExtensionAttribute]
public static class HandlebarsDotNet.Features.CollectionMemberAliasProviderExtensions : object {
    [ExtensionAttribute]
public static HandlebarsConfiguration UseCollectionMemberAliasProvider(HandlebarsConfiguration configuration);
}
internal class HandlebarsDotNet.Features.CollectionMemberAliasProviderFeature : object {
    private static CollectionMemberAliasProvider AliasProvider;
    private static CollectionMemberAliasProviderFeature();
    public sealed virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public sealed virtual void CompilationCompleted();
}
internal class HandlebarsDotNet.Features.CollectionMemberAliasProviderFeatureFactory : object {
    public sealed virtual IFeature CreateFeature();
}
[FeatureOrderAttribute("2")]
internal class HandlebarsDotNet.Features.DefaultCompilerFeature : object {
    public sealed virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public sealed virtual void CompilationCompleted();
}
internal class HandlebarsDotNet.Features.DefaultCompilerFeatureFactory : object {
    public sealed virtual IFeature CreateFeature();
}
internal class HandlebarsDotNet.Features.FeatureOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; }
    public FeatureOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
}
public interface HandlebarsDotNet.Features.IFeature {
    public abstract virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public abstract virtual void CompilationCompleted();
}
public interface HandlebarsDotNet.Features.IFeatureFactory {
    public abstract virtual IFeature CreateFeature();
}
[FeatureOrderAttribute("2147483647")]
internal class HandlebarsDotNet.Features.MissingHelperFeature : object {
    private static string HelperMissingKey;
    private static string BlockHelperMissingKey;
    private IHelperDescriptor`1<HelperOptions> _helper;
    private IHelperDescriptor`1<BlockHelperOptions> _blockHelper;
    public MissingHelperFeature(IHelperDescriptor`1<HelperOptions> helper, IHelperDescriptor`1<BlockHelperOptions> blockHelper);
    public sealed virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public sealed virtual void CompilationCompleted();
}
[ExtensionAttribute]
public static class HandlebarsDotNet.Features.MissingHelperFeatureExtension : object {
    [ExtensionAttribute]
public static HandlebarsConfiguration RegisterMissingHelperHook(HandlebarsConfiguration configuration, IHelperDescriptor`1<HelperOptions> helperMissing, IHelperDescriptor`1<BlockHelperOptions> blockHelperMissing);
    [ExtensionAttribute]
public static HandlebarsConfiguration RegisterMissingHelperHook(HandlebarsConfiguration configuration, HandlebarsReturnWithOptionsHelper helperMissing, HandlebarsBlockHelper blockHelperMissing);
}
internal class HandlebarsDotNet.Features.MissingHelperFeatureFactory : object {
    private IHelperDescriptor`1<HelperOptions> _returnHelper;
    private IHelperDescriptor`1<BlockHelperOptions> _blockHelper;
    public MissingHelperFeatureFactory(IHelperDescriptor`1<HelperOptions> returnHelper, IHelperDescriptor`1<BlockHelperOptions> blockHelper);
    public sealed virtual IFeature CreateFeature();
}
internal class HandlebarsDotNet.Features.WarmUpFeature : object {
    private HashSet`1<Type> _types;
    public WarmUpFeature(HashSet`1<Type> types);
    public sealed virtual void OnCompiling(ICompiledHandlebarsConfiguration configuration);
    public sealed virtual void CompilationCompleted();
}
[ExtensionAttribute]
public static class HandlebarsDotNet.Features.WarmUpFeatureExtensions : object {
    [ExtensionAttribute]
public static HandlebarsConfiguration UseWarmUp(HandlebarsConfiguration configuration, Action`1<ICollection`1<Type>> configure);
}
internal class HandlebarsDotNet.Features.WarmUpFeatureFactory : object {
    private HashSet`1<Type> _types;
    public WarmUpFeatureFactory(HashSet`1<Type> types);
    public sealed virtual IFeature CreateFeature();
}
public class HandlebarsDotNet.FileSystemPartialTemplateResolver : object {
    public sealed virtual bool TryRegisterPartial(IHandlebars env, string partialName, string templatePath);
}
public class HandlebarsDotNet.Handlebars : object {
    private static Lazy`1<IHandlebars> Lazy;
    private static IHandlebars Instance { get; }
    public static HandlebarsConfiguration Configuration { get; }
    private static Handlebars();
    private static IHandlebars get_Instance();
    public static IHandlebars Create(HandlebarsConfiguration configuration);
    public static IHandlebars CreateSharedEnvironment(HandlebarsConfiguration configuration);
    internal static IHandlebars Create(ICompiledHandlebarsConfiguration configuration);
    public static HandlebarsTemplate`3<TextWriter, object, object> Compile(TextReader template);
    public static HandlebarsTemplate`2<object, object> Compile(string template);
    public static HandlebarsTemplate`2<object, object> CompileView(string templatePath);
    public static HandlebarsTemplate`3<TextWriter, object, object> CompileView(string templatePath, ViewReaderFactory readerFactoryFactory);
    public static void RegisterTemplate(string templateName, HandlebarsTemplate`3<TextWriter, object, object> template);
    public static void RegisterTemplate(string templateName, string template);
    public static void RegisterHelper(string helperName, HandlebarsHelper helperFunction);
    public static void RegisterHelper(string helperName, HandlebarsHelperWithOptions helperFunction);
    public static void RegisterHelper(string helperName, HandlebarsReturnHelper helperFunction);
    public static void RegisterHelper(string helperName, HandlebarsReturnWithOptionsHelper helperFunction);
    public static void RegisterHelper(string helperName, HandlebarsBlockHelper helperFunction);
    public static void RegisterHelper(string helperName, HandlebarsReturnBlockHelper helperFunction);
    public static void RegisterHelper(IHelperDescriptor`1<HelperOptions> helperObject);
    public static void RegisterHelper(IHelperDescriptor`1<BlockHelperOptions> helperObject);
    public void RegisterDecorator(string helperName, HandlebarsBlockDecorator helperFunction);
    public void RegisterDecorator(string helperName, HandlebarsDecorator helperFunction);
    public void RegisterDecorator(string helperName, HandlebarsBlockDecoratorVoid helperFunction);
    public void RegisterDecorator(string helperName, HandlebarsDecoratorVoid helperFunction);
    public static HandlebarsConfiguration get_Configuration();
}
public class HandlebarsDotNet.HandlebarsBlockDecorator : MulticastDelegate {
    public HandlebarsBlockDecorator(object object, IntPtr method);
    public virtual TemplateDelegate Invoke(TemplateDelegate function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(TemplateDelegate function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual TemplateDelegate EndInvoke(BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsBlockDecoratorVoid : MulticastDelegate {
    public HandlebarsBlockDecoratorVoid(object object, IntPtr method);
    public virtual void Invoke(TemplateDelegate function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(TemplateDelegate function, BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(BlockDecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsBlockHelper : MulticastDelegate {
    public HandlebarsBlockHelper(object object, IntPtr method);
    public virtual void Invoke(EncodedTextWriter output, BlockHelperOptions options, Context context, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(EncodedTextWriter output, BlockHelperOptions options, Context context, Arguments arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsCompilerException : HandlebarsException {
    public HandlebarsCompilerException(string message);
    internal HandlebarsCompilerException(string message, IReaderContext context);
    public HandlebarsCompilerException(string message, Exception innerException);
    internal HandlebarsCompilerException(string message, Exception innerException, IReaderContext context);
}
public class HandlebarsDotNet.HandlebarsConfiguration : object {
    private UndefinedFormatter _undefinedFormatter;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> <Helpers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> <BlockHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, IDecoratorDescriptor`1<DecoratorOptions>> <Decorators>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, IDecoratorDescriptor`1<BlockDecoratorOptions>> <BlockDecorators>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> <RegisteredTemplates>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppendOnlyList`1<IHelperResolver> <HelperResolvers>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionNameResolver <ExpressionNameResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextEncoder <TextEncoder>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewEngineFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnUnresolvedBindingExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoEscape>k__BackingField;
    [CompilerGeneratedAttribute]
private IPartialTemplateResolver <PartialTemplateResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IMissingPartialTemplateHandler <MissingPartialTemplateHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private short <PartialRecursionDepthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppendOnlyList`1<IMemberAliasProvider> <AliasProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Compatibility <Compatibility>k__BackingField;
    [CompilerGeneratedAttribute]
private CompileTimeConfiguration <CompileTimeConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableList`1<IFormatterProvider> <FormatterProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableList`1<IObjectDescriptorProvider> <ObjectDescriptorProviders>k__BackingField;
    public IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> Helpers { get; }
    public IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> BlockHelpers { get; }
    public IIndexed`2<string, IDecoratorDescriptor`1<DecoratorOptions>> Decorators { get; }
    public IIndexed`2<string, IDecoratorDescriptor`1<BlockDecoratorOptions>> BlockDecorators { get; }
    public IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> RegisteredTemplates { get; }
    public IAppendOnlyList`1<IHelperResolver> HelperResolvers { get; }
    public IExpressionNameResolver ExpressionNameResolver { get; public set; }
    public ITextEncoder TextEncoder { get; public set; }
    public IFormatProvider FormatProvider { get; public set; }
    public ViewEngineFileSystem FileSystem { get; public set; }
    [ObsoleteAttribute("Register custom formatters using `Formatters` property")]
public string UnresolvedBindingFormatter { get; public set; }
    public bool ThrowOnUnresolvedBindingExpression { get; public set; }
    public bool NoEscape { get; public set; }
    public IPartialTemplateResolver PartialTemplateResolver { get; public set; }
    public IMissingPartialTemplateHandler MissingPartialTemplateHandler { get; public set; }
    public short PartialRecursionDepthLimit { get; public set; }
    public IAppendOnlyList`1<IMemberAliasProvider> AliasProviders { get; }
    public Compatibility Compatibility { get; }
    public CompileTimeConfiguration CompileTimeConfiguration { get; }
    public ObservableList`1<IFormatterProvider> FormatterProviders { get; }
    public ObservableList`1<IObjectDescriptorProvider> ObjectDescriptorProviders { get; }
    [CompilerGeneratedAttribute]
public IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> get_Helpers();
    [CompilerGeneratedAttribute]
public IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> get_BlockHelpers();
    [CompilerGeneratedAttribute]
public IIndexed`2<string, IDecoratorDescriptor`1<DecoratorOptions>> get_Decorators();
    [CompilerGeneratedAttribute]
public IIndexed`2<string, IDecoratorDescriptor`1<BlockDecoratorOptions>> get_BlockDecorators();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> get_RegisteredTemplates();
    [CompilerGeneratedAttribute]
public IAppendOnlyList`1<IHelperResolver> get_HelperResolvers();
    [CompilerGeneratedAttribute]
public IExpressionNameResolver get_ExpressionNameResolver();
    [CompilerGeneratedAttribute]
public void set_ExpressionNameResolver(IExpressionNameResolver value);
    [CompilerGeneratedAttribute]
public ITextEncoder get_TextEncoder();
    [CompilerGeneratedAttribute]
public void set_TextEncoder(ITextEncoder value);
    [CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
public void set_FormatProvider(IFormatProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual ViewEngineFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public void set_FileSystem(ViewEngineFileSystem value);
    public string get_UnresolvedBindingFormatter();
    public void set_UnresolvedBindingFormatter(string value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnUnresolvedBindingExpression();
    [CompilerGeneratedAttribute]
public void set_ThrowOnUnresolvedBindingExpression(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoEscape();
    [CompilerGeneratedAttribute]
public void set_NoEscape(bool value);
    [CompilerGeneratedAttribute]
public IPartialTemplateResolver get_PartialTemplateResolver();
    [CompilerGeneratedAttribute]
public void set_PartialTemplateResolver(IPartialTemplateResolver value);
    [CompilerGeneratedAttribute]
public IMissingPartialTemplateHandler get_MissingPartialTemplateHandler();
    [CompilerGeneratedAttribute]
public void set_MissingPartialTemplateHandler(IMissingPartialTemplateHandler value);
    [CompilerGeneratedAttribute]
public short get_PartialRecursionDepthLimit();
    [CompilerGeneratedAttribute]
public void set_PartialRecursionDepthLimit(short value);
    [CompilerGeneratedAttribute]
public IAppendOnlyList`1<IMemberAliasProvider> get_AliasProviders();
    [CompilerGeneratedAttribute]
public Compatibility get_Compatibility();
    [CompilerGeneratedAttribute]
public CompileTimeConfiguration get_CompileTimeConfiguration();
    [CompilerGeneratedAttribute]
public ObservableList`1<IFormatterProvider> get_FormatterProviders();
    [CompilerGeneratedAttribute]
public ObservableList`1<IObjectDescriptorProvider> get_ObjectDescriptorProviders();
}
internal class HandlebarsDotNet.HandlebarsConfigurationAdapter : object {
    private List`1<object> _observers;
    [CompilerGeneratedAttribute]
private HandlebarsConfiguration <UnderlingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableList`1<IFormatterProvider> <FormatterProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableList`1<IObjectDescriptorProvider> <ObjectDescriptorProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppendOnlyList`1<IExpressionMiddleware> <ExpressionMiddlewares>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppendOnlyList`1<IMemberAliasProvider> <AliasProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionCompiler <ExpressionCompiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IFeature> <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<HelperOptions>>> <Helpers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>> <BlockHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>> <Decorators>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>> <BlockDecorators>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppendOnlyList`1<IHelperResolver> <HelperResolvers>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> <RegisteredTemplates>k__BackingField;
    public HandlebarsConfiguration UnderlingConfiguration { get; }
    public IExpressionNameResolver ExpressionNameResolver { get; }
    public ITextEncoder TextEncoder { get; }
    public IFormatProvider FormatProvider { get; }
    public ViewEngineFileSystem FileSystem { get; }
    public ObservableList`1<IFormatterProvider> FormatterProviders { get; }
    public bool ThrowOnUnresolvedBindingExpression { get; }
    public IPartialTemplateResolver PartialTemplateResolver { get; }
    public IMissingPartialTemplateHandler MissingPartialTemplateHandler { get; }
    public short PartialRecursionDepthLimit { get; }
    public Compatibility Compatibility { get; }
    public bool NoEscape { get; }
    public ObservableList`1<IObjectDescriptorProvider> ObjectDescriptorProviders { get; }
    public IAppendOnlyList`1<IExpressionMiddleware> ExpressionMiddlewares { get; }
    public IAppendOnlyList`1<IMemberAliasProvider> AliasProviders { get; }
    public IExpressionCompiler ExpressionCompiler { get; public set; }
    public IReadOnlyList`1<IFeature> Features { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<HelperOptions>>> Helpers { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>> BlockHelpers { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>> Decorators { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>> BlockDecorators { get; }
    public IAppendOnlyList`1<IHelperResolver> HelperResolvers { get; }
    public IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> RegisteredTemplates { get; }
    public HandlebarsConfigurationAdapter(HandlebarsConfiguration configuration);
    [CompilerGeneratedAttribute]
public sealed virtual HandlebarsConfiguration get_UnderlingConfiguration();
    public sealed virtual IExpressionNameResolver get_ExpressionNameResolver();
    public sealed virtual ITextEncoder get_TextEncoder();
    public sealed virtual IFormatProvider get_FormatProvider();
    public sealed virtual ViewEngineFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public sealed virtual ObservableList`1<IFormatterProvider> get_FormatterProviders();
    public sealed virtual bool get_ThrowOnUnresolvedBindingExpression();
    public sealed virtual IPartialTemplateResolver get_PartialTemplateResolver();
    public sealed virtual IMissingPartialTemplateHandler get_MissingPartialTemplateHandler();
    public sealed virtual short get_PartialRecursionDepthLimit();
    public sealed virtual Compatibility get_Compatibility();
    public sealed virtual bool get_NoEscape();
    [CompilerGeneratedAttribute]
public sealed virtual ObservableList`1<IObjectDescriptorProvider> get_ObjectDescriptorProviders();
    [CompilerGeneratedAttribute]
public sealed virtual IAppendOnlyList`1<IExpressionMiddleware> get_ExpressionMiddlewares();
    [CompilerGeneratedAttribute]
public sealed virtual IAppendOnlyList`1<IMemberAliasProvider> get_AliasProviders();
    [CompilerGeneratedAttribute]
public sealed virtual IExpressionCompiler get_ExpressionCompiler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpressionCompiler(IExpressionCompiler value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IFeature> get_Features();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<HelperOptions>>> get_Helpers();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>> get_BlockHelpers();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>> get_Decorators();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>> get_BlockDecorators();
    [CompilerGeneratedAttribute]
public sealed virtual IAppendOnlyList`1<IHelperResolver> get_HelperResolvers();
    [CompilerGeneratedAttribute]
public sealed virtual IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> get_RegisteredTemplates();
    private ObservableIndex`3<PathInfoLight, Ref`1<TDescriptor>, PathInfoLightEqualityComparer> CreateHelpersSubscription(IIndexed`2<string, TDescriptor> source);
    private ObservableList`1<IObjectDescriptorProvider> CreateObjectDescriptorProvider(ObservableList`1<IObjectDescriptorProvider> descriptorProviders);
}
public class HandlebarsDotNet.HandlebarsDecorator : MulticastDelegate {
    public HandlebarsDecorator(object object, IntPtr method);
    public virtual TemplateDelegate Invoke(TemplateDelegate function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(TemplateDelegate function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual TemplateDelegate EndInvoke(DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsDecoratorVoid : MulticastDelegate {
    public HandlebarsDecoratorVoid(object object, IntPtr method);
    public virtual void Invoke(TemplateDelegate function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(TemplateDelegate function, DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(DecoratorOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
internal class HandlebarsDotNet.HandlebarsEnvironment : object {
    private static ViewReaderFactory ViewReaderFactory;
    private AmbientContext _ambientContext;
    [CompilerGeneratedAttribute]
private bool <IsSharedEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private HandlebarsConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompiledHandlebarsConfiguration <CompiledConfiguration>k__BackingField;
    public bool IsSharedEnvironment { get; }
    public HandlebarsConfiguration Configuration { get; }
    internal ICompiledHandlebarsConfiguration CompiledConfiguration { get; }
    private ICompiledHandlebarsConfiguration HandlebarsDotNet.ICompiledHandlebars.CompiledConfiguration { get; }
    public HandlebarsEnvironment(HandlebarsConfiguration configuration);
    internal HandlebarsEnvironment(ICompiledHandlebarsConfiguration configuration);
    private static HandlebarsEnvironment();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSharedEnvironment();
    [CompilerGeneratedAttribute]
public sealed virtual HandlebarsConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
internal ICompiledHandlebarsConfiguration get_CompiledConfiguration();
    private sealed virtual override ICompiledHandlebarsConfiguration HandlebarsDotNet.ICompiledHandlebars.get_CompiledConfiguration();
    public sealed virtual HandlebarsTemplate`3<TextWriter, object, object> CompileView(string templatePath, ViewReaderFactory readerFactoryFactory);
    public sealed virtual HandlebarsTemplate`2<object, object> CompileView(string templatePath);
    private HandlebarsTemplate`3<TextWriter, object, object> CompileViewInternal(string templatePath, ViewReaderFactory readerFactoryFactory);
    public sealed virtual IHandlebars CreateSharedEnvironment();
    public sealed virtual HandlebarsTemplate`3<TextWriter, object, object> Compile(TextReader template);
    public sealed virtual HandlebarsTemplate`2<object, object> Compile(string template);
    public sealed virtual void RegisterTemplate(string templateName, HandlebarsTemplate`3<TextWriter, object, object> template);
    public sealed virtual void RegisterTemplate(string templateName, string template);
    public sealed virtual void RegisterDecorator(string helperName, HandlebarsBlockDecorator helperFunction);
    public sealed virtual void RegisterDecorator(string helperName, HandlebarsDecorator helperFunction);
    public sealed virtual void RegisterDecorator(string helperName, HandlebarsBlockDecoratorVoid helperFunction);
    public sealed virtual void RegisterDecorator(string helperName, HandlebarsDecoratorVoid helperFunction);
    public sealed virtual DisposableContainer Configure();
    public sealed virtual IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> GetHelpers();
    public sealed virtual IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> GetBlockHelpers();
}
public class HandlebarsDotNet.HandlebarsException : Exception {
    public HandlebarsException(string message);
    internal HandlebarsException(string message, IReaderContext context);
    public HandlebarsException(string message, Exception innerException);
    internal HandlebarsException(string message, Exception innerException, IReaderContext context);
    private static string FormatMessage(string message, IReaderContext context);
}
[ExtensionAttribute]
public static class HandlebarsDotNet.HandlebarsExtensions : object {
    [ExtensionAttribute]
public static void WriteSafeString(EncodedTextWriter& writer, string value);
    [ExtensionAttribute]
public static void WriteSafeString(EncodedTextWriter& writer, object value);
    [ExtensionAttribute]
public static HandlebarsConfiguration Configure(HandlebarsConfiguration configuration, Action`1<HandlebarsConfiguration> config);
}
public class HandlebarsDotNet.HandlebarsHelper : MulticastDelegate {
    public HandlebarsHelper(object object, IntPtr method);
    public virtual void Invoke(EncodedTextWriter output, Context context, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(EncodedTextWriter output, Context context, Arguments arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsHelperWithOptions : MulticastDelegate {
    public HandlebarsHelperWithOptions(object object, IntPtr method);
    public virtual void Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsParserException : HandlebarsException {
    public HandlebarsParserException(string message);
    internal HandlebarsParserException(string message, IReaderContext context);
    public HandlebarsParserException(string message, Exception innerException);
    internal HandlebarsParserException(string message, Exception innerException, IReaderContext context);
}
public class HandlebarsDotNet.HandlebarsReturnBlockHelper : MulticastDelegate {
    public HandlebarsReturnBlockHelper(object object, IntPtr method);
    public virtual object Invoke(BlockHelperOptions options, Context context, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(BlockHelperOptions options, Context context, Arguments arguments, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsReturnHelper : MulticastDelegate {
    public HandlebarsReturnHelper(object object, IntPtr method);
    public virtual object Invoke(Context context, Arguments arguments);
    public virtual IAsyncResult BeginInvoke(Context context, Arguments arguments, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsReturnWithOptionsHelper : MulticastDelegate {
    public HandlebarsReturnWithOptionsHelper(object object, IntPtr method);
    public virtual object Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public virtual IAsyncResult BeginInvoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, AsyncCallback callback, object object);
    public virtual object EndInvoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments, IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsRuntimeException : HandlebarsException {
    public HandlebarsRuntimeException(string message);
    internal HandlebarsRuntimeException(string message, IReaderContext context);
    public HandlebarsRuntimeException(string message, Exception innerException);
    internal HandlebarsRuntimeException(string message, Exception innerException, IReaderContext context);
}
public class HandlebarsDotNet.HandlebarsTemplate`2 : MulticastDelegate {
    public HandlebarsTemplate`2(object object, IntPtr method);
    public virtual string Invoke(TContext context, TData data);
    public virtual IAsyncResult BeginInvoke(TContext context, TData data, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class HandlebarsDotNet.HandlebarsTemplate`3 : MulticastDelegate {
    public HandlebarsTemplate`3(object object, IntPtr method);
    public virtual void Invoke(TWriter writer, TContext context, TData data);
    public virtual IAsyncResult BeginInvoke(TWriter writer, TContext context, TData data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class HandlebarsDotNet.HandlebarsUtils : object {
    public static bool IsTruthy(object value);
    public static bool IsFalsy(object value);
    public static bool IsTruthyOrNonEmpty(object value);
    public static bool IsFalsyOrEmpty(object value);
    private static bool IsNumber(object value);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.HelperOptions : ValueType {
    [CompilerGeneratedAttribute]
private BindingContext <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public BindingContext Frame { get; }
    public DataValues Data { get; }
    public PathInfo Name { get; }
    public HelperOptions(PathInfo name, BindingContext frame);
    [CompilerGeneratedAttribute]
public sealed virtual BindingContext get_Frame();
    public sealed virtual DataValues get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
}
[ExtensionAttribute]
public static class HandlebarsDotNet.HelperOptionsExtensions : object {
    [ExtensionAttribute]
public static bool TryAccessMember(T helperOptions, object instance, ChainSegment chainSegment, Object& value);
    [ExtensionAttribute]
public static object ResolvePath(T helperOptions, PathInfo pathInfo);
}
public class HandlebarsDotNet.Helpers.BlockHelpers.DelegateBlockHelperDescriptor : object {
    private HandlebarsBlockHelper _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateBlockHelperDescriptor(string name, HandlebarsBlockHelper helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(BlockHelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, BlockHelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.BlockHelpers.DelegateReturnBlockHelperDescriptor : object {
    private HandlebarsReturnBlockHelper _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateReturnBlockHelperDescriptor(string name, HandlebarsReturnBlockHelper helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(BlockHelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, BlockHelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.BlockHelpers.LateBindBlockHelperDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public LateBindBlockHelperDescriptor(string name);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(BlockHelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, BlockHelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.BlockHelpers.MissingBlockHelperDescriptor : object {
    private static ChainSegment[] BlockParamsVariables;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    private static MissingBlockHelperDescriptor();
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(BlockHelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, BlockHelperOptions& options, Context& context, Arguments& arguments);
    private static void RenderSection(object value, BindingContext context, EncodedTextWriter writer, TemplateDelegate body, TemplateDelegate inversion);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.BlockHelpers.WithBlockHelperDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(BlockHelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, BlockHelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.BlockHelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, BlockHelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.DelegateHelperDescriptor : object {
    private HandlebarsHelper _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateHelperDescriptor(string name, HandlebarsHelper helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.DelegateHelperWithOptionsDescriptor : object {
    private HandlebarsHelperWithOptions _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateHelperWithOptionsDescriptor(string name, HandlebarsHelperWithOptions helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.DelegateReturnHelperDescriptor : object {
    private HandlebarsReturnHelper _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateReturnHelperDescriptor(string name, HandlebarsReturnHelper helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.DelegateReturnHelperWithOptionsDescriptor : object {
    private HandlebarsReturnWithOptionsHelper _helper;
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public DelegateReturnHelperWithOptionsDescriptor(string name, HandlebarsReturnWithOptionsHelper helper);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
[ExtensionAttribute]
public static class HandlebarsDotNet.Helpers.HelperExtensions : object {
    [ExtensionAttribute]
public static object ReturnInvoke(THelperDescriptor descriptor, TOptions& options, Context& context, Arguments& arguments);
}
public interface HandlebarsDotNet.Helpers.IHelperDescriptor {
    public PathInfo Name { get; }
    public abstract virtual PathInfo get_Name();
}
public interface HandlebarsDotNet.Helpers.IHelperDescriptor`1 {
    public abstract virtual object Invoke(TOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    public abstract virtual void Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, TOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public interface HandlebarsDotNet.Helpers.IHelperResolver {
    public abstract virtual bool TryResolveHelper(PathInfo name, Type targetType, IHelperDescriptor`1& helper);
    public abstract virtual bool TryResolveBlockHelper(PathInfo name, IHelperDescriptor`1& helper);
}
public class HandlebarsDotNet.Helpers.LateBindHelperDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    public LateBindHelperDescriptor(string name);
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.LookupReturnHelperDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
public class HandlebarsDotNet.Helpers.MissingHelperDescriptor : object {
    [CompilerGeneratedAttribute]
private PathInfo <Name>k__BackingField;
    public PathInfo Name { get; }
    [CompilerGeneratedAttribute]
public sealed virtual PathInfo get_Name();
    public object Invoke(HelperOptions& options, Context& context, Arguments& arguments);
    public void Invoke(EncodedTextWriter& output, HelperOptions& options, Context& context, Arguments& arguments);
    private sealed virtual override object HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
    private sealed virtual override void HandlebarsDotNet.Helpers.IHelperDescriptor<HandlebarsDotNet.HelperOptions>.Invoke(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) output, HelperOptions& modreq(System.Runtime.InteropServices.InAttribute) options, Context& modreq(System.Runtime.InteropServices.InAttribute) context, Arguments& modreq(System.Runtime.InteropServices.InAttribute) arguments);
}
[ExtensionAttribute]
public static class HandlebarsDotNet.HelpersRegistryExtensions : object {
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsHelper helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsHelperWithOptions helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsReturnHelper helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsReturnWithOptionsHelper helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, IHelperDescriptor`1<HelperOptions> helperObject);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsBlockHelper helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, string helperName, HandlebarsReturnBlockHelper helperFunction);
    [ExtensionAttribute]
public static void RegisterHelper(TRegistry registry, IHelperDescriptor`1<BlockHelperOptions> helperObject);
}
public class HandlebarsDotNet.HtmlEncoder : object {
    public sealed virtual void Encode(StringBuilder text, TextWriter target);
    public sealed virtual void Encode(string text, TextWriter target);
    public sealed virtual void Encode(T text, TextWriter target);
    private static void EncodeImpl(T text, TextWriter target);
}
public class HandlebarsDotNet.HtmlEncoderLegacy : object {
    public sealed virtual void Encode(StringBuilder text, TextWriter target);
    public sealed virtual void Encode(string text, TextWriter target);
    public sealed virtual void Encode(T text, TextWriter target);
    private static void EncodeImpl(T text, TextWriter target);
}
internal interface HandlebarsDotNet.ICompiledHandlebars {
    public ICompiledHandlebarsConfiguration CompiledConfiguration { get; }
    public abstract virtual ICompiledHandlebarsConfiguration get_CompiledConfiguration();
}
public interface HandlebarsDotNet.ICompiledHandlebarsConfiguration {
    public HandlebarsConfiguration UnderlingConfiguration { get; }
    public IExpressionNameResolver ExpressionNameResolver { get; }
    public ITextEncoder TextEncoder { get; }
    public IFormatProvider FormatProvider { get; }
    public ObservableList`1<IFormatterProvider> FormatterProviders { get; }
    public bool ThrowOnUnresolvedBindingExpression { get; }
    public IPartialTemplateResolver PartialTemplateResolver { get; }
    public IMissingPartialTemplateHandler MissingPartialTemplateHandler { get; }
    public short PartialRecursionDepthLimit { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<HelperOptions>>> Helpers { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>> BlockHelpers { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>> Decorators { get; }
    public IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>> BlockDecorators { get; }
    public IAppendOnlyList`1<IHelperResolver> HelperResolvers { get; }
    public Compatibility Compatibility { get; }
    public ObservableList`1<IObjectDescriptorProvider> ObjectDescriptorProviders { get; }
    public IAppendOnlyList`1<IExpressionMiddleware> ExpressionMiddlewares { get; }
    public IAppendOnlyList`1<IMemberAliasProvider> AliasProviders { get; }
    public IExpressionCompiler ExpressionCompiler { get; public set; }
    public IReadOnlyList`1<IFeature> Features { get; }
    public bool NoEscape { get; }
    public abstract virtual HandlebarsConfiguration get_UnderlingConfiguration();
    public abstract virtual IExpressionNameResolver get_ExpressionNameResolver();
    public abstract virtual ITextEncoder get_TextEncoder();
    public abstract virtual IFormatProvider get_FormatProvider();
    public abstract virtual ObservableList`1<IFormatterProvider> get_FormatterProviders();
    public abstract virtual bool get_ThrowOnUnresolvedBindingExpression();
    public abstract virtual IPartialTemplateResolver get_PartialTemplateResolver();
    public abstract virtual IMissingPartialTemplateHandler get_MissingPartialTemplateHandler();
    public abstract virtual short get_PartialRecursionDepthLimit();
    public abstract virtual IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<HelperOptions>>> get_Helpers();
    public abstract virtual IIndexed`2<PathInfoLight, Ref`1<IHelperDescriptor`1<BlockHelperOptions>>> get_BlockHelpers();
    public abstract virtual IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<DecoratorOptions>>> get_Decorators();
    public abstract virtual IIndexed`2<PathInfoLight, Ref`1<IDecoratorDescriptor`1<BlockDecoratorOptions>>> get_BlockDecorators();
    public abstract virtual IAppendOnlyList`1<IHelperResolver> get_HelperResolvers();
    public abstract virtual Compatibility get_Compatibility();
    public abstract virtual ObservableList`1<IObjectDescriptorProvider> get_ObjectDescriptorProviders();
    public abstract virtual IAppendOnlyList`1<IExpressionMiddleware> get_ExpressionMiddlewares();
    public abstract virtual IAppendOnlyList`1<IMemberAliasProvider> get_AliasProviders();
    public abstract virtual IExpressionCompiler get_ExpressionCompiler();
    public abstract virtual void set_ExpressionCompiler(IExpressionCompiler value);
    public abstract virtual IReadOnlyList`1<IFeature> get_Features();
    public abstract virtual bool get_NoEscape();
}
public interface HandlebarsDotNet.IDescriptor`1 {
}
public interface HandlebarsDotNet.IExpressionCompiler {
    public abstract virtual T Compile(Expression`1<T> expression);
}
public interface HandlebarsDotNet.IExpressionMiddleware {
    public abstract virtual Expression`1<T> Invoke(Expression`1<T> expression);
}
public interface HandlebarsDotNet.IHandlebars {
    public bool IsSharedEnvironment { get; }
    public HandlebarsConfiguration Configuration { get; }
    public abstract virtual IHandlebars CreateSharedEnvironment();
    public abstract virtual bool get_IsSharedEnvironment();
    public abstract virtual HandlebarsTemplate`3<TextWriter, object, object> Compile(TextReader template);
    public abstract virtual HandlebarsTemplate`2<object, object> Compile(string template);
    public abstract virtual HandlebarsTemplate`2<object, object> CompileView(string templatePath);
    public abstract virtual HandlebarsTemplate`3<TextWriter, object, object> CompileView(string templatePath, ViewReaderFactory readerFactoryFactory);
    public abstract virtual HandlebarsConfiguration get_Configuration();
    public abstract virtual void RegisterTemplate(string templateName, HandlebarsTemplate`3<TextWriter, object, object> template);
    public abstract virtual void RegisterTemplate(string templateName, string template);
    public abstract virtual void RegisterDecorator(string helperName, HandlebarsBlockDecorator helperFunction);
    public abstract virtual void RegisterDecorator(string helperName, HandlebarsDecorator helperFunction);
    public abstract virtual void RegisterDecorator(string helperName, HandlebarsBlockDecoratorVoid helperFunction);
    public abstract virtual void RegisterDecorator(string helperName, HandlebarsDecoratorVoid helperFunction);
    public abstract virtual DisposableContainer Configure();
}
public interface HandlebarsDotNet.IHandlebarsTemplateRegistrations {
    public IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> RegisteredTemplates { get; }
    public ViewEngineFileSystem FileSystem { get; }
    public abstract virtual IIndexed`2<string, HandlebarsTemplate`3<TextWriter, object, object>> get_RegisteredTemplates();
    public abstract virtual ViewEngineFileSystem get_FileSystem();
}
public interface HandlebarsDotNet.IHelperOptions {
    public DataValues Data { get; }
    public PathInfo Name { get; }
    public abstract virtual DataValues get_Data();
    public abstract virtual PathInfo get_Name();
}
public interface HandlebarsDotNet.IHelpersRegistry {
    public abstract virtual IIndexed`2<string, IHelperDescriptor`1<HelperOptions>> GetHelpers();
    public abstract virtual IIndexed`2<string, IHelperDescriptor`1<BlockHelperOptions>> GetBlockHelpers();
}
public interface HandlebarsDotNet.IMemberAliasProvider {
}
public interface HandlebarsDotNet.IMemberAliasProvider`1 {
    public abstract virtual bool TryGetMemberByAlias(T instance, Type targetType, ChainSegment memberAlias, Object& value);
}
public interface HandlebarsDotNet.IMissingPartialTemplateHandler {
    public abstract virtual void Handle(ICompiledHandlebarsConfiguration configuration, string partialName, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) textWriter);
}
public class HandlebarsDotNet.IO.CollectionFormatterProvider : object {
    private static Type CollectionFormatterType;
    private static Type CollectionType;
    private static CollectionFormatterProvider();
    public sealed virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
}
public class HandlebarsDotNet.IO.DefaultFormatterProvider : object {
    private static DictionarySlim`3<Type, IFormatter, ReferenceEqualityComparer`1<Type>> Formatters;
    private static DefaultObjectFormatter DefaultObjectFormatter;
    private static DefaultFormatterProvider();
    public sealed virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
}
public class HandlebarsDotNet.IO.FormatterProvider : object {
    private static Func`3<Type, ObservableList`1<IFormatterProvider>, DeferredValue`2<KeyValuePair`2<Type, ObservableList`1<IFormatterProvider>>, IFormatter>> ValueFactory;
    private static Func`2<KeyValuePair`2<Type, ObservableList`1<IFormatterProvider>>, IFormatter> DeferredValueFactory;
    private LookupSlim`3<Type, DeferredValue`2<KeyValuePair`2<Type, ObservableList`1<IFormatterProvider>>, IFormatter>, ReferenceEqualityComparer`1<Type>> _formatters;
    private ObservableList`1<IFormatterProvider> _formatterProviders;
    private List`1<object> _observers;
    public static FormatterProvider Current { get; }
    public FormatterProvider(ObservableList`1<IFormatterProvider> providers);
    private static FormatterProvider();
    public static FormatterProvider get_Current();
    public FormatterProvider Append(ObservableList`1<IFormatterProvider> providers);
    public FormatterProvider Append(FormatterProvider provider);
    public sealed virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultBoolFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultCharFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultDateTimeFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultDecimalFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultDoubleFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultFloatFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultIntFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultLongFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultObjectFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultShortFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultUIntFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultULongFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public class HandlebarsDotNet.IO.Formatters.DefaultFormatters.DefaultUShortFormatter : object {
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public interface HandlebarsDotNet.IO.IFormatter {
    public abstract virtual void Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public interface HandlebarsDotNet.IO.IFormatterProvider {
    public abstract virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
}
public class HandlebarsDotNet.IO.ReadOnlyCollectionFormatterProvider : object {
    private static Type CollectionFormatterType;
    private static Type CollectionType;
    private static ReadOnlyCollectionFormatterProvider();
    public sealed virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
}
public class HandlebarsDotNet.IO.UndefinedFormatter : object {
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    public string FormatString { get; public set; }
    public UndefinedFormatter(string formatString);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
public void set_FormatString(string value);
    public sealed virtual bool TryCreateFormatter(Type type, IFormatter& formatter);
    public void Format(T value, EncodedTextWriter& writer);
    private sealed virtual override void HandlebarsDotNet.IO.IFormatter.Format(T value, EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer);
}
public interface HandlebarsDotNet.IOptions {
    public BindingContext Frame { get; }
    public abstract virtual BindingContext get_Frame();
}
public interface HandlebarsDotNet.IPartialTemplateResolver {
    public abstract virtual bool TryRegisterPartial(IHandlebars env, string partialName, string templatePath);
}
internal interface HandlebarsDotNet.IReaderContext {
    public int LineNumber { get; public set; }
    public int CharNumber { get; public set; }
    public abstract virtual int get_LineNumber();
    public abstract virtual void set_LineNumber(int value);
    public abstract virtual int get_CharNumber();
    public abstract virtual void set_CharNumber(int value);
}
public class HandlebarsDotNet.Iterators.ArrayIterator`1 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.CollectionIterator`1 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.CollectionIterator`2 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.DictionaryIterator`1 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.DictionaryIterator`3 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.DynamicObjectIterator : object {
    private ObjectDescriptor _descriptor;
    public DynamicObjectIterator(ObjectDescriptor descriptor);
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.EnumerableIterator`1 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.EnumerableIterator`2 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public interface HandlebarsDotNet.Iterators.IIterator {
    public abstract virtual void Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ListIterator`1 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ListIterator`2 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ObjectIterator : object {
    private ObjectDescriptor _descriptor;
    public ObjectIterator(ObjectDescriptor descriptor);
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ReadOnlyCollectionIterator`2 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ReadOnlyDictionaryIterator`3 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public class HandlebarsDotNet.Iterators.ReadOnlyListIterator`2 : object {
    public void Iterate(EncodedTextWriter& writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
    private sealed virtual override void HandlebarsDotNet.Iterators.IIterator.Iterate(EncodedTextWriter& modreq(System.Runtime.InteropServices.InAttribute) writer, BindingContext context, ChainSegment[] blockParamsVariables, object input, TemplateDelegate template, TemplateDelegate ifEmpty);
}
public interface HandlebarsDotNet.ITextEncoder {
    public abstract virtual void Encode(StringBuilder text, TextWriter target);
    public abstract virtual void Encode(string text, TextWriter target);
    public abstract virtual void Encode(T text, TextWriter target);
}
internal class HandlebarsDotNet.LayoutViewModel : object {
    private static ChainSegment BodyChainSegment;
    private string _body;
    private object _value;
    private ObjectDescriptor _valueDescriptor;
    public LayoutViewModel(string body, object value);
    private static LayoutViewModel();
}
public class HandlebarsDotNet.MemberAccessors.DictionaryAccessors.GenericDictionaryAccessor`3 : object {
    private static TypeConverter TypeConverter;
    private static GenericDictionaryAccessor`3();
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.DictionaryAccessors.ReadOnlyGenericDictionaryAccessor`3 : object {
    private static TypeConverter TypeConverter;
    private static ReadOnlyGenericDictionaryAccessor`3();
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.DictionaryAccessors.ReadOnlyStringDictionaryAccessor`2 : object {
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.DictionaryAccessors.StringDictionaryAccessor`2 : object {
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.DictionaryMemberAccessor : object {
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.DynamicMemberAccessor : object {
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
    private static object GetProperty(object target, string name);
}
public class HandlebarsDotNet.MemberAccessors.EnumerableAccessors.EnumerableMemberAccessor : object {
    public static EnumerableMemberAccessor Create(Type type);
    public virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
    protected virtual bool TryGetValueInternal(object instance, int index, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.EnumerableAccessors.EnumerableMemberAccessor`2 : EnumerableMemberAccessor {
    protected virtual bool TryGetValueInternal(object instance, int index, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.EnumerableAccessors.ListMemberAccessor`2 : EnumerableMemberAccessor {
    protected virtual bool TryGetValueInternal(object instance, int index, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.EnumerableAccessors.ReadOnlyListMemberAccessor`2 : EnumerableMemberAccessor {
    protected virtual bool TryGetValueInternal(object instance, int index, Object& value);
}
public interface HandlebarsDotNet.MemberAccessors.IMemberAccessor {
    public abstract virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.MergedMemberAccessor : object {
    private IMemberAccessor[] _accessors;
    public MergedMemberAccessor(IMemberAccessor[] accessors);
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
}
public class HandlebarsDotNet.MemberAccessors.ReflectionMemberAccessor : object {
    private static Func`2<Type, DeferredValue`2<Type, RawObjectTypeDescriptor>> DescriptorsValueFactory;
    private LookupSlim`3<Type, DeferredValue`2<Type, RawObjectTypeDescriptor>, ReferenceEqualityComparer`1<Type>> _descriptors;
    private IReadOnlyList`1<IMemberAliasProvider> _aliasProviders;
    public ReflectionMemberAccessor(IReadOnlyList`1<IMemberAliasProvider> aliasProviders);
    private static ReflectionMemberAccessor();
    public sealed virtual bool TryGetValue(object instance, ChainSegment memberName, Object& value);
    private bool TryGetValueImpl(object instance, Type instanceType, ChainSegment memberName, Object& value);
}
internal class HandlebarsDotNet.MemberAliasProvider.CollectionMemberAliasProvider : object {
    private static ChainSegment Count;
    private static ChainSegment Length;
    private static CollectionMemberAliasProvider();
    public sealed virtual bool TryGetMemberByAlias(object instance, Type targetType, ChainSegment memberAlias, Object& value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.ObjectAccessor : ValueType {
    private object _data;
    private ObjectDescriptor _descriptor;
    private IMemberAccessor _memberAccessor;
    public IEnumerable`1<ChainSegment> Properties { get; }
    public object Item { get; }
    public ObjectAccessor(object data, ObjectDescriptor descriptor);
    public ObjectAccessor(object data);
    public IEnumerable`1<ChainSegment> get_Properties();
    public object get_Item(ChainSegment segment);
    public bool TryGetValue(ChainSegment segment, Object& value);
}
public class HandlebarsDotNet.ObjectDescriptors.DictionaryObjectDescriptor : object {
    private static Type Type;
    private static MethodInfo Factory;
    private static DictionaryMemberAccessor DictionaryMemberAccessor;
    private static Func`3<ObjectDescriptor, object, IEnumerable> GetProperties;
    private static DictionaryObjectDescriptor();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static ObjectDescriptor ObjectDescriptorFactory();
}
public class HandlebarsDotNet.ObjectDescriptors.DynamicObjectDescriptor : object {
    private ObjectDescriptorProvider _objectDescriptorProvider;
    private static DynamicMemberAccessor DynamicMemberAccessor;
    private static Func`3<ObjectDescriptor, object, IEnumerable`1<object>> GetProperties;
    private static Type Type;
    public DynamicObjectDescriptor(ObjectDescriptorProvider objectDescriptorProvider);
    private static DynamicObjectDescriptor();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
}
public class HandlebarsDotNet.ObjectDescriptors.EnumerableObjectDescriptor : object {
    private static Type Type;
    private static Type StringType;
    private static Type EnumerableObjectDescriptorType;
    private static BindingFlags BindingFlags;
    private static MethodInfo ArrayObjectDescriptorFactoryMethodInfo;
    private static MethodInfo ListObjectDescriptorFactoryMethodInfo;
    private static MethodInfo ReadOnlyListObjectDescriptorFactoryMethodInfo;
    private static MethodInfo NonGenericListObjectDescriptorFactoryMethodInfo;
    private static MethodInfo CollectionObjectDescriptorFactoryMethodInfo;
    private static MethodInfo ReadOnlyCollectionObjectDescriptorFactoryMethodInfo;
    private static MethodInfo NonGenericCollectionObjectDescriptorFactoryMethodInfo;
    private static MethodInfo EnumerableObjectDescriptorFactoryMethodInfo;
    private static MethodInfo NonGenericEnumerableObjectDescriptorFactoryMethodInfo;
    private ObjectDescriptorProvider _descriptorProvider;
    public EnumerableObjectDescriptor(ObjectDescriptorProvider descriptorProvider);
    private static EnumerableObjectDescriptor();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static bool TryCreateArrayDescriptor(Type type, Object[] parameters, ObjectDescriptor& value);
    private static bool TryCreateDescriptorFromOpenGeneric(Type type, Type openGenericType, Object[] parameters, MethodInfo method, ObjectDescriptor& descriptor);
    private static bool TryCreateDescriptor(Type type, Type targetType, Object[] parameters, MethodInfo method, ObjectDescriptor& descriptor);
    private static ObjectDescriptor ArrayObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor ListObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor ReadOnlyListObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor NonGenericListObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor CollectionObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor ReadOnlyCollectionObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor NonGenericCollectionObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor EnumerableObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
    private static ObjectDescriptor NonGenericEnumerableObjectDescriptorFactory(IMemberAccessor accessor, ObjectDescriptor descriptor);
}
public class HandlebarsDotNet.ObjectDescriptors.GenericDictionaryObjectDescriptorProvider : object {
    private static MethodInfo CreateDescriptorMethodInfo;
    private LookupSlim`3<Type, DeferredValue`2<Type, Type>, ReferenceEqualityComparer`1<Type>> _typeCache;
    private static Func`2<Type, DeferredValue`2<Type, Type>> InterfaceTypeValueFactory;
    private static GenericDictionaryObjectDescriptorProvider();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static ObjectDescriptor CreateDescriptor();
}
public interface HandlebarsDotNet.ObjectDescriptors.IObjectDescriptorProvider {
    public abstract virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
}
public class HandlebarsDotNet.ObjectDescriptors.ObjectDescriptor : object {
    public static ObjectDescriptor Empty;
    public IIterator Iterator;
    public Object[] Dependencies;
    public Type DescribedType;
    public Func`3<ObjectDescriptor, object, IEnumerable> GetProperties;
    public IMemberAccessor MemberAccessor;
    public ObjectDescriptor(Type describedType, IMemberAccessor memberAccessor, Func`3<ObjectDescriptor, object, IEnumerable> getProperties, Func`2<ObjectDescriptor, IIterator> iterator, Object[] dependencies);
    private static ObjectDescriptor();
    public static ObjectDescriptor Create(object from);
    public static ObjectDescriptor Create(Type from);
    public static bool TryCreate(object from, ObjectDescriptor& descriptor);
    public static bool TryCreate(Type from, ObjectDescriptor& descriptor);
}
public class HandlebarsDotNet.ObjectDescriptors.ObjectDescriptorFactory : object {
    private ObservableList`1<IObjectDescriptorProvider> _providers;
    private LookupSlim`3<Type, DeferredValue`2<Type, ObjectDescriptor>, ReferenceEqualityComparer`1<Type>> _descriptorsCache;
    private static Func`3<Type, ObservableList`1<IObjectDescriptorProvider>, DeferredValue`2<Type, ObjectDescriptor>> ValueFactory;
    private IObserver`1<ObservableEvent`1<IObjectDescriptorProvider>> _observer;
    public static ObjectDescriptorFactory Current { get; }
    public ObjectDescriptorFactory(ObservableList`1<IObjectDescriptorProvider> providers);
    private static ObjectDescriptorFactory();
    public static ObjectDescriptorFactory get_Current();
    public ObjectDescriptorFactory Append(ObservableList`1<IObjectDescriptorProvider> providers);
    public ObjectDescriptorFactory Append(ObjectDescriptorFactory factory);
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ObservableEvent`1<IObjectDescriptorProvider> value);
}
public class HandlebarsDotNet.ObjectDescriptors.ObjectDescriptorProvider : object {
    private LookupSlim`3<Type, DeferredValue`2<Type, ChainSegment[]>, ReferenceEqualityComparer`1<Type>> _membersCache;
    private ReflectionMemberAccessor _reflectionMemberAccessor;
    private static Func`3<ObjectDescriptor, object, IEnumerable`1<object>> GetProperties;
    private static Func`2<Type, DeferredValue`2<Type, ChainSegment[]>> DescriptorValueFactory;
    public ObjectDescriptorProvider(IReadOnlyList`1<IMemberAliasProvider> aliasProviders);
    private static ObjectDescriptorProvider();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
}
public class HandlebarsDotNet.ObjectDescriptors.ReadOnlyGenericDictionaryObjectDescriptorProvider : object {
    private static MethodInfo CreateDescriptorMethodInfo;
    private LookupSlim`3<Type, DeferredValue`2<Type, Type>, ReferenceEqualityComparer`1<Type>> _typeCache;
    private static Func`2<Type, DeferredValue`2<Type, Type>> InterfaceTypeValueFactory;
    private static ReadOnlyGenericDictionaryObjectDescriptorProvider();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static ObjectDescriptor CreateDescriptor();
}
public class HandlebarsDotNet.ObjectDescriptors.ReadOnlyStringDictionaryObjectDescriptorProvider : object {
    private static Object[] EmptyArray;
    private static MethodInfo CreateClassDescriptorMethodInfo;
    private LookupSlim`3<Type, DeferredValue`2<Type, Type>, ReferenceEqualityComparer`1<Type>> _typeCache;
    private static Func`2<Type, DeferredValue`2<Type, Type>> InterfaceTypeValueFactory;
    private static ReadOnlyStringDictionaryObjectDescriptorProvider();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static ObjectDescriptor CreateDescriptor();
}
public class HandlebarsDotNet.ObjectDescriptors.StringDictionaryObjectDescriptorProvider : object {
    private static Object[] EmptyArray;
    private static MethodInfo CreateClassDescriptorMethodInfo;
    private LookupSlim`3<Type, DeferredValue`2<Type, Type>, ReferenceEqualityComparer`1<Type>> _typeCache;
    private static Func`2<Type, DeferredValue`2<Type, Type>> InterfaceTypeValueFactory;
    private static StringDictionaryObjectDescriptorProvider();
    public sealed virtual bool TryGetDescriptor(Type type, ObjectDescriptor& value);
    private static ObjectDescriptor CreateDescriptor();
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.ObjectExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static T As(object source);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.PathInfoLight : ValueType {
    private int _comparerTag;
    public PathInfo PathInfo;
    [CompilerGeneratedAttribute]
private static PathInfoLightEqualityComparer <PlainPathComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static PathInfoLightEqualityComparer <PlainPathWithPartsCountComparer>k__BackingField;
    internal static PathInfoLightEqualityComparer PlainPathComparer { get; }
    internal static PathInfoLightEqualityComparer PlainPathWithPartsCountComparer { get; }
    public PathInfoLight(PathInfo pathInfo);
    private PathInfoLight(PathInfo pathInfo, int comparerTag);
    private static PathInfoLight();
    [CompilerGeneratedAttribute]
internal static PathInfoLightEqualityComparer get_PlainPathComparer();
    [CompilerGeneratedAttribute]
internal static PathInfoLightEqualityComparer get_PlainPathWithPartsCountComparer();
    internal PathInfoLight TagComparer();
    public sealed virtual bool Equals(PathInfoLight other);
    public sealed virtual bool Equals(PathInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static PathInfoLight op_Implicit(PathInfo pathInfo);
    public static PathInfoLight op_Implicit(string path);
    public static PathInfo op_Implicit(PathInfoLight pathInfo);
}
public class HandlebarsDotNet.PathStructure.ChainSegment : object {
    private static Dictionary`2<string, WellKnownVariable> WellKnownVariables;
    [CompilerGeneratedAttribute]
private static ChainSegmentEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <First>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Last>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainSegment <This>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private int _hashCode;
    [DebuggerBrowsableAttribute("0")]
private string _value;
    public string TrimmedValue;
    public bool IsThis;
    internal string LowerInvariant;
    internal bool IsValue;
    internal WellKnownVariable WellKnownVariable;
    public static ChainSegmentEqualityComparer EqualityComparer { get; }
    public static ChainSegment Index { get; }
    public static ChainSegment First { get; }
    public static ChainSegment Last { get; }
    public static ChainSegment Value { get; }
    public static ChainSegment Key { get; }
    public static ChainSegment Root { get; }
    public static ChainSegment Parent { get; }
    public static ChainSegment This { get; }
    internal ChainSegment(string value, WellKnownVariable wellKnownVariable);
    private static ChainSegment();
    [CompilerGeneratedAttribute]
public static ChainSegmentEqualityComparer get_EqualityComparer();
    public static ChainSegment Create(string value);
    public static ChainSegment Create(object value);
    internal static ChainSegment Create(string value, WellKnownVariable variable);
    [CompilerGeneratedAttribute]
public static ChainSegment get_Index();
    [CompilerGeneratedAttribute]
public static ChainSegment get_First();
    [CompilerGeneratedAttribute]
public static ChainSegment get_Last();
    [CompilerGeneratedAttribute]
public static ChainSegment get_Value();
    [CompilerGeneratedAttribute]
public static ChainSegment get_Key();
    [CompilerGeneratedAttribute]
public static ChainSegment get_Root();
    [CompilerGeneratedAttribute]
public static ChainSegment get_Parent();
    [CompilerGeneratedAttribute]
public static ChainSegment get_This();
    public virtual string ToString();
    public sealed virtual bool Equals(ChainSegment other);
    public virtual bool Equals(object obj);
    private bool EqualsImpl(ChainSegment other);
    public virtual int GetHashCode();
    private int GetHashCodeImpl();
    public static bool op_Equality(ChainSegment a, ChainSegment b);
    public static bool op_Inequality(ChainSegment a, ChainSegment b);
    public static string op_Implicit(ChainSegment segment);
    public static ChainSegment op_Implicit(string segment);
    private static Substring TrimSquareBrackets(Substring key);
}
public class HandlebarsDotNet.PathStructure.ChainSegmentStore : object {
    private static Func`3<string, WellKnownVariable, DeferredValue`2<CreationProperties, ChainSegment>> ValueFactory;
    private LookupSlim`3<string, DeferredValue`2<CreationProperties, ChainSegment>, StringEqualityComparer> _lookup;
    public static ChainSegmentStore Current { get; }
    private static ChainSegmentStore();
    public static ChainSegmentStore get_Current();
    public ChainSegment Create(string value);
    public ChainSegment Create(object value);
    public ChainSegment Create(string value, WellKnownVariable variable);
}
public class HandlebarsDotNet.PathStructure.PathInfo : object {
    internal bool IsValidHelperLiteral;
    internal bool HasValue;
    internal bool IsThis;
    internal bool IsPureThis;
    internal bool IsInversion;
    internal bool IsBlockHelper;
    internal bool IsBlockClose;
    private int _hashCode;
    private int _trimmedHashCode;
    private int _trimmedInvariantHashCode;
    public static PathInfo Empty;
    public bool IsVariable;
    public PathSegment[] Segments;
    public string Path;
    public string TrimmedPath;
    private PathInfo(PathType pathType, string path, bool isValidHelperLiteral, PathSegment[] segments);
    private static PathInfo();
    public sealed virtual bool Equals(PathInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static string op_Implicit(PathInfo pathInfo);
    public static PathInfo op_Implicit(string path);
    public static PathInfo Parse(string path);
    private static ChainSegment[] GetPathChain(Substring segmentString);
    private static PathType GetPathType(string path);
}
public class HandlebarsDotNet.PathStructure.PathInfoStore : object {
    private static Func`2<string, DeferredValue`2<string, PathInfo>> ValueFactory;
    private LookupSlim`3<string, DeferredValue`2<string, PathInfo>, StringEqualityComparer> _paths;
    public static PathInfoStore Current { get; }
    private static PathInfoStore();
    public static PathInfoStore get_Current();
    public PathInfo GetOrAdd(string path);
}
public static class HandlebarsDotNet.PathStructure.PathResolver : object {
    public static object ResolvePath(BindingContext context, PathInfo pathInfo);
    private static bool TryResolveValue(bool isVariable, BindingContext context, ChainSegment chainSegment, object instance, Object& value);
    public static bool TryAccessMember(BindingContext context, object instance, ChainSegment chainSegment, Object& value);
    private static ChainSegment ResolveMemberName(object instance, ChainSegment memberName, ICompiledHandlebarsConfiguration configuration);
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.PathStructure.PathSegment : ValueType {
    private static Substring ThisSubstring;
    private int _hashCode;
    internal bool IsParent;
    internal bool IsThis;
    public ChainSegment[] PathChain;
    public bool IsNotEmpty;
    internal PathSegment(Substring segment, ChainSegment[] chain);
    private static PathSegment();
    public sealed virtual bool Equals(PathSegment other);
    public sealed virtual bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private int GetHashCodeImpl();
}
public enum HandlebarsDotNet.PathStructure.PathType : Enum {
    public int value__;
    public static PathType None;
    public static PathType Empty;
    public static PathType Variable;
    public static PathType Inversion;
    public static PathType BlockHelper;
    public static PathType BlockClose;
}
public enum HandlebarsDotNet.PathStructure.WellKnownVariable : Enum {
    public int value__;
    public static WellKnownVariable None;
    public static WellKnownVariable Index;
    public static WellKnownVariable Key;
    public static WellKnownVariable Value;
    public static WellKnownVariable First;
    public static WellKnownVariable Last;
    public static WellKnownVariable Root;
    public static WellKnownVariable Parent;
    public static WellKnownVariable This;
}
internal static class HandlebarsDotNet.Polyfills.ArrayEx : object {
    public static T[] Empty();
}
internal class HandlebarsDotNet.Pools.GenericObjectPool`1 : InternalObjectPool`2<T, Policy<T>> {
    [CompilerGeneratedAttribute]
private static GenericObjectPool`1<T> <Shared>k__BackingField;
    public static GenericObjectPool`1<T> Shared { get; }
    private static GenericObjectPool`1();
    [CompilerGeneratedAttribute]
public static GenericObjectPool`1<T> get_Shared();
}
internal interface HandlebarsDotNet.Pools.IInternalObjectPoolPolicy`1 {
    public abstract virtual T Create();
    public abstract virtual bool Return(T item);
}
internal class HandlebarsDotNet.Pools.InternalObjectPool`2 : object {
    private TPolicy _policy;
    private ConcurrentQueue`1<T> _queue;
    public InternalObjectPool`2(TPolicy policy);
    public T Get();
    public void Return(T obj);
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.Pools.ObjectPoolExtensions : object {
    [ExtensionAttribute]
public static DisposableContainer`2<T, InternalObjectPool`2<T, TPolicy>> Use(InternalObjectPool`2<T, TPolicy> objectPool);
}
internal class HandlebarsDotNet.Pools.StringBuilderPool : InternalObjectPool`2<StringBuilder, StringBuilderPooledObjectPolicy> {
    private static Lazy`1<StringBuilderPool> Lazy;
    public static StringBuilderPool Shared { get; }
    public StringBuilderPool(int initialCapacity);
    private static StringBuilderPool();
    public static StringBuilderPool get_Shared();
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
public static DisposableContainer`1<ReaderWriterLockSlim> ReadLock(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
public static DisposableContainer`1<ReaderWriterLockSlim> WriteLock(ReaderWriterLockSlim lock);
}
public class HandlebarsDotNet.ReusableStringWriter : StringWriter {
    private static InternalObjectPool`2<ReusableStringWriter, Policy> Pool;
    private IFormatProvider _formatProvider;
    public IFormatProvider FormatProvider { get; }
    private static ReusableStringWriter();
    public static ReusableStringWriter Get(IFormatProvider formatProvider);
    public virtual IFormatProvider get_FormatProvider();
    protected virtual void Dispose(bool disposing);
}
public class HandlebarsDotNet.Runtime.AmbientContext : object {
    private static InternalObjectPool`2<AmbientContext, Policy> Pool;
    [ThreadStaticAttribute]
private static Stack`1<AmbientContext> _local;
    [CompilerGeneratedAttribute]
private PathInfoStore <PathInfoStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ChainSegmentStore <ChainSegmentStore>k__BackingField;
    [CompilerGeneratedAttribute]
private UndefinedBindingResultCache <UndefinedBindingResultCache>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterProvider <FormatterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectDescriptorFactory <ObjectDescriptorFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Bag>k__BackingField;
    private static Stack`1<AmbientContext> Local { get; }
    public static AmbientContext Current { get; }
    public PathInfoStore PathInfoStore { get; private set; }
    public ChainSegmentStore ChainSegmentStore { get; private set; }
    public UndefinedBindingResultCache UndefinedBindingResultCache { get; private set; }
    public FormatterProvider FormatterProvider { get; private set; }
    public ObjectDescriptorFactory ObjectDescriptorFactory { get; private set; }
    public Dictionary`2<string, object> Bag { get; }
    private static AmbientContext();
    private static Stack`1<AmbientContext> get_Local();
    public static AmbientContext get_Current();
    public static AmbientContext Create(PathInfoStore pathInfoStore, ChainSegmentStore chainSegmentStore, UndefinedBindingResultCache undefinedBindingResultCache, FormatterProvider formatterProvider, ObjectDescriptorFactory descriptorFactory);
    public static AmbientContext Create(AmbientContext context, PathInfoStore pathInfoStore, ChainSegmentStore chainSegmentStore, UndefinedBindingResultCache undefinedBindingResultCache, FormatterProvider formatterProvider, ObjectDescriptorFactory descriptorFactory);
    public static DisposableContainer Use(AmbientContext ambientContext);
    [CompilerGeneratedAttribute]
public PathInfoStore get_PathInfoStore();
    [CompilerGeneratedAttribute]
private void set_PathInfoStore(PathInfoStore value);
    [CompilerGeneratedAttribute]
public ChainSegmentStore get_ChainSegmentStore();
    [CompilerGeneratedAttribute]
private void set_ChainSegmentStore(ChainSegmentStore value);
    [CompilerGeneratedAttribute]
public UndefinedBindingResultCache get_UndefinedBindingResultCache();
    [CompilerGeneratedAttribute]
private void set_UndefinedBindingResultCache(UndefinedBindingResultCache value);
    [CompilerGeneratedAttribute]
public FormatterProvider get_FormatterProvider();
    [CompilerGeneratedAttribute]
private void set_FormatterProvider(FormatterProvider value);
    [CompilerGeneratedAttribute]
public ObjectDescriptorFactory get_ObjectDescriptorFactory();
    [CompilerGeneratedAttribute]
private void set_ObjectDescriptorFactory(ObjectDescriptorFactory value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Bag();
    public sealed virtual void Dispose();
}
public static class HandlebarsDotNet.Runtime.BoxedValues : object {
    private static int BoxedIntegersCount;
    private static Object[] BoxedIntegers;
    public static object True;
    public static object False;
    public static object Zero;
    private static BoxedValues();
    public static object Int(int value);
}
public class HandlebarsDotNet.Runtime.DeferredValue`2 : object {
    private TState _state;
    private Func`2<TState, T> _factory;
    private T _value;
    private bool _isValueCreated;
    public T Value { get; }
    public DeferredValue`2(TState state, Func`2<TState, T> factory);
    public virtual string ToString();
    public T get_Value();
    public void Reset();
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.Runtime.DisposableContainer : ValueType {
    private Action _onDispose;
    public DisposableContainer(Action onDispose);
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.Runtime.DisposableContainer`1 : ValueType {
    private Action`1<T> _onDispose;
    public T Value;
    public DisposableContainer`1(T value, Action`1<T> onDispose);
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
public class HandlebarsDotNet.Runtime.DisposableContainer`2 : ValueType {
    private TState _state;
    private Action`2<T, TState> _onDispose;
    public T Value;
    public DisposableContainer`2(T value, TState state, Action`2<T, TState> onDispose);
    public sealed virtual void Dispose();
}
public class HandlebarsDotNet.Runtime.GcDeferredValue`2 : object {
    private TState _state;
    private Func`2<TState, T> _factory;
    private WeakReference`1<T> _value;
    private bool _isValueCreated;
    public T Value { get; }
    public GcDeferredValue`2(TState state, Func`2<TState, T> factory);
    public virtual string ToString();
    public T get_Value();
}
public class HandlebarsDotNet.Runtime.Ref`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Ref`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal class HandlebarsDotNet.StringUtils.StringBuilderEnumerator : ValueType {
    private StringBuilder _stringBuilder;
    private int _index;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    public StringBuilderEnumerator(StringBuilder stringBuilder);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Dispose();
}
internal class HandlebarsDotNet.StringUtils.StringEnumerator : ValueType {
    private string _text;
    private int _length;
    private int _index;
    public char Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public StringEnumerator(string text);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual char get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.StringUtils.Substring : ValueType {
    public string String;
    public int Start;
    public int Length;
    public char Item { get; }
    public Substring(string str);
    public Substring(Substring& substring);
    public Substring(Substring& substring, Int32& start);
    public Substring(Substring& substring, Int32& start, Int32& length);
    public Substring(string str, Int32& start);
    public Substring(string str, Int32& start, Int32& length);
    public char get_Item(Int32& index);
    public sealed virtual bool Equals(Substring other);
    public sealed virtual bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool EqualsIgnoreCase(Substring& a, Substring& b);
    public static SplitEnumerator Split(Substring& str, Char& separator, StringSplitOptions& options);
    public static Substring TrimStart(Substring& str, Char& trimChar);
    public static Substring TrimEnd(Substring& str, Char& trimChar);
    public static Substring Trim(Substring& str, Char& trimChar);
    public static bool StartsWith(Substring& substring, Char& c);
    public static bool EndsWith(Substring& substring, Char& c);
    public SubstringEnumerator GetEnumerator();
    public static bool op_Equality(Substring& a, Substring& b);
    public static bool op_Inequality(Substring& a, Substring& b);
    public static bool op_Equality(Substring& a, string b);
    public static bool op_Inequality(Substring& a, string b);
    public static bool op_Equality(string a, Substring& b);
    public static bool op_Inequality(string a, Substring& b);
    public static bool Contains(Substring& substring, Char& c);
    public static int IndexOf(Substring& substring, Char& c);
    public static int IndexOf(Substring& substring, Char& c, int startIndex);
    public static bool IndexOf(Substring& substring, Char& c, Int32& index);
    public static bool IndexOf(Substring& substring, Char& c, Int32& startIndex, Int32& index);
    public static int LastIndexOf(Substring& substring, Char& c);
    public static int LastIndexOf(Substring& substring, Char& c, int startIndex);
    public static bool LastIndexOf(Substring& substring, Char& c, Int32& index);
    public static bool LastIndexOf(Substring& substring, Char& c, int startIndex, Int32& index);
    public static Substring op_Implicit(string a);
}
internal class HandlebarsDotNet.SubExpressionExpression : HandlebarsExpression {
    private Expression _expression;
    public Type Type { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    public SubExpressionExpression(Expression expression);
    public virtual Type get_Type();
    public Expression get_Expression();
    public virtual ExpressionType get_NodeType();
}
internal class HandlebarsDotNet.TextEncoderWrapper : object {
    private static InternalObjectPool`2<TextEncoderWrapper, Policy> Pool;
    private ITextEncoder _underlyingEncoder;
    private bool _enabled;
    [CompilerGeneratedAttribute]
private static TextEncoderWrapper <Null>k__BackingField;
    public static TextEncoderWrapper Null { get; }
    public bool Enabled { get; public set; }
    private static TextEncoderWrapper();
    [CompilerGeneratedAttribute]
public static TextEncoderWrapper get_Null();
    public static TextEncoderWrapper Create(ITextEncoder encoder);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public sealed virtual void Encode(StringBuilder text, TextWriter target);
    public sealed virtual void Encode(string text, TextWriter target);
    public sealed virtual void Encode(T text, TextWriter target);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class HandlebarsDotNet.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsAssignableToGenericType(Type givenType, Type genericType, Type& resolvedType);
}
[DebuggerDisplayAttribute("undefined")]
public class HandlebarsDotNet.UndefinedBindingResult : object {
    public string Value;
    internal UndefinedBindingResult(string value);
    public static UndefinedBindingResult Create(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(UndefinedBindingResult other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class HandlebarsDotNet.UndefinedBindingResultCache : object {
    private static Func`2<string, DeferredValue`2<string, UndefinedBindingResult>> ValueFactory;
    private LookupSlim`3<string, DeferredValue`2<string, UndefinedBindingResult>, StringEqualityComparer> _cache;
    public static UndefinedBindingResultCache Current { get; }
    private static UndefinedBindingResultCache();
    public static UndefinedBindingResultCache get_Current();
    public UndefinedBindingResult Create(string value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.ValueProviders.BlockParamsValues : ValueType {
    private ChainSegment[] _variables;
    private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> _values;
    unknown object Item {public set; }
    unknown object Item {public set; }
    public BlockParamsValues(BindingContext context, ChainSegment[] variables);
    public void CreateProperty(Int32& variableIndex, EntryIndex`1& index);
    public void set_Item(EntryIndex`1& index, object value);
    public void set_Item(int variableIndex, object value);
    private ChainSegment GetVariable(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class HandlebarsDotNet.ValueProviders.DataValues : ValueType {
    private EntryIndex`1[] _wellKnownVariables;
    private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> _data;
    public object Item { get; public set; }
    public object Item { get; public set; }
    public DataValues(BindingContext context);
    public T Value(ChainSegment segment);
    public object get_Item(ChainSegment segment);
    public void set_Item(ChainSegment segment, object value);
    public object get_Item(EntryIndex`1& entryIndex);
    public void set_Item(EntryIndex`1& entryIndex, object value);
    public void CreateProperty(ChainSegment variable, EntryIndex`1& index);
    public void CreateProperty(ChainSegment variable, object defaultValue, EntryIndex`1& index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class HandlebarsDotNet.ValueProviders.IteratorValues : ValueType {
    private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> _data;
    private EntryIndex`1[] _wellKnownVariables;
    public object Value { get; public set; }
    public object First { get; public set; }
    public object Index { get; public set; }
    public object Key { get; public set; }
    public object Last { get; public set; }
    public IteratorValues(BindingContext bindingContext);
    public object get_Value();
    public void set_Value(object value);
    public object get_First();
    public void set_First(object value);
    public object get_Index();
    public void set_Index(object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Last();
    public void set_Last(object value);
}
[IsByRefLikeAttribute]
[IsReadOnlyAttribute]
[ObsoleteAttribute("Use IteratorValues")]
public class HandlebarsDotNet.ValueProviders.ObjectIteratorValues : ValueType {
    private FixedSizeDictionary`3<ChainSegment, object, ChainSegmentEqualityComparer> _data;
    private EntryIndex`1[] _wellKnownVariables;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public object First { get; public set; }
    public object Index { get; public set; }
    public object Last { get; public set; }
    public ObjectIteratorValues(BindingContext bindingContext);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    public object get_First();
    public void set_First(object value);
    public object get_Index();
    public void set_Index(object value);
    public object get_Last();
    public void set_Last(object value);
}
public abstract class HandlebarsDotNet.ViewEngineFileSystem : object {
    public abstract virtual string GetFileContent(string filename);
    private static string GetDir(string currentFilePath);
    public string Closest(string filename, string otherFileName);
    protected abstract virtual string CombinePath(string dir, string otherFileName);
    public abstract virtual bool FileExists(string filePath);
}
public class HandlebarsDotNet.ViewReaderFactory : MulticastDelegate {
    public ViewReaderFactory(object object, IntPtr method);
    public virtual TextReader Invoke(ICompiledHandlebarsConfiguration configuration, string templatePath);
    public virtual IAsyncResult BeginInvoke(ICompiledHandlebarsConfiguration configuration, string templatePath, AsyncCallback callback, object object);
    public virtual TextReader EndInvoke(IAsyncResult result);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
