internal enum CronExpressionDescriptor.CasingTypeEnum : Enum {
    public int value__;
    public static CasingTypeEnum Title;
    public static CasingTypeEnum Sentence;
    public static CasingTypeEnum LowerCase;
}
internal enum CronExpressionDescriptor.DescriptionTypeEnum : Enum {
    public int value__;
    public static DescriptionTypeEnum FULL;
    public static DescriptionTypeEnum TIMEOFDAY;
    public static DescriptionTypeEnum SECONDS;
    public static DescriptionTypeEnum MINUTES;
    public static DescriptionTypeEnum HOURS;
    public static DescriptionTypeEnum DAYOFWEEK;
    public static DescriptionTypeEnum MONTH;
    public static DescriptionTypeEnum DAYOFMONTH;
    public static DescriptionTypeEnum YEAR;
}
internal class CronExpressionDescriptor.ExpressionDescriptor : object {
    private Char[] m_specialCharacters;
    private string m_expression;
    private Options m_options;
    private String[] m_expressionParts;
    private bool m_parsed;
    private CultureInfo m_culture;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate2c;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate33;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate34;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate35;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate37;
    public ExpressionDescriptor(string expression);
    public ExpressionDescriptor(string expression, Options options);
    public string GetDescription(DescriptionTypeEnum type);
    protected string GetFullDescription();
    protected string GetTimeOfDayDescription();
    protected string GetSecondsDescription();
    protected string GetMinutesDescription();
    protected string GetHoursDescription();
    protected string GetDayOfWeekDescription();
    protected string GetMonthDescription();
    protected string GetDayOfMonthDescription();
    private string GetYearDescription();
    protected string GetSegmentDescription(string expression, string allDescription, Func`2<string, string> getSingleItemDescription, Func`2<string, string> getIntervalDescriptionFormat, Func`2<string, string> getBetweenDescriptionFormat, Func`2<string, string> getDescriptionFormat);
    protected string GenerateBetweenSegmentDescription(string betweenExpression, Func`2<string, string> getBetweenDescriptionFormat, Func`2<string, string> getSingleItemDescription);
    protected string FormatTime(string hourExpression, string minuteExpression);
    protected string FormatTime(string hourExpression, string minuteExpression, string secondExpression);
    protected string TransformVerbosity(string description, bool useVerboseFormat);
    protected string TransformCase(string description, CasingTypeEnum caseType);
    public static string GetDescription(string expression);
    public static string GetDescription(string expression, Options options);
    [CompilerGeneratedAttribute]
private static string <GetSecondsDescription>b__0(string s);
    [CompilerGeneratedAttribute]
private static string <GetSecondsDescription>b__1(string s);
    [CompilerGeneratedAttribute]
private static string <GetSecondsDescription>b__2(string s);
    [CompilerGeneratedAttribute]
private static string <GetSecondsDescription>b__3(string s);
    [CompilerGeneratedAttribute]
private static string <GetMinutesDescription>b__8(string s);
    [CompilerGeneratedAttribute]
private static string <GetMinutesDescription>b__9(string s);
    [CompilerGeneratedAttribute]
private static string <GetMinutesDescription>b__a(string s);
    [CompilerGeneratedAttribute]
private static string <GetMinutesDescription>b__b(string s);
    [CompilerGeneratedAttribute]
private string <GetHoursDescription>b__10(string s);
    [CompilerGeneratedAttribute]
private static string <GetHoursDescription>b__11(string s);
    [CompilerGeneratedAttribute]
private static string <GetHoursDescription>b__12(string s);
    [CompilerGeneratedAttribute]
private static string <GetHoursDescription>b__13(string s);
    [CompilerGeneratedAttribute]
private string <GetDayOfWeekDescription>b__17(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfWeekDescription>b__18(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfWeekDescription>b__19(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfWeekDescription>b__1a(string s);
    [CompilerGeneratedAttribute]
private static string <GetMonthDescription>b__1e(string s);
    [CompilerGeneratedAttribute]
private static string <GetMonthDescription>b__1f(string s);
    [CompilerGeneratedAttribute]
private static string <GetMonthDescription>b__20(string s);
    [CompilerGeneratedAttribute]
private static string <GetMonthDescription>b__21(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfMonthDescription>b__26(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfMonthDescription>b__27(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfMonthDescription>b__28(string s);
    [CompilerGeneratedAttribute]
private static string <GetDayOfMonthDescription>b__29(string s);
    [CompilerGeneratedAttribute]
private static string <GetYearDescription>b__2e(string s);
    [CompilerGeneratedAttribute]
private static string <GetYearDescription>b__2f(string s);
    [CompilerGeneratedAttribute]
private static string <GetYearDescription>b__30(string s);
    [CompilerGeneratedAttribute]
private static string <GetYearDescription>b__31(string s);
    [CompilerGeneratedAttribute]
private static string <GetSegmentDescription>b__36(string s);
}
internal class CronExpressionDescriptor.ExpressionParser : object {
    private string m_expression;
    private Options m_options;
    private CultureInfo m_en_culture;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public ExpressionParser(string expression, Options options);
    public String[] Parse();
    private void NormalizeExpression(String[] expressionParts);
    private static string DecreaseDaysOfWeek(string dayOfWeekExpressionPart);
    [CompilerGeneratedAttribute]
private static string <Parse>b__0(string el);
}
internal class CronExpressionDescriptor.Options : object {
    [CompilerGeneratedAttribute]
private bool <ThrowExceptionOnParseError>k__BackingField;
    [CompilerGeneratedAttribute]
private CasingTypeEnum <CasingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DayOfWeekStartIndexZero>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Use24HourTimeFormat>k__BackingField;
    public bool ThrowExceptionOnParseError { get; public set; }
    public CasingTypeEnum CasingType { get; public set; }
    public bool Verbose { get; public set; }
    public bool DayOfWeekStartIndexZero { get; public set; }
    public bool Use24HourTimeFormat { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptionOnParseError();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptionOnParseError(bool value);
    [CompilerGeneratedAttribute]
public CasingTypeEnum get_CasingType();
    [CompilerGeneratedAttribute]
public void set_CasingType(CasingTypeEnum value);
    [CompilerGeneratedAttribute]
public bool get_Verbose();
    [CompilerGeneratedAttribute]
public void set_Verbose(bool value);
    [CompilerGeneratedAttribute]
public bool get_DayOfWeekStartIndexZero();
    [CompilerGeneratedAttribute]
public void set_DayOfWeekStartIndexZero(bool value);
    [CompilerGeneratedAttribute]
public bool get_Use24HourTimeFormat();
    [CompilerGeneratedAttribute]
public void set_Use24HourTimeFormat(bool value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CronExpressionDescriptor.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnErrorOccuredWhenGeneratingTheExpressionD { get; }
    internal static string At { get; }
    internal static string AtSpace { get; }
    internal static string AtX0 { get; }
    internal static string AtX0MinutesPastTheHour { get; }
    internal static string AtX0MinutesPastTheHourGt20 { get; }
    internal static string AtX0SecondsPastTheMinute { get; }
    internal static string AtX0SecondsPastTheMinuteGt20 { get; }
    internal static string BetweenX0AndX1 { get; }
    internal static string ComaBetweenDayX0AndX1OfTheMonth { get; }
    internal static string ComaEveryDay { get; }
    internal static string ComaEveryHour { get; }
    internal static string ComaEveryMinute { get; }
    internal static string ComaEveryX0Days { get; }
    internal static string ComaEveryX0DaysOfTheWeek { get; }
    internal static string ComaEveryX0Months { get; }
    internal static string ComaEveryX0Years { get; }
    internal static string ComaOnDayX0OfTheMonth { get; }
    internal static string ComaOnlyInX0 { get; }
    internal static string ComaOnlyOnX0 { get; }
    internal static string ComaOnThe { get; }
    internal static string ComaOnTheLastDayOfTheMonth { get; }
    internal static string ComaOnTheLastWeekdayOfTheMonth { get; }
    internal static string ComaOnTheLastX0OfTheMonth { get; }
    internal static string ComaOnTheX0OfTheMonth { get; }
    internal static string ComaX0ThroughX1 { get; }
    internal static string ComaMinX0ThroughMinX1 { get; }
    internal static string ComaMonthX0ThroughMonthX1 { get; }
    internal static string ComaYearX0ThroughYearX1 { get; }
    internal static string CommaStartingX0 { get; }
    internal static string EveryHour { get; }
    internal static string EveryMinute { get; }
    internal static string EveryMinuteBetweenX0AndX1 { get; }
    internal static string EverySecond { get; }
    internal static string EveryX0Hours { get; }
    internal static string EveryX0Minutes { get; }
    internal static string EveryX0Seconds { get; }
    internal static string Fifth { get; }
    internal static string First { get; }
    internal static string FirstWeekday { get; }
    internal static string Forth { get; }
    internal static string MinutesX0ThroughX1PastTheHour { get; }
    internal static string Second { get; }
    internal static string SecondsX0ThroughX1PastTheMinute { get; }
    internal static string SpaceAnd { get; }
    internal static string SpaceAndSpace { get; }
    internal static string SpaceX0OfTheMonth { get; }
    internal static string Third { get; }
    internal static string WeekdayNearestDayX0 { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnErrorOccuredWhenGeneratingTheExpressionD();
    internal static string get_At();
    internal static string get_AtSpace();
    internal static string get_AtX0();
    internal static string get_AtX0MinutesPastTheHour();
    internal static string get_AtX0MinutesPastTheHourGt20();
    internal static string get_AtX0SecondsPastTheMinute();
    internal static string get_AtX0SecondsPastTheMinuteGt20();
    internal static string get_BetweenX0AndX1();
    internal static string get_ComaBetweenDayX0AndX1OfTheMonth();
    internal static string get_ComaEveryDay();
    internal static string get_ComaEveryHour();
    internal static string get_ComaEveryMinute();
    internal static string get_ComaEveryX0Days();
    internal static string get_ComaEveryX0DaysOfTheWeek();
    internal static string get_ComaEveryX0Months();
    internal static string get_ComaEveryX0Years();
    internal static string get_ComaOnDayX0OfTheMonth();
    internal static string get_ComaOnlyInX0();
    internal static string get_ComaOnlyOnX0();
    internal static string get_ComaOnThe();
    internal static string get_ComaOnTheLastDayOfTheMonth();
    internal static string get_ComaOnTheLastWeekdayOfTheMonth();
    internal static string get_ComaOnTheLastX0OfTheMonth();
    internal static string get_ComaOnTheX0OfTheMonth();
    internal static string get_ComaX0ThroughX1();
    internal static string get_ComaMinX0ThroughMinX1();
    internal static string get_ComaMonthX0ThroughMonthX1();
    internal static string get_ComaYearX0ThroughYearX1();
    internal static string get_CommaStartingX0();
    internal static string get_EveryHour();
    internal static string get_EveryMinute();
    internal static string get_EveryMinuteBetweenX0AndX1();
    internal static string get_EverySecond();
    internal static string get_EveryX0Hours();
    internal static string get_EveryX0Minutes();
    internal static string get_EveryX0Seconds();
    internal static string get_Fifth();
    internal static string get_First();
    internal static string get_FirstWeekday();
    internal static string get_Forth();
    internal static string get_MinutesX0ThroughX1PastTheHour();
    internal static string get_Second();
    internal static string get_SecondsX0ThroughX1PastTheMinute();
    internal static string get_SpaceAnd();
    internal static string get_SpaceAndSpace();
    internal static string get_SpaceX0OfTheMonth();
    internal static string get_Third();
    internal static string get_WeekdayNearestDayX0();
}
internal static class Cronos.CalendarHelper : object {
    private static int DaysPerWeekCount;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static Int32[] DaysInMonth;
    private static CalendarHelper();
    public static bool IsGreaterThan(int year1, int month1, int day1, int year2, int month2, int day2);
    public static long DateTimeToTicks(int year, int month, int day, int hour, int minute, int second);
    public static void FillDateTimeParts(long ticks, Int32& second, Int32& minute, Int32& hour, Int32& day, Int32& month, Int32& year);
    public static DayOfWeek GetDayOfWeek(int year, int month, int day);
    public static int GetDaysInMonth(int year, int month);
    public static int MoveToNearestWeekDay(int year, int month, int day);
    public static bool IsNthDayOfWeek(int day, int n);
    public static bool IsLastDayOfWeek(int year, int month, int day);
}
internal class Cronos.CronExpression : object {
    private static long NotFound;
    private static int MaxYear;
    public static CronExpression Yearly;
    public static CronExpression Weekly;
    public static CronExpression Monthly;
    public static CronExpression Daily;
    public static CronExpression Hourly;
    public static CronExpression EveryMinute;
    public static CronExpression EverySecond;
    private static TimeZoneInfo UtcTimeZone;
    private static Int32[] DeBruijnPositions;
    private long _second;
    private long _minute;
    private int _hour;
    private int _dayOfMonth;
    private short _month;
    private byte _dayOfWeek;
    private byte _nthDayOfWeek;
    private byte _lastMonthOffset;
    private CronExpressionFlag _flags;
    internal CronExpression(long second, long minute, int hour, int dayOfMonth, short month, byte dayOfWeek, byte nthDayOfWeek, byte lastMonthOffset, CronExpressionFlag flags);
    private static CronExpression();
    public static CronExpression Parse(string expression);
    public static CronExpression Parse(string expression, CronFormat format);
    public static bool TryParse(string expression, CronExpression& cronExpression);
    public static bool TryParse(string expression, CronFormat format, CronExpression& cronExpression);
    public Nullable`1<DateTime> GetNextOccurrence(DateTime fromUtc, bool inclusive);
    [IteratorStateMachineAttribute("Cronos.CronExpression/<GetOccurrences>d__26")]
public IEnumerable`1<DateTime> GetOccurrences(DateTime fromUtc, DateTime toUtc, bool fromInclusive, bool toInclusive);
    public Nullable`1<DateTime> GetNextOccurrence(DateTime fromUtc, TimeZoneInfo zone, bool inclusive);
    [IteratorStateMachineAttribute("Cronos.CronExpression/<GetOccurrences>d__28")]
public IEnumerable`1<DateTime> GetOccurrences(DateTime fromUtc, DateTime toUtc, TimeZoneInfo zone, bool fromInclusive, bool toInclusive);
    public Nullable`1<DateTimeOffset> GetNextOccurrence(DateTimeOffset from, TimeZoneInfo zone, bool inclusive);
    [IteratorStateMachineAttribute("Cronos.CronExpression/<GetOccurrences>d__30")]
public IEnumerable`1<DateTimeOffset> GetOccurrences(DateTimeOffset from, DateTimeOffset to, TimeZoneInfo zone, bool fromInclusive, bool toInclusive);
    public virtual string ToString();
    public sealed virtual bool Equals(CronExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CronExpression left, CronExpression right);
    public static bool op_Inequality(CronExpression left, CronExpression right);
    private Nullable`1<DateTimeOffset> GetOccurrenceConsideringTimeZone(DateTimeOffset fromUtc, TimeZoneInfo zone, bool inclusive);
    private long FindOccurrence(long startTimeTicks, long endTimeTicks, bool startInclusive);
    private long FindOccurrence(long ticks, bool startInclusive);
    private static bool Move(long fieldBits, Int32& fieldValue);
    private int GetLastDayOfMonth(int year, int month);
    private bool IsDayOfWeekMatch(int year, int month, int day);
    private static int GetFirstSet(long value);
    private bool HasFlag(CronExpressionFlag value);
    private static StringBuilder AppendFieldValue(StringBuilder expressionBuilder, CronField field, long fieldValue);
    private StringBuilder AppendDayOfMonth(StringBuilder expressionBuilder, int domValue);
    private void AppendDayOfWeek(StringBuilder expressionBuilder, int dowValue);
    private static void ThrowFromShouldBeLessThanToException(string fromName, string toName);
    private static void ThrowWrongDateTimeKindException(string paramName);
    private static void ThrowDateTimeExceedsMaxException(string paramName);
    private static void ThrowArgumentNullException(string paramName);
    private static bool GetBit(long value, int index);
}
[FlagsAttribute]
internal enum Cronos.CronExpressionFlag : Enum {
    public byte value__;
    public static CronExpressionFlag DayOfMonthLast;
    public static CronExpressionFlag DayOfWeekLast;
    public static CronExpressionFlag Interval;
    public static CronExpressionFlag NearestWeekday;
    public static CronExpressionFlag NthDayOfWeek;
}
internal class Cronos.CronField : object {
    private static String[] MonthNames;
    private static String[] DayOfWeekNames;
    private static Int32[] MonthNamesArray;
    private static Int32[] DayOfWeekNamesArray;
    public static CronField DaysOfWeek;
    public static CronField Months;
    public static CronField DaysOfMonth;
    public static CronField Hours;
    public static CronField Minutes;
    public static CronField Seconds;
    public string Name;
    public int First;
    public int Last;
    public Int32[] Names;
    public bool CanDefineInterval;
    public long AllBits;
    private static CronField();
    private CronField(string name, int first, int last, Int32[] names, bool canDefineInterval);
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Cronos.CronFormat : Enum {
    public int value__;
    public static CronFormat Standard;
    public static CronFormat IncludeSeconds;
}
internal class Cronos.CronFormatException : FormatException {
    private static string BaseMessage;
    public CronFormatException(string message);
    public CronFormatException(string message, Exception innerException);
    internal CronFormatException(CronField field, string message);
    protected CronFormatException(SerializationInfo info, StreamingContext context);
}
internal static class Cronos.CronParser : object {
    private static int MinNthDayOfWeek;
    private static int MaxNthDayOfWeek;
    private static int SundayBits;
    public static CronExpression Parse(string expression, CronFormat format);
    private static void SkipWhiteSpaces(Char*& pointer);
    private static void ParseWhiteSpace(CronField prevField, Char*& pointer);
    private static void ParseEndOfString(Char*& pointer);
    private static CronExpression ParseMacro(Char*& pointer);
    private static long ParseField(CronField field, Char*& pointer, CronExpressionFlag& flags);
    private static long ParseDayOfMonth(Char*& pointer, CronExpressionFlag& flags, Byte& lastDayOffset);
    private static long ParseDayOfWeek(Char*& pointer, CronExpressionFlag& flags, Byte& nthWeekDay);
    private static long ParseStar(CronField field, Char*& pointer);
    private static long ParseList(CronField field, Char*& pointer, CronExpressionFlag& flags);
    private static long ParseRange(CronField field, Char*& pointer, int low, CronExpressionFlag& flags);
    private static long ParseStep(CronField field, Char*& pointer, int low, int high);
    private static long ParseLastDayOfMonth(CronField field, Char*& pointer, CronExpressionFlag& flags, Byte& lastMonthOffset);
    private static long ParseNthWeekDay(CronField field, Char*& pointer, int dayOfWeek, CronExpressionFlag& flags, Byte& nthDayOfWeek);
    private static long ParseLastWeekDay(int dayOfWeek, CronExpressionFlag& flags);
    private static bool Accept(Char*& pointer, char character);
    private static bool AcceptCharacter(Char*& pointer, char character);
    private static int ParseNumber(CronField field, Char*& pointer, int low, int high);
    private static int ParseValue(CronField field, Char*& pointer);
    private static long GetBits(CronField field, int num1, int num2, int step);
    private static long GetRangeBits(int low, int high, int step);
    private static long GetReversedRangeBits(CronField field, int num1, int num2, int step);
    private static long GetBit(int num1);
    private static int GetNumber(Char*& pointer, Int32[] names);
    private static void SetBit(Int64& value, int index);
    private static bool IsEndOfString(int code);
    private static bool IsWhiteSpace(int code);
    private static bool IsDigit(int code);
    private static bool IsLetter(int code);
    private static int GetNumeric(int code);
    private static int ToUpper(int code);
    private static void ThrowFormatException(CronField field, string format, Object[] args);
    private static void ThrowFormatException(string format, Object[] args);
}
internal static class Cronos.DateTimeHelper : object {
    private static TimeSpan OneSecond;
    private static DateTimeHelper();
    public static DateTimeOffset FloorToSeconds(DateTimeOffset dateTimeOffset);
    public static bool IsRound(DateTimeOffset dateTimeOffset);
    private static long GetExtraTicks(long ticks);
}
internal static class Cronos.TimeZoneHelper : object {
    public static bool IsAmbiguousTime(TimeZoneInfo zone, DateTime ambiguousTime);
    public static TimeSpan GetDaylightOffset(TimeZoneInfo zone, DateTime ambiguousDateTime);
    public static DateTimeOffset GetDaylightTimeStart(TimeZoneInfo zone, DateTime invalidDateTime);
    public static DateTimeOffset GetStandardTimeStart(TimeZoneInfo zone, DateTime ambiguousTime, TimeSpan daylightOffset);
    public static DateTimeOffset GetAmbiguousIntervalEnd(TimeZoneInfo zone, DateTime ambiguousTime);
    public static DateTimeOffset GetDaylightTimeEnd(TimeZoneInfo zone, DateTime ambiguousTime, TimeSpan daylightOffset);
    private static TimeSpan[] GetAmbiguousOffsets(TimeZoneInfo zone, DateTime ambiguousTime);
    private static DateTime GetDstTransitionEndDateTime(TimeZoneInfo zone, DateTime ambiguousDateTime);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
public class Hangfire.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("6592")]
public class Hangfire.Annotations.CanBeNullAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("1036")]
public class Hangfire.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("64")]
public class Hangfire.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2432")]
public class Hangfire.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2432")]
public class Hangfire.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum Hangfire.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum Hangfire.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2048")]
public class Hangfire.Annotations.InstantHandleAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2048")]
public class Hangfire.Annotations.InvokerParameterNameAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class Hangfire.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class Hangfire.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Annotations.NamespaceDoc : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("64")]
public class Hangfire.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("6592")]
public class Hangfire.Annotations.NotNullAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
[MeansImplicitUseAttribute]
public class Hangfire.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [NotNullAttribute]
public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("64")]
public class Hangfire.Annotations.PureAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("96")]
public class Hangfire.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class Hangfire.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Hangfire.AppBuilderExtensions : object {
    private static ConcurrentDictionary`2<IBackgroundProcessingServer, object> Servers;
    private static AppBuilderExtensions();
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, IBackgroundProcess[] additionalProcesses);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, BackgroundJobServerOptions options);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, BackgroundJobServerOptions options, IBackgroundProcess[] additionalProcesses);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, BackgroundJobServerOptions options, JobStorage storage);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, JobStorage storage, BackgroundJobServerOptions options, IBackgroundProcess[] additionalProcesses);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireServer(IAppBuilder builder, IBackgroundProcessingServer server);
    private static void OnAppDisposing(object state);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireDashboard(IAppBuilder builder);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireDashboard(IAppBuilder builder, string pathMatch);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireDashboard(IAppBuilder builder, string pathMatch, DashboardOptions options);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireDashboard(IAppBuilder builder, string pathMatch, DashboardOptions options, JobStorage storage);
    [ExtensionAttribute]
public static IAppBuilder UseHangfireDashboard(IAppBuilder builder, string pathMatch, DashboardOptions options, JobStorage storage, IOwinDashboardAntiforgery antiforgery);
    [ExtensionAttribute]
private static Action`1<Func`2<IDictionary`2<string, object>, Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>>> UseOwin(IAppBuilder builder);
}
public enum Hangfire.AttemptsExceededAction : Enum {
    public int value__;
    public static AttemptsExceededAction Fail;
    public static AttemptsExceededAction Delete;
}
public class Hangfire.AutomaticRetryAttribute : JobFilterAttribute {
    public static int DefaultRetryAttempts;
    private static Func`2<long, int> DefaultDelayInSecondsByAttemptFunc;
    private ILog _logger;
    private object _lockObject;
    private int _attempts;
    private Int32[] _delaysInSeconds;
    private Func`2<long, int> _delayInSecondsByAttemptFunc;
    private AttemptsExceededAction _onAttemptsExceeded;
    private bool _logEvents;
    private Type[] _onlyOn;
    public int Attempts { get; public set; }
    [JsonPropertyAttribute]
public Int32[] DelaysInSeconds { get; public set; }
    [JsonIgnoreAttribute]
public Func`2<long, int> DelayInSecondsByAttemptFunc { get; public set; }
    [JsonPropertyAttribute]
public AttemptsExceededAction OnAttemptsExceeded { get; public set; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("True")]
public bool LogEvents { get; public set; }
    [JsonPropertyAttribute]
public Type[] OnlyOn { get; public set; }
    private static AutomaticRetryAttribute();
    public int get_Attempts();
    public void set_Attempts(int value);
    public Int32[] get_DelaysInSeconds();
    public void set_DelaysInSeconds(Int32[] value);
    public Func`2<long, int> get_DelayInSecondsByAttemptFunc();
    public void set_DelayInSecondsByAttemptFunc(Func`2<long, int> value);
    public AttemptsExceededAction get_OnAttemptsExceeded();
    public void set_OnAttemptsExceeded(AttemptsExceededAction value);
    public bool get_LogEvents();
    public void set_LogEvents(bool value);
    public Type[] get_OnlyOn();
    public void set_OnlyOn(Type[] value);
    public sealed virtual void OnStateElection(ElectStateContext context);
    public sealed virtual void OnStateApplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
    public sealed virtual void OnStateUnapplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
    private void ScheduleAgainLater(ElectStateContext context, int retryAttempt, FailedState failedState);
    private void TransitionToDeleted(ElectStateContext context, FailedState failedState);
}
public class Hangfire.BackgroundJob : object {
    private static Lazy`1<IBackgroundJobClient> CachedClient;
    private static Func`1<IBackgroundJobClient> DefaultFactory;
    private static Func`1<IBackgroundJobClient> _clientFactory;
    private static object ClientFactoryLock;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <ParametersSnapshot>k__BackingField;
    internal static Func`1<IBackgroundJobClient> ClientFactory { get; internal set; }
    [NotNullAttribute]
public string Id { get; }
    [CanBeNullAttribute]
public Job Job { get; }
    public DateTime CreatedAt { get; }
    [CanBeNullAttribute]
public IReadOnlyDictionary`2<string, string> ParametersSnapshot { get; }
    public BackgroundJob(string id, Job job, DateTime createdAt);
    public BackgroundJob(string id, Job job, DateTime createdAt, IReadOnlyDictionary`2<string, string> parametersSnapshot);
    private static BackgroundJob();
    internal static Func`1<IBackgroundJobClient> get_ClientFactory();
    internal static void set_ClientFactory(Func`1<IBackgroundJobClient> value);
    public static string Enqueue(Expression`1<Action> methodCall);
    public static string Enqueue(string queue, Expression`1<Action> methodCall);
    public static string Enqueue(Expression`1<Func`1<Task>> methodCall);
    public static string Enqueue(string queue, Expression`1<Func`1<Task>> methodCall);
    public static string Enqueue(Expression`1<Action`1<T>> methodCall);
    public static string Enqueue(string queue, Expression`1<Action`1<T>> methodCall);
    public static string Enqueue(Expression`1<Func`2<T, Task>> methodCall);
    public static string Enqueue(string queue, Expression`1<Func`2<T, Task>> methodCall);
    public static string Schedule(Expression`1<Action> methodCall, TimeSpan delay);
    public static string Schedule(string queue, Expression`1<Action> methodCall, TimeSpan delay);
    public static string Schedule(Expression`1<Func`1<Task>> methodCall, TimeSpan delay);
    public static string Schedule(string queue, Expression`1<Func`1<Task>> methodCall, TimeSpan delay);
    public static string Schedule(Expression`1<Action> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(string queue, Expression`1<Action> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(Expression`1<Func`1<Task>> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(string queue, Expression`1<Func`1<Task>> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(Expression`1<Action`1<T>> methodCall, TimeSpan delay);
    public static string Schedule(string queue, Expression`1<Action`1<T>> methodCall, TimeSpan delay);
    public static string Schedule(Expression`1<Func`2<T, Task>> methodCall, TimeSpan delay);
    public static string Schedule(string queue, Expression`1<Func`2<T, Task>> methodCall, TimeSpan delay);
    public static string Schedule(Expression`1<Action`1<T>> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(string queue, Expression`1<Action`1<T>> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(Expression`1<Func`2<T, Task>> methodCall, DateTimeOffset enqueueAt);
    public static string Schedule(string queue, Expression`1<Func`2<T, Task>> methodCall, DateTimeOffset enqueueAt);
    public static bool Delete(string jobId);
    public static bool Delete(string jobId, string fromState);
    public static bool Requeue(string jobId);
    public static bool Requeue(string jobId, string fromState);
    public static bool Reschedule(string jobId, TimeSpan delay);
    public static bool Reschedule(string jobId, TimeSpan delay, string fromState);
    public static bool Reschedule(string jobId, DateTimeOffset enqueueAt);
    public static bool Reschedule(string jobId, DateTimeOffset enqueueAt, string fromState);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Action> methodCall);
    public static string ContinueJobWith(string parentId, Expression`1<Action> methodCall);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Action`1<T>> methodCall);
    public static string ContinueJobWith(string parentId, Expression`1<Action`1<T>> methodCall);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Action> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, Expression`1<Action> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, string queue, Expression`1<Action> methodCall, JobContinuationOptions options);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Func`1<Task>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, Expression`1<Func`1<Task>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, string queue, Expression`1<Func`1<Task>> methodCall, JobContinuationOptions options);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Action`1<T>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, Expression`1<Action`1<T>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, string queue, Expression`1<Action`1<T>> methodCall, JobContinuationOptions options);
    [ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(string parentId, Expression`1<Func`2<T, Task>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, Expression`1<Func`2<T, Task>> methodCall, JobContinuationOptions options);
    public static string ContinueJobWith(string parentId, string queue, Expression`1<Func`2<T, Task>> methodCall, JobContinuationOptions options);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_ParametersSnapshot();
}
public class Hangfire.BackgroundJobClient : object {
    private JobStorage _storage;
    private IBackgroundJobFactory _factory;
    private IBackgroundJobStateChanger _stateChanger;
    public JobStorage Storage { get; }
    public int RetryAttempts { get; public set; }
    public BackgroundJobClient(JobStorage storage);
    public BackgroundJobClient(JobStorage storage, IJobFilterProvider filterProvider);
    public BackgroundJobClient(JobStorage storage, IBackgroundJobFactory factory, IBackgroundJobStateChanger stateChanger);
    public sealed virtual JobStorage get_Storage();
    public int get_RetryAttempts();
    public void set_RetryAttempts(int value);
    public sealed virtual string Create(Job job, IState state);
    public sealed virtual string Create(Job job, IState state, IDictionary`2<string, object> parameters);
    public sealed virtual bool ChangeState(string jobId, IState state, string expectedState);
}
public class Hangfire.BackgroundJobClientException : CreateJobFailedException {
    public BackgroundJobClientException(string message, Exception inner);
    protected BackgroundJobClientException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Hangfire.BackgroundJobClientExtensions : object {
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, Expression`1<Action> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, string queue, Expression`1<Action> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, Expression`1<Func`1<Task>> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, string queue, Expression`1<Func`1<Task>> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, Expression`1<Action`1<T>> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, string queue, Expression`1<Action`1<T>> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, Expression`1<Func`2<T, Task>> methodCall);
    [ExtensionAttribute]
public static string Enqueue(IBackgroundJobClient client, string queue, Expression`1<Func`2<T, Task>> methodCall);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Action> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Action> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Func`1<Task>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Func`1<Task>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Action> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Action> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Func`1<Task>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Func`1<Task>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Action`1<T>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Action`1<T>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Func`2<T, Task>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Func`2<T, Task>> methodCall, TimeSpan delay);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Action`1<T>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Action`1<T>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, Expression`1<Func`2<T, Task>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Schedule(IBackgroundJobClient client, string queue, Expression`1<Func`2<T, Task>> methodCall, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, Expression`1<Action> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, string queue, Expression`1<Action> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, Expression`1<Func`1<Task>> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, string queue, Expression`1<Func`1<Task>> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, Expression`1<Action`1<T>> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, string queue, Expression`1<Action`1<T>> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, Expression`1<Func`2<T, Task>> methodCall, IState state);
    [ExtensionAttribute]
public static string Create(IBackgroundJobClient client, string queue, Expression`1<Func`2<T, Task>> methodCall, IState state);
    [ExtensionAttribute]
public static bool ChangeState(IBackgroundJobClient client, string jobId, IState state);
    [ExtensionAttribute]
public static bool Delete(IBackgroundJobClient client, string jobId);
    [ExtensionAttribute]
public static bool Delete(IBackgroundJobClient client, string jobId, string fromState);
    [ExtensionAttribute]
public static bool Requeue(IBackgroundJobClient client, string jobId);
    [ExtensionAttribute]
public static bool Reschedule(IBackgroundJobClient client, string jobId, TimeSpan delay, string fromState);
    [ExtensionAttribute]
public static bool Reschedule(IBackgroundJobClient client, string jobId, TimeSpan delay);
    [ExtensionAttribute]
public static bool Reschedule(IBackgroundJobClient client, string jobId, DateTimeOffset enqueueAt, string fromState);
    [ExtensionAttribute]
public static bool Reschedule(IBackgroundJobClient client, string jobId, DateTimeOffset enqueueAt);
    [ExtensionAttribute]
public static bool Requeue(IBackgroundJobClient client, string jobId, string fromState);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, IState nextState);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, IState nextState);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, IState nextState);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, IState nextState);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, JobContinuationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, JobContinuationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, string queue, Expression`1<Action> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Func`1<Task>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Func`1<Task>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, string queue, Expression`1<Func`1<Task>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Action`1<T>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, string queue, Expression`1<Action`1<T>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Deprecated for clarity, please use ContinueJobWith method with the same arguments. Will be removed in 2.0.0.")]
public static string ContinueWith(IBackgroundJobClient client, string parentId, Expression`1<Func`2<T, Task>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, Expression`1<Func`2<T, Task>> methodCall, IState nextState, JobContinuationOptions options);
    [ExtensionAttribute]
public static string ContinueJobWith(IBackgroundJobClient client, string parentId, string queue, Expression`1<Func`2<T, Task>> methodCall, IState nextState, JobContinuationOptions options);
}
public class Hangfire.BackgroundJobServer : object {
    private ILog _logger;
    private BackgroundJobServerOptions _options;
    private BackgroundProcessingServer _processingServer;
    public BackgroundJobServer(JobStorage storage);
    public BackgroundJobServer(BackgroundJobServerOptions options);
    public BackgroundJobServer(BackgroundJobServerOptions options, JobStorage storage);
    public BackgroundJobServer(BackgroundJobServerOptions options, JobStorage storage, IEnumerable`1<IBackgroundProcess> additionalProcesses);
    [ObsoleteAttribute("Create your own BackgroundJobServer-like type and pass custom services to it. This constructor will be removed in 2.0.0.")]
[EditorBrowsableAttribute("2")]
public BackgroundJobServer(BackgroundJobServerOptions options, JobStorage storage, IEnumerable`1<IBackgroundProcess> additionalProcesses, IJobFilterProvider filterProvider, JobActivator activator, IBackgroundJobFactory factory, IBackgroundJobPerformer performer, IBackgroundJobStateChanger stateChanger);
    public sealed virtual void SendStop();
    public sealed virtual void Dispose();
    [ObsoleteAttribute("This method is a stub. There is no need to call the `Start` method. Will be removed in version 2.0.0.")]
public void Start();
    [ObsoleteAttribute("Please call the `Shutdown` method instead. Will be removed in version 2.0.0.")]
public void Stop();
    [ObsoleteAttribute("Please call the `Shutdown` method instead. Will be removed in version 2.0.0.")]
public void Stop(bool force);
    public sealed virtual bool WaitForShutdown(TimeSpan timeout);
    public sealed virtual Task WaitForShutdownAsync(CancellationToken cancellationToken);
    private IEnumerable`1<IBackgroundProcessDispatcherBuilder> GetRequiredProcesses(IJobFilterProvider filterProvider, JobActivator activator, IBackgroundJobFactory factory, IBackgroundJobPerformer performer, IBackgroundJobStateChanger stateChanger);
    private BackgroundProcessingServerOptions GetProcessingServerOptions();
}
public class Hangfire.BackgroundJobServerOptions : object {
    private static int MaxDefaultWorkerCount;
    private int _workerCount;
    private String[] _queues;
    private TimeSpan _serverTimeout;
    private TimeSpan _serverCheckInterval;
    private TimeSpan _heartbeatInterval;
    private TimeSpan _stopTimeout;
    private TimeSpan _shutdownTimeout;
    private TimeSpan _schedulePollingInterval;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLightweightServer>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CancellationCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerWatchdogOptions <ServerWatchdogOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IJobFilterProvider <FilterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JobActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeZoneResolver <TimeZoneResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <TaskScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Thread> <WorkerThreadConfigurationAction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelismForSchedulers>k__BackingField;
    public string ServerName { get; public set; }
    public bool IsLightweightServer { get; public set; }
    public int WorkerCount { get; public set; }
    public String[] Queues { get; public set; }
    public TimeSpan StopTimeout { get; public set; }
    public TimeSpan ShutdownTimeout { get; public set; }
    public TimeSpan SchedulePollingInterval { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public TimeSpan ServerCheckInterval { get; public set; }
    public TimeSpan ServerTimeout { get; public set; }
    public TimeSpan CancellationCheckInterval { get; public set; }
    [ObsoleteAttribute("Please use `ServerTimeout` or `ServerCheckInterval` options instead. Will be removed in 2.0.0.")]
public ServerWatchdogOptions ServerWatchdogOptions { get; public set; }
    [CanBeNullAttribute]
public IJobFilterProvider FilterProvider { get; public set; }
    [CanBeNullAttribute]
public JobActivator Activator { get; public set; }
    [CanBeNullAttribute]
public ITimeZoneResolver TimeZoneResolver { get; public set; }
    [CanBeNullAttribute]
public TaskScheduler TaskScheduler { get; public set; }
    [CanBeNullAttribute]
public Action`1<Thread> WorkerThreadConfigurationAction { get; public set; }
    public int MaxDegreeOfParallelismForSchedulers { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsLightweightServer();
    [CompilerGeneratedAttribute]
public void set_IsLightweightServer(bool value);
    public int get_WorkerCount();
    public void set_WorkerCount(int value);
    public String[] get_Queues();
    public void set_Queues(String[] value);
    public TimeSpan get_StopTimeout();
    public void set_StopTimeout(TimeSpan value);
    public TimeSpan get_ShutdownTimeout();
    public void set_ShutdownTimeout(TimeSpan value);
    public TimeSpan get_SchedulePollingInterval();
    public void set_SchedulePollingInterval(TimeSpan value);
    public TimeSpan get_HeartbeatInterval();
    public void set_HeartbeatInterval(TimeSpan value);
    public TimeSpan get_ServerCheckInterval();
    public void set_ServerCheckInterval(TimeSpan value);
    public TimeSpan get_ServerTimeout();
    public void set_ServerTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CancellationCheckInterval();
    [CompilerGeneratedAttribute]
public void set_CancellationCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public ServerWatchdogOptions get_ServerWatchdogOptions();
    [CompilerGeneratedAttribute]
public void set_ServerWatchdogOptions(ServerWatchdogOptions value);
    [CompilerGeneratedAttribute]
public IJobFilterProvider get_FilterProvider();
    [CompilerGeneratedAttribute]
public void set_FilterProvider(IJobFilterProvider value);
    [CompilerGeneratedAttribute]
public JobActivator get_Activator();
    [CompilerGeneratedAttribute]
public void set_Activator(JobActivator value);
    [CompilerGeneratedAttribute]
public ITimeZoneResolver get_TimeZoneResolver();
    [CompilerGeneratedAttribute]
public void set_TimeZoneResolver(ITimeZoneResolver value);
    [CompilerGeneratedAttribute]
public TaskScheduler get_TaskScheduler();
    [CompilerGeneratedAttribute]
public void set_TaskScheduler(TaskScheduler value);
    [CompilerGeneratedAttribute]
public Action`1<Thread> get_WorkerThreadConfigurationAction();
    [CompilerGeneratedAttribute]
public void set_WorkerThreadConfigurationAction(Action`1<Thread> value);
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelismForSchedulers();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelismForSchedulers(int value);
}
[ObsoleteAttribute]
internal class Hangfire.BootstrapperConfiguration : object {
    [CompilerGeneratedAttribute]
private string <DashboardPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppPath>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private JobActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`1<BackgroundJobServer>> <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private IAuthorizationFilter[] <AuthorizationFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Filters>k__BackingField;
    public string DashboardPath { get; private set; }
    public string AppPath { get; private set; }
    public JobStorage Storage { get; private set; }
    public JobActivator Activator { get; private set; }
    public List`1<Func`1<BackgroundJobServer>> Servers { get; }
    public IAuthorizationFilter[] AuthorizationFilters { get; private set; }
    public List`1<object> Filters { get; }
    [CompilerGeneratedAttribute]
public string get_DashboardPath();
    [CompilerGeneratedAttribute]
private void set_DashboardPath(string value);
    [CompilerGeneratedAttribute]
public string get_AppPath();
    [CompilerGeneratedAttribute]
private void set_AppPath(string value);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(JobStorage value);
    [CompilerGeneratedAttribute]
public JobActivator get_Activator();
    [CompilerGeneratedAttribute]
private void set_Activator(JobActivator value);
    [CompilerGeneratedAttribute]
public List`1<Func`1<BackgroundJobServer>> get_Servers();
    [CompilerGeneratedAttribute]
public IAuthorizationFilter[] get_AuthorizationFilters();
    [CompilerGeneratedAttribute]
private void set_AuthorizationFilters(IAuthorizationFilter[] value);
    [CompilerGeneratedAttribute]
public List`1<object> get_Filters();
    public sealed virtual void UseAuthorizationFilters(IAuthorizationFilter[] filters);
    public sealed virtual void UseFilter(object filter);
    public sealed virtual void UseDashboardPath(string path);
    public sealed virtual void UseAppPath(string path);
    public sealed virtual void UseStorage(JobStorage storage);
    public sealed virtual void UseActivator(JobActivator activator);
    public sealed virtual void UseServer(Func`1<BackgroundJobServer> server);
}
[ExtensionAttribute]
[ObsoleteAttribute("Please use `AppBuilderExtensions` class instead. Will be removed in version 2.0.0.")]
public static class Hangfire.BootstrapperConfigurationExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, int workerCount);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, String[] queues);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, int workerCount, String[] queues);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, BackgroundJobServerOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, JobStorage storage);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void UseServer(IBootstrapperConfiguration configuration, JobStorage storage, BackgroundJobServerOptions options);
}
public class Hangfire.CaptureCultureAttribute : JobFilterAttribute {
    private ILog _logger;
    [CompilerGeneratedAttribute]
private string <DefaultCultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultUICultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureDefault>k__BackingField;
    [CanBeNullAttribute]
public string DefaultCultureName { get; }
    [CanBeNullAttribute]
public string DefaultUICultureName { get; }
    public bool CaptureDefault { get; }
    public CaptureCultureAttribute(string defaultCultureName, bool captureDefault);
    public CaptureCultureAttribute(string defaultCultureName, string defaultUICultureName, bool captureDefault);
    [CompilerGeneratedAttribute]
public string get_DefaultCultureName();
    [CompilerGeneratedAttribute]
public string get_DefaultUICultureName();
    [CompilerGeneratedAttribute]
public bool get_CaptureDefault();
    public sealed virtual void OnCreating(CreatingContext context);
    public sealed virtual void OnCreated(CreatedContext context);
    public sealed virtual void OnPerforming(PerformingContext context);
    public sealed virtual void OnPerformed(PerformedContext context);
    private static void SetCurrentCulture(CultureInfo value);
    private static void SetCurrentUICulture(CultureInfo value);
}
public class Hangfire.Client.BackgroundJobFactory : object {
    private IJobFilterProvider _filterProvider;
    private IBackgroundJobFactory _innerFactory;
    public int RetryAttempts { get; public set; }
    public IStateMachine StateMachine { get; }
    public BackgroundJobFactory(IJobFilterProvider filterProvider);
    internal BackgroundJobFactory(IJobFilterProvider filterProvider, IBackgroundJobFactory innerFactory);
    public int get_RetryAttempts();
    public void set_RetryAttempts(int value);
    public sealed virtual IStateMachine get_StateMachine();
    public sealed virtual BackgroundJob Create(CreateContext context);
    private JobFilterInfo GetFilters(Job job);
    private CreatedContext CreateWithFilters(CreateContext context, IEnumerable`1<IClientFilter> filters);
    private static CreatedContext InvokeClientFilter(IClientFilter filter, CreatingContext preContext, Func`1<CreatedContext> continuation);
    private static void InvokeOnCreating(KeyValuePair`2<IClientFilter, CreatingContext> x);
    private static void InvokeOnCreated(KeyValuePair`2<IClientFilter, CreatedContext> x);
    private static void InvokeExceptionFilters(ClientExceptionContext context, IEnumerable`1<IClientExceptionFilter> filters);
    private static void InvokeOnClientException(KeyValuePair`2<IClientExceptionFilter, ClientExceptionContext> x);
}
public class Hangfire.Client.ClientExceptionContext : CreateContext {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionHandled>k__BackingField;
    public Exception Exception { get; }
    public bool ExceptionHandled { get; public set; }
    public ClientExceptionContext(CreateContext createContext, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public bool get_ExceptionHandled();
    [CompilerGeneratedAttribute]
public void set_ExceptionHandled(bool value);
}
internal class Hangfire.Client.CoreBackgroundJobFactory : object {
    private ILog _logger;
    private object _syncRoot;
    private int _retryAttempts;
    private Func`2<int, TimeSpan> _retryDelayFunc;
    [CompilerGeneratedAttribute]
private IStateMachine <StateMachine>k__BackingField;
    public IStateMachine StateMachine { get; }
    public int RetryAttempts { get; public set; }
    public Func`2<int, TimeSpan> RetryDelayFunc { get; public set; }
    public CoreBackgroundJobFactory(IStateMachine stateMachine);
    [CompilerGeneratedAttribute]
public sealed virtual IStateMachine get_StateMachine();
    public int get_RetryAttempts();
    public void set_RetryAttempts(int value);
    public Func`2<int, TimeSpan> get_RetryDelayFunc();
    public void set_RetryDelayFunc(Func`2<int, TimeSpan> value);
    public sealed virtual BackgroundJob Create(CreateContext context);
    private BackgroundJob CreateBackgroundJobTwoSteps(CreateContext context, Dictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    private void RetryOnException(Int32& attemptsLeft, Action`1<int> action);
    private T RetryOnException(Int32& attemptsLeft, Func`2<int, T> action);
    private static TimeSpan GetRetryDelay(int retryAttempt);
}
public class Hangfire.Client.CreateContext : object {
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private IState <InitialState>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IBackgroundJobFactory <Factory>k__BackingField;
    [NotNullAttribute]
public JobStorage Storage { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    [NotNullAttribute]
public IDictionary`2<string, object> Items { get; }
    [NotNullAttribute]
public IDictionary`2<string, object> Parameters { get; }
    [NotNullAttribute]
public Job Job { get; }
    [CanBeNullAttribute]
public IState InitialState { get; }
    [NotNullAttribute]
internal IProfiler Profiler { get; }
    [CanBeNullAttribute]
public IBackgroundJobFactory Factory { get; internal set; }
    public CreateContext(CreateContext context);
    public CreateContext(JobStorage storage, IStorageConnection connection, Job job, IState initialState);
    public CreateContext(JobStorage storage, IStorageConnection connection, Job job, IState initialState, IDictionary`2<string, object> parameters);
    internal CreateContext(JobStorage storage, IStorageConnection connection, Job job, IState initialState, IDictionary`2<string, object> parameters, IProfiler profiler);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public IState get_InitialState();
    [CompilerGeneratedAttribute]
internal IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public IBackgroundJobFactory get_Factory();
    [CompilerGeneratedAttribute]
internal void set_Factory(IBackgroundJobFactory value);
}
public class Hangfire.Client.CreatedContext : CreateContext {
    [CompilerGeneratedAttribute]
private BackgroundJob <BackgroundJob>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionHandled>k__BackingField;
    [CanBeNullAttribute]
[ObsoleteAttribute("Please use `BackgroundJob` property instead. Will be removed in 2.0.0.")]
public string JobId { get; }
    [CanBeNullAttribute]
public BackgroundJob BackgroundJob { get; }
    public IDictionary`2<string, object> Parameters { get; }
    [CanBeNullAttribute]
public Exception Exception { get; }
    public bool Canceled { get; }
    public bool ExceptionHandled { get; public set; }
    public CreatedContext(CreateContext context, BackgroundJob backgroundJob, bool canceled, Exception exception);
    public string get_JobId();
    [CompilerGeneratedAttribute]
public BackgroundJob get_BackgroundJob();
    public virtual IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
public bool get_ExceptionHandled();
    [CompilerGeneratedAttribute]
public void set_ExceptionHandled(bool value);
    [ObsoleteAttribute("This method only throws InvalidOperationException, will be removed in 2.0.0.")]
public void SetJobParameter(string name, object value);
}
[ObsoleteAttribute("Please use the `BackgroundJobClientException` instead. Will be removed in 2.0.0.")]
public class Hangfire.Client.CreateJobFailedException : Exception {
    public CreateJobFailedException(string message, Exception inner);
    protected CreateJobFailedException(SerializationInfo info, StreamingContext context);
}
public class Hangfire.Client.CreatingContext : CreateContext {
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    public bool Canceled { get; public set; }
    public CreatingContext(CreateContext context);
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
public void set_Canceled(bool value);
    public void SetJobParameter(string name, object value);
    public T GetJobParameter(string name);
}
public interface Hangfire.Client.IBackgroundJobFactory {
    [NotNullAttribute]
public IStateMachine StateMachine { get; }
    public abstract virtual IStateMachine get_StateMachine();
    [CanBeNullAttribute]
public abstract virtual BackgroundJob Create(CreateContext context);
}
public interface Hangfire.Client.IClientExceptionFilter {
    public abstract virtual void OnClientException(ClientExceptionContext filterContext);
}
public interface Hangfire.Client.IClientFilter {
    public abstract virtual void OnCreating(CreatingContext context);
    public abstract virtual void OnCreated(CreatedContext context);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Client.NamespaceDoc : object {
}
[ExcludeFromCodeCoverageAttribute]
internal static class Hangfire.Common.CachedExpressionCompiler : object {
    private static ParameterExpression UnusedParameterExpr;
    private static CachedExpressionCompiler();
    public static object Evaluate(Expression arg);
    private static Func`2<object, object> Wrap(Expression arg);
}
[ExtensionAttribute]
public static class Hangfire.Common.CancellationTokenExtentions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("CancellationToken.WaitHandle is now preferred, since early days of .NET Core passed. Will be removed in 2.0.0.")]
public static CancellationEvent GetCancellationEvent(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WaitOrThrow(CancellationToken cancellationToken, TimeSpan timeout);
    [ExtensionAttribute]
public static bool Wait(CancellationToken cancellationToken, TimeSpan timeout);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.BinaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public BinaryExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal static class Hangfire.Common.ExpressionUtil.CachedExpressionCompiler : object {
    public static Func`2<TModel, TValue> Process(Expression`1<Func`2<TModel, TValue>> lambdaExpression);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.ConditionalExpressionFingerprint : ExpressionFingerprint {
    public ConditionalExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.ConstantExpressionFingerprint : ExpressionFingerprint {
    public ConstantExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.DefaultExpressionFingerprint : ExpressionFingerprint {
    public DefaultExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
}
[ExcludeFromCodeCoverageAttribute]
internal abstract class Hangfire.Common.ExpressionUtil.ExpressionFingerprint : object {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    protected ExpressionFingerprint(ExpressionType nodeType, Type type);
    [CompilerGeneratedAttribute]
public ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Type get_Type();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
    protected bool Equals(ExpressionFingerprint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.ExpressionFingerprintChain : object {
    public List`1<ExpressionFingerprint> Elements;
    public sealed virtual bool Equals(ExpressionFingerprintChain other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.FingerprintingExpressionVisitor : ExpressionVisitor {
    private List`1<object> _seenConstants;
    private List`1<ParameterExpression> _seenParameters;
    private ExpressionFingerprintChain _currentChain;
    private bool _gaveUp;
    private T GiveUp(T node);
    public static ExpressionFingerprintChain GetFingerprintChain(Expression expr, List`1& capturedConstants);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected virtual Expression VisitDefault(DefaultExpression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitIndex(IndexExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitLabel(LabelExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitListInit(ListInitExpression node);
    protected virtual Expression VisitLoop(LoopExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected virtual Expression VisitTry(TryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.HashCodeCombiner : object {
    private long _combinedHash64;
    public int CombinedHash { get; }
    public int get_CombinedHash();
    public void AddFingerprint(ExpressionFingerprint fingerprint);
    public void AddEnumerable(IEnumerable e);
    public void AddInt32(int i);
    public void AddObject(object o);
}
internal class Hangfire.Common.ExpressionUtil.Hoisted`2 : MulticastDelegate {
    public Hoisted`2(object object, IntPtr method);
    public virtual TValue Invoke(TModel model, List`1<object> capturedConstants);
    public virtual IAsyncResult BeginInvoke(TModel model, List`1<object> capturedConstants, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.HoistingExpressionVisitor`2 : ExpressionVisitor {
    private static ParameterExpression _hoistedConstantsParamExpr;
    private int _numConstantsProcessed;
    private static HoistingExpressionVisitor`2();
    public static Expression`1<Hoisted`2<TIn, TOut>> Hoist(Expression`1<Func`2<TIn, TOut>> expr);
    protected virtual Expression VisitConstant(ConstantExpression node);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.IndexExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public PropertyInfo Indexer { get; }
    public IndexExpressionFingerprint(ExpressionType nodeType, Type type, PropertyInfo indexer);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Indexer();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.LambdaExpressionFingerprint : ExpressionFingerprint {
    public LambdaExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.MemberExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public MemberInfo Member { get; }
    public MemberExpressionFingerprint(ExpressionType nodeType, Type type, MemberInfo member);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.MethodCallExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public MethodCallExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.ParameterExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private int <ParameterIndex>k__BackingField;
    public int ParameterIndex { get; }
    public ParameterExpressionFingerprint(ExpressionType nodeType, Type type, int parameterIndex);
    [CompilerGeneratedAttribute]
public int get_ParameterIndex();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.TypeBinaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private Type <TypeOperand>k__BackingField;
    public Type TypeOperand { get; }
    public TypeBinaryExpressionFingerprint(ExpressionType nodeType, Type type, Type typeOperand);
    [CompilerGeneratedAttribute]
public Type get_TypeOperand();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExcludeFromCodeCoverageAttribute]
internal class Hangfire.Common.ExpressionUtil.UnaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public UnaryExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public virtual bool Equals(object obj);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
public interface Hangfire.Common.IJobFilter {
    public bool AllowMultiple { get; }
    public int Order { get; }
    public abstract virtual bool get_AllowMultiple();
    public abstract virtual int get_Order();
}
public interface Hangfire.Common.IJobFilterProvider {
    public abstract virtual IEnumerable`1<JobFilter> GetFilters(Job job);
}
public class Hangfire.Common.Job : object {
    private static Object[] EmptyObjectArray;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<object> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    [NotNullAttribute]
public Type Type { get; }
    [NotNullAttribute]
public MethodInfo Method { get; }
    [NotNullAttribute]
public IReadOnlyList`1<object> Args { get; }
    [CanBeNullAttribute]
public string Queue { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Please use `Args` property instead to avoid unnecessary serializations/deserializations. Will be deleted in 2.0.0.")]
public String[] Arguments { get; }
    public Job(MethodInfo method);
    public Job(MethodInfo method, Object[] args);
    public Job(Type type, MethodInfo method);
    public Job(Type type, MethodInfo method, Object[] args);
    public Job(Type type, MethodInfo method, IReadOnlyList`1<object> args, string queue);
    [ObsoleteAttribute("Please use Job(Type, MethodInfo, object[]) ctor overload instead. Will be removed in 2.0.0.")]
public Job(Type type, MethodInfo method, String[] arguments);
    private static Job();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<object> get_Args();
    [CompilerGeneratedAttribute]
public string get_Queue();
    public virtual string ToString();
    public string ToString(bool includeQueue);
    internal IEnumerable`1<JobFilterAttribute> GetTypeFilterAttributes(bool useCache);
    internal IEnumerable`1<JobFilterAttribute> GetMethodFilterAttributes(bool useCache);
    private static IEnumerable`1<JobFilterAttribute> GetFilterAttributes(MemberInfo memberInfo);
    public static Job FromExpression(Expression`1<Action> methodCall);
    public static Job FromExpression(Expression`1<Action> methodCall, string queue);
    public static Job FromExpression(Expression`1<Func`1<Task>> methodCall);
    public static Job FromExpression(Expression`1<Func`1<Task>> methodCall, string queue);
    public static Job FromExpression(Expression`1<Action`1<TType>> methodCall);
    public static Job FromExpression(Expression`1<Action`1<TType>> methodCall, string queue);
    public static Job FromExpression(Expression`1<Func`2<TType, Task>> methodCall);
    public static Job FromExpression(Expression`1<Func`2<TType, Task>> methodCall, string queue);
    private static Job FromExpression(LambdaExpression methodCall, Type explicitType, string queue);
    private static void Validate(Type type, string typeParameterName, MethodInfo method, string methodParameterName, int argumentCount, string argumentParameterName);
    private static Object[] GetExpressionValues(IEnumerable`1<Expression> expressions);
    private static object GetExpressionValue(Expression expression);
    public String[] get_Arguments();
    [ObsoleteAttribute("This method is deprecated. Please use `CoreBackgroundJobPerformer` or `BackgroundJobPerformer` classes instead. Will be removed in 2.0.0.")]
public object Perform(JobActivator activator, IJobCancellationToken cancellationToken);
    [ObsoleteAttribute("Will be removed in 2.0.0")]
private object Activate(JobActivator activator);
    [ObsoleteAttribute("Will be removed in 2.0.0")]
private Object[] GetArguments(IJobCancellationToken cancellationToken);
    [ObsoleteAttribute("Will be removed in 2.0.0")]
private object InvokeMethod(object instance, Object[] deserializedArguments, IJobCancellationToken cancellationToken);
    [ObsoleteAttribute("Will be removed in 2.0.0")]
private static void Dispose(object instance);
}
public class Hangfire.Common.JobFilter : object {
    public static int DefaultOrder;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private JobFilterScope <Scope>k__BackingField;
    public object Instance { get; protected set; }
    public int Order { get; protected set; }
    public JobFilterScope Scope { get; protected set; }
    public JobFilter(object instance, JobFilterScope scope, Nullable`1<int> order);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
protected void set_Instance(object value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
protected void set_Order(int value);
    [CompilerGeneratedAttribute]
public JobFilterScope get_Scope();
    [CompilerGeneratedAttribute]
protected void set_Scope(JobFilterScope value);
}
[AttributeUsageAttribute("1092")]
public abstract class Hangfire.Common.JobFilterAttribute : Attribute {
    private static ConcurrentDictionary`2<Type, bool> MultiuseAttributeCache;
    private int _order;
    [JsonIgnoreAttribute]
public bool AllowMultiple { get; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("-1")]
public int Order { get; public set; }
    [JsonIgnoreAttribute]
public object TypeId { get; }
    private static JobFilterAttribute();
    public sealed virtual bool get_AllowMultiple();
    public sealed virtual int get_Order();
    public void set_Order(int value);
    public virtual object get_TypeId();
    private static bool AllowsMultiple(Type attributeType);
}
public class Hangfire.Common.JobFilterAttributeFilterProvider : object {
    private bool _cacheAttributeInstances;
    public JobFilterAttributeFilterProvider(bool cacheAttributeInstances);
    protected virtual IEnumerable`1<JobFilterAttribute> GetTypeAttributes(Job job);
    protected virtual IEnumerable`1<JobFilterAttribute> GetMethodAttributes(Job job);
    public virtual IEnumerable`1<JobFilter> GetFilters(Job job);
}
public class Hangfire.Common.JobFilterCollection : object {
    private List`1<JobFilter> _filters;
    public int Count { get; }
    public int get_Count();
    public void Add(object filter);
    public void Add(object filter, int order);
    private void AddInternal(object filter, Nullable`1<int> order);
    public void Clear();
    public bool Contains(object filter);
    public void Remove(object filter);
    public void Remove();
    public void Remove(Type type);
    public sealed virtual IEnumerator`1<JobFilter> GetEnumerator();
    private sealed virtual override IEnumerable`1<JobFilter> Hangfire.Common.IJobFilterProvider.GetFilters(Job job);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void ValidateFilterInstance(object instance);
}
internal class Hangfire.Common.JobFilterInfo : object {
    private IEnumerable`1<JobFilter> _filters;
    public IEnumerable`1<IClientFilter> ClientFilters { get; }
    public IEnumerable`1<IServerFilter> ServerFilters { get; }
    public IEnumerable`1<IElectStateFilter> ElectStateFilters { get; }
    public IEnumerable`1<IApplyStateFilter> ApplyStateFilters { get; }
    public IEnumerable`1<IClientExceptionFilter> ClientExceptionFilters { get; }
    public IEnumerable`1<IServerExceptionFilter> ServerExceptionFilters { get; }
    public JobFilterInfo(IEnumerable`1<JobFilter> filters);
    public IEnumerable`1<IClientFilter> get_ClientFilters();
    public IEnumerable`1<IServerFilter> get_ServerFilters();
    public IEnumerable`1<IElectStateFilter> get_ElectStateFilters();
    public IEnumerable`1<IApplyStateFilter> get_ApplyStateFilters();
    public IEnumerable`1<IClientExceptionFilter> get_ClientExceptionFilters();
    public IEnumerable`1<IServerExceptionFilter> get_ServerExceptionFilters();
    [IteratorStateMachineAttribute("Hangfire.Common.JobFilterInfo/<GetFilters>d__14`1")]
private IEnumerable`1<T> GetFilters();
}
public class Hangfire.Common.JobFilterProviderCollection : Collection`1<IJobFilterProvider> {
    public JobFilterProviderCollection(IJobFilterProvider[] providers);
    public sealed virtual IEnumerable`1<JobFilter> GetFilters(Job job);
    private static void RemoveDuplicates(List`1<JobFilter> filters);
    private static bool AllowMultiple(object filterInstance);
    private static int Comparison(JobFilter x, JobFilter y);
}
public static class Hangfire.Common.JobFilterProviders : object {
    [CompilerGeneratedAttribute]
private static JobFilterProviderCollection <Providers>k__BackingField;
    public static JobFilterProviderCollection Providers { get; }
    private static JobFilterProviders();
    [CompilerGeneratedAttribute]
public static JobFilterProviderCollection get_Providers();
}
public enum Hangfire.Common.JobFilterScope : Enum {
    public int value__;
    public static JobFilterScope Global;
    public static JobFilterScope Type;
    public static JobFilterScope Method;
}
public static class Hangfire.Common.JobHelper : object {
    private static DateTime Epoch;
    private static DateTime MillisecondTimestampBoundaryDate;
    private static long MillisecondTimestampBoundary;
    private static JobHelper();
    [ObsoleteAttribute("Please use `GlobalConfiguration.UseSerializerSettings` instead. Will be removed in 2.0.0")]
public static void SetSerializerSettings(JsonSerializerSettings setting);
    [ObsoleteAttribute("Please use `SerializationHelper.Serialize` with appropriate serialization option instead. Will be removed in 2.0.0")]
public static string ToJson(object value);
    [ObsoleteAttribute("Please use `SerializationHelper.Deserialize` with appropriate serialization option instead. Will be removed in 2.0.0")]
public static T FromJson(string value);
    [ObsoleteAttribute("Please use `SerializationHelper.Deserialize` with appropriate serialization option instead. Will be removed in 2.0.0")]
public static object FromJson(string value, Type type);
    public static long ToTimestamp(DateTime value);
    public static DateTime FromTimestamp(long value);
    public static long ToMillisecondTimestamp(DateTime value);
    public static DateTime FromMillisecondTimestamp(long value);
    public static string SerializeDateTime(DateTime value);
    public static DateTime DeserializeDateTime(string value);
    public static Nullable`1<DateTime> DeserializeNullableDateTime(string value);
}
public class Hangfire.Common.JobLoadException : Exception {
    public JobLoadException(string message, Exception inner);
    protected JobLoadException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class Hangfire.Common.MethodInfoExtensions : object {
    [ExtensionAttribute]
public static string GetNormalizedName(MethodInfo methodInfo);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Common.NamespaceDoc : object {
}
internal static class Hangfire.Common.ReflectedAttributeCache : object {
    private static ConcurrentDictionary`2<TypeInfo, ReadOnlyCollection`1<JobFilterAttribute>> TypeFilterAttributeCache;
    private static ConcurrentDictionary`2<MethodInfo, ReadOnlyCollection`1<JobFilterAttribute>> MethodFilterAttributeCache;
    private static ReflectedAttributeCache();
    public static ICollection`1<JobFilterAttribute> GetTypeFilterAttributes(Type type);
    public static ICollection`1<JobFilterAttribute> GetMethodFilterAttributes(MethodInfo methodInfo);
    private static ReadOnlyCollection`1<TAttribute> GetAttributes(ConcurrentDictionary`2<TMemberInfo, ReadOnlyCollection`1<TAttribute>> lookup, TMemberInfo memberInfo);
}
public static class Hangfire.Common.SerializationHelper : object {
    private static Lazy`1<JsonSerializerSettings> InternalSerializerSettings;
    private static JsonSerializerSettings _userSerializerSettings;
    private static SerializationHelper();
    public static string Serialize(T value);
    public static string Serialize(T value, SerializationOption option);
    public static string Serialize(object value, Type type, SerializationOption option);
    public static object Deserialize(string value, Type type);
    public static object Deserialize(string value, Type type, SerializationOption option);
    public static T Deserialize(string value);
    public static T Deserialize(string value, SerializationOption option);
    internal static JsonSerializerSettings GetInternalSettings();
    internal static void SetUserSerializerSettings(JsonSerializerSettings settings);
    private static JsonSerializerSettings GetLegacyTypedSerializerSettings();
    private static void SetSimpleTypeNameAssemblyFormat(JsonSerializerSettings serializerSettings);
    private static JsonSerializerSettings GetSerializerSettings(SerializationOption serializationOption);
    private static JsonSerializerSettings GetUserSerializerSettings();
}
public enum Hangfire.Common.SerializationOption : Enum {
    public int value__;
    public static SerializationOption Internal;
    public static SerializationOption TypedInternal;
    public static SerializationOption User;
}
[ExtensionAttribute]
internal static class Hangfire.Common.ShallowExceptionHelper : object {
    private static object DataKey;
    private static ShallowExceptionHelper();
    [ExtensionAttribute]
public static void PreserveOriginalStackTrace(Exception exception);
    [ExtensionAttribute]
public static string ToStringWithOriginalStackTrace(Exception exception, Nullable`1<int> numLines);
    private static string ToStringHelper(Exception exception, bool isInner);
    private static string GetFirstLines(string text, Nullable`1<int> numLines);
}
[ExtensionAttribute]
internal static class Hangfire.Common.TypeExtensions : object {
    private static Regex GenericArgumentsRegex;
    private static TypeExtensions();
    [ExtensionAttribute]
public static string ToGenericTypeString(Type type);
    [ExtensionAttribute]
public static MethodInfo GetNonOpenMatchingMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static Type[] GetAllGenericArguments(TypeInfo type);
    private static bool TypesMatchRecursive(TypeInfo parameterType, TypeInfo actualType, IList`1<Type> genericArguments);
    [ExtensionAttribute]
private static string GetFullNameWithoutNamespace(Type type);
    [ExtensionAttribute]
private static string ReplacePlusWithDotInNestedTypeName(string typeName);
    [ExtensionAttribute]
private static string ReplaceGenericParametersInGenericTypeName(string typeName, Type type);
}
public class Hangfire.Common.TypeHelper : object {
    private static ConcurrentDictionary`2<Type, string> DefaultTypeSerializerCache;
    private static ConcurrentDictionary`2<Type, string> SimpleAssemblyTypeSerializerCache;
    private static ConcurrentDictionary`2<string, Type> DefaultTypeResolverCache;
    private static ConcurrentDictionary`2<string, Type> IgnoredAssemblyVersionTypeResolverCache;
    private static Assembly CoreLibrary;
    private static AssemblyName MscorlibAssemblyName;
    private static ConcurrentDictionary`2<string, Assembly> AssemblyCache;
    private static Regex VersionRegex;
    private static Regex CultureRegex;
    private static Regex PublicKeyTokenRegex;
    private static Func`2<string, Type> _currentTypeResolver;
    private static Func`2<Type, string> _currentTypeSerializer;
    public static Func`2<string, Type> CurrentTypeResolver { get; public set; }
    public static Func`2<Type, string> CurrentTypeSerializer { get; public set; }
    private static TypeHelper();
    public static Func`2<string, Type> get_CurrentTypeResolver();
    public static void set_CurrentTypeResolver(Func`2<string, Type> value);
    public static Func`2<Type, string> get_CurrentTypeSerializer();
    public static void set_CurrentTypeSerializer(Func`2<Type, string> value);
    public static string DefaultTypeSerializer(Type type);
    public static string SimpleAssemblyTypeSerializer(Type type);
    public static Type DefaultTypeResolver(string typeName);
    public static Type IgnoredAssemblyVersionTypeResolver(string typeName);
    private static void SerializeType(Type type, bool withAssemblyName, StringBuilder typeNameBuilder);
    private static void SerializeTypes(Type[] types, StringBuilder typeNamesBuilder);
    private static Assembly CachedAssemblyResolver(AssemblyName assemblyName);
    private static Assembly AssemblyResolver(string assemblyString);
    private static Type TypeResolver(Assembly assembly, string typeName, bool ignoreCase);
}
public class Hangfire.Common.TypeHelperSerializationBinder : SerializationBinder {
    public virtual Type BindToType(string assemblyName, string typeName);
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    private static int GetAssemblyNameDelimiterIndex(string typeName);
}
public enum Hangfire.CompatibilityLevel : Enum {
    public int value__;
    public static CompatibilityLevel Version_110;
    public static CompatibilityLevel Version_170;
    public static CompatibilityLevel Version_180;
}
[ExtensionAttribute]
public static class Hangfire.CompatibilityLevelExtensions : object {
    [ExtensionAttribute]
public static IGlobalConfiguration SetDataCompatibilityLevel(IGlobalConfiguration configuration, CompatibilityLevel compatibilityLevel);
}
public class Hangfire.ContinuationsSupportAttribute : JobFilterAttribute {
    internal static HashSet`1<string> KnownFinalStates;
    private static TimeSpan AddJobLockTimeout;
    private static TimeSpan ContinuationStateFetchTimeout;
    private static TimeSpan ContinuationInvalidTimeout;
    private ILog _logger;
    private bool _pushResults;
    private HashSet`1<string> _knownFinalStates;
    private IBackgroundJobStateChanger _stateChanger;
    public ContinuationsSupportAttribute(bool pushResults);
    public ContinuationsSupportAttribute(HashSet`1<string> knownFinalStates);
    public ContinuationsSupportAttribute(bool pushResults, HashSet`1<string> knownFinalStates);
    public ContinuationsSupportAttribute(HashSet`1<string> knownFinalStates, IBackgroundJobStateChanger stateChanger);
    public ContinuationsSupportAttribute(bool pushResults, HashSet`1<string> knownFinalStates, IBackgroundJobStateChanger stateChanger);
    private static ContinuationsSupportAttribute();
    public sealed virtual void OnStateElection(ElectStateContext context);
    public sealed virtual void OnStateApplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
    internal static List`1<Continuation> DeserializeContinuations(string serialized);
    private void AddContinuation(ElectStateContext context, AwaitingState awaitingState);
    private void ExecuteContinuationsIfExist(ElectStateContext context);
    private StateData GetContinuationState(ElectStateContext context, string continuationJobId, TimeSpan timeout);
    private bool ShouldStartContinuation(string antecedentStateName, JobContinuationOptions options);
    private static void SetContinuations(IStorageConnection connection, string jobId, List`1<Continuation> continuations);
    private static List`1<Continuation> GetContinuations(ElectStateContext context, string jobId);
    private sealed virtual override void Hangfire.States.IApplyStateFilter.OnStateUnapplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
}
public static class Hangfire.Cron : object {
    public static string Minutely();
    public static string Hourly();
    public static string Hourly(int minute);
    public static string Daily();
    public static string Daily(int hour);
    public static string Daily(int hour, int minute);
    public static string Weekly();
    public static string Weekly(DayOfWeek dayOfWeek);
    public static string Weekly(DayOfWeek dayOfWeek, int hour);
    public static string Weekly(DayOfWeek dayOfWeek, int hour, int minute);
    public static string Monthly();
    public static string Monthly(int day);
    public static string Monthly(int day, int hour);
    public static string Monthly(int day, int hour, int minute);
    public static string Yearly();
    public static string Yearly(int month);
    public static string Yearly(int month, int day);
    public static string Yearly(int month, int day, int hour);
    public static string Yearly(int month, int day, int hour, int minute);
    public static string Never();
    [ObsoleteAttribute("Please use Cron expressions instead. Will be removed in 2.0.0")]
public static string MinuteInterval(int interval);
    [ObsoleteAttribute("Please use Cron expressions instead. Will be removed in 2.0.0")]
public static string HourInterval(int interval);
    [ObsoleteAttribute("Please use Cron expressions instead. Will be removed in 2.0.0")]
public static string DayInterval(int interval);
    [ObsoleteAttribute("Please use Cron expressions instead. Will be removed in 2.0.0")]
public static string MonthInterval(int interval);
    [ObsoleteAttribute("Please install `CronExpressionDescriptor` package manually and use it.")]
public static string GetDescription(string cronExpression);
}
internal class Hangfire.Dashboard.BatchCommandDispatcher : object {
    private Action`2<DashboardContext, string> _command;
    public BatchCommandDispatcher(Action`2<DashboardContext, string> command);
    [ObsoleteAttribute("Use the `BatchCommandDispatcher(Action<DashboardContext>, string)` instead. Will be removed in 2.0.0.")]
public BatchCommandDispatcher(Action`2<RequestDispatcherContext, string> command);
    [AsyncStateMachineAttribute("Hangfire.Dashboard.BatchCommandDispatcher/<Dispatch>d__3")]
public sealed virtual Task Dispatch(DashboardContext context);
}
internal class Hangfire.Dashboard.CombinedResourceDispatcher : EmbeddedResourceDispatcher {
    private IEnumerable`1<Tuple`2<Assembly, string>> _resources;
    public CombinedResourceDispatcher(string contentType, IEnumerable`1<Tuple`2<Assembly, string>> resources);
    [AsyncStateMachineAttribute("Hangfire.Dashboard.CombinedResourceDispatcher/<WriteResponse>d__2")]
protected virtual Task WriteResponse(DashboardResponse response);
}
internal class Hangfire.Dashboard.CommandDispatcher : object {
    private Func`2<DashboardContext, bool> _command;
    public CommandDispatcher(Func`2<DashboardContext, bool> command);
    [ObsoleteAttribute("Use the `CommandDispatcher(Func<DashboardContext, bool>)` ctor instead. Will be removed in 2.0.0.")]
public CommandDispatcher(Func`2<RequestDispatcherContext, bool> command);
    public sealed virtual Task Dispatch(DashboardContext context);
}
public abstract class Hangfire.Dashboard.DashboardContext : object {
    private Lazy`1<bool> _isReadOnlyLazy;
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Match <UriMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AntiforgeryHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AntiforgeryToken>k__BackingField;
    public JobStorage Storage { get; }
    public DashboardOptions Options { get; }
    public Match UriMatch { get; public set; }
    public DashboardRequest Request { get; protected set; }
    public DashboardResponse Response { get; protected set; }
    public bool IsReadOnly { get; }
    public string AntiforgeryHeader { get; public set; }
    public string AntiforgeryToken { get; public set; }
    protected DashboardContext(JobStorage storage, DashboardOptions options);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public DashboardOptions get_Options();
    [CompilerGeneratedAttribute]
public Match get_UriMatch();
    [CompilerGeneratedAttribute]
public void set_UriMatch(Match value);
    [CompilerGeneratedAttribute]
public DashboardRequest get_Request();
    [CompilerGeneratedAttribute]
protected void set_Request(DashboardRequest value);
    [CompilerGeneratedAttribute]
public DashboardResponse get_Response();
    [CompilerGeneratedAttribute]
protected void set_Response(DashboardResponse value);
    public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public string get_AntiforgeryHeader();
    [CompilerGeneratedAttribute]
public void set_AntiforgeryHeader(string value);
    [CompilerGeneratedAttribute]
public string get_AntiforgeryToken();
    [CompilerGeneratedAttribute]
public void set_AntiforgeryToken(string value);
    public virtual IBackgroundJobClient GetBackgroundJobClient();
    public virtual IRecurringJobManager GetRecurringJobManager();
}
public class Hangfire.Dashboard.DashboardMetric : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<RazorPage, Metric> <Func>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Name { get; }
    public Func`2<RazorPage, Metric> Func { get; }
    public string Title { get; public set; }
    public string Url { get; public set; }
    public DashboardMetric(string name, Func`2<RazorPage, Metric> func);
    public DashboardMetric(string name, string title, Func`2<RazorPage, Metric> func);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<RazorPage, Metric> get_Func();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
public static class Hangfire.Dashboard.DashboardMetrics : object {
    private static Dictionary`2<string, DashboardMetric> Metrics;
    public static DashboardMetric ServerCount;
    public static DashboardMetric RecurringJobCount;
    public static DashboardMetric RetriesCount;
    public static DashboardMetric EnqueuedCountOrNull;
    public static DashboardMetric FailedCountOrNull;
    public static DashboardMetric EnqueuedAndQueueCount;
    public static DashboardMetric ScheduledCount;
    public static DashboardMetric ProcessingCount;
    public static DashboardMetric SucceededCount;
    public static DashboardMetric FailedCount;
    public static DashboardMetric DeletedCount;
    public static DashboardMetric AwaitingCount;
    private static DashboardMetrics();
    public static void AddMetric(DashboardMetric metric);
    public static IEnumerable`1<DashboardMetric> GetMetrics();
}
internal class Hangfire.Dashboard.DashboardMiddleware : OwinMiddleware {
    private string _appPath;
    private int _statsPollingInterval;
    private JobStorage _storage;
    private RouteCollection _routes;
    private IEnumerable`1<IAuthorizationFilter> _authorizationFilters;
    public DashboardMiddleware(OwinMiddleware next, string appPath, int statsPollingInterval, JobStorage storage, RouteCollection routes, IEnumerable`1<IAuthorizationFilter> authorizationFilters);
    public virtual Task Invoke(IOwinContext owinContext);
}
[ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static class Hangfire.Dashboard.DashboardOwinExtensions : object {
    internal static IAuthorizationFilter[] DefaultAuthorizationFilters;
    internal static string DefaultDashboardPath;
    internal static string DefaultAppPath;
    private static DashboardOwinExtensions();
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void MapHangfireDashboard(IAppBuilder app);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void MapHangfireDashboard(IAppBuilder app, string dashboardPath);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void MapHangfireDashboard(IAppBuilder app, string dashboardPath, string appPath);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void MapHangfireDashboard(IAppBuilder app, string dashboardPath, string appPath, IEnumerable`1<IAuthorizationFilter> authorizationFilters);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void MapHangfireDashboard(IAppBuilder app, string dashboardPath, string appPath, IEnumerable`1<IAuthorizationFilter> authorizationFilters, JobStorage storage);
}
public abstract class Hangfire.Dashboard.DashboardRequest : object {
    public string Method { get; }
    public string Path { get; }
    public string PathBase { get; }
    public string LocalIpAddress { get; }
    public string RemoteIpAddress { get; }
    public abstract virtual string get_Method();
    public abstract virtual string get_Path();
    public abstract virtual string get_PathBase();
    public abstract virtual string get_LocalIpAddress();
    public abstract virtual string get_RemoteIpAddress();
    public abstract virtual string GetQuery(string key);
    public abstract virtual Task`1<IList`1<string>> GetFormValuesAsync(string key);
}
public abstract class Hangfire.Dashboard.DashboardResponse : object {
    public string ContentType { get; public set; }
    public int StatusCode { get; public set; }
    public Stream Body { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual int get_StatusCode();
    public abstract virtual void set_StatusCode(int value);
    public abstract virtual Stream get_Body();
    public abstract virtual void SetExpire(Nullable`1<DateTimeOffset> value);
    public abstract virtual Task WriteAsync(string text);
}
public static class Hangfire.Dashboard.DashboardRoutes : object {
    private static List`1<Tuple`2<Assembly, string>> JavaScripts;
    private static List`1<Tuple`2<Assembly, string>> Stylesheets;
    private static List`1<Tuple`2<Assembly, string>> StylesheetsDarkMode;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) JavaScriptsHashCode;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) StylesheetsHashCode;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) StylesheetsDarkModeHashCode;
    [CompilerGeneratedAttribute]
private static RouteCollection <Routes>k__BackingField;
    public static RouteCollection Routes { get; }
    private static DashboardRoutes();
    [CompilerGeneratedAttribute]
public static RouteCollection get_Routes();
    public static void AddStylesheet(Assembly assembly, string resource);
    public static void AddStylesheetDarkMode(Assembly assembly, string resource);
    public static void AddJavaScript(Assembly assembly, string resource);
    internal static string GetContentFolderNamespace(string contentFolder);
    internal static string GetContentResourceName(string contentFolder, string resourceName);
    private static DeletedState CreateDeletedState();
    private static EnqueuedState CreateEnqueuedState();
}
internal class Hangfire.Dashboard.EmbeddedResourceDispatcher : object {
    private Assembly _assembly;
    private string _resourceName;
    private string _contentType;
    public EmbeddedResourceDispatcher(string contentType, Assembly assembly, string resourceName);
    [AsyncStateMachineAttribute("Hangfire.Dashboard.EmbeddedResourceDispatcher/<Dispatch>d__4")]
public sealed virtual Task Dispatch(DashboardContext context);
    protected virtual Task WriteResponse(DashboardResponse response);
    [AsyncStateMachineAttribute("Hangfire.Dashboard.EmbeddedResourceDispatcher/<WriteResource>d__6")]
protected Task WriteResource(DashboardResponse response, Assembly assembly, string resourceName);
}
public class Hangfire.Dashboard.HtmlHelper : object {
    private static Type DisplayNameType;
    private static Func`2<object, string> GetDisplayName;
    private RazorPage _page;
    private static StackTraceHtmlFragments StackTraceHtmlFragments;
    public RazorPage Page { get; }
    private static HtmlHelper();
    public HtmlHelper(RazorPage page);
    public RazorPage get_Page();
    public NonEscapedString Breadcrumbs(string title, IDictionary`2<string, string> items);
    public NonEscapedString JobsSidebar();
    public NonEscapedString SidebarMenu(IEnumerable`1<Func`2<RazorPage, MenuItem>> items);
    public NonEscapedString BlockMetric(DashboardMetric metric);
    public NonEscapedString InlineMetric(DashboardMetric metric);
    public NonEscapedString Paginator(Pager pager);
    public NonEscapedString PerPageSelector(Pager pager);
    public NonEscapedString RenderPartial(RazorPage partialPage);
    public NonEscapedString Raw(string value);
    public NonEscapedString JobId(string jobId, bool shorten);
    public string JobName(Job job);
    public string JobName(Job job, bool includeQueue);
    public NonEscapedString StateLabel(string stateName);
    public NonEscapedString StateLabel(string stateName, string text, bool hover);
    public NonEscapedString JobIdLink(string jobId);
    public NonEscapedString JobNameLink(string jobId, Job job);
    public NonEscapedString JobNameLink(string jobId, Job job, bool includeQueue);
    public NonEscapedString RelativeTime(DateTime value);
    public NonEscapedString MomentTitle(DateTime time, string value);
    public NonEscapedString LocalTime(DateTime value);
    public string ToHumanDuration(Nullable`1<TimeSpan> duration, bool displaySign);
    [ObsoleteAttribute("This method is unused and will be removed in 2.0.0.")]
public string FormatProperties(IDictionary`2<string, string> properties);
    public NonEscapedString QueueLabel(string queue);
    public NonEscapedString ServerId(string serverId);
    public NonEscapedString StackTrace(string stackTrace);
    public string HtmlEncode(string text);
}
[ObsoleteAttribute("Please use `IDashboardAuthorizationFilter` instead. Will be removed in 2.0.0.")]
public interface Hangfire.Dashboard.IAuthorizationFilter {
    public abstract virtual bool Authorize(IDictionary`2<string, object> owinEnvironment);
}
public interface Hangfire.Dashboard.IDashboardAsyncAuthorizationFilter {
    public abstract virtual Task`1<bool> AuthorizeAsync(DashboardContext context);
}
public interface Hangfire.Dashboard.IDashboardAuthorizationFilter {
    public abstract virtual bool Authorize(DashboardContext context);
}
public interface Hangfire.Dashboard.IDashboardDispatcher {
    public abstract virtual Task Dispatch(DashboardContext context);
}
[ObsoleteAttribute("Use the `IDashboardDispatcher` interface instead. Will be removed in 2.0.0.")]
public interface Hangfire.Dashboard.IRequestDispatcher {
    public abstract virtual Task Dispatch(RequestDispatcherContext context);
}
internal static class Hangfire.Dashboard.JobDetailsRenderer : object {
    private static object SyncRoot;
    private static List`1<Tuple`2<int, Func`2<JobDetailsRendererDto, NonEscapedString>>> Renderers;
    private static JobDetailsRenderer();
    public static IEnumerable`1<Tuple`2<int, Func`2<JobDetailsRendererDto, NonEscapedString>>> GetRenderers();
    public static void AddRenderer(int order, Func`2<JobDetailsRendererDto, NonEscapedString> renderer);
}
public class Hangfire.Dashboard.JobDetailsRendererDto : object {
    [CompilerGeneratedAttribute]
private RazorPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private JobDetailsDto <JobDetails>k__BackingField;
    public RazorPage Page { get; }
    public string JobId { get; }
    public JobDetailsDto JobDetails { get; }
    public JobDetailsRendererDto(RazorPage page, string jobId, JobDetailsDto jobDetails);
    [CompilerGeneratedAttribute]
public RazorPage get_Page();
    [CompilerGeneratedAttribute]
public string get_JobId();
    [CompilerGeneratedAttribute]
public JobDetailsDto get_JobDetails();
}
[ExtensionAttribute]
public static class Hangfire.Dashboard.JobHistoryRenderer : object {
    private static IDictionary`2<string, Func`3<HtmlHelper, IDictionary`2<string, string>, NonEscapedString>> Renderers;
    private static IDictionary`2<string, string> BackgroundStateColors;
    private static IDictionary`2<string, string> ForegroundStateColors;
    private static IDictionary`2<string, string> StateCssSuffixes;
    private static JobHistoryRenderer();
    [ObsoleteAttribute("Use `AddStateCssSuffix` method's logic instead. Will be removed in 2.0.0.")]
public static void AddBackgroundStateColor(string stateName, string color);
    public static string GetBackgroundStateColor(string stateName);
    [ObsoleteAttribute("Use `AddStateCssSuffix` method's logic instead. Will be removed in 2.0.0.")]
public static void AddForegroundStateColor(string stateName, string color);
    public static string GetForegroundStateColor(string stateName);
    public static void AddStateCssSuffix(string stateName, string color);
    public static string GetStateCssSuffix(string stateName);
    public static void Register(string state, Func`3<HtmlHelper, IDictionary`2<string, string>, NonEscapedString> renderer);
    public static bool Exists(string state);
    [ExtensionAttribute]
public static NonEscapedString RenderHistory(HtmlHelper helper, string state, IDictionary`2<string, string> properties);
    public static NonEscapedString NullRenderer(HtmlHelper helper, IDictionary`2<string, string> properties);
    public static NonEscapedString DefaultRenderer(HtmlHelper helper, IDictionary`2<string, string> stateData);
    public static NonEscapedString SucceededRenderer(HtmlHelper html, IDictionary`2<string, string> stateData);
    private static NonEscapedString FailedRenderer(HtmlHelper html, IDictionary`2<string, string> stateData);
    private static NonEscapedString ProcessingRenderer(HtmlHelper helper, IDictionary`2<string, string> stateData);
    private static NonEscapedString EnqueuedRenderer(HtmlHelper helper, IDictionary`2<string, string> stateData);
    private static NonEscapedString ScheduledRenderer(HtmlHelper helper, IDictionary`2<string, string> stateData);
    private static NonEscapedString AwaitingRenderer(HtmlHelper helper, IDictionary`2<string, string> stateData);
    private static NonEscapedString DeletedRenderer(HtmlHelper html, IDictionary`2<string, string> stateData);
}
internal static class Hangfire.Dashboard.JobMethodCallRenderer : object {
    internal static int MaxArgumentToRenderSize;
    private static JobMethodCallRenderer();
    public static NonEscapedString Render(Job job);
    private static string WrapIdentifier(string value);
    private static string WrapKeyword(string value);
    private static string WrapType(string value);
    private static string WrapString(string value);
    private static string Span(string class, string value);
    private static string Encode(string value);
    private static Type GetIEnumerableGenericArgument(Type type);
    public static string GetNameWithoutGenericArity(Type t);
}
public static class Hangfire.Dashboard.JobsSidebarMenu : object {
    public static List`1<Func`2<RazorPage, MenuItem>> Items;
    private static JobsSidebarMenu();
}
internal class Hangfire.Dashboard.JsonStats : object {
    [AsyncStateMachineAttribute("Hangfire.Dashboard.JsonStats/<Dispatch>d__0")]
public sealed virtual Task Dispatch(DashboardContext context);
}
public class Hangfire.Dashboard.LocalRequestsOnlyAuthorizationFilter : object {
    public sealed virtual bool Authorize(DashboardContext context);
    public sealed virtual bool Authorize(IDictionary`2<string, object> owinEnvironment);
}
public class Hangfire.Dashboard.MenuItem : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardMetric <Metric>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardMetric[] <Metrics>k__BackingField;
    public string Text { get; }
    public string Url { get; }
    public bool Active { get; public set; }
    public DashboardMetric Metric { get; public set; }
    public DashboardMetric[] Metrics { get; public set; }
    public MenuItem(string text, string url);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
public void set_Active(bool value);
    [CompilerGeneratedAttribute]
public DashboardMetric get_Metric();
    [CompilerGeneratedAttribute]
public void set_Metric(DashboardMetric value);
    [CompilerGeneratedAttribute]
public DashboardMetric[] get_Metrics();
    [CompilerGeneratedAttribute]
public void set_Metrics(DashboardMetric[] value);
    public IEnumerable`1<DashboardMetric> GetAllMetrics();
}
public class Hangfire.Dashboard.Metric : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IntValue>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Highlighted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Value { get; }
    public long IntValue { get; public set; }
    public MetricStyle Style { get; public set; }
    public bool Highlighted { get; public set; }
    public string Title { get; public set; }
    public Metric(string value);
    public Metric(long value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public long get_IntValue();
    [CompilerGeneratedAttribute]
public void set_IntValue(long value);
    [CompilerGeneratedAttribute]
public MetricStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(MetricStyle value);
    [CompilerGeneratedAttribute]
public bool get_Highlighted();
    [CompilerGeneratedAttribute]
public void set_Highlighted(bool value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
public enum Hangfire.Dashboard.MetricStyle : Enum {
    public int value__;
    public static MetricStyle Default;
    public static MetricStyle Info;
    public static MetricStyle Success;
    public static MetricStyle Warning;
    public static MetricStyle Danger;
}
[ExtensionAttribute]
internal static class Hangfire.Dashboard.MetricStyleExtensions : object {
    [ExtensionAttribute]
public static string ToClassName(MetricStyle style);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Hangfire.Dashboard.MiddlewareExtensions : object {
    [ExtensionAttribute]
public static Action`1<Func`2<IDictionary`2<string, object>, Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>>> UseHangfireDashboard(Action`1<Func`2<IDictionary`2<string, object>, Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>>> builder, DashboardOptions options, JobStorage storage, RouteCollection routes, IOwinDashboardAntiforgery antiforgery);
    public static Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>> UseHangfireDashboard(DashboardOptions options, JobStorage storage, RouteCollection routes, IOwinDashboardAntiforgery antiforgery);
    private static int GetUnauthorizedStatusCode(IOwinContext owinContext);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Dashboard.NamespaceDoc : object {
}
public static class Hangfire.Dashboard.NavigationMenu : object {
    public static List`1<Func`2<RazorPage, MenuItem>> Items;
    private static NavigationMenu();
}
public class Hangfire.Dashboard.NonEscapedString : object {
    private string _value;
    public NonEscapedString(string value);
    public virtual string ToString();
}
public interface Hangfire.Dashboard.Owin.IOwinDashboardAntiforgery {
    public string HeaderName { get; }
    public abstract virtual string get_HeaderName();
    public abstract virtual string GetToken(IDictionary`2<string, object> environment);
    public abstract virtual bool ValidateRequest(IDictionary`2<string, object> environment);
}
public class Hangfire.Dashboard.OwinDashboardContext : DashboardContext {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Environment>k__BackingField;
    public IDictionary`2<string, object> Environment { get; }
    public OwinDashboardContext(JobStorage storage, DashboardOptions options, IDictionary`2<string, object> environment);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Environment();
}
[ExtensionAttribute]
public static class Hangfire.Dashboard.OwinDashboardContextExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<string, object> GetOwinEnvironment(DashboardContext context);
}
internal class Hangfire.Dashboard.OwinDashboardRequest : DashboardRequest {
    private static string FormCollectionKey;
    private IOwinContext _context;
    public string Method { get; }
    public string Path { get; }
    public string PathBase { get; }
    public string LocalIpAddress { get; }
    public string RemoteIpAddress { get; }
    public OwinDashboardRequest(IDictionary`2<string, object> environment);
    public virtual string get_Method();
    public virtual string get_Path();
    public virtual string get_PathBase();
    public virtual string get_LocalIpAddress();
    public virtual string get_RemoteIpAddress();
    public virtual string GetQuery(string key);
    [AsyncStateMachineAttribute("Hangfire.Dashboard.OwinDashboardRequest/<GetFormValuesAsync>d__14")]
public virtual Task`1<IList`1<string>> GetFormValuesAsync(string key);
}
internal class Hangfire.Dashboard.OwinDashboardResponse : DashboardResponse {
    private IOwinContext _context;
    public string ContentType { get; public set; }
    public int StatusCode { get; public set; }
    public Stream Body { get; }
    public OwinDashboardResponse(IDictionary`2<string, object> environment);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual int get_StatusCode();
    public virtual void set_StatusCode(int value);
    public virtual Stream get_Body();
    public virtual void SetExpire(Nullable`1<DateTimeOffset> value);
    public virtual Task WriteAsync(string text);
}
public class Hangfire.Dashboard.Pager : object {
    private static int PageItemsCount;
    private static int DefaultRecordsPerPage;
    private int _startPageIndex;
    private int _endPageIndex;
    [CompilerGeneratedAttribute]
private string <BasePageUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecordsPerPage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalPageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalRecordCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Item> <PagerItems>k__BackingField;
    public string BasePageUrl { get; public set; }
    public int FromRecord { get; }
    public int RecordsPerPage { get; }
    public int CurrentPage { get; }
    public int TotalPageCount { get; }
    public long TotalRecordCount { get; }
    internal ICollection`1<Item> PagerItems { get; }
    public Pager(int from, int perPage, long total);
    public Pager(int from, int perPage, int defaultPerPage, long total);
    [CompilerGeneratedAttribute]
public string get_BasePageUrl();
    [CompilerGeneratedAttribute]
public void set_BasePageUrl(string value);
    [CompilerGeneratedAttribute]
public int get_FromRecord();
    [CompilerGeneratedAttribute]
public int get_RecordsPerPage();
    [CompilerGeneratedAttribute]
public int get_CurrentPage();
    [CompilerGeneratedAttribute]
public int get_TotalPageCount();
    [CompilerGeneratedAttribute]
public long get_TotalRecordCount();
    [CompilerGeneratedAttribute]
internal ICollection`1<Item> get_PagerItems();
    public virtual string PageUrl(int page);
    public string RecordsPerPageUrl(int perPage);
    private ICollection`1<Item> GenerateItems();
    private void AddPrevious(ICollection`1<Item> results);
    private void AddMoreBefore(ICollection`1<Item> results);
    private void AddMoreAfter(ICollection`1<Item> results);
    private void AddPageNumbers(ICollection`1<Item> results);
    private void AddNext(ICollection`1<Item> results);
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.AwaitingJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.BlockMetric : RazorPage {
    [CompilerGeneratedAttribute]
private DashboardMetric <DashboardMetric>k__BackingField;
    public DashboardMetric DashboardMetric { get; }
    public BlockMetric(DashboardMetric dashboardMetric);
    [CompilerGeneratedAttribute]
public DashboardMetric get_DashboardMetric();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.Breadcrumbs : RazorPage {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Items>k__BackingField;
    public string Title { get; }
    public IDictionary`2<string, string> Items { get; }
    public Breadcrumbs(string title, IDictionary`2<string, string> items);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Items();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.DeletedJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.EnqueuedJobsPage : RazorPage {
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Queue { get; }
    public EnqueuedJobsPage(string queue);
    [CompilerGeneratedAttribute]
public string get_Queue();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.ErrorAlert : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.FailedJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.FetchedJobsPage : RazorPage {
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Queue { get; }
    public FetchedJobsPage(string queue);
    [CompilerGeneratedAttribute]
public string get_Queue();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.HomePage : RazorPage {
    public static List`1<DashboardMetric> Metrics;
    private static HomePage();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.InlineMetric : RazorPage {
    [CompilerGeneratedAttribute]
private DashboardMetric <DashboardMetric>k__BackingField;
    public DashboardMetric DashboardMetric { get; }
    public InlineMetric(DashboardMetric dashboardMetric);
    [CompilerGeneratedAttribute]
public DashboardMetric get_DashboardMetric();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.JobDetailsPage : RazorPage {
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    public string JobId { get; }
    public JobDetailsPage(string jobId);
    [CompilerGeneratedAttribute]
public string get_JobId();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
public class Hangfire.Dashboard.Pages.LayoutPage : RazorPage {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public LayoutPage(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
    public virtual void Execute();
}
[CompilerGeneratedAttribute]
internal class Hangfire.Dashboard.Pages.NamespaceDoc : object {
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.Navigation : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.Paginator : RazorPage {
    private Pager _pager;
    public Paginator(Pager pager);
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.PerPageSelector : RazorPage {
    private Pager _pager;
    public PerPageSelector(Pager pager);
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.ProcessingJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.QueuesPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.RecurringJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.RetriesPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.ScheduledJobsPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.ServersPage : RazorPage {
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.SidebarMenu : RazorPage {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Func`2<RazorPage, MenuItem>> <Items>k__BackingField;
    public IEnumerable`1<Func`2<RazorPage, MenuItem>> Items { get; }
    public SidebarMenu(IEnumerable`1<Func`2<RazorPage, MenuItem>> items);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Func`2<RazorPage, MenuItem>> get_Items();
    public virtual void Execute();
}
[GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
internal class Hangfire.Dashboard.Pages.SucceededJobs : RazorPage {
    public virtual void Execute();
}
public abstract class Hangfire.Dashboard.RazorPage : object {
    private Lazy`1<StatisticsDto> _statisticsLazy;
    private Lazy`1<Tuple`3<Nullable`1<DateTime>, DateTime, Nullable`1<TimeSpan>>> _dateTimeLazy;
    private StringBuilder _content;
    private string _body;
    [CompilerGeneratedAttribute]
private RazorPage <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlHelper <Html>k__BackingField;
    [CompilerGeneratedAttribute]
private UrlHelper <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <GenerationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DashboardContext <Context>k__BackingField;
    public RazorPage Layout { get; protected set; }
    public HtmlHelper Html { get; private set; }
    public UrlHelper Url { get; private set; }
    public JobStorage Storage { get; }
    public string AppPath { get; }
    public DashboardOptions DashboardOptions { get; }
    public Stopwatch GenerationTime { get; private set; }
    public Nullable`1<DateTime> StorageUtcNow { get; }
    public DateTime ApplicationUtcNow { get; }
    public Nullable`1<TimeSpan> TimeDifference { get; }
    public StatisticsDto Statistics { get; }
    public DashboardContext Context { get; private set; }
    internal DashboardRequest Request { get; }
    internal DashboardResponse Response { get; }
    public string RequestPath { get; }
    public bool IsReadOnly { get; }
    [CompilerGeneratedAttribute]
public RazorPage get_Layout();
    [CompilerGeneratedAttribute]
protected void set_Layout(RazorPage value);
    [CompilerGeneratedAttribute]
public HtmlHelper get_Html();
    [CompilerGeneratedAttribute]
private void set_Html(HtmlHelper value);
    [CompilerGeneratedAttribute]
public UrlHelper get_Url();
    [CompilerGeneratedAttribute]
private void set_Url(UrlHelper value);
    public JobStorage get_Storage();
    public string get_AppPath();
    public DashboardOptions get_DashboardOptions();
    [CompilerGeneratedAttribute]
public Stopwatch get_GenerationTime();
    [CompilerGeneratedAttribute]
private void set_GenerationTime(Stopwatch value);
    public Nullable`1<DateTime> get_StorageUtcNow();
    public DateTime get_ApplicationUtcNow();
    public Nullable`1<TimeSpan> get_TimeDifference();
    public StatisticsDto get_Statistics();
    [CompilerGeneratedAttribute]
public DashboardContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(DashboardContext value);
    internal DashboardRequest get_Request();
    internal DashboardResponse get_Response();
    public string get_RequestPath();
    public bool get_IsReadOnly();
    public abstract virtual void Execute();
    public string Query(string key);
    public virtual string ToString();
    public void Assign(RazorPage parentPage);
    internal void Assign(DashboardContext context);
    protected void WriteLiteral(string textToAppend);
    protected virtual void Write(object value);
    protected virtual object RenderBody();
    private string TransformText(string body);
    private static string Encode(string text);
    [CompilerGeneratedAttribute]
private StatisticsDto <Assign>b__51_0();
    [CompilerGeneratedAttribute]
private Tuple`3<Nullable`1<DateTime>, DateTime, Nullable`1<TimeSpan>> <Assign>b__51_1();
}
internal class Hangfire.Dashboard.RazorPageDispatcher : object {
    private Func`2<Match, RazorPage> _pageFunc;
    public RazorPageDispatcher(Func`2<Match, RazorPage> pageFunc);
    public sealed virtual Task Dispatch(DashboardContext context);
}
[ObsoleteAttribute("Use the `DashboardContext` class instead. Will be removed in 2.0.0.")]
public class Hangfire.Dashboard.RequestDispatcherContext : object {
    [CompilerGeneratedAttribute]
private string <AppPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatsPollingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorage <JobStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <OwinEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private Match <UriMatch>k__BackingField;
    public string AppPath { get; }
    public int StatsPollingInterval { get; }
    public JobStorage JobStorage { get; }
    public IDictionary`2<string, object> OwinEnvironment { get; }
    public Match UriMatch { get; }
    public RequestDispatcherContext(string appPath, int statsPollingInterval, JobStorage jobStorage, IDictionary`2<string, object> owinEnvironment, Match uriMatch);
    [CompilerGeneratedAttribute]
public string get_AppPath();
    [CompilerGeneratedAttribute]
public int get_StatsPollingInterval();
    [CompilerGeneratedAttribute]
public JobStorage get_JobStorage();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_OwinEnvironment();
    [CompilerGeneratedAttribute]
public Match get_UriMatch();
    public static RequestDispatcherContext FromDashboardContext(DashboardContext context);
}
[ObsoleteAttribute("Use IDashboardDispatcher-based dispatchers instead. Will be removed in 2.0.0.")]
public class Hangfire.Dashboard.RequestDispatcherWrapper : object {
    private IRequestDispatcher _dispatcher;
    public RequestDispatcherWrapper(IRequestDispatcher dispatcher);
    public sealed virtual Task Dispatch(DashboardContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Hangfire.Dashboard.Resources.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AwaitingJobsPage_ContinuationsWarning_Text { get; }
    public static string AwaitingJobsPage_ContinuationsWarning_Title { get; }
    public static string AwaitingJobsPage_NoJobs { get; }
    public static string AwaitingJobsPage_Table_Options { get; }
    public static string AwaitingJobsPage_Table_Parent { get; }
    public static string AwaitingJobsPage_Table_Since { get; }
    public static string AwaitingJobsPage_Title { get; }
    public static string Common_CannotFindTargetMethod { get; }
    public static string Common_Condition { get; }
    public static string Common_Continuations { get; }
    public static string Common_Created { get; }
    public static string Common_Delete { get; }
    public static string Common_DeleteConfirm { get; }
    public static string Common_DeleteSelected { get; }
    public static string Common_Deleting { get; }
    public static string Common_Disabled { get; }
    public static string Common_EnqueueButton_Text { get; }
    public static string Common_Enqueued { get; }
    public static string Common_Enqueueing { get; }
    public static string Common_Error { get; }
    public static string Common_Fetched { get; }
    public static string Common_Id { get; }
    public static string Common_Job { get; }
    public static string Common_JobExpired { get; }
    public static string Common_JobStateChanged_Text { get; }
    public static string Common_LessDetails { get; }
    public static string Common_MoreDetails { get; }
    public static string Common_NoState { get; }
    public static string Common_NotAvailable { get; }
    public static string Common_PeriodDay { get; }
    public static string Common_PeriodWeek { get; }
    public static string Common_Reason { get; }
    public static string Common_RequeueJobs { get; }
    public static string Common_Retry { get; }
    public static string Common_Server { get; }
    public static string Common_State { get; }
    public static string Common_Unknown { get; }
    public static string DeletedJobsPage_NoJobs { get; }
    public static string DeletedJobsPage_Table_Deleted { get; }
    public static string DeletedJobsPage_Table_Exception { get; }
    public static string DeletedJobsPage_Title { get; }
    public static string EnqueuedJobsPage_NoJobs { get; }
    public static string EnqueuedJobsPage_Title { get; }
    public static string FailedJobsPage_FailedJobsNotExpire_Warning_Html { get; }
    public static string FailedJobsPage_NoJobs { get; }
    public static string FailedJobsPage_Table_Failed { get; }
    public static string FailedJobsPage_Title { get; }
    public static string FetchedJobsPage_NoJobs { get; }
    public static string FetchedJobsPage_Title { get; }
    public static string HomePage_GraphHover_Failed { get; }
    public static string HomePage_GraphHover_Succeeded { get; }
    public static string HomePage_HistoryGraph { get; }
    public static string HomePage_RealtimeGraph { get; }
    public static string HomePage_Title { get; }
    public static string JobDetailsPage_Created { get; }
    public static string JobDetailsPage_DeleteConfirm { get; }
    public static string JobDetailsPage_JobAbortedNotActive_Warning_Html { get; }
    public static string JobDetailsPage_JobAbortedWithHeartbeat_Warning_Html { get; }
    public static string JobDetailsPage_JobExpired { get; }
    public static string JobDetailsPage_JobFinished_Warning_Html { get; }
    public static string JobDetailsPage_JobId { get; }
    public static string JobDetailsPage_Parameters { get; }
    public static string JobDetailsPage_Requeue { get; }
    public static string JobDetailsPage_State { get; }
    public static string JobsSidebarMenu_Awaiting { get; }
    public static string JobsSidebarMenu_Deleted { get; }
    public static string JobsSidebarMenu_Enqueued { get; }
    public static string JobsSidebarMenu_Failed { get; }
    public static string JobsSidebarMenu_Processing { get; }
    public static string JobsSidebarMenu_Scheduled { get; }
    public static string JobsSidebarMenu_Succeeded { get; }
    public static string LayoutPage_Back { get; }
    public static string LayoutPage_Footer_Generatedms { get; }
    public static string LayoutPage_Footer_StorageTime { get; }
    public static string LayoutPage_Footer_Time { get; }
    public static string LayoutPage_Footer_TimeIsOutOfSync { get; }
    public static string Metrics_ActiveConnections { get; }
    public static string Metrics_AwaitingCount { get; }
    public static string Metrics_DeletedJobs { get; }
    public static string Metrics_EnqueuedCountOrNull { get; }
    public static string Metrics_EnqueuedQueuesCount { get; }
    public static string Metrics_FailedCountOrNull { get; }
    public static string Metrics_FailedJobs { get; }
    public static string Metrics_ProcessingJobs { get; }
    public static string Metrics_RecurringJobs { get; }
    public static string Metrics_Retries { get; }
    public static string Metrics_ScheduledJobs { get; }
    public static string Metrics_Servers { get; }
    public static string Metrics_SQLServer_ActiveTransactions { get; }
    public static string Metrics_SQLServer_DataFilesSize { get; }
    public static string Metrics_SQLServer_LogFilesSize { get; }
    public static string Metrics_SQLServer_SchemaVersion { get; }
    public static string Metrics_SucceededJobs { get; }
    public static string Metrics_TotalConnections { get; }
    public static string NavigationMenu_Jobs { get; }
    public static string NavigationMenu_RecurringJobs { get; }
    public static string NavigationMenu_Retries { get; }
    public static string NavigationMenu_Servers { get; }
    public static string Paginator_Next { get; }
    public static string Paginator_Prev { get; }
    public static string Paginator_TotalItems { get; }
    public static string PerPageSelector_ItemsPerPage { get; }
    public static string ProcessingJobsPage_Aborted { get; }
    public static string ProcessingJobsPage_NoJobs { get; }
    public static string ProcessingJobsPage_Table_Started { get; }
    public static string ProcessingJobsPage_Title { get; }
    public static string QueuesPage_NoJobs { get; }
    public static string QueuesPage_NoQueues { get; }
    public static string QueuesPage_Table_Length { get; }
    public static string QueuesPage_Table_NextsJobs { get; }
    public static string QueuesPage_Table_Queue { get; }
    public static string QueuesPage_Title { get; }
    public static string RecurringJobsPage_Canceled { get; }
    public static string RecurringJobsPage_NoJobs { get; }
    public static string RecurringJobsPage_RecurringJobDisabled_Tooltip { get; }
    public static string RecurringJobsPage_Table_Cron { get; }
    public static string RecurringJobsPage_Table_LastExecution { get; }
    public static string RecurringJobsPage_Table_NextExecution { get; }
    public static string RecurringJobsPage_Table_TimeZone { get; }
    public static string RecurringJobsPage_Title { get; }
    public static string RecurringJobsPage_Triggering { get; }
    public static string RecurringJobsPage_TriggerNow { get; }
    public static string RetriesPage_NoJobs { get; }
    public static string RetriesPage_Title { get; }
    public static string RetriesPage_Warning_Html { get; }
    public static string ScheduledJobsPage_EnqueueNow { get; }
    public static string ScheduledJobsPage_NoJobs { get; }
    public static string ScheduledJobsPage_Table_Enqueue { get; }
    public static string ScheduledJobsPage_Table_Scheduled { get; }
    public static string ScheduledJobsPage_Title { get; }
    public static string ServersPage_Active { get; }
    public static string ServersPage_NoServers { get; }
    public static string ServersPage_Note_Text { get; }
    public static string ServersPage_Note_Title { get; }
    public static string ServersPage_Possibly_Aborted { get; }
    public static string ServersPage_Table_Heartbeat { get; }
    public static string ServersPage_Table_Name { get; }
    public static string ServersPage_Table_Queues { get; }
    public static string ServersPage_Table_Started { get; }
    public static string ServersPage_Table_Workers { get; }
    public static string ServersPage_Title { get; }
    public static string SucceededJobsPage_NoJobs { get; }
    public static string SucceededJobsPage_Table_Duration { get; }
    public static string SucceededJobsPage_Table_Latency { get; }
    public static string SucceededJobsPage_Table_Succeeded { get; }
    public static string SucceededJobsPage_Table_TotalDuration { get; }
    public static string SucceededJobsPage_Title { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AwaitingJobsPage_ContinuationsWarning_Text();
    public static string get_AwaitingJobsPage_ContinuationsWarning_Title();
    public static string get_AwaitingJobsPage_NoJobs();
    public static string get_AwaitingJobsPage_Table_Options();
    public static string get_AwaitingJobsPage_Table_Parent();
    public static string get_AwaitingJobsPage_Table_Since();
    public static string get_AwaitingJobsPage_Title();
    public static string get_Common_CannotFindTargetMethod();
    public static string get_Common_Condition();
    public static string get_Common_Continuations();
    public static string get_Common_Created();
    public static string get_Common_Delete();
    public static string get_Common_DeleteConfirm();
    public static string get_Common_DeleteSelected();
    public static string get_Common_Deleting();
    public static string get_Common_Disabled();
    public static string get_Common_EnqueueButton_Text();
    public static string get_Common_Enqueued();
    public static string get_Common_Enqueueing();
    public static string get_Common_Error();
    public static string get_Common_Fetched();
    public static string get_Common_Id();
    public static string get_Common_Job();
    public static string get_Common_JobExpired();
    public static string get_Common_JobStateChanged_Text();
    public static string get_Common_LessDetails();
    public static string get_Common_MoreDetails();
    public static string get_Common_NoState();
    public static string get_Common_NotAvailable();
    public static string get_Common_PeriodDay();
    public static string get_Common_PeriodWeek();
    public static string get_Common_Reason();
    public static string get_Common_RequeueJobs();
    public static string get_Common_Retry();
    public static string get_Common_Server();
    public static string get_Common_State();
    public static string get_Common_Unknown();
    public static string get_DeletedJobsPage_NoJobs();
    public static string get_DeletedJobsPage_Table_Deleted();
    public static string get_DeletedJobsPage_Table_Exception();
    public static string get_DeletedJobsPage_Title();
    public static string get_EnqueuedJobsPage_NoJobs();
    public static string get_EnqueuedJobsPage_Title();
    public static string get_FailedJobsPage_FailedJobsNotExpire_Warning_Html();
    public static string get_FailedJobsPage_NoJobs();
    public static string get_FailedJobsPage_Table_Failed();
    public static string get_FailedJobsPage_Title();
    public static string get_FetchedJobsPage_NoJobs();
    public static string get_FetchedJobsPage_Title();
    public static string get_HomePage_GraphHover_Failed();
    public static string get_HomePage_GraphHover_Succeeded();
    public static string get_HomePage_HistoryGraph();
    public static string get_HomePage_RealtimeGraph();
    public static string get_HomePage_Title();
    public static string get_JobDetailsPage_Created();
    public static string get_JobDetailsPage_DeleteConfirm();
    public static string get_JobDetailsPage_JobAbortedNotActive_Warning_Html();
    public static string get_JobDetailsPage_JobAbortedWithHeartbeat_Warning_Html();
    public static string get_JobDetailsPage_JobExpired();
    public static string get_JobDetailsPage_JobFinished_Warning_Html();
    public static string get_JobDetailsPage_JobId();
    public static string get_JobDetailsPage_Parameters();
    public static string get_JobDetailsPage_Requeue();
    public static string get_JobDetailsPage_State();
    public static string get_JobsSidebarMenu_Awaiting();
    public static string get_JobsSidebarMenu_Deleted();
    public static string get_JobsSidebarMenu_Enqueued();
    public static string get_JobsSidebarMenu_Failed();
    public static string get_JobsSidebarMenu_Processing();
    public static string get_JobsSidebarMenu_Scheduled();
    public static string get_JobsSidebarMenu_Succeeded();
    public static string get_LayoutPage_Back();
    public static string get_LayoutPage_Footer_Generatedms();
    public static string get_LayoutPage_Footer_StorageTime();
    public static string get_LayoutPage_Footer_Time();
    public static string get_LayoutPage_Footer_TimeIsOutOfSync();
    public static string get_Metrics_ActiveConnections();
    public static string get_Metrics_AwaitingCount();
    public static string get_Metrics_DeletedJobs();
    public static string get_Metrics_EnqueuedCountOrNull();
    public static string get_Metrics_EnqueuedQueuesCount();
    public static string get_Metrics_FailedCountOrNull();
    public static string get_Metrics_FailedJobs();
    public static string get_Metrics_ProcessingJobs();
    public static string get_Metrics_RecurringJobs();
    public static string get_Metrics_Retries();
    public static string get_Metrics_ScheduledJobs();
    public static string get_Metrics_Servers();
    public static string get_Metrics_SQLServer_ActiveTransactions();
    public static string get_Metrics_SQLServer_DataFilesSize();
    public static string get_Metrics_SQLServer_LogFilesSize();
    public static string get_Metrics_SQLServer_SchemaVersion();
    public static string get_Metrics_SucceededJobs();
    public static string get_Metrics_TotalConnections();
    public static string get_NavigationMenu_Jobs();
    public static string get_NavigationMenu_RecurringJobs();
    public static string get_NavigationMenu_Retries();
    public static string get_NavigationMenu_Servers();
    public static string get_Paginator_Next();
    public static string get_Paginator_Prev();
    public static string get_Paginator_TotalItems();
    public static string get_PerPageSelector_ItemsPerPage();
    public static string get_ProcessingJobsPage_Aborted();
    public static string get_ProcessingJobsPage_NoJobs();
    public static string get_ProcessingJobsPage_Table_Started();
    public static string get_ProcessingJobsPage_Title();
    public static string get_QueuesPage_NoJobs();
    public static string get_QueuesPage_NoQueues();
    public static string get_QueuesPage_Table_Length();
    public static string get_QueuesPage_Table_NextsJobs();
    public static string get_QueuesPage_Table_Queue();
    public static string get_QueuesPage_Title();
    public static string get_RecurringJobsPage_Canceled();
    public static string get_RecurringJobsPage_NoJobs();
    public static string get_RecurringJobsPage_RecurringJobDisabled_Tooltip();
    public static string get_RecurringJobsPage_Table_Cron();
    public static string get_RecurringJobsPage_Table_LastExecution();
    public static string get_RecurringJobsPage_Table_NextExecution();
    public static string get_RecurringJobsPage_Table_TimeZone();
    public static string get_RecurringJobsPage_Title();
    public static string get_RecurringJobsPage_Triggering();
    public static string get_RecurringJobsPage_TriggerNow();
    public static string get_RetriesPage_NoJobs();
    public static string get_RetriesPage_Title();
    public static string get_RetriesPage_Warning_Html();
    public static string get_ScheduledJobsPage_EnqueueNow();
    public static string get_ScheduledJobsPage_NoJobs();
    public static string get_ScheduledJobsPage_Table_Enqueue();
    public static string get_ScheduledJobsPage_Table_Scheduled();
    public static string get_ScheduledJobsPage_Title();
    public static string get_ServersPage_Active();
    public static string get_ServersPage_NoServers();
    public static string get_ServersPage_Note_Text();
    public static string get_ServersPage_Note_Title();
    public static string get_ServersPage_Possibly_Aborted();
    public static string get_ServersPage_Table_Heartbeat();
    public static string get_ServersPage_Table_Name();
    public static string get_ServersPage_Table_Queues();
    public static string get_ServersPage_Table_Started();
    public static string get_ServersPage_Table_Workers();
    public static string get_ServersPage_Title();
    public static string get_SucceededJobsPage_NoJobs();
    public static string get_SucceededJobsPage_Table_Duration();
    public static string get_SucceededJobsPage_Table_Latency();
    public static string get_SucceededJobsPage_Table_Succeeded();
    public static string get_SucceededJobsPage_Table_TotalDuration();
    public static string get_SucceededJobsPage_Title();
}
public class Hangfire.Dashboard.RouteCollection : object {
    private List`1<Tuple`2<string, IDashboardDispatcher>> _dispatchers;
    [ObsoleteAttribute("Use the Add(string, IDashboardDispatcher) overload instead. Will be removed in 2.0.0.")]
public void Add(string pathTemplate, IRequestDispatcher dispatcher);
    public void Add(string pathTemplate, IDashboardDispatcher dispatcher);
    public Tuple`2<IDashboardDispatcher, Match> FindDispatcher(string path);
}
[ExtensionAttribute]
public static class Hangfire.Dashboard.RouteCollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRazorPage(RouteCollection routes, string pathTemplate, Func`2<Match, RazorPage> pageFunc);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the AddCommand(RouteCollection, string, Func<DashboardContext, bool>) overload instead. Will be removed in 2.0.0.")]
public static void AddCommand(RouteCollection routes, string pathTemplate, Func`2<RequestDispatcherContext, bool> command);
    [ExtensionAttribute]
public static void AddCommand(RouteCollection routes, string pathTemplate, Func`2<DashboardContext, bool> command);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the AddBatchCommand(RouteCollection, string, Func<DashboardContext, bool>) overload instead. Will be removed in 2.0.0.")]
public static void AddBatchCommand(RouteCollection routes, string pathTemplate, Action`2<RequestDispatcherContext, string> command);
    [ExtensionAttribute]
public static void AddBatchCommand(RouteCollection routes, string pathTemplate, Action`2<DashboardContext, string> command);
    [ExtensionAttribute]
public static void AddClientBatchCommand(RouteCollection routes, string pathTemplate, Action`2<IBackgroundJobClient, string> command);
    [ExtensionAttribute]
public static void AddRecurringBatchCommand(RouteCollection routes, string pathTemplate, Action`2<IRecurringJobManager, string> command);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("For binary compatibility only. Use overload with Action<IRecurringJobManager, string> instead.")]
public static void AddRecurringBatchCommand(RouteCollection routes, string pathTemplate, Action`2<RecurringJobManager, string> command);
}
internal enum Hangfire.Dashboard.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[ExtensionAttribute]
internal static class Hangfire.Dashboard.TypeExtensionMethods : object {
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
}
public class Hangfire.Dashboard.UrlHelper : object {
    private OwinContext _owinContext;
    private DashboardContext _context;
    [ObsoleteAttribute("Please use UrlHelper(DashboardContext) instead. Will be removed in 2.0.0.")]
public UrlHelper(IDictionary`2<string, object> owinEnvironment);
    public UrlHelper(DashboardContext context);
    public string To(string relativePath);
    public string Home();
    public string JobDetails(string jobId);
    public string LinkToQueues();
    public string Queue(string queue);
}
public class Hangfire.DashboardOptions : object {
    private static IDashboardAuthorizationFilter[] DefaultAuthorization;
    private IEnumerable`1<IDashboardAsyncAuthorizationFilter> _asyncAuthorization;
    [CompilerGeneratedAttribute]
private string <AppPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrefixPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IAuthorizationFilter> <AuthorizationFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IDashboardAuthorizationFilter> <Authorization>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DashboardContext, bool> <IsReadOnlyFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatsPollingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayStorageConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DashboardTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<DashboardContext, Job, string> <DisplayNameFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreAntiforgeryToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimeZoneResolver <TimeZoneResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultRecordsPerPage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DarkModeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FaviconPath>k__BackingField;
    public string AppPath { get; public set; }
    public string PrefixPath { get; public set; }
    [ObsoleteAttribute("Please use `Authorization` property instead. Will be removed in 2.0.0.")]
public IEnumerable`1<IAuthorizationFilter> AuthorizationFilters { get; public set; }
    public IEnumerable`1<IDashboardAuthorizationFilter> Authorization { get; public set; }
    public IEnumerable`1<IDashboardAsyncAuthorizationFilter> AsyncAuthorization { get; public set; }
    public Func`2<DashboardContext, bool> IsReadOnlyFunc { get; public set; }
    public int StatsPollingInterval { get; public set; }
    public bool DisplayStorageConnectionString { get; public set; }
    public string DashboardTitle { get; public set; }
    public Func`3<DashboardContext, Job, string> DisplayNameFunc { get; public set; }
    public bool IgnoreAntiforgeryToken { get; public set; }
    public ITimeZoneResolver TimeZoneResolver { get; public set; }
    public int DefaultRecordsPerPage { get; public set; }
    public bool DarkModeEnabled { get; public set; }
    public string FaviconPath { get; public set; }
    private static DashboardOptions();
    [CompilerGeneratedAttribute]
public string get_AppPath();
    [CompilerGeneratedAttribute]
public void set_AppPath(string value);
    [CompilerGeneratedAttribute]
public string get_PrefixPath();
    [CompilerGeneratedAttribute]
public void set_PrefixPath(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IAuthorizationFilter> get_AuthorizationFilters();
    [CompilerGeneratedAttribute]
public void set_AuthorizationFilters(IEnumerable`1<IAuthorizationFilter> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IDashboardAuthorizationFilter> get_Authorization();
    [CompilerGeneratedAttribute]
public void set_Authorization(IEnumerable`1<IDashboardAuthorizationFilter> value);
    public IEnumerable`1<IDashboardAsyncAuthorizationFilter> get_AsyncAuthorization();
    public void set_AsyncAuthorization(IEnumerable`1<IDashboardAsyncAuthorizationFilter> value);
    [CompilerGeneratedAttribute]
public Func`2<DashboardContext, bool> get_IsReadOnlyFunc();
    [CompilerGeneratedAttribute]
public void set_IsReadOnlyFunc(Func`2<DashboardContext, bool> value);
    [CompilerGeneratedAttribute]
public int get_StatsPollingInterval();
    [CompilerGeneratedAttribute]
public void set_StatsPollingInterval(int value);
    [CompilerGeneratedAttribute]
public bool get_DisplayStorageConnectionString();
    [CompilerGeneratedAttribute]
public void set_DisplayStorageConnectionString(bool value);
    [CompilerGeneratedAttribute]
public string get_DashboardTitle();
    [CompilerGeneratedAttribute]
public void set_DashboardTitle(string value);
    [CompilerGeneratedAttribute]
public Func`3<DashboardContext, Job, string> get_DisplayNameFunc();
    [CompilerGeneratedAttribute]
public void set_DisplayNameFunc(Func`3<DashboardContext, Job, string> value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreAntiforgeryToken();
    [CompilerGeneratedAttribute]
public void set_IgnoreAntiforgeryToken(bool value);
    [CompilerGeneratedAttribute]
public ITimeZoneResolver get_TimeZoneResolver();
    [CompilerGeneratedAttribute]
public void set_TimeZoneResolver(ITimeZoneResolver value);
    [CompilerGeneratedAttribute]
public int get_DefaultRecordsPerPage();
    [CompilerGeneratedAttribute]
public void set_DefaultRecordsPerPage(int value);
    [CompilerGeneratedAttribute]
public bool get_DarkModeEnabled();
    [CompilerGeneratedAttribute]
public void set_DarkModeEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_FaviconPath();
    [CompilerGeneratedAttribute]
public void set_FaviconPath(string value);
}
public class Hangfire.DefaultTimeZoneResolver : object {
    public sealed virtual TimeZoneInfo GetTimeZoneById(string timeZoneId);
}
public class Hangfire.DisableConcurrentExecutionAttribute : JobFilterAttribute {
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutSec>k__BackingField;
    [CanBeNullAttribute]
public string Resource { get; }
    public int TimeoutSec { get; }
    public DisableConcurrentExecutionAttribute(int timeoutInSeconds);
    [JsonConstructorAttribute]
public DisableConcurrentExecutionAttribute(string resource, int timeoutSec);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public int get_TimeoutSec();
    public sealed virtual void OnPerforming(PerformingContext context);
    public sealed virtual void OnPerformed(PerformedContext context);
    private string GetResource(Job job);
}
public class Hangfire.ExceptionInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionInfo <InnerException>k__BackingField;
    [NotNullAttribute]
[JsonPropertyAttribute("e")]
public string Type { get; }
    [CanBeNullAttribute]
[JsonPropertyAttribute]
public string Message { get; }
    [CanBeNullAttribute]
[JsonPropertyAttribute]
public ExceptionInfo InnerException { get; }
    public ExceptionInfo(Exception exception);
    [JsonConstructorAttribute]
public ExceptionInfo(string type, string message, ExceptionInfo innerException);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public ExceptionInfo get_InnerException();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Hangfire.ExceptionTypeHelper : object {
    private static Type StackOverflowType;
    private static Type OutOfMemoryType;
    private static ExceptionTypeHelper();
    [ExtensionAttribute]
internal static bool IsCatchableExceptionType(Exception e);
}
[AttributeUsageAttribute("2048")]
public class Hangfire.FromExceptionAttribute : FromParameterAttribute {
}
[AttributeUsageAttribute("2048")]
public class Hangfire.FromParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public FromParameterAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class Hangfire.FromResultAttribute : FromParameterAttribute {
}
public class Hangfire.GlobalConfiguration : object {
    private static int _compatibilityLevel;
    [CompilerGeneratedAttribute]
private static IGlobalConfiguration <Configuration>k__BackingField;
    public static IGlobalConfiguration Configuration { get; }
    internal static CompatibilityLevel CompatibilityLevel { get; internal set; }
    private static GlobalConfiguration();
    [CompilerGeneratedAttribute]
public static IGlobalConfiguration get_Configuration();
    internal static CompatibilityLevel get_CompatibilityLevel();
    internal static void set_CompatibilityLevel(CompatibilityLevel value);
    internal static bool HasCompatibilityLevel(CompatibilityLevel level);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Hangfire.GlobalConfigurationExtensions : object {
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TStorage> UseStorage(IGlobalConfiguration configuration, TStorage storage);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TStorage> WithJobExpirationTimeout(IGlobalConfiguration`1<TStorage> configuration, TimeSpan timeout);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TActivator> UseActivator(IGlobalConfiguration configuration, TActivator activator);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<JobActivator> UseDefaultActivator(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TLogProvider> UseLogProvider(IGlobalConfiguration configuration, TLogProvider provider);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<NLogLogProvider> UseNLogLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<ColouredConsoleLogProvider> UseColouredConsoleLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<ColouredConsoleLogProvider> UseColouredConsoleLogProvider(IGlobalConfiguration configuration, LogLevel minLevel);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<Log4NetLogProvider> UseLog4NetLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<ElmahLogProvider> UseElmahLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<ElmahLogProvider> UseElmahLogProvider(IGlobalConfiguration configuration, LogLevel minLevel);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<EntLibLogProvider> UseEntLibLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<SerilogLogProvider> UseSerilogLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<LoupeLogProvider> UseLoupeLogProvider(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TFilter> UseFilter(IGlobalConfiguration configuration, TFilter filter);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<TFilterProvider> UseFilterProvider(IGlobalConfiguration configuration, TFilterProvider filterProvider);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDashboardMetric(IGlobalConfiguration configuration, DashboardMetric metric);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDashboardMetrics(IGlobalConfiguration configuration, DashboardMetric[] metrics);
    [ExtensionAttribute]
public static IGlobalConfiguration UseJobDetailsRenderer(IGlobalConfiguration configuration, int order, Func`2<JobDetailsRendererDto, NonEscapedString> renderer);
    [ExtensionAttribute]
public static IGlobalConfiguration UseTypeResolver(IGlobalConfiguration configuration, Func`2<string, Type> typeResolver);
    [ExtensionAttribute]
public static IGlobalConfiguration UseTypeSerializer(IGlobalConfiguration configuration, Func`2<Type, string> typeSerializer);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultTypeResolver(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultTypeSerializer(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseSimpleAssemblyNameTypeSerializer(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseIgnoredAssemblyVersionTypeResolver(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseSerializerSettings(IGlobalConfiguration configuration, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static IGlobalConfiguration UseRecommendedSerializerSettings(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseRecommendedSerializerSettings(IGlobalConfiguration configuration, Action`1<JsonSerializerSettings> settingsConfiguration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseResultsInContinuations(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration UseMaxLinesInExceptionDetails(IGlobalConfiguration configuration, Nullable`1<int> numberOfLines);
    [ExtensionAttribute]
public static IGlobalConfiguration UseMaxArgumentSizeToRender(IGlobalConfiguration configuration, int size);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultCulture(IGlobalConfiguration configuration, CultureInfo culture);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultCulture(IGlobalConfiguration configuration, CultureInfo culture, bool captureDefault);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultCulture(IGlobalConfiguration configuration, CultureInfo culture, CultureInfo uiCulture);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDefaultCulture(IGlobalConfiguration configuration, CultureInfo culture, CultureInfo uiCulture, bool captureDefault);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDashboardStylesheet(IGlobalConfiguration configuration, Assembly assembly, string resource);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDashboardStylesheetDarkMode(IGlobalConfiguration configuration, Assembly assembly, string resource);
    [ExtensionAttribute]
public static IGlobalConfiguration UseDashboardJavaScript(IGlobalConfiguration configuration, Assembly assembly, string resource);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static IGlobalConfiguration`1<T> Use(IGlobalConfiguration configuration, T entry, Action`1<T> entryAction);
}
public static class Hangfire.GlobalJobFilters : object {
    [CompilerGeneratedAttribute]
private static JobFilterCollection <Filters>k__BackingField;
    public static JobFilterCollection Filters { get; }
    private static GlobalJobFilters();
    [CompilerGeneratedAttribute]
public static JobFilterCollection get_Filters();
}
public static class Hangfire.GlobalStateHandlers : object {
    [CompilerGeneratedAttribute]
private static ICollection`1<IStateHandler> <Handlers>k__BackingField;
    public static ICollection`1<IStateHandler> Handlers { get; }
    private static GlobalStateHandlers();
    [CompilerGeneratedAttribute]
public static ICollection`1<IStateHandler> get_Handlers();
}
public interface Hangfire.IBackgroundJobClient {
    [CanBeNullAttribute]
public abstract virtual string Create(Job job, IState state);
    public abstract virtual bool ChangeState(string jobId, IState state, string expectedState);
}
public interface Hangfire.IBackgroundJobClientV2 {
    [NotNullAttribute]
public JobStorage Storage { get; }
    public abstract virtual JobStorage get_Storage();
    [CanBeNullAttribute]
public abstract virtual string Create(Job job, IState state, IDictionary`2<string, object> parameters);
}
[ObsoleteAttribute("Please use `GlobalConfiguration` class instead. Will be removed in version 2.0.0.")]
public interface Hangfire.IBootstrapperConfiguration {
    [ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard("/hangfire", new DashboardOptions { AuthorizationFilters = filters })` OWIN extension method instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseAuthorizationFilters(IAuthorizationFilter[] filters);
    [ObsoleteAttribute("Please use `GlobalConfiguration.UseFilter` instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseFilter(object filter);
    [ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard(string pathMatch)` OWIN extension method instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseDashboardPath(string path);
    [ObsoleteAttribute("Please use `IAppBuilder.UseHangfireDashboard("/hangfire", new DashboardOptions { AppPath = path })` OWIN extension method instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseAppPath(string path);
    [ObsoleteAttribute("Please use `GlobalConfiguration.UseStorage` instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseStorage(JobStorage storage);
    [ObsoleteAttribute("Please use `GlobalConfiguration.UseActivator` instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseActivator(JobActivator activator);
    [ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public abstract virtual void UseServer(Func`1<BackgroundJobServer> server);
}
public class Hangfire.IdempotentCompletionAttribute : JobFilterAttribute {
    public sealed virtual void OnStateElection(ElectStateContext context);
}
[EditorBrowsableAttribute("1")]
public interface Hangfire.IGlobalConfiguration {
}
[EditorBrowsableAttribute("1")]
public interface Hangfire.IGlobalConfiguration`1 {
    [EditorBrowsableAttribute("2")]
public T Entry { get; }
    public abstract virtual T get_Entry();
}
public interface Hangfire.IJobCancellationToken {
    public CancellationToken ShutdownToken { get; }
    public abstract virtual CancellationToken get_ShutdownToken();
    public abstract virtual void ThrowIfCancellationRequested();
}
public interface Hangfire.IRecurringJobManager {
    public abstract virtual void AddOrUpdate(string recurringJobId, Job job, string cronExpression, RecurringJobOptions options);
    public abstract virtual void Trigger(string recurringJobId);
    public abstract virtual void RemoveIfExists(string recurringJobId);
}
public interface Hangfire.IRecurringJobManagerV2 {
    [NotNullAttribute]
public JobStorage Storage { get; }
    public abstract virtual JobStorage get_Storage();
    [CanBeNullAttribute]
public abstract virtual string TriggerJob(string recurringJobId);
}
internal interface Hangfire.IStackTraceFormatter`1 {
    public T BeforeFrame { get; }
    public T AfterFrame { get; }
    public T BeforeParameters { get; }
    public T AfterParameters { get; }
    public abstract virtual T Text(string text);
    public abstract virtual T Type(T markup);
    public abstract virtual T Method(T markup);
    public abstract virtual T ParameterType(T markup);
    public abstract virtual T ParameterName(T markup);
    public abstract virtual T File(T markup);
    public abstract virtual T Line(T markup);
    public abstract virtual T get_BeforeFrame();
    public abstract virtual T get_AfterFrame();
    public abstract virtual T get_BeforeParameters();
    public abstract virtual T get_AfterParameters();
}
public interface Hangfire.ITimeZoneResolver {
    [NotNullAttribute]
public abstract virtual TimeZoneInfo GetTimeZoneById(string timeZoneId);
}
public class Hangfire.JobActivator : object {
    private static JobActivator _current;
    public static JobActivator Current { get; public set; }
    private static JobActivator();
    public static JobActivator get_Current();
    public static void set_Current(JobActivator value);
    public virtual object ActivateJob(Type jobType);
    [ObsoleteAttribute("Please implement/use the BeginScope(JobActivatorContext) method instead. Will be removed in 2.0.0.")]
public virtual JobActivatorScope BeginScope();
    public virtual JobActivatorScope BeginScope(JobActivatorContext context);
    public virtual JobActivatorScope BeginScope(PerformContext context);
}
public class Hangfire.JobActivatorContext : object {
    [CompilerGeneratedAttribute]
private BackgroundJob <BackgroundJob>k__BackingField;
    [CompilerGeneratedAttribute]
private IJobCancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [NotNullAttribute]
public BackgroundJob BackgroundJob { get; }
    [NotNullAttribute]
public IJobCancellationToken CancellationToken { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    public JobActivatorContext(IStorageConnection connection, BackgroundJob backgroundJob, IJobCancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public BackgroundJob get_BackgroundJob();
    [CompilerGeneratedAttribute]
public IJobCancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    public void SetJobParameter(string name, object value);
    public T GetJobParameter(string name);
    public T GetJobParameter(string name, bool allowStale);
}
public abstract class Hangfire.JobActivatorScope : object {
    private static ThreadLocal`1<JobActivatorScope> _current;
    [CompilerGeneratedAttribute]
private object <InnerScope>k__BackingField;
    public static JobActivatorScope Current { get; }
    [ObsoleteAttribute("This property wasn't implemented and will be removed in Hangfire 2.0.0.")]
public object InnerScope { get; public set; }
    private static JobActivatorScope();
    public static JobActivatorScope get_Current();
    [CompilerGeneratedAttribute]
public object get_InnerScope();
    [CompilerGeneratedAttribute]
public void set_InnerScope(object value);
    public abstract virtual object Resolve(Type type);
    public virtual void DisposeScope();
    public sealed virtual void Dispose();
}
public class Hangfire.JobCancellationToken : object {
    private bool _canceled;
    [CompilerGeneratedAttribute]
private CancellationToken <ShutdownToken>k__BackingField;
    public CancellationToken ShutdownToken { get; }
    public static IJobCancellationToken Null { get; }
    public JobCancellationToken(bool canceled);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_ShutdownToken();
    public static IJobCancellationToken get_Null();
    public sealed virtual void ThrowIfCancellationRequested();
}
[ExtensionAttribute]
internal static class Hangfire.JobCancellationTokenExtensions : object {
    [ExtensionAttribute]
public static bool IsAborted(IJobCancellationToken jobCancellationToken);
}
[FlagsAttribute]
public enum Hangfire.JobContinuationOptions : Enum {
    public int value__;
    public static JobContinuationOptions OnAnyFinishedState;
    public static JobContinuationOptions OnlyOnSucceededState;
    public static JobContinuationOptions OnlyOnDeletedState;
}
[AttributeUsageAttribute("64")]
public class Hangfire.JobDisplayNameAttribute : Attribute {
    private static ConcurrentDictionary`2<Type, ResourceManager> _resourceManagerCache;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceType>k__BackingField;
    public string DisplayName { get; }
    public Type ResourceType { get; public set; }
    public JobDisplayNameAttribute(string displayName);
    private static JobDisplayNameAttribute();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public Type get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(Type value);
    public virtual string Format(DashboardContext context, Job job);
    private static ResourceManager InitResourceManager(Type type);
}
public class Hangfire.JobParameterInjectionFilter : object {
    internal static string DefaultException;
    private static JobParameterInjectionFilter();
    public sealed virtual void OnPerforming(PerformingContext context);
    public sealed virtual void OnPerformed(PerformedContext context);
}
public abstract class Hangfire.JobStorage : object {
    private static object LockObject;
    private static JobStorage _current;
    private TimeSpan _jobExpirationTimeout;
    public static JobStorage Current { get; public set; }
    public TimeSpan JobExpirationTimeout { get; public set; }
    public bool LinearizableReads { get; }
    private static JobStorage();
    public static JobStorage get_Current();
    public static void set_Current(JobStorage value);
    public TimeSpan get_JobExpirationTimeout();
    public void set_JobExpirationTimeout(TimeSpan value);
    public virtual bool get_LinearizableReads();
    public abstract virtual IMonitoringApi GetMonitoringApi();
    public abstract virtual IStorageConnection GetConnection();
    public virtual IStorageConnection GetReadOnlyConnection();
    public virtual IEnumerable`1<IServerComponent> GetComponents();
    public virtual IEnumerable`1<IStateHandler> GetStateHandlers();
    public virtual void WriteOptionsToLog(ILog logger);
    public virtual bool HasFeature(string featureId);
}
public class Hangfire.LatencyTimeoutAttribute : JobFilterAttribute {
    private ILog _logger;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutInSeconds>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    public int TimeoutInSeconds { get; }
    public LatencyTimeoutAttribute(int timeoutInSeconds);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    public sealed virtual void OnStateElection(ElectStateContext context);
}
public interface Hangfire.Logging.ILog {
    public abstract virtual bool Log(LogLevel logLevel, Func`1<string> messageFunc, Exception exception);
}
public interface Hangfire.Logging.ILogProvider {
    public abstract virtual ILog GetLogger(string name);
}
[ExtensionAttribute]
public static class Hangfire.Logging.LogExtensions : object {
    [ExtensionAttribute]
public static bool IsDebugEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsErrorEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsFatalEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsInfoEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILog logger);
    [ExtensionAttribute]
public static bool IsWarnEnabled(ILog logger);
    [ExtensionAttribute]
public static void Debug(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Debug(ILog logger, string message);
    [ExtensionAttribute]
public static void DebugFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void DebugException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Error(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Error(ILog logger, string message);
    [ExtensionAttribute]
public static void ErrorFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void ErrorException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Fatal(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Fatal(ILog logger, string message);
    [ExtensionAttribute]
public static void FatalFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void FatalException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Info(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Info(ILog logger, string message);
    [ExtensionAttribute]
public static void InfoFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void InfoException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Trace(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Trace(ILog logger, string message);
    [ExtensionAttribute]
public static void TraceFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void TraceException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Warn(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Warn(ILog logger, string message);
    [ExtensionAttribute]
public static void WarnFormat(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void WarnException(ILog logger, string message, Exception exception);
    private static void GuardAgainstNullLogger(ILog logger);
    [ExtensionAttribute]
private static void LogFormat(ILog logger, LogLevel logLevel, string message, Object[] args);
    [ExtensionAttribute]
private static Func`1<T> AsFunc(T value);
    [ExtensionAttribute]
private static T Return(T value);
}
internal class Hangfire.Logging.LoggerExecutionWrapper : object {
    private ILog _logger;
    public static string FailedToGenerateLogMessage;
    public ILog WrappedLogger { get; }
    public LoggerExecutionWrapper(ILog logger);
    public ILog get_WrappedLogger();
    public sealed virtual bool Log(LogLevel logLevel, Func`1<string> messageFunc, Exception exception);
}
public enum Hangfire.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
}
public static class Hangfire.Logging.LogProvider : object {
    private static ILogProvider _currentLogProvider;
    internal static List`1<Tuple`2<IsLoggerAvailable, CreateLogProvider>> LogProviderResolvers;
    private static LogProvider();
    public static ILog For();
    public static ILog GetCurrentClassLogger();
    public static ILog GetLogger(Type type);
    public static ILog GetLogger(string name);
    public static void SetCurrentLogProvider(ILogProvider logProvider);
    private static ILogProvider ResolveLogProvider();
}
public class Hangfire.Logging.LogProviders.ColouredConsoleLogProvider : object {
    private LogLevel _minLevel;
    [CompilerGeneratedAttribute]
private static Dictionary`2<LogLevel, ConsoleColor> <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageFormatterDelegate <MessageFormatter>k__BackingField;
    public static Dictionary`2<LogLevel, ConsoleColor> Colors { get; public set; }
    public static MessageFormatterDelegate MessageFormatter { get; public set; }
    private static ColouredConsoleLogProvider();
    public ColouredConsoleLogProvider(LogLevel minLevel);
    public sealed virtual ILog GetLogger(string name);
    [CompilerGeneratedAttribute]
public static Dictionary`2<LogLevel, ConsoleColor> get_Colors();
    [CompilerGeneratedAttribute]
public static void set_Colors(Dictionary`2<LogLevel, ConsoleColor> value);
    [CompilerGeneratedAttribute]
public static MessageFormatterDelegate get_MessageFormatter();
    [CompilerGeneratedAttribute]
public static void set_MessageFormatter(MessageFormatterDelegate value);
    protected static string DefaultMessageFormatter(string loggerName, LogLevel level, object message, Exception e);
}
public class Hangfire.Logging.LogProviders.ElmahLogProvider : object {
    private static bool _providerIsAvailableOverride;
    private static LogLevel DefaultMinLevel;
    private Type _errorType;
    private LogLevel _minLevel;
    private Func`1<object> _getErrorLogDelegate;
    public static bool ProviderIsAvailableOverride { get; public set; }
    public ElmahLogProvider(LogLevel minLevel);
    private static ElmahLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static Type GetHttpContextType();
    private static Type GetErrorType();
    private static Func`1<object> GetGetErrorLogMethodCall();
}
public class Hangfire.Logging.LogProviders.EntLibLogProvider : object {
    private static string TypeTemplate;
    private static bool _providerIsAvailableOverride;
    private static Type LogEntryType;
    private static Type LoggerType;
    private Action`3<string, string, TraceEventType> WriteLogEntry;
    private Func`3<string, TraceEventType, bool> ShouldLogEntry;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static EntLibLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Action`3<string, string, TraceEventType> GetWriteLogEntry();
    private static Func`3<string, TraceEventType, bool> GetShouldLogEntry();
    private static MemberInitExpression GetWriteLogExpression(Expression message, ParameterExpression severityParameter, ParameterExpression logNameParameter);
}
public class Hangfire.Logging.LogProviders.Log4NetLogProvider : object {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private static bool _providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static Log4NetLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetGetLoggerMethodCall();
}
public class Hangfire.Logging.LogProviders.LoupeLogProvider : object {
    private static bool _providerIsAvailableOverride;
    private WriteDelegate _logWriteDelegate;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static LoupeLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static WriteDelegate GetLogWriteDelegate();
}
[CompilerGeneratedAttribute]
internal class Hangfire.Logging.LogProviders.NamespaceDoc : object {
}
public class Hangfire.Logging.LogProviders.NLogLogProvider : object {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private static bool _providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static NLogLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetGetLoggerMethodCall();
}
public class Hangfire.Logging.LogProviders.SerilogLogProvider : object {
    private Func`2<string, object> _getLoggerByNameDelegate;
    private SerilogCallbacks _callbacks;
    private static bool _providerIsAvailableOverride;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static SerilogLogProvider();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public sealed virtual ILog GetLogger(string name);
    public static bool IsLoggerAvailable();
    private static Type GetLogManagerType();
    private static Func`2<string, object> GetForContextMethodCall();
}
[CompilerGeneratedAttribute]
internal class Hangfire.Logging.NamespaceDoc : object {
}
[CompilerGeneratedAttribute]
internal class Hangfire.Logging.NamespaceGroupDoc : object {
}
public enum Hangfire.MisfireHandlingMode : Enum {
    public int value__;
    public static MisfireHandlingMode Relaxed;
    public static MisfireHandlingMode Strict;
    public static MisfireHandlingMode Ignorable;
}
[CompilerGeneratedAttribute]
internal class Hangfire.NamespaceDoc : object {
}
[ExtensionAttribute]
[ObsoleteAttribute("Please use `GlobalConfiguration` class for configuration, or `IAppBuilder.UseHangfireDashboard` and `IAppBuilder.UseHangfireServer` OWIN extension methods instead. Will be removed in version 2.0.0.")]
public static class Hangfire.OwinBootstrapper : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `GlobalConfiguration` class for configuration, or `IAppBuilder.UseHangfireDashboard` and `IAppBuilder.UseHangfireServer` OWIN extension methods instead. Will be removed in version 2.0.0.")]
public static void UseHangfire(IAppBuilder app, Action`1<IBootstrapperConfiguration> configurationAction);
}
internal static class Hangfire.Processing.AppDomainUnloadMonitor : object {
    private static int _initialized;
    private static bool _isUnloading;
    public static bool IsUnloading { get; }
    public static void EnsureInitialized();
    public static bool get_IsUnloading();
    private static void OnDomainUnload(object sender, EventArgs args);
}
internal class Hangfire.Processing.BackgroundDispatcher : object {
    private ILog _logger;
    private CountdownEvent _stopped;
    private IBackgroundExecution _execution;
    private Action`2<Guid, object> _action;
    private object _state;
    public BackgroundDispatcher(IBackgroundExecution execution, Action`2<Guid, object> action, object state, Func`2<ThreadStart, IEnumerable`1<Thread>> threadFactory);
    public sealed virtual bool Wait(TimeSpan timeout);
    [AsyncStateMachineAttribute("Hangfire.Processing.BackgroundDispatcher/<WaitAsync>d__7")]
public sealed virtual Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private void DispatchLoop();
}
internal class Hangfire.Processing.BackgroundDispatcherAsync : object {
    private ILog _logger;
    private CountdownEvent _stopped;
    private IBackgroundExecution _execution;
    private Func`3<Guid, object, Task> _action;
    private object _state;
    private TaskScheduler _taskScheduler;
    private bool _ownsScheduler;
    public BackgroundDispatcherAsync(IBackgroundExecution execution, Func`3<Guid, object, Task> action, object state, TaskScheduler taskScheduler, int maxConcurrency, bool ownsScheduler);
    public sealed virtual bool Wait(TimeSpan timeout);
    [AsyncStateMachineAttribute("Hangfire.Processing.BackgroundDispatcherAsync/<WaitAsync>d__9")]
public sealed virtual Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Hangfire.Processing.BackgroundDispatcherAsync/<DispatchLoop>d__12")]
private Task DispatchLoop();
}
internal class Hangfire.Processing.BackgroundExecution : object {
    private static TimeSpan FallbackRetryDelay;
    private ManualResetEvent _stopped;
    private Stopwatch _faultedSince;
    private Stopwatch _failedSince;
    private Stopwatch _lastException;
    private int _exceptionsCount;
    private CancellationToken _stopToken;
    private BackgroundExecutionOptions _options;
    private ILog _logger;
    private Stopwatch _createdAt;
    private Stopwatch _stoppedAt;
    private CancellationTokenRegistration _stopRegistration;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    public bool StopRequested { get; }
    public BackgroundExecution(BackgroundExecutionOptions options, CancellationToken stopToken);
    private static BackgroundExecution();
    public bool get_StopRequested();
    public sealed virtual void Run(Action`2<Guid, object> callback, object state);
    [AsyncStateMachineAttribute("Hangfire.Processing.BackgroundExecution/<RunAsync>d__17")]
public sealed virtual Task RunAsync(Func`3<Guid, object, Task> callback, object state);
    public sealed virtual void Dispose();
    public void NotifySucceeded();
    public virtual string ToString();
    private void HandleStarted(Guid executionId, TimeSpan& initialDelay);
    private bool HandleDelay(Guid executionId, TimeSpan delay);
    [AsyncStateMachineAttribute("Hangfire.Processing.BackgroundExecution/<HandleDelayAsync>d__23")]
private Task`1<bool> HandleDelayAsync(Guid executionId, TimeSpan delay);
    private void LogUnableWait(Guid executionId, TimeSpan delay, Exception ex);
    private void LogRetry(Guid executionId, TimeSpan delay);
    private void NormalizeDelay(TimeSpan& retryDelay);
    private void HandleSuccess(TimeSpan& nextDelay);
    private void HandleException(Guid executionId, Exception exception, TimeSpan& delay);
    private void HandleStop(Guid executionId);
    private void HandleThreadAbort(Guid executionId, Exception exception);
    private void ToRunningState();
    private void ToFailedState(Exception exception, TimeSpan& retryDelay);
    private string GetExecutionLoopTemplate(Guid executionId);
    private string GetExecutionTemplate();
    private void SetStoppedAt();
    [CompilerGeneratedAttribute]
private string <ToRunningState>b__31_0();
}
internal class Hangfire.Processing.BackgroundExecutionOptions : object {
    private static TimeSpan DefaultMaxAttemptDelay;
    private TimeSpan _warningThreshold;
    private TimeSpan _errorThreshold;
    private TimeSpan _stillErrorThreshold;
    private Func`2<int, TimeSpan> _retryDelay;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public TimeSpan WarningThreshold { get; public set; }
    public TimeSpan ErrorThreshold { get; public set; }
    public TimeSpan StillErrorThreshold { get; public set; }
    public Func`2<int, TimeSpan> RetryDelay { get; public set; }
    private static BackgroundExecutionOptions();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public TimeSpan get_WarningThreshold();
    public void set_WarningThreshold(TimeSpan value);
    public TimeSpan get_ErrorThreshold();
    public void set_ErrorThreshold(TimeSpan value);
    public TimeSpan get_StillErrorThreshold();
    public void set_StillErrorThreshold(TimeSpan value);
    public Func`2<int, TimeSpan> get_RetryDelay();
    public void set_RetryDelay(Func`2<int, TimeSpan> value);
    internal static TimeSpan GetBackOffMultiplier(int retryAttemptNumber);
}
public class Hangfire.Processing.BackgroundTaskScheduler : TaskScheduler {
    private ConcurrentQueue`1<Task> _queue;
    private Thread[] _threads;
    private HashSet`1<int> _ourThreadIds;
    private Semaphore _semaphore;
    private ManualResetEvent _stopped;
    private WaitHandle[] _waitHandles;
    private Action`1<Exception> _exceptionHandler;
    private int _disposed;
    public int MaximumConcurrencyLevel { get; }
    public BackgroundTaskScheduler(int threadCount);
    public BackgroundTaskScheduler(Func`2<ThreadStart, IEnumerable`1<Thread>> threadFactory, Action`1<Exception> exceptionHandler);
    public virtual int get_MaximumConcurrencyLevel();
    public sealed virtual void Dispose();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    private static IEnumerable`1<Thread> DefaultThreadFactory(ThreadStart threadStart, int threadCount);
    private static void DefaultExceptionHandler(Exception exception);
    private void DispatchLoop();
    private void InvokeUnhandledExceptionHandler(Exception exception);
    private void ThrowIfDisposed();
}
public interface Hangfire.Processing.IBackgroundDispatcher {
    public abstract virtual bool Wait(TimeSpan timeout);
    public abstract virtual Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
}
public interface Hangfire.Processing.IBackgroundExecution {
    public abstract virtual void Run(Action`2<Guid, object> callback, object state);
    public abstract virtual Task RunAsync(Func`3<Guid, object, Task> callback, object state);
}
internal class Hangfire.Processing.InlineSynchronizationContext : SynchronizationContext {
    private ConcurrentQueue`1<Tuple`2<SendOrPostCallback, object>> _queue;
    private Semaphore _semaphore;
    public WaitHandle WaitHandle { get; }
    public WaitHandle get_WaitHandle();
    public Tuple`2<SendOrPostCallback, object> Dequeue();
    public sealed virtual void Dispose();
    public virtual void Post(SendOrPostCallback callback, object state);
}
[ExtensionAttribute]
internal static class Hangfire.Processing.TaskExtensions : object {
    private static Type[] EmptyTypes;
    private static WaitHandle InvalidWaitHandleInstance;
    private static TaskExtensions();
    [ExtensionAttribute]
public static bool WaitOne(WaitHandle waitHandle, TimeSpan timeout, CancellationToken token);
    [AsyncStateMachineAttribute("Hangfire.Processing.TaskExtensions/<WaitOneAsync>d__3")]
[ExtensionAttribute]
public static Task`1<bool> WaitOneAsync(WaitHandle waitHandle, TimeSpan timeout, CancellationToken token);
    [ExtensionAttribute]
public static bool IsTaskLike(Type type, Func`2& getTaskFunc);
    [ExtensionAttribute]
public static object GetTaskLikeResult(Task task, object obj, Type returnType);
    private static void CallBack(object state, bool timedOut);
    private static void Callback(object state);
    private static TaskCompletionSource`1<T> CreateCompletionSource();
    private static void TrySetCanceled(TaskCompletionSource`1<T> source, CancellationToken token);
}
internal class Hangfire.Profiling.EmptyProfiler : object {
    internal static IProfiler Instance;
    private static EmptyProfiler();
    public sealed virtual TResult InvokeMeasured(TInstance instance, Func`2<TInstance, TResult> action, Func`2<TInstance, string> messageFunc);
}
internal interface Hangfire.Profiling.IProfiler {
    public abstract virtual TResult InvokeMeasured(TInstance instance, Func`2<TInstance, TResult> action, Func`2<TInstance, string> messageFunc);
}
[ExtensionAttribute]
internal static class Hangfire.Profiling.ProfilerExtensions : object {
    [ExtensionAttribute]
public static void InvokeMeasured(IProfiler profiler, TInstance instance, Action`1<TInstance> action, Func`2<TInstance, string> messageFunc);
    private static bool InvokeAction(InstanceAction`1<TInstance> tuple);
    private static string MessageCallback(InstanceAction`1<TInstance> action);
}
internal class Hangfire.Profiling.SlowLogProfiler : object {
    private static TimeSpan DefaultThreshold;
    private int _thresholdMs;
    private ILog _logger;
    public SlowLogProfiler(ILog logger);
    public SlowLogProfiler(ILog logger, TimeSpan threshold);
    private static SlowLogProfiler();
    public sealed virtual TResult InvokeMeasured(TInstance instance, Func`2<TInstance, TResult> action, Func`2<TInstance, string> messageFunc);
}
public class Hangfire.QueueAttribute : JobFilterAttribute {
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Queue { get; }
    public QueueAttribute(string queue);
    [CompilerGeneratedAttribute]
public string get_Queue();
    public sealed virtual void OnStateElection(ElectStateContext context);
}
public static class Hangfire.RecurringJob : object {
    private static Lazy`1<RecurringJobManager> Instance;
    private static RecurringJob();
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action`1<T>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Action`1<T>> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate(string, Expression<Action>, Func<string>, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate<T>(string, Expression<Action<T>>, Func<string>, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate(string, Expression<Action>, string, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action> methodCall, string cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate<T>(string, Expression<Action<T>>, string, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`1<Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`1<Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter and RecurringJobOptions instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`2<T, Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ObsoleteAttribute("Please use an overload with the explicit recurringJobId parameter instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(Expression`1<Func`2<T, Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate(string, Expression<Func<Task>>, Func<string>, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate<T>(string, Expression<Func<T, Task>>, Func<string>, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate(string, Expression<Func<Task>>, string, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ObsoleteAttribute("Please use AddOrUpdate<T>(string, Expression<Func<T, Task>>, string, RecurringJobOptions) instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, RecurringJobOptions options);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, string cronExpression);
    public static void AddOrUpdate(string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, RecurringJobOptions options);
    public static void RemoveIfExists(string recurringJobId);
    [ObsoleteAttribute("Please use the TriggerJob method instead. Will be removed in 2.0.0.")]
public static void Trigger(string recurringJobId);
    public static string TriggerJob(string recurringJobId);
    private static string GetRecurringJobId(Job job);
}
internal class Hangfire.RecurringJobEntity : object {
    private static Char[] SeparatorCharacters;
    private IDictionary`2<string, string> _recurringJob;
    [CompilerGeneratedAttribute]
private string <RecurringJobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Cron>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeZoneId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private MisfireHandlingMode <MisfireHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NextExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastJobId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public string RecurringJobId { get; }
    public string Queue { get; public set; }
    public string Cron { get; public set; }
    public string TimeZoneId { get; public set; }
    public string Job { get; public set; }
    public MisfireHandlingMode MisfireHandling { get; public set; }
    public Nullable`1<DateTime> CreatedAt { get; }
    public Nullable`1<DateTime> NextExecution { get; private set; }
    public Nullable`1<DateTime> LastExecution { get; public set; }
    public string LastJobId { get; public set; }
    public Nullable`1<int> Version { get; private set; }
    public int RetryAttempt { get; public set; }
    public string Error { get; public set; }
    public RecurringJobEntity(string recurringJobId, IDictionary`2<string, string> recurringJob);
    private static RecurringJobEntity();
    [CompilerGeneratedAttribute]
public string get_RecurringJobId();
    [CompilerGeneratedAttribute]
public string get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(string value);
    [CompilerGeneratedAttribute]
public string get_Cron();
    [CompilerGeneratedAttribute]
public void set_Cron(string value);
    [CompilerGeneratedAttribute]
public string get_TimeZoneId();
    [CompilerGeneratedAttribute]
public void set_TimeZoneId(string value);
    [CompilerGeneratedAttribute]
public string get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(string value);
    [CompilerGeneratedAttribute]
public MisfireHandlingMode get_MisfireHandling();
    [CompilerGeneratedAttribute]
public void set_MisfireHandling(MisfireHandlingMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreatedAt();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NextExecution();
    [CompilerGeneratedAttribute]
private void set_NextExecution(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastExecution();
    [CompilerGeneratedAttribute]
public void set_LastExecution(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_LastJobId();
    [CompilerGeneratedAttribute]
public void set_LastJobId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public void set_RetryAttempt(int value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    public void ScheduleNext(ITimeZoneResolver timeZoneResolver, DateTime from);
    public IEnumerable`1<DateTime> ScheduleNext(ITimeZoneResolver timeZoneResolver, DateTime from, DateTime now, TimeSpan precision);
    public bool IsChanged(DateTime now, IReadOnlyDictionary`2& changedFields);
    public void ScheduleRetry(DateTime nextAttempt, string error);
    public void Disable(string error);
    private IReadOnlyDictionary`2<string, string> GetChangedFields(DateTime now);
    public virtual string ToString();
    public static CronExpression ParseCronExpression(string cronExpression);
}
[ExtensionAttribute]
internal static class Hangfire.RecurringJobExtensions : object {
    [ExtensionAttribute]
public static IDisposable AcquireDistributedRecurringJobLock(IStorageConnection connection, string recurringJobId, TimeSpan timeout);
    [ExtensionAttribute]
public static RecurringJobEntity GetRecurringJob(IStorageConnection connection, string recurringJobId);
    [ExtensionAttribute]
public static RecurringJobEntity GetOrCreateRecurringJob(IStorageConnection connection, string recurringJobId);
    [ExtensionAttribute]
public static void UpdateRecurringJob(IWriteOnlyTransaction transaction, RecurringJobEntity recurringJob, IReadOnlyDictionary`2<string, string> changedFields, ILog logger);
    [ExtensionAttribute]
public static BackgroundJob TriggerRecurringJob(IBackgroundJobFactory factory, JobStorage storage, IStorageConnection connection, IProfiler profiler, RecurringJobEntity recurringJob, DateTime now);
    [ExtensionAttribute]
public static void EnqueueBackgroundJob(IStateMachine stateMachine, JobStorage storage, IStorageConnection connection, IWriteOnlyTransaction transaction, RecurringJobEntity recurringJob, BackgroundJob backgroundJob, string reason, IProfiler profiler);
}
public class Hangfire.RecurringJobManager : object {
    private static TimeSpan DefaultTimeout;
    private ILog _logger;
    private JobStorage _storage;
    private IBackgroundJobFactory _factory;
    private Func`1<DateTime> _nowFactory;
    private ITimeZoneResolver _timeZoneResolver;
    public JobStorage Storage { get; }
    public RecurringJobManager(JobStorage storage);
    public RecurringJobManager(JobStorage storage, IJobFilterProvider filterProvider);
    public RecurringJobManager(JobStorage storage, IJobFilterProvider filterProvider, ITimeZoneResolver timeZoneResolver);
    public RecurringJobManager(JobStorage storage, IJobFilterProvider filterProvider, ITimeZoneResolver timeZoneResolver, Func`1<DateTime> nowFactory);
    public RecurringJobManager(JobStorage storage, IBackgroundJobFactory factory);
    public RecurringJobManager(JobStorage storage, IBackgroundJobFactory factory, ITimeZoneResolver timeZoneResolver);
    internal RecurringJobManager(JobStorage storage, IBackgroundJobFactory factory, ITimeZoneResolver timeZoneResolver, Func`1<DateTime> nowFactory);
    private static RecurringJobManager();
    public sealed virtual JobStorage get_Storage();
    public sealed virtual void AddOrUpdate(string recurringJobId, Job job, string cronExpression, RecurringJobOptions options);
    private static void ValidateCronExpression(string cronExpression);
    public sealed virtual void Trigger(string recurringJobId);
    [ObsoleteAttribute("Please use the `TriggerJob` method instead. Will be removed in 2.0.0.")]
public string TriggerExecution(string recurringJobId);
    public sealed virtual string TriggerJob(string recurringJobId);
    public sealed virtual void RemoveIfExists(string recurringJobId);
}
[ExtensionAttribute]
public static class Hangfire.RecurringJobManagerExtensions : object {
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Job job, string cronExpression);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Job, string, RecurringJobOptions) method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Job job, string cronExpression, TimeZoneInfo timeZone);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Job, string, RecurringJobOptions) method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Job job, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Expression<Action>, Func<string>, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate<T>(string, Expression<Action<T>>, Func<string>, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Expression<Action>, string, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate<T>(string, Expression<Action<T>>, string, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Action`1<T>> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Action`1<T>> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Expression<Func<Task>>, Func<string>, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate<T>(string, Expression<Func<T, Task>>, Func<string>, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, Func`1<string> cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate(string, Expression<Func<Task>>, string, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`1<Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`1<Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the AddOrUpdate<T>(string, Expression<Func<T, Task>>, string, RecurringJobOptions) extension method instead. Will be removed in 2.0.0.")]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, TimeZoneInfo timeZone, string queue);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, RecurringJobOptions options);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, string cronExpression);
    [ExtensionAttribute]
public static void AddOrUpdate(IRecurringJobManager manager, string recurringJobId, string queue, Expression`1<Func`2<T, Task>> methodCall, string cronExpression, RecurringJobOptions options);
}
public class Hangfire.RecurringJobOptions : object {
    private TimeZoneInfo _timeZone;
    private string _queueName;
    [CompilerGeneratedAttribute]
private MisfireHandlingMode <MisfireHandling>k__BackingField;
    [NotNullAttribute]
public TimeZoneInfo TimeZone { get; public set; }
    [ObsoleteAttribute("Please use non-obsolete AddOrUpdate with the explicit `queue` parameter instead. Will be removed in 2.0.0.")]
[NotNullAttribute]
public string QueueName { get; public set; }
    public MisfireHandlingMode MisfireHandling { get; public set; }
    public TimeZoneInfo get_TimeZone();
    public void set_TimeZone(TimeZoneInfo value);
    public string get_QueueName();
    public void set_QueueName(string value);
    [CompilerGeneratedAttribute]
public MisfireHandlingMode get_MisfireHandling();
    [CompilerGeneratedAttribute]
public void set_MisfireHandling(MisfireHandlingMode value);
}
internal static class Hangfire.Server.AspNetShutdownDetector : object {
    private static TimeSpan CheckForShutdownTimerInterval;
    private static CancellationTokenSource CancellationTokenSource;
    private static int _isInitialized;
    private static bool _isSucceeded;
    private static Thread _checkForShutdownThread;
    private static Func`1<string> _shutdownReasonFunc;
    private static Func`1<bool> _checkConfigChangedFunc;
    private static Func`1<bool> _disposingHttpRuntime;
    public static bool IsSucceeded { get; }
    public static bool DisposingHttpRuntime { get; }
    private static AspNetShutdownDetector();
    public static bool get_IsSucceeded();
    public static CancellationToken GetShutdownToken();
    public static bool get_DisposingHttpRuntime();
    private static void EnsureInitialized();
    private static void CheckForAppDomainShutdown(object state);
    private static void Cancel(string reason);
    private static void RegisterForStopListeningEvent(Boolean& success);
    private static void StopListening(object sender, EventArgs e);
    private static void InitializeShutdownReason(Boolean& success);
    private static void InitializeMgdHasConfigChanged(Boolean& success);
    private static void InitializeDisposingHttpRuntime(Boolean& success);
    private static Func`1<T> CreateGetStaticFieldDelegate(FieldInfo fieldInfo);
    private static Func`2<object, T> CreateGetFieldDelegate(FieldInfo fieldInfo, Type type);
    private static ILog GetLogger();
}
public class Hangfire.Server.BackgroundJobPerformer : object {
    internal static string ContextCanceledKey;
    private IJobFilterProvider _filterProvider;
    private IBackgroundJobPerformer _innerPerformer;
    public BackgroundJobPerformer(IJobFilterProvider filterProvider);
    public BackgroundJobPerformer(IJobFilterProvider filterProvider, JobActivator activator);
    public BackgroundJobPerformer(IJobFilterProvider filterProvider, JobActivator activator, TaskScheduler taskScheduler);
    internal BackgroundJobPerformer(IJobFilterProvider filterProvider, IBackgroundJobPerformer innerPerformer);
    private static BackgroundJobPerformer();
    public sealed virtual object Perform(PerformContext context);
    private JobFilterInfo GetFilters(Job job);
    private object PerformJobWithFilters(PerformContext context, IEnumerable`1<IServerFilter> filters);
    private static PerformedContext InvokePerformFilter(IServerFilter filter, PerformingContext preContext, Func`1<PerformedContext> continuation);
    private static void InvokeOnPerforming(KeyValuePair`2<IServerFilter, PerformingContext> x);
    private static void InvokeOnPerformed(KeyValuePair`2<IServerFilter, PerformedContext> x);
    private static void InvokeServerExceptionFilters(ServerExceptionContext context, IEnumerable`1<IServerExceptionFilter> filters);
    private static void InvokeOnServerException(KeyValuePair`2<IServerExceptionFilter, ServerExceptionContext> x);
}
public class Hangfire.Server.BackgroundProcessContext : object {
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ExecutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <StoppingToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <StoppedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ShutdownToken>k__BackingField;
    [NotNullAttribute]
public string ServerId { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<string, object> Properties { get; }
    [NotNullAttribute]
public JobStorage Storage { get; }
    public Guid ExecutionId { get; }
    [ObsoleteAttribute("Please use the StoppingToken property instead, will be removed in 2.0.0.")]
public CancellationToken CancellationToken { get; }
    public CancellationToken StoppingToken { get; }
    public CancellationToken StoppedToken { get; }
    public CancellationToken ShutdownToken { get; }
    public bool IsStopping { get; }
    public bool IsStopped { get; }
    [ObsoleteAttribute("Please use IsStopping or IsStopped properties instead. Will be removed in 2.0.0.")]
public bool IsShutdownRequested { get; }
    [ObsoleteAttribute("This constructor overload is deprecated and will be removed in 2.0.0.")]
public BackgroundProcessContext(string serverId, JobStorage storage, IDictionary`2<string, object> properties, CancellationToken cancellationToken);
    public BackgroundProcessContext(string serverId, JobStorage storage, IDictionary`2<string, object> properties, Guid executionId, CancellationToken stoppingToken, CancellationToken stoppedToken, CancellationToken shutdownToken);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public Guid get_ExecutionId();
    public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public CancellationToken get_StoppingToken();
    [CompilerGeneratedAttribute]
public CancellationToken get_StoppedToken();
    [CompilerGeneratedAttribute]
public CancellationToken get_ShutdownToken();
    public bool get_IsStopping();
    public bool get_IsStopped();
    public bool get_IsShutdownRequested();
    public void Wait(TimeSpan timeout);
}
internal class Hangfire.Server.BackgroundProcessDispatcherBuilder : object {
    private IBackgroundProcess _process;
    private Func`2<ThreadStart, IEnumerable`1<Thread>> _threadFactory;
    public BackgroundProcessDispatcherBuilder(IBackgroundProcess process, Func`2<ThreadStart, IEnumerable`1<Thread>> threadFactory);
    public sealed virtual IBackgroundDispatcher Create(BackgroundServerContext context, BackgroundProcessingServerOptions options);
    public virtual string ToString();
    private static void ExecuteProcess(Guid executionId, object state);
}
internal class Hangfire.Server.BackgroundProcessDispatcherBuilderAsync : object {
    private int _maxConcurrency;
    private bool _ownsScheduler;
    private Func`1<TaskScheduler> _taskScheduler;
    private IBackgroundProcessAsync _process;
    public BackgroundProcessDispatcherBuilderAsync(IBackgroundProcessAsync process, Func`1<TaskScheduler> taskScheduler, int maxConcurrency, bool ownsScheduler);
    public sealed virtual IBackgroundDispatcher Create(BackgroundServerContext context, BackgroundProcessingServerOptions options);
    public virtual string ToString();
    [AsyncStateMachineAttribute("Hangfire.Server.BackgroundProcessDispatcherBuilderAsync/<ExecuteProcess>d__7")]
private static Task ExecuteProcess(Guid executionId, object state);
}
[ExtensionAttribute]
public static class Hangfire.Server.BackgroundProcessExtensions : object {
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcess process);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcess process, int threadCount);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcess process, int threadCount, Action`1<Thread> threadConfig);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcess process, Func`3<string, ThreadStart, IEnumerable`1<Thread>> threadFactory);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcessAsync process);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcessAsync process, int maxConcurrency);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcessAsync process, int maxConcurrency, int threadCount);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseBackgroundPool(IBackgroundProcessAsync process, int maxConcurrency, Func`3<string, ThreadStart, IEnumerable`1<Thread>> threadFactory);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseThreadPool(IBackgroundProcessAsync process);
    [ExtensionAttribute]
public static IBackgroundProcessDispatcherBuilder UseThreadPool(IBackgroundProcessAsync process, int maxConcurrency);
    [IteratorStateMachineAttribute("Hangfire.Server.BackgroundProcessExtensions/<DefaultThreadFactory>d__10")]
internal static IEnumerable`1<Thread> DefaultThreadFactory(int threadCount, string threadName, ThreadStart threadStart, Action`1<Thread> threadConfig);
}
public class Hangfire.Server.BackgroundProcessingServer : object {
    public static TimeSpan DefaultShutdownTimeout;
    private static int _lastThreadId;
    private ILog _logger;
    private CancellationTokenSource _stoppingCts;
    private CancellationTokenSource _stoppedCts;
    private CancellationTokenSource _shutdownCts;
    private CancellationTokenRegistration _shutdownRegistration;
    private IBackgroundServerProcess _process;
    private BackgroundProcessingServerOptions _options;
    private IBackgroundDispatcher _dispatcher;
    private int _disposed;
    private bool _awaited;
    public BackgroundProcessingServer(IEnumerable`1<IBackgroundProcess> processes);
    public BackgroundProcessingServer(IEnumerable`1<IBackgroundProcess> processes, IDictionary`2<string, object> properties);
    public BackgroundProcessingServer(JobStorage storage, IEnumerable`1<IBackgroundProcess> processes);
    public BackgroundProcessingServer(JobStorage storage, IEnumerable`1<IBackgroundProcess> processes, IDictionary`2<string, object> properties);
    public BackgroundProcessingServer(JobStorage storage, IEnumerable`1<IBackgroundProcess> processes, IDictionary`2<string, object> properties, BackgroundProcessingServerOptions options);
    public BackgroundProcessingServer(JobStorage storage, IEnumerable`1<IBackgroundProcessDispatcherBuilder> dispatcherBuilders, IDictionary`2<string, object> properties, BackgroundProcessingServerOptions options);
    internal BackgroundProcessingServer(BackgroundServerProcess process, BackgroundProcessingServerOptions options);
    private static BackgroundProcessingServer();
    public sealed virtual void SendStop();
    public sealed virtual bool WaitForShutdown(TimeSpan timeout);
    [AsyncStateMachineAttribute("Hangfire.Server.BackgroundProcessingServer/<WaitForShutdownAsync>d__21")]
public sealed virtual Task WaitForShutdownAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void OnCurrentDomainUnload(object sender, EventArgs args);
    private void OnAspNetShutdown();
    private static IBackgroundProcessDispatcherBuilder[] GetProcesses(IEnumerable`1<IBackgroundProcess> processes);
    private IBackgroundDispatcher CreateDispatcher();
    private void RunServer(Guid executionId, object state);
    [IteratorStateMachineAttribute("Hangfire.Server.BackgroundProcessingServer/<ThreadFactory>d__28")]
private static IEnumerable`1<Thread> ThreadFactory(ThreadStart threadStart);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private TimeSpan <CreateDispatcher>b__26_0(int retry);
}
public class Hangfire.Server.BackgroundProcessingServerOptions : object {
    internal static TimeSpan DefaultStopTimeout;
    internal static TimeSpan DefaultLastChanceTimeout;
    internal static TimeSpan DefaultHeartbeatInterval;
    private Func`2<int, TimeSpan> _retryDelay;
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ServerCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ServerTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CancellationCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeStorageProcesses>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <StopTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ShutdownTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LastChanceTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RestartDelay>k__BackingField;
    public TimeSpan HeartbeatInterval { get; public set; }
    public TimeSpan ServerCheckInterval { get; public set; }
    public TimeSpan ServerTimeout { get; public set; }
    public TimeSpan CancellationCheckInterval { get; public set; }
    public string ServerName { get; public set; }
    public bool ExcludeStorageProcesses { get; public set; }
    public Func`2<int, TimeSpan> RetryDelay { get; public set; }
    public TimeSpan StopTimeout { get; public set; }
    public TimeSpan ShutdownTimeout { get; public set; }
    public TimeSpan LastChanceTimeout { get; public set; }
    public TimeSpan RestartDelay { get; public set; }
    private static BackgroundProcessingServerOptions();
    [CompilerGeneratedAttribute]
public TimeSpan get_HeartbeatInterval();
    [CompilerGeneratedAttribute]
public void set_HeartbeatInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ServerCheckInterval();
    [CompilerGeneratedAttribute]
public void set_ServerCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ServerTimeout();
    [CompilerGeneratedAttribute]
public void set_ServerTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CancellationCheckInterval();
    [CompilerGeneratedAttribute]
public void set_CancellationCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeStorageProcesses();
    [CompilerGeneratedAttribute]
public void set_ExcludeStorageProcesses(bool value);
    public Func`2<int, TimeSpan> get_RetryDelay();
    public void set_RetryDelay(Func`2<int, TimeSpan> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_StopTimeout();
    [CompilerGeneratedAttribute]
public void set_StopTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ShutdownTimeout();
    [CompilerGeneratedAttribute]
public void set_ShutdownTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LastChanceTimeout();
    [CompilerGeneratedAttribute]
public void set_LastChanceTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RestartDelay();
    [CompilerGeneratedAttribute]
public void set_RestartDelay(TimeSpan value);
}
public class Hangfire.Server.BackgroundServerContext : object {
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <StoppingToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <StoppedToken>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ShutdownToken>k__BackingField;
    public string ServerId { get; }
    public JobStorage Storage { get; }
    public IDictionary`2<string, object> Properties { get; }
    public CancellationToken StoppingToken { get; }
    public CancellationToken StoppedToken { get; }
    public CancellationToken ShutdownToken { get; }
    public BackgroundServerContext(string serverId, JobStorage storage, IDictionary`2<string, object> properties, CancellationToken stoppingToken, CancellationToken stoppedToken, CancellationToken shutdownToken);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public CancellationToken get_StoppingToken();
    [CompilerGeneratedAttribute]
public CancellationToken get_StoppedToken();
    [CompilerGeneratedAttribute]
public CancellationToken get_ShutdownToken();
}
internal class Hangfire.Server.BackgroundServerProcess : object {
    private static Char[] ColonSeparator;
    private ILog _logger;
    private JobStorage _storage;
    private BackgroundProcessingServerOptions _options;
    private IDictionary`2<string, object> _properties;
    private IBackgroundProcessDispatcherBuilder[] _dispatcherBuilders;
    public BackgroundServerProcess(JobStorage storage, IEnumerable`1<IBackgroundProcessDispatcherBuilder> dispatcherBuilders, BackgroundProcessingServerOptions options, IDictionary`2<string, object> properties);
    private static BackgroundServerProcess();
    public sealed virtual void Execute(Guid executionId, BackgroundExecution execution, CancellationToken stoppingToken, CancellationToken stoppedToken, CancellationToken shutdownToken);
    private IBackgroundDispatcher CreateHeartbeatProcess(BackgroundServerContext context, Action requestRestart);
    [IteratorStateMachineAttribute("Hangfire.Server.BackgroundServerProcess/<GetRequiredProcesses>d__9")]
private IEnumerable`1<IBackgroundProcessDispatcherBuilder> GetRequiredProcesses();
    private IEnumerable`1<IBackgroundProcessDispatcherBuilder> GetStorageComponents();
    private string GetServerId();
    private void CreateServer(BackgroundServerContext context);
    private void ServerDelete(BackgroundServerContext context, Stopwatch stoppedAt);
    private void StartDispatchers(BackgroundServerContext context, ICollection`1<IBackgroundDispatcher> dispatchers);
    private void WaitForDispatchers(BackgroundServerContext context, IReadOnlyList`1<IBackgroundDispatcher> dispatchers);
    private static void DisposeDispatchers(IEnumerable`1<IBackgroundDispatcher> dispatchers);
    private static ServerContext GetServerContext(IDictionary`2<string, object> properties);
    internal static string GetServerTemplate(string serverId);
}
internal class Hangfire.Server.CoreBackgroundJobPerformer : object {
    internal static Dictionary`2<Type, Func`2<PerformContext, object>> Substitutions;
    private JobActivator _activator;
    private TaskScheduler _taskScheduler;
    public CoreBackgroundJobPerformer(JobActivator activator, TaskScheduler taskScheduler);
    private static CoreBackgroundJobPerformer();
    public sealed virtual object Perform(PerformContext context);
    internal static void HandleJobPerformanceException(Exception exception, IJobCancellationToken cancellationToken, BackgroundJob job);
    private object InvokeMethod(PerformContext context, object instance, Object[] arguments);
    private object InvokeOnTaskScheduler(PerformContext context, Tuple`3<MethodInfo, object, Object[]> tuple, Func`2<object, Task> getTaskFunc);
    private static object InvokeOnTaskPump(PerformContext context, Tuple`3<MethodInfo, object, Object[]> tuple, Func`2<object, Task> getTaskFunc);
    private static object InvokeSynchronously(object state);
    private static Object[] SubstituteArguments(PerformContext context);
}
public class Hangfire.Server.DelayedJobScheduler : object {
    public static TimeSpan DefaultPollingDelay;
    private static TimeSpan DefaultLockTimeout;
    private static int BatchSize;
    private static int MaxStateChangeAttempts;
    private ILog _logger;
    private ConcurrentDictionary`2<Type, bool> _isBatchingAvailableCache;
    private IBackgroundJobStateChanger _stateChanger;
    private IProfiler _profiler;
    private TimeSpan _pollingDelay;
    private bool _parallelismIssueLogged;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <TaskScheduler>k__BackingField;
    public int MaxDegreeOfParallelism { get; public set; }
    public TaskScheduler TaskScheduler { get; public set; }
    public DelayedJobScheduler(TimeSpan pollingDelay);
    public DelayedJobScheduler(TimeSpan pollingDelay, IBackgroundJobStateChanger stateChanger);
    private static DelayedJobScheduler();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public TaskScheduler get_TaskScheduler();
    [CompilerGeneratedAttribute]
public void set_TaskScheduler(TaskScheduler value);
    public sealed virtual void Execute(BackgroundProcessContext context);
    public virtual string ToString();
    private int EnqueueNextScheduledJobs(BackgroundProcessContext context);
    private static void EnqueueEntry(string entry, int colonIndex, IWriteOnlyTransaction transaction);
    private void EnqueueBackgroundJob(BackgroundProcessContext context, IStorageConnection connection, string jobId);
    private bool IsBatchingAvailable(JobStorage storage, IStorageConnection connection);
    private T UseConnectionDistributedLock(JobStorage storage, Func`2<IStorageConnection, T> action);
}
public interface Hangfire.Server.IBackgroundJobPerformer {
    public abstract virtual object Perform(PerformContext context);
}
public interface Hangfire.Server.IBackgroundProcess {
    public abstract virtual void Execute(BackgroundProcessContext context);
}
public interface Hangfire.Server.IBackgroundProcessAsync {
    public abstract virtual Task ExecuteAsync(BackgroundProcessContext context);
}
public interface Hangfire.Server.IBackgroundProcessDispatcherBuilder {
    public abstract virtual IBackgroundDispatcher Create(BackgroundServerContext context, BackgroundProcessingServerOptions options);
}
public interface Hangfire.Server.IBackgroundProcessingServer {
    public abstract virtual void SendStop();
    public abstract virtual bool WaitForShutdown(TimeSpan timeout);
    public abstract virtual Task WaitForShutdownAsync(CancellationToken cancellationToken);
}
internal interface Hangfire.Server.IBackgroundServerProcess {
    public abstract virtual void Execute(Guid executionId, BackgroundExecution execution, CancellationToken stoppingToken, CancellationToken stoppedToken, CancellationToken shutdownToken);
}
[ObsoleteAttribute("Please use the `IBackgroundProcess` interface where you can. Will be removed in 2.0.0.")]
public interface Hangfire.Server.IServerComponent {
    public abstract virtual void Execute(CancellationToken cancellationToken);
}
public interface Hangfire.Server.IServerExceptionFilter {
    public abstract virtual void OnServerException(ServerExceptionContext filterContext);
}
public interface Hangfire.Server.IServerFilter {
    public abstract virtual void OnPerforming(PerformingContext context);
    public abstract virtual void OnPerformed(PerformedContext context);
}
[ObsoleteAttribute("Please use the `IBackgroundProcess` interface where you can. Will be removed in 2.0.0.")]
public interface Hangfire.Server.IServerProcess {
}
public class Hangfire.Server.JobAbortedException : OperationCanceledException {
    protected JobAbortedException(SerializationInfo info, StreamingContext context);
}
public class Hangfire.Server.JobPerformanceException : Exception {
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    public string JobId { get; private set; }
    public JobPerformanceException(string message, Exception innerException);
    public JobPerformanceException(string message, Exception innerException, string jobId);
    protected JobPerformanceException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_JobId();
    [CompilerGeneratedAttribute]
private void set_JobId(string value);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Server.NamespaceDoc : object {
}
public class Hangfire.Server.PerformContext : object {
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundJob <BackgroundJob>k__BackingField;
    [CompilerGeneratedAttribute]
private IJobCancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IBackgroundJobPerformer <Performer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CanBeNullAttribute]
public JobStorage Storage { get; }
    [NotNullAttribute]
public IDictionary`2<string, object> Items { get; }
    [NotNullAttribute]
public BackgroundJob BackgroundJob { get; }
    [ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public string JobId { get; }
    [ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public Job Job { get; }
    [ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public DateTime CreatedAt { get; }
    [NotNullAttribute]
public IJobCancellationToken CancellationToken { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    [NotNullAttribute]
internal IProfiler Profiler { get; }
    [CanBeNullAttribute]
public IBackgroundJobPerformer Performer { get; internal set; }
    [CanBeNullAttribute]
public string ServerId { get; }
    public PerformContext(PerformContext context);
    [ObsoleteAttribute("Please use PerformContext(JobStorage, IStorageConnection, BackgroundJob, IJobCancellationToken) overload instead. Will be removed in 2.0.0.")]
public PerformContext(IStorageConnection connection, BackgroundJob backgroundJob, IJobCancellationToken cancellationToken);
    public PerformContext(JobStorage storage, IStorageConnection connection, BackgroundJob backgroundJob, IJobCancellationToken cancellationToken);
    internal PerformContext(JobStorage storage, IStorageConnection connection, BackgroundJob backgroundJob, IJobCancellationToken cancellationToken, IProfiler profiler, string serverId);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public BackgroundJob get_BackgroundJob();
    public string get_JobId();
    public Job get_Job();
    public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public IJobCancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    [CompilerGeneratedAttribute]
internal IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public IBackgroundJobPerformer get_Performer();
    [CompilerGeneratedAttribute]
internal void set_Performer(IBackgroundJobPerformer value);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    public void SetJobParameter(string name, object value);
    public T GetJobParameter(string name);
    public T GetJobParameter(string name, bool allowStale);
}
public class Hangfire.Server.PerformedContext : PerformContext {
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionHandled>k__BackingField;
    [CanBeNullAttribute]
public object Result { get; }
    public bool Canceled { get; }
    [CanBeNullAttribute]
public Exception Exception { get; }
    public bool ExceptionHandled { get; public set; }
    public PerformedContext(PerformContext context, object result, bool canceled, Exception exception);
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public bool get_ExceptionHandled();
    [CompilerGeneratedAttribute]
public void set_ExceptionHandled(bool value);
}
public class Hangfire.Server.PerformingContext : PerformContext {
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    public bool Canceled { get; public set; }
    public PerformingContext(PerformContext context);
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
public void set_Canceled(bool value);
}
public class Hangfire.Server.RecurringJobScheduler : object {
    private static TimeSpan LockTimeout;
    private static int BatchSize;
    private static int MaxRetryAttemptCount;
    private static int MaxSupportedVersion;
    private ILog _logger;
    private ConcurrentDictionary`2<Type, bool> _isBatchingAvailableCache;
    private IBackgroundJobFactory _factory;
    private Func`1<DateTime> _nowFactory;
    private ITimeZoneResolver _timeZoneResolver;
    private TimeSpan _pollingDelay;
    private IProfiler _profiler;
    private bool _parallelismIssueLogged;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <TaskScheduler>k__BackingField;
    public int MaxDegreeOfParallelism { get; public set; }
    public TaskScheduler TaskScheduler { get; public set; }
    public RecurringJobScheduler(IBackgroundJobFactory factory);
    public RecurringJobScheduler(IBackgroundJobFactory factory, TimeSpan pollingDelay);
    public RecurringJobScheduler(IBackgroundJobFactory factory, TimeSpan pollingDelay, ITimeZoneResolver timeZoneResolver);
    public RecurringJobScheduler(IBackgroundJobFactory factory, TimeSpan pollingDelay, ITimeZoneResolver timeZoneResolver, Func`1<DateTime> nowFactory);
    private static RecurringJobScheduler();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public TaskScheduler get_TaskScheduler();
    [CompilerGeneratedAttribute]
public void set_TaskScheduler(TaskScheduler value);
    public sealed virtual void Execute(BackgroundProcessContext context);
    public virtual string ToString();
    private int EnqueueNextRecurringJobs(BackgroundProcessContext context);
    private void TryEnqueueBackgroundJob(BackgroundProcessContext context, IStorageConnection connection, string recurringJobId, DateTime now);
    private void ScheduleRecurringJob(BackgroundProcessContext context, IStorageConnection connection, string recurringJobId, RecurringJobEntity recurringJob, DateTime now);
    private void RetryRecurringJob(string recurringJobId, RecurringJobEntity recurringJob, DateTime now, Exception error);
    private void RemoveRecurringJob(IStorageConnection connection, string recurringJobId);
    private T UseConnectionDistributedLock(JobStorage storage, Func`2<IStorageConnection, T> action);
    private bool IsBatchingAvailable(JobStorage storage, IStorageConnection connection);
}
public class Hangfire.Server.ServerContext : object {
    [CompilerGeneratedAttribute]
private int <WorkerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Queues>k__BackingField;
    public int WorkerCount { get; public set; }
    public String[] Queues { get; public set; }
    [CompilerGeneratedAttribute]
public int get_WorkerCount();
    [CompilerGeneratedAttribute]
public void set_WorkerCount(int value);
    [CompilerGeneratedAttribute]
public String[] get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(String[] value);
}
public class Hangfire.Server.ServerExceptionContext : PerformContext {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionHandled>k__BackingField;
    public Exception Exception { get; }
    public bool ExceptionHandled { get; public set; }
    public ServerExceptionContext(PerformContext context, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public bool get_ExceptionHandled();
    [CompilerGeneratedAttribute]
public void set_ExceptionHandled(bool value);
}
internal class Hangfire.Server.ServerHeartbeatProcess : object {
    private ILog _logger;
    private TimeSpan _interval;
    private TimeSpan _serverTimeout;
    private Action _requestRestart;
    private Stopwatch _faultedSince;
    public ServerHeartbeatProcess(TimeSpan interval, TimeSpan serverTimeout, Action requestRestart);
    public sealed virtual void Execute(BackgroundProcessContext context);
}
internal class Hangfire.Server.ServerJobCancellationToken : object {
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<ServerJobCancellationToken, object>> WatchedServers;
    private object _syncRoot;
    private string _jobId;
    private string _serverId;
    private string _workerId;
    private IStorageConnection _connection;
    private CancellationToken _shutdownToken;
    private Lazy`1<CancellationTokenHolder> _cancellationTokenHolder;
    private ConcurrentDictionary`2<ServerJobCancellationToken, object> _watchedTokens;
    private bool _disposed;
    public CancellationToken ShutdownToken { get; }
    public bool IsAborted { get; }
    public ServerJobCancellationToken(IStorageConnection connection, string jobId, string serverId, string workerId, CancellationToken shutdownToken);
    private static ServerJobCancellationToken();
    public sealed virtual void Dispose();
    public sealed virtual CancellationToken get_ShutdownToken();
    public bool get_IsAborted();
    public sealed virtual void ThrowIfCancellationRequested();
    public static void AddServer(string serverId);
    public static void RemoveServer(string serverId);
    public static IEnumerable`1<Tuple`2<string, string>> CheckAllCancellationTokens(string serverId, IStorageConnection connection, CancellationToken cancellationToken);
    public bool TryCheckJobIsAborted(IStorageConnection connection);
    private bool CheckJobStateChanged(IStorageConnection connection);
    private bool IsJobStateChanged(IStorageConnection connection);
    private void CheckDisposed();
    [CompilerGeneratedAttribute]
private CancellationTokenHolder <.ctor>b__10_0();
}
internal class Hangfire.Server.ServerJobCancellationWatcher : object {
    public static TimeSpan DefaultCheckInterval;
    private ILog _logger;
    private TimeSpan _checkInterval;
    public ServerJobCancellationWatcher(TimeSpan checkInterval);
    private static ServerJobCancellationWatcher();
    public sealed virtual void Execute(BackgroundProcessContext context);
    public virtual string ToString();
}
[ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static class Hangfire.Server.ServerOwinExtensions : object {
    private static ConcurrentBag`1<BackgroundJobServer> Servers;
    private static ServerOwinExtensions();
    [ExtensionAttribute]
[ObsoleteAttribute("Please use `IAppBuilder.UseHangfireServer` OWIN extension method instead. Will be removed in version 2.0.0.")]
public static void RunHangfireServer(IAppBuilder app, BackgroundJobServer server);
}
internal class Hangfire.Server.ServerProcessDispatcherBuilder : object {
    private IServerComponent _component;
    private Func`2<ThreadStart, IEnumerable`1<Thread>> _threadFactory;
    public ServerProcessDispatcherBuilder(IServerComponent component, Func`2<ThreadStart, IEnumerable`1<Thread>> threadFactory);
    public sealed virtual IBackgroundDispatcher Create(BackgroundServerContext context, BackgroundProcessingServerOptions options);
    public virtual string ToString();
    private static void ExecuteComponent(Guid executionId, object state);
}
internal class Hangfire.Server.ServerWatchdog : object {
    public static TimeSpan DefaultCheckInterval;
    public static TimeSpan DefaultServerTimeout;
    public static TimeSpan MaxServerTimeout;
    public static TimeSpan MaxServerCheckInterval;
    public static TimeSpan MaxHeartbeatInterval;
    private ILog _logger;
    private TimeSpan _checkInterval;
    private TimeSpan _serverTimeout;
    public ServerWatchdog(TimeSpan checkInterval, TimeSpan serverTimeout);
    private static ServerWatchdog();
    public sealed virtual void Execute(BackgroundProcessContext context);
    public virtual string ToString();
}
[ObsoleteAttribute("Please use `BackgroundJobServerOptions` properties instead. Will be removed in 2.0.0.")]
public class Hangfire.Server.ServerWatchdogOptions : object {
    private TimeSpan _serverTimeout;
    private TimeSpan _checkInterval;
    public TimeSpan ServerTimeout { get; public set; }
    public TimeSpan CheckInterval { get; public set; }
    public TimeSpan get_ServerTimeout();
    public void set_ServerTimeout(TimeSpan value);
    public TimeSpan get_CheckInterval();
    public void set_CheckInterval(TimeSpan value);
}
public class Hangfire.Server.Worker : object {
    [ObsoleteAttribute("Please use JobStorageFeatures.StorageTransactionalAcknowledge instead.")]
public static string TransactionalAcknowledgePrefix;
    private TimeSpan _jobInitializationWaitTimeout;
    private int _maxStateChangeAttempts;
    private ILog _logger;
    private IEnumerable`1<string> _queues;
    private IBackgroundJobPerformer _performer;
    private IBackgroundJobStateChanger _stateChanger;
    private IProfiler _profiler;
    public Worker(String[] queues);
    public Worker(IEnumerable`1<string> queues, IBackgroundJobPerformer performer, IBackgroundJobStateChanger stateChanger);
    internal Worker(IEnumerable`1<string> queues, IBackgroundJobPerformer performer, IBackgroundJobStateChanger stateChanger, TimeSpan jobInitializationTimeout, int maxStateChangeAttempts);
    private static Worker();
    public sealed virtual void Execute(BackgroundProcessContext context);
    private IState TryChangeState(BackgroundProcessContext context, IStorageConnection connection, string jobId, IState state, IReadOnlyDictionary`2<string, object> customData, String[] expectedStates, IFetchedJob completeJob, BackgroundJob& backgroundJob, CancellationToken initializeToken, CancellationToken abortToken);
    private void Requeue(IFetchedJob fetchedJob);
    private IState PerformJob(BackgroundProcessContext context, IStorageConnection connection, string jobId, BackgroundJob backgroundJob, IReadOnlyDictionary`2& customData);
}
internal static class Hangfire.StackTraceFormatter : object {
    private static StackTraceHtmlFragments DefaultStackTraceHtmlFragments;
    private static StackTraceFormatter();
    public static string FormatHtml(string text, IStackTraceFormatter`1<string> formatter);
    public static IEnumerable`1<T> Format(string text, IStackTraceFormatter`1<T> formatter);
}
internal class Hangfire.StackTraceHtmlFragments : object {
    [CompilerGeneratedAttribute]
private string <BeforeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterParameters>k__BackingField;
    public string BeforeType { get; public set; }
    public string AfterType { get; public set; }
    public string BeforeMethod { get; public set; }
    public string AfterMethod { get; public set; }
    public string BeforeParameterType { get; public set; }
    public string AfterParameterType { get; public set; }
    public string BeforeParameterName { get; public set; }
    public string AfterParameterName { get; public set; }
    public string BeforeFile { get; public set; }
    public string AfterFile { get; public set; }
    public string BeforeLine { get; public set; }
    public string AfterLine { get; public set; }
    public string BeforeFrame { get; public set; }
    public string AfterFrame { get; public set; }
    public string BeforeParameters { get; public set; }
    public string AfterParameters { get; public set; }
    private string Hangfire.IStackTraceFormatter<System.String>.BeforeFrame { get; }
    private string Hangfire.IStackTraceFormatter<System.String>.AfterFrame { get; }
    private string Hangfire.IStackTraceFormatter<System.String>.BeforeParameters { get; }
    private string Hangfire.IStackTraceFormatter<System.String>.AfterParameters { get; }
    [CompilerGeneratedAttribute]
public string get_BeforeType();
    [CompilerGeneratedAttribute]
public void set_BeforeType(string value);
    [CompilerGeneratedAttribute]
public string get_AfterType();
    [CompilerGeneratedAttribute]
public void set_AfterType(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeMethod();
    [CompilerGeneratedAttribute]
public void set_BeforeMethod(string value);
    [CompilerGeneratedAttribute]
public string get_AfterMethod();
    [CompilerGeneratedAttribute]
public void set_AfterMethod(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeParameterType();
    [CompilerGeneratedAttribute]
public void set_BeforeParameterType(string value);
    [CompilerGeneratedAttribute]
public string get_AfterParameterType();
    [CompilerGeneratedAttribute]
public void set_AfterParameterType(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeParameterName();
    [CompilerGeneratedAttribute]
public void set_BeforeParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_AfterParameterName();
    [CompilerGeneratedAttribute]
public void set_AfterParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeFile();
    [CompilerGeneratedAttribute]
public void set_BeforeFile(string value);
    [CompilerGeneratedAttribute]
public string get_AfterFile();
    [CompilerGeneratedAttribute]
public void set_AfterFile(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeLine();
    [CompilerGeneratedAttribute]
public void set_BeforeLine(string value);
    [CompilerGeneratedAttribute]
public string get_AfterLine();
    [CompilerGeneratedAttribute]
public void set_AfterLine(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeFrame();
    [CompilerGeneratedAttribute]
public void set_BeforeFrame(string value);
    [CompilerGeneratedAttribute]
public string get_AfterFrame();
    [CompilerGeneratedAttribute]
public void set_AfterFrame(string value);
    [CompilerGeneratedAttribute]
public string get_BeforeParameters();
    [CompilerGeneratedAttribute]
public void set_BeforeParameters(string value);
    [CompilerGeneratedAttribute]
public string get_AfterParameters();
    [CompilerGeneratedAttribute]
public void set_AfterParameters(string value);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.Text(string text);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.Type(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.Method(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.ParameterType(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.ParameterName(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.File(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.Line(string markup);
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.get_BeforeFrame();
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.get_AfterFrame();
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.get_BeforeParameters();
    private sealed virtual override string Hangfire.IStackTraceFormatter<System.String>.get_AfterParameters();
}
internal class Hangfire.StackTraceParser : object {
    private static string Space;
    private static string NotSpace;
    private static Regex Regex;
    private static StackTraceParser();
    public static IEnumerable`1<T> Parse(string text, Func`8<string, string, string, string, IEnumerable`1<KeyValuePair`2<string, string>>, string, string, T> selector);
    public static IEnumerable`1<TFrame> Parse(string text, Func`4<int, int, string, TToken> tokenSelector, Func`3<TToken, TToken, TMethod> methodSelector, Func`3<TToken, TToken, TParameter> parameterSelector, Func`3<TToken, IEnumerable`1<TParameter>, TParameters> parametersSelector, Func`3<TToken, TToken, TSourceLocation> sourceLocationSelector, Func`5<TToken, TMethod, TParameters, TSourceLocation, TFrame> selector);
    private static T Token(Capture capture, Func`4<int, int, string, T> tokenSelector);
}
public class Hangfire.States.ApplyStateContext : StateContext {
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriteOnlyTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundJob <BackgroundJob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldStateName>k__BackingField;
    [CompilerGeneratedAttribute]
private IState <NewState>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <JobExpirationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <CustomData>k__BackingField;
    [CompilerGeneratedAttribute]
private IStateMachine <StateMachine>k__BackingField;
    [NotNullAttribute]
public JobStorage Storage { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    [NotNullAttribute]
public IWriteOnlyTransaction Transaction { get; }
    public BackgroundJob BackgroundJob { get; }
    [CanBeNullAttribute]
public string OldStateName { get; }
    [NotNullAttribute]
public IState NewState { get; }
    public TimeSpan JobExpirationTimeout { get; public set; }
    [NotNullAttribute]
internal IProfiler Profiler { get; }
    [CanBeNullAttribute]
public IReadOnlyDictionary`2<string, object> CustomData { get; }
    [CanBeNullAttribute]
public IStateMachine StateMachine { get; }
    public ApplyStateContext(IWriteOnlyTransaction transaction, ElectStateContext context);
    public ApplyStateContext(JobStorage storage, IStorageConnection connection, IWriteOnlyTransaction transaction, BackgroundJob backgroundJob, IState newState, string oldStateName);
    internal ApplyStateContext(JobStorage storage, IStorageConnection connection, IWriteOnlyTransaction transaction, BackgroundJob backgroundJob, IState newState, string oldStateName, IProfiler profiler, IStateMachine stateMachine, IReadOnlyDictionary`2<string, object> customData);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    [CompilerGeneratedAttribute]
public IWriteOnlyTransaction get_Transaction();
    [CompilerGeneratedAttribute]
public virtual BackgroundJob get_BackgroundJob();
    [CompilerGeneratedAttribute]
public string get_OldStateName();
    [CompilerGeneratedAttribute]
public IState get_NewState();
    [CompilerGeneratedAttribute]
public TimeSpan get_JobExpirationTimeout();
    [CompilerGeneratedAttribute]
public void set_JobExpirationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
internal IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public IStateMachine get_StateMachine();
    public T GetJobParameter(string name);
    public T GetJobParameter(string name, bool allowStale);
}
public class Hangfire.States.AwaitingState : object {
    private static TimeSpan DefaultExpiration;
    public static string StateName;
    [CompilerGeneratedAttribute]
private string <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private IState <NextState>k__BackingField;
    [CompilerGeneratedAttribute]
private JobContinuationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Expiration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [NotNullAttribute]
public string ParentId { get; }
    [NotNullAttribute]
public IState NextState { get; }
    public JobContinuationOptions Options { get; }
    [JsonIgnoreAttribute]
public TimeSpan Expiration { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    public AwaitingState(string parentId);
    public AwaitingState(string parentId, IState nextState);
    [JsonConstructorAttribute]
public AwaitingState(string parentId, IState nextState, JobContinuationOptions options);
    public AwaitingState(string parentId, IState nextState, JobContinuationOptions options, TimeSpan expiration);
    private static AwaitingState();
    [CompilerGeneratedAttribute]
public string get_ParentId();
    [CompilerGeneratedAttribute]
public IState get_NextState();
    [CompilerGeneratedAttribute]
public JobContinuationOptions get_Options();
    [CompilerGeneratedAttribute]
public TimeSpan get_Expiration();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public class Hangfire.States.BackgroundJobStateChanger : object {
    private static TimeSpan JobLockTimeout;
    private StateMachine _stateMachine;
    public BackgroundJobStateChanger(IJobFilterProvider filterProvider);
    public BackgroundJobStateChanger(StateMachine stateMachine);
    internal BackgroundJobStateChanger(IJobFilterProvider filterProvider, IStateMachine stateMachine);
    private static BackgroundJobStateChanger();
    public sealed virtual IState ChangeState(StateChangeContext context);
    private static JobData GetJobData(StateChangeContext context);
}
internal class Hangfire.States.CoreStateMachine : object {
    private Func`3<JobStorage, string, IEnumerable`1<IStateHandler>> _stateHandlersThunk;
    internal CoreStateMachine(Func`3<JobStorage, string, IEnumerable`1<IStateHandler>> stateHandlersThunk);
    public sealed virtual IState ApplyState(ApplyStateContext context);
    [IteratorStateMachineAttribute("Hangfire.States.CoreStateMachine/<GetStateHandlers>d__4")]
private static IEnumerable`1<IStateHandler> GetStateHandlers(JobStorage storage, string stateName);
}
public class Hangfire.States.DeletedState : object {
    public static Exception DefaultException;
    public static string StateName;
    [CompilerGeneratedAttribute]
private ExceptionInfo <ExceptionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DeletedAt>k__BackingField;
    [JsonPropertyAttribute]
public ExceptionInfo ExceptionInfo { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    [JsonIgnoreAttribute]
public DateTime DeletedAt { get; }
    public DeletedState(ExceptionInfo exceptionInfo);
    private static DeletedState();
    [CompilerGeneratedAttribute]
public ExceptionInfo get_ExceptionInfo();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    [CompilerGeneratedAttribute]
public DateTime get_DeletedAt();
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public class Hangfire.States.ElectStateContext : StateContext {
    private IList`1<IState> _traversedStates;
    private IState _candidateState;
    [CompilerGeneratedAttribute]
private BackgroundJob <BackgroundJob>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriteOnlyTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <CustomData>k__BackingField;
    [CompilerGeneratedAttribute]
private StateMachine <StateMachine>k__BackingField;
    public BackgroundJob BackgroundJob { get; }
    [NotNullAttribute]
public JobStorage Storage { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    [NotNullAttribute]
public IWriteOnlyTransaction Transaction { get; }
    [NotNullAttribute]
public IState CandidateState { get; public set; }
    [CanBeNullAttribute]
public string CurrentState { get; }
    [NotNullAttribute]
public IState[] TraversedStates { get; }
    [NotNullAttribute]
internal IProfiler Profiler { get; }
    [CanBeNullAttribute]
public IDictionary`2<string, object> CustomData { get; }
    [CanBeNullAttribute]
public StateMachine StateMachine { get; }
    public ElectStateContext(ApplyStateContext applyContext);
    public ElectStateContext(ApplyStateContext applyContext, StateMachine stateMachine);
    [CompilerGeneratedAttribute]
public virtual BackgroundJob get_BackgroundJob();
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    [CompilerGeneratedAttribute]
public IWriteOnlyTransaction get_Transaction();
    public IState get_CandidateState();
    public void set_CandidateState(IState value);
    [CompilerGeneratedAttribute]
public string get_CurrentState();
    public IState[] get_TraversedStates();
    [CompilerGeneratedAttribute]
internal IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public StateMachine get_StateMachine();
    public void SetJobParameter(string name, T value);
    public T GetJobParameter(string name);
    public T GetJobParameter(string name, bool allowStale);
}
public class Hangfire.States.EnqueuedState : object {
    private static Regex ValidationRegex;
    public static string DefaultQueue;
    public static string StateName;
    private string _queue;
    [CompilerGeneratedAttribute]
private DateTime <EnqueuedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [NotNullAttribute]
public string Queue { get; public set; }
    [JsonIgnoreAttribute]
public DateTime EnqueuedAt { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    [JsonConstructorAttribute]
public EnqueuedState(string queue);
    private static EnqueuedState();
    public string get_Queue();
    public void set_Queue(string value);
    [CompilerGeneratedAttribute]
public DateTime get_EnqueuedAt();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    public sealed virtual Dictionary`2<string, string> SerializeData();
    internal static bool TryValidateQueueName(string value);
    internal static void ValidateQueueName(string parameterName, string value);
}
public class Hangfire.States.FailedState : object {
    internal static Nullable`1<int> MaxLinesInExceptionDetails;
    public static string StateName;
    [CompilerGeneratedAttribute]
private DateTime <FailedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxLinesInStackTrace>k__BackingField;
    [JsonIgnoreAttribute]
public DateTime FailedAt { get; }
    public Exception Exception { get; }
    [JsonPropertyAttribute]
public string ServerId { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    [JsonIgnoreAttribute]
public Nullable`1<int> MaxLinesInStackTrace { get; public set; }
    public FailedState(Exception exception);
    public FailedState(Exception exception, string serverId);
    private static FailedState();
    [CompilerGeneratedAttribute]
public DateTime get_FailedAt();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_ServerId();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxLinesInStackTrace();
    [CompilerGeneratedAttribute]
public void set_MaxLinesInStackTrace(Nullable`1<int> value);
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public interface Hangfire.States.IApplyStateFilter {
    public abstract virtual void OnStateApplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
    public abstract virtual void OnStateUnapplied(ApplyStateContext context, IWriteOnlyTransaction transaction);
}
public interface Hangfire.States.IBackgroundJobStateChanger {
    public abstract virtual IState ChangeState(StateChangeContext context);
}
public interface Hangfire.States.IElectStateFilter {
    public abstract virtual void OnStateElection(ElectStateContext context);
}
public interface Hangfire.States.IState {
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public string Reason { get; }
    public bool IsFinal { get; }
    public bool IgnoreJobLoadException { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Reason();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IgnoreJobLoadException();
    [NotNullAttribute]
public abstract virtual Dictionary`2<string, string> SerializeData();
}
public interface Hangfire.States.IStateHandler {
    public string StateName { get; }
    public abstract virtual string get_StateName();
    public abstract virtual void Apply(ApplyStateContext context, IWriteOnlyTransaction transaction);
    public abstract virtual void Unapply(ApplyStateContext context, IWriteOnlyTransaction transaction);
}
public interface Hangfire.States.IStateMachine {
    public abstract virtual IState ApplyState(ApplyStateContext context);
}
[CompilerGeneratedAttribute]
internal class Hangfire.States.NamespaceDoc : object {
}
public class Hangfire.States.ProcessingState : object {
    public static string StateName;
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [JsonIgnoreAttribute]
public DateTime StartedAt { get; }
    public string ServerId { get; }
    public string WorkerId { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    internal ProcessingState(string serverId, string workerId);
    private static ProcessingState();
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public class Hangfire.States.ScheduledState : object {
    public static string StateName;
    [CompilerGeneratedAttribute]
private DateTime <EnqueueAt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ScheduledAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public DateTime EnqueueAt { get; }
    [JsonIgnoreAttribute]
public DateTime ScheduledAt { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    public ScheduledState(TimeSpan enqueueIn);
    [JsonConstructorAttribute]
public ScheduledState(DateTime enqueueAt);
    private static ScheduledState();
    [CompilerGeneratedAttribute]
public DateTime get_EnqueueAt();
    [CompilerGeneratedAttribute]
public DateTime get_ScheduledAt();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public class Hangfire.States.StateChangeContext : object {
    [CompilerGeneratedAttribute]
private JobStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStorageTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackgroundJobId>k__BackingField;
    [CompilerGeneratedAttribute]
private IState <NewState>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpectedStates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <CustomData>k__BackingField;
    [CompilerGeneratedAttribute]
private IFetchedJob <CompleteJob>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundJob <ProcessedJob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [NotNullAttribute]
public JobStorage Storage { get; }
    [NotNullAttribute]
public IStorageConnection Connection { get; }
    [CanBeNullAttribute]
public JobStorageTransaction Transaction { get; }
    [NotNullAttribute]
public string BackgroundJobId { get; }
    [NotNullAttribute]
public IState NewState { get; }
    [CanBeNullAttribute]
public IEnumerable`1<string> ExpectedStates { get; }
    public bool DisableFilters { get; }
    public CancellationToken CancellationToken { get; }
    [NotNullAttribute]
internal IProfiler Profiler { get; }
    [CanBeNullAttribute]
public IReadOnlyDictionary`2<string, object> CustomData { get; }
    [CanBeNullAttribute]
public IFetchedJob CompleteJob { get; }
    [CanBeNullAttribute]
public BackgroundJob ProcessedJob { get; public set; }
    [CanBeNullAttribute]
public string ServerId { get; public set; }
    public StateChangeContext(JobStorage storage, IStorageConnection connection, string backgroundJobId, IState newState);
    public StateChangeContext(JobStorage storage, IStorageConnection connection, string backgroundJobId, IState newState, String[] expectedStates);
    public StateChangeContext(JobStorage storage, IStorageConnection connection, string backgroundJobId, IState newState, IEnumerable`1<string> expectedStates, CancellationToken cancellationToken);
    public StateChangeContext(JobStorage storage, IStorageConnection connection, JobStorageTransaction transaction, string backgroundJobId, IState newState, IEnumerable`1<string> expectedStates, CancellationToken cancellationToken);
    internal StateChangeContext(JobStorage storage, IStorageConnection connection, string backgroundJobId, IState newState, IEnumerable`1<string> expectedStates, bool disableFilters, CancellationToken cancellationToken, IProfiler profiler, string serverId, IReadOnlyDictionary`2<string, object> customData);
    internal StateChangeContext(JobStorage storage, IStorageConnection connection, JobStorageTransaction transaction, string backgroundJobId, IState newState, IEnumerable`1<string> expectedStates, bool disableFilters, IFetchedJob completeJob, CancellationToken cancellationToken, IProfiler profiler, string serverId, IReadOnlyDictionary`2<string, object> customData);
    [CompilerGeneratedAttribute]
public JobStorage get_Storage();
    [CompilerGeneratedAttribute]
public IStorageConnection get_Connection();
    [CompilerGeneratedAttribute]
public JobStorageTransaction get_Transaction();
    [CompilerGeneratedAttribute]
public string get_BackgroundJobId();
    [CompilerGeneratedAttribute]
public IState get_NewState();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExpectedStates();
    [CompilerGeneratedAttribute]
public bool get_DisableFilters();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public IFetchedJob get_CompleteJob();
    [CompilerGeneratedAttribute]
public BackgroundJob get_ProcessedJob();
    [CompilerGeneratedAttribute]
public void set_ProcessedJob(BackgroundJob value);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(string value);
}
[ObsoleteAttribute("This class is here for compatibility reasons. Will be removed in 2.0.0.")]
public abstract class Hangfire.States.StateContext : object {
    [NotNullAttribute]
public BackgroundJob BackgroundJob { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public string JobId { get; }
    [CanBeNullAttribute]
[ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public Job Job { get; }
    [ObsoleteAttribute("Please use BackgroundJob property instead. Will be removed in 2.0.0.")]
public DateTime CreatedAt { get; }
    public abstract virtual BackgroundJob get_BackgroundJob();
    public string get_JobId();
    public Job get_Job();
    public DateTime get_CreatedAt();
}
[ObsoleteAttribute("This was a helper class, and it's not used anymore. Will be removed in 2.0.0.")]
public class Hangfire.States.StateHandlerCollection : object {
    private Dictionary`2<string, List`1<IStateHandler>> _handlers;
    public void AddRange(IEnumerable`1<IStateHandler> handlers);
    public void AddHandler(IStateHandler handler);
    public IEnumerable`1<IStateHandler> GetHandlers(string stateName);
}
public class Hangfire.States.StateMachine : object {
    private IJobFilterProvider _filterProvider;
    private IStateMachine _innerStateMachine;
    public IStateMachine InnerStateMachine { get; }
    public StateMachine(IJobFilterProvider filterProvider);
    internal StateMachine(IJobFilterProvider filterProvider, IStateMachine innerStateMachine);
    public IStateMachine get_InnerStateMachine();
    public sealed virtual IState ApplyState(ApplyStateContext initialContext);
    private static void InvokeOnStateElection(KeyValuePair`2<IElectStateFilter, ElectStateContext> x);
    private static void InvokeOnStateApplied(KeyValuePair`2<IApplyStateFilter, ApplyStateContext> x);
    private static void InvokeOnStateUnapplied(KeyValuePair`2<IApplyStateFilter, ApplyStateContext> x);
    private JobFilterInfo GetFilters(Job job);
}
public class Hangfire.States.SucceededState : object {
    public static string StateName;
    [CompilerGeneratedAttribute]
private DateTime <SucceededAt>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Latency>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PerformanceDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [JsonIgnoreAttribute]
public DateTime SucceededAt { get; }
    public object Result { get; }
    public long Latency { get; }
    public long PerformanceDuration { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    public string Reason { get; public set; }
    [JsonIgnoreAttribute]
public bool IsFinal { get; }
    [JsonIgnoreAttribute]
public bool IgnoreJobLoadException { get; }
    [JsonConstructorAttribute]
public SucceededState(object result, long latency, long performanceDuration);
    private static SucceededState();
    [CompilerGeneratedAttribute]
public DateTime get_SucceededAt();
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public long get_Latency();
    [CompilerGeneratedAttribute]
public long get_PerformanceDuration();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IgnoreJobLoadException();
    public sealed virtual Dictionary`2<string, string> SerializeData();
}
public class Hangfire.StatisticsHistoryAttribute : JobFilterAttribute {
    public sealed virtual void OnStateElection(ElectStateContext context);
}
public class Hangfire.Storage.BackgroundServerGoneException : Exception {
    protected BackgroundServerGoneException(SerializationInfo info, StreamingContext context);
}
public class Hangfire.Storage.DistributedLockTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    public string Resource { get; }
    public DistributedLockTimeoutException(string resource);
    protected DistributedLockTimeoutException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Resource();
}
public interface Hangfire.Storage.IFetchedJob {
    public string JobId { get; }
    public abstract virtual string get_JobId();
    public abstract virtual void RemoveFromQueue();
    public abstract virtual void Requeue();
}
public interface Hangfire.Storage.IMonitoringApi {
    public abstract virtual IList`1<QueueWithTopEnqueuedJobsDto> Queues();
    public abstract virtual IList`1<ServerDto> Servers();
    public abstract virtual JobDetailsDto JobDetails(string jobId);
    public abstract virtual StatisticsDto GetStatistics();
    public abstract virtual JobList`1<EnqueuedJobDto> EnqueuedJobs(string queue, int from, int perPage);
    public abstract virtual JobList`1<FetchedJobDto> FetchedJobs(string queue, int from, int perPage);
    public abstract virtual JobList`1<ProcessingJobDto> ProcessingJobs(int from, int count);
    public abstract virtual JobList`1<ScheduledJobDto> ScheduledJobs(int from, int count);
    public abstract virtual JobList`1<SucceededJobDto> SucceededJobs(int from, int count);
    public abstract virtual JobList`1<FailedJobDto> FailedJobs(int from, int count);
    public abstract virtual JobList`1<DeletedJobDto> DeletedJobs(int from, int count);
    public abstract virtual long ScheduledCount();
    public abstract virtual long EnqueuedCount(string queue);
    public abstract virtual long FetchedCount(string queue);
    public abstract virtual long FailedCount();
    public abstract virtual long ProcessingCount();
    public abstract virtual long SucceededListCount();
    public abstract virtual long DeletedListCount();
    public abstract virtual IDictionary`2<DateTime, long> SucceededByDatesCount();
    public abstract virtual IDictionary`2<DateTime, long> FailedByDatesCount();
    public abstract virtual IDictionary`2<DateTime, long> HourlySucceededJobs();
    public abstract virtual IDictionary`2<DateTime, long> HourlyFailedJobs();
}
public class Hangfire.Storage.InvocationData : object {
    private static ConcurrentDictionary`2<Tuple`4<Func`2<string, Type>, string, string, string>, Tuple`2<Type, MethodInfo>> MethodDeserializerCache;
    private static ConcurrentDictionary`2<Tuple`3<Func`2<Type, string>, Type, MethodInfo>, Tuple`3<string, string, string>> MethodSerializerCache;
    private static ConcurrentDictionary`2<Tuple`2<Func`2<Type, string>, string>, String[]> ParameterTypesDeserializerCache;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Type { get; }
    public string Method { get; }
    public string ParameterTypes { get; }
    public string Arguments { get; public set; }
    [JsonPropertyAttribute]
public string Queue { get; }
    public InvocationData(string type, string method, string parameterTypes, string arguments);
    [JsonConstructorAttribute]
public InvocationData(string type, string method, string parameterTypes, string arguments, string queue);
    private static InvocationData();
    [ObsoleteAttribute("Please use IGlobalConfiguration.UseTypeResolver instead. Will be removed in 2.0.0.")]
public static void SetTypeResolver(Func`2<string, Type> typeResolver);
    [ObsoleteAttribute("Please use IGlobalConfiguration.UseTypeSerializer instead. Will be removed in 2.0.0.")]
public static void SetTypeSerializer(Func`2<Type, string> typeSerializer);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public string get_ParameterTypes();
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_Queue();
    [ObsoleteAttribute("Please use DeserializeJob() method instead. Will be removed in 2.0.0 for clarity.")]
public Job Deserialize();
    [ObsoleteAttribute("Please use SerializeJob(Job) method instead. Will be removed in 2.0.0 for clarity.")]
public static InvocationData Serialize(Job job);
    public Job DeserializeJob();
    public static InvocationData SerializeJob(Job job);
    public static InvocationData DeserializePayload(string payload);
    public string SerializePayload(bool excludeArguments);
    private static String[] DeserializeParameterTypesArray(Func`2<Type, string> typeSerializer, string parameterTypes);
    internal static String[] SerializeArguments(MethodInfo methodInfo, IReadOnlyList`1<object> arguments);
    internal static Object[] DeserializeArguments(MethodInfo methodInfo, String[] arguments);
    private static void CachedSerializeMethod(Func`2<Type, string> typeSerializer, Type type, MethodInfo methodInfo, String& typeName, String& methodName, String& parameterTypes);
    private static void CachedDeserializeMethod(Func`2<string, Type> typeResolver, string typeName, string methodName, string parameterTypes, Type& type, MethodInfo& methodInfo);
    private static object DeserializeArgument(string argument, Type type);
    internal static bool ParseDateTimeArgument(string argument, DateTime& value);
}
public interface Hangfire.Storage.IStorageConnection {
    public abstract virtual IWriteOnlyTransaction CreateWriteTransaction();
    public abstract virtual IDisposable AcquireDistributedLock(string resource, TimeSpan timeout);
    public abstract virtual string CreateExpiredJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    public abstract virtual IFetchedJob FetchNextJob(String[] queues, CancellationToken cancellationToken);
    public abstract virtual void SetJobParameter(string id, string name, string value);
    public abstract virtual string GetJobParameter(string id, string name);
    [CanBeNullAttribute]
public abstract virtual JobData GetJobData(string jobId);
    [CanBeNullAttribute]
public abstract virtual StateData GetStateData(string jobId);
    public abstract virtual void AnnounceServer(string serverId, ServerContext context);
    public abstract virtual void RemoveServer(string serverId);
    public abstract virtual void Heartbeat(string serverId);
    public abstract virtual int RemoveTimedOutServers(TimeSpan timeOut);
    [NotNullAttribute]
public abstract virtual HashSet`1<string> GetAllItemsFromSet(string key);
    public abstract virtual string GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore);
    public abstract virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    [CanBeNullAttribute]
public abstract virtual Dictionary`2<string, string> GetAllEntriesFromHash(string key);
}
public interface Hangfire.Storage.IWriteOnlyTransaction {
    public abstract virtual void ExpireJob(string jobId, TimeSpan expireIn);
    public abstract virtual void PersistJob(string jobId);
    public abstract virtual void SetJobState(string jobId, IState state);
    public abstract virtual void AddJobState(string jobId, IState state);
    public abstract virtual void AddToQueue(string queue, string jobId);
    public abstract virtual void IncrementCounter(string key);
    public abstract virtual void IncrementCounter(string key, TimeSpan expireIn);
    public abstract virtual void DecrementCounter(string key);
    public abstract virtual void DecrementCounter(string key, TimeSpan expireIn);
    public abstract virtual void AddToSet(string key, string value);
    public abstract virtual void AddToSet(string key, string value, double score);
    public abstract virtual void RemoveFromSet(string key, string value);
    public abstract virtual void InsertToList(string key, string value);
    public abstract virtual void RemoveFromList(string key, string value);
    public abstract virtual void TrimList(string key, int keepStartingFrom, int keepEndingAt);
    public abstract virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public abstract virtual void RemoveHash(string key);
    public abstract virtual void Commit();
}
public class Hangfire.Storage.JobData : object {
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <ParametersSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    public string State { get; public set; }
    public Job Job { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public IReadOnlyDictionary`2<string, string> ParametersSnapshot { get; public set; }
    public JobLoadException LoadException { get; public set; }
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_ParametersSnapshot();
    [CompilerGeneratedAttribute]
public void set_ParametersSnapshot(IReadOnlyDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    public void EnsureLoaded();
}
public abstract class Hangfire.Storage.JobStorageConnection : object {
    public virtual void Dispose();
    public abstract virtual IWriteOnlyTransaction CreateWriteTransaction();
    public abstract virtual IDisposable AcquireDistributedLock(string resource, TimeSpan timeout);
    public abstract virtual string CreateExpiredJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    public abstract virtual IFetchedJob FetchNextJob(String[] queues, CancellationToken cancellationToken);
    public abstract virtual void SetJobParameter(string id, string name, string value);
    public abstract virtual string GetJobParameter(string id, string name);
    public abstract virtual JobData GetJobData(string jobId);
    public abstract virtual StateData GetStateData(string jobId);
    public abstract virtual void AnnounceServer(string serverId, ServerContext context);
    public abstract virtual void RemoveServer(string serverId);
    public abstract virtual void Heartbeat(string serverId);
    public abstract virtual int RemoveTimedOutServers(TimeSpan timeOut);
    public abstract virtual HashSet`1<string> GetAllItemsFromSet(string key);
    public abstract virtual string GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore);
    public virtual List`1<string> GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore, int count);
    public virtual long GetSetCount(string key);
    public virtual long GetSetCount(IEnumerable`1<string> keys, int limit);
    public virtual bool GetSetContains(string key, string value);
    public virtual List`1<string> GetRangeFromSet(string key, int startingFrom, int endingAt);
    public virtual TimeSpan GetSetTtl(string key);
    public abstract virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public abstract virtual Dictionary`2<string, string> GetAllEntriesFromHash(string key);
    public virtual string GetValueFromHash(string key, string name);
    public virtual long GetHashCount(string key);
    public virtual TimeSpan GetHashTtl(string key);
    public virtual long GetListCount(string key);
    public virtual List`1<string> GetAllItemsFromList(string key);
    public virtual List`1<string> GetRangeFromList(string key, int startingFrom, int endingAt);
    public virtual TimeSpan GetListTtl(string key);
    public virtual long GetCounter(string key);
    public virtual DateTime GetUtcDateTime();
}
public static class Hangfire.Storage.JobStorageFeatures : object {
    internal static string TransactionalAcknowledgePrefix;
    public static string JobQueueProperty;
    public static string ExtendedApi;
    private static JobStorageFeatures();
    public static Exception GetNotSupportedException(string featureId);
}
public abstract class Hangfire.Storage.JobStorageMonitor : object {
    public abstract virtual IList`1<QueueWithTopEnqueuedJobsDto> Queues();
    public abstract virtual IList`1<ServerDto> Servers();
    public abstract virtual JobDetailsDto JobDetails(string jobId);
    public abstract virtual StatisticsDto GetStatistics();
    public abstract virtual JobList`1<EnqueuedJobDto> EnqueuedJobs(string queue, int from, int perPage);
    public abstract virtual JobList`1<FetchedJobDto> FetchedJobs(string queue, int from, int perPage);
    public abstract virtual JobList`1<ProcessingJobDto> ProcessingJobs(int from, int count);
    public abstract virtual JobList`1<ScheduledJobDto> ScheduledJobs(int from, int count);
    public abstract virtual JobList`1<SucceededJobDto> SucceededJobs(int from, int count);
    public abstract virtual JobList`1<FailedJobDto> FailedJobs(int from, int count);
    public abstract virtual JobList`1<DeletedJobDto> DeletedJobs(int from, int count);
    public virtual JobList`1<AwaitingJobDto> AwaitingJobs(int from, int count);
    public abstract virtual long ScheduledCount();
    public abstract virtual long EnqueuedCount(string queue);
    public abstract virtual long FetchedCount(string queue);
    public abstract virtual long FailedCount();
    public abstract virtual long ProcessingCount();
    public abstract virtual long SucceededListCount();
    public abstract virtual long DeletedListCount();
    public virtual long AwaitingCount();
    public abstract virtual IDictionary`2<DateTime, long> SucceededByDatesCount();
    public abstract virtual IDictionary`2<DateTime, long> FailedByDatesCount();
    public virtual IDictionary`2<DateTime, long> DeletedByDatesCount();
    public abstract virtual IDictionary`2<DateTime, long> HourlySucceededJobs();
    public abstract virtual IDictionary`2<DateTime, long> HourlyFailedJobs();
    public virtual IDictionary`2<DateTime, long> HourlyDeletedJobs();
}
public abstract class Hangfire.Storage.JobStorageTransaction : object {
    public virtual void Dispose();
    public abstract virtual void ExpireJob(string jobId, TimeSpan expireIn);
    public abstract virtual void PersistJob(string jobId);
    public abstract virtual void SetJobState(string jobId, IState state);
    public abstract virtual void AddJobState(string jobId, IState state);
    public abstract virtual void AddToQueue(string queue, string jobId);
    public abstract virtual void IncrementCounter(string key);
    public abstract virtual void IncrementCounter(string key, TimeSpan expireIn);
    public abstract virtual void DecrementCounter(string key);
    public abstract virtual void DecrementCounter(string key, TimeSpan expireIn);
    public abstract virtual void AddToSet(string key, string value);
    public abstract virtual void AddToSet(string key, string value, double score);
    public abstract virtual void RemoveFromSet(string key, string value);
    public abstract virtual void InsertToList(string key, string value);
    public abstract virtual void RemoveFromList(string key, string value);
    public abstract virtual void TrimList(string key, int keepStartingFrom, int keepEndingAt);
    public abstract virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public abstract virtual void RemoveHash(string key);
    public abstract virtual void Commit();
    public virtual void ExpireSet(string key, TimeSpan expireIn);
    public virtual void ExpireList(string key, TimeSpan expireIn);
    public virtual void ExpireHash(string key, TimeSpan expireIn);
    public virtual void PersistSet(string key);
    public virtual void PersistList(string key);
    public virtual void PersistHash(string key);
    public virtual void AddRangeToSet(string key, IList`1<string> items);
    public virtual void RemoveSet(string key);
    public virtual void AcquireDistributedLock(string resource, TimeSpan timeout);
    public virtual void RemoveFromQueue(IFetchedJob fetchedJob);
    public virtual void SetJobParameter(string jobId, string name, string value);
    public virtual string CreateJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
}
public class Hangfire.Storage.Monitoring.AwaitingJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <AwaitingAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InAwaitingState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentStateName>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public Nullable`1<DateTime> AwaitingAt { get; public set; }
    public bool InAwaitingState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    public string ParentStateName { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_AwaitingAt();
    [CompilerGeneratedAttribute]
public void set_AwaitingAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_InAwaitingState();
    [CompilerGeneratedAttribute]
public void set_InAwaitingState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ParentStateName();
    [CompilerGeneratedAttribute]
public void set_ParentStateName(string value);
}
public class Hangfire.Storage.Monitoring.DeletedJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DeletedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InDeletedState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public Nullable`1<DateTime> DeletedAt { get; public set; }
    public bool InDeletedState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DeletedAt();
    [CompilerGeneratedAttribute]
public void set_DeletedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_InDeletedState();
    [CompilerGeneratedAttribute]
public void set_InDeletedState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.EnqueuedJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <EnqueuedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InEnqueuedState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public string State { get; public set; }
    public Nullable`1<DateTime> EnqueuedAt { get; public set; }
    public bool InEnqueuedState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_EnqueuedAt();
    [CompilerGeneratedAttribute]
public void set_EnqueuedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_InEnqueuedState();
    [CompilerGeneratedAttribute]
public void set_InEnqueuedState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.FailedJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FailedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InFailedState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public string Reason { get; public set; }
    public Nullable`1<DateTime> FailedAt { get; public set; }
    public string ExceptionType { get; public set; }
    public string ExceptionMessage { get; public set; }
    public string ExceptionDetails { get; public set; }
    public bool InFailedState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FailedAt();
    [CompilerGeneratedAttribute]
public void set_FailedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_ExceptionType();
    [CompilerGeneratedAttribute]
public void set_ExceptionType(string value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public string get_ExceptionDetails();
    [CompilerGeneratedAttribute]
public void set_ExceptionDetails(string value);
    [CompilerGeneratedAttribute]
public bool get_InFailedState();
    [CompilerGeneratedAttribute]
public void set_InFailedState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.FetchedJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FetchedAt>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public string State { get; public set; }
    public Nullable`1<DateTime> FetchedAt { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FetchedAt();
    [CompilerGeneratedAttribute]
public void set_FetchedAt(Nullable`1<DateTime> value);
}
public class Hangfire.Storage.Monitoring.JobDetailsDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<StateHistoryDto> <History>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpireAt>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public Nullable`1<DateTime> CreatedAt { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    public IList`1<StateHistoryDto> History { get; public set; }
    public Nullable`1<DateTime> ExpireAt { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IList`1<StateHistoryDto> get_History();
    [CompilerGeneratedAttribute]
public void set_History(IList`1<StateHistoryDto> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public void set_ExpireAt(Nullable`1<DateTime> value);
}
public class Hangfire.Storage.Monitoring.JobList`1 : List`1<KeyValuePair`2<string, TDto>> {
    public JobList`1(IEnumerable`1<KeyValuePair`2<string, TDto>> source);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Storage.Monitoring.NamespaceDoc : object {
}
public class Hangfire.Storage.Monitoring.ProcessingJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InProcessingState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public bool InProcessingState { get; public set; }
    public string ServerId { get; public set; }
    public Nullable`1<DateTime> StartedAt { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public bool get_InProcessingState();
    [CompilerGeneratedAttribute]
public void set_InProcessingState(bool value);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.QueueWithTopEnqueuedJobsDto : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Fetched>k__BackingField;
    [CompilerGeneratedAttribute]
private JobList`1<EnqueuedJobDto> <FirstJobs>k__BackingField;
    public string Name { get; public set; }
    public long Length { get; public set; }
    public Nullable`1<long> Fetched { get; public set; }
    public JobList`1<EnqueuedJobDto> FirstJobs { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Fetched();
    [CompilerGeneratedAttribute]
public void set_Fetched(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public JobList`1<EnqueuedJobDto> get_FirstJobs();
    [CompilerGeneratedAttribute]
public void set_FirstJobs(JobList`1<EnqueuedJobDto> value);
}
public class Hangfire.Storage.Monitoring.ScheduledJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EnqueueAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ScheduledAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InScheduledState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public DateTime EnqueueAt { get; public set; }
    public Nullable`1<DateTime> ScheduledAt { get; public set; }
    public bool InScheduledState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public DateTime get_EnqueueAt();
    [CompilerGeneratedAttribute]
public void set_EnqueueAt(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ScheduledAt();
    [CompilerGeneratedAttribute]
public void set_ScheduledAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_InScheduledState();
    [CompilerGeneratedAttribute]
public void set_InScheduledState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.ServerDto : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WorkersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Heartbeat>k__BackingField;
    public string Name { get; public set; }
    public int WorkersCount { get; public set; }
    public DateTime StartedAt { get; public set; }
    public IList`1<string> Queues { get; public set; }
    public Nullable`1<DateTime> Heartbeat { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_WorkersCount();
    [CompilerGeneratedAttribute]
public void set_WorkersCount(int value);
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(IList`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Heartbeat();
    [CompilerGeneratedAttribute]
public void set_Heartbeat(Nullable`1<DateTime> value);
}
public class Hangfire.Storage.Monitoring.StateHistoryDto : object {
    [CompilerGeneratedAttribute]
private string <StateName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Data>k__BackingField;
    public string StateName { get; public set; }
    public string Reason { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public IDictionary`2<string, string> Data { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StateName();
    [CompilerGeneratedAttribute]
public void set_StateName(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IDictionary`2<string, string> value);
}
public class Hangfire.Storage.Monitoring.StatisticsDto : object {
    [CompilerGeneratedAttribute]
private long <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Recurring>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Enqueued>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Scheduled>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Processing>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Failed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Awaiting>k__BackingField;
    public long Servers { get; public set; }
    public long Recurring { get; public set; }
    public long Enqueued { get; public set; }
    public long Queues { get; public set; }
    public long Scheduled { get; public set; }
    public long Processing { get; public set; }
    public long Succeeded { get; public set; }
    public long Failed { get; public set; }
    public long Deleted { get; public set; }
    public Nullable`1<long> Retries { get; public set; }
    public Nullable`1<long> Awaiting { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Servers();
    [CompilerGeneratedAttribute]
public void set_Servers(long value);
    [CompilerGeneratedAttribute]
public long get_Recurring();
    [CompilerGeneratedAttribute]
public void set_Recurring(long value);
    [CompilerGeneratedAttribute]
public long get_Enqueued();
    [CompilerGeneratedAttribute]
public void set_Enqueued(long value);
    [CompilerGeneratedAttribute]
public long get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(long value);
    [CompilerGeneratedAttribute]
public long get_Scheduled();
    [CompilerGeneratedAttribute]
public void set_Scheduled(long value);
    [CompilerGeneratedAttribute]
public long get_Processing();
    [CompilerGeneratedAttribute]
public void set_Processing(long value);
    [CompilerGeneratedAttribute]
public long get_Succeeded();
    [CompilerGeneratedAttribute]
public void set_Succeeded(long value);
    [CompilerGeneratedAttribute]
public long get_Failed();
    [CompilerGeneratedAttribute]
public void set_Failed(long value);
    [CompilerGeneratedAttribute]
public long get_Deleted();
    [CompilerGeneratedAttribute]
public void set_Deleted(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Awaiting();
    [CompilerGeneratedAttribute]
public void set_Awaiting(Nullable`1<long> value);
}
public class Hangfire.Storage.Monitoring.SucceededJobDto : object {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TotalDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SucceededAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InSucceededState>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <StateData>k__BackingField;
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public InvocationData InvocationData { get; public set; }
    public object Result { get; public set; }
    public Nullable`1<long> TotalDuration { get; public set; }
    public Nullable`1<DateTime> SucceededAt { get; public set; }
    public bool InSucceededState { get; public set; }
    public IDictionary`2<string, string> StateData { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(InvocationData value);
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TotalDuration();
    [CompilerGeneratedAttribute]
public void set_TotalDuration(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_SucceededAt();
    [CompilerGeneratedAttribute]
public void set_SucceededAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_InSucceededState();
    [CompilerGeneratedAttribute]
public void set_InSucceededState(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(IDictionary`2<string, string> value);
}
[CompilerGeneratedAttribute]
internal class Hangfire.Storage.NamespaceDoc : object {
}
[CompilerGeneratedAttribute]
internal class Hangfire.Storage.NamespaceGroupDoc : object {
}
public class Hangfire.Storage.RecurringJobDto : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Cron>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private JobLoadException <LoadException>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NextExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastJobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastJobState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Removed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeZoneId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    public string Id { get; public set; }
    public string Cron { get; public set; }
    public string Queue { get; public set; }
    public Job Job { get; public set; }
    public JobLoadException LoadException { get; public set; }
    public Nullable`1<DateTime> NextExecution { get; public set; }
    public string LastJobId { get; public set; }
    public string LastJobState { get; public set; }
    public Nullable`1<DateTime> LastExecution { get; public set; }
    public Nullable`1<DateTime> CreatedAt { get; public set; }
    public bool Removed { get; public set; }
    public string TimeZoneId { get; public set; }
    public string Error { get; public set; }
    public int RetryAttempt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Cron();
    [CompilerGeneratedAttribute]
public void set_Cron(string value);
    [CompilerGeneratedAttribute]
public string get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(string value);
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public JobLoadException get_LoadException();
    [CompilerGeneratedAttribute]
public void set_LoadException(JobLoadException value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NextExecution();
    [CompilerGeneratedAttribute]
public void set_NextExecution(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_LastJobId();
    [CompilerGeneratedAttribute]
public void set_LastJobId(string value);
    [CompilerGeneratedAttribute]
public string get_LastJobState();
    [CompilerGeneratedAttribute]
public void set_LastJobState(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastExecution();
    [CompilerGeneratedAttribute]
public void set_LastExecution(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Removed();
    [CompilerGeneratedAttribute]
public void set_Removed(bool value);
    [CompilerGeneratedAttribute]
public string get_TimeZoneId();
    [CompilerGeneratedAttribute]
public void set_TimeZoneId(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
    [CompilerGeneratedAttribute]
public void set_RetryAttempt(int value);
}
public class Hangfire.Storage.StateData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Data>k__BackingField;
    [NotNullAttribute]
public string Name { get; public set; }
    [CanBeNullAttribute]
public string Reason { get; public set; }
    [NotNullAttribute]
public IDictionary`2<string, string> Data { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IDictionary`2<string, string> value);
}
[ExtensionAttribute]
public static class Hangfire.Storage.StorageConnectionExtensions : object {
    [ExtensionAttribute]
public static IDisposable AcquireDistributedJobLock(IStorageConnection connection, string jobId, TimeSpan timeout);
    [ExtensionAttribute]
public static void AcquireDistributedJobLock(JobStorageTransaction transaction, string jobId, TimeSpan timeout);
    [ExtensionAttribute]
public static long GetRecurringJobCount(JobStorageConnection connection);
    [ExtensionAttribute]
public static List`1<string> GetRecurringJobIds(JobStorageConnection connection, int startingFrom, int endingAt);
    [ExtensionAttribute]
public static List`1<RecurringJobDto> GetRecurringJobs(JobStorageConnection connection, int startingFrom, int endingAt);
    [ExtensionAttribute]
public static List`1<RecurringJobDto> GetRecurringJobs(IStorageConnection connection);
    [ExtensionAttribute]
public static List`1<RecurringJobDto> GetRecurringJobs(IStorageConnection connection, IEnumerable`1<string> ids);
    private static List`1<RecurringJobDto> GetRecurringJobDtos(IStorageConnection connection, IEnumerable`1<string> ids);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Owin.Builder.AppBuilder : object {
    private static Func`2<IDictionary`2<string, object>, Task> NotFound;
    private IList`1<Tuple`3<Type, Delegate, Object[]>> _middleware;
    private IDictionary`2<Tuple`2<Type, Type>, Delegate> _conversions;
    private IDictionary`2<string, object> _properties;
    public IDictionary`2<string, object> Properties { get; }
    internal AppBuilder(IDictionary`2<Tuple`2<Type, Type>, Delegate> conversions, IDictionary`2<string, object> properties);
    private static AppBuilder();
    public sealed virtual IDictionary`2<string, object> get_Properties();
    public sealed virtual IAppBuilder Use(object middleware, Object[] args);
    public sealed virtual IAppBuilder New();
    public sealed virtual object Build(Type returnType);
    private void AddSignatureConversion(Delegate conversion);
    private static Type GetParameterType(Delegate function);
    private object BuildInternal(Type signature);
    private object Convert(Type signature, object app);
    private object ConvertMultiHop(Type signature, object app);
    private object ConvertOneHop(Type signature, object app);
    private static Delegate ToMemberDelegate(Type signature, object app);
    private static Tuple`3<Type, Delegate, Object[]> ToMiddlewareFactory(object middlewareObject, Object[] args);
    private static Tuple`3<Type, Delegate, Object[]> ToInstanceMiddlewareFactory(object middlewareObject, Object[] args);
    private static Tuple`3<Type, Delegate, Object[]> ToGeneratorMiddlewareFactory(object middlewareObject, Object[] args);
    private static Tuple`3<Type, Delegate, Object[]> ToConstructorMiddlewareFactory(object middlewareObject, Object[] args, Delegate& middlewareDelegate);
    private static bool TestArgForParameter(Type parameterType, object arg);
}
[ExtensionAttribute]
internal static class Microsoft.Owin.Builder.AppBuilderExtensions : object {
    [ExtensionAttribute]
public static Func`2<IDictionary`2<string, object>, Task> Build(IAppBuilder builder);
    [ExtensionAttribute]
public static TApp Build(IAppBuilder builder);
    [ExtensionAttribute]
public static void AddSignatureConversion(IAppBuilder builder, Delegate conversion);
    [ExtensionAttribute]
public static void AddSignatureConversion(IAppBuilder builder, Func`2<T1, T2> conversion);
}
internal static class Microsoft.Owin.Builder.Constants : object {
    internal static string BuilderAddConversion;
    internal static string BuilderDefaultApp;
    internal static string Invoke;
    internal static string Initialize;
}
internal class Microsoft.Owin.Builder.NotFound : object {
    private static Task Completed;
    private static NotFound();
    private static Task CreateCompletedTask();
    public Task Invoke(IDictionary`2<string, object> env);
}
internal class Microsoft.Owin.BuilderProperties.Address : ValueType {
    private IDictionary`2<string, object> _dictionary;
    public IDictionary`2<string, object> Dictionary { get; }
    public string Scheme { get; public set; }
    public string Host { get; public set; }
    public string Port { get; public set; }
    public string Path { get; public set; }
    public Address(IDictionary`2<string, object> dictionary);
    public Address(string scheme, string host, string port, string path);
    public IDictionary`2<string, object> get_Dictionary();
    public string get_Scheme();
    public void set_Scheme(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Port();
    public void set_Port(string value);
    public string get_Path();
    public void set_Path(string value);
    public static Address Create();
    public bool Equals(Address other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Address left, Address right);
    public static bool op_Inequality(Address left, Address right);
    public T Get(string key);
    public Address Set(string key, object value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Owin.BuilderProperties.AddressCollection : ValueType {
    private IList`1<IDictionary`2<string, object>> _list;
    public IList`1<IDictionary`2<string, object>> List { get; }
    public int Count { get; }
    public Address Item { get; public set; }
    public AddressCollection(IList`1<IDictionary`2<string, object>> list);
    public IList`1<IDictionary`2<string, object>> get_List();
    public int get_Count();
    public Address get_Item(int index);
    public void set_Item(int index, Address value);
    public void Add(Address address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Owin.BuilderProperties.AddressCollection/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<Address> GetEnumerator();
    public static AddressCollection Create();
    public bool Equals(AddressCollection other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AddressCollection left, AddressCollection right);
    public static bool op_Inequality(AddressCollection left, AddressCollection right);
}
internal class Microsoft.Owin.BuilderProperties.AppProperties : ValueType {
    private IDictionary`2<string, object> _dictionary;
    public string OwinVersion { get; public set; }
    public Func`2<IDictionary`2<string, object>, Task> DefaultApp { get; public set; }
    public Action`1<Delegate> AddSignatureConversionDelegate { get; public set; }
    public string AppName { get; public set; }
    public TextWriter TraceOutput { get; public set; }
    public CancellationToken OnAppDisposing { get; public set; }
    public AddressCollection Addresses { get; public set; }
    public Capabilities Capabilities { get; public set; }
    public IDictionary`2<string, object> Dictionary { get; }
    public AppProperties(IDictionary`2<string, object> dictionary);
    public string get_OwinVersion();
    public void set_OwinVersion(string value);
    public Func`2<IDictionary`2<string, object>, Task> get_DefaultApp();
    public void set_DefaultApp(Func`2<IDictionary`2<string, object>, Task> value);
    public Action`1<Delegate> get_AddSignatureConversionDelegate();
    public void set_AddSignatureConversionDelegate(Action`1<Delegate> value);
    public string get_AppName();
    public void set_AppName(string value);
    public TextWriter get_TraceOutput();
    public void set_TraceOutput(TextWriter value);
    public CancellationToken get_OnAppDisposing();
    public void set_OnAppDisposing(CancellationToken value);
    public AddressCollection get_Addresses();
    public void set_Addresses(AddressCollection value);
    public Capabilities get_Capabilities();
    public void set_Capabilities(Capabilities value);
    public IDictionary`2<string, object> get_Dictionary();
    public bool Equals(AppProperties other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AppProperties left, AppProperties right);
    public static bool op_Inequality(AppProperties left, AppProperties right);
    public T Get(string key);
    public AppProperties Set(string key, object value);
}
internal class Microsoft.Owin.BuilderProperties.Capabilities : ValueType {
    private IDictionary`2<string, object> _dictionary;
    public IDictionary`2<string, object> Dictionary { get; }
    public string SendFileVersion { get; public set; }
    public string WebSocketVersion { get; public set; }
    public Capabilities(IDictionary`2<string, object> dictionary);
    public IDictionary`2<string, object> get_Dictionary();
    public string get_SendFileVersion();
    public void set_SendFileVersion(string value);
    public string get_WebSocketVersion();
    public void set_WebSocketVersion(string value);
    public static Capabilities Create();
    public bool Equals(Capabilities other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Capabilities left, Capabilities right);
    public static bool op_Inequality(Capabilities left, Capabilities right);
    public T Get(string key);
    public Capabilities Set(string key, object value);
}
internal class Microsoft.Owin.CookieOptions : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Secure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HttpOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SameSiteMode> <SameSite>k__BackingField;
    public string Domain { get; public set; }
    public string Path { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public bool Secure { get; public set; }
    public bool HttpOnly { get; public set; }
    public Nullable`1<SameSiteMode> SameSite { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Secure();
    [CompilerGeneratedAttribute]
public void set_Secure(bool value);
    [CompilerGeneratedAttribute]
public bool get_HttpOnly();
    [CompilerGeneratedAttribute]
public void set_HttpOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<SameSiteMode> get_SameSite();
    [CompilerGeneratedAttribute]
public void set_SameSite(Nullable`1<SameSiteMode> value);
}
[ExtensionAttribute]
internal static class Microsoft.Owin.Extensions.IntegratedPipelineExtensions : object {
    private static string IntegratedPipelineStageMarker;
    [ExtensionAttribute]
public static IAppBuilder UseStageMarker(IAppBuilder app, string stageName);
    [ExtensionAttribute]
public static IAppBuilder UseStageMarker(IAppBuilder app, PipelineStage stage);
}
internal class Microsoft.Owin.Extensions.UseHandlerMiddleware : object {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    private Func`2<IOwinContext, Task> _handler;
    public UseHandlerMiddleware(Func`2<IDictionary`2<string, object>, Task> next, Func`2<IOwinContext, Task> handler);
    public UseHandlerMiddleware(Func`2<IDictionary`2<string, object>, Task> next, Func`3<IOwinContext, Func`1<Task>, Task> handler);
    public Task Invoke(IDictionary`2<string, object> environment);
}
internal class Microsoft.Owin.FormCollection : ReadableStringCollection {
    public FormCollection(IDictionary`2<string, String[]> store);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Owin.HeaderDictionary : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, String[]> <Store>k__BackingField;
    private IDictionary`2<string, String[]> Store { get; private set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<String[]> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public string Item { get; public set; }
    private String[] System.Collections.Generic.IDictionary<System.String,System.String[]>.Item { get; private set; }
    public HeaderDictionary(IDictionary`2<string, String[]> store);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, String[]> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, String[]> value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<String[]> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    private sealed virtual override String[] System.Collections.Generic.IDictionary<System.String,System.String[]>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.String[]>.set_Item(string key, String[] value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, String[]>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual string Get(string key);
    public sealed virtual IList`1<string> GetValues(string key);
    public sealed virtual IList`1<string> GetCommaSeparatedValues(string key);
    public sealed virtual void Append(string key, string value);
    public sealed virtual void AppendValues(string key, String[] values);
    public sealed virtual void AppendCommaSeparatedValues(string key, String[] values);
    public sealed virtual void Set(string key, string value);
    public sealed virtual void SetValues(string key, String[] values);
    public sealed virtual void SetCommaSeparatedValues(string key, String[] values);
    public sealed virtual void Add(string key, String[] value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, String[]& value);
    public sealed virtual void Add(KeyValuePair`2<string, String[]> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, String[]> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, String[]> item);
}
internal static class Microsoft.Owin.Helpers.WebHelpers : object {
    public static IFormCollection ParseForm(string text);
}
internal class Microsoft.Owin.HostString : ValueType {
    private string _value;
    public string Value { get; }
    public HostString(string value);
    public string get_Value();
    public virtual string ToString();
    public string ToUriComponent();
    public static HostString FromUriComponent(string uriComponent);
    public static HostString FromUriComponent(Uri uri);
    public sealed virtual bool Equals(HostString other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HostString left, HostString right);
    public static bool op_Inequality(HostString left, HostString right);
}
internal interface Microsoft.Owin.IFormCollection {
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Owin.IHeaderDictionary {
    public string Item { get; public set; }
    public abstract virtual string get_Item(string key);
    public abstract virtual void set_Item(string key, string value);
    public abstract virtual IList`1<string> GetCommaSeparatedValues(string key);
    public abstract virtual void Append(string key, string value);
    public abstract virtual void AppendValues(string key, String[] values);
    public abstract virtual void AppendCommaSeparatedValues(string key, String[] values);
    public abstract virtual void Set(string key, string value);
    public abstract virtual void SetValues(string key, String[] values);
    public abstract virtual void SetCommaSeparatedValues(string key, String[] values);
}
internal class Microsoft.Owin.Infrastructure.AppFuncTransition : OwinMiddleware {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    public AppFuncTransition(Func`2<IDictionary`2<string, object>, Task> next);
    public virtual Task Invoke(IOwinContext context);
}
internal class Microsoft.Owin.Infrastructure.ChunkingCookieManager : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChunkSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowForPartialCookies>k__BackingField;
    public Nullable`1<int> ChunkSize { get; public set; }
    public bool ThrowForPartialCookies { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ChunkSize();
    [CompilerGeneratedAttribute]
public void set_ChunkSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_ThrowForPartialCookies();
    [CompilerGeneratedAttribute]
public void set_ThrowForPartialCookies(bool value);
    private static int ParseChunksCount(string value);
    public sealed virtual string GetRequestCookie(IOwinContext context, string key);
    public sealed virtual void AppendResponseCookie(IOwinContext context, string key, string value, CookieOptions options);
    public sealed virtual void DeleteCookie(IOwinContext context, string key, CookieOptions options);
    private static bool IsQuoted(string value);
    private static string RemoveQuotes(string value);
    private static string Quote(string value);
    private static string GetStringRepresentationOfSameSite(SameSiteMode siteMode);
}
internal static class Microsoft.Owin.Infrastructure.Constants : object {
    internal static string Https;
    internal static string HttpDateFormat;
}
internal class Microsoft.Owin.Infrastructure.CookieManager : object {
    public sealed virtual string GetRequestCookie(IOwinContext context, string key);
    public sealed virtual void AppendResponseCookie(IOwinContext context, string key, string value, CookieOptions options);
    public sealed virtual void DeleteCookie(IOwinContext context, string key, CookieOptions options);
}
[GeneratedCodeAttribute("App_Packages", "")]
internal class Microsoft.Owin.Infrastructure.HeaderSegment : ValueType {
    private StringSegment _formatting;
    private StringSegment _data;
    public StringSegment Formatting { get; }
    public StringSegment Data { get; }
    public HeaderSegment(StringSegment formatting, StringSegment data);
    public StringSegment get_Formatting();
    public StringSegment get_Data();
    public sealed virtual bool Equals(HeaderSegment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HeaderSegment left, HeaderSegment right);
    public static bool op_Inequality(HeaderSegment left, HeaderSegment right);
}
[GeneratedCodeAttribute("App_Packages", "")]
internal class Microsoft.Owin.Infrastructure.HeaderSegmentCollection : ValueType {
    private String[] _headers;
    public HeaderSegmentCollection(String[] headers);
    public sealed virtual bool Equals(HeaderSegmentCollection other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HeaderSegmentCollection left, HeaderSegmentCollection right);
    public static bool op_Inequality(HeaderSegmentCollection left, HeaderSegmentCollection right);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<HeaderSegment> System.Collections.Generic.IEnumerable<Microsoft.Owin.Infrastructure.HeaderSegment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface Microsoft.Owin.Infrastructure.ICookieManager {
    public abstract virtual string GetRequestCookie(IOwinContext context, string key);
    public abstract virtual void AppendResponseCookie(IOwinContext context, string key, string value, CookieOptions options);
    public abstract virtual void DeleteCookie(IOwinContext context, string key, CookieOptions options);
}
internal interface Microsoft.Owin.Infrastructure.ISystemClock {
    public DateTimeOffset UtcNow { get; }
    public abstract virtual DateTimeOffset get_UtcNow();
}
internal static class Microsoft.Owin.Infrastructure.OwinHelpers : object {
    private static Action`3<string, string, object> AddCookieCallback;
    private static Char[] SemicolonAndComma;
    private static Action`3<string, string, object> AppendItemCallback;
    private static Char[] AmpersandAndSemicolon;
    private static OwinHelpers();
    internal static IDictionary`2<string, string> GetCookies(IOwinRequest request);
    internal static void ParseDelimited(string text, Char[] delimiters, Action`3<string, string, object> callback, bool decodePlus, bool decodeKey, object state);
    public static string GetHeader(IDictionary`2<string, String[]> headers, string key);
    public static IEnumerable`1<string> GetHeaderSplit(IDictionary`2<string, String[]> headers, string key);
    [IteratorStateMachineAttribute("Microsoft.Owin.Infrastructure.OwinHelpers/<GetHeaderSplitImplementation>d__6")]
private static IEnumerable`1<string> GetHeaderSplitImplementation(String[] values);
    public static String[] GetHeaderUnmodified(IDictionary`2<string, String[]> headers, string key);
    public static void SetHeader(IDictionary`2<string, String[]> headers, string key, string value);
    public static void SetHeaderJoined(IDictionary`2<string, String[]> headers, string key, String[] values);
    private static string QuoteIfNeeded(string value);
    private static string DeQuote(string value);
    public static void SetHeaderUnmodified(IDictionary`2<string, String[]> headers, string key, String[] values);
    public static void SetHeaderUnmodified(IDictionary`2<string, String[]> headers, string key, IEnumerable`1<string> values);
    public static void AppendHeader(IDictionary`2<string, String[]> headers, string key, string values);
    public static void AppendHeaderJoined(IDictionary`2<string, String[]> headers, string key, String[] values);
    public static void AppendHeaderUnmodified(IDictionary`2<string, String[]> headers, string key, String[] values);
    internal static IDictionary`2<string, String[]> GetQuery(IOwinRequest request);
    internal static IFormCollection GetForm(string text);
    internal static string GetJoinedValue(IDictionary`2<string, String[]> store, string key);
    internal static String[] GetUnmodifiedValues(IDictionary`2<string, String[]> store, string key);
    internal static string GetHost(IOwinRequest request);
}
internal class Microsoft.Owin.Infrastructure.OwinMiddlewareTransition : object {
    private OwinMiddleware _next;
    public OwinMiddlewareTransition(OwinMiddleware next);
    public Task Invoke(IDictionary`2<string, object> environment);
}
internal static class Microsoft.Owin.Infrastructure.PathStringHelper : object {
    private static Boolean[] ValidPathChars;
    private static PathStringHelper();
    public static bool IsValidPathChar(char c);
    public static bool IsPercentEncodedChar(string str, int index);
    public static bool IsHexadecimalChar(char c);
}
internal static class Microsoft.Owin.Infrastructure.SignatureConversions : object {
    public static void AddConversions(IAppBuilder app);
    private static OwinMiddleware Conversion1(Func`2<IDictionary`2<string, object>, Task> next);
    private static Func`2<IDictionary`2<string, object>, Task> Conversion2(OwinMiddleware next);
}
[GeneratedCodeAttribute("App_Packages", "")]
internal class Microsoft.Owin.Infrastructure.StringSegment : ValueType {
    private string _buffer;
    private int _offset;
    private int _count;
    public string Buffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public string Value { get; }
    public bool HasValue { get; }
    public StringSegment(string buffer, int offset, int count);
    public string get_Buffer();
    public int get_Offset();
    public int get_Count();
    public string get_Value();
    public bool get_HasValue();
    public sealed virtual bool Equals(StringSegment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSegment left, StringSegment right);
    public static bool op_Inequality(StringSegment left, StringSegment right);
    public bool StartsWith(string text, StringComparison comparisonType);
    public bool EndsWith(string text, StringComparison comparisonType);
    public bool Equals(string text, StringComparison comparisonType);
    public string Substring(int offset, int length);
    public StringSegment Subsegment(int offset, int length);
    public virtual string ToString();
}
internal class Microsoft.Owin.Infrastructure.SystemClock : object {
    public DateTimeOffset UtcNow { get; }
    public sealed virtual DateTimeOffset get_UtcNow();
}
internal static class Microsoft.Owin.Infrastructure.WebUtilities : object {
    public static string AddQueryString(string uri, string queryString);
    public static string AddQueryString(string uri, string name, string value);
    public static string AddQueryString(string uri, IDictionary`2<string, string> queryString);
}
internal interface Microsoft.Owin.IOwinContext {
    public IOwinRequest Request { get; }
    public IOwinResponse Response { get; }
    public IAuthenticationManager Authentication { get; }
    public IDictionary`2<string, object> Environment { get; }
    public TextWriter TraceOutput { get; public set; }
    public abstract virtual IOwinRequest get_Request();
    public abstract virtual IOwinResponse get_Response();
    public abstract virtual IAuthenticationManager get_Authentication();
    public abstract virtual IDictionary`2<string, object> get_Environment();
    public abstract virtual TextWriter get_TraceOutput();
    public abstract virtual void set_TraceOutput(TextWriter value);
    public abstract virtual T Get(string key);
    public abstract virtual IOwinContext Set(string key, T value);
}
internal interface Microsoft.Owin.IOwinRequest {
    public IDictionary`2<string, object> Environment { get; }
    public IOwinContext Context { get; }
    public string Method { get; public set; }
    public string Scheme { get; public set; }
    public bool IsSecure { get; }
    public HostString Host { get; public set; }
    public PathString PathBase { get; public set; }
    public PathString Path { get; public set; }
    public QueryString QueryString { get; public set; }
    public IReadableStringCollection Query { get; }
    public Uri Uri { get; }
    public string Protocol { get; public set; }
    public IHeaderDictionary Headers { get; }
    public RequestCookieCollection Cookies { get; }
    public string ContentType { get; public set; }
    public string CacheControl { get; public set; }
    public string MediaType { get; public set; }
    public string Accept { get; public set; }
    public Stream Body { get; public set; }
    public CancellationToken CallCancelled { get; public set; }
    public string LocalIpAddress { get; public set; }
    public Nullable`1<int> LocalPort { get; public set; }
    public string RemoteIpAddress { get; public set; }
    public Nullable`1<int> RemotePort { get; public set; }
    public IPrincipal User { get; public set; }
    public abstract virtual IDictionary`2<string, object> get_Environment();
    public abstract virtual IOwinContext get_Context();
    public abstract virtual string get_Method();
    public abstract virtual void set_Method(string value);
    public abstract virtual string get_Scheme();
    public abstract virtual void set_Scheme(string value);
    public abstract virtual bool get_IsSecure();
    public abstract virtual HostString get_Host();
    public abstract virtual void set_Host(HostString value);
    public abstract virtual PathString get_PathBase();
    public abstract virtual void set_PathBase(PathString value);
    public abstract virtual PathString get_Path();
    public abstract virtual void set_Path(PathString value);
    public abstract virtual QueryString get_QueryString();
    public abstract virtual void set_QueryString(QueryString value);
    public abstract virtual IReadableStringCollection get_Query();
    public abstract virtual Uri get_Uri();
    public abstract virtual string get_Protocol();
    public abstract virtual void set_Protocol(string value);
    public abstract virtual IHeaderDictionary get_Headers();
    public abstract virtual RequestCookieCollection get_Cookies();
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual string get_CacheControl();
    public abstract virtual void set_CacheControl(string value);
    public abstract virtual string get_MediaType();
    public abstract virtual void set_MediaType(string value);
    public abstract virtual string get_Accept();
    public abstract virtual void set_Accept(string value);
    public abstract virtual Stream get_Body();
    public abstract virtual void set_Body(Stream value);
    public abstract virtual CancellationToken get_CallCancelled();
    public abstract virtual void set_CallCancelled(CancellationToken value);
    public abstract virtual string get_LocalIpAddress();
    public abstract virtual void set_LocalIpAddress(string value);
    public abstract virtual Nullable`1<int> get_LocalPort();
    public abstract virtual void set_LocalPort(Nullable`1<int> value);
    public abstract virtual string get_RemoteIpAddress();
    public abstract virtual void set_RemoteIpAddress(string value);
    public abstract virtual Nullable`1<int> get_RemotePort();
    public abstract virtual void set_RemotePort(Nullable`1<int> value);
    public abstract virtual IPrincipal get_User();
    public abstract virtual void set_User(IPrincipal value);
    public abstract virtual Task`1<IFormCollection> ReadFormAsync();
    public abstract virtual T Get(string key);
    public abstract virtual IOwinRequest Set(string key, T value);
}
internal interface Microsoft.Owin.IOwinResponse {
    public IDictionary`2<string, object> Environment { get; }
    public IOwinContext Context { get; }
    public int StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public string Protocol { get; public set; }
    public IHeaderDictionary Headers { get; }
    public ResponseCookieCollection Cookies { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public string ETag { get; public set; }
    public Stream Body { get; public set; }
    public abstract virtual IDictionary`2<string, object> get_Environment();
    public abstract virtual IOwinContext get_Context();
    public abstract virtual int get_StatusCode();
    public abstract virtual void set_StatusCode(int value);
    public abstract virtual string get_ReasonPhrase();
    public abstract virtual void set_ReasonPhrase(string value);
    public abstract virtual string get_Protocol();
    public abstract virtual void set_Protocol(string value);
    public abstract virtual IHeaderDictionary get_Headers();
    public abstract virtual ResponseCookieCollection get_Cookies();
    public abstract virtual Nullable`1<long> get_ContentLength();
    public abstract virtual void set_ContentLength(Nullable`1<long> value);
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual Nullable`1<DateTimeOffset> get_Expires();
    public abstract virtual void set_Expires(Nullable`1<DateTimeOffset> value);
    public abstract virtual string get_ETag();
    public abstract virtual void set_ETag(string value);
    public abstract virtual Stream get_Body();
    public abstract virtual void set_Body(Stream value);
    public abstract virtual void OnSendingHeaders(Action`1<object> callback, object state);
    public abstract virtual void Redirect(string location);
    public abstract virtual void Write(string text);
    public abstract virtual void Write(Byte[] data);
    public abstract virtual void Write(Byte[] data, int offset, int count);
    public abstract virtual Task WriteAsync(string text);
    public abstract virtual Task WriteAsync(string text, CancellationToken token);
    public abstract virtual Task WriteAsync(Byte[] data);
    public abstract virtual Task WriteAsync(Byte[] data, CancellationToken token);
    public abstract virtual Task WriteAsync(Byte[] data, int offset, int count, CancellationToken token);
    public abstract virtual T Get(string key);
    public abstract virtual IOwinResponse Set(string key, T value);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Owin.IReadableStringCollection {
    public string Item { get; }
    public abstract virtual string get_Item(string key);
    public abstract virtual string Get(string key);
    public abstract virtual IList`1<string> GetValues(string key);
}
[ExtensionAttribute]
internal static class Microsoft.Owin.Logging.AppBuilderLoggerExtensions : object {
    [ExtensionAttribute]
public static void SetLoggerFactory(IAppBuilder app, ILoggerFactory loggerFactory);
    [ExtensionAttribute]
public static ILoggerFactory GetLoggerFactory(IAppBuilder app);
    [ExtensionAttribute]
public static ILogger CreateLogger(IAppBuilder app, string name);
    [ExtensionAttribute]
public static ILogger CreateLogger(IAppBuilder app, Type component);
    [ExtensionAttribute]
public static ILogger CreateLogger(IAppBuilder app);
}
internal class Microsoft.Owin.Logging.DiagnosticsLogger : object {
    private TraceSource _traceSource;
    public DiagnosticsLogger(TraceSource traceSource);
    public sealed virtual bool WriteCore(TraceEventType eventType, int eventId, object state, Exception exception, Func`3<object, Exception, string> formatter);
}
internal class Microsoft.Owin.Logging.DiagnosticsLoggerFactory : object {
    private static string RootTraceName;
    private SourceSwitch _rootSourceSwitch;
    private TraceListener _rootTraceListener;
    private ConcurrentDictionary`2<string, TraceSource> _sources;
    public DiagnosticsLoggerFactory(SourceSwitch rootSourceSwitch, TraceListener rootTraceListener);
    public sealed virtual ILogger Create(string name);
    private TraceSource GetOrAddTraceSource(string name);
    private TraceSource InitializeTraceSource(string traceSourceName);
    private static string ParentSourceName(string traceSourceName);
    private static bool HasDefaultListeners(TraceSource traceSource);
    private static bool HasDefaultSwitch(TraceSource traceSource);
}
internal interface Microsoft.Owin.Logging.ILogger {
    public abstract virtual bool WriteCore(TraceEventType eventType, int eventId, object state, Exception exception, Func`3<object, Exception, string> formatter);
}
internal interface Microsoft.Owin.Logging.ILoggerFactory {
    public abstract virtual ILogger Create(string name);
}
[ExtensionAttribute]
internal static class Microsoft.Owin.Logging.LoggerExtensions : object {
    private static Func`3<object, Exception, string> TheMessage;
    private static Func`3<object, Exception, string> TheMessageAndError;
    private static LoggerExtensions();
    [ExtensionAttribute]
public static bool IsEnabled(ILogger logger, TraceEventType eventType);
    [ExtensionAttribute]
public static void WriteVerbose(ILogger logger, string data);
    [ExtensionAttribute]
public static void WriteInformation(ILogger logger, string message);
    [ExtensionAttribute]
public static void WriteWarning(ILogger logger, string message, String[] args);
    [ExtensionAttribute]
public static void WriteWarning(ILogger logger, string message, Exception error);
    [ExtensionAttribute]
public static void WriteError(ILogger logger, string message);
    [ExtensionAttribute]
public static void WriteError(ILogger logger, string message, Exception error);
    [ExtensionAttribute]
public static void WriteCritical(ILogger logger, string message);
    [ExtensionAttribute]
public static void WriteCritical(ILogger logger, string message, Exception error);
}
internal static class Microsoft.Owin.Logging.LoggerFactory : object {
    [CompilerGeneratedAttribute]
private static ILoggerFactory <Default>k__BackingField;
    public static ILoggerFactory Default { get; public set; }
    private static LoggerFactory();
    [CompilerGeneratedAttribute]
public static ILoggerFactory get_Default();
    [CompilerGeneratedAttribute]
public static void set_Default(ILoggerFactory value);
}
internal class Microsoft.Owin.Mapping.MapMiddleware : object {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    private MapOptions _options;
    public MapMiddleware(Func`2<IDictionary`2<string, object>, Task> next, MapOptions options);
    [AsyncStateMachineAttribute("Microsoft.Owin.Mapping.MapMiddleware/<Invoke>d__3")]
public Task Invoke(IDictionary`2<string, object> environment);
}
internal class Microsoft.Owin.Mapping.MapOptions : object {
    [CompilerGeneratedAttribute]
private PathString <PathMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDictionary`2<string, object>, Task> <Branch>k__BackingField;
    public PathString PathMatch { get; public set; }
    public Func`2<IDictionary`2<string, object>, Task> Branch { get; public set; }
    [CompilerGeneratedAttribute]
public PathString get_PathMatch();
    [CompilerGeneratedAttribute]
public void set_PathMatch(PathString value);
    [CompilerGeneratedAttribute]
public Func`2<IDictionary`2<string, object>, Task> get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(Func`2<IDictionary`2<string, object>, Task> value);
}
internal class Microsoft.Owin.Mapping.MapWhenMiddleware : object {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    private MapWhenOptions _options;
    public MapWhenMiddleware(Func`2<IDictionary`2<string, object>, Task> next, MapWhenOptions options);
    [AsyncStateMachineAttribute("Microsoft.Owin.Mapping.MapWhenMiddleware/<Invoke>d__3")]
public Task Invoke(IDictionary`2<string, object> environment);
}
internal class Microsoft.Owin.Mapping.MapWhenOptions : object {
    [CompilerGeneratedAttribute]
private Func`2<IOwinContext, bool> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IOwinContext, Task`1<bool>> <PredicateAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDictionary`2<string, object>, Task> <Branch>k__BackingField;
    public Func`2<IOwinContext, bool> Predicate { get; public set; }
    public Func`2<IOwinContext, Task`1<bool>> PredicateAsync { get; public set; }
    public Func`2<IDictionary`2<string, object>, Task> Branch { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<IOwinContext, bool> get_Predicate();
    [CompilerGeneratedAttribute]
public void set_Predicate(Func`2<IOwinContext, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<IOwinContext, Task`1<bool>> get_PredicateAsync();
    [CompilerGeneratedAttribute]
public void set_PredicateAsync(Func`2<IOwinContext, Task`1<bool>> value);
    [CompilerGeneratedAttribute]
public Func`2<IDictionary`2<string, object>, Task> get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(Func`2<IDictionary`2<string, object>, Task> value);
}
internal static class Microsoft.Owin.OwinConstants : object {
    public static string RequestScheme;
    public static string RequestMethod;
    public static string RequestPathBase;
    public static string RequestPath;
    public static string RequestQueryString;
    public static string RequestProtocol;
    public static string RequestHeaders;
    public static string RequestBody;
    public static string ResponseStatusCode;
    public static string ResponseReasonPhrase;
    public static string ResponseProtocol;
    public static string ResponseHeaders;
    public static string ResponseBody;
    public static string CallCancelled;
    public static string OwinVersion;
}
internal class Microsoft.Owin.OwinContext : object {
    [CompilerGeneratedAttribute]
private IOwinRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private IOwinResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Environment>k__BackingField;
    public IOwinRequest Request { get; private set; }
    public IOwinResponse Response { get; private set; }
    public IAuthenticationManager Authentication { get; }
    public IDictionary`2<string, object> Environment { get; private set; }
    public TextWriter TraceOutput { get; public set; }
    public OwinContext(IDictionary`2<string, object> environment);
    [CompilerGeneratedAttribute]
public virtual IOwinRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(IOwinRequest value);
    [CompilerGeneratedAttribute]
public virtual IOwinResponse get_Response();
    [CompilerGeneratedAttribute]
private void set_Response(IOwinResponse value);
    public sealed virtual IAuthenticationManager get_Authentication();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Environment();
    [CompilerGeneratedAttribute]
private void set_Environment(IDictionary`2<string, object> value);
    public virtual TextWriter get_TraceOutput();
    public virtual void set_TraceOutput(TextWriter value);
    public virtual T Get(string key);
    public virtual IOwinContext Set(string key, T value);
}
internal abstract class Microsoft.Owin.OwinMiddleware : object {
    [CompilerGeneratedAttribute]
private OwinMiddleware <Next>k__BackingField;
    protected OwinMiddleware Next { get; protected set; }
    protected OwinMiddleware(OwinMiddleware next);
    [CompilerGeneratedAttribute]
protected OwinMiddleware get_Next();
    [CompilerGeneratedAttribute]
protected void set_Next(OwinMiddleware value);
    public abstract virtual Task Invoke(IOwinContext context);
}
internal class Microsoft.Owin.OwinRequest : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Environment>k__BackingField;
    public IDictionary`2<string, object> Environment { get; private set; }
    public IOwinContext Context { get; }
    public string Method { get; public set; }
    public string Scheme { get; public set; }
    public bool IsSecure { get; }
    public HostString Host { get; public set; }
    public PathString PathBase { get; public set; }
    public PathString Path { get; public set; }
    public QueryString QueryString { get; public set; }
    public IReadableStringCollection Query { get; }
    public Uri Uri { get; }
    public string Protocol { get; public set; }
    public IHeaderDictionary Headers { get; }
    private IDictionary`2<string, String[]> RawHeaders { get; }
    public RequestCookieCollection Cookies { get; }
    public string ContentType { get; public set; }
    public string CacheControl { get; public set; }
    public string MediaType { get; public set; }
    public string Accept { get; public set; }
    public Stream Body { get; public set; }
    public CancellationToken CallCancelled { get; public set; }
    public string LocalIpAddress { get; public set; }
    public Nullable`1<int> LocalPort { get; public set; }
    private string LocalPortString { get; private set; }
    public string RemoteIpAddress { get; public set; }
    public Nullable`1<int> RemotePort { get; public set; }
    private string RemotePortString { get; private set; }
    public IPrincipal User { get; public set; }
    public OwinRequest(IDictionary`2<string, object> environment);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Environment();
    [CompilerGeneratedAttribute]
private void set_Environment(IDictionary`2<string, object> value);
    public virtual IOwinContext get_Context();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual string get_Scheme();
    public virtual void set_Scheme(string value);
    public virtual bool get_IsSecure();
    public virtual HostString get_Host();
    public virtual void set_Host(HostString value);
    public virtual PathString get_PathBase();
    public virtual void set_PathBase(PathString value);
    public virtual PathString get_Path();
    public virtual void set_Path(PathString value);
    public virtual QueryString get_QueryString();
    public virtual void set_QueryString(QueryString value);
    public virtual IReadableStringCollection get_Query();
    public virtual Uri get_Uri();
    public virtual string get_Protocol();
    public virtual void set_Protocol(string value);
    public virtual IHeaderDictionary get_Headers();
    private IDictionary`2<string, String[]> get_RawHeaders();
    public sealed virtual RequestCookieCollection get_Cookies();
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual string get_CacheControl();
    public virtual void set_CacheControl(string value);
    public virtual string get_MediaType();
    public virtual void set_MediaType(string value);
    public virtual string get_Accept();
    public virtual void set_Accept(string value);
    public virtual Stream get_Body();
    public virtual void set_Body(Stream value);
    public virtual CancellationToken get_CallCancelled();
    public virtual void set_CallCancelled(CancellationToken value);
    public virtual string get_LocalIpAddress();
    public virtual void set_LocalIpAddress(string value);
    public virtual Nullable`1<int> get_LocalPort();
    public virtual void set_LocalPort(Nullable`1<int> value);
    private string get_LocalPortString();
    private void set_LocalPortString(string value);
    public virtual string get_RemoteIpAddress();
    public virtual void set_RemoteIpAddress(string value);
    public virtual Nullable`1<int> get_RemotePort();
    public virtual void set_RemotePort(Nullable`1<int> value);
    private string get_RemotePortString();
    private void set_RemotePortString(string value);
    public virtual IPrincipal get_User();
    public virtual void set_User(IPrincipal value);
    [AsyncStateMachineAttribute("Microsoft.Owin.OwinRequest/<ReadFormAsync>d__80")]
public sealed virtual Task`1<IFormCollection> ReadFormAsync();
    public virtual T Get(string key);
    public virtual IOwinRequest Set(string key, T value);
}
internal class Microsoft.Owin.OwinResponse : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Environment>k__BackingField;
    public IDictionary`2<string, object> Environment { get; private set; }
    public IOwinContext Context { get; }
    public int StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public string Protocol { get; public set; }
    public IHeaderDictionary Headers { get; }
    private IDictionary`2<string, String[]> RawHeaders { get; }
    public ResponseCookieCollection Cookies { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public string ETag { get; public set; }
    public Stream Body { get; public set; }
    public OwinResponse(IDictionary`2<string, object> environment);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Environment();
    [CompilerGeneratedAttribute]
private void set_Environment(IDictionary`2<string, object> value);
    public virtual IOwinContext get_Context();
    public virtual int get_StatusCode();
    public virtual void set_StatusCode(int value);
    public virtual string get_ReasonPhrase();
    public virtual void set_ReasonPhrase(string value);
    public virtual string get_Protocol();
    public virtual void set_Protocol(string value);
    public virtual IHeaderDictionary get_Headers();
    private IDictionary`2<string, String[]> get_RawHeaders();
    public virtual ResponseCookieCollection get_Cookies();
    public virtual Nullable`1<long> get_ContentLength();
    public virtual void set_ContentLength(Nullable`1<long> value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual Nullable`1<DateTimeOffset> get_Expires();
    public virtual void set_Expires(Nullable`1<DateTimeOffset> value);
    public virtual string get_ETag();
    public virtual void set_ETag(string value);
    public virtual Stream get_Body();
    public virtual void set_Body(Stream value);
    public virtual void OnSendingHeaders(Action`1<object> callback, object state);
    public virtual void Redirect(string location);
    public virtual void Write(string text);
    public virtual void Write(Byte[] data);
    public virtual void Write(Byte[] data, int offset, int count);
    public virtual Task WriteAsync(string text);
    public virtual Task WriteAsync(string text, CancellationToken token);
    public virtual Task WriteAsync(Byte[] data);
    public virtual Task WriteAsync(Byte[] data, CancellationToken token);
    public virtual Task WriteAsync(Byte[] data, int offset, int count, CancellationToken token);
    public virtual T Get(string key);
    private T Get(string key, T fallback);
    public virtual IOwinResponse Set(string key, T value);
}
[AttributeUsageAttribute("1")]
internal class Microsoft.Owin.OwinStartupAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StartupType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string FriendlyName { get; private set; }
    public Type StartupType { get; private set; }
    public string MethodName { get; private set; }
    public OwinStartupAttribute(Type startupType);
    public OwinStartupAttribute(string friendlyName, Type startupType);
    public OwinStartupAttribute(Type startupType, string methodName);
    public OwinStartupAttribute(string friendlyName, Type startupType, string methodName);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public Type get_StartupType();
    [CompilerGeneratedAttribute]
private void set_StartupType(Type value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
}
internal class Microsoft.Owin.PathString : ValueType {
    public static PathString Empty;
    private string _value;
    public string Value { get; }
    public bool HasValue { get; }
    public PathString(string value);
    private static PathString();
    public string get_Value();
    public bool get_HasValue();
    public virtual string ToString();
    public string ToUriComponent();
    public static PathString FromUriComponent(string uriComponent);
    public static PathString FromUriComponent(Uri uri);
    public bool StartsWithSegments(PathString other);
    public bool StartsWithSegments(PathString other, PathString& remaining);
    public PathString Add(PathString other);
    public string Add(QueryString other);
    public sealed virtual bool Equals(PathString other);
    public bool Equals(PathString other, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PathString left, PathString right);
    public static bool op_Inequality(PathString left, PathString right);
    public static PathString op_Addition(PathString left, PathString right);
    public static string op_Addition(PathString left, QueryString right);
}
internal class Microsoft.Owin.QueryString : ValueType {
    public static QueryString Empty;
    private string _value;
    public string Value { get; }
    public bool HasValue { get; }
    public QueryString(string value);
    public QueryString(string name, string value);
    private static QueryString();
    public string get_Value();
    public bool get_HasValue();
    public virtual string ToString();
    public string ToUriComponent();
    public static QueryString FromUriComponent(string uriComponent);
    public static QueryString FromUriComponent(Uri uri);
    public sealed virtual bool Equals(QueryString other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(QueryString left, QueryString right);
    public static bool op_Inequality(QueryString left, QueryString right);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Owin.ReadableStringCollection : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, String[]> <Store>k__BackingField;
    private IDictionary`2<string, String[]> Store { get; private set; }
    public string Item { get; }
    public ReadableStringCollection(IDictionary`2<string, String[]> store);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, String[]> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, String[]> value);
    public sealed virtual string get_Item(string key);
    public sealed virtual string Get(string key);
    public sealed virtual IList`1<string> GetValues(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, String[]>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Owin.RequestCookieCollection : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Store>k__BackingField;
    private IDictionary`2<string, string> Store { get; private set; }
    public string Item { get; }
    public RequestCookieCollection(IDictionary`2<string, string> store);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IDictionary`2<string, string> value);
    public string get_Item(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Owin.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Exception_ConversionTakesOneParameter { get; }
    internal static string Exception_CookieLimitTooSmall { get; }
    internal static string Exception_ImcompleteChunkedCookie { get; }
    internal static string Exception_MiddlewareNotSupported { get; }
    internal static string Exception_MissingOnSendingHeaders { get; }
    internal static string Exception_NoConstructorFound { get; }
    internal static string Exception_NoConversionExists { get; }
    internal static string Exception_PathMustNotEndWithSlash { get; }
    internal static string Exception_PathMustStartWithSlash { get; }
    internal static string Exception_PathRequired { get; }
    internal static string Exception_QueryStringMustStartWithDelimiter { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Exception_ConversionTakesOneParameter();
    internal static string get_Exception_CookieLimitTooSmall();
    internal static string get_Exception_ImcompleteChunkedCookie();
    internal static string get_Exception_MiddlewareNotSupported();
    internal static string get_Exception_MissingOnSendingHeaders();
    internal static string get_Exception_NoConstructorFound();
    internal static string get_Exception_NoConversionExists();
    internal static string get_Exception_PathMustNotEndWithSlash();
    internal static string get_Exception_PathMustStartWithSlash();
    internal static string get_Exception_PathRequired();
    internal static string get_Exception_QueryStringMustStartWithDelimiter();
}
internal class Microsoft.Owin.ResponseCookieCollection : object {
    [CompilerGeneratedAttribute]
private IHeaderDictionary <Headers>k__BackingField;
    private IHeaderDictionary Headers { get; private set; }
    public ResponseCookieCollection(IHeaderDictionary headers);
    [CompilerGeneratedAttribute]
private IHeaderDictionary get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(IHeaderDictionary value);
    public void Append(string key, string value);
    public void Append(string key, string value, CookieOptions options);
    public void Delete(string key);
    public void Delete(string key, CookieOptions options);
    private static string GetStringRepresentationOfSameSite(SameSiteMode siteMode);
}
internal enum Microsoft.Owin.SameSiteMode : Enum {
    public int value__;
    public static SameSiteMode None;
    public static SameSiteMode Lax;
    public static SameSiteMode Strict;
}
internal class Microsoft.Owin.Security.AuthenticateResult : object {
    [CompilerGeneratedAttribute]
private ClaimsIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationDescription <Description>k__BackingField;
    public ClaimsIdentity Identity { get; private set; }
    public AuthenticationProperties Properties { get; private set; }
    public AuthenticationDescription Description { get; private set; }
    public AuthenticateResult(IIdentity identity, AuthenticationProperties properties, AuthenticationDescription description);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(ClaimsIdentity value);
    [CompilerGeneratedAttribute]
public AuthenticationProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(AuthenticationProperties value);
    [CompilerGeneratedAttribute]
public AuthenticationDescription get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(AuthenticationDescription value);
}
internal class Microsoft.Owin.Security.AuthenticationDescription : object {
    private static string CaptionPropertyKey;
    private static string AuthenticationTypePropertyKey;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; private set; }
    public string AuthenticationType { get; public set; }
    public string Caption { get; public set; }
    public AuthenticationDescription(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, object> value);
    public string get_AuthenticationType();
    public void set_AuthenticationType(string value);
    public string get_Caption();
    public void set_Caption(string value);
    private string GetString(string name);
}
internal class Microsoft.Owin.Security.AuthenticationManager : object {
    private IOwinContext _context;
    private IOwinRequest _request;
    public ClaimsPrincipal User { get; public set; }
    internal Func`4<String[], Action`4<IIdentity, IDictionary`2<string, string>, IDictionary`2<string, object>, object>, object, Task> AuthenticateDelegate { get; }
    public AuthenticationResponseChallenge AuthenticationResponseChallenge { get; public set; }
    public AuthenticationResponseGrant AuthenticationResponseGrant { get; public set; }
    public AuthenticationResponseRevoke AuthenticationResponseRevoke { get; public set; }
    public Tuple`2<IPrincipal, IDictionary`2<string, string>> SignInEntry { get; public set; }
    public String[] SignOutEntry { get; public set; }
    public IDictionary`2<string, string> SignOutPropertiesEntry { get; public set; }
    public Tuple`2<String[], IDictionary`2<string, string>> ChallengeEntry { get; public set; }
    public AuthenticationManager(IOwinContext context);
    public sealed virtual ClaimsPrincipal get_User();
    public sealed virtual void set_User(ClaimsPrincipal value);
    internal Func`4<String[], Action`4<IIdentity, IDictionary`2<string, string>, IDictionary`2<string, object>, object>, object, Task> get_AuthenticateDelegate();
    public sealed virtual AuthenticationResponseChallenge get_AuthenticationResponseChallenge();
    public sealed virtual void set_AuthenticationResponseChallenge(AuthenticationResponseChallenge value);
    public sealed virtual AuthenticationResponseGrant get_AuthenticationResponseGrant();
    public sealed virtual void set_AuthenticationResponseGrant(AuthenticationResponseGrant value);
    public sealed virtual AuthenticationResponseRevoke get_AuthenticationResponseRevoke();
    public sealed virtual void set_AuthenticationResponseRevoke(AuthenticationResponseRevoke value);
    public sealed virtual IEnumerable`1<AuthenticationDescription> GetAuthenticationTypes();
    public sealed virtual IEnumerable`1<AuthenticationDescription> GetAuthenticationTypes(Func`2<AuthenticationDescription, bool> predicate);
    private Task GetAuthenticationTypes(Action`1<IDictionary`2<string, object>> callback);
    [AsyncStateMachineAttribute("Microsoft.Owin.Security.AuthenticationManager/<AuthenticateAsync>d__20")]
public sealed virtual Task`1<AuthenticateResult> AuthenticateAsync(string authenticationType);
    [AsyncStateMachineAttribute("Microsoft.Owin.Security.AuthenticationManager/<AuthenticateAsync>d__21")]
public sealed virtual Task`1<IEnumerable`1<AuthenticateResult>> AuthenticateAsync(String[] authenticationTypes);
    private static void AuthenticateAsyncCallback(IIdentity identity, IDictionary`2<string, string> properties, IDictionary`2<string, object> description, object state);
    public sealed virtual void Challenge(AuthenticationProperties properties, String[] authenticationTypes);
    public sealed virtual void Challenge(String[] authenticationTypes);
    public sealed virtual void SignIn(AuthenticationProperties properties, ClaimsIdentity[] identities);
    public sealed virtual void SignIn(ClaimsIdentity[] identities);
    public sealed virtual void SignOut(AuthenticationProperties properties, String[] authenticationTypes);
    public sealed virtual void SignOut(String[] authenticationTypes);
    [AsyncStateMachineAttribute("Microsoft.Owin.Security.AuthenticationManager/<Authenticate>d__29")]
public Task Authenticate(String[] authenticationTypes, Action`4<IIdentity, IDictionary`2<string, string>, IDictionary`2<string, object>, object> callback, object state);
    public Tuple`2<IPrincipal, IDictionary`2<string, string>> get_SignInEntry();
    public void set_SignInEntry(Tuple`2<IPrincipal, IDictionary`2<string, string>> value);
    public String[] get_SignOutEntry();
    public void set_SignOutEntry(String[] value);
    public IDictionary`2<string, string> get_SignOutPropertiesEntry();
    public void set_SignOutPropertiesEntry(IDictionary`2<string, string> value);
    public Tuple`2<String[], IDictionary`2<string, string>> get_ChallengeEntry();
    public void set_ChallengeEntry(Tuple`2<String[], IDictionary`2<string, string>> value);
}
internal class Microsoft.Owin.Security.AuthenticationProperties : object {
    internal static string IssuedUtcKey;
    internal static string ExpiresUtcKey;
    internal static string IsPersistentKey;
    internal static string RedirectUriKey;
    internal static string RefreshKey;
    internal static string UtcDateTimeFormat;
    private IDictionary`2<string, string> _dictionary;
    public IDictionary`2<string, string> Dictionary { get; }
    public bool IsPersistent { get; public set; }
    public string RedirectUri { get; public set; }
    public Nullable`1<DateTimeOffset> IssuedUtc { get; public set; }
    public Nullable`1<DateTimeOffset> ExpiresUtc { get; public set; }
    public Nullable`1<bool> AllowRefresh { get; public set; }
    public AuthenticationProperties(IDictionary`2<string, string> dictionary);
    public IDictionary`2<string, string> get_Dictionary();
    public bool get_IsPersistent();
    public void set_IsPersistent(bool value);
    public string get_RedirectUri();
    public void set_RedirectUri(string value);
    public Nullable`1<DateTimeOffset> get_IssuedUtc();
    public void set_IssuedUtc(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ExpiresUtc();
    public void set_ExpiresUtc(Nullable`1<DateTimeOffset> value);
    public Nullable`1<bool> get_AllowRefresh();
    public void set_AllowRefresh(Nullable`1<bool> value);
}
internal class Microsoft.Owin.Security.AuthenticationResponseChallenge : object {
    [CompilerGeneratedAttribute]
private String[] <AuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationProperties <Properties>k__BackingField;
    public String[] AuthenticationTypes { get; private set; }
    public AuthenticationProperties Properties { get; private set; }
    public AuthenticationResponseChallenge(String[] authenticationTypes, AuthenticationProperties properties);
    [CompilerGeneratedAttribute]
public String[] get_AuthenticationTypes();
    [CompilerGeneratedAttribute]
private void set_AuthenticationTypes(String[] value);
    [CompilerGeneratedAttribute]
public AuthenticationProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(AuthenticationProperties value);
}
internal class Microsoft.Owin.Security.AuthenticationResponseGrant : object {
    [CompilerGeneratedAttribute]
private ClaimsIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <Principal>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationProperties <Properties>k__BackingField;
    public ClaimsIdentity Identity { get; private set; }
    public ClaimsPrincipal Principal { get; private set; }
    public AuthenticationProperties Properties { get; private set; }
    public AuthenticationResponseGrant(ClaimsIdentity identity, AuthenticationProperties properties);
    public AuthenticationResponseGrant(ClaimsPrincipal principal, AuthenticationProperties properties);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(ClaimsIdentity value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_Principal();
    [CompilerGeneratedAttribute]
private void set_Principal(ClaimsPrincipal value);
    [CompilerGeneratedAttribute]
public AuthenticationProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(AuthenticationProperties value);
}
internal class Microsoft.Owin.Security.AuthenticationResponseRevoke : object {
    [CompilerGeneratedAttribute]
private String[] <AuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationProperties <Properties>k__BackingField;
    public String[] AuthenticationTypes { get; private set; }
    public AuthenticationProperties Properties { get; private set; }
    public AuthenticationResponseRevoke(String[] authenticationTypes);
    public AuthenticationResponseRevoke(String[] authenticationTypes, AuthenticationProperties properties);
    [CompilerGeneratedAttribute]
public String[] get_AuthenticationTypes();
    [CompilerGeneratedAttribute]
private void set_AuthenticationTypes(String[] value);
    [CompilerGeneratedAttribute]
public AuthenticationProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(AuthenticationProperties value);
}
internal interface Microsoft.Owin.Security.IAuthenticationManager {
    public ClaimsPrincipal User { get; public set; }
    public AuthenticationResponseChallenge AuthenticationResponseChallenge { get; public set; }
    public AuthenticationResponseGrant AuthenticationResponseGrant { get; public set; }
    public AuthenticationResponseRevoke AuthenticationResponseRevoke { get; public set; }
    public abstract virtual ClaimsPrincipal get_User();
    public abstract virtual void set_User(ClaimsPrincipal value);
    public abstract virtual AuthenticationResponseChallenge get_AuthenticationResponseChallenge();
    public abstract virtual void set_AuthenticationResponseChallenge(AuthenticationResponseChallenge value);
    public abstract virtual AuthenticationResponseGrant get_AuthenticationResponseGrant();
    public abstract virtual void set_AuthenticationResponseGrant(AuthenticationResponseGrant value);
    public abstract virtual AuthenticationResponseRevoke get_AuthenticationResponseRevoke();
    public abstract virtual void set_AuthenticationResponseRevoke(AuthenticationResponseRevoke value);
    public abstract virtual IEnumerable`1<AuthenticationDescription> GetAuthenticationTypes();
    public abstract virtual IEnumerable`1<AuthenticationDescription> GetAuthenticationTypes(Func`2<AuthenticationDescription, bool> predicate);
    public abstract virtual Task`1<AuthenticateResult> AuthenticateAsync(string authenticationType);
    public abstract virtual Task`1<IEnumerable`1<AuthenticateResult>> AuthenticateAsync(String[] authenticationTypes);
    public abstract virtual void Challenge(AuthenticationProperties properties, String[] authenticationTypes);
    public abstract virtual void Challenge(String[] authenticationTypes);
    public abstract virtual void SignIn(AuthenticationProperties properties, ClaimsIdentity[] identities);
    public abstract virtual void SignIn(ClaimsIdentity[] identities);
    public abstract virtual void SignOut(AuthenticationProperties properties, String[] authenticationTypes);
    public abstract virtual void SignOut(String[] authenticationTypes);
}
[ExtensionAttribute]
internal static class MoreLinq.MoreEnumerable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Pairwise(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
    [IteratorStateMachineAttribute("MoreLinq.MoreEnumerable/<PairwiseImpl>d__1`2")]
[ExtensionAttribute]
private static IEnumerable`1<TResult> PairwiseImpl(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TResult> resultSelector);
}
[ExtensionAttribute]
internal static class Owin.AppBuilderUseExtensions : object {
    [ExtensionAttribute]
public static IAppBuilder Use(IAppBuilder app, Object[] args);
    [ExtensionAttribute]
public static void Run(IAppBuilder app, Func`2<IOwinContext, Task> handler);
    [ExtensionAttribute]
public static IAppBuilder Use(IAppBuilder app, Func`3<IOwinContext, Func`1<Task>, Task> handler);
}
[ExtensionAttribute]
internal static class Owin.MapExtensions : object {
    [ExtensionAttribute]
public static IAppBuilder Map(IAppBuilder app, string pathMatch, Action`1<IAppBuilder> configuration);
    [ExtensionAttribute]
public static IAppBuilder Map(IAppBuilder app, PathString pathMatch, Action`1<IAppBuilder> configuration);
}
[ExtensionAttribute]
internal static class Owin.MapWhenExtensions : object {
    [ExtensionAttribute]
public static IAppBuilder MapWhen(IAppBuilder app, Func`2<IOwinContext, bool> predicate, Action`1<IAppBuilder> configuration);
    [ExtensionAttribute]
public static IAppBuilder MapWhenAsync(IAppBuilder app, Func`2<IOwinContext, Task`1<bool>> predicate, Action`1<IAppBuilder> configuration);
}
internal enum Owin.PipelineStage : Enum {
    public int value__;
    public static PipelineStage Authenticate;
    public static PipelineStage PostAuthenticate;
    public static PipelineStage Authorize;
    public static PipelineStage PostAuthorize;
    public static PipelineStage ResolveCache;
    public static PipelineStage PostResolveCache;
    public static PipelineStage MapHandler;
    public static PipelineStage PostMapHandler;
    public static PipelineStage AcquireState;
    public static PipelineStage PostAcquireState;
    public static PipelineStage PreHandlerExecute;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
