[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Hangfire.GlobalConfigurationExtensions : object {
    [ExtensionAttribute]
public static IGlobalConfiguration`1<InMemoryStorage> UseInMemoryStorage(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<InMemoryStorage> UseInMemoryStorage(IGlobalConfiguration configuration, InMemoryStorageOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.CounterEntry : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MonotonicTime> <ExpireAt>k__BackingField;
    public string Key { get; }
    public long Value { get; public set; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public CounterEntry(string id);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MonotonicTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
}
internal class Hangfire.InMemory.Entities.ExpirableEntryComparer`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> _comparer;
    public ExpirableEntryComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(IExpirableEntry`1<T> x, IExpirableEntry`1<T> y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.HashEntry : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MonotonicTime> <ExpireAt>k__BackingField;
    public string Key { get; }
    public IDictionary`2<string, string> Value { get; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public HashEntry(string id, StringComparer comparer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MonotonicTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
}
[NullableContextAttribute("1")]
internal interface Hangfire.InMemory.Entities.IExpirableEntry`1 {
    public T Key { get; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public abstract virtual T get_Key();
    public abstract virtual Nullable`1<MonotonicTime> get_ExpireAt();
    public abstract virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.JobEntry`1 : object {
    private StateRecord[] _history;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] _parameters;
    [CompilerGeneratedAttribute]
private T <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationData <InvocationData>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private StateRecord <State>k__BackingField;
    [CompilerGeneratedAttribute]
private MonotonicTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MonotonicTime> <ExpireAt>k__BackingField;
    public T Key { get; }
    public InvocationData InvocationData { get; internal set; }
    [NullableAttribute("2")]
public StateRecord State { get; public set; }
    public IEnumerable`1<StateRecord> History { get; }
    public MonotonicTime CreatedAt { get; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public JobEntry`1(T key, InvocationData data, KeyValuePair`2[] parameters, MonotonicTime createdAt);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Key();
    [CompilerGeneratedAttribute]
public InvocationData get_InvocationData();
    [CompilerGeneratedAttribute]
internal void set_InvocationData(InvocationData value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public StateRecord get_State();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_State(StateRecord value);
    public IEnumerable`1<StateRecord> get_History();
    [CompilerGeneratedAttribute]
public MonotonicTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MonotonicTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
    public string GetParameter(string name, StringComparer comparer);
    public void SetParameter(string name, string value, StringComparer comparer);
    public KeyValuePair`2[] GetParameters();
    public void AddHistoryEntry(StateRecord record, int maxLength);
}
internal class Hangfire.InMemory.Entities.JobStateCreatedAtComparer`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> _comparer;
    public JobStateCreatedAtComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(JobEntry`1<T> x, JobEntry`1<T> y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.ListEntry : object {
    private LinkedList`1<string> _list;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MonotonicTime> <ExpireAt>k__BackingField;
    public string Key { get; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public int Count { get; }
    public ListEntry(string id);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MonotonicTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
    public int get_Count();
    public void Add(string value);
    public int RemoveAll(string value, StringComparer comparer);
    public int Trim(int keepStartingFrom, int keepEndingAt);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.LockEntry`1 : object {
    private SemaphoreSlim _semaphore;
    [NullableAttribute("2")]
private T _owner;
    private int _referenceCount;
    private int _level;
    private bool _finalized;
    public bool TryAcquire(T owner, TimeSpan timeout, Boolean& retry, Boolean& cleanUp);
    public void Release(T owner, Boolean& cleanUp);
    public sealed virtual void Dispose();
    private static void ThrowFinalizedException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.QueueEntry`1 : object {
    private static QueueWaitNode Tombstone;
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<TKey> <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueWaitNode <WaitHead>k__BackingField;
    public ConcurrentQueue`1<TKey> Queue { get; }
    public QueueWaitNode WaitHead { get; }
    private static QueueEntry`1();
    [CompilerGeneratedAttribute]
public ConcurrentQueue`1<TKey> get_Queue();
    [CompilerGeneratedAttribute]
public QueueWaitNode get_WaitHead();
    public void AddWaitNode(QueueWaitNode node);
    public void SignalOneWaitNode();
    private void SignalOneWaitNodeSlow();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.QueueWaitNode : object {
    public AutoResetEvent Value;
    public QueueWaitNode Next;
    public QueueWaitNode(AutoResetEvent value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.ServerEntry : object {
    [CompilerGeneratedAttribute]
private ServerContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private MonotonicTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private MonotonicTime <HeartbeatAt>k__BackingField;
    public ServerContext Context { get; }
    public MonotonicTime StartedAt { get; }
    public MonotonicTime HeartbeatAt { get; public set; }
    public ServerEntry(ServerContext context, MonotonicTime startedAt);
    [CompilerGeneratedAttribute]
public ServerContext get_Context();
    [CompilerGeneratedAttribute]
public MonotonicTime get_StartedAt();
    [CompilerGeneratedAttribute]
public MonotonicTime get_HeartbeatAt();
    [CompilerGeneratedAttribute]
public void set_HeartbeatAt(MonotonicTime value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.SetEntry : object {
    private SortedDictionary`2<string, SortedSetItem> _hash;
    private SortedSet`1<SortedSetItem> _value;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MonotonicTime> <ExpireAt>k__BackingField;
    public string Key { get; }
    public Nullable`1<MonotonicTime> ExpireAt { get; public set; }
    public int Count { get; }
    public SetEntry(string id, StringComparer stringComparer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<MonotonicTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpireAt(Nullable`1<MonotonicTime> value);
    public int get_Count();
    public void Add(string value, double score);
    public List`1<string> GetViewBetween(double from, double to, int count);
    [NullableContextAttribute("2")]
public string GetFirstBetween(double from, double to);
    public void Remove(string value);
    public bool Contains(string value);
    public sealed virtual IEnumerator`1<SortedSetItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Hangfire.InMemory.Entities.SortedSetItem : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Score>k__BackingField;
    public string Value { get; }
    public double Score { get; }
    public SortedSetItem(string value, double score);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public double get_Score();
    public sealed virtual bool Equals(SortedSetItem other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Hangfire.InMemory.Entities.SortedSetItemComparer : object {
    [NullableAttribute("1")]
private StringComparer _stringComparer;
    [NullableContextAttribute("1")]
public SortedSetItemComparer(StringComparer stringComparer);
    public sealed virtual int Compare(SortedSetItem x, SortedSetItem y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.Entities.StateRecord : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private MonotonicTime <CreatedAt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2[] <Data>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public string Reason { get; }
    public MonotonicTime CreatedAt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2[] Data { get; }
    public StateRecord(string name, string reason, KeyValuePair`2[] data, MonotonicTime createdAt);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public MonotonicTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_Data();
}
[NullableContextAttribute("1")]
internal interface Hangfire.InMemory.IKeyProvider`1 {
    public abstract virtual T GetUniqueKey();
    public abstract virtual bool TryParse(string input, T& key);
    public abstract virtual string ToString(T key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.InMemoryConnection`1 : JobStorageConnection {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<LockDisposable<TKey>> _acquiredLocks;
    [CompilerGeneratedAttribute]
private InMemoryStorageOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherBase`1<TKey> <Dispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IKeyProvider`1<TKey> <KeyProvider>k__BackingField;
    public InMemoryStorageOptions Options { get; }
    public DispatcherBase`1<TKey> Dispatcher { get; }
    public IKeyProvider`1<TKey> KeyProvider { get; }
    public InMemoryConnection`1(InMemoryStorageOptions options, DispatcherBase`1<TKey> dispatcher, IKeyProvider`1<TKey> keyProvider);
    [CompilerGeneratedAttribute]
public InMemoryStorageOptions get_Options();
    [CompilerGeneratedAttribute]
public DispatcherBase`1<TKey> get_Dispatcher();
    [CompilerGeneratedAttribute]
public IKeyProvider`1<TKey> get_KeyProvider();
    public virtual void Dispose();
    public virtual IWriteOnlyTransaction CreateWriteTransaction();
    public virtual IDisposable AcquireDistributedLock(string resource, TimeSpan timeout);
    public virtual string CreateExpiredJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    public virtual IFetchedJob FetchNextJob(String[] queues, CancellationToken cancellationToken);
    private InMemoryFetchedJob`1<TKey> FetchNextJobSlow(KeyValuePair`2[] entries, CancellationToken cancellationToken);
    public virtual void SetJobParameter(string id, string name, string value);
    public virtual string GetJobParameter(string id, string name);
    public virtual JobData GetJobData(string jobId);
    public virtual StateData GetStateData(string jobId);
    public virtual void AnnounceServer(string serverId, ServerContext context);
    public virtual void RemoveServer(string serverId);
    public virtual void Heartbeat(string serverId);
    public virtual int RemoveTimedOutServers(TimeSpan timeOut);
    public virtual DateTime GetUtcDateTime();
    public virtual HashSet`1<string> GetAllItemsFromSet(string key);
    public virtual string GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore);
    public virtual List`1<string> GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore, int count);
    public virtual bool GetSetContains(string key, string value);
    public virtual long GetSetCount(string key);
    public virtual long GetSetCount(IEnumerable`1<string> keys, int limit);
    public virtual long GetListCount(string key);
    public virtual long GetCounter(string key);
    public virtual long GetHashCount(string key);
    public virtual TimeSpan GetHashTtl(string key);
    public virtual TimeSpan GetListTtl(string key);
    public virtual TimeSpan GetSetTtl(string key);
    public virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public virtual Dictionary`2<string, string> GetAllEntriesFromHash(string key);
    public virtual string GetValueFromHash(string key, string name);
    public virtual List`1<string> GetAllItemsFromList(string key);
    public virtual List`1<string> GetRangeFromList(string key, int startingFrom, int endingAt);
    public virtual List`1<string> GetRangeFromSet(string key, int startingFrom, int endingAt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.InMemoryFetchedJob`1 : object {
    private InMemoryConnection`1<TKey> _connection;
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    public string QueueName { get; }
    public string JobId { get; }
    public InMemoryFetchedJob`1(InMemoryConnection`1<TKey> connection, string queueName, string jobId);
    [CompilerGeneratedAttribute]
public string get_QueueName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JobId();
    public sealed virtual void Requeue();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override void Hangfire.Storage.IFetchedJob.RemoveFromQueue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.InMemoryMonitoringApi`1 : JobStorageMonitor {
    private static String[] StatisticsStates;
    private static IReadOnlyDictionary`2<string, string> StatisticsCounters;
    private static IReadOnlyDictionary`2<string, string> StatisticsSets;
    private DispatcherBase`1<TKey> _dispatcher;
    private IKeyProvider`1<TKey> _keyProvider;
    public InMemoryMonitoringApi`1(DispatcherBase`1<TKey> dispatcher, IKeyProvider`1<TKey> keyProvider);
    private static InMemoryMonitoringApi`1();
    public virtual IList`1<QueueWithTopEnqueuedJobsDto> Queues();
    public virtual IList`1<ServerDto> Servers();
    public virtual JobDetailsDto JobDetails(string jobId);
    public virtual StatisticsDto GetStatistics();
    public virtual JobList`1<EnqueuedJobDto> EnqueuedJobs(string queue, int from, int perPage);
    public virtual JobList`1<FetchedJobDto> FetchedJobs(string queue, int from, int perPage);
    public virtual JobList`1<ProcessingJobDto> ProcessingJobs(int from, int count);
    public virtual JobList`1<ScheduledJobDto> ScheduledJobs(int from, int count);
    public virtual JobList`1<SucceededJobDto> SucceededJobs(int from, int count);
    public virtual JobList`1<FailedJobDto> FailedJobs(int from, int count);
    public virtual JobList`1<DeletedJobDto> DeletedJobs(int from, int count);
    public virtual JobList`1<AwaitingJobDto> AwaitingJobs(int from, int count);
    public virtual long ScheduledCount();
    public virtual long EnqueuedCount(string queue);
    public virtual long FetchedCount(string queue);
    public virtual long FailedCount();
    public virtual long ProcessingCount();
    public virtual long SucceededListCount();
    public virtual long DeletedListCount();
    public virtual long AwaitingCount();
    public virtual IDictionary`2<DateTime, long> SucceededByDatesCount();
    public virtual IDictionary`2<DateTime, long> FailedByDatesCount();
    public virtual IDictionary`2<DateTime, long> DeletedByDatesCount();
    public virtual IDictionary`2<DateTime, long> HourlySucceededJobs();
    public virtual IDictionary`2<DateTime, long> HourlyFailedJobs();
    public virtual IDictionary`2<DateTime, long> HourlyDeletedJobs();
    private long GetCountByStateName(string stateName);
    private static bool TryGetJobRecord(IReadOnlyDictionary`2<TKey, Record<TKey>> jobs, TKey key, string targetState, JobRecord& jobRecord);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hangfire.InMemory.InMemoryStorage : JobStorage {
    [NullableAttribute("2")]
private Dispatcher`1<Guid> _guidDispatcher;
    [NullableAttribute("2")]
private Dispatcher`1<ulong> _longDispatcher;
    private PaddedInt64 _nextId;
    private Dictionary`2<string, bool> _features;
    [CompilerGeneratedAttribute]
private InMemoryStorageOptions <Options>k__BackingField;
    public InMemoryStorageOptions Options { get; }
    public bool LinearizableReads { get; }
    public InMemoryStorage(InMemoryStorageOptions options);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public InMemoryStorageOptions get_Options();
    public virtual bool get_LinearizableReads();
    public virtual bool HasFeature(string featureId);
    public virtual IMonitoringApi GetMonitoringApi();
    public virtual IStorageConnection GetConnection();
    public virtual string ToString();
    private sealed virtual override Guid Hangfire.InMemory.IKeyProvider<System.Guid>.GetUniqueKey();
    private sealed virtual override bool Hangfire.InMemory.IKeyProvider<System.Guid>.TryParse(string input, Guid& key);
    private sealed virtual override string Hangfire.InMemory.IKeyProvider<System.Guid>.ToString(Guid key);
    private sealed virtual override ulong Hangfire.InMemory.IKeyProvider<System.UInt64>.GetUniqueKey();
    private sealed virtual override bool Hangfire.InMemory.IKeyProvider<System.UInt64>.TryParse(string input, UInt64& key);
    private sealed virtual override string Hangfire.InMemory.IKeyProvider<System.UInt64>.ToString(ulong key);
}
public enum Hangfire.InMemory.InMemoryStorageIdType : Enum {
    public int value__;
    public static InMemoryStorageIdType Long;
    public static InMemoryStorageIdType Guid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hangfire.InMemory.InMemoryStorageOptions : object {
    private int _maxStateHistoryLength;
    [CompilerGeneratedAttribute]
private InMemoryStorageIdType <IdType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <MaxExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <StringComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CommandTimeout>k__BackingField;
    public InMemoryStorageIdType IdType { get; public set; }
    public Nullable`1<TimeSpan> MaxExpirationTime { get; public set; }
    public int MaxStateHistoryLength { get; public set; }
    public StringComparer StringComparer { get; public set; }
    public TimeSpan CommandTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public InMemoryStorageIdType get_IdType();
    [CompilerGeneratedAttribute]
public void set_IdType(InMemoryStorageIdType value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MaxExpirationTime();
    [CompilerGeneratedAttribute]
public void set_MaxExpirationTime(Nullable`1<TimeSpan> value);
    public int get_MaxStateHistoryLength();
    public void set_MaxStateHistoryLength(int value);
    [CompilerGeneratedAttribute]
public StringComparer get_StringComparer();
    [CompilerGeneratedAttribute]
public void set_StringComparer(StringComparer value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(TimeSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.InMemoryTransaction`1 : JobStorageTransaction {
    private InMemoryConnection`1<TKey> _connection;
    private static int MaxCommandsInList;
    private List`1<ICommand`1<TKey>> _commands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedList`1<ICommand`1<TKey>> _additionalCommands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDisposable> _acquiredLocks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _enqueued;
    public InMemoryTransaction`1(InMemoryConnection`1<TKey> connection);
    public virtual void Dispose();
    public virtual void Commit();
    public virtual void AcquireDistributedLock(string resource, TimeSpan timeout);
    public virtual string CreateJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    public virtual void SetJobParameter(string jobId, string name, string value);
    public virtual void ExpireJob(string jobId, TimeSpan expireIn);
    public virtual void PersistJob(string jobId);
    public virtual void SetJobState(string jobId, IState state);
    public virtual void AddJobState(string jobId, IState state);
    public virtual void AddToQueue(string queue, string jobId);
    public virtual void RemoveFromQueue(IFetchedJob fetchedJob);
    public virtual void IncrementCounter(string key);
    public virtual void IncrementCounter(string key, TimeSpan expireIn);
    public virtual void DecrementCounter(string key);
    public virtual void DecrementCounter(string key, TimeSpan expireIn);
    public virtual void AddToSet(string key, string value);
    public virtual void AddToSet(string key, string value, double score);
    public virtual void RemoveFromSet(string key, string value);
    public virtual void InsertToList(string key, string value);
    public virtual void RemoveFromList(string key, string value);
    public virtual void TrimList(string key, int keepStartingFrom, int keepEndingAt);
    public virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public virtual void RemoveHash(string key);
    public virtual void AddRangeToSet(string key, IList`1<string> items);
    public virtual void RemoveSet(string key);
    public virtual void ExpireHash(string key, TimeSpan expireIn);
    public virtual void ExpireList(string key, TimeSpan expireIn);
    public virtual void ExpireSet(string key, TimeSpan expireIn);
    public virtual void PersistHash(string key);
    public virtual void PersistList(string key);
    public virtual void PersistSet(string key);
    private void AddCommand(ICommand`1<TKey> action);
    private bool CommitCore(MemoryState`1<TKey> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Hangfire.InMemory.State.Commands`1 : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Hangfire.InMemory.State.Dispatcher`1 : DispatcherBase`1<TKey> {
    private static UInt32 DefaultEvictionIntervalMs;
    private SemaphoreSlim _semaphore;
    private ConcurrentQueue`1<IDispatcherCallback`1<TKey>> _queries;
    private Thread _thread;
    private ILog _logger;
    private CancellationTokenSource _cts;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private PaddedInt64 _outstandingRequests;
    [CompilerGeneratedAttribute]
private TimeSpan <CommandTimeout>k__BackingField;
    public TimeSpan CommandTimeout { get; public set; }
    public Dispatcher`1(string threadName, Func`1<MonotonicTime> timeResolver, MemoryState`1<TKey> state);
    [CompilerGeneratedAttribute]
public TimeSpan get_CommandTimeout();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CommandTimeout(TimeSpan value);
    public sealed virtual void Dispose();
    public virtual T QueryWriteAndWait(TCommand query, Func`3<TCommand, MemoryState`1<TKey>, T> func);
    public virtual T QueryReadAndWait(TCommand query, Func`3<TCommand, MemoryState`1<TKey>, T> func);
    private void DoWork();
    private void EvictExpiredEntriesIfNeeded(Int32& lastEviction);
    private static void ThrowObjectDisposedException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Hangfire.InMemory.State.DispatcherBase`1 : object {
    private Func`1<MonotonicTime> _timeResolver;
    private MemoryState`1<TKey> _state;
    protected MemoryState`1<TKey> State { get; }
    protected DispatcherBase`1(Func`1<MonotonicTime> timeResolver, MemoryState`1<TKey> state);
    protected MemoryState`1<TKey> get_State();
    public MonotonicTime GetMonotonicTime();
    public KeyValuePair`2[] GetOrAddQueues(IReadOnlyCollection`1<string> queueNames);
    public bool TryAcquireLockEntry(JobStorageConnection owner, string resource, TimeSpan timeout, LockEntry`1& entry);
    public void ReleaseLockEntry(JobStorageConnection owner, string resource, LockEntry`1<JobStorageConnection> entry);
    private void CleanUpLockEntry(string resource, LockEntry`1<JobStorageConnection> entry);
    public virtual T QueryWriteAndWait(TCommand query, Func`3<TCommand, MemoryState`1<TKey>, T> func);
    public virtual T QueryReadAndWait(TCommand query, Func`3<TCommand, MemoryState`1<TKey>, T> func);
    protected void EvictExpiredEntries();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.State.DispatcherCallback`3 : object {
    [NullableAttribute("1")]
private ManualResetEventSlim _ready;
    [NullableAttribute("1")]
private TCommand _command;
    [NullableAttribute("1")]
private Func`3<TCommand, MemoryState`1<TKey>, TResult> _func;
    private TResult _result;
    private Exception _exception;
    public TResult Result { get; }
    public Exception Exception { get; }
    [NullableContextAttribute("1")]
public DispatcherCallback`3(TCommand command, Func`3<TCommand, MemoryState`1<TKey>, TResult> func);
    public TResult get_Result();
    public Exception get_Exception();
    [NullableContextAttribute("1")]
public sealed virtual void Execute(MemoryState`1<TKey> state);
    public bool Wait(TimeSpan timeout, CancellationToken token);
    public sealed virtual void Dispose();
    private void TrySetReady();
}
[ExtensionAttribute]
internal static class Hangfire.InMemory.State.DispatcherExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void QueryWriteAndWait(DispatcherBase`1<TKey> dispatcher, TCommand query);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Hangfire.InMemory.State.ExceptionHelper : object {
    private static Type StackOverflowType;
    private static Type OutOfMemoryType;
    private static ExceptionHelper();
    public static bool IsCatchableExceptionType(Exception ex);
}
[ExtensionAttribute]
internal static class Hangfire.InMemory.State.ExtensionMethods : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Job TryGetJob(InvocationData data, JobLoadException& exception);
}
[NullableContextAttribute("1")]
internal interface Hangfire.InMemory.State.ICommand`1 {
    public abstract virtual void Execute(MemoryState`1<TKey> state);
}
[NullableContextAttribute("1")]
internal interface Hangfire.InMemory.State.IDispatcherCallback`1 {
    public abstract virtual void Execute(MemoryState`1<TKey> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hangfire.InMemory.State.MemoryState`1 : object {
    private JobStateCreatedAtComparer`1<TKey> _jobEntryComparer;
    [CompilerGeneratedAttribute]
private StringComparer <StringComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, LockEntry`1<JobStorageConnection>> <Locks>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, QueueEntry`1<TKey>> <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<TKey, JobEntry`1<TKey>> <Jobs>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<string, HashEntry> <Hashes>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<string, ListEntry> <Lists>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<string, SetEntry> <Sets>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<string, CounterEntry> <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<string, ServerEntry> <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SortedSet`1<JobEntry`1<TKey>>> <JobStateIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSet`1<JobEntry`1<TKey>> <ExpiringJobsIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSet`1<CounterEntry> <ExpiringCountersIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSet`1<HashEntry> <ExpiringHashesIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSet`1<ListEntry> <ExpiringListsIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSet`1<SetEntry> <ExpiringSetsIndex>k__BackingField;
    public StringComparer StringComparer { get; }
    public ConcurrentDictionary`2<string, LockEntry`1<JobStorageConnection>> Locks { get; }
    public ConcurrentDictionary`2<string, QueueEntry`1<TKey>> Queues { get; }
    public SortedDictionary`2<TKey, JobEntry`1<TKey>> Jobs { get; }
    public SortedDictionary`2<string, HashEntry> Hashes { get; }
    public SortedDictionary`2<string, ListEntry> Lists { get; }
    public SortedDictionary`2<string, SetEntry> Sets { get; }
    public SortedDictionary`2<string, CounterEntry> Counters { get; }
    public SortedDictionary`2<string, ServerEntry> Servers { get; }
    public Dictionary`2<string, SortedSet`1<JobEntry`1<TKey>>> JobStateIndex { get; }
    public SortedSet`1<JobEntry`1<TKey>> ExpiringJobsIndex { get; }
    public SortedSet`1<CounterEntry> ExpiringCountersIndex { get; }
    public SortedSet`1<HashEntry> ExpiringHashesIndex { get; }
    public SortedSet`1<ListEntry> ExpiringListsIndex { get; }
    public SortedSet`1<SetEntry> ExpiringSetsIndex { get; }
    public MemoryState`1(StringComparer stringComparer, IComparer`1<TKey> keyComparer);
    [CompilerGeneratedAttribute]
public StringComparer get_StringComparer();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, LockEntry`1<JobStorageConnection>> get_Locks();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, QueueEntry`1<TKey>> get_Queues();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<TKey, JobEntry`1<TKey>> get_Jobs();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<string, HashEntry> get_Hashes();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<string, ListEntry> get_Lists();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<string, SetEntry> get_Sets();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<string, CounterEntry> get_Counters();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<string, ServerEntry> get_Servers();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SortedSet`1<JobEntry`1<TKey>>> get_JobStateIndex();
    [CompilerGeneratedAttribute]
public SortedSet`1<JobEntry`1<TKey>> get_ExpiringJobsIndex();
    [CompilerGeneratedAttribute]
public SortedSet`1<CounterEntry> get_ExpiringCountersIndex();
    [CompilerGeneratedAttribute]
public SortedSet`1<HashEntry> get_ExpiringHashesIndex();
    [CompilerGeneratedAttribute]
public SortedSet`1<ListEntry> get_ExpiringListsIndex();
    [CompilerGeneratedAttribute]
public SortedSet`1<SetEntry> get_ExpiringSetsIndex();
    public QueueEntry`1<TKey> QueueGetOrAdd(string name);
    public void JobCreate(JobEntry`1<TKey> entry, Nullable`1<TimeSpan> expireIn);
    public void JobSetState(JobEntry`1<TKey> entry, StateRecord state);
    public void JobExpire(JobEntry`1<TKey> entry, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn, Nullable`1<TimeSpan> maxExpiration);
    public void JobDelete(JobEntry`1<TKey> entry);
    public HashEntry HashGetOrAdd(string key);
    public void HashExpire(HashEntry entry, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn, Nullable`1<TimeSpan> maxExpiration);
    public void HashDelete(HashEntry entry);
    public SetEntry SetGetOrAdd(string key);
    public void SetExpire(SetEntry entry, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn, Nullable`1<TimeSpan> maxExpiration);
    public void SetDelete(SetEntry entry);
    public ListEntry ListGetOrAdd(string key);
    public void ListExpire(ListEntry entry, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn, Nullable`1<TimeSpan> maxExpiration);
    public void ListDelete(ListEntry entry);
    public CounterEntry CounterGetOrAdd(string key);
    public void CounterExpire(CounterEntry entry, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn);
    public void CounterDelete(CounterEntry entry);
    public void ServerAdd(string serverId, ServerEntry entry);
    public bool ServerRemove(string serverId);
    public void EvictExpiredEntries(MonotonicTime now);
    private static void EvictFromIndex(MonotonicTime now, SortedSet`1<TEntry> index, Action`1<TEntry> action);
    private static void EntryRemove(TEntry entry, IDictionary`2<TEntryKey, TEntry> index, ISet`1<TEntry> expirationIndex);
    private static bool EntryExpire(TEntry entry, SortedSet`1<TEntry> index, Nullable`1<MonotonicTime> now, Nullable`1<TimeSpan> expireIn, Nullable`1<TimeSpan> maxExpiration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Hangfire.InMemory.State.MonitoringQueries`1 : object {
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
internal class Hangfire.InMemory.State.MonotonicTime : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static double TickFrequency;
    private long _timestamp;
    private MonotonicTime(long timestamp);
    private static MonotonicTime();
    public static MonotonicTime GetCurrent();
    public MonotonicTime Add(TimeSpan value);
    public DateTime ToUtcDateTime();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MonotonicTime other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MonotonicTime other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static TimeSpan op_Subtraction(MonotonicTime left, MonotonicTime right);
    public static bool op_Equality(MonotonicTime left, MonotonicTime right);
    public static bool op_Inequality(MonotonicTime left, MonotonicTime right);
    public static bool op_LessThan(MonotonicTime left, MonotonicTime right);
    public static bool op_LessThanOrEqual(MonotonicTime left, MonotonicTime right);
    public static bool op_GreaterThan(MonotonicTime left, MonotonicTime right);
    public static bool op_GreaterThanOrEqual(MonotonicTime left, MonotonicTime right);
    [NullableContextAttribute("1")]
private string DebuggerToString();
}
internal class Hangfire.InMemory.State.PaddedInt64 : ValueType {
    private static int CacheLineSize;
    internal long Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Hangfire.InMemory.State.Queries`1 : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
