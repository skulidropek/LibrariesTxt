[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Dapper.CommandDefinition : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDbTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandTimeout>k__BackingField;
    internal CommandType CommandTypeDirect;
    [CompilerGeneratedAttribute]
private CommandFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Link`2<Type, Action`1<IDbCommand>> commandInitCache;
    [NullableAttribute("1")]
public string CommandText { get; }
    public object Parameters { get; }
    public IDbTransaction Transaction { get; }
    public Nullable`1<int> CommandTimeout { get; }
    public Nullable`1<CommandType> CommandType { get; }
    public bool Buffered { get; }
    internal bool AddToCache { get; }
    public CommandFlags Flags { get; }
    public bool Pipelined { get; }
    public CancellationToken CancellationToken { get; }
    public CommandDefinition(string commandText, object parameters, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType, CommandFlags flags, CancellationToken cancellationToken);
    private CommandDefinition(object parameters);
    internal static CommandDefinition ForCallback(object parameters);
    internal void OnCompleted();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CommandText();
    [CompilerGeneratedAttribute]
public object get_Parameters();
    [CompilerGeneratedAttribute]
public IDbTransaction get_Transaction();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandTimeout();
    public Nullable`1<CommandType> get_CommandType();
    public bool get_Buffered();
    internal bool get_AddToCache();
    [CompilerGeneratedAttribute]
public CommandFlags get_Flags();
    public bool get_Pipelined();
    [NullableContextAttribute("1")]
internal static CommandType InferCommandType(string sql);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [NullableContextAttribute("1")]
internal IDbCommand SetupCommand(IDbConnection cnn, Action`2<IDbCommand, object> paramReader);
    internal static void ResetCommandInitCache();
    [NullableContextAttribute("1")]
private static Action`1<IDbCommand> GetInit(Type commandType);
    [NullableContextAttribute("1")]
private static MethodInfo GetBasicPropertySetter(Type declaringType, string name, Type expectedType);
}
[FlagsAttribute]
internal enum Dapper.CommandFlags : Enum {
    public int value__;
    public static CommandFlags None;
    public static CommandFlags Buffered;
    public static CommandFlags Pipelined;
    public static CommandFlags NoCache;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Dapper.CompiledRegex : object {
    private static string WhitespaceOrReservedPattern;
    private static string LegacyParameterPattern;
    private static string LiteralTokensPattern;
    private static string PseudoPositionalPattern;
    [CompilerGeneratedAttribute]
private static Regex <LegacyParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <LiteralTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <PseudoPositional>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <WhitespaceOrReserved>k__BackingField;
    internal static Regex LegacyParameter { get; }
    internal static Regex LiteralTokens { get; }
    internal static Regex PseudoPositional { get; }
    internal static Regex WhitespaceOrReserved { get; }
    private static CompiledRegex();
    [CompilerGeneratedAttribute]
internal static Regex get_LegacyParameter();
    [CompilerGeneratedAttribute]
internal static Regex get_LiteralTokens();
    [CompilerGeneratedAttribute]
internal static Regex get_PseudoPositional();
    [CompilerGeneratedAttribute]
internal static Regex get_WhitespaceOrReserved();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.CustomPropertyTypeMap : object {
    private Type _type;
    private Func`3<Type, string, PropertyInfo> _propertySelector;
    public CustomPropertyTypeMap(Type type, Func`3<Type, string, PropertyInfo> propertySelector);
    public sealed virtual ConstructorInfo FindConstructor(String[] names, Type[] types);
    [NullableContextAttribute("2")]
public sealed virtual ConstructorInfo FindExplicitConstructor();
    public sealed virtual IMemberMap GetConstructorParameter(ConstructorInfo constructor, string columnName);
    public sealed virtual IMemberMap GetMember(string columnName);
}
internal class Dapper.DataTableHandler : object {
    [NullableContextAttribute("1")]
public sealed virtual object Parse(Type destinationType, object value);
    [NullableContextAttribute("1")]
public sealed virtual void SetValue(IDbDataParameter parameter, object value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Dapper.DbString : object {
    [CompilerGeneratedAttribute]
private static bool <IsAnsiDefault>k__BackingField;
    public static int DefaultLength;
    [CompilerGeneratedAttribute]
private bool <IsAnsi>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public static bool IsAnsiDefault { get; public set; }
    public bool IsAnsi { get; public set; }
    public bool IsFixedLength { get; public set; }
    public int Length { get; public set; }
    public string Value { get; public set; }
    public DbString(string value, int length);
    [CompilerGeneratedAttribute]
public static bool get_IsAnsiDefault();
    [CompilerGeneratedAttribute]
public static void set_IsAnsiDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAnsi();
    [CompilerGeneratedAttribute]
public void set_IsAnsi(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFixedLength();
    [CompilerGeneratedAttribute]
public void set_IsFixedLength(bool value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual void AddParameter(IDbCommand command, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Dapper.DbWrappedReader : DbDataReader {
    private DbDataReader _reader;
    private IDbCommand _cmd;
    private IDataReader Dapper.IWrappedDataReader.Reader { get; }
    private IDbCommand Dapper.IWrappedDataReader.Command { get; }
    public bool HasRows { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public int VisibleFieldCount { get; }
    public DbWrappedReader(IDbCommand cmd, DbDataReader reader);
    public static DbDataReader Create(IDbCommand cmd, DbDataReader reader);
    private sealed virtual override IDataReader Dapper.IWrappedDataReader.get_Reader();
    private sealed virtual override IDbCommand Dapper.IWrappedDataReader.get_Command();
    public virtual bool get_HasRows();
    public virtual void Close();
    [NullableContextAttribute("2")]
public virtual DataTable GetSchemaTable();
    public virtual object InitializeLifetimeService();
    public virtual int get_Depth();
    public virtual bool get_IsClosed();
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual int get_RecordsAffected();
    protected virtual void Dispose(bool disposing);
    public virtual int get_FieldCount();
    public virtual bool GetBoolean(int i);
    public virtual byte GetByte(int i);
    [NullableContextAttribute("2")]
public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual char GetChar(int i);
    [NullableContextAttribute("2")]
public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual string GetDataTypeName(int i);
    public virtual DateTime GetDateTime(int i);
    public virtual decimal GetDecimal(int i);
    public virtual double GetDouble(int i);
    public virtual Type GetFieldType(int i);
    public virtual float GetFloat(int i);
    public virtual Guid GetGuid(int i);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public virtual string GetName(int i);
    public virtual int GetOrdinal(string name);
    public virtual string GetString(int i);
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int i);
    public virtual object get_Item(string name);
    public virtual object get_Item(int i);
    [NullableContextAttribute("0")]
public virtual T GetFieldValue(int ordinal);
    [NullableContextAttribute("0")]
public virtual Task`1<T> GetFieldValueAsync(int ordinal, CancellationToken cancellationToken);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual Stream GetStream(int ordinal);
    public virtual TextReader GetTextReader(int ordinal);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual int get_VisibleFieldCount();
    protected virtual DbDataReader GetDbDataReader(int ordinal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.DefaultTypeMap : object {
    private List`1<FieldInfo> _fields;
    private Type _type;
    [CompilerGeneratedAttribute]
private static bool <MatchNamesWithUnderscores>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PropertyInfo> <Properties>k__BackingField;
    public static bool MatchNamesWithUnderscores { get; public set; }
    public List`1<PropertyInfo> Properties { get; }
    public DefaultTypeMap(Type type);
    internal static MethodInfo GetPropertySetterOrThrow(PropertyInfo propertyInfo, Type type);
    internal static MethodInfo GetPropertySetter(PropertyInfo propertyInfo, Type type);
    internal static List`1<PropertyInfo> GetSettableProps(Type t);
    internal static List`1<FieldInfo> GetSettableFields(Type t);
    public sealed virtual ConstructorInfo FindConstructor(String[] names, Type[] types);
    [NullableContextAttribute("2")]
public sealed virtual ConstructorInfo FindExplicitConstructor();
    public sealed virtual IMemberMap GetConstructorParameter(ConstructorInfo constructor, string columnName);
    public sealed virtual IMemberMap GetMember(string columnName);
    [CompilerGeneratedAttribute]
public static bool get_MatchNamesWithUnderscores();
    [CompilerGeneratedAttribute]
public static void set_MatchNamesWithUnderscores(bool value);
    [NullableContextAttribute("2")]
private static T MatchFirstOrDefault(IList`1<T> members, string name, Func`2<T, string> selector);
    [NullableContextAttribute("2")]
internal static bool EqualsCI(string x, string y);
    [NullableContextAttribute("2")]
internal static bool EqualsCIU(string x, string y);
    [CompilerGeneratedAttribute]
public List`1<PropertyInfo> get_Properties();
    [CompilerGeneratedAttribute]
internal static MethodInfo <GetPropertySetterOrThrow>g__Throw|3_0(PropertyInfo propertyInfo);
    [CompilerGeneratedAttribute]
internal static ParameterInfo <GetConstructorParameter>g__Throw|9_1(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Dapper.DisposedReader : DbDataReader {
    internal static DisposedReader Instance;
    public int Depth { get; }
    public int FieldCount { get; }
    public bool IsClosed { get; }
    public bool HasRows { get; }
    public int RecordsAffected { get; }
    public int VisibleFieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    private static DisposedReader();
    public virtual int get_Depth();
    public virtual int get_FieldCount();
    public virtual bool get_IsClosed();
    public virtual bool get_HasRows();
    public virtual int get_RecordsAffected();
    public virtual int get_VisibleFieldCount();
    private static T ThrowDisposed();
    [AsyncStateMachineAttribute("Dapper.DisposedReader/<ThrowDisposedAsync>d__15`1")]
private static Task`1<T> ThrowDisposedAsync();
    public virtual void Close();
    public virtual DataTable GetSchemaTable();
    public virtual object InitializeLifetimeService();
    protected virtual void Dispose(bool disposing);
    public virtual bool GetBoolean(int ordinal);
    [NullableContextAttribute("2")]
public virtual long GetBytes(int ordinal, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    public virtual float GetFloat(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual char GetChar(int ordinal);
    [NullableContextAttribute("2")]
public virtual long GetChars(int ordinal, long dataOffset, Char[] buffer, int bufferOffset, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    protected virtual DbDataReader GetDbDataReader(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int ordinal);
    [NullableContextAttribute("0")]
public virtual T GetFieldValue(int ordinal);
    [NullableContextAttribute("0")]
public virtual Task`1<T> GetFieldValueAsync(int ordinal, CancellationToken cancellationToken);
    public virtual Guid GetGuid(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual Stream GetStream(int ordinal);
    public virtual string GetString(int ordinal);
    public virtual TextReader GetTextReader(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int ordinal);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual object get_Item(int ordinal);
    public virtual object get_Item(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.DynamicParameters : object {
    internal static DbType EnumerableMultiParameter;
    private static Dictionary`2<Identity, Action`2<IDbCommand, object>> paramReaderCache;
    private Dictionary`2<string, ParamInfo> parameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<object> templates;
    [CompilerGeneratedAttribute]
private bool <RemoveUnused>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action> outputCallbacks;
    [NullableAttribute("2")]
private object Dapper.SqlMapper.IParameterLookup.Item { get; }
    public bool RemoveUnused { get; public set; }
    public IEnumerable`1<string> ParameterNames { get; }
    [NullableContextAttribute("2")]
public DynamicParameters(object template);
    private static DynamicParameters();
    private sealed virtual override object Dapper.SqlMapper.IParameterLookup.get_Item(string name);
    [NullableContextAttribute("2")]
public void AddDynamicParams(object param);
    public void Add(string name, object value, Nullable`1<DbType> dbType, Nullable`1<ParameterDirection> direction, Nullable`1<int> size);
    public void Add(string name, object value, Nullable`1<DbType> dbType, Nullable`1<ParameterDirection> direction, Nullable`1<int> size, Nullable`1<byte> precision, Nullable`1<byte> scale);
    private static string Clean(string name);
    private sealed virtual override void Dapper.SqlMapper.IDynamicParameters.AddParameters(IDbCommand command, Identity identity);
    [CompilerGeneratedAttribute]
public bool get_RemoveUnused();
    [CompilerGeneratedAttribute]
public void set_RemoveUnused(bool value);
    internal static bool ShouldSetDbType(Nullable`1<DbType> dbType);
    internal static bool ShouldSetDbType(DbType dbType);
    protected void AddParameters(IDbCommand command, Identity identity);
    public IEnumerable`1<string> get_ParameterNames();
    public T Get(string name);
    public DynamicParameters Output(T target, Expression`1<Func`2<T, object>> expression, Nullable`1<DbType> dbType, Nullable`1<int> size);
    private sealed virtual override void Dapper.SqlMapper.IParameterCallbacks.OnCompleted();
    [CompilerGeneratedAttribute]
internal static void <Output>g__ThrowInvalidChain|24_0();
}
[AttributeUsageAttribute("96")]
internal class Dapper.ExplicitConstructorAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Dapper.Extensions : object {
    [ExtensionAttribute]
internal static Task`1<TTo> CastResult(Task`1<TFrom> task);
    private static void OnTaskCompleted(Task`1<TFrom> completedTask, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.FeatureSupport : object {
    private static FeatureSupport Default;
    private static FeatureSupport Postgres;
    private static FeatureSupport ClickHouse;
    [CompilerGeneratedAttribute]
private bool <Arrays>k__BackingField;
    public bool Arrays { get; }
    private FeatureSupport(bool arrays);
    private static FeatureSupport();
    public static FeatureSupport Get(IDbConnection connection);
    [CompilerGeneratedAttribute]
public bool get_Arrays();
}
[NullableContextAttribute("1")]
internal interface Dapper.IWrappedDataReader {
    public IDataReader Reader { get; }
    public IDbCommand Command { get; }
    public abstract virtual IDataReader get_Reader();
    public abstract virtual IDbCommand get_Command();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Dapper.SimpleMemberMap : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfo <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [NullableAttribute("1")]
public string ColumnName { get; }
    [NullableAttribute("1")]
public Type MemberType { get; }
    public PropertyInfo Property { get; }
    public FieldInfo Field { get; }
    public ParameterInfo Parameter { get; }
    [NullableContextAttribute("1")]
public SimpleMemberMap(string columnName, PropertyInfo property);
    [NullableContextAttribute("1")]
public SimpleMemberMap(string columnName, FieldInfo field);
    [NullableContextAttribute("1")]
public SimpleMemberMap(string columnName, ParameterInfo parameter);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    [NullableContextAttribute("1")]
public sealed virtual Type get_MemberType();
    [CompilerGeneratedAttribute]
public sealed virtual PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public sealed virtual FieldInfo get_Field();
    [CompilerGeneratedAttribute]
public sealed virtual ParameterInfo get_Parameter();
}
internal class Dapper.SqlDataRecordHandler`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual object Parse(Type destinationType, object value);
    [NullableContextAttribute("1")]
public sealed virtual void SetValue(IDbDataParameter parameter, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.SqlDataRecordListTVPParameter`1 : object {
    private IEnumerable`1<T> data;
    private string typeName;
    public SqlDataRecordListTVPParameter`1(IEnumerable`1<T> data, string typeName);
    private sealed virtual override void Dapper.SqlMapper.ICustomQueryParameter.AddParameter(IDbCommand command, string name);
    internal static void Set(IDbDataParameter parameter, IEnumerable`1<T> data, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Dapper.SqlMapper : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static EventHandler QueryCachePurged;
    private static ConcurrentDictionary`2<Identity, CacheInfo> _queryCache;
    private static int COLLECT_PER_ITEMS;
    private static int COLLECT_HIT_COUNT_MIN;
    private static int collect;
    private static Dictionary`2<Type, TypeMapEntry> typeMap;
    private static Dictionary`2<Type, ITypeHandler> typeHandlers;
    internal static string LinqBinary;
    private static string ObsoleteInternalUsageOnly;
    private static Int32[] ErrTwoRows;
    private static Int32[] ErrZeroRows;
    internal static MethodInfo format;
    private static Dictionary`2<TypeCode, MethodInfo> toStrings;
    private static MethodInfo StringReplace;
    private static MethodInfo InvariantCulture;
    private static Hashtable s_ReadViaGetFieldValueCache;
    private static MethodInfo enumParse;
    private static MethodInfo getItem;
    private static MethodInfo getFieldValueT;
    private static MethodInfo isDbNull;
    public static Func`2<Type, ITypeMap> TypeMapProvider;
    private static Hashtable _typeMaps;
    private static IEqualityComparer`1<string> connectionStringComparer;
    private static string DataTableTypeNameKey;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder perThreadStringBuilderCache;
    public static IEqualityComparer`1<string> ConnectionStringComparer { get; public set; }
    private static SqlMapper();
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<object>> QueryAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<object>> QueryAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstOrDefaultAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleOrDefaultAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<T>> QueryAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<T> QueryFirstAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> QueryFirstOrDefaultAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<T> QuerySingleAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> QuerySingleOrDefaultAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstOrDefaultAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleOrDefaultAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<object>> QueryAsync(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstAsync(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstOrDefaultAsync(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleAsync(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleOrDefaultAsync(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<T>> QueryAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<object>> QueryAsync(IDbConnection cnn, Type type, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstAsync(IDbConnection cnn, Type type, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<T> QueryFirstAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QueryFirstOrDefaultAsync(IDbConnection cnn, Type type, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<T> QueryFirstOrDefaultAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleAsync(IDbConnection cnn, Type type, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<T> QuerySingleAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<object> QuerySingleOrDefaultAsync(IDbConnection cnn, Type type, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<T> QuerySingleOrDefaultAsync(IDbConnection cnn, CommandDefinition command);
    private static Task`1<DbDataReader> ExecuteReaderWithFlagsFallbackAsync(DbCommand cmd, bool wasClosed, CommandBehavior behavior, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static Task TryOpenAsync(IDbConnection cnn, CancellationToken cancel);
    [ExtensionAttribute]
private static DbCommand TrySetupAsyncCommand(CommandDefinition command, IDbConnection cnn, Action`2<IDbCommand, object> paramReader);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<QueryAsync>d__33`1")]
[ExtensionAttribute]
private static Task`1<IEnumerable`1<T>> QueryAsync(IDbConnection cnn, Type effectiveType, CommandDefinition command);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<QueryRowAsync>d__34`1")]
[ExtensionAttribute]
private static Task`1<T> QueryRowAsync(IDbConnection cnn, Row row, Type effectiveType, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<int> ExecuteAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<int> ExecuteAsync(IDbConnection cnn, CommandDefinition command);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<ExecuteMultiImplAsync>d__38")]
private static Task`1<int> ExecuteMultiImplAsync(IDbConnection cnn, CommandDefinition command, IEnumerable multiExec);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<ExecuteImplAsync>d__39")]
private static Task`1<int> ExecuteImplAsync(IDbConnection cnn, CommandDefinition command, object param);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`3<TFirst, TSecond, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`3<TFirst, TSecond, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`4<TFirst, TSecond, TThird, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`4<TFirst, TSecond, TThird, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`5<TFirst, TSecond, TThird, TFourth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`5<TFirst, TSecond, TThird, TFourth, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`6<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`6<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`7<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`7<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Func`8<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, CommandDefinition command, Func`8<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map, string splitOn);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Dapper.SqlMapper/<MultiMapAsync>d__52`8")]
[ExtensionAttribute]
private static Task`1<IEnumerable`1<TReturn>> MultiMapAsync(IDbConnection cnn, CommandDefinition command, Delegate map, string splitOn);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<TReturn>> QueryAsync(IDbConnection cnn, string sql, Type[] types, Func`2<Object[], TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<MultiMapAsync>d__54`1")]
[ExtensionAttribute]
private static Task`1<IEnumerable`1<TReturn>> MultiMapAsync(IDbConnection cnn, CommandDefinition command, Type[] types, Func`2<Object[], TReturn> map, string splitOn);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<ExecuteReaderSync>d__55`1")]
private static IEnumerable`1<T> ExecuteReaderSync(DbDataReader reader, Func`2<DbDataReader, object> func, object parameters);
    [ExtensionAttribute]
public static Task`1<GridReader> QueryMultipleAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<QueryMultipleAsync>d__57")]
[ExtensionAttribute]
public static Task`1<GridReader> QueryMultipleAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<IDataReader> ExecuteReaderAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<DbDataReader> ExecuteReaderAsync(DbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<IDataReader> ExecuteReaderAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<DbDataReader> ExecuteReaderAsync(DbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<IDataReader> ExecuteReaderAsync(IDbConnection cnn, CommandDefinition command, CommandBehavior commandBehavior);
    [ExtensionAttribute]
public static Task`1<DbDataReader> ExecuteReaderAsync(DbConnection cnn, CommandDefinition command, CommandBehavior commandBehavior);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<ExecuteWrappedReaderImplAsync>d__64")]
private static Task`1<DbDataReader> ExecuteWrappedReaderImplAsync(IDbConnection cnn, CommandDefinition command, CommandBehavior commandBehavior);
    [ExtensionAttribute]
public static Task`1<object> ExecuteScalarAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> ExecuteScalarAsync(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static Task`1<object> ExecuteScalarAsync(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static Task`1<T> ExecuteScalarAsync(IDbConnection cnn, CommandDefinition command);
    [AsyncStateMachineAttribute("Dapper.SqlMapper/<ExecuteScalarImplAsync>d__69`1")]
private static Task`1<T> ExecuteScalarImplAsync(IDbConnection cnn, CommandDefinition command);
    private static int GetColumnHash(DbDataReader reader, int startBound, int length);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void add_QueryCachePurged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void remove_QueryCachePurged(EventHandler value);
    private static void OnQueryCachePurged();
    private static void SetQueryCache(Identity key, CacheInfo value);
    private static void CollectCacheGarbage();
    private static bool TryGetQueryCache(Identity key, CacheInfo& value);
    public static void PurgeQueryCache();
    private static void PurgeQueryCacheByType(Type type);
    public static int GetCachedSQLCount();
    public static IEnumerable`1<Tuple`3<string, string, int>> GetCachedSQL(int ignoreHitCountAbove);
    public static IEnumerable`1<Tuple`2<int, int>> GetHashCollissions();
    public static void ResetTypeHandlers();
    [MemberNotNullAttribute("typeHandlers")]
private static void ResetTypeHandlers(bool clone);
    public static void AddTypeMap(Type type, DbType dbType);
    public static void AddTypeMap(Type type, DbType dbType, bool useGetFieldValue);
    private static void SetTypeMap(Dictionary`2<Type, TypeMapEntry> value);
    public static void RemoveTypeMap(Type type);
    public static void AddTypeHandler(Type type, ITypeHandler handler);
    public static bool HasTypeHandler(Type type);
    public static void AddTypeHandlerImpl(Type type, ITypeHandler handler, bool clone);
    public static void AddTypeHandler(TypeHandler`1<T> handler);
    [ObsoleteAttribute("This method is for internal use only", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static void SetDbType(IDataParameter parameter, object value);
    [ObsoleteAttribute("This method is for internal use only", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<DbType> LookupDbType(Type type, string name, bool demand, ITypeHandler& handler);
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Execute(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static int Execute(IDbConnection cnn, CommandDefinition command);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object ExecuteScalar(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T ExecuteScalar(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object ExecuteScalar(IDbConnection cnn, CommandDefinition command);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T ExecuteScalar(IDbConnection cnn, CommandDefinition command);
    [NullableContextAttribute("2")]
private static IEnumerable GetMultiExec(object param);
    [ExtensionAttribute]
private static int ExecuteImpl(IDbConnection cnn, CommandDefinition& command);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static IDataReader ExecuteReader(IDbConnection cnn, CommandDefinition command, CommandBehavior commandBehavior);
    [ExtensionAttribute]
public static IEnumerable`1<object> Query(IDbConnection cnn, string sql, object param, IDbTransaction transaction, bool buffered, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QueryFirst(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object QueryFirstOrDefault(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QuerySingle(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object QuerySingleOrDefault(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static IEnumerable`1<T> Query(IDbConnection cnn, string sql, object param, IDbTransaction transaction, bool buffered, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static T QueryFirst(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T QueryFirstOrDefault(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static T QuerySingle(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T QuerySingleOrDefault(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static IEnumerable`1<object> Query(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, bool buffered, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QueryFirst(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QueryFirstOrDefault(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QuerySingle(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static object QuerySingleOrDefault(IDbConnection cnn, Type type, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static IEnumerable`1<T> Query(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static T QueryFirst(IDbConnection cnn, CommandDefinition command);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T QueryFirstOrDefault(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static T QuerySingle(IDbConnection cnn, CommandDefinition command);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T QuerySingleOrDefault(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
public static GridReader QueryMultiple(IDbConnection cnn, string sql, object param, IDbTransaction transaction, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static GridReader QueryMultiple(IDbConnection cnn, CommandDefinition command);
    [ExtensionAttribute]
private static GridReader QueryMultipleImpl(IDbConnection cnn, CommandDefinition& command);
    private static DbDataReader ExecuteReaderWithFlagsFallback(IDbCommand cmd, bool wasClosed, CommandBehavior behavior);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<QueryImpl>d__144`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> QueryImpl(IDbConnection cnn, CommandDefinition command, Type effectiveType);
    private static void ThrowMultipleRows(Row row);
    private static void ThrowZeroRows(Row row);
    private static T QueryRowImpl(IDbConnection cnn, Row row, CommandDefinition& command, Type effectiveType);
    private static T ReadRow(CacheInfo info, Identity identity, CommandDefinition& command, Type effectiveType, DbDataReader reader);
    private static T GetValue(DbDataReader reader, Type effectiveType, object val);
    [ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`3<TFirst, TSecond, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`4<TFirst, TSecond, TThird, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`5<TFirst, TSecond, TThird, TFourth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`6<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`7<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Func`8<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [ExtensionAttribute]
public static IEnumerable`1<TReturn> Query(IDbConnection cnn, string sql, Type[] types, Func`2<Object[], TReturn> map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static IEnumerable`1<TReturn> MultiMap(IDbConnection cnn, string sql, Delegate map, object param, IDbTransaction transaction, bool buffered, string splitOn, Nullable`1<int> commandTimeout, Nullable`1<CommandType> commandType);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("Dapper.SqlMapper/<MultiMapImpl>d__161`8")]
[ExtensionAttribute]
private static IEnumerable`1<TReturn> MultiMapImpl(IDbConnection cnn, CommandDefinition command, Delegate map, string splitOn, DbDataReader reader, Identity identity, bool finalize);
    private static CommandBehavior GetBehavior(bool close, CommandBehavior default);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<MultiMapImpl>d__163`1")]
[ExtensionAttribute]
private static IEnumerable`1<TReturn> MultiMapImpl(IDbConnection cnn, CommandDefinition command, Type[] types, Func`2<Object[], TReturn> map, string splitOn, DbDataReader reader, Identity identity, bool finalize);
    [NullableContextAttribute("2")]
private static Func`2<DbDataReader, TReturn> GenerateMapper(Func`2<DbDataReader, object> deserializer, Func`2[] otherDeserializers, object map);
    private static Func`2<DbDataReader, TReturn> GenerateMapper(int length, Func`2<DbDataReader, object> deserializer, Func`2[] otherDeserializers, Func`2<Object[], TReturn> map);
    private static Func`2[] GenerateDeserializers(Identity identity, string splitOn, DbDataReader reader);
    private static int GetNextSplitDynamic(int startIdx, string splitOn, DbDataReader reader);
    private static int GetNextSplit(int startIdx, string splitOn, DbDataReader reader);
    private static CacheInfo GetCacheInfo(Identity identity, object exampleParameters, bool addToCache);
    private static bool ShouldPassByPosition(string sql);
    private static void PassByPosition(IDbCommand cmd);
    private static DbDataReader GetDbDataReader(IDataReader reader);
    private static Func`2<DbDataReader, object> GetDeserializer(Type type, DbDataReader reader, int startBound, int length, bool returnNullIfFirstMissing);
    private static Func`2<DbDataReader, object> GetHandlerDeserializer(ITypeHandler handler, Type type, int startBound);
    private static Exception MultiMapException(IDataRecord reader, string splitOn);
    internal static Func`2<DbDataReader, object> GetDapperRowDeserializer(DbDataReader reader, int startBound, int length, bool returnNullIfFirstMissing);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is for internal use only", "False")]
public static char ReadChar(object value);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is for internal use only", "False")]
public static Nullable`1<char> ReadNullableChar(object value);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is for internal use only", "True")]
public static IDbDataParameter FindOrAddParameter(IDataParameterCollection parameters, IDbCommand command, string name);
    internal static int GetListPaddingExtraCount(int count);
    private static string GetInListRegex(string name, bool byPosition);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is for internal use only", "False")]
public static void PackListParameters(IDbCommand command, string namePrefix, object value);
    private static bool TryStringSplit(IEnumerable& list, int splitAt, string namePrefix, IDbCommand command, bool byPosition);
    private static bool TryStringSplit(IEnumerable`1& list, int splitAt, string namePrefix, IDbCommand command, string colType, bool byPosition, Action`2<StringBuilder, T> append);
    [ObsoleteAttribute("This method is for internal use only", "False")]
public static object SanitizeParameterValue(object value);
    private static IEnumerable`1<PropertyInfo> FilterParameters(IEnumerable`1<PropertyInfo> parameters, string sql);
    [ExtensionAttribute]
public static void ReplaceLiterals(IParameterLookup parameters, IDbCommand command);
    [ObsoleteAttribute("This method is for internal use only")]
public static string Format(object value);
    internal static void ReplaceLiterals(IParameterLookup parameters, IDbCommand command, IList`1<LiteralToken> tokens);
    internal static IList`1<LiteralToken> GetLiteralTokens(string sql);
    public static Action`2<IDbCommand, object> CreateParamInfoGenerator(Identity identity, bool checkForDuplicates, bool removeUnused);
    [NullableContextAttribute("2")]
private static bool IsValueTuple(Type type);
    internal static Action`2<IDbCommand, object> CreateParamInfoGenerator(Identity identity, bool checkForDuplicates, bool removeUnused, IList`1<LiteralToken> literals);
    [NullableContextAttribute("2")]
private static MethodInfo GetToString(TypeCode typeCode);
    private static int ExecuteCommand(IDbConnection cnn, CommandDefinition& command, Action`2<IDbCommand, object> paramReader);
    [NullableContextAttribute("2")]
private static T ExecuteScalarImpl(IDbConnection cnn, CommandDefinition& command);
    private static DbDataReader ExecuteReaderImpl(IDbConnection cnn, CommandDefinition& command, CommandBehavior commandBehavior, IDbCommand& cmd);
    private static Action`2<IDbCommand, object> GetParameterReader(IDbConnection cnn, CommandDefinition& command);
    private static Func`2<DbDataReader, object> GetSimpleValueDeserializer(Type type, Type effectiveType, int index, bool useGetFieldValue);
    private static Func`2<DbDataReader, object> ReadViaGetFieldValueFactory(Type type, int index);
    private static Func`2<DbDataReader, object> UnderlyingReadViaGetFieldValueFactory(int index);
    private static bool UseGetFieldValue(Type type);
    [NullableContextAttribute("2")]
private static T Parse(object value);
    public static ITypeMap GetTypeMap(Type type);
    public static void SetTypeMap(Type type, ITypeMap map);
    public static Func`2<IDataReader, object> GetTypeDeserializer(Type type, IDataReader reader, int startBound, int length, bool returnNullIfFirstMissing);
    private static Func`2<IDataReader, object> WrapObjectReader(Func`2<DbDataReader, object> dbReader);
    public static Func`2<DbDataReader, object> GetTypeDeserializer(Type type, DbDataReader reader, int startBound, int length, bool returnNullIfFirstMissing);
    private static LocalBuilder GetTempLocal(ILGenerator il, Dictionary`2& locals, Type type, bool initAndLoad);
    private static Func`2<DbDataReader, object> GetTypeDeserializerImpl(Type type, DbDataReader reader, int startBound, int length, bool returnNullIfFirstMissing);
    private static void GenerateValueTupleDeserializer(Type valueTupleType, DbDataReader reader, int startBound, int length, ILGenerator il);
    private static void GenerateDeserializerFromMap(Type type, DbDataReader reader, int startBound, int length, bool returnNullIfFirstMissing, ILGenerator il);
    private static void LoadDefaultValue(ILGenerator il, Type type);
    private static void LoadReaderValueViaGetFieldValue(ILGenerator il, int index, Type memberType, LocalBuilder valueCopyLocal, Label isDbNullLabel, Boolean& popWhenNull);
    private static void LoadReaderValueOrBranchToDBNullLabel(ILGenerator il, int index, LocalBuilder& stringEnumLocal, LocalBuilder valueCopyLocal, Type colType, Type memberType, Label& isDbNullLabel, Boolean& popWhenNull);
    private static void FlexibleConvertBoxedFromHeadOfStack(ILGenerator il, Type from, Type to, Type via);
    private static MethodInfo GetOperator(Type from, Type to);
    private static MethodInfo ResolveOperator(MethodInfo[] methods, Type from, Type to, string name);
    [ObsoleteAttribute("This method is for internal use only", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static void ThrowNullCustomQueryParameter(string name);
    [ObsoleteAttribute("This method is for internal use only", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static void ThrowDataException(Exception ex, int index, IDataReader reader, object value);
    private static void EmitInt32(ILGenerator il, int value);
    public static IEqualityComparer`1<string> get_ConnectionStringComparer();
    public static void set_ConnectionStringComparer(IEqualityComparer`1<string> value);
    [ExtensionAttribute]
public static ICustomQueryParameter AsTableValuedParameter(DataTable table, string typeName);
    [ExtensionAttribute]
public static void SetTypeName(DataTable table, string typeName);
    [ExtensionAttribute]
public static string GetTypeName(DataTable table);
    [ExtensionAttribute]
public static ICustomQueryParameter AsTableValuedParameter(IEnumerable`1<T> list, string typeName);
    private static StringBuilder GetStringBuilder();
    [ExtensionAttribute]
private static string ToStringRecycle(StringBuilder obj);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<Parse>d__252`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Parse(IDataReader reader);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<Parse>d__253")]
[ExtensionAttribute]
public static IEnumerable`1<object> Parse(IDataReader reader, Type type);
    [IteratorStateMachineAttribute("Dapper.SqlMapper/<Parse>d__254")]
[ExtensionAttribute]
public static IEnumerable`1<object> Parse(IDataReader reader);
    [ExtensionAttribute]
public static Func`2<IDataReader, object> GetRowParser(IDataReader reader, Type type, int startIndex, int length, bool returnNullIfFirstMissing);
    [ExtensionAttribute]
public static Func`2<DbDataReader, object> GetRowParser(DbDataReader reader, Type type, int startIndex, int length, bool returnNullIfFirstMissing);
    [ExtensionAttribute]
public static Func`2<IDataReader, T> GetRowParser(IDataReader reader, Type concreteType, int startIndex, int length, bool returnNullIfFirstMissing);
    [ExtensionAttribute]
public static Func`2<DbDataReader, T> GetRowParser(DbDataReader reader, Type concreteType, int startIndex, int length, bool returnNullIfFirstMissing);
    [CompilerGeneratedAttribute]
internal static LocalBuilder <CreateParamInfoGenerator>g__GetSizeLocal|194_0(<>c__DisplayClass194_0& );
    [CompilerGeneratedAttribute]
internal static Func`2<DbDataReader, object> <GetSimpleValueDeserializer>g__ReadViaGetValue|203_5(int index);
    [CompilerGeneratedAttribute]
internal static Func`2<IDataReader, T> <GetRowParser>g__Wrap|257_0(Func`2<DbDataReader, object> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Dapper.StructuredHelper : object {
    private static Hashtable s_udt;
    private static Hashtable s_tvp;
    private static StructuredHelper();
    private static Action`2<IDbDataParameter, string> GetUDT(Type type);
    private static Action`2<IDbDataParameter, string> GetTVP(Type type);
    private static Action`2<IDbDataParameter, string> SlowGetHelper(Type type, Hashtable hashtable, string nameProperty, int sqlDbType);
    private static Action`2<IDbDataParameter, string> CreateFor(Type type, string nameProperty, int sqlDbType);
    internal static void ConfigureUDT(IDbDataParameter parameter, string typeName);
    internal static void ConfigureTVP(IDbDataParameter parameter, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Dapper.TableValuedParameter : object {
    private DataTable table;
    [NullableAttribute("2")]
private string typeName;
    public TableValuedParameter(DataTable table);
    public TableValuedParameter(DataTable table, string typeName);
    private sealed virtual override void Dapper.SqlMapper.ICustomQueryParameter.AddParameter(IDbCommand command, string name);
    [NullableContextAttribute("2")]
internal static void Set(IDbDataParameter parameter, DataTable table, string typeName);
}
[ExtensionAttribute]
internal static class Dapper.TypeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static MethodInfo GetPublicInstanceMethod(Type type, string name, Type[] types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Dapper.WrappedBasicReader : DbDataReader {
    private IDataReader _reader;
    public bool HasRows { get; }
    public int Depth { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public int FieldCount { get; }
    public object Item { get; }
    public object Item { get; }
    public int VisibleFieldCount { get; }
    public WrappedBasicReader(IDataReader reader);
    public virtual bool get_HasRows();
    public virtual void Close();
    [NullableContextAttribute("2")]
public virtual DataTable GetSchemaTable();
    public virtual object InitializeLifetimeService();
    public virtual int get_Depth();
    public virtual bool get_IsClosed();
    public virtual bool NextResult();
    public virtual bool Read();
    public virtual int get_RecordsAffected();
    protected virtual void Dispose(bool disposing);
    public virtual int get_FieldCount();
    public virtual bool GetBoolean(int i);
    public virtual byte GetByte(int i);
    [NullableContextAttribute("2")]
public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferoffset, int length);
    public virtual char GetChar(int i);
    [NullableContextAttribute("2")]
public virtual long GetChars(int i, long fieldoffset, Char[] buffer, int bufferoffset, int length);
    public virtual string GetDataTypeName(int i);
    public virtual DateTime GetDateTime(int i);
    public virtual decimal GetDecimal(int i);
    public virtual double GetDouble(int i);
    public virtual Type GetFieldType(int i);
    public virtual float GetFloat(int i);
    public virtual Guid GetGuid(int i);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public virtual string GetName(int i);
    public virtual int GetOrdinal(string name);
    public virtual string GetString(int i);
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int i);
    public virtual object get_Item(string name);
    public virtual object get_Item(int i);
    [NullableContextAttribute("0")]
public virtual T GetFieldValue(int ordinal);
    [NullableContextAttribute("0")]
public virtual Task`1<T> GetFieldValueAsync(int ordinal, CancellationToken cancellationToken);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual Stream GetStream(int ordinal);
    public virtual TextReader GetTextReader(int ordinal);
    public virtual Task`1<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    public virtual int get_VisibleFieldCount();
    protected virtual DbDataReader GetDbDataReader(int ordinal);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Dapper.XDocumentHandler : XmlTypeHandler`1<XDocument> {
    protected virtual XDocument Parse(string xml);
    protected virtual string Format(XDocument xml);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Dapper.XElementHandler : XmlTypeHandler`1<XElement> {
    protected virtual XElement Parse(string xml);
    protected virtual string Format(XElement xml);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Dapper.XmlDocumentHandler : XmlTypeHandler`1<XmlDocument> {
    protected virtual XmlDocument Parse(string xml);
    protected virtual string Format(XmlDocument xml);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Dapper.XmlTypeHandler`1 : StringTypeHandler`1<T> {
    public virtual void SetValue(IDbDataParameter parameter, T value);
}
internal class Hangfire.SqlServer.Constants : object {
    public static string DefaultSchema;
    private static Constants();
}
internal class Hangfire.SqlServer.CountersAggregator : object {
    private static int NumberOfRecordsInSinglePass;
    private static TimeSpan DelayBetweenPasses;
    private ILog _logger;
    private SqlServerStorage _storage;
    private TimeSpan _interval;
    public CountersAggregator(SqlServerStorage storage, TimeSpan interval);
    private static CountersAggregator();
    public sealed virtual void Execute(CancellationToken cancellationToken);
    public virtual string ToString();
    private static string GetAggregationQuery(SqlServerStorage storage);
}
public class Hangfire.SqlServer.EnqueuedAndFetchedCountDto : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EnqueuedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FetchedCount>k__BackingField;
    public Nullable`1<int> EnqueuedCount { get; public set; }
    public Nullable`1<int> FetchedCount { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_EnqueuedCount();
    [CompilerGeneratedAttribute]
public void set_EnqueuedCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FetchedCount();
    [CompilerGeneratedAttribute]
public void set_FetchedCount(Nullable`1<int> value);
}
internal class Hangfire.SqlServer.Entities.JobParameter : object {
    [CompilerGeneratedAttribute]
private long <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public long JobId { get; public set; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public long get_JobId();
    [CompilerGeneratedAttribute]
public void set_JobId(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
internal class Hangfire.SqlServer.Entities.Server : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastHeartbeat>k__BackingField;
    public string Id { get; public set; }
    public string Data { get; public set; }
    public DateTime LastHeartbeat { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastHeartbeat();
    [CompilerGeneratedAttribute]
public void set_LastHeartbeat(DateTime value);
}
internal class Hangfire.SqlServer.Entities.ServerData : object {
    [CompilerGeneratedAttribute]
private int <WorkerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartedAt>k__BackingField;
    public int WorkerCount { get; public set; }
    public String[] Queues { get; public set; }
    public Nullable`1<DateTime> StartedAt { get; public set; }
    [CompilerGeneratedAttribute]
public int get_WorkerCount();
    [CompilerGeneratedAttribute]
public void set_WorkerCount(int value);
    [CompilerGeneratedAttribute]
public String[] get_Queues();
    [CompilerGeneratedAttribute]
public void set_Queues(String[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(Nullable`1<DateTime> value);
}
internal class Hangfire.SqlServer.Entities.SqlHash : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpireAt>k__BackingField;
    public string Key { get; public set; }
    public string Field { get; public set; }
    public string Value { get; public set; }
    public Nullable`1<DateTime> ExpireAt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public void set_ExpireAt(Nullable`1<DateTime> value);
}
internal class Hangfire.SqlServer.Entities.SqlJob : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InvocationData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpireAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FetchedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StateChanged>k__BackingField;
    public long Id { get; public set; }
    public string InvocationData { get; public set; }
    public string Arguments { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public Nullable`1<DateTime> ExpireAt { get; public set; }
    public Nullable`1<DateTime> FetchedAt { get; public set; }
    public string StateName { get; public set; }
    public string StateReason { get; public set; }
    public string StateData { get; public set; }
    public Nullable`1<DateTime> StateChanged { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public string get_InvocationData();
    [CompilerGeneratedAttribute]
public void set_InvocationData(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpireAt();
    [CompilerGeneratedAttribute]
public void set_ExpireAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FetchedAt();
    [CompilerGeneratedAttribute]
public void set_FetchedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_StateName();
    [CompilerGeneratedAttribute]
public void set_StateName(string value);
    [CompilerGeneratedAttribute]
public string get_StateReason();
    [CompilerGeneratedAttribute]
public void set_StateReason(string value);
    [CompilerGeneratedAttribute]
public string get_StateData();
    [CompilerGeneratedAttribute]
public void set_StateData(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StateChanged();
    [CompilerGeneratedAttribute]
public void set_StateChanged(Nullable`1<DateTime> value);
}
internal class Hangfire.SqlServer.Entities.SqlState : object {
    [CompilerGeneratedAttribute]
private long <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    public long JobId { get; public set; }
    public string Name { get; public set; }
    public string Reason { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public string Data { get; public set; }
    [CompilerGeneratedAttribute]
public long get_JobId();
    [CompilerGeneratedAttribute]
public void set_JobId(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(string value);
}
[ExtensionAttribute]
internal static class Hangfire.SqlServer.ExceptionTypeHelper : object {
    private static Type OutOfMemoryType;
    private static Type StackOverflowType;
    private static Type ThreadAbortType;
    private static Type AccessViolationType;
    private static Type SecurityType;
    private static ExceptionTypeHelper();
    [ExtensionAttribute]
internal static bool IsCatchableExceptionType(Exception e);
}
internal class Hangfire.SqlServer.ExpirationManager : object {
    private static string DistributedLockKey;
    private static TimeSpan DefaultLockTimeout;
    private static int DefaultNumberOfRecordsInSinglePass;
    private static String[] ProcessedTables;
    private ILog _logger;
    private SqlServerStorage _storage;
    private TimeSpan _stateExpirationTimeout;
    private TimeSpan _checkInterval;
    public ExpirationManager(SqlServerStorage storage, TimeSpan stateExpirationTimeout, TimeSpan checkInterval);
    private static ExpirationManager();
    public sealed virtual void Execute(CancellationToken cancellationToken);
    public virtual string ToString();
    private void CleanupTable(string query, string table, int numberOfRecordsInSinglePass, CancellationToken cancellationToken, Action`1<DbCommand> additionalActions);
    private void UseConnectionDistributedLock(SqlServerStorage storage, Action`1<DbConnection> action);
    private static string GetExpireQuery(string schemaName, string table);
    private static string GetStateCleanupQuery(string schemaName);
    private static int ExecuteNonQuery(DbConnection connection, string commandText, int numberOfRecordsInSinglePass, Action`1<DbCommand> additionalActions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <Execute>b__9_0(DbCommand command);
}
public interface Hangfire.SqlServer.IPersistentJobQueue {
    public abstract virtual IFetchedJob Dequeue(String[] queues, CancellationToken cancellationToken);
    public abstract virtual void Enqueue(DbConnection connection, DbTransaction transaction, string queue, string jobId);
}
public interface Hangfire.SqlServer.IPersistentJobQueueMonitoringApi {
    public abstract virtual IEnumerable`1<string> GetQueues();
    public abstract virtual IEnumerable`1<long> GetEnqueuedJobIds(string queue, int from, int perPage);
    public abstract virtual IEnumerable`1<long> GetFetchedJobIds(string queue, int from, int perPage);
    public abstract virtual EnqueuedAndFetchedCountDto GetEnqueuedAndFetchedCount(string queue);
}
public interface Hangfire.SqlServer.IPersistentJobQueueProvider {
    public abstract virtual IPersistentJobQueue GetJobQueue();
    public abstract virtual IPersistentJobQueueMonitoringApi GetJobQueueMonitoringApi();
}
public class Hangfire.SqlServer.PersistentJobQueueProviderCollection : object {
    private List`1<IPersistentJobQueueProvider> _providers;
    private Dictionary`2<string, IPersistentJobQueueProvider> _providersByQueue;
    private IPersistentJobQueueProvider _defaultProvider;
    public PersistentJobQueueProviderCollection(IPersistentJobQueueProvider defaultProvider);
    public void Add(IPersistentJobQueueProvider provider, IEnumerable`1<string> queues);
    public IPersistentJobQueueProvider GetProvider(string queue);
    public sealed virtual IEnumerator`1<IPersistentJobQueueProvider> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Hangfire.SqlServer.SqlCommandBatch : object {
    private List`1<DbCommand> _commandList;
    private SqlCommandSet _commandSet;
    private int _defaultTimeout;
    [CompilerGeneratedAttribute]
private DbConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private DbTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandBatchMaxTimeout>k__BackingField;
    public DbConnection Connection { get; }
    public DbTransaction Transaction { get; }
    public Nullable`1<int> CommandTimeout { get; public set; }
    public Nullable`1<int> CommandBatchMaxTimeout { get; public set; }
    public SqlCommandBatch(DbConnection connection, DbTransaction transaction, bool preferBatching);
    [CompilerGeneratedAttribute]
public DbConnection get_Connection();
    [CompilerGeneratedAttribute]
public DbTransaction get_Transaction();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandBatchMaxTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandBatchMaxTimeout(Nullable`1<int> value);
    public sealed virtual void Dispose();
    public void Append(string commandText, SqlCommandBatchParameter[] parameters);
    public void Append(DbCommand command);
    public void ExecuteNonQuery();
}
internal class Hangfire.SqlServer.SqlCommandBatchParameter : object {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private DbType <DbType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string ParameterName { get; }
    public DbType DbType { get; }
    public Nullable`1<int> Size { get; }
    public object Value { get; public set; }
    public SqlCommandBatchParameter(string parameterName, DbType dbType, Nullable`1<int> size);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public DbType get_DbType();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Size();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public void AddToCommand(DbCommand command);
}
internal class Hangfire.SqlServer.SqlCommandSet : object {
    private static ConcurrentDictionary`2<Assembly, Type> SqlCommandSetType;
    private static ConcurrentDictionary`2<Type, Action`2<object, DbConnection>> SetConnection;
    private static ConcurrentDictionary`2<Type, Action`2<object, DbTransaction>> SetTransaction;
    private static ConcurrentDictionary`2<Type, Func`2<object, DbCommand>> GetBatchCommand;
    private static ConcurrentDictionary`2<Type, PropertyInfo> BatchCommandProperty;
    private static ConcurrentDictionary`2<Type, Action`2<object, DbCommand>> AppendMethod;
    private static ConcurrentDictionary`2<Type, Func`2<object, int>> ExecuteNonQueryMethod;
    private static ConcurrentDictionary`2<Type, Action`1<object>> DisposeMethod;
    private object _instance;
    private Action`2<object, DbConnection> _setConnection;
    private Action`2<object, DbTransaction> _setTransaction;
    private Func`2<object, DbCommand> _getBatchCommand;
    private Action`2<object, DbCommand> _appendMethod;
    private Func`2<object, int> _executeNonQueryMethod;
    private Action`1<object> _disposeMethod;
    [CompilerGeneratedAttribute]
private int <CommandCount>k__BackingField;
    unknown DbConnection Connection {public set; }
    unknown DbTransaction Transaction {public set; }
    public DbCommand BatchCommand { get; }
    public int CommandCount { get; private set; }
    public SqlCommandSet(DbConnection connection);
    private static SqlCommandSet();
    public void set_Connection(DbConnection value);
    public void set_Transaction(DbTransaction value);
    public DbCommand get_BatchCommand();
    [CompilerGeneratedAttribute]
public int get_CommandCount();
    [CompilerGeneratedAttribute]
private void set_CommandCount(int value);
    public void Append(DbCommand command);
    public int ExecuteNonQuery();
    public sealed virtual void Dispose();
}
internal class Hangfire.SqlServer.SqlServerConnection : JobStorageConnection {
    private SqlServerStorage _storage;
    private Dictionary`2<string, HashSet`1<Guid>> _lockedResources;
    private DbConnection _dedicatedConnection;
    public SqlServerStorage Storage { get; }
    public DbConnection DedicatedConnection { get; }
    public SqlServerConnection(SqlServerStorage storage);
    public SqlServerStorage get_Storage();
    public DbConnection get_DedicatedConnection();
    public virtual void Dispose();
    public virtual IWriteOnlyTransaction CreateWriteTransaction();
    public virtual IDisposable AcquireDistributedLock(string resource, TimeSpan timeout);
    public virtual IFetchedJob FetchNextJob(String[] queues, CancellationToken cancellationToken);
    public virtual string CreateExpiredJob(Job job, IDictionary`2<string, string> parameters, DateTime createdAt, TimeSpan expireIn);
    public virtual JobData GetJobData(string id);
    public virtual StateData GetStateData(string jobId);
    public virtual void SetJobParameter(string id, string name, string value);
    public virtual string GetJobParameter(string id, string name);
    public virtual HashSet`1<string> GetAllItemsFromSet(string key);
    public virtual string GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore);
    public virtual List`1<string> GetFirstByLowestScoreFromSet(string key, double fromScore, double toScore, int count);
    public virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public virtual Dictionary`2<string, string> GetAllEntriesFromHash(string key);
    public virtual void AnnounceServer(string serverId, ServerContext context);
    public virtual void RemoveServer(string serverId);
    public virtual void Heartbeat(string serverId);
    public virtual int RemoveTimedOutServers(TimeSpan timeOut);
    public virtual long GetSetCount(string key);
    public virtual long GetSetCount(IEnumerable`1<string> keys, int limit);
    public virtual bool GetSetContains(string key, string value);
    public virtual List`1<string> GetRangeFromSet(string key, int startingFrom, int endingAt);
    public virtual TimeSpan GetSetTtl(string key);
    public virtual long GetCounter(string key);
    public virtual long GetHashCount(string key);
    public virtual TimeSpan GetHashTtl(string key);
    public virtual string GetValueFromHash(string key, string name);
    public virtual long GetListCount(string key);
    public virtual TimeSpan GetListTtl(string key);
    public virtual List`1<string> GetRangeFromList(string key, int startingFrom, int endingAt);
    public virtual List`1<string> GetAllItemsFromList(string key);
    public virtual DateTime GetUtcDateTime();
    internal DisposableLock AcquireLock(string resource, TimeSpan timeout);
    private void ReleaseLock(string resource, Guid lockId, bool onDisposing, bool releasedExternally);
    [CompilerGeneratedAttribute]
private IPersistentJobQueueProvider <FetchNextJob>b__10_0(string queue);
}
public class Hangfire.SqlServer.SqlServerDistributedLock : object {
    private static TimeSpan LockTimeout;
    private static string LockMode;
    private static string LockOwner;
    private static TimeSpan KeepAliveInterval;
    private static IDictionary`2<int, string> LockErrorMessages;
    private static ThreadLocal`1<Dictionary`2<string, int>> AcquiredLocks;
    private DbConnection _connection;
    private SqlServerStorage _storage;
    private string _resource;
    private Timer _timer;
    private object _lockObject;
    private bool _completed;
    [ObsoleteAttribute("Don't use this class directly, use SqlServerConnection.AcquireDistributedLock instead as it provides better safety. Will be removed in 2.0.0.")]
public SqlServerDistributedLock(SqlServerStorage storage, string resource, TimeSpan timeout);
    private static SqlServerDistributedLock();
    public sealed virtual void Dispose();
    private void ExecuteKeepAliveQuery(object obj);
    internal static void Acquire(DbConnection connection, string resource, TimeSpan timeout);
    internal static void Release(DbConnection connection, string resource);
    internal static DbCommand CreateReleaseCommand(DbConnection connection, string resource, DbParameter& resultParameter);
}
public class Hangfire.SqlServer.SqlServerDistributedLockException : Exception {
    public SqlServerDistributedLockException(string message);
    protected SqlServerDistributedLockException(SerializationInfo info, StreamingContext context);
}
internal class Hangfire.SqlServer.SqlServerHeartbeatProcess : object {
    private ConcurrentDictionary`2<SqlServerTimeoutJob, object> _items;
    public void Track(SqlServerTimeoutJob item);
    public void Untrack(SqlServerTimeoutJob item);
    public sealed virtual void Execute(CancellationToken cancellationToken);
}
internal class Hangfire.SqlServer.SqlServerJobQueue : object {
    internal static ConcurrentDictionary`2<Tuple`2<SqlServerStorage, string>, AutoResetEvent> NewItemInQueueEvents;
    private static Func`2<Tuple`2<SqlServerStorage, string>, SemaphoreSlim> CreateSemaphoreFunc;
    private static TimeSpan LongPollingThreshold;
    private static int PollingQuantumMs;
    private static int DefaultPollingDelayMs;
    private static int MinPollingDelayMs;
    private static ConcurrentDictionary`2<Tuple`2<SqlServerStorage, string>, SemaphoreSlim> Semaphores;
    private SqlServerStorage _storage;
    private SqlServerStorageOptions _options;
    public SqlServerJobQueue(SqlServerStorage storage, SqlServerStorageOptions options);
    private static SqlServerJobQueue();
    [NotNullAttribute]
public sealed virtual IFetchedJob Dequeue(String[] queues, CancellationToken cancellationToken);
    public sealed virtual void Enqueue(DbConnection connection, DbTransaction transaction, string queue, string jobId);
    private SqlServerTimeoutJob DequeueUsingSlidingInvisibilityTimeout(String[] queues, CancellationToken cancellationToken);
    private static SemaphoreSlim CreateSemaphore(Tuple`2<SqlServerStorage, string> _);
    private SqlServerTimeoutJob FetchJob(String[] queues);
    private string GetNonBlockingFetchSql();
    private SqlServerTransactionJob DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken);
    private static WaitHandle[] GetWaitArrayForQueueSignals(SqlServerStorage storage, String[] queues, CancellationToken cancellationToken);
}
internal class Hangfire.SqlServer.SqlServerJobQueueMonitoringApi : object {
    private static TimeSpan QueuesCacheTimeout;
    private SqlServerStorage _storage;
    private object _cacheLock;
    private List`1<string> _queuesCache;
    private Stopwatch _cacheUpdated;
    public SqlServerJobQueueMonitoringApi(SqlServerStorage storage);
    private static SqlServerJobQueueMonitoringApi();
    public sealed virtual IEnumerable`1<string> GetQueues();
    public sealed virtual IEnumerable`1<long> GetEnqueuedJobIds(string queue, int from, int perPage);
    public sealed virtual IEnumerable`1<long> GetFetchedJobIds(string queue, int from, int perPage);
    public sealed virtual EnqueuedAndFetchedCountDto GetEnqueuedAndFetchedCount(string queue);
}
internal class Hangfire.SqlServer.SqlServerJobQueueProvider : object {
    private IPersistentJobQueue _jobQueue;
    private IPersistentJobQueueMonitoringApi _monitoringApi;
    public SqlServerJobQueueProvider(SqlServerStorage storage, SqlServerStorageOptions options);
    public sealed virtual IPersistentJobQueue GetJobQueue();
    public sealed virtual IPersistentJobQueueMonitoringApi GetJobQueueMonitoringApi();
}
internal class Hangfire.SqlServer.SqlServerMonitoringApi : JobStorageMonitor {
    private SqlServerStorage _storage;
    private Nullable`1<int> _jobListLimit;
    public SqlServerMonitoringApi(SqlServerStorage storage, Nullable`1<int> jobListLimit);
    public virtual long ScheduledCount();
    public virtual long EnqueuedCount(string queue);
    public virtual long FetchedCount(string queue);
    public virtual long FailedCount();
    public virtual long ProcessingCount();
    public virtual JobList`1<ProcessingJobDto> ProcessingJobs(int from, int count);
    public virtual JobList`1<ScheduledJobDto> ScheduledJobs(int from, int count);
    public virtual IDictionary`2<DateTime, long> SucceededByDatesCount();
    public virtual IDictionary`2<DateTime, long> FailedByDatesCount();
    public virtual IDictionary`2<DateTime, long> DeletedByDatesCount();
    public virtual IList`1<ServerDto> Servers();
    public virtual JobList`1<FailedJobDto> FailedJobs(int from, int count);
    public virtual JobList`1<SucceededJobDto> SucceededJobs(int from, int count);
    public virtual JobList`1<DeletedJobDto> DeletedJobs(int from, int count);
    public virtual JobList`1<AwaitingJobDto> AwaitingJobs(int from, int count);
    public virtual long AwaitingCount();
    public virtual IList`1<QueueWithTopEnqueuedJobsDto> Queues();
    public virtual JobList`1<EnqueuedJobDto> EnqueuedJobs(string queue, int from, int perPage);
    public virtual JobList`1<FetchedJobDto> FetchedJobs(string queue, int from, int perPage);
    public virtual IDictionary`2<DateTime, long> HourlySucceededJobs();
    public virtual IDictionary`2<DateTime, long> HourlyFailedJobs();
    public virtual IDictionary`2<DateTime, long> HourlyDeletedJobs();
    public virtual JobDetailsDto JobDetails(string jobId);
    public virtual long SucceededListCount();
    public virtual long DeletedListCount();
    public virtual StatisticsDto GetStatistics();
    private Dictionary`2<DateTime, long> GetHourlyTimelineStats(DbConnection connection, string type);
    private Dictionary`2<DateTime, long> GetTimelineStats(DbConnection connection, string type);
    private Dictionary`2<DateTime, long> GetTimelineStats(DbConnection connection, IDictionary`2<string, DateTime> keyMaps);
    private IPersistentJobQueueMonitoringApi GetQueueApi(string queueName);
    private T UseConnection(Func`2<DbConnection, T> action);
    private JobList`1<EnqueuedJobDto> EnqueuedJobs(DbConnection connection, Int64[] jobIds);
    private long GetNumberOfJobsByStateName(DbConnection connection, string stateName);
    private static Job DeserializeJob(string invocationData, string arguments, InvocationData& data, JobLoadException& exception);
    private JobList`1<TDto> GetJobs(DbConnection connection, int from, int count, string stateName, bool descending, Func`6<SqlJob, Job, InvocationData, JobLoadException, SafeDictionary`2<string, string>, TDto> selector);
    private static JobList`1<TDto> DeserializeJobs(ICollection`1<SqlJob> jobs, Func`6<SqlJob, Job, InvocationData, JobLoadException, SafeDictionary`2<string, string>, TDto> selector);
    private JobList`1<FetchedJobDto> FetchedJobs(DbConnection connection, IEnumerable`1<long> jobIds);
    [CompilerGeneratedAttribute]
private long <ScheduledCount>b__3_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private long <FailedCount>b__6_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private long <ProcessingCount>b__7_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <SucceededByDatesCount>b__10_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <FailedByDatesCount>b__11_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <DeletedByDatesCount>b__12_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private IList`1<ServerDto> <Servers>b__13_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private long <AwaitingCount>b__18_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <HourlySucceededJobs>b__22_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <HourlyFailedJobs>b__23_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private Dictionary`2<DateTime, long> <HourlyDeletedJobs>b__24_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private long <SucceededListCount>b__26_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private long <DeletedListCount>b__27_0(DbConnection connection);
}
public static class Hangfire.SqlServer.SqlServerObjectsInstaller : object {
    [ObsoleteAttribute("This field is unused and will be removed in 2.0.0.")]
public static int RequiredSchemaVersion;
    public static int LatestSchemaVersion;
    private static SqlServerObjectsInstaller();
    public static void Install(DbConnection connection);
    public static void Install(DbConnection connection, string schema);
    public static void Install(DbConnection connection, string schema, bool enableHeavyMigrations);
    public static string GetInstallScript(string schema, bool enableHeavyMigrations);
    private static string GetStringResource(Assembly assembly, string resourceName);
}
public class Hangfire.SqlServer.SqlServerStorage : JobStorage {
    private static Char[] SemicolonSeparator;
    private static Char[] EqualSignSeparator;
    private DbConnection _existingConnection;
    private Func`1<DbConnection> _connectionFactory;
    private SqlServerStorageOptions _options;
    private string _connectionString;
    private string _escapedSchemaName;
    private SqlServerHeartbeatProcess _heartbeatProcess;
    private Dictionary`2<string, bool> _features;
    [CompilerGeneratedAttribute]
private PersistentJobQueueProviderCollection <QueueProviders>k__BackingField;
    public static DashboardMetric ActiveConnections;
    public static DashboardMetric TotalConnections;
    public static DashboardMetric ActiveTransactions;
    public static DashboardMetric DataFilesSize;
    public static DashboardMetric LogFilesSize;
    public static DashboardMetric SchemaVersion;
    public static Func`4<string, string, string, DashboardMetric> PerformanceCounterDatabaseMetric;
    public PersistentJobQueueProviderCollection QueueProviders { get; private set; }
    public bool LinearizableReads { get; }
    internal string SchemaName { get; }
    internal Nullable`1<int> CommandTimeout { get; }
    internal Nullable`1<int> CommandBatchMaxTimeout { get; }
    internal Nullable`1<TimeSpan> SlidingInvisibilityTimeout { get; }
    internal SqlServerStorageOptions Options { get; }
    internal SqlServerHeartbeatProcess HeartbeatProcess { get; }
    public SqlServerStorage(string nameOrConnectionString);
    public SqlServerStorage(string nameOrConnectionString, SqlServerStorageOptions options);
    public SqlServerStorage(DbConnection existingConnection);
    public SqlServerStorage(DbConnection existingConnection, SqlServerStorageOptions options);
    public SqlServerStorage(Func`1<DbConnection> connectionFactory);
    public SqlServerStorage(Func`1<DbConnection> connectionFactory, SqlServerStorageOptions options);
    private static SqlServerStorage();
    [CompilerGeneratedAttribute]
public virtual PersistentJobQueueProviderCollection get_QueueProviders();
    [CompilerGeneratedAttribute]
private void set_QueueProviders(PersistentJobQueueProviderCollection value);
    public virtual bool get_LinearizableReads();
    internal string get_SchemaName();
    internal Nullable`1<int> get_CommandTimeout();
    internal Nullable`1<int> get_CommandBatchMaxTimeout();
    internal Nullable`1<TimeSpan> get_SlidingInvisibilityTimeout();
    internal SqlServerStorageOptions get_Options();
    internal SqlServerHeartbeatProcess get_HeartbeatProcess();
    public virtual IMonitoringApi GetMonitoringApi();
    public virtual IStorageConnection GetConnection();
    [IteratorStateMachineAttribute("Hangfire.SqlServer.SqlServerStorage/<GetComponents>d__35")]
public virtual IEnumerable`1<IServerComponent> GetComponents();
    public virtual void WriteOptionsToLog(ILog logger);
    public virtual bool HasFeature(string featureId);
    public virtual string ToString();
    internal void UseConnection(DbConnection dedicatedConnection, Action`1<DbConnection> action);
    internal T UseConnection(DbConnection dedicatedConnection, Func`2<DbConnection, T> func);
    internal void UseTransaction(DbConnection dedicatedConnection, Action`2<DbConnection, DbTransaction> action);
    internal T UseTransaction(DbConnection dedicatedConnection, Func`3<DbConnection, DbTransaction, T> func, Nullable`1<IsolationLevel> isolationLevel);
    internal DbConnection CreateAndOpenConnection();
    internal bool IsExistingConnection(IDbConnection connection);
    internal void ReleaseConnection(IDbConnection connection);
    private DbConnection DefaultConnectionFactory();
    private static bool IsRunningOnWindows();
    private void Initialize();
    private void InitializeQueueProviders();
    private static string GetConnectionString(string nameOrConnectionString);
    [CompilerGeneratedAttribute]
private void <Initialize>b__48_0(DbConnection connection);
}
public class Hangfire.SqlServer.SqlServerStorageOptions : object {
    private TimeSpan _queuePollInterval;
    private string _schemaName;
    private TimeSpan _jobExpirationCheckInterval;
    private Nullable`1<TimeSpan> _slidingInvisibilityTimeout;
    private DbProviderFactory _sqlClientFactory;
    [CompilerGeneratedAttribute]
private Nullable`1<IsolationLevel> <TransactionIsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InvisibilityTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrepareSchemaIfNecessary>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CountersAggregateInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DashboardJobListLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TransactionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CommandBatchMaxTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InactiveStateExpirationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IDisposable> <ImpersonationFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableGlobalLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePageLocksOnDequeue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRecommendedIsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableHeavyMigrations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseFineGrainedLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseIgnoreDupKeyOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeleteExpiredBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTransactionalAcknowledge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryAutoDetectSchemaDependentOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentJobQueueProvider <DefaultQueueProvider>k__BackingField;
    [ObsoleteAttribute("TransactionIsolationLevel option is deprecated, please set UseRecommendedIsolationLevel instead. Will be removed in 2.0.0.")]
public Nullable`1<IsolationLevel> TransactionIsolationLevel { get; public set; }
    public TimeSpan QueuePollInterval { get; public set; }
    [ObsoleteAttribute("Does not make sense anymore. Background jobs re-queued instantly even after ungraceful shutdown now. Will be removed in 2.0.0.")]
public TimeSpan InvisibilityTimeout { get; public set; }
    public Nullable`1<TimeSpan> SlidingInvisibilityTimeout { get; public set; }
    public bool PrepareSchemaIfNecessary { get; public set; }
    public TimeSpan JobExpirationCheckInterval { get; public set; }
    public TimeSpan CountersAggregateInterval { get; public set; }
    public Nullable`1<int> DashboardJobListLimit { get; public set; }
    public TimeSpan TransactionTimeout { get; public set; }
    public Nullable`1<TimeSpan> CommandTimeout { get; public set; }
    public Nullable`1<TimeSpan> CommandBatchMaxTimeout { get; public set; }
    public TimeSpan InactiveStateExpirationTimeout { get; public set; }
    public string SchemaName { get; public set; }
    public Func`1<IDisposable> ImpersonationFunc { get; public set; }
    public bool DisableGlobalLocks { get; public set; }
    [ObsoleteAttribute("This option is deprecated and doesn't change anything. You can safely remove it. Will be removed in 2.0.0.")]
public bool UsePageLocksOnDequeue { get; public set; }
    public bool UseRecommendedIsolationLevel { get; public set; }
    public bool EnableHeavyMigrations { get; public set; }
    public bool UseFineGrainedLocks { get; public set; }
    public bool UseIgnoreDupKeyOption { get; public set; }
    public int DeleteExpiredBatchSize { get; public set; }
    public bool UseTransactionalAcknowledge { get; public set; }
    public DbProviderFactory SqlClientFactory { get; public set; }
    public bool TryAutoDetectSchemaDependentOptions { get; public set; }
    public IPersistentJobQueueProvider DefaultQueueProvider { get; public set; }
    private static DbProviderFactory GetDefaultSqlClientFactory();
    [CompilerGeneratedAttribute]
public Nullable`1<IsolationLevel> get_TransactionIsolationLevel();
    [CompilerGeneratedAttribute]
public void set_TransactionIsolationLevel(Nullable`1<IsolationLevel> value);
    public TimeSpan get_QueuePollInterval();
    public void set_QueuePollInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_InvisibilityTimeout();
    [CompilerGeneratedAttribute]
public void set_InvisibilityTimeout(TimeSpan value);
    public Nullable`1<TimeSpan> get_SlidingInvisibilityTimeout();
    public void set_SlidingInvisibilityTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_PrepareSchemaIfNecessary();
    [CompilerGeneratedAttribute]
public void set_PrepareSchemaIfNecessary(bool value);
    public TimeSpan get_JobExpirationCheckInterval();
    public void set_JobExpirationCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CountersAggregateInterval();
    [CompilerGeneratedAttribute]
public void set_CountersAggregateInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DashboardJobListLimit();
    [CompilerGeneratedAttribute]
public void set_DashboardJobListLimit(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TransactionTimeout();
    [CompilerGeneratedAttribute]
public void set_TransactionTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CommandBatchMaxTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandBatchMaxTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_InactiveStateExpirationTimeout();
    [CompilerGeneratedAttribute]
public void set_InactiveStateExpirationTimeout(TimeSpan value);
    public string get_SchemaName();
    public void set_SchemaName(string value);
    [CompilerGeneratedAttribute]
public Func`1<IDisposable> get_ImpersonationFunc();
    [CompilerGeneratedAttribute]
public void set_ImpersonationFunc(Func`1<IDisposable> value);
    [CompilerGeneratedAttribute]
public bool get_DisableGlobalLocks();
    [CompilerGeneratedAttribute]
public void set_DisableGlobalLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsePageLocksOnDequeue();
    [CompilerGeneratedAttribute]
public void set_UsePageLocksOnDequeue(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseRecommendedIsolationLevel();
    [CompilerGeneratedAttribute]
public void set_UseRecommendedIsolationLevel(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableHeavyMigrations();
    [CompilerGeneratedAttribute]
public void set_EnableHeavyMigrations(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseFineGrainedLocks();
    [CompilerGeneratedAttribute]
public void set_UseFineGrainedLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseIgnoreDupKeyOption();
    [CompilerGeneratedAttribute]
public void set_UseIgnoreDupKeyOption(bool value);
    [CompilerGeneratedAttribute]
public int get_DeleteExpiredBatchSize();
    [CompilerGeneratedAttribute]
public void set_DeleteExpiredBatchSize(int value);
    [CompilerGeneratedAttribute]
public bool get_UseTransactionalAcknowledge();
    [CompilerGeneratedAttribute]
public void set_UseTransactionalAcknowledge(bool value);
    public DbProviderFactory get_SqlClientFactory();
    public void set_SqlClientFactory(DbProviderFactory value);
    [CompilerGeneratedAttribute]
public bool get_TryAutoDetectSchemaDependentOptions();
    [CompilerGeneratedAttribute]
public void set_TryAutoDetectSchemaDependentOptions(bool value);
    [CompilerGeneratedAttribute]
public IPersistentJobQueueProvider get_DefaultQueueProvider();
    [CompilerGeneratedAttribute]
public void set_DefaultQueueProvider(IPersistentJobQueueProvider value);
}
internal class Hangfire.SqlServer.SqlServerTimeoutJob : object {
    private ILog _logger;
    private object _syncRoot;
    private SqlServerStorage _storage;
    private bool _disposed;
    private bool _removedFromQueue;
    private bool _requeued;
    private SqlServerWriteOnlyTransaction _transaction;
    private long _lastHeartbeat;
    private TimeSpan _interval;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FetchedAt>k__BackingField;
    public long Id { get; }
    public string JobId { get; }
    public string Queue { get; }
    internal Nullable`1<DateTime> FetchedAt { get; private set; }
    public SqlServerTimeoutJob(SqlServerStorage storage, long id, string jobId, string queue, Nullable`1<DateTime> fetchedAt);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JobId();
    [CompilerGeneratedAttribute]
public string get_Queue();
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_FetchedAt();
    [CompilerGeneratedAttribute]
private void set_FetchedAt(Nullable`1<DateTime> value);
    public sealed virtual void RemoveFromQueue();
    public sealed virtual void Requeue();
    public sealed virtual void Dispose();
    internal void SetTransaction(SqlServerWriteOnlyTransaction transaction);
    internal void DisposeTimer();
    internal void ExecuteKeepAliveQueryIfRequired();
    [CompilerGeneratedAttribute]
private void <RemoveFromQueue>b__23_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private void <Requeue>b__24_0(DbConnection connection);
    [CompilerGeneratedAttribute]
private void <ExecuteKeepAliveQueryIfRequired>b__28_0(DbConnection connection);
}
internal class Hangfire.SqlServer.SqlServerTransactionJob : object {
    private static TimeSpan KeepAliveInterval;
    private SqlServerStorage _storage;
    private IDbConnection _connection;
    private IDbTransaction _transaction;
    private Timer _timer;
    private object _lockObject;
    [CompilerGeneratedAttribute]
private string <JobId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string JobId { get; }
    public string Queue { get; }
    public SqlServerTransactionJob(SqlServerStorage storage, IDbConnection connection, IDbTransaction transaction, string jobId, string queue);
    private static SqlServerTransactionJob();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JobId();
    [CompilerGeneratedAttribute]
public string get_Queue();
    public sealed virtual void RemoveFromQueue();
    public sealed virtual void Requeue();
    public sealed virtual void Dispose();
    private void ExecuteKeepAliveQuery(object obj);
}
internal class Hangfire.SqlServer.SqlServerWriteOnlyTransaction : JobStorageTransaction {
    private Queue`1<Action`2<DbConnection, DbTransaction>> _queueCommandQueue;
    private HashSet`1<string> _queuesToSignal;
    private SqlServerStorage _storage;
    private SqlServerConnection _connection;
    private SortedDictionary`2<long, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _jobCommands;
    private SortedDictionary`2<string, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _counterCommands;
    private SortedDictionary`2<string, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _hashCommands;
    private SortedDictionary`2<string, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _listCommands;
    private SortedDictionary`2<string, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _setCommands;
    private SortedDictionary`2<string, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> _queueCommands;
    private List`1<Tuple`3<DbCommand, DbParameter, string>> _lockCommands;
    private List`1<DisposableLock> _acquiredLocks;
    private SortedSet`1<string> _lockedResources;
    private bool _committed;
    public bool Committed { get; }
    public SqlServerWriteOnlyTransaction(SqlServerConnection connection);
    public bool get_Committed();
    public virtual void Commit();
    public virtual void Dispose();
    public virtual void AcquireDistributedLock(string resource, TimeSpan timeout);
    public virtual void ExpireJob(string jobId, TimeSpan expireIn);
    public virtual void PersistJob(string jobId);
    public virtual void SetJobState(string jobId, IState state);
    public virtual void AddJobState(string jobId, IState state);
    public virtual void AddToQueue(string queue, string jobId);
    public virtual void IncrementCounter(string key);
    public virtual void IncrementCounter(string key, TimeSpan expireIn);
    public virtual void DecrementCounter(string key);
    public virtual void DecrementCounter(string key, TimeSpan expireIn);
    public virtual void AddToSet(string key, string value);
    public virtual void AddToSet(string key, string value, double score);
    public virtual void RemoveFromSet(string key, string value);
    public virtual void InsertToList(string key, string value);
    public virtual void RemoveFromList(string key, string value);
    public virtual void TrimList(string key, int keepStartingFrom, int keepEndingAt);
    public virtual void SetRangeInHash(string key, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public virtual void RemoveHash(string key);
    public virtual void AddRangeToSet(string key, IList`1<string> items);
    public virtual void RemoveSet(string key);
    public virtual void ExpireHash(string key, TimeSpan expireIn);
    public virtual void ExpireSet(string key, TimeSpan expireIn);
    public virtual void ExpireList(string key, TimeSpan expireIn);
    public virtual void PersistHash(string key);
    public virtual void PersistSet(string key);
    public virtual void PersistList(string key);
    public virtual void RemoveFromQueue(IFetchedJob fetchedJob);
    private static void AppendBatch(SortedDictionary`2<TKey, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> collection, SqlCommandBatch batch);
    private static void AddCommand(SortedDictionary`2<TKey, List`1<Tuple`2<string, SqlCommandBatchParameter[]>>> collection, TKey key, string commandText, SqlCommandBatchParameter[] parameters);
    private void AcquireListLock(string key);
    private void AcquireSetLock(string key);
    private void AcquireHashLock(string key);
    private void AcquireLock(string resource);
    private void TrySignalListeningWorkers();
    [CompilerGeneratedAttribute]
private void <Commit>b__17_0(DbConnection connection, DbTransaction transaction);
}
internal static class Hangfire.SqlServer.TimestampHelper : object {
    public static long GetTimestamp();
    public static TimeSpan Elapsed(long timestamp);
    public static TimeSpan Elapsed(long now, long timestamp);
}
[ExtensionAttribute]
public static class Hangfire.SqlServerStorageExtensions : object {
    private static int _metricsInitialized;
    [ExtensionAttribute]
public static IGlobalConfiguration`1<SqlServerStorage> UseSqlServerStorage(IGlobalConfiguration configuration, string nameOrConnectionString);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<SqlServerStorage> UseSqlServerStorage(IGlobalConfiguration configuration, string nameOrConnectionString, SqlServerStorageOptions options);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<SqlServerStorage> UseSqlServerStorage(IGlobalConfiguration configuration, Func`1<DbConnection> connectionFactory);
    [ExtensionAttribute]
public static IGlobalConfiguration`1<SqlServerStorage> UseSqlServerStorage(IGlobalConfiguration configuration, Func`1<DbConnection> connectionFactory, SqlServerStorageOptions options);
    [ExtensionAttribute]
private static IGlobalConfiguration`1<SqlServerStorage> UseSqlServerStorageCommonMetrics(IGlobalConfiguration`1<SqlServerStorage> configuration);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
