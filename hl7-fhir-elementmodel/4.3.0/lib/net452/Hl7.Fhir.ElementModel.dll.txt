internal class Hl7.Fhir.ElementModel.Adapters.SourceNodeToTypedElementAdapter : object {
    public ISourceNode Current;
    [CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string Name { get; }
    public string InstanceType { get; }
    public object Value { get; }
    public string Location { get; }
    public IElementDefinitionSummary Definition { get; }
    public SourceNodeToTypedElementAdapter(ISourceNode node);
    private SourceNodeToTypedElementAdapter(SourceNodeToTypedElementAdapter parent, ISourceNode sourceNode);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionNotificationHandler get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    public sealed virtual string get_Name();
    public sealed virtual string get_InstanceType();
    public sealed virtual object get_Value();
    public sealed virtual string get_Location();
    public sealed virtual IElementDefinitionSummary get_Definition();
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    private sealed virtual override IEnumerable`1<object> Hl7.Fhir.Utility.IAnnotated.Annotations(Type type);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object o, ExceptionNotification a);
    [CompilerGeneratedAttribute]
private SourceNodeToTypedElementAdapter <Children>b__17_0(ISourceNode c);
}
internal class Hl7.Fhir.ElementModel.Adapters.TypedElementToSourceNodeAdapter : object {
    public ITypedElement Current;
    [CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string Name { get; }
    public string Text { get; }
    public string Location { get; }
    public string ResourceType { get; }
    public TypedElementToSourceNodeAdapter(ITypedElement element);
    private TypedElementToSourceNodeAdapter(TypedElementToSourceNodeAdapter parent, ITypedElement child);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionNotificationHandler get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    public sealed virtual string get_Name();
    public sealed virtual string get_Text();
    public sealed virtual string get_Location();
    public sealed virtual string get_ResourceType();
    public sealed virtual IEnumerable`1<ISourceNode> Children(string name);
    private sealed virtual override IEnumerable`1<object> Hl7.Fhir.Utility.IAnnotated.Annotations(Type type);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object o, ExceptionNotification a);
}
[ObsoleteAttribute("This class is used for internal purposes and is subject to change without notice. Don't use.")]
public class Hl7.Fhir.ElementModel.AdditionalStructuralRule : MulticastDelegate {
    public AdditionalStructuralRule(object object, IntPtr method);
    public virtual object Invoke(ITypedElement node, IExceptionSource ies, object state);
    public virtual IAsyncResult BeginInvoke(ITypedElement node, IExceptionSource ies, object state, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class Hl7.Fhir.ElementModel.DomNode`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private List`1<T> _childList;
    [CompilerGeneratedAttribute]
private T <Parent>k__BackingField;
    private AnnotationList _annotations;
    public string Name { get; public set; }
    protected List`1<T> ChildList { get; protected set; }
    public T Parent { get; protected set; }
    public DomNodeList`1<T> Item { get; }
    public T Item { get; }
    protected AnnotationList AnnotationsInternal { get; }
    protected bool HasAnnotations { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected List`1<T> get_ChildList();
    protected void set_ChildList(List`1<T> value);
    internal IEnumerable`1<T> ChildrenInternal(string name);
    [CompilerGeneratedAttribute]
public T get_Parent();
    [CompilerGeneratedAttribute]
protected void set_Parent(T value);
    public DomNodeList`1<T> get_Item(string name);
    public T get_Item(int index);
    protected AnnotationList get_AnnotationsInternal();
    protected bool get_HasAnnotations();
    public sealed virtual void AddAnnotation(object annotation);
    public sealed virtual void RemoveAnnotations(Type type);
}
[DefaultMemberAttribute("Item")]
public class Hl7.Fhir.ElementModel.DomNodeList`1 : object {
    private IList`1<T> _wrapped;
    public T Item { get; }
    public DomNodeList`1<T> Item { get; }
    public int Count { get; }
    internal DomNodeList`1(IEnumerable`1<T> nodes);
    public T get_Item(int index);
    public DomNodeList`1<T> get_Item(string name);
    public int get_Count();
    public bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Hl7.Fhir.ElementModel.ElementNode : DomNode`1<ElementNode> {
    public static IEnumerable`1<ITypedElement> EmptyList;
    private IReadOnlyCollection`1<IElementDefinitionSummary> _childDefinitions;
    [CompilerGeneratedAttribute]
private IElementDefinitionSummary <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public IElementDefinitionSummary Definition { get; private set; }
    public string InstanceType { get; private set; }
    public object Value { get; public set; }
    public string Location { get; }
    public string ShortPath { get; }
    internal ElementNode(string name, object value, string instanceType, IElementDefinitionSummary definition);
    private static ElementNode();
    public static ITypedElement ForPrimitive(object value);
    public static bool TryConvertToElementValue(object value, Object& primitiveValue);
    public static IEnumerable`1<ITypedElement> CreateList(Object[] values);
    public static IEnumerable`1<ITypedElement> CreateList(IEnumerable`1<object> values);
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    private IReadOnlyCollection`1<IElementDefinitionSummary> getChildDefinitions(IStructureDefinitionSummaryProvider provider);
    public ElementNode Add(IStructureDefinitionSummaryProvider provider, ElementNode child, string name);
    public ElementNode Add(IStructureDefinitionSummaryProvider provider, string name, object value, string instanceType);
    public void ReplaceWith(IStructureDefinitionSummaryProvider provider, ElementNode node);
    public void Replace(IStructureDefinitionSummaryProvider provider, ElementNode oldChild, ElementNode newChild);
    private void importChild(IStructureDefinitionSummaryProvider provider, ElementNode child, string name, Nullable`1<int> position);
    public static ElementNode Root(IStructureDefinitionSummaryProvider provider, string type, string name, object value);
    public static ElementNode FromElement(ITypedElement node, bool recursive, IEnumerable`1<Type> annotationsToCopy);
    private static ElementNode buildNode(ITypedElement node, bool recursive, IEnumerable`1<Type> annotationsToCopy, ElementNode parent);
    public bool Remove(ElementNode child);
    [ObsoleteAttribute("The Clone() function actually only performs a shallow copy, so this function has been renamed to ShallowCopy()")]
public ElementNode Clone();
    public ElementNode ShallowCopy();
    [CompilerGeneratedAttribute]
public sealed virtual IElementDefinitionSummary get_Definition();
    [CompilerGeneratedAttribute]
private void set_Definition(IElementDefinitionSummary value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceType();
    [CompilerGeneratedAttribute]
private void set_InstanceType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public sealed virtual IEnumerable`1<object> Annotations(Type type);
    public sealed virtual string get_Location();
    public sealed virtual string get_ShortPath();
    [CompilerGeneratedAttribute]
internal static object <TryConvertToElementValue>g__conv|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
private bool <get_Location>b__34_0(ElementNode c);
    [CompilerGeneratedAttribute]
private bool <get_ShortPath>b__36_0(ElementNode c);
}
[ExtensionAttribute]
public static class Hl7.Fhir.ElementModel.ElementNodeComparator : object {
    [ExtensionAttribute]
public static TreeComparisonResult IsEqualTo(ITypedElement expected, ITypedElement actual);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Hl7.Fhir.ElementModel.ElementNodeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Children(IEnumerable`1<ITypedElement> nodes, string name);
    [IteratorStateMachineAttribute("Hl7.Fhir.ElementModel.ElementNodeExtensions/<Descendants>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Descendants(ITypedElement element);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Descendants(IEnumerable`1<ITypedElement> elements);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> DescendantsAndSelf(ITypedElement element);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> DescendantsAndSelf(IEnumerable`1<ITypedElement> elements);
    [ExtensionAttribute]
public static void Visit(ITypedElement root, Action`2<int, ITypedElement> visitor);
    [ExtensionAttribute]
private static void visit(ITypedElement root, Action`2<int, ITypedElement> visitor, int depth);
    [ExtensionAttribute]
public static IDisposable Catch(ITypedElement source, ExceptionNotificationHandler handler);
    [ExtensionAttribute]
public static void VisitAll(ITypedElement nav);
    [ExtensionAttribute]
public static List`1<ExceptionNotification> VisitAndCatch(ITypedElement node);
    [ExtensionAttribute]
public static IEnumerable`1<object> Annotations(ITypedElement nav, Type type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T Annotation(ITypedElement nav);
    [ExtensionAttribute]
public static ISourceNode ToSourceNode(ITypedElement node);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<IElementDefinitionSummary> ChildDefinitions(ITypedElement me, IStructureDefinitionSummaryProvider provider);
    [ExtensionAttribute]
public static ScopedNode ToScopedNode(ITypedElement node);
}
[ObsoleteAttribute("The ICdaInfoSupplier interface is part of alpha-level support for parsing CDA and should not yet be used in production. This interface is subject to change.")]
public interface Hl7.Fhir.ElementModel.ICdaInfoSupplier {
    public string XHtmlText { get; }
    public abstract virtual string get_XHtmlText();
}
public interface Hl7.Fhir.ElementModel.IResourceTypeSupplier {
    public string ResourceType { get; }
    public abstract virtual string get_ResourceType();
}
public interface Hl7.Fhir.ElementModel.IShortPathGenerator {
    public string ShortPath { get; }
    public abstract virtual string get_ShortPath();
}
public interface Hl7.Fhir.ElementModel.ISourceNode {
    public string Name { get; }
    public string Text { get; }
    public string Location { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Text();
    public abstract virtual string get_Location();
    public abstract virtual IEnumerable`1<ISourceNode> Children(string name);
}
public interface Hl7.Fhir.ElementModel.ITypedElement {
    public string Name { get; }
    public string InstanceType { get; }
    public object Value { get; }
    public string Location { get; }
    public IElementDefinitionSummary Definition { get; }
    public abstract virtual IEnumerable`1<ITypedElement> Children(string name);
    public abstract virtual string get_Name();
    public abstract virtual string get_InstanceType();
    public abstract virtual object get_Value();
    public abstract virtual string get_Location();
    public abstract virtual IElementDefinitionSummary get_Definition();
}
public class Hl7.Fhir.ElementModel.MaskingNode : object {
    [CompilerGeneratedAttribute]
private bool <_includeAll>k__BackingField;
    private MaskingNodeSettings _settings;
    [CompilerGeneratedAttribute]
private ITypedElement <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    private bool _includeAll { get; private set; }
    public ITypedElement Source { get; private set; }
    public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string Name { get; }
    public string InstanceType { get; }
    public object Value { get; }
    public string Location { get; }
    public IElementDefinitionSummary Definition { get; }
    public MaskingNode(ITypedElement source, MaskingNodeSettings settings);
    private MaskingNode(MaskingNode parent, ITypedElement source, bool includeAll);
    [CompilerGeneratedAttribute]
private bool get__includeAll();
    [CompilerGeneratedAttribute]
private void set__includeAll(bool value);
    public static MaskingNode ForSummary(ITypedElement node);
    public static MaskingNode ForText(ITypedElement node);
    public static MaskingNode ForElements(ITypedElement node, String[] _elements);
    public static MaskingNode ForElements(ITypedElement node, String[] _elements, bool includeMandatory);
    public static MaskingNode ForData(ITypedElement node);
    public static MaskingNode ForCount(ITypedElement node);
    private ScopedNode getScope(ITypedElement node);
    [CompilerGeneratedAttribute]
public ITypedElement get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(ITypedElement value);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionNotificationHandler get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    public sealed virtual string get_Name();
    public sealed virtual string get_InstanceType();
    public sealed virtual object get_Value();
    public sealed virtual string get_Location();
    public sealed virtual IElementDefinitionSummary get_Definition();
    private ValueTuple`2<bool, bool> included(ITypedElement node);
    public sealed virtual IEnumerable`1<object> Annotations(Type type);
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0(object o, ExceptionNotification a);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType0`2<ITypedElement, ValueTuple`2<bool, bool>> <Children>b__34_0(ITypedElement c);
    [CompilerGeneratedAttribute]
private MaskingNode <Children>b__34_2(<>f__AnonymousType0`2<ITypedElement, ValueTuple`2<bool, bool>> <>h__TransparentIdentifier0);
}
public class Hl7.Fhir.ElementModel.MaskingNodeSettings : object {
    [CompilerGeneratedAttribute]
private PreserveBundleMode <PreserveBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeMandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeNarrative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeMarkdown>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAll>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <IncludeElements>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludeElements>k__BackingField;
    public PreserveBundleMode PreserveBundle { get; public set; }
    public bool IncludeMandatory { get; public set; }
    public bool IncludeInSummary { get; public set; }
    public bool ExcludeNarrative { get; public set; }
    public bool ExcludeMarkdown { get; public set; }
    public bool IncludeAll { get; public set; }
    public String[] IncludeElements { get; public set; }
    public String[] ExcludeElements { get; public set; }
    public MaskingNodeSettings(MaskingNodeSettings other);
    [CompilerGeneratedAttribute]
public PreserveBundleMode get_PreserveBundle();
    [CompilerGeneratedAttribute]
public void set_PreserveBundle(PreserveBundleMode value);
    [CompilerGeneratedAttribute]
public bool get_IncludeMandatory();
    [CompilerGeneratedAttribute]
public void set_IncludeMandatory(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeInSummary();
    [CompilerGeneratedAttribute]
public void set_IncludeInSummary(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeNarrative();
    [CompilerGeneratedAttribute]
public void set_ExcludeNarrative(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeMarkdown();
    [CompilerGeneratedAttribute]
public void set_ExcludeMarkdown(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeAll();
    [CompilerGeneratedAttribute]
public void set_IncludeAll(bool value);
    [CompilerGeneratedAttribute]
public String[] get_IncludeElements();
    [CompilerGeneratedAttribute]
public void set_IncludeElements(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_ExcludeElements();
    [CompilerGeneratedAttribute]
public void set_ExcludeElements(String[] value);
    public void CopyTo(MaskingNodeSettings other);
    public MaskingNodeSettings Clone();
    public static MaskingNodeSettings CreateDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Hl7.Fhir.ElementModel.PrimitiveElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceType>k__BackingField;
    public string Name { get; private set; }
    public object Value { get; private set; }
    public string InstanceType { get; private set; }
    public string Location { get; }
    public IElementDefinitionSummary Definition { get; }
    private string Hl7.Fhir.Specification.IElementDefinitionSummary.ElementName { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.IsCollection { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.IsRequired { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.InSummary { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.IsModifier { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.IsChoiceElement { get; }
    private bool Hl7.Fhir.Specification.IElementDefinitionSummary.IsResource { get; }
    [NullableAttribute("2")]
private string Hl7.Fhir.Specification.IElementDefinitionSummary.DefaultTypeName { get; }
    private ITypeSerializationInfo[] Hl7.Fhir.Specification.IElementDefinitionSummary.Type { get; }
    [NullableAttribute("2")]
private string Hl7.Fhir.Specification.IElementDefinitionSummary.NonDefaultNamespace { get; }
    private XmlRepresentation Hl7.Fhir.Specification.IElementDefinitionSummary.Representation { get; }
    private int Hl7.Fhir.Specification.IElementDefinitionSummary.Order { get; }
    private string Hl7.Fhir.Specification.IStructureDefinitionSummary.TypeName { get; }
    private bool Hl7.Fhir.Specification.IStructureDefinitionSummary.IsAbstract { get; }
    private bool Hl7.Fhir.Specification.IStructureDefinitionSummary.IsResource { get; }
    private PrimitiveElement(object value, string instanceType, string name);
    public PrimitiveElement(object value, string name, bool useFullTypeName);
    internal static PrimitiveElement ForQuantity(Quantity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceType();
    [CompilerGeneratedAttribute]
private void set_InstanceType(string value);
    public sealed virtual string get_Location();
    public sealed virtual IElementDefinitionSummary get_Definition();
    private sealed virtual override string Hl7.Fhir.Specification.IElementDefinitionSummary.get_ElementName();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_IsCollection();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_IsRequired();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_InSummary();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_IsModifier();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_IsChoiceElement();
    private sealed virtual override bool Hl7.Fhir.Specification.IElementDefinitionSummary.get_IsResource();
    [NullableContextAttribute("2")]
private sealed virtual override string Hl7.Fhir.Specification.IElementDefinitionSummary.get_DefaultTypeName();
    private sealed virtual override ITypeSerializationInfo[] Hl7.Fhir.Specification.IElementDefinitionSummary.get_Type();
    [NullableContextAttribute("2")]
private sealed virtual override string Hl7.Fhir.Specification.IElementDefinitionSummary.get_NonDefaultNamespace();
    private sealed virtual override XmlRepresentation Hl7.Fhir.Specification.IElementDefinitionSummary.get_Representation();
    private sealed virtual override int Hl7.Fhir.Specification.IElementDefinitionSummary.get_Order();
    private sealed virtual override string Hl7.Fhir.Specification.IStructureDefinitionSummary.get_TypeName();
    private sealed virtual override bool Hl7.Fhir.Specification.IStructureDefinitionSummary.get_IsAbstract();
    private sealed virtual override bool Hl7.Fhir.Specification.IStructureDefinitionSummary.get_IsResource();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ITypedElement Clone();
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    private sealed virtual override IReadOnlyCollection`1<IElementDefinitionSummary> Hl7.Fhir.Specification.IStructureDefinitionSummary.GetElements();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.ScopedNode : object {
    private Cache _cache;
    public ITypedElement Current;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    [NullableAttribute("2")]
public ScopedNode ParentResource;
    [NullableAttribute("2")]
private string _fullUrl;
    [NullableAttribute("2")]
public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string LocalLocation { get; }
    public string Name { get; }
    public string InstanceType { get; }
    public object Value { get; }
    public string Location { get; }
    public bool AtResource { get; }
    public string NearestResourceType { get; }
    public ITypedElement ResourceContext { get; }
    public IElementDefinitionSummary Definition { get; }
    [NullableAttribute("2")]
public string InstanceUri { get; private set; }
    public ScopedNode(ITypedElement wrapped, string instanceUri);
    private ScopedNode(ScopedNode parentNode, ScopedNode parentResource, ITypedElement wrapped, string fullUrl);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ExceptionNotificationHandler get_ExceptionHandler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    public string get_LocalLocation();
    public sealed virtual string get_Name();
    public sealed virtual string get_InstanceType();
    public sealed virtual object get_Value();
    public sealed virtual string get_Location();
    public bool get_AtResource();
    public string get_NearestResourceType();
    public ITypedElement get_ResourceContext();
    public sealed virtual IElementDefinitionSummary get_Definition();
    [IteratorStateMachineAttribute("Hl7.Fhir.ElementModel.ScopedNode/<ParentResources>d__28")]
public IEnumerable`1<ScopedNode> ParentResources();
    [NullableContextAttribute("2")]
public string Id();
    public IEnumerable`1<ScopedNode> ContainedResources();
    public IEnumerable`1<BundledResource> BundledResources();
    [NullableContextAttribute("2")]
public string FullUrl();
    [NullableContextAttribute("2")]
public string get_InstanceUri();
    [NullableContextAttribute("2")]
private void set_InstanceUri(string value);
    public sealed virtual IEnumerable`1<object> Annotations(Type type);
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object o, ExceptionNotification a);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ScopedNode <Children>b__39_0(ITypedElement c);
}
public class Hl7.Fhir.ElementModel.SourceNode : DomNode`1<SourceNode> {
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string ResourceType { get; public set; }
    public string Text { get; public set; }
    public string Location { get; }
    private SourceNode(string name, string text, string resourceType);
    public sealed virtual IEnumerable`1<ISourceNode> Children(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public SourceNode Add(SourceNode child);
    public SourceNode AddRange(IEnumerable`1<SourceNode> children);
    public static SourceNode Valued(string name, string value, SourceNode[] children);
    public static SourceNode Resource(string name, string type, SourceNode[] children);
    public static SourceNode Node(string name, SourceNode[] children);
    public static SourceNode FromNode(ISourceNode node, bool recursive, IEnumerable`1<Type> annotationsToCopy);
    private static SourceNode buildNode(ISourceNode node, bool recursive, IEnumerable`1<Type> annotationsToCopy);
    public SourceNode Clone();
    public sealed virtual IEnumerable`1<object> Annotations(Type type);
    public sealed virtual string get_Location();
    [CompilerGeneratedAttribute]
private bool <get_Location>b__20_0(SourceNode c);
}
[ExtensionAttribute]
public static class Hl7.Fhir.ElementModel.SourceNodeComparator : object {
    [ExtensionAttribute]
public static TreeComparisonResult IsEqualTo(ISourceNode expected, ISourceNode actual);
}
[ExtensionAttribute]
public static class Hl7.Fhir.ElementModel.SourceNodeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ISourceNode> Children(IEnumerable`1<ISourceNode> node, string name);
    [IteratorStateMachineAttribute("Hl7.Fhir.ElementModel.SourceNodeExtensions/<Descendants>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<ISourceNode> Descendants(ISourceNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ISourceNode> Descendants(IEnumerable`1<ISourceNode> nodes);
    [ExtensionAttribute]
public static IEnumerable`1<ISourceNode> DescendantsAndSelf(ISourceNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ISourceNode> DescendantsAndSelf(IEnumerable`1<ISourceNode> nodes);
    [ExtensionAttribute]
public static void Visit(ISourceNode root, Action`2<int, ISourceNode> visitor);
    [ExtensionAttribute]
private static void visit(ISourceNode node, Action`2<int, ISourceNode> visitor, int depth);
    [ExtensionAttribute]
public static IDisposable Catch(ISourceNode node, ExceptionNotificationHandler handler, bool forward);
    [ExtensionAttribute]
public static void VisitAll(ISourceNode root);
    [ExtensionAttribute]
public static IList`1<ExceptionNotification> VisitAndCatch(ISourceNode root);
    [ExtensionAttribute]
public static string GetResourceTypeIndicator(ISourceNode node);
    [ExtensionAttribute]
public static IEnumerable`1<object> Annotations(ISourceNode node, Type type);
    [ExtensionAttribute]
public static T Annotation(ISourceNode nav);
    [ExtensionAttribute]
public static ITypedElement ToTypedElement(ISourceNode node, IStructureDefinitionSummaryProvider provider, string type, TypedElementSettings settings);
    [ExtensionAttribute]
[ObsoleteAttribute("WARNING! For internal API use only. Turning an untyped SourceNode into an ITypedElement without providingtype information (see other overload) will cause side-effects with components in the API that are not prepared to deal withmissing type information. Please don't use this overload unless you know what you are doing.")]
public static ITypedElement ToTypedElement(ISourceNode node);
}
public class Hl7.Fhir.ElementModel.StructuralTypeException : FormatException {
    public StructuralTypeException(string message);
    public StructuralTypeException(string message, Exception inner);
}
public class Hl7.Fhir.ElementModel.TreeComparisonResult : ValueType {
    public bool Success;
    public string FailureLocation;
    public string Details;
    public static TreeComparisonResult OK;
    private static TreeComparisonResult();
    public static TreeComparisonResult Fail(string location, string details);
}
internal class Hl7.Fhir.ElementModel.TypedElementOnSourceNode : object {
    private static string XHTML_INSTANCETYPE;
    private static string XHTML_DIV_TAG_NAME;
    [CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceType>k__BackingField;
    private ISourceNode _source;
    public IStructureDefinitionSummaryProvider Provider;
    private TypedElementSettings _settings;
    [CompilerGeneratedAttribute]
private IElementDefinitionSummary <Definition>k__BackingField;
    private object _value;
    private bool _valueInitialized;
    private static object _initializationLock;
    private static Dictionary`2<string, string> _suffixMap;
    [CompilerGeneratedAttribute]
private string <ShortPath>k__BackingField;
    public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string InstanceType { get; private set; }
    public IElementDefinitionSummary Definition { get; private set; }
    public string Name { get; }
    public object Value { get; }
    public string Location { get; }
    public string ShortPath { get; private set; }
    public TypedElementOnSourceNode(ISourceNode source, string type, IStructureDefinitionSummaryProvider provider, TypedElementSettings settings);
    private TypedElementOnSourceNode(TypedElementOnSourceNode parent, ISourceNode source, IElementDefinitionSummary definition, string instanceType, string prettyPath);
    private static TypedElementOnSourceNode();
    private ValueTuple`2<string, IElementDefinitionSummary> buildRootPosition(string type);
    [CompilerGeneratedAttribute]
public sealed virtual ExceptionNotificationHandler get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    private void raiseTypeError(string message, object source, bool warning, string location);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceType();
    [CompilerGeneratedAttribute]
private void set_InstanceType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IElementDefinitionSummary get_Definition();
    [CompilerGeneratedAttribute]
private void set_Definition(IElementDefinitionSummary value);
    public sealed virtual string get_Name();
    private static Type tryMapFhirPrimitiveTypeToSystemType(string fhirType);
    private object valueFactory();
    public sealed virtual object get_Value();
    private string deriveInstanceType(ISourceNode current, IElementDefinitionSummary info);
    private string typeFromLogicalModelCanonical(ITypeSerializationInfo info);
    private bool tryGetBySuffixedName(Dictionary`2<string, IElementDefinitionSummary> dis, string name, IElementDefinitionSummary& info);
    [IteratorStateMachineAttribute("Hl7.Fhir.ElementModel.TypedElementOnSourceNode/<enumerateElements>d__34")]
private IEnumerable`1<TypedElementOnSourceNode> enumerateElements(Dictionary`2<string, IElementDefinitionSummary> dis, ISourceNode parent, string name);
    public sealed virtual IEnumerable`1<ITypedElement> Children(string name);
    [IteratorStateMachineAttribute("Hl7.Fhir.ElementModel.TypedElementOnSourceNode/<runAdditionalRules>d__36")]
private IEnumerable`1<ITypedElement> runAdditionalRules(IEnumerable`1<ITypedElement> children);
    public sealed virtual string get_Location();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortPath();
    [CompilerGeneratedAttribute]
private void set_ShortPath(string value);
    public virtual string ToString();
    public sealed virtual IEnumerable`1<object> Annotations(Type type);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(object o, ExceptionNotification a);
    [CompilerGeneratedAttribute]
internal static string <deriveInstanceType>g__normalizeSuffix|30_1(string s);
}
public class Hl7.Fhir.ElementModel.TypedElementSettings : object {
    [CompilerGeneratedAttribute]
private TypeErrorMode <ErrorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TruncateDateTimeToDate>k__BackingField;
    public TypeErrorMode ErrorMode { get; public set; }
    [ObsoleteAttribute("Needed for backward compatibility with old parser for resources which were saved and considered valid in the past. Should not be used in new code.")]
public bool TruncateDateTimeToDate { get; public set; }
    public TypedElementSettings(TypedElementSettings other);
    [CompilerGeneratedAttribute]
public TypeErrorMode get_ErrorMode();
    [CompilerGeneratedAttribute]
public void set_ErrorMode(TypeErrorMode value);
    [CompilerGeneratedAttribute]
public bool get_TruncateDateTimeToDate();
    [CompilerGeneratedAttribute]
public void set_TruncateDateTimeToDate(bool value);
    public void CopyTo(TypedElementSettings other);
    public TypedElementSettings Clone();
    public static TypedElementSettings CreateDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Hl7.Fhir.ElementModel.Types.Any : object {
    protected static ArgumentNullException ArgNullException;
    private static Any();
    public static bool TryGetSystemTypeByName(string name, Type& result);
    public static object Parse(string value, Type primitiveType);
    public static bool TryParse(string value, Type primitiveType, Object& parsed);
    internal static ValueTuple`2<bool, T> DoConvert(Func`1<T> parser);
    public static bool TryConvert(object value, Any& primitiveValue);
    public static Any Convert(object value);
    protected static ArgumentException NotSameTypeComparison(object me, object them);
    protected static Result`1<T> CannotCastTo(Any from);
    protected static Result`1<T> propagateNull(object obj, Func`1<T> a);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Type <TryGetSystemTypeByName>g__get|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<bool, object> <TryParse>g__parse|2_0(<>c__DisplayClass2_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Any <TryConvert>g__conv|4_0(<>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Boolean : Any {
    public static Boolean True;
    public static Boolean False;
    public static string TRUE_LITERAL;
    public static string FALSE_LITERAL;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public Boolean(bool value);
    private static Boolean();
    [CompilerGeneratedAttribute]
public bool get_Value();
    public static Boolean Parse(string value);
    public static bool TryParse(string representation, Boolean& value);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Boolean a, Boolean b);
    public static bool op_Inequality(Boolean a, Boolean b);
    public static bool op_Implicit(Boolean b);
    public static Boolean op_Explicit(bool b);
    public static Decimal op_Explicit(Boolean b);
    public static Integer op_Explicit(Boolean b);
    public static Long op_Explicit(Boolean b);
    public static Quantity op_Explicit(Boolean b);
    public static String op_Explicit(Boolean b);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Code : Any {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <System>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Display>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [NullableAttribute("2")]
public string System { get; }
    public string Value { get; }
    [NullableAttribute("2")]
public string Display { get; }
    [NullableAttribute("2")]
public string Version { get; }
    [NullableContextAttribute("2")]
public Code(string system, string code, string display, string version);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_System();
    [CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Display();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Version();
    public static Code Parse(string value);
    public static bool TryParse(string representation, Code& value);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static Concept op_Implicit(Code c);
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    public static bool op_Equality(Code left, Code right);
    public static bool op_Inequality(Code left, Code right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Concept : Any {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<Code> <Codes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Display>k__BackingField;
    public IReadOnlyCollection`1<Code> Codes { get; }
    [NullableAttribute("2")]
public string Display { get; }
    public Concept(IEnumerable`1<Code> codes, string display);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<Code> get_Codes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Display();
    public static Concept Parse(string representation);
    public static bool TryParse(string representation, Concept& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    public static bool op_Equality(Concept left, Concept right);
    public static bool op_Inequality(Concept left, Concept right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Date : Any {
    [CompilerGeneratedAttribute]
private DateTimePrecision <Precision>k__BackingField;
    private string _original;
    private DateTimeOffset _parsedValue;
    [CompilerGeneratedAttribute]
private bool <HasOffset>k__BackingField;
    private static string DATEFORMAT;
    public static Regex PARTIALDATEREGEX;
    public DateTimePrecision Precision { get; private set; }
    public Nullable`1<int> Years { get; }
    public Nullable`1<int> Months { get; }
    public Nullable`1<int> Days { get; }
    public Nullable`1<TimeSpan> Offset { get; }
    public bool HasOffset { get; private set; }
    private Date(string original, DateTimeOffset parsedValue, DateTimePrecision precision, bool hasOffset);
    private static Date();
    public static Date Parse(string representation);
    public static bool TryParse(string representation, Date& value);
    public static Date FromDateTimeOffset(DateTimeOffset dto, DateTimePrecision prec, bool includeOffset);
    public DateTime ToDateTime();
    public static Date Today(bool includeOffset);
    [CompilerGeneratedAttribute]
public DateTimePrecision get_Precision();
    [CompilerGeneratedAttribute]
private void set_Precision(DateTimePrecision value);
    public Nullable`1<int> get_Years();
    public Nullable`1<int> get_Months();
    public Nullable`1<int> get_Days();
    public Nullable`1<TimeSpan> get_Offset();
    [CompilerGeneratedAttribute]
public bool get_HasOffset();
    [CompilerGeneratedAttribute]
private void set_HasOffset(bool value);
    public DateTimeOffset ToDateTimeOffset(int hours, int minutes, int seconds, TimeSpan defaultOffset);
    public DateTimeOffset ToDateTimeOffset(int hours, int minutes, int seconds, int milliseconds, TimeSpan defaultOffset);
    private static bool tryParse(string representation, Date& value);
    public static Date op_Addition(Date dateValue, Quantity addValue);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Result`1<bool> TryEquals(Any other);
    public static bool op_Equality(Date a, Date b);
    public static bool op_Inequality(Date a, Date b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public Result`1<int> TryCompareTo(Any other);
    public static bool op_LessThan(Date a, Date b);
    public static bool op_LessThanOrEqual(Date a, Date b);
    public static bool op_GreaterThan(Date a, Date b);
    public static bool op_GreaterThanOrEqual(Date a, Date b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static DateTime op_Implicit(Date pd);
    public static Date op_Explicit(DateTimeOffset dto);
    public static String op_Explicit(Date d);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.DateTime : Any {
    private string _original;
    private DateTimeOffset _parsedValue;
    [CompilerGeneratedAttribute]
private DateTimePrecision <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOffset>k__BackingField;
    private static string DATETIMEFORMAT;
    private static Regex DATETIMEREGEX;
    public static string FMT_FULL;
    public Nullable`1<int> Years { get; }
    public Nullable`1<int> Months { get; }
    public Nullable`1<int> Days { get; }
    public Nullable`1<int> Hours { get; }
    public Nullable`1<int> Minutes { get; }
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Millis { get; }
    public Nullable`1<TimeSpan> Offset { get; }
    public DateTimePrecision Precision { get; private set; }
    public bool HasOffset { get; private set; }
    internal DateTime(string original, DateTimeOffset parsedValue, DateTimePrecision precision, bool hasOffset);
    private static DateTime();
    public static DateTime Parse(string representation);
    public static bool TryParse(string representation, DateTime& value);
    public static string FormatDateTimeOffset(DateTimeOffset dto);
    public static DateTime FromDateTimeOffset(DateTimeOffset dto);
    [ObsoleteAttribute("FromDateTime() has been renamed to FromDateTimeOffset()")]
public static DateTime FromDateTime(DateTimeOffset dto);
    public static DateTime Now();
    public static DateTime Today();
    public Date TruncateToDate();
    public Nullable`1<int> get_Years();
    public Nullable`1<int> get_Months();
    public Nullable`1<int> get_Days();
    public Nullable`1<int> get_Hours();
    public Nullable`1<int> get_Minutes();
    public Nullable`1<int> get_Seconds();
    public Nullable`1<int> get_Millis();
    public static DateTime op_Addition(DateTime dateTimeValue, Quantity addValue);
    public Nullable`1<TimeSpan> get_Offset();
    [CompilerGeneratedAttribute]
public DateTimePrecision get_Precision();
    [CompilerGeneratedAttribute]
private void set_Precision(DateTimePrecision value);
    [CompilerGeneratedAttribute]
public bool get_HasOffset();
    [CompilerGeneratedAttribute]
private void set_HasOffset(bool value);
    public DateTimeOffset ToDateTimeOffset(TimeSpan defaultOffset);
    private static bool tryParse(string representation, DateTime& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Result`1<bool> TryEquals(Any other);
    public static bool op_Equality(DateTime a, DateTime b);
    public static bool op_Inequality(DateTime a, DateTime b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public Result`1<int> TryCompareTo(Any other);
    internal static Result`1<int> CompareDateTimeParts(DateTimeOffset l, DateTimePrecision lPrec, bool lHasOffset, DateTimeOffset r, DateTimePrecision rPrec, bool rHasOffset);
    public static bool op_LessThan(DateTime a, DateTime b);
    public static bool op_LessThanOrEqual(DateTime a, DateTime b);
    public static bool op_GreaterThan(DateTime a, DateTime b);
    public static bool op_GreaterThanOrEqual(DateTime a, DateTime b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static DateTime op_Explicit(DateTimeOffset dto);
    public static Date op_Explicit(DateTime dt);
    public static String op_Explicit(DateTime dt);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
}
public enum Hl7.Fhir.ElementModel.Types.DateTimePrecision : Enum {
    public int value__;
    public static DateTimePrecision Year;
    public static DateTimePrecision Month;
    public static DateTimePrecision Day;
    public static DateTimePrecision Hour;
    public static DateTimePrecision Minute;
    public static DateTimePrecision Second;
    public static DateTimePrecision Fraction;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Decimal : Any {
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    private static String[] FORBIDDEN_DECIMAL_PREFIXES;
    public static DecimalComparison CQL_EQUALS_COMPARISON;
    public static DecimalComparison CQL_EQUIVALENCE_COMPARISON;
    public decimal Value { get; }
    public Decimal(decimal value);
    private static Decimal();
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public static Decimal Parse(string value);
    public static bool TryParse(string representation, Decimal& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Decimal a, Decimal b);
    public static bool op_Inequality(Decimal a, Decimal b);
    public bool Equals(Any other, DecimalComparison comparisonType);
    public static int Scale(decimal d, bool ignoreTrailingZeroes);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_LessThan(Decimal a, Decimal b);
    public static bool op_LessThanOrEqual(Decimal a, Decimal b);
    public static bool op_GreaterThan(Decimal a, Decimal b);
    public static bool op_GreaterThanOrEqual(Decimal a, Decimal b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static decimal op_Implicit(Decimal d);
    public static Quantity op_Implicit(Decimal d);
    public static Decimal op_Explicit(decimal d);
    public static Boolean op_Explicit(Decimal d);
    public static String op_Explicit(Decimal d);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__scaleEq|11_0(decimal a, decimal b);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__eq|11_1(decimal a, decimal b);
}
public enum Hl7.Fhir.ElementModel.Types.DecimalComparison : Enum {
    public int value__;
    public static DecimalComparison Strict;
    public static DecimalComparison IgnoreTrailingZeroes;
    public static DecimalComparison RoundToSmallestScale;
}
[NullableContextAttribute("1")]
public interface Hl7.Fhir.ElementModel.Types.ICqlConvertible {
    public abstract virtual Result`1<Boolean> TryConvertToBoolean();
    public abstract virtual Result`1<Code> TryConvertToCode();
    public abstract virtual Result`1<Concept> TryConvertToConcept();
    public abstract virtual Result`1<Date> TryConvertToDate();
    public abstract virtual Result`1<DateTime> TryConvertToDateTime();
    public abstract virtual Result`1<Decimal> TryConvertToDecimal();
    public abstract virtual Result`1<Integer> TryConvertToInteger();
    public abstract virtual Result`1<Long> TryConvertToLong();
    public abstract virtual Result`1<Quantity> TryConvertToQuantity();
    public abstract virtual Result`1<Ratio> TryConvertToRatio();
    public abstract virtual Result`1<String> TryConvertToString();
    public abstract virtual Result`1<Time> TryConvertToTime();
}
[NullableContextAttribute("1")]
public interface Hl7.Fhir.ElementModel.Types.ICqlEquatable {
    public abstract virtual Nullable`1<bool> IsEqualTo(Any other);
    public abstract virtual bool IsEquivalentTo(Any other);
}
[NullableContextAttribute("1")]
public interface Hl7.Fhir.ElementModel.Types.ICqlOrderable {
    public abstract virtual Nullable`1<int> CompareTo(Any other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Integer : Any {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public Integer(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    public static Integer Parse(string value);
    public static bool TryParse(string representation, Integer& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Integer a, Integer b);
    public static bool op_Inequality(Integer a, Integer b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_LessThan(Integer a, Integer b);
    public static bool op_LessThanOrEqual(Integer a, Integer b);
    public static bool op_GreaterThan(Integer a, Integer b);
    public static bool op_GreaterThanOrEqual(Integer a, Integer b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static int op_Implicit(Integer i);
    public static Long op_Implicit(Integer i);
    public static Decimal op_Implicit(Integer i);
    public static Quantity op_Implicit(Integer i);
    public static Integer op_Explicit(int i);
    public static Boolean op_Explicit(Integer i);
    public static String op_Explicit(Integer i);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Long : Any {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; }
    public Long(long value);
    [CompilerGeneratedAttribute]
public long get_Value();
    public static Long Parse(string value);
    public static bool TryParse(string representation, Long& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Long a, Long b);
    public static bool op_Inequality(Long a, Long b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_LessThan(Long a, Long b);
    public static bool op_LessThanOrEqual(Long a, Long b);
    public static bool op_GreaterThan(Long a, Long b);
    public static bool op_GreaterThanOrEqual(Long a, Long b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static long op_Implicit(Long i);
    public static Decimal op_Implicit(Long i);
    public static Quantity op_Implicit(Long i);
    public static Long op_Explicit(long i);
    public static Boolean op_Explicit(Long l);
    public static String op_Explicit(Long l);
    public static Integer op_Explicit(Long l);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Quantity : Any {
    public static string UCUM;
    public static string UCUM_UNIT;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Unit>k__BackingField;
    [CompilerGeneratedAttribute]
private QuantityUnitSystem <System>k__BackingField;
    private static string QUANTITY_BASE_REGEX;
    public static Regex QUANTITYREGEX;
    internal static Regex QUANTITYREGEX_FOR_PARSE;
    public static QuantityComparison CQL_EQUALS_COMPARISON;
    public static QuantityComparison CQL_EQUIVALENCE_COMPARISON;
    public decimal Value { get; }
    public string Unit { get; }
    public QuantityUnitSystem System { get; private set; }
    public bool IsDefiniteDuration { get; }
    public bool IsCalendarDuration { get; }
    public bool IsDuration { get; }
    [NullableContextAttribute("2")]
public Quantity(decimal value, string unit);
    [NullableContextAttribute("2")]
public Quantity(decimal value, string unit, QuantityUnitSystem system);
    private static Quantity();
    [CompilerGeneratedAttribute]
public decimal get_Value();
    [CompilerGeneratedAttribute]
public string get_Unit();
    [CompilerGeneratedAttribute]
public QuantityUnitSystem get_System();
    [CompilerGeneratedAttribute]
private void set_System(QuantityUnitSystem value);
    public static Quantity ForCalendarDuration(decimal value, string calendarUnit);
    public static Quantity Parse(string representation);
    public static bool TryParse(string representation, Quantity& quantity);
    public static bool TryParseTimeUnit(string unitLiteral, String& unit, Boolean& isCalendarUnit);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(Any other, QuantityComparison comparisonType);
    public Result`1<bool> TryEquals(Any other, QuantityComparison comparisonType);
    public static bool op_Equality(Quantity a, Quantity b);
    public static bool op_Inequality(Quantity a, Quantity b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_LessThan(Quantity a, Quantity b);
    public static bool op_LessThanOrEqual(Quantity a, Quantity b);
    public static bool op_GreaterThan(Quantity a, Quantity b);
    public static bool op_GreaterThanOrEqual(Quantity a, Quantity b);
    public Result`1<int> TryCompareTo(Any other, QuantityComparison comparisonType);
    private Result`1<int> doDurationComparison(Quantity other, QuantityComparison comparisonType);
    public bool get_IsDefiniteDuration();
    public bool get_IsCalendarDuration();
    public bool get_IsDuration();
    public Result`1<int> TryCompareTo(Any other);
    public static bool op_Addition(Quantity a, Quantity b);
    public static bool op_Subtraction(Quantity a, Quantity b);
    public static bool op_Multiply(Quantity a, Quantity b);
    public static bool op_Division(Quantity a, Quantity b);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    public static String op_Explicit(Quantity q);
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <TryParseTimeUnit>g__parse|20_0(Boolean& isCalendarUnit, <>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static Quantity <doDurationComparison>g__normalizeToUcum|34_0(Quantity orig, <>c__DisplayClass34_0& );
}
[FlagsAttribute]
public enum Hl7.Fhir.ElementModel.Types.QuantityComparison : Enum {
    public int value__;
    public static QuantityComparison None;
    public static QuantityComparison CompareCalendarUnits;
}
public enum Hl7.Fhir.ElementModel.Types.QuantityUnitSystem : Enum {
    public int value__;
    public static QuantityUnitSystem UCUM;
    public static QuantityUnitSystem CalendarDuration;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Ratio : Any {
    [CompilerGeneratedAttribute]
private Quantity <Numerator>k__BackingField;
    [CompilerGeneratedAttribute]
private Quantity <Denominator>k__BackingField;
    public Quantity Numerator { get; }
    public Quantity Denominator { get; }
    public Ratio(Quantity numerator, Quantity denominator);
    [CompilerGeneratedAttribute]
public Quantity get_Numerator();
    [CompilerGeneratedAttribute]
public Quantity get_Denominator();
    public static Ratio Parse(string representation);
    public static bool TryParse(string representation, Ratio& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static String op_Explicit(Ratio r);
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    public static bool op_Equality(Ratio left, Ratio right);
    public static bool op_Inequality(Ratio left, Ratio right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.String : Any {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public static StringComparison CQL_EQUALS_COMPARISON;
    public static StringComparison CQL_EQUIVALENCE_COMPARISON;
    public string Value { get; }
    public String(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public static String Parse(string value);
    public static bool TryParse(string representation, String& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(String a, String b);
    public static bool op_Inequality(String a, String b);
    public bool Equals(Any other, StringComparison comparisonType);
    private static string normalizeWS(string data);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_LessThan(String a, String b);
    public static bool op_LessThanOrEqual(String a, String b);
    public static bool op_GreaterThan(String a, String b);
    public static bool op_GreaterThanOrEqual(String a, String b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static string op_Implicit(String s);
    public static String op_Explicit(string s);
    public static Boolean op_Explicit(String s);
    public static DateTime op_Explicit(String s);
    public static Date op_Explicit(String s);
    public static Time op_Explicit(String s);
    public static Decimal op_Explicit(String s);
    public static Integer op_Explicit(String s);
    public static Long op_Explicit(String s);
    public static Quantity op_Explicit(String s);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
}
[FlagsAttribute]
public enum Hl7.Fhir.ElementModel.Types.StringComparison : Enum {
    public int value__;
    public static StringComparison Unicode;
    public static StringComparison IgnoreCase;
    public static StringComparison NormalizeWhitespace;
    public static StringComparison IgnoreDiacritics;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.Fhir.ElementModel.Types.Time : Any {
    private string _original;
    private DateTimeOffset _parsedValue;
    [CompilerGeneratedAttribute]
private DateTimePrecision <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOffset>k__BackingField;
    internal static string PARTIALTIMEFORMAT;
    internal static string TIMEFORMAT;
    internal static string OFFSETFORMAT;
    private static Regex PARTIALTIMEREGEX;
    public Nullable`1<int> Hours { get; }
    public Nullable`1<int> Minutes { get; }
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Millis { get; }
    public Nullable`1<TimeSpan> Offset { get; }
    public DateTimePrecision Precision { get; private set; }
    public bool HasOffset { get; private set; }
    private Time(string original, DateTimeOffset parsedValue, DateTimePrecision precision, bool hasOffset);
    private static Time();
    public static Time Parse(string representation);
    public static bool TryParse(string representation, Time& value);
    public static Time FromDateTimeOffset(DateTimeOffset dto, DateTimePrecision prec, bool includeOffset);
    public static Time Now(bool includeOffset);
    public Nullable`1<int> get_Hours();
    public Nullable`1<int> get_Minutes();
    public Nullable`1<int> get_Seconds();
    public Nullable`1<int> get_Millis();
    public Nullable`1<TimeSpan> get_Offset();
    [CompilerGeneratedAttribute]
public DateTimePrecision get_Precision();
    [CompilerGeneratedAttribute]
private void set_Precision(DateTimePrecision value);
    [CompilerGeneratedAttribute]
public bool get_HasOffset();
    [CompilerGeneratedAttribute]
private void set_HasOffset(bool value);
    public DateTimeOffset ToDateTimeOffset(int year, int month, int day, TimeSpan defaultOffset);
    private static bool tryParse(string representation, Time& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Result`1<bool> TryEquals(Any other);
    public static bool op_Equality(Time a, Time b);
    public static bool op_Inequality(Time a, Time b);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public Result`1<int> TryCompareTo(Any other);
    public static bool op_LessThan(Time a, Time b);
    public static bool op_LessThanOrEqual(Time a, Time b);
    public static bool op_GreaterThan(Time a, Time b);
    public static bool op_GreaterThanOrEqual(Time a, Time b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Time op_Explicit(DateTimeOffset dto);
    public static String op_Explicit(Time dt);
    private sealed virtual override Nullable`1<bool> Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEqualTo(Any other);
    private sealed virtual override bool Hl7.Fhir.ElementModel.Types.ICqlEquatable.IsEquivalentTo(Any other);
    private sealed virtual override Nullable`1<int> Hl7.Fhir.ElementModel.Types.ICqlOrderable.CompareTo(Any other);
    private sealed virtual override Result`1<String> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToString();
    private sealed virtual override Result`1<Time> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToTime();
    private sealed virtual override Result`1<Code> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToCode();
    private sealed virtual override Result`1<Boolean> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToBoolean();
    private sealed virtual override Result`1<Date> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDate();
    private sealed virtual override Result`1<DateTime> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDateTime();
    private sealed virtual override Result`1<Decimal> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToDecimal();
    private sealed virtual override Result`1<Integer> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToInteger();
    private sealed virtual override Result`1<Long> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToLong();
    private sealed virtual override Result`1<Quantity> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToQuantity();
    private sealed virtual override Result`1<Ratio> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToRatio();
    private sealed virtual override Result`1<Concept> Hl7.Fhir.ElementModel.Types.ICqlConvertible.TryConvertToConcept();
}
public class Hl7.Fhir.Language.TypeSpecifier : object {
    public static string SYSTEM_NAMESPACE;
    public static string DOTNET_NAMESPACE;
    public static TypeSpecifier Any;
    public static TypeSpecifier Boolean;
    public static TypeSpecifier Code;
    public static TypeSpecifier Concept;
    public static TypeSpecifier Date;
    public static TypeSpecifier DateTime;
    public static TypeSpecifier Decimal;
    public static TypeSpecifier Integer;
    public static TypeSpecifier Long;
    public static TypeSpecifier Quantity;
    public static TypeSpecifier Ratio;
    public static TypeSpecifier String;
    public static TypeSpecifier Time;
    public static TypeSpecifier Void;
    public static TypeSpecifier[] AllTypes;
    public static TypeSpecifier[] PrimitiveTypes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public string Name { get; protected set; }
    public string Namespace { get; protected set; }
    public string FullName { get; }
    protected TypeSpecifier(string namespace, string name);
    private static TypeSpecifier();
    public static TypeSpecifier GetByName(string typeName);
    public static TypeSpecifier GetByName(string namespace, string typeName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
protected void set_Namespace(string value);
    public virtual string ToString();
    public string get_FullName();
    public static TypeSpecifier ForNativeType(Type dotNetType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeSpecifier other);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeSpecifier left, TypeSpecifier right);
    public static bool op_Inequality(TypeSpecifier left, TypeSpecifier right);
    [CompilerGeneratedAttribute]
internal static TypeSpecifier <GetByName>g__resolveSystemType|20_0(string name);
    [CompilerGeneratedAttribute]
internal static string <get_FullName>g__esc|31_0(string spec);
    [CompilerGeneratedAttribute]
internal static bool <ForNativeType>g__t|32_0(<>c__DisplayClass32_0& );
}
public class Hl7.Fhir.Serialization.BaseTypedElement : object {
    public ITypedElement Wrapped;
    [CompilerGeneratedAttribute]
private ExceptionNotificationHandler <ExceptionHandler>k__BackingField;
    public ExceptionNotificationHandler ExceptionHandler { get; public set; }
    public string Name { get; }
    public string InstanceType { get; }
    public object Value { get; }
    public string Location { get; }
    public IElementDefinitionSummary Definition { get; }
    public BaseTypedElement(ITypedElement wrapped);
    [CompilerGeneratedAttribute]
public virtual ExceptionNotificationHandler get_ExceptionHandler();
    [CompilerGeneratedAttribute]
public virtual void set_ExceptionHandler(ExceptionNotificationHandler value);
    public virtual string get_Name();
    public virtual string get_InstanceType();
    public virtual object get_Value();
    public virtual string get_Location();
    public virtual IElementDefinitionSummary get_Definition();
    public virtual IEnumerable`1<object> Annotations(Type type);
    public virtual IEnumerable`1<ITypedElement> Children(string name);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object o, ExceptionNotification a);
}
public static class Hl7.Fhir.Serialization.PrimitiveTypeConverter : object {
    private static String[] _forbiddenDecimalPrefixes;
    public static string FMT_FULL;
    private static PrimitiveTypeConverter();
    public static T ConvertTo(object value);
    public static object ConvertTo(object value, Type to);
    private static string convertToXmlString(object value);
    private static object convertXmlStringToPrimitive(Type to, string value);
    private static DateTimeOffset convertToDatetimeOffset(string value);
    public static bool CanConvert(Type type);
}
public class Hl7.Fhir.Specification.ElementDefinitionSummary : object {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChoiceElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsModifier>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlRepresentation <Representation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSerializationInfo[] <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NonDefaultNamespace>k__BackingField;
    public string ElementName { get; private set; }
    public bool IsCollection { get; private set; }
    public bool IsChoiceElement { get; private set; }
    public bool IsResource { get; private set; }
    public bool IsRequired { get; private set; }
    public bool InSummary { get; private set; }
    public bool IsModifier { get; private set; }
    public XmlRepresentation Representation { get; private set; }
    public int Order { get; private set; }
    public string DefaultTypeName { get; private set; }
    public ITypeSerializationInfo[] Type { get; private set; }
    public string NonDefaultNamespace { get; }
    public ElementDefinitionSummary(string elementName, bool isCollection, bool isChoice, bool isResource, XmlRepresentation representation, ITypeSerializationInfo[] type, int order, string nonDefaultNS, bool inSummary, bool isRequired);
    public ElementDefinitionSummary(string elementName, bool isCollection, bool isChoice, bool isResource, XmlRepresentation representation, string defaultType, ITypeSerializationInfo[] type, int order, string nonDefaultNS, bool inSummary, bool isRequired);
    public ElementDefinitionSummary(IElementDefinitionSummary source);
    public static ElementDefinitionSummary ForRoot(IStructureDefinitionSummary rootType, string rootName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ElementName();
    [CompilerGeneratedAttribute]
private void set_ElementName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCollection();
    [CompilerGeneratedAttribute]
private void set_IsCollection(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChoiceElement();
    [CompilerGeneratedAttribute]
private void set_IsChoiceElement(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsResource();
    [CompilerGeneratedAttribute]
private void set_IsResource(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRequired();
    [CompilerGeneratedAttribute]
private void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InSummary();
    [CompilerGeneratedAttribute]
private void set_InSummary(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsModifier();
    [CompilerGeneratedAttribute]
private void set_IsModifier(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual XmlRepresentation get_Representation();
    [CompilerGeneratedAttribute]
private void set_Representation(XmlRepresentation value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DefaultTypeName();
    [CompilerGeneratedAttribute]
private void set_DefaultTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSerializationInfo[] get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ITypeSerializationInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NonDefaultNamespace();
}
[ExtensionAttribute]
public static class Hl7.Fhir.Specification.ElementSerializationInfoExtensions : object {
    [ExtensionAttribute]
public static ElementDefinitionSummary GetElementDefinitionSummary(IAnnotated ann);
}
public interface Hl7.Fhir.Specification.IElementDefinitionSummary {
    public string ElementName { get; }
    public bool IsCollection { get; }
    public bool IsRequired { get; }
    public bool InSummary { get; }
    public bool IsChoiceElement { get; }
    public bool IsResource { get; }
    public bool IsModifier { get; }
    public ITypeSerializationInfo[] Type { get; }
    public string DefaultTypeName { get; }
    public string NonDefaultNamespace { get; }
    public XmlRepresentation Representation { get; }
    public int Order { get; }
    public abstract virtual string get_ElementName();
    public abstract virtual bool get_IsCollection();
    public abstract virtual bool get_IsRequired();
    public abstract virtual bool get_InSummary();
    public abstract virtual bool get_IsChoiceElement();
    public abstract virtual bool get_IsResource();
    public abstract virtual bool get_IsModifier();
    public abstract virtual ITypeSerializationInfo[] get_Type();
    public abstract virtual string get_DefaultTypeName();
    public abstract virtual string get_NonDefaultNamespace();
    public abstract virtual XmlRepresentation get_Representation();
    public abstract virtual int get_Order();
}
public interface Hl7.Fhir.Specification.IStructureDefinitionReference {
    public string ReferredType { get; }
    public abstract virtual string get_ReferredType();
}
public interface Hl7.Fhir.Specification.IStructureDefinitionSummary {
    public string TypeName { get; }
    public bool IsAbstract { get; }
    public bool IsResource { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsResource();
    public abstract virtual IReadOnlyCollection`1<IElementDefinitionSummary> GetElements();
}
public interface Hl7.Fhir.Specification.IStructureDefinitionSummaryProvider {
    public abstract virtual IStructureDefinitionSummary Provide(string canonical);
}
public interface Hl7.Fhir.Specification.ITypeSerializationInfo {
}
[ExtensionAttribute]
public static class Hl7.Fhir.Specification.TypeSerializationInfoExtensions : object {
    [ExtensionAttribute]
public static string GetTypeName(ITypeSerializationInfo info);
}
public enum Hl7.Fhir.Specification.XmlRepresentation : Enum {
    public int value__;
    public static XmlRepresentation None;
    public static XmlRepresentation XmlElement;
    public static XmlRepresentation XmlAttr;
    public static XmlRepresentation XmlText;
    public static XmlRepresentation TypeAttr;
    public static XmlRepresentation CdaText;
    public static XmlRepresentation XHtml;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
