public interface Hl7.Fhir.Language.Debugging.ISourcePositionInfo {
    public Source Source { get; }
    public abstract virtual Source get_Source();
}
public enum Hl7.Fhir.Language.Debugging.OutputCategory : Enum {
    public int value__;
    public static OutputCategory Console;
    public static OutputCategory StdOut;
    public static OutputCategory StdErr;
    public static OutputCategory Telemetry;
}
public class Hl7.Fhir.Language.Debugging.OutputEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private OutputCategory <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private Source <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Column>k__BackingField;
    public OutputCategory Category { get; public set; }
    public string Output { get; public set; }
    public Source Source { get; public set; }
    public Nullable`1<int> Line { get; public set; }
    public Nullable`1<int> Column { get; public set; }
    [CompilerGeneratedAttribute]
public OutputCategory get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(OutputCategory value);
    [CompilerGeneratedAttribute]
public string get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(string value);
    [CompilerGeneratedAttribute]
public Source get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Source value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(Nullable`1<int> value);
}
[ExtensionAttribute]
public static class Hl7.Fhir.Language.Debugging.PositionInfoExtensions : object {
    private static Random _generator;
    private static PositionInfoExtensions();
    [ExtensionAttribute]
public static StackFrame ToStackFrame(ISourcePositionInfo location, string name);
    [ExtensionAttribute]
public static string GetLocationLabel(ISourcePositionInfo loc);
}
public class Hl7.Fhir.Language.Debugging.Source : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceReference>k__BackingField;
    public string Name { get; public set; }
    public string Path { get; public set; }
    public int SourceReference { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_SourceReference();
    [CompilerGeneratedAttribute]
public void set_SourceReference(int value);
}
public class Hl7.Fhir.Language.Debugging.SourceBreakpoint : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public int Line { get; public set; }
    public Nullable`1<int> Column { get; public set; }
    public string Condition { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
public class Hl7.Fhir.Language.Debugging.StackFrame : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Source <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Id { get; public set; }
    public string Name { get; public set; }
    public Source Source { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    private Source Hl7.Fhir.Language.Debugging.ISourcePositionInfo.Source { get; }
    private int Hl7.Fhir.Utility.IPositionInfo.LineNumber { get; }
    private int Hl7.Fhir.Utility.IPositionInfo.LinePosition { get; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Source get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Source value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    private sealed virtual override Source Hl7.Fhir.Language.Debugging.ISourcePositionInfo.get_Source();
    private sealed virtual override int Hl7.Fhir.Utility.IPositionInfo.get_LineNumber();
    private sealed virtual override int Hl7.Fhir.Utility.IPositionInfo.get_LinePosition();
    public virtual string ToString();
}
public class Hl7.FhirPath.CompiledExpression : MulticastDelegate {
    public CompiledExpression(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<ITypedElement> Invoke(ITypedElement root, EvaluationContext ctx);
    public virtual IAsyncResult BeginInvoke(ITypedElement root, EvaluationContext ctx, AsyncCallback callback, object object);
    public virtual IEnumerable`1<ITypedElement> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Hl7.FhirPath.CompiledExpressionExtensions : object {
    [ExtensionAttribute]
public static object Scalar(CompiledExpression evaluator, ITypedElement input, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool Predicate(CompiledExpression evaluator, ITypedElement input, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool IsTrue(CompiledExpression evaluator, ITypedElement input, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool IsBoolean(CompiledExpression evaluator, bool value, ITypedElement input, EvaluationContext ctx);
}
public class Hl7.FhirPath.EvaluationContext : object {
    [CompilerGeneratedAttribute]
private ITypedElement <RootResource>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypedElement <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, IEnumerable`1<ITypedElement>> <Tracer>k__BackingField;
    [ObsoleteAttribute("Please use CreateDefault() instead of this member, which may cause raise conditions.")]
public static EvaluationContext Default;
    public ITypedElement RootResource { get; public set; }
    public ITypedElement Resource { get; public set; }
    public Action`2<string, IEnumerable`1<ITypedElement>> Tracer { get; public set; }
    public EvaluationContext(ITypedElement resource);
    public EvaluationContext(ITypedElement resource, ITypedElement rootResource);
    private static EvaluationContext();
    public static EvaluationContext CreateDefault();
    [CompilerGeneratedAttribute]
public ITypedElement get_RootResource();
    [CompilerGeneratedAttribute]
public void set_RootResource(ITypedElement value);
    [CompilerGeneratedAttribute]
public ITypedElement get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(ITypedElement value);
    [CompilerGeneratedAttribute]
public Action`2<string, IEnumerable`1<ITypedElement>> get_Tracer();
    [CompilerGeneratedAttribute]
public void set_Tracer(Action`2<string, IEnumerable`1<ITypedElement>> value);
}
public class Hl7.FhirPath.Expressions.AxisExpression : VariableRefExpression {
    public static AxisExpression Index;
    public static AxisExpression This;
    public static AxisExpression That;
    public string AxisName { get; }
    public AxisExpression(string axisName);
    private static AxisExpression();
    public string get_AxisName();
}
public class Hl7.FhirPath.Expressions.BinaryExpression : FunctionCallExpression {
    internal static string BIN_PREFIX;
    internal static int BIN_PREFIX_LEN;
    public string Op { get; }
    public Expression Left { get; }
    public Expression Right { get; }
    public BinaryExpression(char op, Expression left, Expression right);
    public BinaryExpression(string op, Expression left, Expression right);
    private static BinaryExpression();
    public string get_Op();
    public Expression get_Left();
    public Expression get_Right();
}
internal class Hl7.FhirPath.Expressions.CallSignature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ArgumentTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public string Name { get; private set; }
    public Type[] ArgumentTypes { get; private set; }
    public Type ReturnType { get; private set; }
    public CallSignature(string name, Type returnType, Type[] argTypes);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
private void set_ArgumentTypes(Type[] value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
    public bool DynamicMatches(string functionName, IEnumerable`1<object> arguments);
    public bool DynamicExactMatches(string functionName, IEnumerable`1<object> arguments);
    public bool Matches(string functionName, int argCount);
}
public class Hl7.FhirPath.Expressions.ChildExpression : FunctionCallExpression {
    public string ChildName { get; }
    public ChildExpression(Expression focus, string name);
    public string get_ChildName();
}
internal class Hl7.FhirPath.Expressions.Closure : object {
    [CompilerGeneratedAttribute]
private EvaluationContext <EvaluationContext>k__BackingField;
    private Dictionary`2<string, IEnumerable`1<ITypedElement>> _namedValues;
    [CompilerGeneratedAttribute]
private Closure <Parent>k__BackingField;
    public EvaluationContext EvaluationContext { get; private set; }
    public Closure Parent { get; private set; }
    [CompilerGeneratedAttribute]
public EvaluationContext get_EvaluationContext();
    [CompilerGeneratedAttribute]
private void set_EvaluationContext(EvaluationContext value);
    public static Closure Root(ITypedElement root, EvaluationContext ctx);
    public virtual void SetValue(string name, IEnumerable`1<ITypedElement> value);
    [CompilerGeneratedAttribute]
public Closure get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(Closure value);
    public virtual Closure Nest();
    public virtual IEnumerable`1<ITypedElement> ResolveValue(string name);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Expressions.ClosureExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetThis(Closure ctx);
    [ExtensionAttribute]
public static void SetThis(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetTotal(Closure ctx);
    [ExtensionAttribute]
public static void SetTotal(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetThat(Closure ctx);
    [ExtensionAttribute]
public static void SetThat(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static void SetOriginalContext(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static void SetResource(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static void SetRootResource(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetOriginalContext(Closure ctx);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetResource(Closure ctx);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetRootResource(Closure ctx);
    [ExtensionAttribute]
public static Closure Nest(Closure ctx, IEnumerable`1<ITypedElement> input);
    [ExtensionAttribute]
public static void SetIndex(Closure ctx, IEnumerable`1<ITypedElement> value);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> GetIndex(Closure ctx);
}
public class Hl7.FhirPath.Expressions.ConstantExpression : Expression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; private set; }
    public ConstantExpression(object value, TypeSpecifier type, ISourcePositionInfo location);
    public ConstantExpression(object value, ISourcePositionInfo location);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public virtual T Accept(ExpressionVisitor`1<T> visitor, SymbolTable scope);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Hl7.FhirPath.Expressions.DynaDispatcher : object {
    private string _name;
    private SymbolTable _scope;
    public DynaDispatcher(string name, SymbolTable scope);
    public IEnumerable`1<ITypedElement> Dispatcher(Closure context, IEnumerable`1<Invokee> args);
    private string noMatchError(IEnumerable`1<object> arguments);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Expressions.EvaluatorExpressionExtensions : object {
    [ExtensionAttribute]
public static Invokee ToEvaluator(Expression expr, SymbolTable scope);
}
internal class Hl7.FhirPath.Expressions.EvaluatorVisitor : ExpressionVisitor`1<Invokee> {
    public virtual Invokee VisitConstant(ConstantExpression expression, SymbolTable scope);
    public virtual Invokee VisitFunctionCall(FunctionCallExpression expression, SymbolTable scope);
    public virtual Invokee VisitNewNodeListInit(NewNodeListInitExpression expression, SymbolTable scope);
    public virtual Invokee VisitVariableRef(VariableRefExpression expression, SymbolTable scope);
    private static Invokee resolve(SymbolTable scope, string name, IEnumerable`1<Type> argumentTypes);
}
public abstract class Hl7.FhirPath.Expressions.Expression : object {
    internal static string OP_PREFIX;
    internal static int OP_PREFIX_LEN;
    [CompilerGeneratedAttribute]
private ISourcePositionInfo <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSpecifier <ExpressionType>k__BackingField;
    public ISourcePositionInfo Location { get; }
    public TypeSpecifier ExpressionType { get; protected set; }
    protected Expression(TypeSpecifier type);
    protected Expression(TypeSpecifier type, ISourcePositionInfo location);
    private static Expression();
    [CompilerGeneratedAttribute]
public ISourcePositionInfo get_Location();
    [CompilerGeneratedAttribute]
public TypeSpecifier get_ExpressionType();
    [CompilerGeneratedAttribute]
protected void set_ExpressionType(TypeSpecifier value);
    public abstract virtual T Accept(ExpressionVisitor`1<T> visitor, SymbolTable scope);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Expression other);
    public virtual int GetHashCode();
    public static bool op_Equality(Expression left, Expression right);
    public static bool op_Inequality(Expression left, Expression right);
}
public abstract class Hl7.FhirPath.Expressions.ExpressionVisitor`1 : object {
    public abstract virtual T VisitConstant(ConstantExpression expression, SymbolTable scope);
    public abstract virtual T VisitFunctionCall(FunctionCallExpression expression, SymbolTable scope);
    public abstract virtual T VisitNewNodeListInit(NewNodeListInitExpression expression, SymbolTable scope);
    public abstract virtual T VisitVariableRef(VariableRefExpression expression, SymbolTable scope);
}
public class Hl7.FhirPath.Expressions.FunctionCallExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Focus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FunctionName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Expression> <Arguments>k__BackingField;
    public Expression Focus { get; private set; }
    public string FunctionName { get; private set; }
    public IEnumerable`1<Expression> Arguments { get; private set; }
    public FunctionCallExpression(Expression focus, string name, TypeSpecifier type, Expression[] arguments);
    public FunctionCallExpression(Expression focus, string name, TypeSpecifier type, IEnumerable`1<Expression> arguments, ISourcePositionInfo location);
    [CompilerGeneratedAttribute]
public Expression get_Focus();
    [CompilerGeneratedAttribute]
private void set_Focus(Expression value);
    [CompilerGeneratedAttribute]
public string get_FunctionName();
    [CompilerGeneratedAttribute]
private void set_FunctionName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Expression> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IEnumerable`1<Expression> value);
    public virtual T Accept(ExpressionVisitor`1<T> visitor, SymbolTable scope);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Hl7.FhirPath.Expressions.IndexerExpression : FunctionCallExpression {
    public Expression Index { get; }
    public IndexerExpression(Expression collection, Expression index);
    public Expression get_Index();
}
internal class Hl7.FhirPath.Expressions.Invokee : MulticastDelegate {
    public Invokee(object object, IntPtr method);
    public virtual IEnumerable`1<ITypedElement> Invoke(Closure context, IEnumerable`1<Invokee> arguments);
    public virtual IAsyncResult BeginInvoke(Closure context, IEnumerable`1<Invokee> arguments, AsyncCallback callback, object object);
    public virtual IEnumerable`1<ITypedElement> EndInvoke(IAsyncResult result);
}
internal static class Hl7.FhirPath.Expressions.InvokeeFactory : object {
    public static IEnumerable`1<Invokee> EmptyArgs;
    private static InvokeeFactory();
    public static IEnumerable`1<ITypedElement> GetThis(Closure context, IEnumerable`1<Invokee> _);
    public static IEnumerable`1<ITypedElement> GetTotal(Closure context, IEnumerable`1<Invokee> _);
    public static IEnumerable`1<ITypedElement> GetContext(Closure context, IEnumerable`1<Invokee> _);
    public static IEnumerable`1<ITypedElement> GetResource(Closure context, IEnumerable`1<Invokee> _);
    public static IEnumerable`1<ITypedElement> GetRootResource(Closure context, IEnumerable`1<Invokee> arguments);
    public static IEnumerable`1<ITypedElement> GetThat(Closure context, IEnumerable`1<Invokee> _);
    public static IEnumerable`1<ITypedElement> GetIndex(Closure context, IEnumerable`1<Invokee> args);
    public static Invokee Wrap(Func`1<R> func);
    public static Invokee Wrap(Func`2<A, R> func, bool propNull);
    internal static Invokee WrapWithPropNullForFocus(Func`4<A, B, C, R> func);
    public static Invokee Wrap(Func`3<A, B, R> func, bool propNull);
    public static Invokee Wrap(Func`4<A, B, C, R> func, bool propNull);
    public static Invokee Wrap(Func`5<A, B, C, D, R> func, bool propNull);
    public static Invokee WrapLogic(Func`3<Func`1<Nullable`1<bool>>, Func`1<Nullable`1<bool>>, Nullable`1<bool>> func);
    public static Invokee Return(ITypedElement value);
    public static Invokee Return(IEnumerable`1<ITypedElement> value);
    public static Invokee Invoke(string functionName, IEnumerable`1<Invokee> arguments, Invokee invokee);
    [CompilerGeneratedAttribute]
internal static string <Invoke>g__formatFunctionName|17_1(string name);
}
public class Hl7.FhirPath.Expressions.NewNodeListInitExpression : Expression {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Expression> <Contents>k__BackingField;
    public static NewNodeListInitExpression Empty;
    public IEnumerable`1<Expression> Contents { get; private set; }
    public NewNodeListInitExpression(IEnumerable`1<Expression> contents);
    private static NewNodeListInitExpression();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Expression> get_Contents();
    [CompilerGeneratedAttribute]
private void set_Contents(IEnumerable`1<Expression> value);
    public virtual T Accept(ExpressionVisitor`1<T> visitor, SymbolTable scope);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Hl7.FhirPath.Expressions.SymbolTable : object {
    [CompilerGeneratedAttribute]
private SymbolTable <Parent>k__BackingField;
    private ConcurrentBag`1<TableEntry> _entries;
    public SymbolTable Parent { get; private set; }
    public SymbolTable(SymbolTable parent);
    public int Count();
    internal Invokee First();
    [CompilerGeneratedAttribute]
public SymbolTable get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(SymbolTable value);
    internal void Add(CallSignature signature, Invokee body);
    public SymbolTable Filter(string name, int argCount);
    internal Invokee DynamicGet(string name, IEnumerable`1<object> args);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Expressions.SymbolTableExtensions : object {
    [ExtensionAttribute]
public static void Add(SymbolTable table, string name, Func`1<R> func);
    [ExtensionAttribute]
public static void Add(SymbolTable table, string name, Func`2<A, R> func, bool doNullProp);
    [ExtensionAttribute]
public static void Add(SymbolTable table, string name, Func`3<A, B, R> func, bool doNullProp);
    [ExtensionAttribute]
public static void Add(SymbolTable table, string name, Func`4<A, B, C, R> func, bool doNullProp);
    [ExtensionAttribute]
public static void Add(SymbolTable table, string name, Func`5<A, B, C, D, R> func, bool doNullProp);
    [ExtensionAttribute]
public static void AddLogic(SymbolTable table, string name, Func`3<Func`1<Nullable`1<bool>>, Func`1<Nullable`1<bool>>, Nullable`1<bool>> func);
    [ExtensionAttribute]
public static void AddVar(SymbolTable table, string name, object value);
    [ExtensionAttribute]
public static void AddVar(SymbolTable table, string name, ITypedElement value);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Expressions.SymbolTableInit : object {
    [ExtensionAttribute]
public static SymbolTable AddStandardFP(SymbolTable t);
    private static string getCoreExtensionUrl(string id);
    private static string getCoreValueSetUrl(string id);
    private static IEnumerable`1<ITypedElement> runAggregate(Closure ctx, IEnumerable`1<Invokee> arguments);
    private static IEnumerable`1<ITypedElement> Trace(Closure ctx, IEnumerable`1<Invokee> arguments);
    private static IEnumerable`1<ITypedElement> runIif(Closure ctx, IEnumerable`1<Invokee> arguments);
    [IteratorStateMachineAttribute("Hl7.FhirPath.Expressions.SymbolTableInit/<runWhere>d__6")]
private static IEnumerable`1<ITypedElement> runWhere(Closure ctx, IEnumerable`1<Invokee> arguments);
    [IteratorStateMachineAttribute("Hl7.FhirPath.Expressions.SymbolTableInit/<runSelect>d__7")]
private static IEnumerable`1<ITypedElement> runSelect(Closure ctx, IEnumerable`1<Invokee> arguments);
    private static IEnumerable`1<ITypedElement> runRepeat(Closure ctx, IEnumerable`1<Invokee> arguments);
    private static IEnumerable`1<ITypedElement> runAll(Closure ctx, IEnumerable`1<Invokee> arguments);
    private static IEnumerable`1<ITypedElement> runAny(Closure ctx, IEnumerable`1<Invokee> arguments);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Expressions.TreeVisualizerExpressionExtensions : object {
    [ExtensionAttribute]
public static string Dump(Expression expr);
}
public class Hl7.FhirPath.Expressions.TreeVisualizerVisitor : ExpressionVisitor`1<StringBuilder> {
    private StringBuilder _result;
    private int _indent;
    public virtual StringBuilder VisitConstant(ConstantExpression expression, SymbolTable scope);
    public virtual StringBuilder VisitFunctionCall(FunctionCallExpression expression, SymbolTable scope);
    public virtual StringBuilder VisitNewNodeListInit(NewNodeListInitExpression expression, SymbolTable scope);
    public virtual StringBuilder VisitVariableRef(VariableRefExpression expression, SymbolTable scope);
    private void appendType(Expression expr);
    private void append(string text, bool newLine);
    private void incr();
    private void decr();
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Expressions.Typecasts : object {
    private static object id(object source);
    private static Cast makeNativeCast(Type to);
    private static ITypedElement any2primitiveTypedElement(object source);
    private static IEnumerable`1<ITypedElement> any2List(object source);
    private static Quantity tryQuantity(object source);
    internal static Quantity ParseQuantity(ITypedElement qe);
    private static Cast getImplicitCast(object f, Type to);
    internal static object UnboxTo(object instance, Type to);
    public static bool CanCastTo(object source, Type to);
    internal static bool IsOfExactType(object source, Type to);
    public static T CastTo(object source);
    public static object CastTo(object source, Type to);
    [ExtensionAttribute]
public static bool IsNullable(Type t);
    public static string ReadableFhirPathName(object value);
    public static string ReadableTypeName(Type t);
}
public class Hl7.FhirPath.Expressions.UnaryExpression : FunctionCallExpression {
    internal static string URY_PREFIX;
    internal static int URY_PREFIX_LEN;
    public string Op { get; }
    public Expression Operand { get; }
    public UnaryExpression(char op, Expression operand);
    public UnaryExpression(string op, Expression operand);
    private static UnaryExpression();
    public string get_Op();
    public Expression get_Operand();
}
public class Hl7.FhirPath.Expressions.VariableRefExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public VariableRefExpression(string name, ISourcePositionInfo location);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual T Accept(ExpressionVisitor`1<T> visitor, SymbolTable scope);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.FhirPath.Functions.MathOperators : object {
    [ExtensionAttribute]
public static Nullable`1<decimal> Sqrt(decimal focus);
    [ExtensionAttribute]
public static Nullable`1<decimal> Power(decimal focus, decimal exponent);
}
public class Hl7.FhirPath.FhirPathCompiler : object {
    private static Lazy`1<SymbolTable> _defaultSymbolTable;
    [CompilerGeneratedAttribute]
private SymbolTable <Symbols>k__BackingField;
    public static SymbolTable DefaultSymbolTable { get; }
    public SymbolTable Symbols { get; private set; }
    public FhirPathCompiler(SymbolTable symbols);
    private static FhirPathCompiler();
    public static void SetDefaultSymbolTable(Lazy`1<SymbolTable> st);
    public static SymbolTable get_DefaultSymbolTable();
    [CompilerGeneratedAttribute]
public SymbolTable get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(SymbolTable value);
    public Expression Parse(string expression);
    public CompiledExpression Compile(Expression expression);
    public CompiledExpression Compile(string expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Hl7.FhirPath.FhirPathCompilerCache : object {
    public static int DEFAULT_FP_EXPRESSION_CACHE_SIZE;
    private Cache`2<string, CompiledExpression> _cache;
    private FhirPathCompiler _compiler;
    private int _cacheSize;
    [NullableContextAttribute("2")]
public FhirPathCompilerCache(FhirPathCompiler compiler, int cacheSize);
    public void Clear();
    public CompiledExpression GetCompiledExpression(string expression);
    public IEnumerable`1<ITypedElement> Select(ITypedElement input, string expression, EvaluationContext ctx);
    public object Scalar(ITypedElement input, string expression, EvaluationContext ctx);
    public bool Predicate(ITypedElement input, string expression, EvaluationContext ctx);
    public bool IsTrue(ITypedElement input, string expression, EvaluationContext ctx);
    public bool IsBoolean(ITypedElement input, string expression, bool value, EvaluationContext ctx);
    [CompilerGeneratedAttribute]
private CompiledExpression <Clear>b__5_0(string expr);
    [CompilerGeneratedAttribute]
private CompiledExpression <Clear>g__compile|5_1(string expression);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.CollectionOperators : object {
    [ExtensionAttribute]
public static Nullable`1<bool> BooleanEval(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static bool Not(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> DistinctUnion(IEnumerable`1<ITypedElement> a, IEnumerable`1<ITypedElement> b);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Item(IEnumerable`1<ITypedElement> focus, int index);
    [ExtensionAttribute]
public static ITypedElement Last(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Tail(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<ITypedElement> focus, ITypedElement value);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Distinct(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static bool IsDistinct(IEnumerable`1<ITypedElement> focus);
    [ExtensionAttribute]
public static bool SubsetOf(IEnumerable`1<ITypedElement> focus, IEnumerable`1<ITypedElement> other);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Intersect(IEnumerable`1<ITypedElement> focus, IEnumerable`1<ITypedElement> other);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Exclude(IEnumerable`1<ITypedElement> focus, IEnumerable`1<ITypedElement> other);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Navigate(IEnumerable`1<ITypedElement> elements, string name);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Navigate(ITypedElement element, string name);
    [ExtensionAttribute]
public static string FpJoin(IEnumerable`1<ITypedElement> collection, string separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.ConversionOperators : object {
    [ExtensionAttribute]
public static Nullable`1<bool> ToBoolean(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToBoolean(Any focus);
    [ExtensionAttribute]
public static Nullable`1<int> ToInteger(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToInteger(Any focus);
    [ExtensionAttribute]
public static Nullable`1<decimal> ToDecimal(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToDecimal(Any focus);
    [ExtensionAttribute]
public static Nullable`1<long> ToLong(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToLong(Any focus);
    [ExtensionAttribute]
public static Quantity ToQuantity(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToQuantity(Any focus);
    [ExtensionAttribute]
public static string ToStringRepresentation(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToString(Any focus);
    [ExtensionAttribute]
public static Date ToDate(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToDate(Any focus);
    [ExtensionAttribute]
public static DateTime ToDateTime(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToDateTime(Any focus);
    [ExtensionAttribute]
public static Time ToTime(Any focus);
    [ExtensionAttribute]
public static bool ConvertsToTime(Any focus);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Hl7.FhirPath.Functions.EqualityOperators : object {
    public static IEqualityComparer`1<ITypedElement> TypedElementEqualityComparer;
    private static EqualityOperators();
    [ExtensionAttribute]
public static Nullable`1<bool> IsEqualTo(IEnumerable`1<ITypedElement> left, IEnumerable`1<ITypedElement> right, bool compareNames);
    [ExtensionAttribute]
public static Nullable`1<bool> IsEqualTo(ITypedElement left, ITypedElement right, bool compareNames);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> IsEqualTo(Any left, Any right);
    private static bool tryCoerce(Any& left, Any& right);
    [ExtensionAttribute]
public static bool IsEquivalentTo(IEnumerable`1<ITypedElement> left, IEnumerable`1<ITypedElement> right, bool compareNames);
    [ExtensionAttribute]
public static bool IsEquivalentTo(ITypedElement left, ITypedElement right, bool compareNames);
    [NullableContextAttribute("2")]
public static bool IsEquivalentTo(Any left, Any right);
    public static Nullable`1<bool> Compare(Any left, Any right, string op);
    [CompilerGeneratedAttribute]
internal static Any <tryCoerce>g__upcastOne|3_0(Any value, Any other);
    [CompilerGeneratedAttribute]
internal static bool <IsEquivalentTo>g__namesAreEquivalent|5_0(ITypedElement le, ITypedElement ri);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <Compare>g__interpret|7_0(Nullable`1<int> compareResult, <>c__DisplayClass7_0& );
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.StringOperators : object {
    [ExtensionAttribute]
public static string FpSubstring(string me, long start, Nullable`1<long> length);
    [ExtensionAttribute]
public static ITypedElement FpIndexOf(string me, string fragment);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> ToChars(string me);
    [ExtensionAttribute]
public static string FpReplace(string me, string find, string replace);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> FpSplit(string me, string seperator);
    [ExtensionAttribute]
public static string FpEncode(string me, string encoding);
    [ExtensionAttribute]
public static string FpDecode(string me, string encoding);
    internal static string EncodeBase64(string data);
    internal static string DecodeBase64(string data);
    internal static string EncodeUrlBase64(string data);
    internal static string DecodeUrlBase64(string data);
    internal static string EncodeHex(string data);
    internal static string DecodeHex(string data);
    [ExtensionAttribute]
public static string FpEscape(string data, string encoding);
    [ExtensionAttribute]
public static string FpUnescape(string data, string encoding);
    internal static string EscapeHtml(string data);
    internal static string UnescapeHtml(string data);
    internal static string EscapeJson(string data);
    internal static string UnescapeJson(string data);
    [IteratorStateMachineAttribute("Hl7.FhirPath.Functions.StringOperators/<<DecodeHex>g__hexStringToBytes|12_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<byte> <DecodeHex>g__hexStringToBytes|12_0(string data);
    [CompilerGeneratedAttribute]
internal static bool <EscapeJson>g__needEscape|17_0(string src, int i);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.ThreeValuedLogicExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<bool> And(Func`1<Nullable`1<bool>> left, Func`1<Nullable`1<bool>> right);
    [ExtensionAttribute]
public static Nullable`1<bool> And(Nullable`1<bool> left, Nullable`1<bool> right);
    [ExtensionAttribute]
public static Nullable`1<bool> Or(Func`1<Nullable`1<bool>> left, Func`1<Nullable`1<bool>> right);
    [ExtensionAttribute]
public static Nullable`1<bool> Or(Nullable`1<bool> left, Nullable`1<bool> right);
    [ExtensionAttribute]
public static Nullable`1<bool> XOr(Func`1<Nullable`1<bool>> left, Func`1<Nullable`1<bool>> right);
    [ExtensionAttribute]
public static Nullable`1<bool> XOr(Nullable`1<bool> left, Nullable`1<bool> right);
    [ExtensionAttribute]
public static Nullable`1<bool> Implies(Func`1<Nullable`1<bool>> left, Func`1<Nullable`1<bool>> right);
    [ExtensionAttribute]
public static Nullable`1<bool> Implies(Nullable`1<bool> left, Nullable`1<bool> right);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.TypeOperators : object {
    [ExtensionAttribute]
public static bool Is(ITypedElement focus, string type);
    public static bool Is(string instanceType, string declaredType);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> FilterType(IEnumerable`1<ITypedElement> focus, string typeName);
    [ExtensionAttribute]
public static ITypedElement CastAs(ITypedElement focus, string typeName);
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Functions.UtilityOperators : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Extension(IEnumerable`1<ITypedElement> focus, string url);
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Trace(IEnumerable`1<ITypedElement> focus, string name, EvaluationContext ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Hl7.FhirPath.IValueProviderFPExtensions : object {
    public static int MAX_FP_EXPRESSION_CACHE_SIZE;
    private static Lazy`1<FhirPathCompilerCache> CACHE;
    private static IValueProviderFPExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<ITypedElement> Select(ITypedElement input, string expression, EvaluationContext ctx);
    [ExtensionAttribute]
public static object Scalar(ITypedElement input, string expression, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool Predicate(ITypedElement input, string expression, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool IsTrue(ITypedElement input, string expression, EvaluationContext ctx);
    [ExtensionAttribute]
public static bool IsBoolean(ITypedElement input, string expression, bool value, EvaluationContext ctx);
    [NullableContextAttribute("2")]
internal static void ReInitializeCache(FhirPathCompiler compiler, Nullable`1<int> cacheSize);
}
internal class Hl7.FhirPath.Parser.Grammar : object {
    public static Parser`1<Quantity> Quantity;
    public static Parser`1<ConstantExpression> Literal;
    public static Parser`1<Expression> BracketExpr;
    public static Parser`1<Expression> EmptyList;
    public static Parser`1<Expression> Term;
    public static Parser`1<string> TypeSpec;
    public static Parser`1<Expression> InvocationExpression;
    public static Parser`1<Expression> PolarityExpression;
    public static Parser`1<Expression> MulExpression;
    public static Parser`1<Expression> AddExpression;
    public static Parser`1<Expression> UnionExpression;
    public static Parser`1<Expression> InEqExpression;
    public static Parser`1<Expression> TypeExpression;
    public static Parser`1<Expression> EqExpression;
    public static Parser`1<Expression> MembershipExpression;
    public static Parser`1<Expression> AndExpression;
    public static Parser`1<Expression> OrExpression;
    public static Parser`1<Expression> ImpliesExpression;
    public static Parser`1<Expression> Expression;
    private static Grammar();
    private static IResult`1<Quantity> quantityParser(IInput i);
    public static Parser`1<Expression> Function(Expression context);
    public static Parser`1<Expression> FunctionParameter(string name);
    public static Parser`1<Expression> FunctionInvocation(Expression focus);
    public static Expression BuildVariableRefExpression(string name);
    private static Parser`1<Expression> chainInvocation(Expression focus);
    public static Parser`1<Expression> Invocation(Expression focus);
    public static Parser`1<Expression> DotInvocation(Expression focus);
    public static Parser`1<Expression> IndexerInvocation(Expression focus);
    public static Parser`1<Expression> BinaryExpression(Parser`1<string> oper, Parser`1<Expression> operands);
}
internal class Hl7.FhirPath.Parser.Lexer : object {
    public static Parser`1<string> Id;
    public static Parser`1<string> Unicode;
    public static Parser`1<string> Escape;
    public static Parser`1<string> String;
    public static Parser`1<string> DelimitedIdentifier;
    public static Parser`1<string> Identifier;
    public static Parser`1<string> ExternalConstant;
    public static Regex DateRegEx;
    public static Parser`1<Date> Date;
    public static Regex DateTimeRegEx;
    public static Parser`1<DateTime> DateTime;
    private static string TIMEFORMAT;
    public static Regex TimeRegEx;
    public static Parser`1<Time> Time;
    public static Parser`1<int> IntegerNumber;
    public static Parser`1<decimal> DecimalNumber;
    public static Parser`1<bool> Bool;
    public static Parser`1<string> QualifiedIdentifier;
    public static Parser`1<string> Axis;
    public static Parser`1<string> Quantity;
    internal static Parser`1<string> PolarityOperator;
    internal static Parser`1<string> MulOperator;
    internal static Parser`1<string> AddOperator;
    internal static Parser`1<string> UnionOperator;
    internal static Parser`1<string> InEqOperator;
    internal static Parser`1<string> TypeOperator;
    internal static Parser`1<string> EqOperator;
    internal static Parser`1<string> MembershipOperator;
    internal static Parser`1<string> AndOperator;
    internal static Parser`1<string> OrOperator;
    internal static Parser`1<string> ImpliesOperator;
    private static Lexer();
    internal static Parser`1<string> DelimitedContents(char delimiter);
    internal static string CleanupDateTimeLiteral(string repr);
    internal static Parser`1<string> Operator(String[] ops);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Parser.ParserExtensions : object {
    [ExtensionAttribute]
public static Parser`1<string> Unescape(Parser`1<IEnumerable`1<char>> c);
    public static char Unescape(char c);
    [ExtensionAttribute]
public static Parser`1<string> Unescape(Parser`1<string> c);
    public static char Unescape(string unicodeHex);
}
internal abstract class Hl7.FhirPath.Sprache.AbstractOption`1 : object {
    public bool IsEmpty { get; }
    public bool IsDefined { get; }
    public abstract virtual bool get_IsEmpty();
    public sealed virtual bool get_IsDefined();
    public sealed virtual T GetOrDefault();
    public abstract virtual T Get();
}
public class Hl7.FhirPath.Sprache.CommentParser : object {
    [CompilerGeneratedAttribute]
private string <Single>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MultiOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MultiClose>k__BackingField;
    public string Single { get; public set; }
    public string NewLine { get; public set; }
    public string MultiOpen { get; public set; }
    public string MultiClose { get; public set; }
    public Parser`1<string> SingleLineComment { get; private set; }
    public Parser`1<string> MultiLineComment { get; private set; }
    public Parser`1<string> AnyComment { get; private set; }
    public CommentParser(string multiOpen, string multiClose, string newLine);
    public CommentParser(string single, string multiOpen, string multiClose, string newLine);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Single();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Single(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NewLine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NewLine(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MultiOpen();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MultiOpen(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MultiClose();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MultiClose(string value);
    public sealed virtual Parser`1<string> get_SingleLineComment();
    private void set_SingleLineComment(Parser`1<string> value);
    public sealed virtual Parser`1<string> get_MultiLineComment();
    private void set_MultiLineComment(Parser`1<string> value);
    public sealed virtual Parser`1<string> get_AnyComment();
    private void set_AnyComment(Parser`1<string> value);
    [CompilerGeneratedAttribute]
private Parser`1<string> <get_SingleLineComment>b__20_0(IEnumerable`1<char> first);
    [CompilerGeneratedAttribute]
private Parser`1<string> <get_MultiLineComment>b__23_0(IEnumerable`1<char> first);
}
internal interface Hl7.FhirPath.Sprache.IComment {
    public string Single { get; public set; }
    public string NewLine { get; public set; }
    public string MultiOpen { get; public set; }
    public string MultiClose { get; public set; }
    public Parser`1<string> SingleLineComment { get; }
    public Parser`1<string> MultiLineComment { get; }
    public Parser`1<string> AnyComment { get; }
    public abstract virtual string get_Single();
    public abstract virtual void set_Single(string value);
    public abstract virtual string get_NewLine();
    public abstract virtual void set_NewLine(string value);
    public abstract virtual string get_MultiOpen();
    public abstract virtual void set_MultiOpen(string value);
    public abstract virtual string get_MultiClose();
    public abstract virtual void set_MultiClose(string value);
    public abstract virtual Parser`1<string> get_SingleLineComment();
    public abstract virtual Parser`1<string> get_MultiLineComment();
    public abstract virtual Parser`1<string> get_AnyComment();
}
public interface Hl7.FhirPath.Sprache.IInput {
    public string Source { get; }
    public char Current { get; }
    public bool AtEnd { get; }
    public int Position { get; }
    public int Line { get; }
    public int Column { get; }
    public IDictionary`2<object, object> Memos { get; }
    public abstract virtual IInput Advance();
    public abstract virtual string get_Source();
    public abstract virtual char get_Current();
    public abstract virtual bool get_AtEnd();
    public abstract virtual int get_Position();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual IDictionary`2<object, object> get_Memos();
}
public class Hl7.FhirPath.Sprache.Input : object {
    private string _source;
    private int _position;
    private int _line;
    private int _column;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Memos>k__BackingField;
    public IDictionary`2<object, object> Memos { get; private set; }
    public string Source { get; }
    public char Current { get; }
    public bool AtEnd { get; }
    public int Position { get; }
    public int Line { get; }
    public int Column { get; }
    public Input(string source);
    internal Input(string source, int position, int line, int column);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Memos();
    [CompilerGeneratedAttribute]
private void set_Memos(IDictionary`2<object, object> value);
    public sealed virtual IInput Advance();
    public sealed virtual string get_Source();
    public sealed virtual char get_Current();
    public sealed virtual bool get_AtEnd();
    public sealed virtual int get_Position();
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IInput other);
    public static bool op_Equality(Input left, Input right);
    public static bool op_Inequality(Input left, Input right);
}
public interface Hl7.FhirPath.Sprache.IOption`1 {
    public bool IsEmpty { get; }
    public bool IsDefined { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsDefined();
    public abstract virtual T GetOrDefault();
    public abstract virtual T Get();
}
public interface Hl7.FhirPath.Sprache.IPositionAware`1 {
    public abstract virtual T SetPos(Position startPos, int length);
}
public interface Hl7.FhirPath.Sprache.IResult`1 {
    public T Value { get; }
    public bool WasSuccessful { get; }
    public string Message { get; }
    public IEnumerable`1<string> Expectations { get; }
    public IInput Remainder { get; }
    public abstract virtual T get_Value();
    public abstract virtual bool get_WasSuccessful();
    public abstract virtual string get_Message();
    public abstract virtual IEnumerable`1<string> get_Expectations();
    public abstract virtual IInput get_Remainder();
}
internal class Hl7.FhirPath.Sprache.None`1 : AbstractOption`1<T> {
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public virtual T Get();
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Sprache.OptionExtensions : object {
    [ExtensionAttribute]
public static T GetOrElse(IOption`1<T> option, T defaultValue);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Sprache.Parse : object {
    public static Parser`1<char> AnyChar;
    public static Parser`1<char> WhiteSpace;
    public static Parser`1<char> Digit;
    public static Parser`1<char> Letter;
    public static Parser`1<char> LetterOrDigit;
    public static Parser`1<char> Lower;
    public static Parser`1<char> Upper;
    public static Parser`1<char> Numeric;
    public static Parser`1<string> Number;
    public static Parser`1<string> Decimal;
    public static Parser`1<string> DecimalInvariant;
    public static Parser`1<string> LineEnd;
    public static Parser`1<string> LineTerminator;
    private static Parse();
    public static Parser`1<char> Char(Predicate`1<char> predicate, string description);
    public static Parser`1<char> CharExcept(Predicate`1<char> predicate, string description);
    public static Parser`1<char> Char(char c);
    public static Parser`1<char> Chars(Char[] c);
    public static Parser`1<char> Chars(string c);
    public static Parser`1<char> CharExcept(char c);
    public static Parser`1<char> CharExcept(IEnumerable`1<char> c);
    public static Parser`1<char> CharExcept(string c);
    public static Parser`1<char> IgnoreCase(char c);
    public static Parser`1<IEnumerable`1<char>> IgnoreCase(string s);
    public static Parser`1<IEnumerable`1<char>> String(string s);
    [ExtensionAttribute]
public static Parser`1<object> Not(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<U> Then(Parser`1<T> first, Func`2<T, Parser`1<U>> second);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Many(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> XMany(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> AtLeastOnce(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> XAtLeastOnce(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<T> End(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<U> Select(Parser`1<T> parser, Func`2<T, U> convert);
    [ExtensionAttribute]
public static Parser`1<T> Token(Parser`1<T> parser);
    public static Parser`1<T> Ref(Func`1<Parser`1<T>> reference);
    [ExtensionAttribute]
public static Parser`1<string> Text(Parser`1<IEnumerable`1<char>> characters);
    [ExtensionAttribute]
public static Parser`1<T> Or(Parser`1<T> first, Parser`1<T> second);
    [ExtensionAttribute]
public static Parser`1<T> Named(Parser`1<T> parser, string name);
    [ExtensionAttribute]
public static Parser`1<T> XOr(Parser`1<T> first, Parser`1<T> second);
    private static IResult`1<T> DetermineBestError(IResult`1<T> firstFailure, IResult`1<T> secondFailure);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Once(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Concat(Parser`1<IEnumerable`1<T>> first, Parser`1<IEnumerable`1<T>> second);
    public static Parser`1<T> Return(T value);
    [ExtensionAttribute]
public static Parser`1<U> Return(Parser`1<T> parser, U value);
    [ExtensionAttribute]
public static Parser`1<T> Except(Parser`1<T> parser, Parser`1<U> except);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Until(Parser`1<T> parser, Parser`1<U> until);
    [ExtensionAttribute]
public static Parser`1<T> Where(Parser`1<T> parser, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Parser`1<V> SelectMany(Parser`1<T> parser, Func`2<T, Parser`1<U>> selector, Func`3<T, U, V> projector);
    public static Parser`1<T> ChainOperator(Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`1<T> XChainOperator(Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`1<T> ChainOperatorRest(T firstOperand, Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`1<T>, Parser`1<T>, Parser`1<T>> or);
    public static Parser`1<T> ChainRightOperator(Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`1<T> XChainRightOperator(Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`1<T> ChainRightOperatorRest(T lastOperand, Parser`1<TOp> op, Parser`1<T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`1<T>, Parser`1<T>, Parser`1<T>> or);
    private static Parser`1<string> DecimalWithoutLeadingDigits(CultureInfo ci);
    private static Parser`1<string> DecimalWithLeadingDigits(CultureInfo ci);
    [ExtensionAttribute]
public static Parser`1<IOption`1<T>> Optional(Parser`1<T> parser);
    [ExtensionAttribute]
public static Parser`1<T> Positioned(Parser`1<T> parser);
    public static Parser`1<string> Identifier(Parser`1<char> firstLetterParser, Parser`1<char> tailLetterParser);
    public static Parser`1<string> Regex(string pattern, string description);
    public static Parser`1<string> Regex(Regex regex, string description);
    public static Parser`1<Match> RegexMatch(string pattern, string description);
    public static Parser`1<Match> RegexMatch(Regex regex, string description);
    private static Regex OptimizeRegex(Regex regex);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> DelimitedBy(Parser`1<T> parser, Parser`1<U> delimiter);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> XDelimitedBy(Parser`1<T> itemParser, Parser`1<U> delimiter);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Repeat(Parser`1<T> parser, int count);
    [ExtensionAttribute]
public static Parser`1<IEnumerable`1<T>> Repeat(Parser`1<T> parser, int minimumCount, int maximumCount);
    [ExtensionAttribute]
public static Parser`1<T> Contained(Parser`1<T> parser, Parser`1<U> open, Parser`1<V> close);
}
public class Hl7.FhirPath.Sprache.ParseException : Exception {
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
}
public class Hl7.FhirPath.Sprache.Parser`1 : MulticastDelegate {
    public Parser`1(object object, IntPtr method);
    public virtual IResult`1<T> Invoke(IInput input);
    public virtual IAsyncResult BeginInvoke(IInput input, AsyncCallback callback, object object);
    public virtual IResult`1<T> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Hl7.FhirPath.Sprache.ParserExtensions : object {
    [ExtensionAttribute]
public static IResult`1<T> TryParse(Parser`1<T> parser, string input);
    [ExtensionAttribute]
public static T Parse(Parser`1<T> parser, string input);
}
public class Hl7.FhirPath.Sprache.Position : object {
    [CompilerGeneratedAttribute]
private int <Pos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Pos { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public Position(int pos, int line, int column);
    public static Position FromInput(IInput input);
    [CompilerGeneratedAttribute]
public int get_Pos();
    [CompilerGeneratedAttribute]
private void set_Pos(int value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Position other);
    public static bool op_Equality(Position left, Position right);
    public static bool op_Inequality(Position left, Position right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Hl7.FhirPath.Sprache.Result : object {
    public static IResult`1<T> Success(T value, IInput remainder);
    public static IResult`1<T> Failure(IInput remainder, string message, IEnumerable`1<string> expectations);
}
internal class Hl7.FhirPath.Sprache.Result`1 : object {
    private T _value;
    private IInput _remainder;
    private bool _wasSuccessful;
    private string _message;
    private IEnumerable`1<string> _expectations;
    public T Value { get; }
    public bool WasSuccessful { get; }
    public string Message { get; }
    public IEnumerable`1<string> Expectations { get; }
    public IInput Remainder { get; }
    public Result`1(T value, IInput remainder);
    public Result`1(IInput remainder, string message, IEnumerable`1<string> expectations);
    public sealed virtual T get_Value();
    public sealed virtual bool get_WasSuccessful();
    public sealed virtual string get_Message();
    public sealed virtual IEnumerable`1<string> get_Expectations();
    public sealed virtual IInput get_Remainder();
    public virtual string ToString();
    private string CalculateRecentlyConsumed();
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Sprache.ResultHelper : object {
    [ExtensionAttribute]
public static IResult`1<U> IfSuccess(IResult`1<T> result, Func`2<IResult`1<T>, IResult`1<U>> next);
    [ExtensionAttribute]
public static IResult`1<T> IfFailure(IResult`1<T> result, Func`2<IResult`1<T>, IResult`1<T>> next);
}
internal class Hl7.FhirPath.Sprache.Some`1 : AbstractOption`1<T> {
    private T _value;
    public bool IsEmpty { get; }
    public Some`1(T value);
    public virtual bool get_IsEmpty();
    public virtual T Get();
}
[ExtensionAttribute]
internal static class Hl7.FhirPath.Sprache.StringExtensions : object {
    [IteratorStateMachineAttribute("Hl7.FhirPath.Sprache.StringExtensions/<ToEnumerable>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<char> ToEnumerable(string this);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
