public class HotChocolate.Stitching.ComputedDirective : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <DependantOn>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<string> DependantOn { get; }
    public ComputedDirective(IReadOnlyList`1<string> dependantOn);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_DependantOn();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.ComputedDirectiveType : DirectiveType`1<ComputedDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<ComputedDirective> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Stitching.ContextDataExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IRequestExecutor> GetRemoteExecutors(IHasContextData hasContextData);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IRequestExecutor> GetRemoteExecutors(ISchema schema);
    [ExtensionAttribute]
public static ISchemaBuilder AddRemoteExecutor(ISchemaBuilder schemaBuilder, string schemaName, IRequestExecutor executor);
    [ExtensionAttribute]
public static IReadOnlyList`1<MergeTypeRuleFactory> GetTypeMergeRules(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddTypeMergeRules(ISchemaBuilder schemaBuilder, MergeTypeRuleFactory mergeRuleFactory);
    [ExtensionAttribute]
public static IReadOnlyList`1<MergeDirectiveRuleFactory> GetDirectiveMergeRules(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddDirectiveMergeRules(ISchemaBuilder schemaBuilder, MergeDirectiveRuleFactory mergeRuleFactory);
    [ExtensionAttribute]
public static IReadOnlyList`1<ITypeRewriter> GetTypeRewriter(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddTypeRewriter(ISchemaBuilder schemaBuilder, ITypeRewriter rewriter);
    [ExtensionAttribute]
public static IReadOnlyList`1<IDocumentRewriter> GetDocumentRewriter(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddDocumentRewriter(ISchemaBuilder schemaBuilder, IDocumentRewriter rewriter);
    [ExtensionAttribute]
public static IReadOnlyList`1<DocumentNode> GetTypeExtensions(IDescriptorContext hasContextData, string name);
    [ExtensionAttribute]
public static ISchemaBuilder AddTypeExtensions(ISchemaBuilder schemaBuilder, DocumentNode document, string name);
    [ExtensionAttribute]
public static IReadOnlyList`1<Func`2<DocumentNode, DocumentNode>> GetMergedDocRewriter(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddMergedDocRewriter(ISchemaBuilder schemaBuilder, Func`2<DocumentNode, DocumentNode> rewrite);
    [ExtensionAttribute]
public static IReadOnlyList`1<Action`1<DocumentNode>> GetMergedDocVisitors(IDescriptorContext hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddMergedDocVisitor(ISchemaBuilder schemaBuilder, Action`1<DocumentNode> visit);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, ISet`1<string>> GetExternalFieldLookup(IHasContextData hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddExternalFieldLookup(ISchemaBuilder schemaBuilder, IReadOnlyDictionary`2<string, ISet`1<string>> externalFieldLookup);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<ValueTuple`2<string, string>, string> GetNameLookup(ISchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<ValueTuple`2<string, string>, string> GetNameLookup(IHasContextData hasContextData);
    [ExtensionAttribute]
public static ISchemaBuilder AddNameLookup(ISchemaBuilder schemaBuilder, IReadOnlyDictionary`2<ValueTuple`2<string, string>, string> nameLookup);
    [ExtensionAttribute]
public static ISchemaBuilder AddNameLookup(ISchemaBuilder schemaBuilder, string originalTypeName, string newTypeName, string schemaName);
    [ExtensionAttribute]
public static IReadOnlyList`1<RemoteSchemaDefinition> GetSchemaDefinitions(IReadOnlyDictionary`2<string, object> contextData);
    [ExtensionAttribute]
public static List`1<RemoteSchemaDefinition> GetOrAddSchemaDefinitions(IDescriptorContext descriptorContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.DelegateDirective : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [NullableAttribute("2")]
public string Path { get; }
    public string Schema { get; }
    public DelegateDirective(string path, string schema);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.DelegateDirectiveType : DirectiveType`1<DelegateDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<DelegateDirective> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Delegation.CollectUsedVariableVisitor : QuerySyntaxWalker`1<ISet`1<string>> {
    public void CollectUsedVariables(FieldNode fieldNode, ISet`1<string> usedVariables);
    public void CollectUsedVariables(IEnumerable`1<FragmentDefinitionNode> fragmentDefinitions, ISet`1<string> usedVariables);
    protected virtual void VisitVariable(VariableNode node, ISet`1<string> context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Delegation.DelegateToRemoteSchemaMiddleware : object {
    private static string _remoteErrorField;
    private static string _schemaNameErrorField;
    private static RootScopedVariableResolver _resolvers;
    private FieldDelegate _next;
    public DelegateToRemoteSchemaMiddleware(FieldDelegate next);
    private static DelegateToRemoteSchemaMiddleware();
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Delegation.DelegateToRemoteSchemaMiddleware/<InvokeAsync>d__5")]
public Task InvokeAsync(IMiddlewareContext context);
    private static void UpdateContextData(IResolverContext context, IQueryResult result, DelegateDirective delegateDirective);
    private static IQueryRequest CreateQuery(IMiddlewareContext context, string schemaName, IImmutableStack`1<SelectionPathComponent> path, IImmutableStack`1<SelectionPathComponent> reversePath);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Delegation.DelegateToRemoteSchemaMiddleware/<ExecuteQueryAsync>d__8")]
private static Task`1<IQueryResult> ExecuteQueryAsync(IResolverContext context, IQueryRequest request, string schemaName);
    private static object ExtractData(IReadOnlyDictionary`2<string, object> data, IImmutableStack`1<SelectionPathComponent> reversePath, string fieldName);
    private static void ReportErrors(string schemaName, IResolverContext context, IImmutableStack`1<SelectionPathComponent> fetchPath, IEnumerable`1<IError> errors);
    private static Path RewriteErrorPath(Path errorPath, Path fieldPath, IImmutableStack`1<SelectionPathComponent> fetchPath);
    private static bool IsHttpError(IError error);
    private static IReadOnlyCollection`1<ScopedVariableValue> CreateVariableValues(IMiddlewareContext context, string schemaName, IEnumerable`1<ScopedVariableValue> scopedVariables, ExtractedField extractedField, ExtractFieldQuerySyntaxRewriter rewriter);
    private static IReadOnlyList`1<ScopedVariableValue> ResolveScopedVariables(IResolverContext context, string schemaName, OperationType operationType, IImmutableStack`1<SelectionPathComponent> reversePath, ExtractFieldQuerySyntaxRewriter rewriter);
    private static IOutputField ResolveFieldFromComponent(IComplexOutputType type, SelectionPathComponent component);
    private static void ResolveScopedVariableArguments(IResolverContext context, string schemaName, SelectionPathComponent component, IOutputField field, ICollection`1<ScopedVariableValue> variables, ExtractFieldQuerySyntaxRewriter rewriter);
    [IteratorStateMachineAttribute("HotChocolate.Stitching.Delegation.DelegateToRemoteSchemaMiddleware/<ResolveUsedRequestVariables>d__17")]
private static IEnumerable`1<ScopedVariableValue> ResolveUsedRequestVariables(ISchema schema, string schemaName, ExtractedField extractedField, IVariableValueCollection requestVariables, ExtractFieldQuerySyntaxRewriter rewriter);
    private static void AddVariables(IQueryRequestBuilder builder, DocumentNode query, IEnumerable`1<ScopedVariableValue> variableValues);
    private static IReadOnlyList`1<VariableDefinitionNode> CreateVariableDefs(IReadOnlyCollection`1<ScopedVariableValue> variableValues);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.Delegation.DictionaryDeserializer : object {
    public static object DeserializeResult(IType fieldType, object obj, InputParser parser, Path path);
    private static object DeserializeEnumResult(IInputType inputType, object value, InputParser parser, Path path);
    private static object DeserializeScalarResult(IInputType inputType, object value, InputParser parser, Path path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Delegation.DictionaryResultMiddleware : object {
    private FieldDelegate _next;
    public DictionaryResultMiddleware(FieldDelegate next);
    public ValueTask InvokeAsync(IMiddlewareContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Delegation.ExtractedField : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FieldNode> <SyntaxNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<VariableDefinitionNode> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FragmentDefinitionNode> <Fragments>k__BackingField;
    public IReadOnlyList`1<FieldNode> SyntaxNodes { get; }
    public IReadOnlyList`1<VariableDefinitionNode> Variables { get; }
    public IReadOnlyList`1<FragmentDefinitionNode> Fragments { get; }
    public ExtractedField(IReadOnlyList`1<FieldNode> syntaxNodes, IReadOnlyList`1<VariableDefinitionNode> variables, IReadOnlyList`1<FragmentDefinitionNode> fragments);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FieldNode> get_SyntaxNodes();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<VariableDefinitionNode> get_Variables();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FragmentDefinitionNode> get_Fragments();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.Delegation.ExtractFieldQuerySyntaxRewriter : SyntaxRewriter`1<Context> {
    private ISchema _schema;
    private FieldDependencyResolver _dependencyResolver;
    private IQueryDelegationRewriter[] _rewriters;
    public ExtractFieldQuerySyntaxRewriter(ISchema schema, IEnumerable`1<IQueryDelegationRewriter> rewriters);
    public ExtractedField ExtractField(string sourceSchema, DocumentNode document, OperationDefinitionNode operation, ISelection selection, INamedOutputType declaringType);
    public IValueNode RewriteValueNode(string sourceSchema, IInputType inputType, IValueNode value);
    protected virtual FieldNode RewriteField(FieldNode node, Context context);
    private FieldNode OnRewriteField(FieldNode node, Context context);
    protected virtual SelectionSetNode RewriteSelectionSet(SelectionSetNode node, Context context);
    protected virtual DirectiveNode RewriteDirective(DirectiveNode node, Context context);
    private SelectionSetNode OnRewriteSelectionSet(SelectionSetNode node, Context context);
    protected virtual ArgumentNode RewriteArgument(ArgumentNode node, Context context);
    protected virtual ObjectFieldNode RewriteObjectField(ObjectFieldNode node, Context context);
    private static void RemoveDelegationFields(SelectionSetNode node, Context context, ICollection`1<ISelectionNode> selections);
    private static bool IsDelegationField(IDirectiveCollection directives);
    private static void AddDependencies(IHasName typeContext, List`1<ISelectionNode> selections, IEnumerable`1<FieldDependency> dependencies);
    private static FieldNode CreateField(string fieldName);
    protected virtual VariableNode RewriteVariable(VariableNode node, Context context);
    protected virtual FragmentSpreadNode RewriteFragmentSpread(FragmentSpreadNode node, Context context);
    protected virtual FragmentDefinitionNode RewriteFragmentDefinition(FragmentDefinitionNode node, Context context);
    protected virtual InlineFragmentNode RewriteInlineFragment(InlineFragmentNode node, Context context);
}
internal static class HotChocolate.Stitching.Delegation.RemoteFieldHelper : object {
    [NullableContextAttribute("1")]
public static object RemoteFieldResolver(IPureResolverContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Delegation.RemoteQueryBuilder : object {
    private static CollectUsedVariableVisitor _usedVariables;
    private List`1<FieldNode> _additionalFields;
    private List`1<VariableDefinitionNode> _variables;
    private List`1<FragmentDefinitionNode> _fragments;
    private NameNode _operationName;
    private OperationType _operation;
    private IImmutableStack`1<SelectionPathComponent> _path;
    [NullableAttribute("2")]
private FieldNode _requestField;
    private static RemoteQueryBuilder();
    public RemoteQueryBuilder SetOperation(NameNode name, OperationType operation);
    public RemoteQueryBuilder SetSelectionPath(IImmutableStack`1<SelectionPathComponent> selectionPath);
    public RemoteQueryBuilder SetRequestField(FieldNode field);
    public RemoteQueryBuilder AddAdditionalField(FieldNode field);
    public RemoteQueryBuilder AddVariable(string name, ITypeNode type);
    public RemoteQueryBuilder AddVariable(string name, ITypeNode type, IValueNode defaultValue);
    public RemoteQueryBuilder AddVariable(VariableDefinitionNode variable);
    public RemoteQueryBuilder AddVariables(IEnumerable`1<VariableDefinitionNode> variables);
    public RemoteQueryBuilder AddFragmentDefinitions(IEnumerable`1<FragmentDefinitionNode> fragments);
    public DocumentNode Build(string targetSchema, IReadOnlyDictionary`2<ValueTuple`2<string, string>, string> nameLookup);
    private DocumentNode CreateDelegationQuery(string targetSchema, IReadOnlyDictionary`2<ValueTuple`2<string, string>, string> nameLookup, OperationType operation, IImmutableStack`1<SelectionPathComponent> path, IEnumerable`1<FieldNode> requestedFields);
    private static ITypeNode RewriteType(ITypeNode type, string typeName);
    private static FieldNode CreateRequestedField(FieldNode requestedField, IImmutableStack`1& path);
    private static FieldNode CreateSelection(FieldNode previous, SelectionPathComponent next);
    private static FieldNode CreateSelection(SelectionSetNode selectionSet, SelectionPathComponent next, string alias);
    private static OperationDefinitionNode CreateOperation(NameNode name, OperationType operation, IReadOnlyList`1<FieldNode> fields, IReadOnlyList`1<VariableDefinitionNode> variables);
    [IteratorStateMachineAttribute("HotChocolate.Stitching.Delegation.RemoteQueryBuilder/<RewriteVariableNames>d__24")]
private static IEnumerable`1<ArgumentNode> RewriteVariableNames(IEnumerable`1<ArgumentNode> arguments);
    public static RemoteQueryBuilder New();
}
internal class HotChocolate.Stitching.Delegation.ScopedVariables.ArgumentScopedVariableResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
internal class HotChocolate.Stitching.Delegation.ScopedVariables.ContextDataScopedVariableResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
internal class HotChocolate.Stitching.Delegation.ScopedVariables.FieldScopedVariableResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
[NullableContextAttribute("1")]
internal interface HotChocolate.Stitching.Delegation.ScopedVariables.IScopedVariableResolver {
    public abstract virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
internal class HotChocolate.Stitching.Delegation.ScopedVariables.RootScopedVariableResolver : object {
    [NullableAttribute("1")]
private Dictionary`2<string, IScopedVariableResolver> _resolvers;
    [NullableContextAttribute("1")]
public sealed virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
internal class HotChocolate.Stitching.Delegation.ScopedVariables.ScopedContextDataScopedVariableResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual ScopedVariableValue Resolve(IResolverContext context, ScopedVariableNode variable, IInputType targetType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class HotChocolate.Stitching.Delegation.ScopedVariables.ScopedVariableValue : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeNode <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IValueNode <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IValueNode <DefaultValue>k__BackingField;
    public string Name { get; }
    public ITypeNode Type { get; }
    [NullableAttribute("2")]
public IValueNode Value { get; }
    [NullableAttribute("2")]
public IValueNode DefaultValue { get; }
    internal ScopedVariableValue(string name, ITypeNode type, IValueNode value, IValueNode defaultValue);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ITypeNode get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IValueNode get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IValueNode get_DefaultValue();
    public ScopedVariableValue WithValue(IValueNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Stitching.Delegation.ScopedVariables.ScopeNames : object {
    [CompilerGeneratedAttribute]
private static string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ScopedContextData>k__BackingField;
    public static string Arguments { get; }
    public static string Fields { get; }
    public static string ContextData { get; }
    public static string ScopedContextData { get; }
    private static ScopeNames();
    [CompilerGeneratedAttribute]
public static string get_Arguments();
    [CompilerGeneratedAttribute]
public static string get_Fields();
    [CompilerGeneratedAttribute]
public static string get_ContextData();
    [CompilerGeneratedAttribute]
public static string get_ScopedContextData();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Delegation.SerializedData : object {
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public object Data { get; }
    public SerializedData(object data);
    [CompilerGeneratedAttribute]
public object get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.DirectiveFieldNames : object {
    public static string Source_Schema;
    public static string Source_Name;
    public static string Delegate_Schema;
    public static string Delegate_Path;
    public static string Computed_DependantOn;
    public static string RemoveType_TypeName;
    public static string RenameType_TypeName;
    public static string RenameType_NewTypeName;
    public static string RenameField_TypeName;
    public static string RenameField_FieldName;
    public static string RenameField_NewFieldName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.DirectiveNames : object {
    public static string Delegate;
    public static string Computed;
    public static string Source;
    public static string RemoveRootTypes;
    public static string RemoveType;
    public static string RenameType;
    public static string RenameField;
}
public static class HotChocolate.Stitching.ErrorHelper : object {
    [NullableContextAttribute("1")]
public static IError HttpRequestClient_HttpError(HttpStatusCode statusCode, string responseBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Stitching.HasDirectiveExtensions : object {
    [ExtensionAttribute]
public static bool TryGetSourceDirective(IHasDirectives hasDirectives, string schemaName, SourceDirective& sourceDirective);
    [ExtensionAttribute]
public static bool TryGetSourceName(IHasDirectives hasDirectives, string schemaName, String& sourceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.Merge.AddSchemaExtensionRewriter : SyntaxRewriter`1<MergeContext> {
    private Dictionary`2<string, DirectiveDefinitionNode> _globalDirectives;
    public AddSchemaExtensionRewriter(IEnumerable`1<DirectiveDefinitionNode> globalDirectives);
    public DocumentNode AddExtensions(DocumentNode schema, DocumentNode extensions);
    private static DocumentNode RemoveDirectives(DocumentNode document, IEnumerable`1<string> directiveNames);
    private static DocumentNode RemoveTypes(DocumentNode document, IEnumerable`1<string> directiveNames);
    private static DocumentNode RemoveDefinitions(DocumentNode document, Func`2<DocumentNode, Dictionary`2<string, IDefinitionNode>> toDict, IEnumerable`1<string> names);
    protected virtual UnionTypeDefinitionNode RewriteUnionTypeDefinition(UnionTypeDefinitionNode node, MergeContext context);
    private static UnionTypeDefinitionNode AddTypes(UnionTypeDefinitionNode typeDefinition, UnionTypeExtensionNode typeExtension);
    protected virtual ObjectTypeDefinitionNode RewriteObjectTypeDefinition(ObjectTypeDefinitionNode node, MergeContext context);
    private static ObjectTypeDefinitionNode AddFields(ObjectTypeDefinitionNode typeDefinition, ObjectTypeExtensionNode typeExtension);
    private static ObjectTypeDefinitionNode AddInterfaces(ObjectTypeDefinitionNode typeDefinition, ObjectTypeExtensionNode typeExtension);
    protected virtual InterfaceTypeDefinitionNode RewriteInterfaceTypeDefinition(InterfaceTypeDefinitionNode node, MergeContext context);
    private static InterfaceTypeDefinitionNode AddFields(InterfaceTypeDefinitionNode typeDefinition, InterfaceTypeExtensionNode typeExtension);
    private static IReadOnlyList`1<FieldDefinitionNode> AddFields(IReadOnlyList`1<FieldDefinitionNode> typeDefinitionFields, IReadOnlyList`1<FieldDefinitionNode> typeExtensionFields);
    protected virtual InputObjectTypeDefinitionNode RewriteInputObjectTypeDefinition(InputObjectTypeDefinitionNode node, MergeContext context);
    private static InputObjectTypeDefinitionNode AddInputFields(InputObjectTypeDefinitionNode typeDefinition, InputObjectTypeExtensionNode typeExtension);
    protected virtual EnumTypeDefinitionNode RewriteEnumTypeDefinition(EnumTypeDefinitionNode node, MergeContext context);
    private static EnumTypeDefinitionNode AddEnumValues(EnumTypeDefinitionNode typeDefinition, EnumTypeExtensionNode typeExtension);
    protected virtual ScalarTypeDefinitionNode RewriteScalarTypeDefinition(ScalarTypeDefinitionNode node, MergeContext context);
    private TDefinition AddDirectives(TDefinition typeDefinition, TExtension typeExtension, Func`2<IReadOnlyList`1<DirectiveNode>, TDefinition> withDirectives, MergeContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Merge.DirectiveTypeInfo : object {
    [CompilerGeneratedAttribute]
private DirectiveDefinitionNode <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ISchemaInfo <Schema>k__BackingField;
    public DirectiveDefinitionNode Definition { get; }
    public ISchemaInfo Schema { get; }
    public DirectiveTypeInfo(DirectiveDefinitionNode definition, ISchemaInfo schema);
    [CompilerGeneratedAttribute]
public sealed virtual DirectiveDefinitionNode get_Definition();
    [CompilerGeneratedAttribute]
public sealed virtual ISchemaInfo get_Schema();
}
[ExtensionAttribute]
internal static class HotChocolate.Stitching.Merge.EnumerableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IReadOnlyList`1<ITypeInfo> NotOfType(IEnumerable`1<ITypeInfo> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.EnumTypeInfo : TypeInfo`1<EnumTypeDefinitionNode> {
    public EnumTypeInfo(EnumTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Stitching.Merge.Handlers.ComplexTypeMergeHelpers : object {
    [ExtensionAttribute]
public static bool CanBeMergedWith(InterfaceTypeInfo left, InterfaceTypeInfo right);
    [ExtensionAttribute]
public static bool CanBeMergedWith(ObjectTypeInfo left, ObjectTypeInfo right);
    private static bool CanBeMerged(ComplexTypeDefinitionNodeBase left, ComplexTypeDefinitionNodeBase right);
    private static bool HasSameShape(FieldDefinitionNode left, FieldDefinitionNode right);
    public static bool HasSameArguments(IReadOnlyList`1<InputValueDefinitionNode> left, IReadOnlyList`1<InputValueDefinitionNode> right);
    private static bool HasSameType(ITypeNode left, ITypeNode right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Handlers.DirectiveTypeMergeHandler : object {
    private MergeDirectiveRuleDelegate _next;
    public DirectiveTypeMergeHandler(MergeDirectiveRuleDelegate next);
    public void Merge(ISchemaMergeContext context, IReadOnlyList`1<IDirectiveTypeInfo> types);
    private void MergeNextType(ISchemaMergeContext context, List`1<IDirectiveTypeInfo> notMerged);
    protected void MergeTypes(ISchemaMergeContext context, IReadOnlyList`1<IDirectiveTypeInfo> types, string newTypeName);
    private static bool CanBeMerged(DirectiveDefinitionNode left, DirectiveDefinitionNode right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Handlers.EnumTypeMergeHandler : object {
    private MergeTypeRuleDelegate _next;
    public EnumTypeMergeHandler(MergeTypeRuleDelegate next);
    public sealed virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
    private static void MergeNextType(ISchemaMergeContext context, List`1<EnumTypeInfo> notMerged);
    private static void MergeType(ISchemaMergeContext context, IReadOnlyList`1<EnumTypeInfo> types);
    internal static bool CanBeMerged(EnumTypeDefinitionNode left, EnumTypeDefinitionNode right);
    private static bool CanBeMerged(ICollection`1<string> left, EnumTypeDefinitionNodeBase right);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.Handlers.InputObjectTypeMergeHandler : TypeMergeHandlerBase`1<InputObjectTypeInfo> {
    public InputObjectTypeMergeHandler(MergeTypeRuleDelegate next);
    protected virtual void MergeTypes(ISchemaMergeContext context, IReadOnlyList`1<InputObjectTypeInfo> types, string newTypeName);
    protected virtual bool CanBeMerged(InputObjectTypeInfo left, InputObjectTypeInfo right);
    private static bool CanHandleFieldTypes(TypePair typePair, ICollection`1<string> fieldTypes, ISet`1<string> processed, Queue`1<TypePair> queue);
    private static bool TryEnqueueFieldType(TypePair typePair, string typeName, Queue`1<TypePair> queue);
    private static bool TryEnqueueForAnalysis(ITypeInfo left, ITypeInfo right, Queue`1<TypePair> queue);
    private static MergeStatus GetMergeStatus(ITypeDefinitionNode leftType, ITypeDefinitionNode rightType);
    private static bool CanBeMerged(InputObjectTypeDefinitionNode left, InputObjectTypeDefinitionNode right, ICollection`1<string> typesToAnalyze);
    private static bool HasSameType(ITypeNode left, ITypeNode right, ICollection`1<string> typesToAnalyze);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.Handlers.InterfaceTypeMergeHandler : TypeMergeHandlerBase`1<InterfaceTypeInfo> {
    public InterfaceTypeMergeHandler(MergeTypeRuleDelegate next);
    protected virtual void MergeTypes(ISchemaMergeContext context, IReadOnlyList`1<InterfaceTypeInfo> types, string newTypeName);
    protected virtual bool CanBeMerged(InterfaceTypeInfo left, InterfaceTypeInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.Handlers.ObjectTypeMergeHandler : TypeMergeHandlerBase`1<ObjectTypeInfo> {
    public ObjectTypeMergeHandler(MergeTypeRuleDelegate next);
    protected virtual void MergeTypes(ISchemaMergeContext context, IReadOnlyList`1<ObjectTypeInfo> types, string newTypeName);
    protected virtual bool CanBeMerged(ObjectTypeInfo left, ObjectTypeInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Handlers.RootTypeMergeHandler : object {
    private MergeTypeRuleDelegate _next;
    public RootTypeMergeHandler(MergeTypeRuleDelegate next);
    public sealed virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
    private static void IntegrateFields(ObjectTypeDefinitionNode rootType, ITypeInfo typeInfo, ISet`1<string> names, ICollection`1<FieldDefinitionNode> fields);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Handlers.ScalarTypeMergeHandler : object {
    private MergeTypeRuleDelegate _next;
    public ScalarTypeMergeHandler(MergeTypeRuleDelegate next);
    public sealed virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Stitching.Merge.Handlers.TypeMergeHandlerBase`1 : object {
    private MergeTypeRuleDelegate _next;
    protected TypeMergeHandlerBase`1(MergeTypeRuleDelegate next);
    public sealed virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
    private void MergeNextType(ISchemaMergeContext context, List`1<T> notMerged);
    protected abstract virtual bool CanBeMerged(T left, T right);
    protected abstract virtual void MergeTypes(ISchemaMergeContext context, IReadOnlyList`1<T> types, string newTypeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Stitching.Merge.Handlers.TypeMergeHelpers : object {
    private static int _maxRetries;
    public static string CreateName(ISchemaMergeContext context, T[] types);
    public static string CreateName(ISchemaMergeContext context, IReadOnlyList`1<T> types);
    [ExtensionAttribute]
public static string CreateUniqueName(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static string CreateUniqueName(ITypeInfo typeInfo, NamedSyntaxNode namedSyntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Handlers.UnionTypeMergeHandler : object {
    private MergeTypeRuleDelegate _next;
    public UnionTypeMergeHandler(MergeTypeRuleDelegate next);
    public sealed virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.IDirectiveMergeHandler {
    public abstract virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<IDirectiveTypeInfo> directives);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.IDirectiveTypeInfo {
    public DirectiveDefinitionNode Definition { get; }
    public ISchemaInfo Schema { get; }
    public abstract virtual DirectiveDefinitionNode get_Definition();
    public abstract virtual ISchemaInfo get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.InputObjectTypeInfo : TypeInfo`1<InputObjectTypeDefinitionNode> {
    public InputObjectTypeInfo(InputObjectTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.InterfaceTypeInfo : TypeInfo`1<InterfaceTypeDefinitionNode> {
    public InterfaceTypeInfo(InterfaceTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ISchemaInfo {
    public string Name { get; }
    public DocumentNode Document { get; }
    public IReadOnlyDictionary`2<string, ITypeDefinitionNode> Types { get; }
    public IReadOnlyDictionary`2<string, DirectiveDefinitionNode> Directives { get; }
    public ObjectTypeDefinitionNode QueryType { get; }
    [NullableAttribute("2")]
public ObjectTypeDefinitionNode MutationType { get; }
    [NullableAttribute("2")]
public ObjectTypeDefinitionNode SubscriptionType { get; }
    public abstract virtual string get_Name();
    public abstract virtual DocumentNode get_Document();
    public abstract virtual IReadOnlyDictionary`2<string, ITypeDefinitionNode> get_Types();
    public abstract virtual IReadOnlyDictionary`2<string, DirectiveDefinitionNode> get_Directives();
    public abstract virtual ObjectTypeDefinitionNode get_QueryType();
    [NullableContextAttribute("2")]
public abstract virtual ObjectTypeDefinitionNode get_MutationType();
    [NullableContextAttribute("2")]
public abstract virtual ObjectTypeDefinitionNode get_SubscriptionType();
    public abstract virtual bool IsRootType(ITypeDefinitionNode typeDefinition);
    public abstract virtual bool TryGetOperationType(ObjectTypeDefinitionNode rootType, OperationType& operationType);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ISchemaMergeContext {
    public abstract virtual void AddType(ITypeDefinitionNode type);
    public abstract virtual void AddDirective(DirectiveDefinitionNode directive);
    public abstract virtual bool ContainsType(string typeName);
    public abstract virtual bool ContainsDirective(string directiveName);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ISchemaMerger {
    public abstract virtual ISchemaMerger AddSchema(string name, DocumentNode schema);
    [ObsoleteAttribute("Use AddTypeMergeRule")]
public abstract virtual ISchemaMerger AddMergeRule(MergeTypeRuleFactory factory);
    public abstract virtual ISchemaMerger AddTypeMergeRule(MergeTypeRuleFactory factory);
    public abstract virtual ISchemaMerger AddDirectiveMergeRule(MergeDirectiveRuleFactory factory);
    public abstract virtual ISchemaMerger AddTypeRewriter(ITypeRewriter rewriter);
    public abstract virtual ISchemaMerger AddDocumentRewriter(IDocumentRewriter rewriter);
    public abstract virtual DocumentNode Merge();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ITypeInfo {
    public ITypeDefinitionNode Definition { get; }
    public ISchemaInfo Schema { get; }
    public bool IsRootType { get; }
    public abstract virtual ITypeDefinitionNode get_Definition();
    public abstract virtual ISchemaInfo get_Schema();
    public abstract virtual bool get_IsRootType();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ITypeInfo`1 {
    public T Definition { get; }
    public abstract virtual T get_Definition();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.ITypeMergeHandler {
    public abstract virtual void Merge(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
}
public class HotChocolate.Stitching.Merge.MergeDirectiveRuleDelegate : MulticastDelegate {
    public MergeDirectiveRuleDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ISchemaMergeContext context, IReadOnlyList`1<IDirectiveTypeInfo> types);
    public virtual IAsyncResult BeginInvoke(ISchemaMergeContext context, IReadOnlyList`1<IDirectiveTypeInfo> types, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Stitching.Merge.MergeDirectiveRuleFactory : MulticastDelegate {
    public MergeDirectiveRuleFactory(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual MergeDirectiveRuleDelegate Invoke(MergeDirectiveRuleDelegate next);
    public virtual IAsyncResult BeginInvoke(MergeDirectiveRuleDelegate next, AsyncCallback callback, object object);
    public virtual MergeDirectiveRuleDelegate EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Stitching.Merge.MergeSyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static T Rename(T enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static T Rename(T typeDefinitionNode, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static FieldDefinitionNode Rename(FieldDefinitionNode enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static FieldDefinitionNode Rename(FieldDefinitionNode enumTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static InputValueDefinitionNode Rename(InputValueDefinitionNode enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static InputValueDefinitionNode Rename(InputValueDefinitionNode enumTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static ScalarTypeDefinitionNode Rename(ScalarTypeDefinitionNode enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static ScalarTypeDefinitionNode Rename(ScalarTypeDefinitionNode enumTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static DirectiveDefinitionNode Rename(DirectiveDefinitionNode directiveDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static DirectiveDefinitionNode Rename(DirectiveDefinitionNode directiveDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static EnumTypeDefinitionNode Rename(EnumTypeDefinitionNode enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static EnumTypeDefinitionNode Rename(EnumTypeDefinitionNode enumTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static InputObjectTypeDefinitionNode Rename(InputObjectTypeDefinitionNode enumTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static InputObjectTypeDefinitionNode Rename(InputObjectTypeDefinitionNode enumTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static UnionTypeDefinitionNode Rename(UnionTypeDefinitionNode unionTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static UnionTypeDefinitionNode Rename(UnionTypeDefinitionNode unionTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static ObjectTypeDefinitionNode Rename(ObjectTypeDefinitionNode objectTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static ObjectTypeDefinitionNode Rename(ObjectTypeDefinitionNode objectTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    [ExtensionAttribute]
public static InterfaceTypeDefinitionNode Rename(InterfaceTypeDefinitionNode interfaceTypeDefinition, string newName, String[] schemaNames);
    [ExtensionAttribute]
public static InterfaceTypeDefinitionNode Rename(InterfaceTypeDefinitionNode interfaceTypeDefinition, string newName, IEnumerable`1<string> schemaNames);
    private static T AddSource(T interfaceTypeDefinition, string newName, IEnumerable`1<string> schemaNames, Func`3<NameNode, IReadOnlyList`1<DirectiveNode>, T> rewrite);
    private static IReadOnlyList`1<DirectiveNode> AddRenamedDirective(IEnumerable`1<DirectiveNode> directives, string originalName, IEnumerable`1<string> schemaNames);
    private static bool HasSourceDirective(DirectiveNode directive, string schemaName);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, bool overwrite);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, SelectionPathComponent selectionPath);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, SelectionPathComponent selectionPath, bool overwrite);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, IReadOnlyCollection`1<SelectionPathComponent> selectionPath);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, IReadOnlyCollection`1<SelectionPathComponent> selectionPath, bool overwrite);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, string delegationPath);
    [ExtensionAttribute]
public static FieldDefinitionNode AddDelegationPath(FieldDefinitionNode field, string schemaName, string delegationPath, bool overwrite);
    [ExtensionAttribute]
public static string GetOriginalName(INamedSyntaxNode typeDefinition, string schemaName);
    [ExtensionAttribute]
public static bool IsFromSchema(INamedSyntaxNode typeDefinition, string schemaName);
}
public class HotChocolate.Stitching.Merge.MergeTypeRuleDelegate : MulticastDelegate {
    public MergeTypeRuleDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types);
    public virtual IAsyncResult BeginInvoke(ISchemaMergeContext context, IReadOnlyList`1<ITypeInfo> types, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Stitching.Merge.MergeTypeRuleFactory : MulticastDelegate {
    public MergeTypeRuleFactory(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual MergeTypeRuleDelegate Invoke(MergeTypeRuleDelegate next);
    public virtual IAsyncResult BeginInvoke(MergeTypeRuleDelegate next, AsyncCallback callback, object object);
    public virtual MergeTypeRuleDelegate EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.ObjectTypeInfo : TypeInfo`1<ObjectTypeDefinitionNode> {
    public ObjectTypeInfo(ObjectTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.DelegateDocumentRewriter : object {
    private RewriteDocumentDelegate _rewrite;
    public DelegateDocumentRewriter(RewriteDocumentDelegate rewrite);
    public sealed virtual DocumentNode Rewrite(ISchemaInfo schema, DocumentNode document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.DelegateTypeRewriter : object {
    private RewriteTypeDefinitionDelegate _rewrite;
    public DelegateTypeRewriter(RewriteTypeDefinitionDelegate rewrite);
    public sealed virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.Rewriters.IDocumentRewriter {
    public abstract virtual DocumentNode Rewrite(ISchemaInfo schema, DocumentNode document);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Merge.Rewriters.ITypeRewriter {
    public abstract virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RemoveFieldRewriter : object {
    [CompilerGeneratedAttribute]
private FieldReference <Field>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public FieldReference Field { get; }
    [NullableAttribute("2")]
public string SchemaName { get; }
    public RemoveFieldRewriter(FieldReference field, string schemaName);
    [CompilerGeneratedAttribute]
public FieldReference get_Field();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    public sealed virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
    private T RemoveFields(T typeDefinition, RewriteFieldsDelegate`1<T> rewrite);
    private InputObjectTypeDefinitionNode RemoveFields(InputObjectTypeDefinitionNode typeDefinition);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RemoveRootTypeRewriter : object {
    [CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public string SchemaName { get; }
    public RemoveRootTypeRewriter(string schemaName);
    [CompilerGeneratedAttribute]
public string get_SchemaName();
    [NullableContextAttribute("1")]
public sealed virtual DocumentNode Rewrite(ISchemaInfo schema, DocumentNode document);
    [NullableContextAttribute("1")]
private static void RemoveType(ICollection`1<IDefinitionNode> definitions, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RemoveTypeRewriter : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public string TypeName { get; }
    [NullableAttribute("2")]
public string SchemaName { get; }
    public RemoveTypeRewriter(string typeName, string schemaName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    public sealed virtual DocumentNode Rewrite(ISchemaInfo schema, DocumentNode document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RenameFieldArgumentRewriter : object {
    [CompilerGeneratedAttribute]
private FieldReference <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewArgumentName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public FieldReference Field { get; }
    public string ArgumentName { get; }
    public string NewArgumentName { get; }
    [NullableAttribute("2")]
public string SchemaName { get; }
    public RenameFieldArgumentRewriter(FieldReference field, string argumentName, string newArgumentName, string schemaName);
    [CompilerGeneratedAttribute]
public FieldReference get_Field();
    [CompilerGeneratedAttribute]
public string get_ArgumentName();
    [CompilerGeneratedAttribute]
public string get_NewArgumentName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    public sealed virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
    private T SelectField(T typeDefinition, string schemaName, RewriteFieldsDelegate`1<T> rewrite);
    private FieldDefinitionNode RewriteArgument(string schemaName, FieldDefinitionNode field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RenameFieldRewriter : object {
    [CompilerGeneratedAttribute]
private FieldReference <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFieldName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public FieldReference Field { get; }
    public string NewFieldName { get; }
    [NullableAttribute("2")]
public string SchemaName { get; }
    public RenameFieldRewriter(FieldReference field, string newFieldName, string schemaName);
    [CompilerGeneratedAttribute]
public FieldReference get_Field();
    [CompilerGeneratedAttribute]
public string get_NewFieldName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    public sealed virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
    private T RenameFields(T typeDefinition, string schemaName, RewriteFieldsDelegate`1<T> rewrite);
    private InputObjectTypeDefinitionNode RenameFields(InputObjectTypeDefinitionNode typeDefinition, string schemaName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.Rewriters.RenameTypeRewriter : object {
    [CompilerGeneratedAttribute]
private string <OriginalTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewTypeName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    public string OriginalTypeName { get; }
    public string NewTypeName { get; }
    [NullableAttribute("2")]
public string SchemaName { get; }
    public RenameTypeRewriter(string originalTypeName, string newTypeName, string schemaName);
    [CompilerGeneratedAttribute]
public string get_OriginalTypeName();
    [CompilerGeneratedAttribute]
public string get_NewTypeName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    public sealed virtual ITypeDefinitionNode Rewrite(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
}
public class HotChocolate.Stitching.Merge.Rewriters.RewriteDocumentDelegate : MulticastDelegate {
    public RewriteDocumentDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual DocumentNode Invoke(ISchemaInfo schema, DocumentNode document);
    public virtual IAsyncResult BeginInvoke(ISchemaInfo schema, DocumentNode document, AsyncCallback callback, object object);
    public virtual DocumentNode EndInvoke(IAsyncResult result);
}
internal class HotChocolate.Stitching.Merge.Rewriters.RewriteFieldsDelegate`1 : MulticastDelegate {
    public RewriteFieldsDelegate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke(IReadOnlyList`1<FieldDefinitionNode> fields);
    public virtual IAsyncResult BeginInvoke(IReadOnlyList`1<FieldDefinitionNode> fields, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class HotChocolate.Stitching.Merge.Rewriters.RewriteTypeDefinitionDelegate : MulticastDelegate {
    public RewriteTypeDefinitionDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ITypeDefinitionNode Invoke(ISchemaInfo schema, ITypeDefinitionNode typeDefinition);
    public virtual IAsyncResult BeginInvoke(ISchemaInfo schema, ITypeDefinitionNode typeDefinition, AsyncCallback callback, object object);
    public virtual ITypeDefinitionNode EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.ScalarTypeInfo : TypeInfo`1<ScalarTypeDefinitionNode> {
    public ScalarTypeInfo(ScalarTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.SchemaInfo : object {
    private static Dictionary`2<OperationType, string> _names;
    private ObjectTypeDefinitionNode _queryType;
    private ObjectTypeDefinitionNode _mutationType;
    private ObjectTypeDefinitionNode _subscriptionType;
    [CompilerGeneratedAttribute]
private Dictionary`2<OperationType, ObjectTypeDefinitionNode> <RootTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentNode <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ITypeDefinitionNode> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, DirectiveDefinitionNode> <Directives>k__BackingField;
    protected Dictionary`2<OperationType, ObjectTypeDefinitionNode> RootTypes { get; }
    public string Name { get; }
    public DocumentNode Document { get; }
    public IReadOnlyDictionary`2<string, ITypeDefinitionNode> Types { get; }
    public IReadOnlyDictionary`2<string, DirectiveDefinitionNode> Directives { get; }
    public ObjectTypeDefinitionNode QueryType { get; }
    public ObjectTypeDefinitionNode MutationType { get; }
    public ObjectTypeDefinitionNode SubscriptionType { get; }
    public SchemaInfo(string name, DocumentNode document);
    private static SchemaInfo();
    [CompilerGeneratedAttribute]
protected Dictionary`2<OperationType, ObjectTypeDefinitionNode> get_RootTypes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual DocumentNode get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, ITypeDefinitionNode> get_Types();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, DirectiveDefinitionNode> get_Directives();
    public sealed virtual ObjectTypeDefinitionNode get_QueryType();
    public sealed virtual ObjectTypeDefinitionNode get_MutationType();
    public sealed virtual ObjectTypeDefinitionNode get_SubscriptionType();
    public sealed virtual bool IsRootType(ITypeDefinitionNode typeDefinition);
    public sealed virtual bool TryGetOperationType(ObjectTypeDefinitionNode rootType, OperationType& operationType);
    private static Dictionary`2<OperationType, ObjectTypeDefinitionNode> GetRootTypeMapppings(IDictionary`2<OperationType, string> nameMappings, IDictionary`2<string, ITypeDefinitionNode> types);
    private static IDictionary`2<OperationType, string> GetRootTypeNameMapppings(SchemaDefinitionNodeBase schemaDefinition);
}
[ExtensionAttribute]
internal static class HotChocolate.Stitching.Merge.SchemaInfoExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ObjectTypeDefinitionNode GetRootType(ISchemaInfo schema, OperationType operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Merge.SchemaMergeContext : object {
    private Dictionary`2<string, ITypeDefinitionNode> _types;
    private Dictionary`2<string, DirectiveDefinitionNode> _dirs;
    public sealed virtual void AddType(ITypeDefinitionNode type);
    public sealed virtual void AddDirective(DirectiveDefinitionNode directive);
    public sealed virtual bool ContainsType(string typeName);
    public sealed virtual bool ContainsDirective(string directiveName);
    public DocumentNode CreateSchema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Merge.SchemaMergeException : Exception {
    [CompilerGeneratedAttribute]
private ITypeDefinitionNode <TypeDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeExtensionNode <TypeExtension>k__BackingField;
    public ITypeDefinitionNode TypeDefinition { get; }
    public ITypeExtensionNode TypeExtension { get; }
    public SchemaMergeException(ITypeDefinitionNode typeDefinition, ITypeExtensionNode typeExtension, string message);
    [CompilerGeneratedAttribute]
public ITypeDefinitionNode get_TypeDefinition();
    [CompilerGeneratedAttribute]
public ITypeExtensionNode get_TypeExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Merge.SchemaMerger : object {
    private static List`1<MergeTypeRuleFactory> _defaultMergeRules;
    private List`1<MergeTypeRuleFactory> _mergeRules;
    private List`1<MergeDirectiveRuleFactory> _directiveMergeRules;
    private List`1<ITypeRewriter> _typeRewriters;
    private List`1<IDocumentRewriter> _docRewriters;
    private OrderedDictionary`2<string, DocumentNode> _schemas;
    private static SchemaMerger();
    [ObsoleteAttribute("Use AddTypeMergeRule")]
public sealed virtual ISchemaMerger AddMergeRule(MergeTypeRuleFactory factory);
    public sealed virtual ISchemaMerger AddTypeMergeRule(MergeTypeRuleFactory factory);
    public sealed virtual ISchemaMerger AddDirectiveMergeRule(MergeDirectiveRuleFactory factory);
    public sealed virtual ISchemaMerger AddSchema(string name, DocumentNode schema);
    public sealed virtual ISchemaMerger AddTypeRewriter(ITypeRewriter rewriter);
    public sealed virtual ISchemaMerger AddDocumentRewriter(IDocumentRewriter rewriter);
    public sealed virtual DocumentNode Merge();
    private IReadOnlyList`1<ISchemaInfo> CreateSchemaInfos();
    private static DocumentNode PrepareSchemaDocument(DocumentNode document, string schemaName);
    private static bool IsIntrospectionType(ITypeDefinitionNode typeDefinition);
    private DocumentNode RewriteDocument(ISchemaInfo schema, DocumentNode document);
    private DocumentNode RewriteTypes(ISchemaInfo schema, DocumentNode document);
    private static DocumentNode RewriteTypeReferences(IReadOnlyList`1<ISchemaInfo> schemas, DocumentNode document);
    private static void MergeRootType(ISchemaMergeContext context, OperationType operation, IEnumerable`1<ISchemaInfo> schemas, MergeTypeRuleDelegate merge);
    private void MergeTypes(ISchemaMergeContext context, ISet`1<string> typeNames, IReadOnlyCollection`1<ISchemaInfo> schemas, MergeTypeRuleDelegate merge);
    private static ISet`1<string> CreateTypesNameSet(IReadOnlyCollection`1<ISchemaInfo> schemas);
    private static ISet`1<string> CreateDirectivesNameSet(IReadOnlyCollection`1<ISchemaInfo> schemas);
    private void MergeDirectives(ISchemaMergeContext context, ISet`1<string> typeNames, IReadOnlyCollection`1<ISchemaInfo> schemas, MergeDirectiveRuleDelegate merge);
    private static void SetTypes(string name, IReadOnlyCollection`1<ISchemaInfo> schemas, ICollection`1<ITypeInfo> types);
    private static void SetDirectives(string name, IReadOnlyCollection`1<ISchemaInfo> schemas, ICollection`1<IDirectiveTypeInfo> directives);
    private MergeTypeRuleDelegate CompileMergeTypeDelegate();
    private MergeDirectiveRuleDelegate CompileMergeDirectiveDelegate();
    public static SchemaMerger New();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Stitching.Merge.SchemaMergerExtensions : object {
    [ExtensionAttribute]
public static ISchemaMerger IgnoreRootTypes(ISchemaMerger schemaMerger, string schemaName);
    [ExtensionAttribute]
public static ISchemaMerger IgnoreType(ISchemaMerger schemaMerger, string typeName, string schemaName);
    [ExtensionAttribute]
public static ISchemaMerger IgnoreField(ISchemaMerger schemaMerger, FieldReference field, string schemaName);
    [ExtensionAttribute]
public static ISchemaMerger RenameType(ISchemaMerger schemaMerger, string originalTypeName, string newTypeName, string schemaName);
    [ExtensionAttribute]
public static ISchemaMerger RenameField(ISchemaMerger schemaMerger, FieldReference field, string newFieldName, string schemaName);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddTypeMergeHandler")]
public static ISchemaMerger AddMergeHandler(ISchemaMerger merger);
    [ExtensionAttribute]
public static ISchemaMerger AddTypeMergeHandler(ISchemaMerger merger);
    [ExtensionAttribute]
public static ISchemaMerger AddDirectiveMergeHandler(ISchemaMerger merger);
    internal static MergeTypeRuleFactory CreateTypeMergeRule();
    internal static MergeDirectiveRuleFactory CreateDirectiveMergeRule();
    private static ConstructorInfo CreateHandlerInternal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.TypeInfo : object {
    [CompilerGeneratedAttribute]
private ITypeDefinitionNode <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ISchemaInfo <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRootType>k__BackingField;
    public ITypeDefinitionNode Definition { get; }
    public ISchemaInfo Schema { get; }
    public bool IsRootType { get; }
    protected TypeInfo(ITypeDefinitionNode typeDefinition, ISchemaInfo schema);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeDefinitionNode get_Definition();
    [CompilerGeneratedAttribute]
public sealed virtual ISchemaInfo get_Schema();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRootType();
    public static ITypeInfo Create(ITypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Merge.TypeInfo`1 : TypeInfo {
    [CompilerGeneratedAttribute]
private T <Definition>k__BackingField;
    public T Definition { get; }
    protected TypeInfo`1(T typeDefinition, ISchemaInfo schema);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Definition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Stitching.Merge.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsQueryType(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsMutationType(ITypeInfo typeInfo);
    [ExtensionAttribute]
public static bool IsSubscriptionType(ITypeInfo typeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.TypeReferenceRewriter : SyntaxRewriter`1<Context> {
    public DocumentNode RewriteSchema(DocumentNode document, string schemaName);
    private static Dictionary`2<string, string> GetRenamedTypes(DocumentNode document, string schemaName);
    private static Dictionary`2<FieldDefinitionNode, string> GetFieldsToRename(DocumentNode document, string schemaName);
    private static void RenameObjectField(ObjectTypeDefinitionNode objectType, RenameFieldsContext renameContext);
    private static IReadOnlyCollection`1<InterfaceTypeDefinitionNode> GetInterfaceTypes(ObjectTypeDefinitionNode objectType, IDictionary`2<string, ComplexTypeDefinitionNodeBase> types);
    private static IReadOnlyCollection`1<InterfaceTypeDefinitionNode> GetInterfacesThatProvideFieldDefinition(string originalFieldName, IEnumerable`1<InterfaceTypeDefinitionNode> interfaceTypes);
    private static void RenameInterfaceField(InterfaceTypeDefinitionNode interfaceType, RenameFieldsContext renameContext);
    private static void RenameInterfaceField(InterfaceTypeDefinitionNode interfaceType, RenameFieldsContext renameContext, string originalFieldName, string newFieldName);
    private static void AddNewFieldName(ComplexTypeDefinitionNodeBase type, RenameFieldsContext renameContext, string originalFieldName, string newFieldName);
    protected virtual ObjectTypeDefinitionNode RewriteObjectTypeDefinition(ObjectTypeDefinitionNode node, Context context);
    protected virtual InterfaceTypeDefinitionNode RewriteInterfaceTypeDefinition(InterfaceTypeDefinitionNode node, Context context);
    protected virtual UnionTypeDefinitionNode RewriteUnionTypeDefinition(UnionTypeDefinitionNode node, Context context);
    protected virtual InputObjectTypeDefinitionNode RewriteInputObjectTypeDefinition(InputObjectTypeDefinitionNode node, Context context);
    protected virtual NamedTypeNode RewriteNamedType(NamedTypeNode node, Context context);
    protected virtual FieldDefinitionNode RewriteFieldDefinition(FieldDefinitionNode node, Context context);
    private static bool IsRelevant(NamedSyntaxNode typeDefinition, Context context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Merge.UnionTypeInfo : TypeInfo`1<UnionTypeDefinitionNode> {
    public UnionTypeInfo(UnionTypeDefinitionNode typeDefinition, ISchemaInfo schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Pipeline.HttpRequestClient : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<string, string> _contentType;
    private static JsonWriterOptions _jsonWriterOptions;
    private IHttpClientFactory _clientFactory;
    private IErrorHandler _errorHandler;
    private IHttpStitchingRequestInterceptor _requestInterceptor;
    public HttpRequestClient(IHttpClientFactory clientFactory, IErrorHandler errorHandler, IHttpStitchingRequestInterceptor requestInterceptor);
    private static HttpRequestClient();
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<FetchAsync>d__6")]
public Task`1<IQueryResult> FetchAsync(IQueryRequest request, string targetSchema, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<FetchAsync>d__7")]
private Task`1<IQueryResult> FetchAsync(IQueryRequest request, HttpRequestMessage requestMessage, string targetSchema, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<CreateRequestMessageAsync>d__8")]
internal static ValueTask`1<HttpRequestMessage> CreateRequestMessageAsync(ArrayWriter writer, IQueryRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<ParseErrorResponseMessageAsync>d__9")]
private static ValueTask`1<IQueryResult> ParseErrorResponseMessageAsync(HttpResponseMessage responseMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<ParseResponseMessageAsync>d__10")]
internal static ValueTask`1<IQueryResult> ParseResponseMessageAsync(HttpResponseMessage responseMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestClient/<CreateRequestAsync>d__11")]
private ValueTask`1<HttpRequestMessage> CreateRequestAsync(ArrayWriter writer, IQueryRequest request, string targetSchema, CancellationToken cancellationToken);
    private static IReadOnlyDictionary`2<string, object> ParseResponse(Byte[] buffer, int bytesBuffered);
    private static void WriteJsonRequest(ArrayWriter writer, Utf8JsonWriter jsonWriter, IQueryRequest request);
    private static void WriteJsonRequestVariables(ArrayWriter writer, Utf8JsonWriter jsonWriter, IReadOnlyDictionary`2<string, object> variables);
    private static void WriteValue(ArrayWriter writer, Utf8JsonWriter jsonWriter, object value);
    private static void WriterNumber(ReadOnlySpan`1<byte> number, Utf8JsonWriter jsonWriter, ArrayWriter arrayWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Pipeline.HttpRequestMiddleware : object {
    private RequestDelegate _next;
    private HttpRequestClient _httpRequestClient;
    public HttpRequestMiddleware(RequestDelegate next, HttpRequestClient httpRequestClient);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Pipeline.HttpRequestMiddleware/<InvokeAsync>d__3")]
public ValueTask InvokeAsync(IRequestContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.Pipeline.HttpResponseDeserializer : object {
    private static string _data;
    private static string _extensions;
    private static string _errors;
    public static IQueryResult Deserialize(IReadOnlyDictionary`2<string, object> serializedResult);
    private static void DeserializeErrors(IQueryResultBuilder result, IReadOnlyDictionary`2<string, object> serializedResult);
    [NullableContextAttribute("2")]
private static object DeserializeErrorValue(object value);
    private static Dictionary`2<string, object> DeserializeErrorObject(object obj);
    private static Dictionary`2<string, object> DeserializeErrorObject(IReadOnlyDictionary`2<string, object> obj);
    private static List`1<object> DeserializeErrorList(IReadOnlyList`1<object> list);
}
public class HotChocolate.Stitching.Pipeline.HttpStitchingRequestInterceptor : object {
    [NullableContextAttribute("1")]
public virtual ValueTask OnCreateRequestAsync(string targetSchema, IQueryRequest request, HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<IQueryResult> OnReceivedResultAsync(string targetSchema, IQueryRequest request, IQueryResult result, HttpResponseMessage responseMessage, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Pipeline.IHttpStitchingRequestInterceptor {
    public abstract virtual ValueTask OnCreateRequestAsync(string targetSchema, IQueryRequest request, HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<IQueryResult> OnReceivedResultAsync(string targetSchema, IQueryRequest request, IQueryResult result, HttpResponseMessage responseMessage, CancellationToken cancellationToken);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HotChocolate.Stitching.Properties.StitchingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddSchemaExtensionRewriter_DirectiveDoesNotExist { get; }
    internal static string AddSchemaExtensionRewriter_DirectiveIsUnique { get; }
    internal static string AddSchemaExtensionRewriter_TypeMismatch { get; }
    internal static string ArgumentScopedVariableResolver_CannotHandleVariable { get; }
    internal static string ArgumentScopedVariableResolver_InvalidArgumentName { get; }
    internal static string ComputedDirectiveType_Description { get; }
    internal static string ContextDataScopedVariableResolver_CannotHandleVariable { get; }
    internal static string DelegateDirectiveType_Description { get; }
    internal static string DelegateDirectiveType_Schema_FieldDescription { get; }
    internal static string DelegateDirectiveType_Path_FieldDescription { get; }
    internal static string DelegationMiddleware_ArgumentNotFound { get; }
    internal static string DelegationMiddleware_OnlyQueryResults { get; }
    internal static string DelegationMiddleware_PathElementInvalid { get; }
    internal static string DelegationMiddleware_PathElementTypeUnexpected { get; }
    internal static string ExtensionsFilePath_EmptyOrNull { get; }
    internal static string Extensions_EmptyOrNull { get; }
    internal static string FieldScopedVariableResolver_CannotHandleVariable { get; }
    internal static string FieldScopedVariableResolver_InvalidFieldName { get; }
    internal static string IntrospectionDeserializer_Json_NullOrEmpty { get; }
    internal static string MergeSyntaxNodeExtensions_NoSchema { get; }
    internal static string QueryRequestBuilder_OperationNameInvalid { get; }
    internal static string QueryRequestBuilder_OperationNameMissing { get; }
    internal static string QueryRequestBuilder_QueryIsNull { get; }
    internal static string RemoteExecutorBuilder_NoSchema { get; }
    internal static string RemoteExecutorBuilder_NoSchemaName { get; }
    internal static string RootScopedVariableResolver_ScopeNotSupported { get; }
    internal static string ScalarType_InvalidBaseType { get; }
    internal static string SchemaFilePath_EmptyOrNull { get; }
    internal static string SchemaMergerExtensions_NoValidConstructor { get; }
    internal static string SchemaName_EmptyOrNull { get; }
    internal static string SchemaName_NotFound { get; }
    internal static string Schema_EmptyOrNull { get; }
    internal static string ScopedCtxDataScopedVariableResolver_CannotHandleVariable { get; }
    internal static string SourceDirectiveType_Description { get; }
    internal static string SourceDirectiveType_Name_Description { get; }
    internal static string SourceDirectiveType_Schema_Description { get; }
    internal static string StitchingBuilder_SchemaNameInUse { get; }
    internal static string Type_NotSupported { get; }
    internal static string BufferedRequest_Create_QueryCannotBeNull { get; }
    internal static string ThrowHelper_BufferedRequest_VariableDoesNotExist { get; }
    internal static string ThrowHelper_BufferedRequest_OperationNotFound { get; }
    internal static string HttpRequestClient_UnknownVariableValueKind { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddSchemaExtensionRewriter_DirectiveDoesNotExist();
    internal static string get_AddSchemaExtensionRewriter_DirectiveIsUnique();
    internal static string get_AddSchemaExtensionRewriter_TypeMismatch();
    internal static string get_ArgumentScopedVariableResolver_CannotHandleVariable();
    internal static string get_ArgumentScopedVariableResolver_InvalidArgumentName();
    internal static string get_ComputedDirectiveType_Description();
    internal static string get_ContextDataScopedVariableResolver_CannotHandleVariable();
    internal static string get_DelegateDirectiveType_Description();
    internal static string get_DelegateDirectiveType_Schema_FieldDescription();
    internal static string get_DelegateDirectiveType_Path_FieldDescription();
    internal static string get_DelegationMiddleware_ArgumentNotFound();
    internal static string get_DelegationMiddleware_OnlyQueryResults();
    internal static string get_DelegationMiddleware_PathElementInvalid();
    internal static string get_DelegationMiddleware_PathElementTypeUnexpected();
    internal static string get_ExtensionsFilePath_EmptyOrNull();
    internal static string get_Extensions_EmptyOrNull();
    internal static string get_FieldScopedVariableResolver_CannotHandleVariable();
    internal static string get_FieldScopedVariableResolver_InvalidFieldName();
    internal static string get_IntrospectionDeserializer_Json_NullOrEmpty();
    internal static string get_MergeSyntaxNodeExtensions_NoSchema();
    internal static string get_QueryRequestBuilder_OperationNameInvalid();
    internal static string get_QueryRequestBuilder_OperationNameMissing();
    internal static string get_QueryRequestBuilder_QueryIsNull();
    internal static string get_RemoteExecutorBuilder_NoSchema();
    internal static string get_RemoteExecutorBuilder_NoSchemaName();
    internal static string get_RootScopedVariableResolver_ScopeNotSupported();
    internal static string get_ScalarType_InvalidBaseType();
    internal static string get_SchemaFilePath_EmptyOrNull();
    internal static string get_SchemaMergerExtensions_NoValidConstructor();
    internal static string get_SchemaName_EmptyOrNull();
    internal static string get_SchemaName_NotFound();
    internal static string get_Schema_EmptyOrNull();
    internal static string get_ScopedCtxDataScopedVariableResolver_CannotHandleVariable();
    internal static string get_SourceDirectiveType_Description();
    internal static string get_SourceDirectiveType_Name_Description();
    internal static string get_SourceDirectiveType_Schema_Description();
    internal static string get_StitchingBuilder_SchemaNameInUse();
    internal static string get_Type_NotSupported();
    internal static string get_BufferedRequest_Create_QueryCannotBeNull();
    internal static string get_ThrowHelper_BufferedRequest_VariableDoesNotExist();
    internal static string get_ThrowHelper_BufferedRequest_OperationNotFound();
    internal static string get_HttpRequestClient_UnknownVariableValueKind();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Requests.BufferedRequest : object {
    [CompilerGeneratedAttribute]
private IQueryRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentNode <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationDefinitionNode <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<IExecutionResult> <Promise>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Aliases>k__BackingField;
    public IQueryRequest Request { get; }
    public DocumentNode Document { get; }
    public OperationDefinitionNode Operation { get; }
    public TaskCompletionSource`1<IExecutionResult> Promise { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> Aliases { get; public set; }
    private BufferedRequest(IQueryRequest request, DocumentNode document, OperationDefinitionNode operation);
    [CompilerGeneratedAttribute]
public IQueryRequest get_Request();
    [CompilerGeneratedAttribute]
public DocumentNode get_Document();
    [CompilerGeneratedAttribute]
public OperationDefinitionNode get_Operation();
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<IExecutionResult> get_Promise();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Aliases();
    [CompilerGeneratedAttribute]
public void set_Aliases(IDictionary`2<string, string> value);
    public static BufferedRequest Create(IQueryRequest request, ISchema schema);
    internal static OperationDefinitionNode ResolveOperation(DocumentNode document, string operationName);
    private static IQueryRequest NormalizeRequest(IQueryRequest request, OperationDefinitionNode operation, ISchema schema);
    private static InputFormatter GetInputFormatter(ISchema schema);
    private static ITypeConverter GetTypeConverter(ISchema schema);
    private static IValueNode RewriteVariable(OperationDefinitionNode operation, string name, object value, ISchema schema, ITypeConverter converter, InputFormatter inputFormatter);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Requests.IRemoteRequestExecutor {
    public ISchema Schema { get; }
    public IServiceProvider Services { get; }
    public abstract virtual ISchema get_Schema();
    public abstract virtual IServiceProvider get_Services();
    public abstract virtual Task`1<IExecutionResult> ExecuteAsync(IQueryRequest request, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Requests.IStitchingContext {
    public abstract virtual IRemoteRequestExecutor GetRemoteRequestExecutor(string schemaName);
    public abstract virtual ISchema GetRemoteSchema(string schemaName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.Requests.MergeRequestHelper : object {
    [IteratorStateMachineAttribute("HotChocolate.Stitching.Requests.MergeRequestHelper/<MergeRequests>d__0")]
public static IEnumerable`1<ValueTuple`2<IQueryRequest, IEnumerable`1<BufferedRequest>>> MergeRequests(IEnumerable`1<BufferedRequest> requests);
    public static void DispatchResults(IQueryResult mergedResult, IEnumerable`1<BufferedRequest> requests);
    private static void MergeRequest(BufferedRequest bufferedRequest, MergeRequestRewriter rewriter, IDictionary`2<string, object> variableValues, string requestPrefix);
    private static void MergeVariables(IReadOnlyDictionary`2<string, object> original, IDictionary`2<string, object> merged, string requestPrefix);
    private static QueryResultBuilder ExtractResult(IDictionary`2<string, string> aliases, IQueryResult mergedResult, ICollection`1<IError> handledErrors);
    private static void ExtractData(IDictionary`2<string, string> aliases, IQueryResult mergedResult, QueryResultBuilder result);
    private static void ExtractErrors(IDictionary`2<string, string> aliases, IQueryResult mergedResult, ICollection`1<IError> handledErrors, QueryResultBuilder result);
    private static IError RewriteError(IError error, string responseName);
    private static bool TryResolveField(IError error, IDictionary`2<string, string> aliases, String& responseName);
    [NullableContextAttribute("2")]
private static Path GetRoot(Path path);
    private static Path ReplaceRoot(Path path, string responseName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Stitching.Requests.MergeRequestRewriter : SyntaxRewriter`1<Context> {
    private static NameNode _defaultName;
    private List`1<FieldNode> _fields;
    private Dictionary`2<string, VariableDefinitionNode> _variables;
    private Dictionary`2<string, FragmentDefinitionNode> _fragments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _aliases;
    private string _requestPrefix;
    private bool _rewriteFragments;
    private Nullable`1<OperationType> _operationType;
    [NullableAttribute("2")]
private NameNode _operationName;
    private static MergeRequestRewriter();
    public void SetOperationName(NameNode name);
    public IDictionary`2<string, string> AddQuery(BufferedRequest request, string requestPrefix, bool isAutoGenerated);
    public DocumentNode Merge();
    protected virtual VariableDefinitionNode RewriteVariableDefinition(VariableDefinitionNode node, Context context);
    protected virtual FieldNode RewriteField(FieldNode node, Context context);
    protected virtual FragmentSpreadNode RewriteFragmentSpread(FragmentSpreadNode node, Context context);
    protected virtual FragmentDefinitionNode RewriteFragmentDefinition(FragmentDefinitionNode node, Context context);
    protected virtual DirectiveNode RewriteDirective(DirectiveNode node, Context context);
    protected virtual VariableNode RewriteVariable(VariableNode node, Context context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Stitching.Requests.MergeUtils : object {
    [ExtensionAttribute]
public static NameNode CreateNewName(NameNode name, string requestName);
    [ExtensionAttribute]
public static string CreateNewName(string name, string requestName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Requests.RemoteRequestExecutor : object {
    private SemaphoreSlim _semaphore;
    private List`1<BufferedRequest> _bufferedRequests;
    private IBatchScheduler _batchScheduler;
    private IRequestExecutor _executor;
    private bool _taskRegistered;
    public ISchema Schema { get; }
    public IServiceProvider Services { get; }
    public RemoteRequestExecutor(IBatchScheduler batchScheduler, IRequestExecutor executor);
    public sealed virtual ISchema get_Schema();
    public sealed virtual IServiceProvider get_Services();
    public sealed virtual Task`1<IExecutionResult> ExecuteAsync(IQueryRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Requests.RemoteRequestExecutor/<ExecuteRequestsInternal>d__11")]
private ValueTask ExecuteRequestsInternal(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Requests.RemoteRequestExecutor/<ExecuteSingleRequestAsync>d__12")]
private ValueTask ExecuteSingleRequestAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Requests.RemoteRequestExecutor/<ExecuteBufferedRequestBatchAsync>d__13")]
private ValueTask ExecuteBufferedRequestBatchAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Requests.StitchingContext : object {
    private Dictionary`2<string, RemoteRequestExecutor> _executors;
    public StitchingContext(IBatchScheduler batchScheduler, IRequestContext requestContext);
    public sealed virtual IRemoteRequestExecutor GetRemoteRequestExecutor(string schemaName);
    public sealed virtual ISchema GetRemoteSchema(string schemaName);
}
public class HotChocolate.Stitching.Requests.StitchingContextEnricher : object {
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(IRequestContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Requests.StitchingContextParameterExpressionBuilder : CustomParameterExpressionBuilder {
    private Expression`1<Func`2<IResolverContext, IStitchingContext>> _expression;
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
    private static IStitchingContext GetStitchingContext(IResolverContext context);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.SchemaDefinitions.IPublishSchemaDefinitionDescriptor {
    public abstract virtual IPublishSchemaDefinitionDescriptor SetName(string name);
    public abstract virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromFile(string fileName);
    public abstract virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromResource(Assembly assembly, string key);
    public abstract virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromString(string schemaSdl);
    public abstract virtual IPublishSchemaDefinitionDescriptor SetSchemaDefinitionPublisher(Func`2<IServiceProvider, ISchemaDefinitionPublisher> publisherFactory);
    public abstract virtual IPublishSchemaDefinitionDescriptor IgnoreRootTypes();
    public abstract virtual IPublishSchemaDefinitionDescriptor IgnoreType(string typeName);
    public abstract virtual IPublishSchemaDefinitionDescriptor RenameType(string typeName, string newTypeName);
    public abstract virtual IPublishSchemaDefinitionDescriptor RenameField(string typeName, string fieldName, string newFieldName);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.SchemaDefinitions.ISchemaDefinitionPublisher {
    public abstract virtual ValueTask PublishAsync(RemoteSchemaDefinition schemaDefinition, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.SchemaDefinitions.PublishSchemaDefinitionDescriptor : object {
    private IRequestExecutorBuilder _builder;
    private string _key;
    private List`1<DirectiveNode> _schemaDirectives;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IServiceProvider, ISchemaDefinitionPublisher> _publisherFactory;
    [NullableAttribute("2")]
private string _name;
    [NullableAttribute("2")]
private RemoteSchemaDefinition _schemaDefinition;
    public bool HasPublisher { get; }
    public PublishSchemaDefinitionDescriptor(IRequestExecutorBuilder builder);
    public bool get_HasPublisher();
    public sealed virtual IPublishSchemaDefinitionDescriptor SetName(string name);
    public sealed virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromFile(string fileName);
    public sealed virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromResource(Assembly assembly, string key);
    public sealed virtual IPublishSchemaDefinitionDescriptor AddTypeExtensionsFromString(string schemaSdl);
    public sealed virtual IPublishSchemaDefinitionDescriptor SetSchemaDefinitionPublisher(Func`2<IServiceProvider, ISchemaDefinitionPublisher> publisherFactory);
    public sealed virtual IPublishSchemaDefinitionDescriptor IgnoreRootTypes();
    public sealed virtual IPublishSchemaDefinitionDescriptor IgnoreType(string typeName);
    public sealed virtual IPublishSchemaDefinitionDescriptor RenameType(string typeName, string newTypeName);
    public sealed virtual IPublishSchemaDefinitionDescriptor RenameField(string typeName, string fieldName, string newFieldName);
    public RemoteSchemaDefinition Build(IDescriptorContext context, ISchema schema);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.SchemaDefinitions.PublishSchemaDefinitionDescriptor/<PublishAsync>d__19")]
public ValueTask PublishAsync(IServiceProvider applicationServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.SchemaDefinitions.SchemaDefinitionFieldNames : object {
    public static string SchemaDefinitionField;
    public static string ConfigurationArgument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.SchemaDefinitions.SchemaDefinitionSchemaInterceptor : TypeInterceptor {
    private PublishSchemaDefinitionDescriptor _descriptor;
    public SchemaDefinitionSchemaInterceptor(PublishSchemaDefinitionDescriptor descriptor);
    internal virtual void OnBeforeCreateSchemaInternal(IDescriptorContext context, ISchemaBuilder schemaBuilder);
    internal virtual void OnAfterCreateSchemaInternal(IDescriptorContext context, ISchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.SchemaDefinitions.SchemaDefinitionType : ObjectType`1<RemoteSchemaDefinition> {
    protected virtual void Configure(IObjectTypeDescriptor`1<RemoteSchemaDefinition> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.SchemaDefinitions.SchemaDefinitionTypeInterceptor : TypeInterceptor {
    private bool _publishOnSchema;
    private ITypeCompletionContext _queryContext;
    public SchemaDefinitionTypeInterceptor(bool publishOnSchema);
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.ScopedVariableNode : object {
    [CompilerGeneratedAttribute]
private SyntaxKind <Kind>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private NameNode <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private NameNode <Name>k__BackingField;
    public SyntaxKind Kind { get; }
    [NullableAttribute("2")]
public Location Location { get; }
    public NameNode Scope { get; }
    public NameNode Name { get; }
    public string Value { get; }
    private object HotChocolate.Language.IValueNode.Value { get; }
    public ScopedVariableNode(string scope, string name);
    public ScopedVariableNode(NameNode scope, NameNode name);
    public ScopedVariableNode(Location location, NameNode scope, NameNode name);
    [CompilerGeneratedAttribute]
public sealed virtual SyntaxKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Location get_Location();
    [CompilerGeneratedAttribute]
public NameNode get_Scope();
    [CompilerGeneratedAttribute]
public NameNode get_Name();
    public sealed virtual string get_Value();
    private sealed virtual override object HotChocolate.Language.IValueNode.get_Value();
    public sealed virtual IEnumerable`1<ISyntaxNode> GetNodes();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ScopedVariableNode other);
    [NullableContextAttribute("2")]
public bool Equals(IValueNode other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(bool indented);
    public VariableNode ToVariableNode();
    public string ToVariableName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.SelectionPathComponent : object {
    [CompilerGeneratedAttribute]
private NameNode <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ArgumentNode> <Arguments>k__BackingField;
    public NameNode Name { get; }
    public IReadOnlyList`1<ArgumentNode> Arguments { get; }
    public SelectionPathComponent(NameNode name, IReadOnlyList`1<ArgumentNode> arguments);
    [CompilerGeneratedAttribute]
public NameNode get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ArgumentNode> get_Arguments();
    public virtual string ToString();
    private static string SerializeArgument(ArgumentNode argument);
    private static string SerializeValue(IValueNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.SelectionPathParser : object {
    private static int _maxStackSize;
    public static IImmutableStack`1<SelectionPathComponent> Parse(string path);
    [NullableContextAttribute("0")]
private static void Prepare(string path, Span`1<byte> sourceText);
    private static ImmutableStack`1<SelectionPathComponent> ParseSelectionPath(Utf8GraphQLParser& parser);
    private static SelectionPathComponent ParseSelectionPathComponent(Utf8GraphQLParser& parser);
    private static List`1<ArgumentNode> ParseArguments(Utf8GraphQLParser& parser);
    private static ArgumentNode ParseArgument(Utf8GraphQLParser& parser);
    private static IValueNode ParseValueLiteral(Utf8GraphQLParser& parser);
    private static ScopedVariableNode ParseVariable(Utf8GraphQLParser& parser);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.SourceDirective : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    public string Name { get; }
    public string Schema { get; }
    public SourceDirective(string name, string schema);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.SourceDirectiveType : DirectiveType`1<SourceDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<SourceDirective> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.ThrowHelper : object {
    public static InvalidOperationException BufferedRequest_VariableDoesNotExist(string name);
    public static InvalidOperationException BufferedRequest_OperationNotFound(DocumentNode document);
    public static GraphQLException ArgumentScopedVariableResolver_InvalidArgumentName(string variableName, FieldNode fieldSelection, Path path);
    public static GraphQLException FieldScopedVariableResolver_InvalidFieldName(string variableName, FieldNode fieldSelection, Path path);
    public static GraphQLException RootScopedVariableResolver_ScopeNotSupported(string scopeName, FieldNode fieldSelection, Path path);
    public static SchemaException PublishSchemaDefinitionDescriptor_ResourceNotFound(string key);
    public static SchemaException IntrospectionHelper_UnableToFetchSchemaDefinition(IReadOnlyList`1<IError> errors);
    public static SchemaException RequestExecutorBuilder_ResourceNotFound(string key);
    public static SchemaException RequestExecutorBuilder_ArgumentWithNameWasNotFound(string argument);
    public static SchemaException RequestExecutorBuilder_ArgumentValueWasNotAStringValue(string argument);
    public static InvalidOperationException RequestExecutorBuilder_RemoteExecutorNotFound();
    public static InvalidOperationException RequestExecutorBuilder_NameLookupNotFound();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Utilities.CopySchemaDefinitionTypeInterceptor : TypeInterceptor {
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class HotChocolate.Stitching.Utilities.FieldDependency : ValueType {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string TypeName { get; }
    public string FieldName { get; }
    public FieldDependency(string typeName, string fieldName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_FieldName();
    public sealed virtual bool Equals(FieldDependency other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.Utilities.FieldDependencyResolver : QuerySyntaxWalker`1<Context> {
    private ISchema _schema;
    protected bool VisitFragmentDefinitions { get; }
    public FieldDependencyResolver(ISchema schema);
    protected virtual bool get_VisitFragmentDefinitions();
    public ISet`1<FieldDependency> GetFieldDependencies(DocumentNode document, FieldNode field, INamedOutputType declaringType);
    public ISet`1<FieldDependency> GetFieldDependencies(DocumentNode document, SelectionSetNode selectionSet, INamedOutputType declaringType);
    private static IDictionary`2<string, FragmentDefinitionNode> GetFragments(DocumentNode document);
    protected virtual void VisitField(FieldNode node, Context context);
    private static void CollectDelegationDependencies(Context context, IHasName type, IOutputField field);
    private static void CollectComputeDependencies(Context context, IComplexOutputType type, IOutputField field);
    private static void CollectFieldNames(DelegateDirective directive, IHasName type, ISet`1<FieldDependency> dependencies);
    protected virtual void VisitFragmentSpread(FragmentSpreadNode node, Context context);
    protected virtual void VisitFragmentDefinition(FragmentDefinitionNode node, Context context);
    protected virtual void VisitInlineFragment(InlineFragmentNode node, Context context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Stitching.Utilities.IntrospectionHelper : object {
    private HttpClient _httpClient;
    private string _configuration;
    public IntrospectionHelper(HttpClient httpClient, string configuration);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Utilities.IntrospectionHelper/<GetSchemaDefinitionAsync>d__3")]
public Task`1<RemoteSchemaDefinition> GetSchemaDefinitionAsync(CancellationToken cancellationToken);
    private static bool ProvidesSchemaDefinition(DocumentNode schemaDocument);
    [AsyncStateMachineAttribute("HotChocolate.Stitching.Utilities.IntrospectionHelper/<FetchSchemaDefinitionAsync>d__5")]
private ValueTask`1<RemoteSchemaDefinition> FetchSchemaDefinitionAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Stitching.Utilities.IQueryDelegationRewriter {
    public abstract virtual FieldNode OnRewriteField(string targetSchemaName, IOutputType outputType, IOutputField outputField, FieldNode field);
    public abstract virtual SelectionSetNode OnRewriteSelectionSet(string targetSchemaName, IOutputType outputType, IOutputField outputField, SelectionSetNode selectionSet);
}
public class HotChocolate.Stitching.Utilities.QueryDelegationRewriterBase : object {
    [NullableContextAttribute("1")]
public virtual FieldNode OnRewriteField(string targetSchemaName, IOutputType outputType, IOutputField outputField, FieldNode field);
    [NullableContextAttribute("1")]
public virtual SelectionSetNode OnRewriteSelectionSet(string targetSchemaName, IOutputType outputType, IOutputField outputField, SelectionSetNode selectionSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Stitching.Utilities.SchemaExtensionsRewriter : SyntaxRewriter`1<Context> {
    private List`1<DirectiveNode> _directives;
    public IReadOnlyList`1<DirectiveNode> SchemaActions { get; }
    public IReadOnlyList`1<DirectiveNode> get_SchemaActions();
    protected virtual SchemaExtensionNode RewriteSchemaExtension(SchemaExtensionNode node, Context context);
    protected virtual DirectiveNode RewriteDirective(DirectiveNode node, Context context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Utilities.StitchingSchemaInterceptor : TypeInterceptor {
    internal virtual void OnBeforeCreateSchemaInternal(IDescriptorContext context, ISchemaBuilder schemaBuilder);
    private static DocumentNode MergeSchemas(IDescriptorContext context, IDictionary`2<string, DocumentNode> schemas);
    private static DocumentNode AddExtensions(DocumentNode schema, IReadOnlyCollection`1<DocumentNode> typeExtensions);
    private static DocumentNode RewriteMerged(IDescriptorContext context, DocumentNode schema);
    private static void VisitMerged(IDescriptorContext context, DocumentNode schema);
    private static void MarkExternalFields(ISchemaBuilder schemaBuilder, DocumentNode document);
    private static void BuildNameLookup(IDescriptorContext context, ISchemaBuilder schemaBuilder, DocumentNode document, ICollection`1<string> schemaNames);
    private static void MarkExternalFields(IReadOnlyList`1<FieldDefinitionNode> fields, ISet`1<string> externalFields);
    private static bool IsOfTypeFallback(ObjectType objectType, IResolverContext context, object resolverResult);
    private static bool TryDeserializeTypeName(object serializedTypeName, String& typeName);
    private static bool IsOfTypeWithClrType(IHasRuntimeType type, object result);
    private static bool IsOfTypeWithName(IHasName objectType, object result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Stitching.Utilities.StitchingTypeInterceptor : TypeInterceptor {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ValueTuple`2<string, string>> _handledExternalFields;
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    private static bool IsDelegatedField(DirectiveDefinition directiveDef);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.WellKnownContextData : object {
    public static string IsAutoGenerated;
    public static string SchemaName;
    public static string RemoteExecutors;
    public static string TypeMergeRules;
    public static string DirectiveMergeRules;
    public static string DocumentRewriter;
    public static string TypeRewriter;
    public static string TypeExtensions;
    public static string MergedDocRewriter;
    public static string MergedDocVisitors;
    public static string RequestVarNames;
    public static string ExternalFieldLookup;
    public static string NameLookup;
    public static string SchemaDefinitions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Stitching.WellKnownFieldNames : object {
    [CompilerGeneratedAttribute]
private static string <TypeName>k__BackingField;
    public static string TypeName { get; }
    private static WellKnownFieldNames();
    [CompilerGeneratedAttribute]
public static string get_TypeName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.HotChocolateStitchingRequestExecutorExtensions : object {
    [ExtensionAttribute]
public static IRequestExecutorBuilder UseHttpRequests(IRequestExecutorBuilder builder);
    [ExtensionAttribute]
public static IRequestExecutorBuilder UseHttpRequestPipeline(IRequestExecutorBuilder builder);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddRemoteSchema(IRequestExecutorBuilder builder, string schemaName, bool ignoreRootTypes);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddRemoteSchemaFromString(IRequestExecutorBuilder builder, string schemaName, string schemaSdl, bool ignoreRootTypes);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddRemoteSchemaFromFile(IRequestExecutorBuilder builder, string schemaName, string fileName, bool ignoreRootTypes);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddRemoteSchema(IRequestExecutorBuilder builder, string schemaName, Func`3<IServiceProvider, CancellationToken, ValueTask`1<RemoteSchemaDefinition>> loadSchema, bool ignoreRootTypes);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddLocalSchema(IRequestExecutorBuilder builder, string schemaName, bool ignoreRootTypes);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeMergeRule(IRequestExecutorBuilder builder, MergeTypeRuleFactory mergeRuleFactory);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddDirectiveMergeRule(IRequestExecutorBuilder builder, MergeDirectiveRuleFactory mergeRuleFactory);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeRewriter(IRequestExecutorBuilder builder, ITypeRewriter rewriter);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddDocumentRewriter(IRequestExecutorBuilder builder, IDocumentRewriter rewriter);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeExtensionsFromString(IRequestExecutorBuilder builder, string schemaSdl);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeExtensionsFromFile(IRequestExecutorBuilder builder, string fileName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeExtensionsFromResource(IRequestExecutorBuilder builder, Assembly assembly, string key);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddMergedDocumentRewriter(IRequestExecutorBuilder builder, Func`2<DocumentNode, DocumentNode> rewrite);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddMergedDocVisitor(IRequestExecutorBuilder builder, Action`1<DocumentNode> visit);
    [ExtensionAttribute]
public static IRequestExecutorBuilder IgnoreRootTypes(IRequestExecutorBuilder builder, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder IgnoreType(IRequestExecutorBuilder builder, string typeName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder IgnoreField(IRequestExecutorBuilder builder, string typeName, string fieldName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder IgnoreField(IRequestExecutorBuilder builder, FieldReference field, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RenameType(IRequestExecutorBuilder builder, string originalTypeName, string newTypeName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RewriteType(IRequestExecutorBuilder builder, string originalTypeName, string newTypeName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RenameField(IRequestExecutorBuilder builder, string typeName, string fieldName, string newFieldName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RenameField(IRequestExecutorBuilder builder, FieldReference field, string newFieldName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RenameField(IRequestExecutorBuilder builder, string typeName, string fieldName, string argumentName, string newArgumentName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder RenameField(IRequestExecutorBuilder builder, FieldReference field, string argumentName, string newArgumentName, string schemaName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeRewriter(IRequestExecutorBuilder builder, RewriteTypeDefinitionDelegate rewrite);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddDocumentRewriter(IRequestExecutorBuilder builder, RewriteDocumentDelegate rewrite);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddTypeMergeHandler(IRequestExecutorBuilder builder);
    [ExtensionAttribute]
public static IRequestExecutorBuilder AddDirectiveMergeHandler(IRequestExecutorBuilder builder);
    private static string GetArgumentValue(DirectiveNode directive, string argumentName);
    [ExtensionAttribute]
public static IRequestExecutorBuilder PublishSchemaDefinition(IRequestExecutorBuilder builder, Action`1<IPublishSchemaDefinitionDescriptor> configure);
}
