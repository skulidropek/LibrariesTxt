[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.AggregateTypeInterceptor : TypeInterceptor {
    private List`1<TypeReference> _typeReferences;
    private TypeInterceptor[] _typeInterceptors;
    [NullableAttribute("2")]
private TypeInterceptor _mutationAggregator;
    public void SetInterceptors(IReadOnlyCollection`1<TypeInterceptor> typeInterceptors);
    internal virtual void OnBeforeCreateSchemaInternal(IDescriptorContext context, ISchemaBuilder schemaBuilder);
    internal virtual void InitializeContext(IDescriptorContext context, TypeInitializer typeInitializer, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeReferenceResolver typeReferenceResolver);
    public virtual void OnBeforeDiscoverTypes();
    public virtual void OnAfterDiscoverTypes();
    public virtual void OnBeforeInitialize(ITypeDiscoveryContext discoveryContext);
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnTypeRegistered(ITypeDiscoveryContext discoveryContext);
    public virtual IEnumerable`1<TypeReference> RegisterMoreTypes(IReadOnlyCollection`1<ITypeDiscoveryContext> discoveryContexts);
    public virtual void OnTypesInitialized();
    public virtual void OnAfterRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnBeforeCompleteTypeNames();
    public virtual void OnAfterCompleteTypeNames();
    public virtual void OnBeforeCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnTypesCompletedName();
    public virtual void OnBeforeMergeTypeExtensions();
    public virtual void OnAfterMergeTypeExtensions();
    internal virtual void OnBeforeCompleteMutation(ITypeCompletionContext completionContext, ObjectTypeDefinition definition);
    public virtual void OnBeforeCompleteTypes();
    public virtual void OnAfterCompleteTypes();
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnValidateType(ITypeSystemObjectContext validationContext, DefinitionBase definition);
    public virtual bool TryCreateScope(ITypeDiscoveryContext discoveryContext, IReadOnlyList`1& typeDeps);
    public virtual void OnTypesCompleted();
    internal virtual void OnBeforeRegisterSchemaTypes(IDescriptorContext context, SchemaTypesDefinition schemaTypesDefinition);
    internal virtual void OnAfterCreateSchemaInternal(IDescriptorContext context, ISchema schema);
    public virtual void OnCreateSchemaError(IDescriptorContext context, Exception error);
    private TypeInterceptor& GetReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.DefaultTypeDiscoveryHandler : TypeDiscoveryHandler {
    [CompilerGeneratedAttribute]
private ITypeInspector <TypeInspector>k__BackingField;
    private ITypeInspector TypeInspector { get; }
    public DefaultTypeDiscoveryHandler(ITypeInspector typeInspector);
    [CompilerGeneratedAttribute]
private ITypeInspector get_TypeInspector();
    public virtual bool TryInferType(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeReference[]& schemaTypeRefs);
    public virtual bool TryInferKind(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeKind& typeKind);
    private static bool IsStaticObjectTypeExtension(TypeDiscoveryInfo typeInfo);
    private static bool IsObjectTypeExtension(TypeDiscoveryInfo typeInfo);
    private static bool IsObjectType(TypeDiscoveryInfo typeInfo);
    private static bool IsUnionType(TypeDiscoveryInfo typeInfo);
    private static bool IsInterfaceType(TypeDiscoveryInfo typeInfo);
    private static bool IsInputObjectType(TypeDiscoveryInfo typeInfo);
    private static bool IsEnumType(TypeDiscoveryInfo typeInfo);
    private static bool IsDirectiveType(TypeDiscoveryInfo typeInfo);
}
internal class HotChocolate.Configuration.DependantFactoryTypeReferenceHandler : object {
    private HashSet`1<DependantFactoryTypeReference> _handled;
    private IDescriptorContext _context;
    public TypeReferenceKind Kind { get; }
    public DependantFactoryTypeReferenceHandler(IDescriptorContext context);
    public sealed virtual TypeReferenceKind get_Kind();
    public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
public enum HotChocolate.Configuration.DirectiveVisibility : Enum {
    public int value__;
    public static DirectiveVisibility Public;
    public static DirectiveVisibility Internal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.ExtendedTypeDirectiveReferenceHandler : object {
    [CompilerGeneratedAttribute]
private ITypeInspector <typeInspector>P;
    public TypeReferenceKind Kind { get; }
    public ExtendedTypeDirectiveReferenceHandler(ITypeInspector typeInspector);
    public sealed virtual TypeReferenceKind get_Kind();
    public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.ExtendedTypeRefEqualityComparer : object {
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtendedTypeReference x, ExtendedTypeReference y);
    [NullableContextAttribute("2")]
private static bool Equals(IExtendedType x, IExtendedType y);
    public sealed virtual int GetHashCode(ExtendedTypeReference obj);
    private static int GetHashCode(IExtendedType obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.ExtendedTypeReferenceHandler : object {
    [CompilerGeneratedAttribute]
private ITypeInspector <typeInspector>P;
    public TypeReferenceKind Kind { get; }
    public ExtendedTypeReferenceHandler(ITypeInspector typeInspector);
    public sealed virtual TypeReferenceKind get_Kind();
    public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
    private static void TryMapToExistingRegistration(ITypeRegistrar typeRegistrar, ITypeInfo typeInfo, TypeContext context, string scope);
    private static bool IsTypeSystemObject(Type type);
}
internal class HotChocolate.Configuration.FactoryTypeReferenceHandler : object {
    private HashSet`1<string> _handled;
    private IDescriptorContext _context;
    public TypeReferenceKind Kind { get; }
    public FactoryTypeReferenceHandler(IDescriptorContext context);
    public sealed virtual TypeReferenceKind get_Kind();
    public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
public enum HotChocolate.Configuration.FieldMiddlewareApplication : Enum {
    public byte value__;
    public static FieldMiddlewareApplication UserDefinedFields;
    public static FieldMiddlewareApplication AllFields;
}
[NullableContextAttribute("1")]
public interface HotChocolate.Configuration.ITypeCompletionContext {
    public IReadOnlyList`1<FieldMiddleware> GlobalComponents { get; }
    [NullableAttribute("2")]
public IsOfTypeFallback IsOfType { get; }
    public abstract virtual IReadOnlyList`1<FieldMiddleware> get_GlobalComponents();
    [NullableContextAttribute("2")]
public abstract virtual IsOfTypeFallback get_IsOfType();
    public abstract virtual bool TryGetType(TypeReference typeRef, T& type);
    public abstract virtual T GetType(TypeReference typeRef);
    public abstract virtual TypeReference GetNamedTypeReference(TypeReference typeRef);
    public abstract virtual IEnumerable`1<T> GetTypes();
    public abstract virtual bool TryGetDirectiveType(TypeReference directiveRef, DirectiveType& directiveType);
}
public interface HotChocolate.Configuration.ITypeDiscoveryContext {
    public IList`1<TypeDependency> Dependencies { get; }
    public abstract virtual IList`1<TypeDependency> get_Dependencies();
}
[NullableContextAttribute("1")]
internal interface HotChocolate.Configuration.ITypeRegistrar {
    public IReadOnlyCollection`1<TypeReference> Unresolved { get; }
    public abstract virtual void Register(TypeSystemObjectBase obj, string scope, bool inferred, Action`1<RegisteredType> configure);
    public abstract virtual void MarkUnresolved(TypeReference typeReference);
    public abstract virtual void MarkResolved(TypeReference typeReference);
    public abstract virtual bool IsResolved(TypeReference typeReference);
    public abstract virtual TypeSystemObjectBase CreateInstance(Type namedSchemaType);
    public abstract virtual IReadOnlyCollection`1<TypeReference> get_Unresolved();
    public abstract virtual IReadOnlyCollection`1<TypeReference> GetUnhandled();
}
[NullableContextAttribute("1")]
internal interface HotChocolate.Configuration.ITypeRegistrarHandler {
    public TypeReferenceKind Kind { get; }
    public abstract virtual TypeReferenceKind get_Kind();
    public abstract virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Configuration.ITypeSystemObjectContext {
    public ITypeSystemObject Type { get; }
    public TypeReference TypeReference { get; }
    public bool IsType { get; }
    public bool IsIntrospectionType { get; }
    public bool IsDirective { get; }
    public bool IsSchema { get; }
    public bool IsInferred { get; }
    public IServiceProvider Services { get; }
    public IDescriptorContext DescriptorContext { get; }
    public TypeInterceptor TypeInterceptor { get; }
    public ITypeInspector TypeInspector { get; }
    public abstract virtual ITypeSystemObject get_Type();
    public abstract virtual TypeReference get_TypeReference();
    public abstract virtual bool get_IsType();
    public abstract virtual bool get_IsIntrospectionType();
    public abstract virtual bool get_IsDirective();
    public abstract virtual bool get_IsSchema();
    public abstract virtual bool get_IsInferred();
    public abstract virtual IServiceProvider get_Services();
    public abstract virtual IDescriptorContext get_DescriptorContext();
    public abstract virtual TypeInterceptor get_TypeInterceptor();
    public abstract virtual ITypeInspector get_TypeInspector();
    public abstract virtual void ReportError(ISchemaError error);
    public abstract virtual bool TryPredictTypeKind(TypeReference typeRef, TypeKind& kind);
}
[ExtensionAttribute]
internal static class HotChocolate.Configuration.ListExtensions : object {
    [ExtensionAttribute]
public static void TryAdd(List`1<T> list, T item);
}
public class HotChocolate.Configuration.OnAfterSchemaCreate : MulticastDelegate {
    public OnAfterSchemaCreate(object object, IntPtr method);
    public virtual void Invoke(IDescriptorContext descriptorContext, ISchema schema);
    public virtual IAsyncResult BeginInvoke(IDescriptorContext descriptorContext, ISchema schema, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnBeforeSchemaCreate : MulticastDelegate {
    public OnBeforeSchemaCreate(object object, IntPtr method);
    public virtual void Invoke(IDescriptorContext descriptorContext, ISchemaBuilder schemaBuilder);
    public virtual IAsyncResult BeginInvoke(IDescriptorContext descriptorContext, ISchemaBuilder schemaBuilder, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnCompleteType : MulticastDelegate {
    public OnCompleteType(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ITypeCompletionContext context, DefinitionBase definition, IDictionary`2<string, object> contextData);
    public virtual IAsyncResult BeginInvoke(ITypeCompletionContext context, DefinitionBase definition, IDictionary`2<string, object> contextData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnCompleteType`1 : MulticastDelegate {
    public OnCompleteType`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ITypeCompletionContext context, T definition, IDictionary`2<string, object> contextData);
    public virtual IAsyncResult BeginInvoke(ITypeCompletionContext context, T definition, IDictionary`2<string, object> contextData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnInitializeType : MulticastDelegate {
    public OnInitializeType(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ITypeDiscoveryContext context, DefinitionBase definition, IDictionary`2<string, object> contextData);
    public virtual IAsyncResult BeginInvoke(ITypeDiscoveryContext context, DefinitionBase definition, IDictionary`2<string, object> contextData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnInitializeType`1 : MulticastDelegate {
    public OnInitializeType`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ITypeDiscoveryContext context, T definition, IDictionary`2<string, object> contextData);
    public virtual IAsyncResult BeginInvoke(ITypeDiscoveryContext context, T definition, IDictionary`2<string, object> contextData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class HotChocolate.Configuration.OnSchemaError : MulticastDelegate {
    public OnSchemaError(object object, IntPtr method);
    public virtual void Invoke(IDescriptorContext descriptorContext, Exception exception);
    public virtual IAsyncResult BeginInvoke(IDescriptorContext descriptorContext, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.RegisteredResolver : object {
    [CompilerGeneratedAttribute]
private Type <ResolverType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IFieldReference <Field>k__BackingField;
    public Type ResolverType { get; }
    public Type SourceType { get; }
    public IFieldReference Field { get; }
    public bool IsSourceResolver { get; }
    public RegisteredResolver(Type resolverType, Type sourceType, IFieldReference field);
    [CompilerGeneratedAttribute]
public Type get_ResolverType();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public IFieldReference get_Field();
    public bool get_IsSourceResolver();
    public RegisteredResolver WithField(IFieldReference field);
    public RegisteredResolver WithSourceType(Type sourceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.RegisteredType : object {
    [NullableAttribute("2")]
private TypeReferenceResolver _typeReferenceResolver;
    [CompilerGeneratedAttribute]
private TypeStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsQueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsMutationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSubscriptionType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<FieldMiddleware> <GlobalComponents>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IsOfTypeFallback <IsOfType>k__BackingField;
    private TypeRegistry _typeRegistry;
    private TypeLookup _typeLookup;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TypeDependency> _conditionals;
    [CompilerGeneratedAttribute]
private TypeSystemObjectBase <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeKind> <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TypeReference> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TypeDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirectiveType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIntrospectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSchema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ISchemaError> _errors;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private IDescriptorContext <DescriptorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInterceptor <TypeInterceptor>k__BackingField;
    public TypeStatus Status { get; public set; }
    public Nullable`1<bool> IsQueryType { get; public set; }
    public Nullable`1<bool> IsMutationType { get; public set; }
    public Nullable`1<bool> IsSubscriptionType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<FieldMiddleware> GlobalComponents { get; private set; }
    private IReadOnlyList`1<FieldMiddleware> HotChocolate.Configuration.ITypeCompletionContext.GlobalComponents { get; }
    [NullableAttribute("2")]
public IsOfTypeFallback IsOfType { get; private set; }
    public TypeReference TypeReference { get; }
    public TypeSystemObjectBase Type { get; }
    public Nullable`1<TypeKind> Kind { get; }
    public Type RuntimeType { get; }
    public List`1<TypeReference> References { get; }
    public List`1<TypeDependency> Dependencies { get; }
    public List`1<TypeDependency> Conditionals { get; }
    public bool IsInferred { get; }
    public bool IsExtension { get; }
    public bool IsNamedType { get; }
    public bool IsDirectiveType { get; }
    public bool IsIntrospectionType { get; }
    public bool IsSchema { get; }
    public bool IsType { get; }
    public bool IsDirective { get; }
    public List`1<ISchemaError> Errors { get; }
    public bool HasErrors { get; }
    [NullableAttribute("2")]
public string Scope { get; }
    public IDescriptorContext DescriptorContext { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    public IServiceProvider Services { get; }
    public ITypeInspector TypeInspector { get; }
    public TypeInterceptor TypeInterceptor { get; }
    private IList`1<TypeDependency> HotChocolate.Configuration.ITypeDiscoveryContext.Dependencies { get; }
    private ITypeSystemObject HotChocolate.Configuration.ITypeSystemObjectContext.Type { get; }
    public RegisteredType(TypeSystemObjectBase type, bool isInferred, TypeRegistry typeRegistry, TypeLookup typeLookup, IDescriptorContext descriptorContext, TypeInterceptor typeInterceptor, string scope);
    [CompilerGeneratedAttribute]
public TypeStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(TypeStatus value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsQueryType();
    [CompilerGeneratedAttribute]
public void set_IsQueryType(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsMutationType();
    [CompilerGeneratedAttribute]
public void set_IsMutationType(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSubscriptionType();
    [CompilerGeneratedAttribute]
public void set_IsSubscriptionType(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public List`1<FieldMiddleware> get_GlobalComponents();
    [CompilerGeneratedAttribute]
private void set_GlobalComponents(List`1<FieldMiddleware> value);
    private sealed virtual override IReadOnlyList`1<FieldMiddleware> HotChocolate.Configuration.ITypeCompletionContext.get_GlobalComponents();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IsOfTypeFallback get_IsOfType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_IsOfType(IsOfTypeFallback value);
    public sealed virtual TypeReference get_TypeReference();
    public void PrepareForCompletion(TypeReferenceResolver typeReferenceResolver, List`1<FieldMiddleware> globalComponents, IsOfTypeFallback isOfType);
    public sealed virtual bool TryGetType(TypeReference typeRef, T& type);
    public sealed virtual T GetType(TypeReference typeRef);
    public sealed virtual TypeReference GetNamedTypeReference(TypeReference typeRef);
    public sealed virtual IEnumerable`1<T> GetTypes();
    public sealed virtual bool TryGetDirectiveType(TypeReference directiveRef, DirectiveType& directiveType);
    [CompilerGeneratedAttribute]
public TypeSystemObjectBase get_Type();
    [CompilerGeneratedAttribute]
public Nullable`1<TypeKind> get_Kind();
    public sealed virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public List`1<TypeReference> get_References();
    [CompilerGeneratedAttribute]
public List`1<TypeDependency> get_Dependencies();
    public List`1<TypeDependency> get_Conditionals();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInferred();
    [CompilerGeneratedAttribute]
public bool get_IsExtension();
    [CompilerGeneratedAttribute]
public bool get_IsNamedType();
    [CompilerGeneratedAttribute]
public bool get_IsDirectiveType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIntrospectionType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSchema();
    public sealed virtual bool get_IsType();
    public sealed virtual bool get_IsDirective();
    public List`1<ISchemaError> get_Errors();
    public bool get_HasErrors();
    public void ClearConditionals();
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Scope();
    [CompilerGeneratedAttribute]
public sealed virtual IDescriptorContext get_DescriptorContext();
    public sealed virtual IDictionary`2<string, object> get_ContextData();
    public sealed virtual IServiceProvider get_Services();
    public sealed virtual ITypeInspector get_TypeInspector();
    [CompilerGeneratedAttribute]
public sealed virtual TypeInterceptor get_TypeInterceptor();
    private sealed virtual override IList`1<TypeDependency> HotChocolate.Configuration.ITypeDiscoveryContext.get_Dependencies();
    private sealed virtual override ITypeSystemObject HotChocolate.Configuration.ITypeSystemObjectContext.get_Type();
    public sealed virtual void ReportError(ISchemaError error);
    public sealed virtual bool TryPredictTypeKind(TypeReference typeRef, TypeKind& kind);
    private static TypeKind GetTypeKindFromSchemaType(IExtendedType type);
}
internal enum HotChocolate.Configuration.RootTypeKind : Enum {
    public int value__;
    public static RootTypeKind Query;
    public static RootTypeKind Mutation;
    public static RootTypeKind Subscription;
    public static RootTypeKind None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.ScalarTypeDiscoveryHandler : TypeDiscoveryHandler {
    [CompilerGeneratedAttribute]
private ITypeInspector <TypeInspector>k__BackingField;
    private ITypeInspector TypeInspector { get; }
    public ScalarTypeDiscoveryHandler(ITypeInspector typeInspector);
    [CompilerGeneratedAttribute]
private ITypeInspector get_TypeInspector();
    public virtual bool TryInferType(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeReference[]& schemaTypeRefs);
    public virtual bool TryInferKind(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeKind& typeKind);
}
internal class HotChocolate.Configuration.SchemaTypeReferenceHandler : object {
    public TypeReferenceKind Kind { get; }
    public sealed virtual TypeReferenceKind get_Kind();
    [NullableContextAttribute("1")]
public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.SyntaxTypeReferenceHandler : object {
    private HashSet`1<string> _handled;
    private ITypeInspector _typeInspector;
    public TypeReferenceKind Kind { get; }
    public SyntaxTypeReferenceHandler(ITypeInspector typeInspector);
    public sealed virtual TypeReferenceKind get_Kind();
    public sealed virtual void Handle(ITypeRegistrar typeRegistrar, TypeReference typeReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeDiscoverer : object {
    private List`1<TypeReference> _unregistered;
    private List`1<ISchemaError> _errors;
    private List`1<TypeReference> _resolved;
    private IDescriptorContext _context;
    private TypeRegistry _typeRegistry;
    private TypeRegistrar _typeRegistrar;
    private ITypeRegistrarHandler[] _handlers;
    private TypeInterceptor _interceptor;
    public TypeRegistrar Registrar { get; }
    public TypeDiscoverer(IDescriptorContext context, TypeRegistry typeRegistry, TypeLookup typeLookup, IEnumerable`1<TypeReference> initialTypes, TypeInterceptor interceptor, bool includeSystemTypes);
    public TypeRegistrar get_Registrar();
    public IReadOnlyList`1<ISchemaError> DiscoverTypes();
    private void RegisterTypes();
    private bool TryInferTypes();
    private void CollectErrors();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Configuration.TypeDiscoveryDescriptorContextExtensions : object {
    [ExtensionAttribute]
public static bool TryInferSchemaType(IDescriptorContext context, TypeReference unresolvedTypeRef, TypeReference[]& schemaTypeRefs);
    [ExtensionAttribute]
public static bool TryInferSchemaTypeKind(IDescriptorContext context, ExtendedTypeReference unresolvedTypeRef, TypeKind& kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeInitializer : object {
    private List`1<FieldMiddleware> _globalComps;
    private List`1<ISchemaError> _errors;
    private IDescriptorContext _context;
    private TypeInterceptor _interceptor;
    [NullableAttribute("2")]
private IsOfTypeFallback _isOfType;
    private Func`2<TypeSystemObjectBase, RootTypeKind> _getTypeKind;
    private IReadOnlySchemaOptions _options;
    private TypeRegistry _typeRegistry;
    private TypeLookup _typeLookup;
    private TypeReferenceResolver _typeReferenceResolver;
    private List`1<RegisteredType> _next;
    private List`1<RegisteredType> _temp;
    private List`1<TypeReference> _typeRefs;
    private HashSet`1<TypeReference> _typeRefSet;
    private List`1<RegisteredRootType> _rootTypes;
    private TypeDiscoverer _typeDiscoverer;
    public IList`1<FieldMiddleware> GlobalComponents { get; }
    public TypeInitializer(IDescriptorContext descriptorContext, TypeRegistry typeRegistry, IReadOnlyList`1<TypeReference> initialTypes, IsOfTypeFallback isOfType, Func`2<TypeSystemObjectBase, RootTypeKind> getTypeKind, IReadOnlySchemaOptions options);
    public IList`1<FieldMiddleware> get_GlobalComponents();
    public void Initialize();
    private void DiscoverTypes();
    private void RegisterImplicitAbstractTypeDependencies();
    private List`1<RegisteredType> GetTypesWithRuntimeType(HashSet`1<RegisteredType> processed, TypeKind kind);
    private void CompleteNames();
    internal RegisteredType InitializeType(Type type);
    internal RegisteredType InitializeType(TypeSystemObjectBase type);
    internal bool CompleteTypeName(RegisteredType registeredType);
    private void ResolveRootTyped();
    private void MergeTypeExtensions();
    private void MergeTypeExtension(IEnumerable`1<RegisteredType> extensions, RegisteredType registeredType, INamedType namedType, HashSet`1<RegisteredType> processed);
    private void CompleteTypes();
    internal bool CompleteType(RegisteredType registeredType);
    private void FinalizeTypes();
    private bool ProcessTypes(TypeDependencyFulfilled fulfilled, Func`2<RegisteredType, bool> action);
    [IteratorStateMachineAttribute("HotChocolate.Configuration.TypeInitializer/<GetInitialBatch>d__34")]
private IEnumerable`1<RegisteredType> GetInitialBatch(TypeDependencyFulfilled fulfilled);
    [IteratorStateMachineAttribute("HotChocolate.Configuration.TypeInitializer/<GetNextBatch>d__35")]
private IEnumerable`1<RegisteredType> GetNextBatch(ISet`1<TypeReference> processed);
    private bool TryNormalizeDependencies(List`1<TypeDependency> dependencies, IReadOnlyList`1& normalized, IReadOnlyList`1& notFound);
    private void EnsureNoErrors();
    [CompilerGeneratedAttribute]
private bool <CompleteNames>b__23_0(RegisteredType type);
    [CompilerGeneratedAttribute]
private bool <CompleteTypes>b__30_0(RegisteredType type);
    [CompilerGeneratedAttribute]
private List`1<TypeReference> <GetNextBatch>g__GetTypeRefsExceptSelfRefs|35_0(RegisteredType type, IReadOnlyList`1<TypeReference> normalizedTypeReferences);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Configuration.TypeInterceptor : object {
    private static UInt32 _defaultPosition;
    internal UInt32 Position { get; }
    internal virtual UInt32 get_Position();
    internal virtual bool IsEnabled(IDescriptorContext context);
    internal virtual bool IsMutationAggregator(IDescriptorContext context);
    internal virtual void SetSiblings(TypeInterceptor[] all);
    [ObsoleteAttribute("This hook is deprecated and will be removed in the next release.")]
internal virtual void OnBeforeCreateSchema(IDescriptorContext context, ISchemaBuilder schemaBuilder);
    internal virtual void OnBeforeCreateSchemaInternal(IDescriptorContext context, ISchemaBuilder schemaBuilder);
    internal virtual void InitializeContext(IDescriptorContext context, TypeInitializer typeInitializer, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeReferenceResolver typeReferenceResolver);
    public virtual void OnBeforeDiscoverTypes();
    public virtual void OnAfterDiscoverTypes();
    public virtual void OnBeforeInitialize(ITypeDiscoveryContext discoveryContext);
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual IEnumerable`1<TypeReference> RegisterMoreTypes(IReadOnlyCollection`1<ITypeDiscoveryContext> discoveryContexts);
    public virtual void OnTypeRegistered(ITypeDiscoveryContext discoveryContext);
    public virtual void OnTypesInitialized();
    public virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnAfterRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnBeforeCompleteTypeNames();
    public virtual void OnAfterCompleteTypeNames();
    public virtual void OnBeforeCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnTypesCompletedName();
    public virtual void OnBeforeMergeTypeExtensions();
    public virtual void OnAfterMergeTypeExtensions();
    internal virtual void OnBeforeCompleteMutation(ITypeCompletionContext completionContext, ObjectTypeDefinition definition);
    public virtual void OnBeforeCompleteMutationField(ITypeCompletionContext completionContext, ObjectFieldDefinition mutationField);
    public virtual void OnBeforeCompleteTypes();
    public virtual void OnAfterCompleteTypes();
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnValidateType(ITypeSystemObjectContext validationContext, DefinitionBase definition);
    public virtual void OnTypesCompleted();
    internal virtual void OnBeforeRegisterSchemaTypes(IDescriptorContext context, SchemaTypesDefinition schemaTypesDefinition);
    [ObsoleteAttribute("This hook is deprecated and will be removed in the next release.")]
public virtual void OnAfterCreateSchema(IDescriptorContext context, ISchema schema);
    internal virtual void OnAfterCreateSchemaInternal(IDescriptorContext context, ISchema schema);
    public virtual void OnCreateSchemaError(IDescriptorContext context, Exception error);
    public virtual bool TryCreateScope(ITypeDiscoveryContext discoveryContext, IReadOnlyList`1& typeDependencies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeLookup : object {
    private Dictionary`2<TypeReference, TypeReference> _refs;
    private ITypeInspector _typeInspector;
    private TypeRegistry _typeRegistry;
    public TypeLookup(ITypeInspector typeInspector, TypeRegistry typeRegistry);
    public bool TryNormalizeReference(TypeReference typeRef, TypeReference& namedTypeRef);
    private bool TryNormalizeExtendedTypeReference(ExtendedTypeReference typeRef, TypeReference& namedTypeRef);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeReferenceResolver : object {
    private Dictionary`2<TypeId, IType> _typeCache;
    private ITypeInspector _typeInspector;
    private TypeRegistry _typeRegistry;
    private TypeLookup _typeLookup;
    public TypeReferenceResolver(ITypeInspector typeInspector, TypeRegistry typeRegistry, TypeLookup typeLookup);
    public IEnumerable`1<T> GetTypes();
    public TypeReference GetNamedTypeReference(TypeReference typeRef);
    public bool TryGetType(TypeReference typeRef, IType& type);
    public bool TryGetDirectiveType(TypeReference typeRef, DirectiveType& directiveType);
    private static IType CreateType(IType namedType, ITypeNode typeNode);
    private TypeId CreateId(TypeReference typeRef, TypeReference namedTypeRef);
    private static int CreateFlags(ITypeInfo typeInfo);
    private static int CreateFlags(ITypeNode type);
}
[ExtensionAttribute]
internal static class HotChocolate.Configuration.TypeRefHelper : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeReference CreateTypeRef(ITypeInspector typeInspector, Type schemaType, TypeDiscoveryInfo typeInfo, TypeReference originalTypeRef);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeRegistrar : object {
    private HashSet`1<TypeReference> _unresolved;
    private HashSet`1<RegisteredType> _handled;
    private TypeRegistry _typeRegistry;
    private TypeLookup _typeLookup;
    private IDescriptorContext _context;
    private TypeInterceptor _interceptor;
    private IServiceProvider _schemaServices;
    [NullableAttribute("2")]
private IServiceProvider _applicationServices;
    public IReadOnlyCollection`1<TypeReference> Unresolved { get; }
    public TypeRegistrar(IDescriptorContext context, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeInterceptor typeInterceptor);
    public sealed virtual TypeSystemObjectBase CreateInstance(Type namedSchemaType);
    public sealed virtual void Register(TypeSystemObjectBase obj, string scope, bool inferred, Action`1<RegisteredType> configure);
    private void RegisterTypeAndResolveReferences(RegisteredType registeredType);
    public sealed virtual void MarkUnresolved(TypeReference typeReference);
    public sealed virtual void MarkResolved(TypeReference typeReference);
    public sealed virtual bool IsResolved(TypeReference typeReference);
    public sealed virtual IReadOnlyCollection`1<TypeReference> get_Unresolved();
    public sealed virtual IReadOnlyCollection`1<TypeReference> GetUnhandled();
    private RegisteredType InitializeType(TypeSystemObjectBase typeSystemObject, string scope, bool isInferred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeRegistry : object {
    private Dictionary`2<TypeReference, RegisteredType> _typeRegister;
    private Dictionary`2<ExtendedTypeReference, TypeReference> _runtimeTypeRefs;
    private Dictionary`2<string, TypeReference> _nameRefs;
    private List`1<RegisteredType> _types;
    private TypeInterceptor _typeRegistryInterceptor;
    public int Count { get; }
    public IReadOnlyList`1<RegisteredType> Types { get; }
    public IReadOnlyDictionary`2<ExtendedTypeReference, TypeReference> RuntimeTypeRefs { get; }
    public IReadOnlyDictionary`2<string, TypeReference> NameRefs { get; }
    public TypeRegistry(TypeInterceptor typeRegistryInterceptor);
    public int get_Count();
    public IReadOnlyList`1<RegisteredType> get_Types();
    public IReadOnlyDictionary`2<ExtendedTypeReference, TypeReference> get_RuntimeTypeRefs();
    public IReadOnlyDictionary`2<string, TypeReference> get_NameRefs();
    public bool IsRegistered(TypeReference typeReference);
    public bool TryGetType(TypeReference typeRef, RegisteredType& registeredType);
    public bool TryGetTypeRef(ExtendedTypeReference runtimeTypeRef, TypeReference& typeRef);
    public bool TryGetTypeRef(string typeName, TypeReference& typeRef);
    public IEnumerable`1<TypeReference> GetTypeRefs();
    public void TryRegister(ExtendedTypeReference runtimeTypeRef, TypeReference typeRef);
    public void Register(RegisteredType registeredType);
    public void Register(string typeName, ExtendedTypeReference typeReference);
    public void Register(string typeName, RegisteredType registeredType);
    public void CompleteDiscovery();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.TypeTrimmer : object {
    private HashSet`1<TypeSystemObjectBase> _touched;
    private List`1<ObjectType> _rootTypes;
    private List`1<TypeSystemObjectBase> _discoveredTypes;
    public TypeTrimmer(IEnumerable`1<TypeSystemObjectBase> discoveredTypes);
    [NullableContextAttribute("2")]
public void AddOperationType(ObjectType operationType);
    public IReadOnlyCollection`1<TypeSystemObjectBase> Trim();
    private void VisitRoot(ObjectType rootType);
    private void Visit(TypeSystemObjectBase type);
    private void VisitScalar(ScalarType type);
    private void VisitEnum(EnumType type);
    private void VisitObject(ObjectType type);
    private void VisitUnion(UnionType type);
    private void VisitInterface(InterfaceType type);
    private void VisitInput(InputObjectType type);
    private void VisitDirective(DirectiveType type);
    private void VisitDirectives(IHasDirectives hasDirectives);
}
internal class HotChocolate.Configuration.Validation.DirectiveValidationRule : object {
    private static char _prefixCharacter;
    public sealed virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
    private static void EnsureDirectiveNameIsValid(DirectiveType type, ICollection`1<ISchemaError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Configuration.Validation.InputObjectTypeValidationRule : object {
    public sealed virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
    private static void TryReachCycleRecursively(CycleValidationContext& context, InputObjectType type);
    private static IType UnwrapCompletelyIfRequired(IType type);
    private static void EnsureOneOfFieldsAreValid(InputObjectType type, ICollection`1<ISchemaError> errors, List`1& temp);
}
internal class HotChocolate.Configuration.Validation.InterfaceHasAtLeastOneImplementationRule : object {
    public sealed virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
}
internal class HotChocolate.Configuration.Validation.InterfaceTypeValidationRule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
}
[NullableContextAttribute("1")]
internal interface HotChocolate.Configuration.Validation.ISchemaValidationRule {
    public abstract virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
}
internal class HotChocolate.Configuration.Validation.ObjectTypeValidationRule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Validate(ReadOnlySpan`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options, ICollection`1<ISchemaError> errors);
}
internal static class HotChocolate.Configuration.Validation.SchemaValidator : object {
    private static ISchemaValidationRule[] _rules;
    private static SchemaValidator();
    public static IReadOnlyCollection`1<ISchemaError> Validate(IEnumerable`1<ITypeSystemObject> typeSystemObjects, IReadOnlySchemaOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Configuration.Validation.TypeValidationHelper : object {
    private static char _prefixCharacter;
    public static void EnsureTypeHasFields(IComplexOutputType type, ICollection`1<ISchemaError> errors);
    public static void EnsureFieldDeprecationIsValid(IInputObjectType type, ICollection`1<ISchemaError> errors);
    public static void EnsureArgumentDeprecationIsValid(IComplexOutputType type, ICollection`1<ISchemaError> errors);
    public static void EnsureArgumentDeprecationIsValid(DirectiveType type, ICollection`1<ISchemaError> errors);
    public static void EnsureTypeHasFields(InputObjectType type, ICollection`1<ISchemaError> errors);
    public static void EnsureFieldNamesAreValid(IComplexOutputType type, ICollection`1<ISchemaError> errors);
    public static void EnsureFieldNamesAreValid(InputObjectType type, ICollection`1<ISchemaError> errors);
    public static void EnsureArgumentNamesAreValid(DirectiveType type, ICollection`1<ISchemaError> errors);
    public static void EnsureInterfacesAreCorrectlyImplemented(IComplexOutputType type, ICollection`1<ISchemaError> errors);
    private static void ValidateImplementation(IComplexOutputType type, IInterfaceType implementedType, ICollection`1<ISchemaError> errors);
    private static void ValidateArguments(IOutputField field, IOutputField implementedField, ICollection`1<ISchemaError> errors);
    private static bool IsFullyImplementingInterface(IComplexOutputType type, IInterfaceType implementedType);
    private static bool IsValidImplementationFieldType(IOutputType fieldType, IOutputType implementedType);
    private static bool StartsWithTwoUnderscores(string name);
}
public class HotChocolate.CreateConvention : MulticastDelegate {
    public CreateConvention(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IConvention Invoke(IServiceProvider services);
    public virtual IAsyncResult BeginInvoke(IServiceProvider services, AsyncCallback callback, object object);
    public virtual IConvention EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class HotChocolate.DirectiveTypeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISchemaBuilder AddCostDirectiveType(ISchemaBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class HotChocolate.Execution.Processing.ArgumentMap : object {
    private Dictionary`2<string, ArgumentValue> _arguments;
    private bool _isFinal;
    private bool _hasErrors;
    [CompilerGeneratedAttribute]
private static ArgumentMap <Empty>k__BackingField;
    public static ArgumentMap Empty { get; }
    public ArgumentValue Item { get; }
    public bool IsFullyCoercedNoErrors { get; }
    public bool HasErrors { get; }
    public int Count { get; }
    private IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.Keys { get; }
    private IEnumerable`1<ArgumentValue> System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.Values { get; }
    internal ArgumentMap(Dictionary`2<string, ArgumentValue> arguments);
    private static ArgumentMap();
    [CompilerGeneratedAttribute]
public static ArgumentMap get_Empty();
    public sealed virtual ArgumentValue get_Item(string name);
    public bool get_IsFullyCoercedNoErrors();
    public bool get_HasErrors();
    public sealed virtual int get_Count();
    private sealed virtual override IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.get_Keys();
    private sealed virtual override IEnumerable`1<ArgumentValue> System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.get_Values();
    public bool ContainsName(string name);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.ContainsKey(string key);
    public bool TryGetValue(string name, ArgumentValue& value);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,HotChocolate.Resolvers.ArgumentValue>.TryGetValue(string key, ArgumentValue& value);
    public sealed virtual IEnumerator`1<ArgumentValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, ArgumentValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,HotChocolate.Resolvers.ArgumentValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Execution.Processing.IFragment {
    public int Id { get; }
    public IObjectType TypeCondition { get; }
    public ISyntaxNode SyntaxNode { get; }
    public IReadOnlyList`1<DirectiveNode> Directives { get; }
    public ISelectionSet SelectionSet { get; }
    public abstract virtual int get_Id();
    public abstract virtual IObjectType get_TypeCondition();
    public abstract virtual ISyntaxNode get_SyntaxNode();
    public abstract virtual IReadOnlyList`1<DirectiveNode> get_Directives();
    public abstract virtual ISelectionSet get_SelectionSet();
    public abstract virtual string GetLabel(IVariableValueCollection variables);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Execution.Processing.IOperation {
    public string Id { get; }
    public DocumentNode Document { get; }
    public OperationDefinitionNode Definition { get; }
    public ObjectType RootType { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public OperationType Type { get; }
    public ISelectionSet RootSelectionSet { get; }
    public IReadOnlyList`1<ISelectionVariants> SelectionVariants { get; }
    public bool HasIncrementalParts { get; }
    public abstract virtual string get_Id();
    public abstract virtual DocumentNode get_Document();
    public abstract virtual OperationDefinitionNode get_Definition();
    public abstract virtual ObjectType get_RootType();
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
    public abstract virtual OperationType get_Type();
    public abstract virtual ISelectionSet get_RootSelectionSet();
    public abstract virtual IReadOnlyList`1<ISelectionVariants> get_SelectionVariants();
    public abstract virtual bool get_HasIncrementalParts();
    public abstract virtual ISelectionSet GetSelectionSet(ISelection selection, IObjectType typeContext);
    public abstract virtual IEnumerable`1<IObjectType> GetPossibleTypes(ISelection selection);
    public abstract virtual long CreateIncludeFlags(IVariableValueCollection variables);
}
public interface HotChocolate.Execution.Processing.IOptionalSelection {
    public bool IsInternal { get; }
    public bool IsConditional { get; }
    public abstract virtual bool get_IsInternal();
    public abstract virtual bool get_IsConditional();
    public abstract virtual bool IsIncluded(long includeFlags, bool allowInternals);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Execution.Processing.ISelection {
    public int Id { get; }
    public string ResponseName { get; }
    public IObjectField Field { get; }
    public IType Type { get; }
    public TypeKind TypeKind { get; }
    public bool IsList { get; }
    public IObjectType DeclaringType { get; }
    public ISelectionSet DeclaringSelectionSet { get; }
    public FieldNode SyntaxNode { get; }
    [NullableAttribute("2")]
public SelectionSetNode SelectionSet { get; }
    public SelectionExecutionStrategy Strategy { get; }
    [NullableAttribute("2")]
public FieldDelegate ResolverPipeline { get; }
    [NullableAttribute("2")]
public PureFieldDelegate PureResolver { get; }
    public ArgumentMap Arguments { get; }
    public bool HasStreamResult { get; }
    public abstract virtual int get_Id();
    public abstract virtual string get_ResponseName();
    public abstract virtual IObjectField get_Field();
    public abstract virtual IType get_Type();
    public abstract virtual TypeKind get_TypeKind();
    public abstract virtual bool get_IsList();
    public abstract virtual IObjectType get_DeclaringType();
    public abstract virtual ISelectionSet get_DeclaringSelectionSet();
    public abstract virtual FieldNode get_SyntaxNode();
    [NullableContextAttribute("2")]
public abstract virtual SelectionSetNode get_SelectionSet();
    public abstract virtual SelectionExecutionStrategy get_Strategy();
    [NullableContextAttribute("2")]
public abstract virtual FieldDelegate get_ResolverPipeline();
    [NullableContextAttribute("2")]
public abstract virtual PureFieldDelegate get_PureResolver();
    public abstract virtual ArgumentMap get_Arguments();
    public abstract virtual bool get_HasStreamResult();
    public abstract virtual bool HasStreamDirective(long includeFlags);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Execution.Processing.ISelectionSet {
    public int Id { get; }
    public bool IsConditional { get; }
    public IReadOnlyList`1<ISelection> Selections { get; }
    public IReadOnlyList`1<IFragment> Fragments { get; }
    public abstract virtual int get_Id();
    public abstract virtual bool get_IsConditional();
    public abstract virtual IReadOnlyList`1<ISelection> get_Selections();
    public abstract virtual IReadOnlyList`1<IFragment> get_Fragments();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Execution.Processing.ISelectionVariants {
    public int Id { get; }
    public abstract virtual int get_Id();
    public abstract virtual IEnumerable`1<IObjectType> GetPossibleTypes();
    public abstract virtual bool IsPossibleType(IObjectType typeContext);
    public abstract virtual ISelectionSet GetSelectionSet(IObjectType typeContext);
}
public enum HotChocolate.Execution.Processing.SelectionExecutionStrategy : Enum {
    public int value__;
    public static SelectionExecutionStrategy Default;
    public static SelectionExecutionStrategy Serial;
    public static SelectionExecutionStrategy Pure;
}
public interface HotChocolate.IFluent {
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
}
public enum HotChocolate.Internal.ArgumentKind : Enum {
    public int value__;
    public static ArgumentKind Argument;
    public static ArgumentKind Source;
    public static ArgumentKind Service;
    public static ArgumentKind Schema;
    public static ArgumentKind ObjectType;
    public static ArgumentKind Field;
    public static ArgumentKind DocumentSyntax;
    public static ArgumentKind OperationDefinitionSyntax;
    public static ArgumentKind Operation;
    public static ArgumentKind FieldSyntax;
    public static ArgumentKind Selection;
    public static ArgumentKind Context;
    public static ArgumentKind CancellationToken;
    public static ArgumentKind GlobalState;
    public static ArgumentKind ScopedState;
    public static ArgumentKind LocalState;
    public static ArgumentKind EventMessage;
    public static ArgumentKind Custom;
}
public abstract class HotChocolate.Internal.CustomParameterExpressionBuilder : object {
    private ArgumentKind HotChocolate.Internal.IParameterExpressionBuilder.Kind { get; }
    private bool HotChocolate.Internal.IParameterExpressionBuilder.IsPure { get; }
    private bool HotChocolate.Internal.IParameterExpressionBuilder.IsDefaultHandler { get; }
    private sealed virtual override ArgumentKind HotChocolate.Internal.IParameterExpressionBuilder.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.IParameterExpressionBuilder.get_IsPure();
    private sealed virtual override bool HotChocolate.Internal.IParameterExpressionBuilder.get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public abstract virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public abstract virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Internal.CustomParameterExpressionBuilder`1 : CustomParameterExpressionBuilder {
    private Func`2<ParameterInfo, bool> _canHandle;
    private Expression`1<Func`2<IResolverContext, TArg>> _expression;
    public CustomParameterExpressionBuilder`1(Expression`1<Func`2<IResolverContext, TArg>> expression);
    public CustomParameterExpressionBuilder`1(Expression`1<Func`2<IResolverContext, TArg>> expression, Func`2<ParameterInfo, bool> canHandle);
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
}
public class HotChocolate.Internal.CustomServiceParameterExpressionBuilder`1 : object {
    private static Type _serviceType;
    private ServiceKind _kind;
    private ArgumentKind HotChocolate.Internal.IParameterExpressionBuilder.Kind { get; }
    private bool HotChocolate.Internal.IParameterExpressionBuilder.IsDefaultHandler { get; }
    private bool HotChocolate.Internal.IParameterExpressionBuilder.IsPure { get; }
    public CustomServiceParameterExpressionBuilder`1(ServiceKind kind);
    private static CustomServiceParameterExpressionBuilder`1();
    private sealed virtual override ArgumentKind HotChocolate.Internal.IParameterExpressionBuilder.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.IParameterExpressionBuilder.get_IsDefaultHandler();
    private sealed virtual override bool HotChocolate.Internal.IParameterExpressionBuilder.get_IsPure();
    public sealed virtual bool CanHandle(ParameterInfo parameter);
    public sealed virtual void ApplyConfiguration(ParameterInfo parameter, ObjectFieldDescriptor descriptor);
    public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Internal.ExtendedMethodInfo : object {
    [CompilerGeneratedAttribute]
private IExtendedType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ParameterInfo, IExtendedType> <ParameterTypes>k__BackingField;
    public IExtendedType ReturnType { get; }
    public IReadOnlyDictionary`2<ParameterInfo, IExtendedType> ParameterTypes { get; }
    public ExtendedMethodInfo(IExtendedType returnType, IReadOnlyDictionary`2<ParameterInfo, IExtendedType> parameterTypes);
    [CompilerGeneratedAttribute]
public IExtendedType get_ReturnType();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ParameterInfo, IExtendedType> get_ParameterTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Internal.ExtendedType : object {
    [CompilerGeneratedAttribute]
private ExtendedTypeId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Source>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedTypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExtendedType> <TypeArguments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExtendedType <ElementType>k__BackingField;
    public ExtendedTypeId Id { get; }
    public Type Type { get; }
    public Type Source { get; }
    [NullableAttribute("2")]
public Type Definition { get; }
    public ExtendedTypeKind Kind { get; }
    public bool IsGeneric { get; }
    public bool IsArray { get; }
    public bool IsList { get; }
    public bool IsArrayOrList { get; }
    public bool IsNamedType { get; }
    public bool IsSchemaType { get; }
    public bool IsInterface { get; }
    public bool IsNullable { get; }
    public IReadOnlyList`1<ExtendedType> TypeArguments { get; }
    private IReadOnlyList`1<IExtendedType> HotChocolate.Internal.IExtendedType.TypeArguments { get; }
    [NullableAttribute("2")]
public ExtendedType ElementType { get; }
    [NullableAttribute("2")]
private IExtendedType HotChocolate.Internal.IExtendedType.ElementType { get; }
    [NullableContextAttribute("2")]
private ExtendedType(Type type, ExtendedTypeKind kind, IReadOnlyList`1<ExtendedType> typeArguments, Type source, Type definition, ExtendedType elementType, bool isList, bool isNamedType, bool isNullable);
    [CompilerGeneratedAttribute]
public ExtendedTypeId get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Type get_Definition();
    [CompilerGeneratedAttribute]
public sealed virtual ExtendedTypeKind get_Kind();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsArray();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsList();
    public sealed virtual bool get_IsArrayOrList();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNamedType();
    public sealed virtual bool get_IsSchemaType();
    public sealed virtual bool get_IsInterface();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNullable();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ExtendedType> get_TypeArguments();
    private sealed virtual override IReadOnlyList`1<IExtendedType> HotChocolate.Internal.IExtendedType.get_TypeArguments();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExtendedType get_ElementType();
    [NullableContextAttribute("2")]
private sealed virtual override IExtendedType HotChocolate.Internal.IExtendedType.get_ElementType();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IExtendedType other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ExtendedType FromType(Type type, TypeCache cache);
    private static ExtendedType FromTypeInternal(Type type, TypeCache cache);
    public static ExtendedType FromMember(MemberInfo member, TypeCache cache);
    public static ExtendedMethodInfo FromMethod(MethodInfo method, TypeCache cache);
}
[ExtensionAttribute]
public static class HotChocolate.Internal.ExtendedTypeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAssignableFrom(Type type, IExtendedType extendedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class HotChocolate.Internal.ExtendedTypeId : ValueType {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedTypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Nullability>k__BackingField;
    public Type Type { get; }
    public ExtendedTypeKind Kind { get; }
    public UInt32 Nullability { get; }
    public ExtendedTypeId(Type type, ExtendedTypeKind kind, UInt32 nullability);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ExtendedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public UInt32 get_Nullability();
    public bool Equals(ExtendedTypeId other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum HotChocolate.Internal.ExtendedTypeKind : Enum {
    public int value__;
    public static ExtendedTypeKind Runtime;
    public static ExtendedTypeKind Extended;
    public static ExtendedTypeKind Schema;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Internal.FieldInitHelper : object {
    internal static IValueNode CompleteDefaultValue(ITypeCompletionContext context, ArgumentDefinition argumentDefinition, IInputType argumentType, FieldCoordinate argumentCoordinate);
    public static FieldCollection`1<TField> CompleteFields(ITypeCompletionContext context, ITypeSystemMember declaringMember, IReadOnlyList`1<TFieldDefinition> fieldDefs, Func`3<TFieldDefinition, int, TField> fieldFactory);
    public static FieldCollection`1<TField> CompleteFields(ITypeCompletionContext context, ITypeSystemMember declaringMember, IEnumerable`1<TFieldDefinition> fieldDefs, Func`3<TFieldDefinition, int, TField> fieldFactory, int maxFieldCount);
    public static FieldCollection`1<TField> CompleteFields(ITypeCompletionContext context, ITypeSystemMember declaringMember, TField[] fields);
    public static FieldCollection`1<TField> CompleteFieldsInternal(ITypeCompletionContext context, ITypeSystemMember declaringMember, IEnumerable`1<TFieldDefinition> fieldDefinitions, Func`3<TFieldDefinition, int, TField> fieldFactory, int fieldCount);
    private static FieldCollection`1<TField> CompleteFieldsInternal(ITypeCompletionContext context, ITypeSystemMember declaringMember, TField[] fields);
    internal static Type CompleteRuntimeType(IType type, Type runtimeType);
    internal static Type CompleteRuntimeType(IType type, Type runtimeType, Boolean& isOptional);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Internal.IExtendedType {
    public Type Type { get; }
    public Type Source { get; }
    [NullableAttribute("2")]
public Type Definition { get; }
    public ExtendedTypeKind Kind { get; }
    public bool IsGeneric { get; }
    public bool IsArray { get; }
    public bool IsList { get; }
    public bool IsArrayOrList { get; }
    public bool IsNamedType { get; }
    public bool IsSchemaType { get; }
    public bool IsInterface { get; }
    public bool IsNullable { get; }
    public IReadOnlyList`1<IExtendedType> TypeArguments { get; }
    [NullableAttribute("2")]
public IExtendedType ElementType { get; }
    public abstract virtual Type get_Type();
    public abstract virtual Type get_Source();
    [NullableContextAttribute("2")]
public abstract virtual Type get_Definition();
    public abstract virtual ExtendedTypeKind get_Kind();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsList();
    public abstract virtual bool get_IsArrayOrList();
    public abstract virtual bool get_IsNamedType();
    public abstract virtual bool get_IsSchemaType();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsNullable();
    public abstract virtual IReadOnlyList`1<IExtendedType> get_TypeArguments();
    [NullableContextAttribute("2")]
public abstract virtual IExtendedType get_ElementType();
}
public interface HotChocolate.Internal.IParameterExpressionBuilder {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public abstract virtual ArgumentKind get_Kind();
    public abstract virtual bool get_IsPure();
    public abstract virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public abstract virtual Expression Build(ParameterExpressionBuilderContext context);
}
public interface HotChocolate.Internal.IParameterFieldConfiguration {
    public abstract virtual void ApplyConfiguration(ParameterInfo parameter, ObjectFieldDescriptor descriptor);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Internal.IParameterHandler {
    public abstract virtual bool CanHandle(ParameterInfo parameter);
}
public interface HotChocolate.Internal.ITypeAttribute {
    public bool Inherited { get; public set; }
    public TypeKind Kind { get; }
    public bool IsTypeExtension { get; }
    public abstract virtual bool get_Inherited();
    public abstract virtual void set_Inherited(bool value);
    public abstract virtual TypeKind get_Kind();
    public abstract virtual bool get_IsTypeExtension();
}
public interface HotChocolate.Internal.ITypeFactory {
    public abstract virtual IType CreateType(INamedType namedType);
}
public interface HotChocolate.Internal.ITypeInfo {
    public Type NamedType { get; }
    public Type OriginalType { get; }
    public IReadOnlyList`1<TypeComponent> Components { get; }
    public bool IsSchemaType { get; }
    public bool IsRuntimeType { get; }
    public abstract virtual Type get_NamedType();
    public abstract virtual Type get_OriginalType();
    public abstract virtual IReadOnlyList`1<TypeComponent> get_Components();
    public abstract virtual bool get_IsSchemaType();
    public abstract virtual bool get_IsRuntimeType();
    public abstract virtual bool IsInputType();
    public abstract virtual bool IsOutputType();
    public abstract virtual IExtendedType GetExtendedType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class HotChocolate.Internal.ParameterExpressionBuilderContext : ValueType {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <ResolverContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    public ParameterInfo Parameter { get; }
    public Expression ResolverContext { get; }
    [NullableAttribute("2")]
public string ArgumentName { get; }
    internal ParameterExpressionBuilderContext(ParameterInfo parameter, Expression resolverContext, IReadOnlyDictionary`2<ParameterInfo, string> argumentNameLookup);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public Expression get_ResolverContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ArgumentName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Internal.TypeCache : object {
    private object _sync;
    private Dictionary`2<ExtendedTypeId, ExtendedType> _types;
    private Dictionary`2<object, ExtendedType> _typeMemberLookup;
    private Dictionary`2<ExtendedTypeId, TypeInfo> _typeInfos;
    public ExtendedType GetType(ExtendedTypeId id);
    [NullableContextAttribute("2")]
public bool TryGetType(ExtendedTypeId id, ExtendedType& extendedType);
    public bool TryGetType(Type type, ExtendedType& extendedType);
    public ExtendedType GetOrCreateType(object member, Func`1<ExtendedType> create);
    public bool TryAdd(ExtendedType extendedType, object member);
    public TypeInfo GetOrCreateTypeInfo(IExtendedType extendedType, Func`1<TypeInfo> create);
}
[IsReadOnlyAttribute]
public class HotChocolate.Internal.TypeComponent : ValueType {
    [CompilerGeneratedAttribute]
private TypeComponentKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IExtendedType <Type>k__BackingField;
    public TypeComponentKind Kind { get; }
    public IExtendedType Type { get; }
    public TypeComponent(TypeComponentKind kind, IExtendedType type);
    [CompilerGeneratedAttribute]
public TypeComponentKind get_Kind();
    [CompilerGeneratedAttribute]
public IExtendedType get_Type();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static TypeComponent op_Implicit(ValueTuple`2<TypeComponentKind, IExtendedType> component);
}
public enum HotChocolate.Internal.TypeComponentKind : Enum {
    public int value__;
    public static TypeComponentKind NonNull;
    public static TypeComponentKind List;
    public static TypeComponentKind Named;
}
[ExtensionAttribute]
public static class HotChocolate.Internal.TypeDependencyHelper : object {
    public static void CollectDependencies(InterfaceTypeDefinition definition, ICollection`1<TypeDependency> dependencies);
    public static void CollectDependencies(ObjectTypeDefinition definition, ICollection`1<TypeDependency> dependencies);
    public static void CollectDependencies(InputObjectTypeDefinition definition, ICollection`1<TypeDependency> dependencies);
    public static void CollectDependencies(EnumTypeDefinition definition, ICollection`1<TypeDependency> dependencies);
    public static void CollectDependencies(DirectiveTypeDefinition definition, ICollection`1<TypeDependency> dependencies);
    internal static void CollectDirectiveDependencies(TypeDefinitionBase`1<T> definition, ICollection`1<TypeDependency> dependencies);
    private static void CollectDirectiveDependencies(FieldDefinitionBase definition, ICollection`1<TypeDependency> dependencies);
    private static void CollectFieldDependencies(IReadOnlyList`1<OutputFieldDefinitionBase> fields, ICollection`1<TypeDependency> dependencies);
    private static void CollectArgumentDependencies(IReadOnlyList`1<ArgumentDefinition> fields, ICollection`1<TypeDependency> dependencies);
    [ExtensionAttribute]
public static void RegisterDependencies(ITypeDiscoveryContext context, ObjectTypeDefinition definition);
    [ExtensionAttribute]
public static void RegisterDependencies(ITypeDiscoveryContext context, InterfaceTypeDefinition definition);
    [ExtensionAttribute]
public static void RegisterDependencies(ITypeDiscoveryContext context, EnumTypeDefinition definition);
    [ExtensionAttribute]
public static void RegisterDependencies(ITypeDiscoveryContext context, InputObjectTypeDefinition definition);
    private static TypeDependencyFulfilled GetDefaultValueDependencyKind(ArgumentDefinition argumentDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Internal.TypeDiscoveryHandler : object {
    public abstract virtual bool TryInferType(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeReference[]& schemaTypeRefs);
    public virtual bool TryInferKind(TypeReference typeReference, TypeDiscoveryInfo typeInfo, TypeKind& typeKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class HotChocolate.Internal.TypeDiscoveryInfo : ValueType {
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITypeAttribute <Attribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbstract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirectiveRef>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeContext <Context>k__BackingField;
    public Type RuntimeType { get; }
    [NullableAttribute("2")]
public ITypeAttribute Attribute { get; }
    public bool IsInterface { get; }
    public bool IsComplex { get; }
    public bool IsAbstract { get; }
    public bool IsStatic { get; }
    public bool IsEnum { get; }
    public bool IsPublic { get; }
    public bool IsDirectiveRef { get; }
    public TypeContext Context { get; }
    public TypeDiscoveryInfo(TypeReference typeReference);
    [CompilerGeneratedAttribute]
public Type get_RuntimeType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITypeAttribute get_Attribute();
    [CompilerGeneratedAttribute]
public bool get_IsInterface();
    [CompilerGeneratedAttribute]
public bool get_IsComplex();
    [CompilerGeneratedAttribute]
public bool get_IsAbstract();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public bool get_IsEnum();
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public bool get_IsDirectiveRef();
    [CompilerGeneratedAttribute]
public TypeContext get_Context();
    private static ITypeAttribute GetTypeAttributeInternal(Type runtimeType);
    private static bool IsComplexTypeInternal(IExtendedType unresolvedType, bool isPublic);
    private static bool IsPublicInternal(Type runtimeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Internal.TypeExtensionHelper : object {
    public static void MergeInterfaceFields(ITypeCompletionContext context, IList`1<InterfaceFieldDefinition> extensionFields, IList`1<InterfaceFieldDefinition> typeFields);
    public static void MergeInputObjectFields(ITypeCompletionContext context, IList`1<InputFieldDefinition> extensionFields, IList`1<InputFieldDefinition> typeFields);
    private static void MergeOutputFields(ITypeCompletionContext context, IList`1<T> extensionFields, IList`1<T> typeFields, Action`3<IList`1<T>, T, T> action, Action`1<T> onBeforeAdd);
    private static void MergeFields(ITypeCompletionContext context, IList`1<T> extensionFields, IList`1<T> typeFields, Action`3<IList`1<T>, T, T> action, Action`1<T> onBeforeAdd);
    public static void MergeDirectives(ITypeCompletionContext context, IList`1<DirectiveDefinition> extension, IList`1<DirectiveDefinition> type);
    private static void MergeDirective(ITypeCompletionContext context, IList`1<ValueTuple`2<DirectiveType, DirectiveDefinition>> directives, DirectiveDefinition directive);
    public static void MergeContextData(DefinitionBase extension, DefinitionBase type);
    public static void MergeInterfaces(ObjectTypeDefinition extension, ObjectTypeDefinition type);
    public static void MergeTypes(ICollection`1<TypeReference> extensionTypes, ICollection`1<TypeReference> typeTypes);
    public static void MergeConfigurations(ICollection`1<ITypeSystemMemberConfiguration> extensionConfigurations, ICollection`1<ITypeSystemMemberConfiguration> typeConfigurations);
}
[ExtensionAttribute]
public static class HotChocolate.Internal.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsSchemaType(Type type);
    [ExtensionAttribute]
internal static bool IsNonGenericSchemaType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Internal.TypeInfo : object {
    private IExtendedType _extendedType;
    [CompilerGeneratedAttribute]
private Type <NamedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OriginalType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TypeComponent> <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSchemaType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRuntimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    public Type NamedType { get; }
    public Type OriginalType { get; }
    public IReadOnlyList`1<TypeComponent> Components { get; }
    public bool IsSchemaType { get; }
    public bool IsRuntimeType { get; }
    public bool IsValid { get; }
    private TypeInfo(Type namedType, Type originalType, IReadOnlyList`1<TypeComponent> components, bool isSchemaType, IExtendedType extendedType, bool isStructureValid);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_NamedType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_OriginalType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<TypeComponent> get_Components();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSchemaType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRuntimeType();
    public sealed virtual IExtendedType GetExtendedType();
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    public sealed virtual bool IsInputType();
    public sealed virtual bool IsOutputType();
    public sealed virtual IType CreateType(INamedType namedType);
    public static TypeInfo Create(IExtendedType type, TypeCache cache);
    public static bool TryCreate(IExtendedType type, TypeCache cache, TypeInfo& typeInfo);
    private static TypeInfo CreateInternal(IExtendedType type, Type originalType, TypeCache cache);
    private static bool IsStructureValid(IReadOnlyList`1<TypeComponent> components);
}
[ExtensionAttribute]
internal static class HotChocolate.Internal.TypeInfoExtensions : object {
    [ExtensionAttribute]
internal static IType CreateType(ITypeInfo typeInfo, INamedType namedType);
}
public class HotChocolate.InvalidSchemaCoordinateException : Exception {
    [CompilerGeneratedAttribute]
private SchemaCoordinate <Coordinate>k__BackingField;
    public SchemaCoordinate Coordinate { get; }
    [NullableContextAttribute("1")]
public InvalidSchemaCoordinateException(string message, SchemaCoordinate coordinate);
    [CompilerGeneratedAttribute]
public SchemaCoordinate get_Coordinate();
}
[NullableContextAttribute("2")]
public interface HotChocolate.IReadOnlySchemaOptions {
    public string QueryTypeName { get; }
    public string MutationTypeName { get; }
    public string SubscriptionTypeName { get; }
    public bool StrictValidation { get; }
    public bool UseXmlDocumentation { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Assembly, string> ResolveXmlDocumentationFileName { get; }
    public bool SortFieldsByName { get; }
    public bool PreserveSyntaxNodes { get; }
    public bool RemoveUnreachableTypes { get; }
    public bool RemoveUnusedTypeSystemDirectives { get; }
    public BindingBehavior DefaultBindingBehavior { get; }
    public FieldBindingFlags DefaultFieldBindingFlags { get; }
    public FieldMiddlewareApplication FieldMiddleware { get; }
    public bool EnableDirectiveIntrospection { get; }
    public DirectiveVisibility DefaultDirectiveVisibility { get; }
    public ExecutionStrategy DefaultResolverStrategy { get; }
    public bool ValidatePipelineOrder { get; }
    public bool StrictRuntimeTypeValidation { get; }
    public IsOfTypeFallback DefaultIsOfTypeCheck { get; }
    public bool EnableOneOf { get; }
    public bool EnsureAllNodesCanBeResolved { get; }
    public bool EnableFlagEnums { get; }
    public bool EnableDefer { get; }
    public bool EnableStream { get; }
    public int MaxAllowedNodeBatchSize { get; }
    public bool StripLeadingIFromInterface { get; }
    public bool EnableTrueNullability { get; }
    public bool EnableTag { get; }
    public abstract virtual string get_QueryTypeName();
    public abstract virtual string get_MutationTypeName();
    public abstract virtual string get_SubscriptionTypeName();
    public abstract virtual bool get_StrictValidation();
    public abstract virtual bool get_UseXmlDocumentation();
    public abstract virtual Func`2<Assembly, string> get_ResolveXmlDocumentationFileName();
    public abstract virtual bool get_SortFieldsByName();
    public abstract virtual bool get_PreserveSyntaxNodes();
    public abstract virtual bool get_RemoveUnreachableTypes();
    public abstract virtual bool get_RemoveUnusedTypeSystemDirectives();
    public abstract virtual BindingBehavior get_DefaultBindingBehavior();
    public abstract virtual FieldBindingFlags get_DefaultFieldBindingFlags();
    public abstract virtual FieldMiddlewareApplication get_FieldMiddleware();
    public abstract virtual bool get_EnableDirectiveIntrospection();
    public abstract virtual DirectiveVisibility get_DefaultDirectiveVisibility();
    public abstract virtual ExecutionStrategy get_DefaultResolverStrategy();
    public abstract virtual bool get_ValidatePipelineOrder();
    public abstract virtual bool get_StrictRuntimeTypeValidation();
    public abstract virtual IsOfTypeFallback get_DefaultIsOfTypeCheck();
    public abstract virtual bool get_EnableOneOf();
    public abstract virtual bool get_EnsureAllNodesCanBeResolved();
    public abstract virtual bool get_EnableFlagEnums();
    public abstract virtual bool get_EnableDefer();
    public abstract virtual bool get_EnableStream();
    public abstract virtual int get_MaxAllowedNodeBatchSize();
    public abstract virtual bool get_StripLeadingIFromInterface();
    public abstract virtual bool get_EnableTrueNullability();
    public abstract virtual bool get_EnableTag();
}
[NullableContextAttribute("1")]
public interface HotChocolate.ISchema {
    [NullableAttribute("2")]
public IServiceProvider Services { get; }
    public ObjectType QueryType { get; }
    [NullableAttribute("2")]
public ObjectType MutationType { get; }
    [NullableAttribute("2")]
public ObjectType SubscriptionType { get; }
    public IReadOnlyCollection`1<INamedType> Types { get; }
    public IReadOnlyCollection`1<DirectiveType> DirectiveTypes { get; }
    [NullableContextAttribute("2")]
public abstract virtual IServiceProvider get_Services();
    public abstract virtual ObjectType get_QueryType();
    [NullableContextAttribute("2")]
public abstract virtual ObjectType get_MutationType();
    [NullableContextAttribute("2")]
public abstract virtual ObjectType get_SubscriptionType();
    public abstract virtual IReadOnlyCollection`1<INamedType> get_Types();
    public abstract virtual IReadOnlyCollection`1<DirectiveType> get_DirectiveTypes();
    public abstract virtual T GetType(string typeName);
    public abstract virtual bool TryGetType(string typeName, T& type);
    public abstract virtual bool TryGetRuntimeType(string typeName, Type& runtimeType);
    public abstract virtual IReadOnlyList`1<ObjectType> GetPossibleTypes(INamedType abstractType);
    public abstract virtual DirectiveType GetDirectiveType(string directiveName);
    public abstract virtual bool TryGetDirectiveType(string directiveName, DirectiveType& directiveType);
    public abstract virtual DocumentNode ToDocument(bool includeSpecScalars);
    public abstract virtual string Print();
    public abstract virtual string ToString();
}
[NullableContextAttribute("1")]
public interface HotChocolate.ISchemaBuilder {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    public abstract virtual IDictionary`2<string, object> get_ContextData();
    public abstract virtual ISchemaBuilder SetSchema(Type type);
    public abstract virtual ISchemaBuilder SetSchema(ISchema schema);
    public abstract virtual ISchemaBuilder SetSchema(Action`1<ISchemaTypeDescriptor> configure);
    public abstract virtual ISchemaBuilder SetOptions(IReadOnlySchemaOptions options);
    public abstract virtual ISchemaBuilder ModifyOptions(Action`1<SchemaOptions> configure);
    public abstract virtual ISchemaBuilder Use(FieldMiddleware middleware);
    public abstract virtual ISchemaBuilder AddDocument(LoadSchemaDocument loadDocument);
    public abstract virtual ISchemaBuilder AddType(Type type);
    public abstract virtual ISchemaBuilder AddType(INamedType namedType);
    public abstract virtual ISchemaBuilder AddType(INamedTypeExtension typeExtension);
    [ObsoleteAttribute("Use BindRuntimeType")]
public abstract virtual ISchemaBuilder BindClrType(Type clrType, Type schemaType);
    public abstract virtual ISchemaBuilder BindRuntimeType(Type runtimeType, Type schemaType);
    public abstract virtual ISchemaBuilder AddRootType(Type rootType, OperationType operation);
    public abstract virtual ISchemaBuilder AddRootType(ObjectType rootType, OperationType operation);
    public abstract virtual ISchemaBuilder TryAddRootType(Func`1<ObjectType> rootType, OperationType operation);
    public abstract virtual ISchemaBuilder AddDirectiveType(DirectiveType type);
    public abstract virtual ISchemaBuilder SetTypeResolver(IsOfTypeFallback isOfType);
    public abstract virtual ISchemaBuilder AddServices(IServiceProvider services);
    public abstract virtual ISchemaBuilder SetContextData(string key, object value);
    public abstract virtual ISchemaBuilder SetContextData(string key, Func`2<object, object> update);
    public abstract virtual ISchemaBuilder TryAddTypeInterceptor(Type interceptor);
    public abstract virtual ISchemaBuilder TryAddTypeInterceptor(TypeInterceptor interceptor);
    public abstract virtual ISchemaBuilder AddConvention(Type convention, CreateConvention factory, string scope);
    public abstract virtual ISchemaBuilder TryAddConvention(Type convention, CreateConvention factory, string scope);
    public abstract virtual ISchema Create();
    public abstract virtual ISchema Create(IDescriptorContext context);
    public abstract virtual IDescriptorContext CreateContext();
}
[NullableContextAttribute("1")]
public interface HotChocolate.ISchemaError {
    public string Message { get; }
    [NullableAttribute("2")]
public string Code { get; }
    [NullableAttribute("2")]
public ITypeSystemObject TypeSystemObject { get; }
    public IReadOnlyCollection`1<ISyntaxNode> SyntaxNodes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<object> Path { get; }
    public IReadOnlyDictionary`2<string, object> Extensions { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    public abstract virtual string get_Message();
    [NullableContextAttribute("2")]
public abstract virtual string get_Code();
    [NullableContextAttribute("2")]
public abstract virtual ITypeSystemObject get_TypeSystemObject();
    public abstract virtual IReadOnlyCollection`1<ISyntaxNode> get_SyntaxNodes();
    public abstract virtual IReadOnlyCollection`1<object> get_Path();
    public abstract virtual IReadOnlyDictionary`2<string, object> get_Extensions();
    [NullableContextAttribute("2")]
public abstract virtual Exception get_Exception();
}
public interface HotChocolate.ISchemaErrorBuilder {
    public abstract virtual ISchemaErrorBuilder SetMessage(string message);
    public abstract virtual ISchemaErrorBuilder SetCode(string code);
    public abstract virtual ISchemaErrorBuilder SetPath(IReadOnlyCollection`1<object> path);
    public abstract virtual ISchemaErrorBuilder SetPath(Path path);
    public abstract virtual ISchemaErrorBuilder SetTypeSystemObject(ITypeSystemObject typeSystemObject);
    public abstract virtual ISchemaErrorBuilder AddSyntaxNode(ISyntaxNode syntaxNode);
    public abstract virtual ISchemaErrorBuilder SetExtension(string key, object value);
    public abstract virtual ISchemaErrorBuilder SetException(Exception exception);
    public abstract virtual ISchemaError Build();
}
public class HotChocolate.LoadDocumentAsync : MulticastDelegate {
    public LoadDocumentAsync(object object, IntPtr method);
    public virtual ValueTask`1<DocumentNode> Invoke(IServiceProvider services, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(IServiceProvider services, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual ValueTask`1<DocumentNode> EndInvoke(IAsyncResult result);
}
public class HotChocolate.LoadSchemaDocument : MulticastDelegate {
    public LoadSchemaDocument(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual DocumentNode Invoke(IServiceProvider services);
    public virtual IAsyncResult BeginInvoke(IServiceProvider services, AsyncCallback callback, object object);
    public virtual DocumentNode EndInvoke(IAsyncResult result);
}
internal class HotChocolate.MapMiddleware : object {
    private FieldDelegate _next;
    private FieldReference _fieldReference;
    private FieldDelegate _fieldDelegate;
    public MapMiddleware(FieldDelegate next, FieldReference fieldReference, FieldDelegate fieldDelegate);
    public ValueTask InvokeAsync(IMiddlewareContext context);
    private bool IsField(string typeName, string fieldName);
}
internal static class HotChocolate.Properties.TypeResourceHelper : object {
    public static string Scalar_Cannot_Serialize(string typeName);
    public static string Scalar_Cannot_Deserialize(string typeName);
    public static string Scalar_Cannot_ParseLiteral(string typeName, Type literalType);
    public static string Scalar_Cannot_ParseValue(string typeName, Type valueType);
    public static string Scalar_Cannot_ParseResult(string typeName, Type valueType);
    public static string Type_Name_IsNotValid(string typeName);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HotChocolate.Properties.TypeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ThrowHelper_MissingDirectiveIfArgument { get; }
    internal static string ArgumentDescriptor_InputTypeViolation { get; }
    internal static string ArgumentValueBuilder_NonNull { get; }
    internal static string BooleanType_Description { get; }
    internal static string ByteType_Description { get; }
    internal static string ComplexTypeBindingBuilder_FieldBuilderNotSupported { get; }
    internal static string ComplexTypeBindingBuilder_FieldNotComplete { get; }
    internal static string DataLoaderRegistry_KeyNullOrEmpty { get; }
    internal static string DataLoaderResolverContextExtensions_RegistryIsNull { get; }
    internal static string DataLoaderResolverContextExtensions_UnableToRegister { get; }
    internal static string DateTimeType_Description { get; }
    internal static string DateType_Description { get; }
    internal static string DecimalType_Description { get; }
    internal static string DefaultTypeInspector_MemberInvalid { get; }
    internal static string DependencyDescriptorBase_OnlyTsoIsAllowed { get; }
    internal static string DirectiveCollection_DirectiveIsUnique { get; }
    internal static string DirectiveCollection_LocationNotAllowed { get; }
    internal static string DirectiveLocation_ArgumentDefinition { get; }
    internal static string DirectiveLocation_Description { get; }
    internal static string DirectiveLocation_Enum { get; }
    internal static string DirectiveLocation_EnumValue { get; }
    internal static string DirectiveLocation_Field { get; }
    internal static string DirectiveLocation_FieldDefinition { get; }
    internal static string DirectiveLocation_FragmentDefinition { get; }
    internal static string DirectiveLocation_FragmentSpread { get; }
    internal static string DirectiveLocation_InlineFragment { get; }
    internal static string DirectiveLocation_InputFieldDefinition { get; }
    internal static string DirectiveLocation_InputObject { get; }
    internal static string DirectiveLocation_Interface { get; }
    internal static string DirectiveLocation_Mutation { get; }
    internal static string DirectiveLocation_Object { get; }
    internal static string DirectiveLocation_Query { get; }
    internal static string DirectiveLocation_Scalar { get; }
    internal static string DirectiveLocation_Schema { get; }
    internal static string DirectiveLocation_Subscription { get; }
    internal static string DirectiveLocation_Union { get; }
    internal static string DirectiveTypeDescriptor_OnlyProperties { get; }
    internal static string DirectiveTypeFactory_LocationNotSupported { get; }
    internal static string DirectiveType_NoLocations { get; }
    internal static string DirectiveType_ReplaceWithUse { get; }
    internal static string DirectiveType_UnableToConvert { get; }
    internal static string Directive_Description { get; }
    internal static string Directive_UseLocation { get; }
    internal static string EnumTypeExtension_CannotMerge { get; }
    internal static string EnumTypeExtension_ValueTypeInvalid { get; }
    internal static string EnumType_NoValues { get; }
    internal static string EnumValue_Description { get; }
    internal static string EnumValue_ValueIsNull { get; }
    internal static string FieldInitHelper_InvalidDefaultValue { get; }
    internal static string FieldInitHelper_NoFields { get; }
    internal static string Field_Description { get; }
    internal static string FloatType_Description { get; }
    internal static string IdType_Description { get; }
    internal static string InputField_CannotSetValue { get; }
    internal static string InputObjectTypeExtension_CannotMerge { get; }
    internal static string InputObjectType_CannotParseLiteral { get; }
    internal static string InputObjectType_NoFields { get; }
    internal static string InputTypeNonNullCheck_ValueIsNull { get; }
    internal static string InputValue_DefaultValue { get; }
    internal static string InputValue_Description { get; }
    internal static string InterfaceImplRule_ArgumentsDontMatch { get; }
    internal static string InterfaceImplRule_ArgumentsNotImpl { get; }
    internal static string InterfaceImplRule_FieldNotImpl { get; }
    internal static string InterfaceImplRule_FieldTypeInvalid { get; }
    internal static string InterfaceImplRule_ReturnTypeInvalid { get; }
    internal static string InterfaceTypeExtension_CannotMerge { get; }
    internal static string IntType_Description { get; }
    internal static string LongType_Description { get; }
    internal static string MultiplierPathType_Description { get; }
    internal static string NameType_Description { get; }
    internal static string Name_Cannot_BeEmpty { get; }
    internal static string ObjectFieldDescriptorBase_FieldType { get; }
    internal static string ObjectTypeDescriptor_InterfaceBaseClass { get; }
    internal static string InterfaceTypeDescriptor_InterfaceBaseClass { get; }
    internal static string ObjectTypeDescriptor_MustBePropertyOrMethod { get; }
    internal static string ObjectTypeDescriptor_ResolveWith_NonAbstract { get; }
    internal static string NodeDescriptor_MustBeMethod { get; }
    internal static string NodeDescriptor_IdMember { get; }
    internal static string ObjectTypeDescriptor_Resolver_SchemaType { get; }
    internal static string Reflection_MemberMust_BeMethodOrProperty { get; }
    internal static string ResolverCompiler_UnknownParameterType { get; }
    internal static string ResolverTypeBindingBuilder_FieldBuilderNotSupported { get; }
    internal static string ResolverTypeBindingBuilder_FieldNotComplete { get; }
    internal static string Scalar_Cannot_Deserialize { get; }
    internal static string Scalar_Cannot_ParseLiteral { get; }
    internal static string Scalar_Cannot_ParseValue { get; }
    internal static string Scalar_Cannot_Serialize { get; }
    internal static string SchemaBuilderExtensions_DirectiveTypeIsBaseType { get; }
    internal static string SchemaBuilderExtensions_MustBeDirectiveType { get; }
    internal static string SchemaBuilderExtensions_SchemaIsEmpty { get; }
    internal static string SchemaBuilder_Binding_CannotBeHandled { get; }
    internal static string SchemaBuilder_Binding_Invalid { get; }
    internal static string SchemaBuilder_ISchemaNotTso { get; }
    internal static string SchemaBuilder_NoQueryType { get; }
    internal static string SchemaBuilder_RootType_MustBeClass { get; }
    internal static string SchemaBuilder_RootType_MustBeObjectType { get; }
    internal static string SchemaBuilder_RootType_NonGenericType { get; }
    internal static string SchemaBuilder_SchemaTypeInvalid { get; }
    internal static string SchemaErrorBuilder_MessageIsNull { get; }
    internal static string SchemaField_Description { get; }
    internal static string SchemaSyntaxVisitor_UnknownOperationType { get; }
    internal static string Schema_Description { get; }
    internal static string Schema_Directives { get; }
    internal static string Schema_MutationType { get; }
    internal static string Schema_QueryType { get; }
    internal static string Schema_SubscriptionType { get; }
    internal static string Schema_Types { get; }
    internal static string ShortType_Description { get; }
    internal static string StringType_Description { get; }
    internal static string String_Argument_NullOrEmpty { get; }
    internal static string TypeConfiguration_ConfigureIsNull { get; }
    internal static string TypeConfiguration_DefinitionIsNull { get; }
    internal static string TypeDependency_MustBeSchemaType { get; }
    internal static string TypeExtensions_InvalidStructure { get; }
    internal static string TypeExtensions_KindIsNotSupported { get; }
    internal static string TypeExtensions_NoListType { get; }
    internal static string TypeExtensions_TypeIsNotOfT { get; }
    internal static string TypeField_Description { get; }
    internal static string TypeInitializer_CannotResolveDependency { get; }
    internal static string TypeInitializer_CompleteName_Duplicate { get; }
    internal static string TypeInitializer_Merge_KindDoesNotMatch { get; }
    internal static string TypeKind_Description { get; }
    internal static string TypeKind_Enum { get; }
    internal static string TypeKind_InputObject { get; }
    internal static string TypeKind_Interface { get; }
    internal static string TypeKind_List { get; }
    internal static string TypeKind_NonNull { get; }
    internal static string TypeKind_Object { get; }
    internal static string TypeKind_Scalar { get; }
    internal static string TypeKind_Union { get; }
    internal static string TypeNameField_Description { get; }
    internal static string TypeNameHelper_InvalidTypeStructure { get; }
    internal static string TypeNameHelper_OnlyTsosAreAllowed { get; }
    internal static string TypeResourceHelper_TypeNameEmptyOrNull { get; }
    internal static string Type_Description { get; }
    internal static string UnionTypeExtension_CannotMerge { get; }
    internal static string VariableValueBuilder_InputType { get; }
    internal static string VariableValueBuilder_InvalidValue { get; }
    internal static string VariableValueBuilder_NodeKind { get; }
    internal static string VariableValueBuilder_NonNull { get; }
    internal static string VariableValueBuilder_NonNull_In_Graph { get; }
    internal static string VariableValueBuilder_VarNameEmpty { get; }
    internal static string Argument_TypeIsNull { get; }
    internal static string NonNullType_NotAnInputType { get; }
    internal static string NonNullType_TypeIsNunNullType { get; }
    internal static string NonNullType_ValueIsNull { get; }
    internal static string ObjectTypeExtension_CannotMerge { get; }
    internal static string TypeSystemObjectBase_DefinitionIsNull { get; }
    internal static string TypeSystemObjectBase_NameIsNull { get; }
    internal static string TypeSystemObject_DescriptionImmutable { get; }
    internal static string TypeSystemObject_NameImmutable { get; }
    internal static string UnionType_MustHaveTypes { get; }
    internal static string UnionType_UnableToResolveType { get; }
    internal static string SchemaBuilder_MustBeSchemaType { get; }
    internal static string TypeRegistrar_TypesInconsistent { get; }
    internal static string TypeConvertion_ConvertNotSupported { get; }
    internal static string SchemaBuilder_Interceptor_NotSuppported { get; }
    internal static string IdSerializer_UnableToEncode { get; }
    internal static string IdSerializer_UnableToDecode { get; }
    internal static string SchemaBuilder_Convention_NotSuppported { get; }
    internal static string TimeSpanType_Description { get; }
    internal static string DefaultDataLoaderRegistry_GetOrRegister { get; }
    internal static string DataLoaderResolverContextExtensions_CreateDataLoader_AbstractType { get; }
    internal static string DataLoaderResolverContextExtensions_CreateDataLoader_UnableToCreate { get; }
    internal static string NonNamedType_IsInstanceOfType_NotAnInputType { get; }
    internal static string RegisteredType_CompletionContext_Not_Initialized { get; }
    internal static string RegisteredType_CompletionContext_Already_Set { get; }
    internal static string DeferDirectiveType_Description { get; }
    internal static string DeferDirectiveType_Label_Description { get; }
    internal static string DeferDirectiveType_If_Description { get; }
    internal static string StreamDirectiveType_Description { get; }
    internal static string StreamDirectiveType_Label_Description { get; }
    internal static string StreamDirectiveType_InitialCount_Description { get; }
    internal static string StreamDirectiveType_If_Description { get; }
    internal static string SchemaBuilder_AddRootType_TypeAlreadyRegistered { get; }
    internal static string NodeDescriptor_IdField_MustBePropertyOrMethod { get; }
    internal static string DeprecatedDirectiveType_TypeDescription { get; }
    internal static string DeprecatedDirectiveType_ReasonDescription { get; }
    internal static string IncludeDirectiveType_TypeDescription { get; }
    internal static string IncludeDirectiveType_IfDescription { get; }
    internal static string SkipDirectiveType_TypeDescription { get; }
    internal static string SkipDirectiveType_IfDescription { get; }
    internal static string SpecifiedByDirectiveType_TypeDescription { get; }
    internal static string SpecifiedByDirectiveType_UrlDescription { get; }
    internal static string NodeType_TypeDescription { get; }
    internal static string AnyType_CycleInObjectGraph { get; }
    internal static string UuidType_FormatUnknown { get; }
    internal static string Directive_GetArgument_ArgumentNameIsInvalid { get; }
    internal static string AppliedDirective_Description { get; }
    internal static string DirectiveArgument_Description { get; }
    internal static string ThrowHelper_UsePagingAttribute_NodeTypeUnknown { get; }
    internal static string Schema_GetDirectiveType_DoesNotExist { get; }
    internal static string ErrorHelper_ObjectField_HasNoResolver { get; }
    internal static string ExtendedTypeReferenceHandler_NonGenericExecutableNotAllowed { get; }
    internal static string BindingCompiler_AddBinding_BindingCannotBeHandled { get; }
    internal static string Type_SpecifiedByUrl_Description { get; }
    internal static string SchemaBuilderExtensions_AddObjectType_TIsSchemaType { get; }
    internal static string SchemaBuilderExtensions_AddUnionType_TIsSchemaType { get; }
    internal static string SchemaBuilderExtensions_AddEnumType_TIsSchemaType { get; }
    internal static string SchemaBuilderExtensions_AddInterfaceType_TIsSchemaType { get; }
    internal static string SchemaBuilderExtensions_AddInputObjectType_TIsSchemaType { get; }
    internal static string CostDirective_ComplexityCannotBeBelowOne { get; }
    internal static string CostDirective_DefaultMultiplierCannotBeBelowTwo { get; }
    internal static string EventMessageParameterExpressionBuilder_MessageNotFound { get; }
    internal static string DefaultResolverCompilerService_CreateResolver_ArgumentValidationError { get; }
    internal static string DefaultResolverCompilerService_CompileSubscribe_OnlyMethodsAllowed { get; }
    internal static string SchemaBuilderExtensions_AddResolverConfig_ContextInvalid { get; }
    internal static string SchemaBuilderExtensions_AddResolver_EmptyCooridnates { get; }
    internal static string ExpressionHelper_GetGlobalStateWithDefault_NoDefaults { get; }
    internal static string ExpressionHelper_ResolveScopedContextData_KeyDoesNotExist { get; }
    internal static string ExpressionHelper_GetScopedStateWithDefault_NoDefaultValue { get; }
    internal static string ClaimsPrincipalParameterExpressionBuilder_NoClaimsFound { get; }
    internal static string DirectiveLocation_VariableDefinition { get; }
    internal static string SchemaBuilderExtensions_AddResolver_TypeConditionNotMet { get; }
    internal static string SchemaBuilderExtensions_AddRootResolver_NeedsToBeClassOrInterface { get; }
    internal static string Relay_NodeField_Description { get; }
    internal static string Relay_NodeField_Id_Description { get; }
    internal static string Relay_NodesField_Description { get; }
    internal static string Relay_NodesField_Ids_Description { get; }
    internal static string ErrorHelper_MiddlewareOrderInvalid { get; }
    internal static string ErrorHelper_NoSchemaTypesAllowedAsRuntimeType { get; }
    internal static string FieldInitHelper_CompleteFields_MaxFieldCountToSmall { get; }
    internal static string RegisteredType_Completion_NotYetReady { get; }
    internal static string EdgeType_IsInstanceOfType_NonObject { get; }
    internal static string EdgeType_Description { get; }
    internal static string EdgeType_Cursor_Description { get; }
    internal static string EdgeType_Node_Description { get; }
    internal static string ConnectionType_Description { get; }
    internal static string ConnectionType_PageInfo_Description { get; }
    internal static string ConnectionType_Edges_Description { get; }
    internal static string ConnectionType_TotalCount_Description { get; }
    internal static string CollectionSegmentType_PageInfo_Description { get; }
    internal static string CollectionSegmentType_Description { get; }
    internal static string CollectionSegmentType_Items_Description { get; }
    internal static string ConnectionType_Nodes_Description { get; }
    internal static string ServiceHelper_UseResolverServiceInternal_Order { get; }
    internal static string DefaultNamingConventions_FormatFieldName_EmptyOrNull { get; }
    internal static string OneOfDirectiveType_Description { get; }
    internal static string ThrowHelper_OneOfNoFieldSet { get; }
    internal static string ThrowHelper_OneOfMoreThanOneFieldSet { get; }
    internal static string ThrowHelper_OneOfFieldIsNull { get; }
    internal static string ReflectionUtils_ExtractMethod_MethodExpected { get; }
    internal static string ResolverContextExtensions_ScopedContextData_KeyNotFound { get; }
    internal static string ResolverContextExtensions_LocalContextData_KeyNotFound { get; }
    internal static string ResolverContextExtensions_ContextData_KeyNotFound { get; }
    internal static string SchemaTypes_GetType_DoesNotExist { get; }
    internal static string SchemaTypes_DefinitionInvalid { get; }
    internal static string InputObjectTypeDescriptor_OnlyProperties { get; }
    internal static string InterfaceTypeDescriptor_MustBePropertyOrMethod { get; }
    internal static string ThrowHelper_FieldBase_Sealed { get; }
    internal static string TypeInitializer_CannotFindType { get; }
    internal static string ThrowHelper_RelayIdFieldHelpers_NoFieldType { get; }
    internal static string ThrowHelper_NodeResolver_ObjNoDefinition { get; }
    internal static string ThrowHelper_NodeResolver_ArgumentTypeMissing { get; }
    internal static string ThrowHelper_Schema_GetMember_TypeNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_FieldNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_FieldArgNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_InvalidCoordinate { get; }
    internal static string ThrowHelper_Schema_GetMember_InputFieldNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_EnumValueNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_DirectiveNotFound { get; }
    internal static string ThrowHelper_Schema_GetMember_DirectiveArgumentNotFound { get; }
    internal static string ThrowHelper_FormatResultLeaf_InvalidSyntaxKind { get; }
    internal static string ThrowHelper_FormatResultList_InvalidObjectKind { get; }
    internal static string ThrowHelper_FormatResultObject_InvalidObjectKind { get; }
    internal static string ThrowHelper_FormatValueList_InvalidObjectKind { get; }
    internal static string ThrowHelper_ParseList_InvalidObjectKind { get; }
    internal static string ThrowHelper_ParseNestedList_InvalidSyntaxKind { get; }
    internal static string ThrowHelper_ParseInputObject_InvalidObjectKind { get; }
    internal static string ThrowHelper_ParseInputObject_InvalidSyntaxKind { get; }
    internal static string ThrowHelper_NonNullInputViolation { get; }
    internal static string ThrowHelper_InvalidInputFieldNames { get; }
    internal static string ThrowHelper_RequiredInputFieldIsMissing { get; }
    internal static string ThrowHelper_DataLoader_InvalidType { get; }
    internal static string ThrowHelper_Convention_ConventionCouldNotBeCreated { get; }
    internal static string ThrowHelper_Convention_TwoConventionsRegisteredForScope { get; }
    internal static string ThrowHelper_NodeAttribute_IdFieldNotFound { get; }
    internal static string ThrowHelper_TypeCompletionContext_UnableToResolveType { get; }
    internal static string ThrowHelper_TypeRegistrar_CreateInstanceFailed { get; }
    internal static string ThrowHelper_Convention_UnableToCreateConvention { get; }
    internal static string ThrowHelper_SubscribeAttribute_SubscribeResolverNotFound { get; }
    internal static string ThrowHelper_SubscribeAttribute_TopicTypeUnspecified { get; }
    internal static string ThrowHelper_SubscribeAttribute_MessageTypeUnspecified { get; }
    internal static string ThrowHelper_EventMessage_NotFound { get; }
    internal static string ThrowHelper_EventMessage_InvalidCast { get; }
    internal static string ErrorHelper_NeedsOneAtLeastField { get; }
    internal static string ErrorHelper_TwoUnderscoresNotAllowedField { get; }
    internal static string ErrorHelper_TwoUnderscoresNotAllowedOnArgument { get; }
    internal static string ErrorHelper_TwoUnderscoresNotAllowedOnDirectiveName { get; }
    internal static string ErrorHelper_NotTransitivelyImplemented { get; }
    internal static string ErrorHelper_InvalidFieldType { get; }
    internal static string ErrorHelper_FieldNotImplemented { get; }
    internal static string ErrorHelper_InvalidArgumentType { get; }
    internal static string ErrorHelper_AdditionalArgumentNotNullable { get; }
    internal static string ErrorHelper_ArgumentNotImplemented { get; }
    internal static string ErrorHelper_OneofInputObjectMustHaveNullableFieldsWithoutDefaults { get; }
    internal static string ErrorHelper_InputObjectMustNotHaveRecursiveNonNullableReferencesToSelf { get; }
    internal static string ErrorHelper_RequiredArgumentCannotBeDeprecated { get; }
    internal static string ErrorHelper_RequiredFieldCannotBeDeprecated { get; }
    internal static string ErrorHelper_InterfaceHasNoImplementation { get; }
    internal static string ErrorHelper_CompleteInterfacesHelper_UnableToResolveInterface { get; }
    internal static string ErrorHelper_DirectiveCollection_ArgumentDoesNotExist { get; }
    internal static string ErrorHelper_DirectiveCollection_ArgumentNonNullViolation { get; }
    internal static string ErrorHelper_ObjectType_UnableToInferOrResolveType { get; }
    internal static string ErrorHelper_Relay_NoNodeResolver { get; }
    internal static string ErrorHelper_NodeResolver_MustHaveExactlyOneIdArg { get; }
    internal static string ErrorHelper_NodeResolver_MustReturnObject { get; }
    internal static string ErrorHelper_NodeResolver_NodeTypeHasNoId { get; }
    internal static string ThrowHelper_InvalidInputFieldNames_Single { get; }
    internal static string ThrowHelper_MutationDuplicateErrorName { get; }
    internal static string ErrorHelper_NodeResolverMissing { get; }
    internal static string ThrowHelper_Flags_Enum_Shape_Unknown { get; }
    internal static string ThrowHelper_Flags_Parser_NoSelection { get; }
    internal static string ThrowHelper_Flags_Parser_UnknownSelection { get; }
    internal static string ThrowHelper_Flags_IllegalFlagEnumName { get; }
    internal static string Directive_GetArgumentValue_UnknownArgument { get; }
    internal static string ErrorHelper_DirectiveCollection_ArgumentValueTypeIsWrong { get; }
    internal static string TypeDiscoveryInfo_TypeRefKindNotSupported { get; }
    internal static string ErrorHelper_FetchedToManyNodesAtOnce { get; }
    internal static string ThrowHelper_InputTypeExpected_Message { get; }
    internal static string ThrowHelper_OutputTypeExpected_Message { get; }
    internal static string TagDirective_Name_NotValid { get; }
    internal static string TagDirective_Descriptor_NotSupported { get; }
    internal static string MutationConvention_ShouldBeEnabled_WhenAddingErrorType { get; }
    internal static string ErrorHelper_DuplicateFieldName_Message { get; }
    internal static string ErrorHelper_DuplicateDataMiddlewareDetected_Message { get; }
    internal static string SchemaException_UnexpectedError { get; }
    internal static string SchemaException_ErrorSummaryText { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ThrowHelper_MissingDirectiveIfArgument();
    internal static string get_ArgumentDescriptor_InputTypeViolation();
    internal static string get_ArgumentValueBuilder_NonNull();
    internal static string get_BooleanType_Description();
    internal static string get_ByteType_Description();
    internal static string get_ComplexTypeBindingBuilder_FieldBuilderNotSupported();
    internal static string get_ComplexTypeBindingBuilder_FieldNotComplete();
    internal static string get_DataLoaderRegistry_KeyNullOrEmpty();
    internal static string get_DataLoaderResolverContextExtensions_RegistryIsNull();
    internal static string get_DataLoaderResolverContextExtensions_UnableToRegister();
    internal static string get_DateTimeType_Description();
    internal static string get_DateType_Description();
    internal static string get_DecimalType_Description();
    internal static string get_DefaultTypeInspector_MemberInvalid();
    internal static string get_DependencyDescriptorBase_OnlyTsoIsAllowed();
    internal static string get_DirectiveCollection_DirectiveIsUnique();
    internal static string get_DirectiveCollection_LocationNotAllowed();
    internal static string get_DirectiveLocation_ArgumentDefinition();
    internal static string get_DirectiveLocation_Description();
    internal static string get_DirectiveLocation_Enum();
    internal static string get_DirectiveLocation_EnumValue();
    internal static string get_DirectiveLocation_Field();
    internal static string get_DirectiveLocation_FieldDefinition();
    internal static string get_DirectiveLocation_FragmentDefinition();
    internal static string get_DirectiveLocation_FragmentSpread();
    internal static string get_DirectiveLocation_InlineFragment();
    internal static string get_DirectiveLocation_InputFieldDefinition();
    internal static string get_DirectiveLocation_InputObject();
    internal static string get_DirectiveLocation_Interface();
    internal static string get_DirectiveLocation_Mutation();
    internal static string get_DirectiveLocation_Object();
    internal static string get_DirectiveLocation_Query();
    internal static string get_DirectiveLocation_Scalar();
    internal static string get_DirectiveLocation_Schema();
    internal static string get_DirectiveLocation_Subscription();
    internal static string get_DirectiveLocation_Union();
    internal static string get_DirectiveTypeDescriptor_OnlyProperties();
    internal static string get_DirectiveTypeFactory_LocationNotSupported();
    internal static string get_DirectiveType_NoLocations();
    internal static string get_DirectiveType_ReplaceWithUse();
    internal static string get_DirectiveType_UnableToConvert();
    internal static string get_Directive_Description();
    internal static string get_Directive_UseLocation();
    internal static string get_EnumTypeExtension_CannotMerge();
    internal static string get_EnumTypeExtension_ValueTypeInvalid();
    internal static string get_EnumType_NoValues();
    internal static string get_EnumValue_Description();
    internal static string get_EnumValue_ValueIsNull();
    internal static string get_FieldInitHelper_InvalidDefaultValue();
    internal static string get_FieldInitHelper_NoFields();
    internal static string get_Field_Description();
    internal static string get_FloatType_Description();
    internal static string get_IdType_Description();
    internal static string get_InputField_CannotSetValue();
    internal static string get_InputObjectTypeExtension_CannotMerge();
    internal static string get_InputObjectType_CannotParseLiteral();
    internal static string get_InputObjectType_NoFields();
    internal static string get_InputTypeNonNullCheck_ValueIsNull();
    internal static string get_InputValue_DefaultValue();
    internal static string get_InputValue_Description();
    internal static string get_InterfaceImplRule_ArgumentsDontMatch();
    internal static string get_InterfaceImplRule_ArgumentsNotImpl();
    internal static string get_InterfaceImplRule_FieldNotImpl();
    internal static string get_InterfaceImplRule_FieldTypeInvalid();
    internal static string get_InterfaceImplRule_ReturnTypeInvalid();
    internal static string get_InterfaceTypeExtension_CannotMerge();
    internal static string get_IntType_Description();
    internal static string get_LongType_Description();
    internal static string get_MultiplierPathType_Description();
    internal static string get_NameType_Description();
    internal static string get_Name_Cannot_BeEmpty();
    internal static string get_ObjectFieldDescriptorBase_FieldType();
    internal static string get_ObjectTypeDescriptor_InterfaceBaseClass();
    internal static string get_InterfaceTypeDescriptor_InterfaceBaseClass();
    internal static string get_ObjectTypeDescriptor_MustBePropertyOrMethod();
    internal static string get_ObjectTypeDescriptor_ResolveWith_NonAbstract();
    internal static string get_NodeDescriptor_MustBeMethod();
    internal static string get_NodeDescriptor_IdMember();
    internal static string get_ObjectTypeDescriptor_Resolver_SchemaType();
    internal static string get_Reflection_MemberMust_BeMethodOrProperty();
    internal static string get_ResolverCompiler_UnknownParameterType();
    internal static string get_ResolverTypeBindingBuilder_FieldBuilderNotSupported();
    internal static string get_ResolverTypeBindingBuilder_FieldNotComplete();
    internal static string get_Scalar_Cannot_Deserialize();
    internal static string get_Scalar_Cannot_ParseLiteral();
    internal static string get_Scalar_Cannot_ParseValue();
    internal static string get_Scalar_Cannot_Serialize();
    internal static string get_SchemaBuilderExtensions_DirectiveTypeIsBaseType();
    internal static string get_SchemaBuilderExtensions_MustBeDirectiveType();
    internal static string get_SchemaBuilderExtensions_SchemaIsEmpty();
    internal static string get_SchemaBuilder_Binding_CannotBeHandled();
    internal static string get_SchemaBuilder_Binding_Invalid();
    internal static string get_SchemaBuilder_ISchemaNotTso();
    internal static string get_SchemaBuilder_NoQueryType();
    internal static string get_SchemaBuilder_RootType_MustBeClass();
    internal static string get_SchemaBuilder_RootType_MustBeObjectType();
    internal static string get_SchemaBuilder_RootType_NonGenericType();
    internal static string get_SchemaBuilder_SchemaTypeInvalid();
    internal static string get_SchemaErrorBuilder_MessageIsNull();
    internal static string get_SchemaField_Description();
    internal static string get_SchemaSyntaxVisitor_UnknownOperationType();
    internal static string get_Schema_Description();
    internal static string get_Schema_Directives();
    internal static string get_Schema_MutationType();
    internal static string get_Schema_QueryType();
    internal static string get_Schema_SubscriptionType();
    internal static string get_Schema_Types();
    internal static string get_ShortType_Description();
    internal static string get_StringType_Description();
    internal static string get_String_Argument_NullOrEmpty();
    internal static string get_TypeConfiguration_ConfigureIsNull();
    internal static string get_TypeConfiguration_DefinitionIsNull();
    internal static string get_TypeDependency_MustBeSchemaType();
    internal static string get_TypeExtensions_InvalidStructure();
    internal static string get_TypeExtensions_KindIsNotSupported();
    internal static string get_TypeExtensions_NoListType();
    internal static string get_TypeExtensions_TypeIsNotOfT();
    internal static string get_TypeField_Description();
    internal static string get_TypeInitializer_CannotResolveDependency();
    internal static string get_TypeInitializer_CompleteName_Duplicate();
    internal static string get_TypeInitializer_Merge_KindDoesNotMatch();
    internal static string get_TypeKind_Description();
    internal static string get_TypeKind_Enum();
    internal static string get_TypeKind_InputObject();
    internal static string get_TypeKind_Interface();
    internal static string get_TypeKind_List();
    internal static string get_TypeKind_NonNull();
    internal static string get_TypeKind_Object();
    internal static string get_TypeKind_Scalar();
    internal static string get_TypeKind_Union();
    internal static string get_TypeNameField_Description();
    internal static string get_TypeNameHelper_InvalidTypeStructure();
    internal static string get_TypeNameHelper_OnlyTsosAreAllowed();
    internal static string get_TypeResourceHelper_TypeNameEmptyOrNull();
    internal static string get_Type_Description();
    internal static string get_UnionTypeExtension_CannotMerge();
    internal static string get_VariableValueBuilder_InputType();
    internal static string get_VariableValueBuilder_InvalidValue();
    internal static string get_VariableValueBuilder_NodeKind();
    internal static string get_VariableValueBuilder_NonNull();
    internal static string get_VariableValueBuilder_NonNull_In_Graph();
    internal static string get_VariableValueBuilder_VarNameEmpty();
    internal static string get_Argument_TypeIsNull();
    internal static string get_NonNullType_NotAnInputType();
    internal static string get_NonNullType_TypeIsNunNullType();
    internal static string get_NonNullType_ValueIsNull();
    internal static string get_ObjectTypeExtension_CannotMerge();
    internal static string get_TypeSystemObjectBase_DefinitionIsNull();
    internal static string get_TypeSystemObjectBase_NameIsNull();
    internal static string get_TypeSystemObject_DescriptionImmutable();
    internal static string get_TypeSystemObject_NameImmutable();
    internal static string get_UnionType_MustHaveTypes();
    internal static string get_UnionType_UnableToResolveType();
    internal static string get_SchemaBuilder_MustBeSchemaType();
    internal static string get_TypeRegistrar_TypesInconsistent();
    internal static string get_TypeConvertion_ConvertNotSupported();
    internal static string get_SchemaBuilder_Interceptor_NotSuppported();
    internal static string get_IdSerializer_UnableToEncode();
    internal static string get_IdSerializer_UnableToDecode();
    internal static string get_SchemaBuilder_Convention_NotSuppported();
    internal static string get_TimeSpanType_Description();
    internal static string get_DefaultDataLoaderRegistry_GetOrRegister();
    internal static string get_DataLoaderResolverContextExtensions_CreateDataLoader_AbstractType();
    internal static string get_DataLoaderResolverContextExtensions_CreateDataLoader_UnableToCreate();
    internal static string get_NonNamedType_IsInstanceOfType_NotAnInputType();
    internal static string get_RegisteredType_CompletionContext_Not_Initialized();
    internal static string get_RegisteredType_CompletionContext_Already_Set();
    internal static string get_DeferDirectiveType_Description();
    internal static string get_DeferDirectiveType_Label_Description();
    internal static string get_DeferDirectiveType_If_Description();
    internal static string get_StreamDirectiveType_Description();
    internal static string get_StreamDirectiveType_Label_Description();
    internal static string get_StreamDirectiveType_InitialCount_Description();
    internal static string get_StreamDirectiveType_If_Description();
    internal static string get_SchemaBuilder_AddRootType_TypeAlreadyRegistered();
    internal static string get_NodeDescriptor_IdField_MustBePropertyOrMethod();
    internal static string get_DeprecatedDirectiveType_TypeDescription();
    internal static string get_DeprecatedDirectiveType_ReasonDescription();
    internal static string get_IncludeDirectiveType_TypeDescription();
    internal static string get_IncludeDirectiveType_IfDescription();
    internal static string get_SkipDirectiveType_TypeDescription();
    internal static string get_SkipDirectiveType_IfDescription();
    internal static string get_SpecifiedByDirectiveType_TypeDescription();
    internal static string get_SpecifiedByDirectiveType_UrlDescription();
    internal static string get_NodeType_TypeDescription();
    internal static string get_AnyType_CycleInObjectGraph();
    internal static string get_UuidType_FormatUnknown();
    internal static string get_Directive_GetArgument_ArgumentNameIsInvalid();
    internal static string get_AppliedDirective_Description();
    internal static string get_DirectiveArgument_Description();
    internal static string get_ThrowHelper_UsePagingAttribute_NodeTypeUnknown();
    internal static string get_Schema_GetDirectiveType_DoesNotExist();
    internal static string get_ErrorHelper_ObjectField_HasNoResolver();
    internal static string get_ExtendedTypeReferenceHandler_NonGenericExecutableNotAllowed();
    internal static string get_BindingCompiler_AddBinding_BindingCannotBeHandled();
    internal static string get_Type_SpecifiedByUrl_Description();
    internal static string get_SchemaBuilderExtensions_AddObjectType_TIsSchemaType();
    internal static string get_SchemaBuilderExtensions_AddUnionType_TIsSchemaType();
    internal static string get_SchemaBuilderExtensions_AddEnumType_TIsSchemaType();
    internal static string get_SchemaBuilderExtensions_AddInterfaceType_TIsSchemaType();
    internal static string get_SchemaBuilderExtensions_AddInputObjectType_TIsSchemaType();
    internal static string get_CostDirective_ComplexityCannotBeBelowOne();
    internal static string get_CostDirective_DefaultMultiplierCannotBeBelowTwo();
    internal static string get_EventMessageParameterExpressionBuilder_MessageNotFound();
    internal static string get_DefaultResolverCompilerService_CreateResolver_ArgumentValidationError();
    internal static string get_DefaultResolverCompilerService_CompileSubscribe_OnlyMethodsAllowed();
    internal static string get_SchemaBuilderExtensions_AddResolverConfig_ContextInvalid();
    internal static string get_SchemaBuilderExtensions_AddResolver_EmptyCooridnates();
    internal static string get_ExpressionHelper_GetGlobalStateWithDefault_NoDefaults();
    internal static string get_ExpressionHelper_ResolveScopedContextData_KeyDoesNotExist();
    internal static string get_ExpressionHelper_GetScopedStateWithDefault_NoDefaultValue();
    internal static string get_ClaimsPrincipalParameterExpressionBuilder_NoClaimsFound();
    internal static string get_DirectiveLocation_VariableDefinition();
    internal static string get_SchemaBuilderExtensions_AddResolver_TypeConditionNotMet();
    internal static string get_SchemaBuilderExtensions_AddRootResolver_NeedsToBeClassOrInterface();
    internal static string get_Relay_NodeField_Description();
    internal static string get_Relay_NodeField_Id_Description();
    internal static string get_Relay_NodesField_Description();
    internal static string get_Relay_NodesField_Ids_Description();
    internal static string get_ErrorHelper_MiddlewareOrderInvalid();
    internal static string get_ErrorHelper_NoSchemaTypesAllowedAsRuntimeType();
    internal static string get_FieldInitHelper_CompleteFields_MaxFieldCountToSmall();
    internal static string get_RegisteredType_Completion_NotYetReady();
    internal static string get_EdgeType_IsInstanceOfType_NonObject();
    internal static string get_EdgeType_Description();
    internal static string get_EdgeType_Cursor_Description();
    internal static string get_EdgeType_Node_Description();
    internal static string get_ConnectionType_Description();
    internal static string get_ConnectionType_PageInfo_Description();
    internal static string get_ConnectionType_Edges_Description();
    internal static string get_ConnectionType_TotalCount_Description();
    internal static string get_CollectionSegmentType_PageInfo_Description();
    internal static string get_CollectionSegmentType_Description();
    internal static string get_CollectionSegmentType_Items_Description();
    internal static string get_ConnectionType_Nodes_Description();
    internal static string get_ServiceHelper_UseResolverServiceInternal_Order();
    internal static string get_DefaultNamingConventions_FormatFieldName_EmptyOrNull();
    internal static string get_OneOfDirectiveType_Description();
    internal static string get_ThrowHelper_OneOfNoFieldSet();
    internal static string get_ThrowHelper_OneOfMoreThanOneFieldSet();
    internal static string get_ThrowHelper_OneOfFieldIsNull();
    internal static string get_ReflectionUtils_ExtractMethod_MethodExpected();
    internal static string get_ResolverContextExtensions_ScopedContextData_KeyNotFound();
    internal static string get_ResolverContextExtensions_LocalContextData_KeyNotFound();
    internal static string get_ResolverContextExtensions_ContextData_KeyNotFound();
    internal static string get_SchemaTypes_GetType_DoesNotExist();
    internal static string get_SchemaTypes_DefinitionInvalid();
    internal static string get_InputObjectTypeDescriptor_OnlyProperties();
    internal static string get_InterfaceTypeDescriptor_MustBePropertyOrMethod();
    internal static string get_ThrowHelper_FieldBase_Sealed();
    internal static string get_TypeInitializer_CannotFindType();
    internal static string get_ThrowHelper_RelayIdFieldHelpers_NoFieldType();
    internal static string get_ThrowHelper_NodeResolver_ObjNoDefinition();
    internal static string get_ThrowHelper_NodeResolver_ArgumentTypeMissing();
    internal static string get_ThrowHelper_Schema_GetMember_TypeNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_FieldNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_FieldArgNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_InvalidCoordinate();
    internal static string get_ThrowHelper_Schema_GetMember_InputFieldNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_EnumValueNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_DirectiveNotFound();
    internal static string get_ThrowHelper_Schema_GetMember_DirectiveArgumentNotFound();
    internal static string get_ThrowHelper_FormatResultLeaf_InvalidSyntaxKind();
    internal static string get_ThrowHelper_FormatResultList_InvalidObjectKind();
    internal static string get_ThrowHelper_FormatResultObject_InvalidObjectKind();
    internal static string get_ThrowHelper_FormatValueList_InvalidObjectKind();
    internal static string get_ThrowHelper_ParseList_InvalidObjectKind();
    internal static string get_ThrowHelper_ParseNestedList_InvalidSyntaxKind();
    internal static string get_ThrowHelper_ParseInputObject_InvalidObjectKind();
    internal static string get_ThrowHelper_ParseInputObject_InvalidSyntaxKind();
    internal static string get_ThrowHelper_NonNullInputViolation();
    internal static string get_ThrowHelper_InvalidInputFieldNames();
    internal static string get_ThrowHelper_RequiredInputFieldIsMissing();
    internal static string get_ThrowHelper_DataLoader_InvalidType();
    internal static string get_ThrowHelper_Convention_ConventionCouldNotBeCreated();
    internal static string get_ThrowHelper_Convention_TwoConventionsRegisteredForScope();
    internal static string get_ThrowHelper_NodeAttribute_IdFieldNotFound();
    internal static string get_ThrowHelper_TypeCompletionContext_UnableToResolveType();
    internal static string get_ThrowHelper_TypeRegistrar_CreateInstanceFailed();
    internal static string get_ThrowHelper_Convention_UnableToCreateConvention();
    internal static string get_ThrowHelper_SubscribeAttribute_SubscribeResolverNotFound();
    internal static string get_ThrowHelper_SubscribeAttribute_TopicTypeUnspecified();
    internal static string get_ThrowHelper_SubscribeAttribute_MessageTypeUnspecified();
    internal static string get_ThrowHelper_EventMessage_NotFound();
    internal static string get_ThrowHelper_EventMessage_InvalidCast();
    internal static string get_ErrorHelper_NeedsOneAtLeastField();
    internal static string get_ErrorHelper_TwoUnderscoresNotAllowedField();
    internal static string get_ErrorHelper_TwoUnderscoresNotAllowedOnArgument();
    internal static string get_ErrorHelper_TwoUnderscoresNotAllowedOnDirectiveName();
    internal static string get_ErrorHelper_NotTransitivelyImplemented();
    internal static string get_ErrorHelper_InvalidFieldType();
    internal static string get_ErrorHelper_FieldNotImplemented();
    internal static string get_ErrorHelper_InvalidArgumentType();
    internal static string get_ErrorHelper_AdditionalArgumentNotNullable();
    internal static string get_ErrorHelper_ArgumentNotImplemented();
    internal static string get_ErrorHelper_OneofInputObjectMustHaveNullableFieldsWithoutDefaults();
    internal static string get_ErrorHelper_InputObjectMustNotHaveRecursiveNonNullableReferencesToSelf();
    internal static string get_ErrorHelper_RequiredArgumentCannotBeDeprecated();
    internal static string get_ErrorHelper_RequiredFieldCannotBeDeprecated();
    internal static string get_ErrorHelper_InterfaceHasNoImplementation();
    internal static string get_ErrorHelper_CompleteInterfacesHelper_UnableToResolveInterface();
    internal static string get_ErrorHelper_DirectiveCollection_ArgumentDoesNotExist();
    internal static string get_ErrorHelper_DirectiveCollection_ArgumentNonNullViolation();
    internal static string get_ErrorHelper_ObjectType_UnableToInferOrResolveType();
    internal static string get_ErrorHelper_Relay_NoNodeResolver();
    internal static string get_ErrorHelper_NodeResolver_MustHaveExactlyOneIdArg();
    internal static string get_ErrorHelper_NodeResolver_MustReturnObject();
    internal static string get_ErrorHelper_NodeResolver_NodeTypeHasNoId();
    internal static string get_ThrowHelper_InvalidInputFieldNames_Single();
    internal static string get_ThrowHelper_MutationDuplicateErrorName();
    internal static string get_ErrorHelper_NodeResolverMissing();
    internal static string get_ThrowHelper_Flags_Enum_Shape_Unknown();
    internal static string get_ThrowHelper_Flags_Parser_NoSelection();
    internal static string get_ThrowHelper_Flags_Parser_UnknownSelection();
    internal static string get_ThrowHelper_Flags_IllegalFlagEnumName();
    internal static string get_Directive_GetArgumentValue_UnknownArgument();
    internal static string get_ErrorHelper_DirectiveCollection_ArgumentValueTypeIsWrong();
    internal static string get_TypeDiscoveryInfo_TypeRefKindNotSupported();
    internal static string get_ErrorHelper_FetchedToManyNodesAtOnce();
    internal static string get_ThrowHelper_InputTypeExpected_Message();
    internal static string get_ThrowHelper_OutputTypeExpected_Message();
    internal static string get_TagDirective_Name_NotValid();
    internal static string get_TagDirective_Descriptor_NotSupported();
    internal static string get_MutationConvention_ShouldBeEnabled_WhenAddingErrorType();
    internal static string get_ErrorHelper_DuplicateFieldName_Message();
    internal static string get_ErrorHelper_DuplicateDataMiddlewareDetected_Message();
    internal static string get_SchemaException_UnexpectedError();
    internal static string get_SchemaException_ErrorSummaryText();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.RelaySchemaBuilderExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use AddGlobalObjectIdentification / AddQueryFieldToMutationPayloads")]
public static ISchemaBuilder EnableRelaySupport(ISchemaBuilder schemaBuilder, RelayOptions options);
    [ExtensionAttribute]
public static ISchemaBuilder AddGlobalObjectIdentification(ISchemaBuilder schemaBuilder);
    [ExtensionAttribute]
public static ISchemaBuilder AddGlobalObjectIdentification(ISchemaBuilder schemaBuilder, bool registerNodeInterface);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryFieldToMutationPayloads(ISchemaBuilder schemaBuilder, Action`1<MutationPayloadOptions> configureOptions);
    [ExtensionAttribute]
private static ISchemaBuilder AddQueryFieldToMutationPayloads(ISchemaBuilder schemaBuilder, MutationPayloadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.ResolverContextExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetGlobalStateOrDefault`")]
public static T GetGlobalValue(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetGlobalStateOrDefault(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetGlobalState(IResolverContext context, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetScopedStateOrDefault`")]
public static T GetScopedValue(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetScopedStateOrDefault(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetScopedState(IResolverContext context, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetLocalStateOrDefault`")]
public static T GetLocalValue(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetLocalStateOrDefault(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetLocalState(IResolverContext context, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `SetGlobalState`")]
public static void SetGlobalValue(IResolverContext context, string name, T value);
    [ExtensionAttribute]
public static void SetGlobalState(IResolverContext context, string name, T value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `SetScopedState`")]
public static void SetScopedValue(IResolverContext context, string name, T value);
    [ExtensionAttribute]
public static void SetScopedState(IResolverContext context, string name, T value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `SetLocalState`")]
public static void SetLocalValue(IResolverContext context, string name, T value);
    [ExtensionAttribute]
public static void SetLocalState(IResolverContext context, string name, T value);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetOrSetGlobalState`")]
public static T GetOrAddGlobalValue(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
public static T GetOrSetGlobalState(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetOrSetScopedState`")]
public static T GetOrAddScopedValue(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
public static T GetOrSetScopedState(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `GetOrSetLocalState`")]
public static T GetOrAddLocalValue(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
public static T GetOrSetLocalState(IResolverContext context, string name, Func`2<string, T> createValue);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static void RemoveGlobalValue(IResolverContext context, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `RemoveScopedState`")]
public static void RemoveScopedValue(IResolverContext context, string name);
    [ExtensionAttribute]
public static void RemoveScopedState(IResolverContext context, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `RemoveLocalState`")]
public static void RemoveLocalValue(IResolverContext context, string name);
    [ExtensionAttribute]
public static void RemoveLocalState(IResolverContext context, string name);
    [ExtensionAttribute]
public static T GetEventMessage(IResolverContext context);
    [ExtensionAttribute]
public static ClaimsPrincipal GetUser(IResolverContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Resolvers.ArgumentValue : object {
    [NullableAttribute("1")]
private IInputFieldInfo _argument;
    [CompilerGeneratedAttribute]
private Nullable`1<ValueKind> <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullyCoerced>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueNode <ValueLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private IError <Error>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; }
    public FieldCoordinate Coordinate { get; }
    [NullableAttribute("1")]
public IInputType Type { get; }
    [NullableAttribute("1")]
public Type RuntimeType { get; }
    public IValueNode DefaultValue { get; }
    public IInputValueFormatter Formatter { get; }
    public Nullable`1<ValueKind> Kind { get; }
    public bool IsFullyCoerced { get; }
    public bool HasError { get; }
    public bool IsDefaultValue { get; }
    public object Value { get; }
    public IValueNode ValueLiteral { get; }
    public IError Error { get; }
    [NullableContextAttribute("1")]
public ArgumentValue(IInputFieldInfo argument, ValueKind kind, bool isFullyCoerced, bool isDefaultValue, object value, IValueNode valueLiteral);
    [NullableContextAttribute("1")]
public ArgumentValue(IInputFieldInfo argument, IError error);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual FieldCoordinate get_Coordinate();
    [NullableContextAttribute("1")]
public sealed virtual IInputType get_Type();
    [NullableContextAttribute("1")]
public sealed virtual Type get_RuntimeType();
    public sealed virtual IValueNode get_DefaultValue();
    public sealed virtual IInputValueFormatter get_Formatter();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueKind> get_Kind();
    [CompilerGeneratedAttribute]
public bool get_IsFullyCoerced();
    [CompilerGeneratedAttribute]
public bool get_HasError();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultValue();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public IValueNode get_ValueLiteral();
    [CompilerGeneratedAttribute]
public IError get_Error();
}
public enum HotChocolate.Resolvers.CleanAfter : Enum {
    public int value__;
    public static CleanAfter Resolver;
    public static CleanAfter Request;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.DefaultResolverCompiler : object {
    private static IReadOnlyList`1<IParameterExpressionBuilder> _empty;
    private static ParameterExpression _context;
    private static ParameterExpression _pureContext;
    private static MethodInfo _parent;
    private static MethodInfo _resolver;
    private Dictionary`2<ParameterInfo, IParameterExpressionBuilder> _cache;
    private List`1<IParameterExpressionBuilder> _parameterExpressionBuilders;
    private List`1<IParameterExpressionBuilder> _defaultParameterExpressionBuilders;
    private List`1<IParameterFieldConfiguration> _parameterFieldConfigurations;
    private ImplicitArgumentParameterExpressionBuilder _defaultExprBuilder;
    private IReadOnlyDictionary`2<ParameterInfo, string> _emptyLookup;
    public DefaultResolverCompiler(IEnumerable`1<IParameterExpressionBuilder> customParameterExpressionBuilders);
    private static DefaultResolverCompiler();
    [NullableContextAttribute("2")]
public sealed virtual FieldResolverDelegates CompileResolve(Expression`1<Func`2<TResolver, object>> propertyOrMethod, Type sourceType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public sealed virtual FieldResolverDelegates CompileResolve(LambdaExpression lambda, Type sourceType, Type resolverType);
    [NullableContextAttribute("2")]
public sealed virtual FieldResolverDelegates CompileResolve(MemberInfo member, Type sourceType, Type resolverType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public sealed virtual SubscribeResolverDelegate CompileSubscribe(MemberInfo member, Type sourceType, Type resolverType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    [IteratorStateMachineAttribute("HotChocolate.Resolvers.DefaultResolverCompiler/<GetArgumentParameters>d__16")]
public sealed virtual IEnumerable`1<ParameterInfo> GetArgumentParameters(ParameterInfo[] parameters, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public sealed virtual void ApplyConfiguration(ParameterInfo[] parameters, ObjectFieldDescriptor descriptor);
    private FieldResolverDelegate CompileStaticResolver(MethodInfo method, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> fieldParameterExpressionBuilders);
    private FieldResolverDelegate CreateResolver(MemberInfo member, Type source, Type resolverType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> fieldParameterExpressionBuilders);
    private PureFieldDelegate TryCompilePureResolver(MemberInfo member, Type source, Type resolver, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> fieldParameterExpressionBuilders);
    private bool IsPureResolver(MethodInfo method, ParameterInfo[] parameters, IReadOnlyList`1<IParameterExpressionBuilder> fieldParameterExpressionBuilders);
    private static bool IsPureResolverResult(Type resultType);
    private static Expression CreateResolverOwner(ParameterExpression context, Type source, Type resolver);
    private Expression[] CreateParameters(ParameterExpression resolverContext, ParameterInfo[] parameters, IReadOnlyDictionary`2<ParameterInfo, string> argumentNameLookup, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    private IParameterExpressionBuilder GetParameterExpressionBuilder(ParameterInfo parameter, IReadOnlyList`1<IParameterExpressionBuilder> fieldParameterExpressionBuilders);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Resolvers.DirectiveClassMiddlewareFactory : object {
    private static MethodInfo _createGeneric;
    private static PropertyInfo _services;
    private static DirectiveClassMiddlewareFactory();
    internal static DirectiveMiddleware Create();
    internal static DirectiveMiddleware Create(Type middlewareType);
    internal static DirectiveMiddleware Create(Func`3<IServiceProvider, FieldDelegate, TMiddleware> activate);
}
internal class HotChocolate.Resolvers.DirectiveDelegateMiddleware : object {
    [CompilerGeneratedAttribute]
private string <DirectiveName>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveMiddleware <Middleware>k__BackingField;
    public string DirectiveName { get; }
    public DirectiveMiddleware Middleware { get; }
    public DirectiveDelegateMiddleware(string directiveName, DirectiveMiddleware middleware);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DirectiveName();
    [CompilerGeneratedAttribute]
public DirectiveMiddleware get_Middleware();
}
internal class HotChocolate.Resolvers.DirectiveMethodMiddleware : object {
    [CompilerGeneratedAttribute]
private string <DirectiveName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public string DirectiveName { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public DirectiveMethodMiddleware(string directiveName, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DirectiveName();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
}
public class HotChocolate.Resolvers.DirectiveMiddleware : MulticastDelegate {
    public DirectiveMiddleware(object object, IntPtr method);
    public virtual FieldDelegate Invoke(FieldDelegate next, Directive directive);
    public virtual IAsyncResult BeginInvoke(FieldDelegate next, Directive directive, AsyncCallback callback, object object);
    public virtual FieldDelegate EndInvoke(IAsyncResult result);
}
public enum HotChocolate.Resolvers.DirectiveScope : Enum {
    public int value__;
    public static DirectiveScope All;
    public static DirectiveScope FieldSelection;
}
internal static class HotChocolate.Resolvers.Expressions.ExpressionHelper : object {
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.ExpressionHelper/<AwaitTaskHelper>d__0`1")]
public static ValueTask`1<object> AwaitTaskHelper(Task`1<T> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.ExpressionHelper/<AwaitValueTaskHelper>d__1`1")]
public static ValueTask`1<object> AwaitValueTaskHelper(ValueTask`1<T> task);
    public static ValueTask`1<object> WrapResultHelper(T result);
    public static TContextData GetGlobalState(IDictionary`2<string, object> contextData, string key, bool defaultIfNotExists);
    public static TContextData GetGlobalStateWithDefault(IDictionary`2<string, object> contextData, string key, bool hasDefaultValue, TContextData defaultValue);
    public static SetState`1<TContextData> SetGlobalStateGeneric(IDictionary`2<string, object> contextData, string key);
    public static SetState SetGlobalState(IDictionary`2<string, object> contextData, string key);
    public static TContextData GetScopedState(IPureResolverContext context, IReadOnlyDictionary`2<string, object> contextData, string key, bool defaultIfNotExists);
    public static TContextData GetScopedStateWithDefault(IPureResolverContext context, IReadOnlyDictionary`2<string, object> contextData, string key, bool hasDefaultValue, TContextData defaultValue);
    public static SetState`1<TContextData> SetScopedStateGeneric(IResolverContext context, string key);
    public static SetState SetScopedState(IResolverContext context, string key);
    public static SetState`1<TContextData> SetLocalStateGeneric(IResolverContext context, string key);
    public static SetState SetLocalState(IResolverContext context, string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.Parameters.ArgumentParameterExpressionBuilder : object {
    private static string _argumentValue;
    private static string _argumentLiteral;
    private static string _argumentOptional;
    private static Type _optional;
    private static MethodInfo _getArgumentValue;
    private static MethodInfo _getArgumentLiteral;
    private static MethodInfo _getArgumentOptional;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static ArgumentParameterExpressionBuilder();
    private static bool IsArgumentValueMethod(MethodInfo method);
    private static bool IsArgumentLiteralMethod(MethodInfo method);
    private static bool IsArgumentOptionalMethod(MethodInfo method);
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    public virtual bool CanHandle(ParameterInfo parameter);
    public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.CancellationTokenParameterExpressionBuilder : object {
    [NullableAttribute("1")]
private static PropertyInfo _cancellationToken;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static CancellationTokenParameterExpressionBuilder();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.ClaimsPrincipalParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
    [NullableContextAttribute("1")]
private static ClaimsPrincipal GetClaimsPrincipal(IPureResolverContext context, bool nullable);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.DocumentParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, DocumentNode> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.EventMessageParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IResolverContext, object> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
    private static object GetEventMessage(IImmutableDictionary`2<string, object> contextData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.FieldParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, IObjectField> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.FieldSyntaxParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, FieldNode> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.Parameters.GlobalStateParameterExpressionBuilder : object {
    private static PropertyInfo _contextData;
    private static MethodInfo _getGlobalState;
    private static MethodInfo _getGlobalStateWithDefault;
    private static MethodInfo _setGlobalState;
    private static MethodInfo _setGlobalStateGeneric;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static GlobalStateParameterExpressionBuilder();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    public sealed virtual bool CanHandle(ParameterInfo parameter);
    public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
    private Expression BuildSetter(ParameterInfo parameter, ConstantExpression key, MemberExpression contextData);
    private Expression BuildGetter(ParameterInfo parameter, ConstantExpression key, MemberExpression contextData);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.ImplicitArgumentParameterExpressionBuilder : ArgumentParameterExpressionBuilder {
    [NullableContextAttribute("1")]
public virtual bool CanHandle(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class HotChocolate.Resolvers.Expressions.Parameters.LambdaParameterExpressionBuilder`2 : object {
    private Expression`1<Func`2<TContext, TValue>> _expression;
    [CompilerGeneratedAttribute]
private bool <IsPure>k__BackingField;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    protected LambdaParameterExpressionBuilder`2(Expression`1<Func`2<TContext, TValue>> expression);
    public abstract virtual ArgumentKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    public abstract virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
    private InvocationExpression CreateInvokeExpression(Expression context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.LegacyScopedServiceParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    public sealed virtual bool CanHandle(ParameterInfo parameter);
    public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.Parameters.LocalStateParameterExpressionBuilder : ScopedStateParameterExpressionBuilder {
    private static PropertyInfo _localContextDataProperty;
    private static MethodInfo _setLocalState;
    private static MethodInfo _setLocalStateGeneric;
    public ArgumentKind Kind { get; }
    protected PropertyInfo ContextDataProperty { get; }
    protected MethodInfo SetStateMethod { get; }
    protected MethodInfo SetStateGenericMethod { get; }
    private static LocalStateParameterExpressionBuilder();
    public virtual ArgumentKind get_Kind();
    protected virtual PropertyInfo get_ContextDataProperty();
    protected virtual MethodInfo get_SetStateMethod();
    protected virtual MethodInfo get_SetStateGenericMethod();
    public virtual bool CanHandle(ParameterInfo parameter);
    protected virtual string GetKey(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.ObjectTypeParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, IObjectType> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.OperationDefinitionParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, OperationDefinitionNode> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.OperationParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, IOperation> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
}
internal static class HotChocolate.Resolvers.Expressions.Parameters.ParameterExpressionBuilderHelpers : object {
    [CompilerGeneratedAttribute]
private static Type <ContextType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Type <PureContextType>k__BackingField;
    public static Type ContextType { get; }
    public static Type PureContextType { get; }
    private static ParameterExpressionBuilderHelpers();
    [CompilerGeneratedAttribute]
public static Type get_ContextType();
    [CompilerGeneratedAttribute]
public static Type get_PureContextType();
    public static bool IsStateSetter(Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.Parameters.ParentParameterExpressionBuilder : object {
    private static string _parent;
    private static MethodInfo _getParentMethod;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static ParentParameterExpressionBuilder();
    private static bool IsParentMethod(MethodInfo method);
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    public sealed virtual bool CanHandle(ParameterInfo parameter);
    public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.PathParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, Path> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.PureResolverContextParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.ResolverContextParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.SchemaParameterExpressionBuilder : object {
    [NullableAttribute("1")]
private static PropertyInfo _schema;
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static SchemaParameterExpressionBuilder();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.ScopedServiceParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual void ApplyConfiguration(ParameterInfo parameter, ObjectFieldDescriptor descriptor);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.Parameters.ScopedStateParameterExpressionBuilder : object {
    private static MethodInfo _getScopedState;
    private static MethodInfo _getScopedStateWithDefault;
    private static MethodInfo _setScopedState;
    private static MethodInfo _setScopedStateGeneric;
    private static PropertyInfo _contextDataProperty;
    protected PropertyInfo ContextDataProperty { get; }
    protected MethodInfo SetStateMethod { get; }
    protected MethodInfo SetStateGenericMethod { get; }
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    private static ScopedStateParameterExpressionBuilder();
    protected virtual PropertyInfo get_ContextDataProperty();
    protected virtual MethodInfo get_SetStateMethod();
    protected virtual MethodInfo get_SetStateGenericMethod();
    public virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public virtual bool get_IsDefaultHandler();
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
    protected virtual string GetKey(ParameterInfo parameter);
    protected Expression BuildSetter(ParameterInfo parameter, ConstantExpression key, Expression context);
    protected Expression BuildGetter(ParameterInfo parameter, ConstantExpression key, Expression context, Type targetType);
    protected virtual bool ResolveDefaultIfNotExistsParameterValue(Type targetType, ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class HotChocolate.Resolvers.Expressions.Parameters.SelectionParameterExpressionBuilder : LambdaParameterExpressionBuilder`2<IPureResolverContext, object> {
    public ArgumentKind Kind { get; }
    public virtual ArgumentKind get_Kind();
    public virtual bool CanHandle(ParameterInfo parameter);
    public virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Resolvers.Expressions.Parameters.ServiceExpressionHelper : object {
    private static string _service;
    private static string _fromServicesAttribute;
    private static MethodInfo _getServiceMethod;
    private static PropertyInfo _contextData;
    private static MethodInfo _getScopedState;
    private static MethodInfo _getScopedStateWithDefault;
    private static ServiceExpressionHelper();
    public static void ApplyConfiguration(ParameterInfo parameter, ObjectFieldDescriptor descriptor, ServiceKind serviceKind);
    public static Expression Build(ParameterInfo parameter, Expression context, ServiceKind serviceKind);
    private static Expression BuildDefaultService(ParameterInfo parameter, Expression context);
    private static Expression BuildLocalService(ParameterInfo parameter, Expression context);
    public static bool TryGetServiceKind(ParameterInfo parameter, ServiceKind& kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Resolvers.Expressions.Parameters.ServiceHelper : object {
    private static BindingFlags _flags;
    private static MethodInfo _usePooledService;
    private static MethodInfo _useResolverService;
    private static ServiceHelper();
    internal static void UsePooledService(ObjectFieldDefinition definition, Type serviceType);
    internal static void UsePooledService(ObjectFieldDefinition definition);
    private static void UsePooledServiceInternal(ObjectFieldDefinition definition);
    internal static void UseResolverService(ObjectFieldDefinition definition, Type serviceType);
    private static void UseResolverServiceInternal(ObjectFieldDefinition definition);
}
internal class HotChocolate.Resolvers.Expressions.Parameters.ServiceParameterExpressionBuilder : object {
    public ArgumentKind Kind { get; }
    public bool IsPure { get; }
    public bool IsDefaultHandler { get; }
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual bool get_IsPure();
    public sealed virtual bool get_IsDefaultHandler();
    [NullableContextAttribute("1")]
public sealed virtual bool CanHandle(ParameterInfo parameter);
    [NullableContextAttribute("1")]
public sealed virtual void ApplyConfiguration(ParameterInfo parameter, ObjectFieldDescriptor descriptor);
    [NullableContextAttribute("1")]
public sealed virtual Expression Build(ParameterExpressionBuilderContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Resolvers.Expressions.ResolverDescriptor : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <ResolverType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldMember <Field>k__BackingField;
    [NullableAttribute("2")]
public Type ResolverType { get; }
    public Type SourceType { get; }
    public FieldMember Field { get; }
    public ResolverDescriptor(Type sourceType, FieldMember field, Type resolverType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_ResolverType();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public FieldMember get_Field();
}
internal static class HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper : object {
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskSourceStreamGeneric>d__0`1")]
public static ValueTask`1<ISourceStream> AwaitTaskSourceStreamGeneric(Task`1<ISourceStream`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskSourceStream>d__1")]
public static ValueTask`1<ISourceStream> AwaitTaskSourceStream(Task`1<ISourceStream> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskAsyncEnumerable>d__2`1")]
public static ValueTask`1<ISourceStream> AwaitTaskAsyncEnumerable(Task`1<IAsyncEnumerable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskEnumerable>d__3`1")]
public static ValueTask`1<ISourceStream> AwaitTaskEnumerable(Task`1<IEnumerable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskQueryable>d__4`1")]
public static ValueTask`1<ISourceStream> AwaitTaskQueryable(Task`1<IQueryable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitTaskObservable>d__5`1")]
public static ValueTask`1<ISourceStream> AwaitTaskObservable(Task`1<IObservable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitValueTaskSourceStreamGeneric>d__6`1")]
public static ValueTask`1<ISourceStream> AwaitValueTaskSourceStreamGeneric(ValueTask`1<ISourceStream`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitValueTaskAsyncEnumerable>d__7`1")]
public static ValueTask`1<ISourceStream> AwaitValueTaskAsyncEnumerable(ValueTask`1<IAsyncEnumerable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitValueTaskEnumerable>d__8`1")]
public static ValueTask`1<ISourceStream> AwaitValueTaskEnumerable(ValueTask`1<IEnumerable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitValueTaskQueryable>d__9`1")]
public static ValueTask`1<ISourceStream> AwaitValueTaskQueryable(ValueTask`1<IQueryable`1<T>> task);
    [AsyncStateMachineAttribute("HotChocolate.Resolvers.Expressions.SubscribeExpressionHelper/<AwaitValueTaskObservable>d__10`1")]
public static ValueTask`1<ISourceStream> AwaitValueTaskObservable(ValueTask`1<IObservable`1<T>> task);
    public static ValueTask`1<ISourceStream> WrapSourceStreamGeneric(ISourceStream`1<T> result);
    public static ValueTask`1<ISourceStream> WrapSourceStream(ISourceStream result);
    public static ValueTask`1<ISourceStream> WrapAsyncEnumerable(IAsyncEnumerable`1<T> result);
    public static ValueTask`1<ISourceStream> WrapEnumerable(IEnumerable`1<T> result);
    public static ValueTask`1<ISourceStream> WrapQueryable(IQueryable`1<T> result);
    public static ValueTask`1<ISourceStream> WrapObservable(IObservable`1<T> result);
    private static ISourceStream ConvertObservable(IObservable`1<T> enumerable);
    private static ISourceStream ConvertEnumerable(IEnumerable`1<T> enumerable);
    private static ISourceStream ConvertEnumerable(IAsyncEnumerable`1<T> enumerable);
}
[ExtensionAttribute]
internal static class HotChocolate.Resolvers.Expressions.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] types);
}
public static class HotChocolate.Resolvers.FieldClassMiddlewareFactory : object {
    private static MethodInfo _createGeneric;
    private static PropertyInfo _services;
    private static FieldClassMiddlewareFactory();
    public static FieldMiddleware Create(ValueTuple`2[] services);
    public static FieldMiddleware Create(Type middlewareType, ValueTuple`2[] services);
    public static FieldMiddleware Create(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    private static FieldDelegate CreateDelegate(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory, FieldDelegate next);
}
public class HotChocolate.Resolvers.FieldDelegate : MulticastDelegate {
    public FieldDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ValueTask Invoke(IMiddlewareContext context);
    public virtual IAsyncResult BeginInvoke(IMiddlewareContext context, AsyncCallback callback, object object);
    public virtual ValueTask EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Resolvers.FieldMember : FieldReferenceBase {
    private FieldReference _fieldReference;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public MemberInfo Member { get; }
    public Expression Expression { get; }
    [NullableContextAttribute("1")]
public FieldMember(string typeName, string fieldName, MemberInfo member);
    [NullableContextAttribute("1")]
public FieldMember(string typeName, string fieldName, Expression expression);
    [NullableContextAttribute("1")]
private FieldMember(string typeName, string fieldName, MemberInfo member, Expression expression);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [NullableContextAttribute("1")]
public FieldMember WithTypeName(string typeName);
    [NullableContextAttribute("1")]
public FieldMember WithFieldName(string fieldName);
    [NullableContextAttribute("1")]
public FieldMember WithMember(MemberInfo member);
    [NullableContextAttribute("1")]
public FieldMember WithExpression(Expression expression);
    public sealed virtual bool Equals(FieldMember other);
    public virtual bool Equals(object obj);
    private bool IsEqualTo(FieldMember other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public FieldReference ToFieldReference();
}
public class HotChocolate.Resolvers.FieldMiddleware : MulticastDelegate {
    public FieldMiddleware(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual FieldDelegate Invoke(FieldDelegate next);
    public virtual IAsyncResult BeginInvoke(FieldDelegate next, AsyncCallback callback, object object);
    public virtual FieldDelegate EndInvoke(IAsyncResult result);
}
public class HotChocolate.Resolvers.FieldReference : FieldReferenceBase {
    public FieldReference(string typeName, string fieldName);
    public FieldReference WithTypeName(string typeName);
    public FieldReference WithFieldName(string fieldName);
    public FieldMember WithMember(MemberInfo member);
    public FieldMember WithExpression(Expression expression);
    public FieldResolver WithResolver(FieldResolverDelegate resolver);
    public sealed virtual bool Equals(FieldReference other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Resolvers.FieldReferenceBase : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string TypeName { get; }
    public string FieldName { get; }
    protected FieldReferenceBase(string typeName, string fieldName);
    protected FieldReferenceBase(FieldReferenceBase fieldReference);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FieldName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
protected bool IsEqualTo(FieldReferenceBase other);
    protected bool IsReferenceEqualTo(T value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Resolvers.FieldResolver : FieldReferenceBase {
    [NullableAttribute("2")]
private FieldReference _fieldReference;
    [CompilerGeneratedAttribute]
private FieldResolverDelegate <Resolver>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PureFieldDelegate <PureResolver>k__BackingField;
    public FieldResolverDelegate Resolver { get; }
    [NullableAttribute("2")]
public PureFieldDelegate PureResolver { get; }
    public FieldResolver(string typeName, string fieldName, FieldResolverDelegate resolver, PureFieldDelegate pureResolver);
    public FieldResolver(FieldReference fieldReference, FieldResolverDelegate resolver, PureFieldDelegate pureResolver);
    [CompilerGeneratedAttribute]
public FieldResolverDelegate get_Resolver();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PureFieldDelegate get_PureResolver();
    public FieldResolver WithTypeName(string typeName);
    public FieldResolver WithFieldName(string fieldName);
    public FieldResolver WithResolver(FieldResolverDelegate resolver);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FieldResolver other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
private bool IsEqualTo(FieldResolver other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public FieldReference ToFieldReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class HotChocolate.Resolvers.FieldResolverConfig : ValueType {
    private bool _isEmpty;
    [CompilerGeneratedAttribute]
private FieldCoordinate <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldResolverDelegate <Resolver>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PureFieldDelegate <PureResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResultType>k__BackingField;
    public FieldCoordinate Field { get; }
    public FieldResolverDelegate Resolver { get; }
    [NullableAttribute("2")]
public PureFieldDelegate PureResolver { get; }
    public Type ResultType { get; }
    public bool IsDefault { get; }
    [NullableContextAttribute("2")]
public FieldResolverConfig(FieldCoordinate field, FieldResolverDelegate resolver, PureFieldDelegate pureResolver, Type resultType);
    [CompilerGeneratedAttribute]
public FieldCoordinate get_Field();
    [CompilerGeneratedAttribute]
public FieldResolverDelegate get_Resolver();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PureFieldDelegate get_PureResolver();
    [CompilerGeneratedAttribute]
public Type get_ResultType();
    public bool get_IsDefault();
    public FieldResolverDelegates ToFieldResolverDelegates();
}
public class HotChocolate.Resolvers.FieldResolverDelegate : MulticastDelegate {
    public FieldResolverDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ValueTask`1<object> Invoke(IResolverContext context);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, AsyncCallback callback, object object);
    public virtual ValueTask`1<object> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class HotChocolate.Resolvers.FieldResolverDelegates : ValueType {
    [CompilerGeneratedAttribute]
private FieldResolverDelegate <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private PureFieldDelegate <PureResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasResolvers>k__BackingField;
    public FieldResolverDelegate Resolver { get; }
    public PureFieldDelegate PureResolver { get; }
    public bool HasResolvers { get; }
    public FieldResolverDelegates(FieldResolverDelegate resolver, PureFieldDelegate pureResolver);
    [NullableContextAttribute("1")]
internal FieldResolverDelegates(FieldResolver resolver);
    [CompilerGeneratedAttribute]
public FieldResolverDelegate get_Resolver();
    [CompilerGeneratedAttribute]
public PureFieldDelegate get_PureResolver();
    [CompilerGeneratedAttribute]
public bool get_HasResolvers();
}
public interface HotChocolate.Resolvers.IDirectiveMiddleware {
    public string DirectiveName { get; }
    public abstract virtual string get_DirectiveName();
}
public interface HotChocolate.Resolvers.IFieldReference {
    public string TypeName { get; }
    public string FieldName { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual string get_FieldName();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Resolvers.IMiddlewareContext {
    [NullableAttribute("2")]
public IType ValueType { get; public set; }
    [NullableAttribute("2")]
public object Result { get; public set; }
    public bool IsResultModified { get; }
    public IOperationResultBuilder OperationResult { get; }
    [NullableContextAttribute("2")]
public abstract virtual IType get_ValueType();
    [NullableContextAttribute("2")]
public abstract virtual void set_ValueType(IType value);
    [NullableContextAttribute("2")]
public abstract virtual object get_Result();
    [NullableContextAttribute("2")]
public abstract virtual void set_Result(object value);
    public abstract virtual bool get_IsResultModified();
    public abstract virtual IOperationResultBuilder get_OperationResult();
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<T> ResolveAsync();
    public abstract virtual void RegisterForCleanup(Func`1<ValueTask> action, CleanAfter cleanAfter);
    public abstract virtual IReadOnlyDictionary`2<string, ArgumentValue> ReplaceArguments(IReadOnlyDictionary`2<string, ArgumentValue> newArgumentValues);
    public abstract virtual IReadOnlyDictionary`2<string, ArgumentValue> ReplaceArguments(ReplaceArguments replace);
    public abstract virtual ArgumentValue ReplaceArgument(string argumentName, ArgumentValue newArgumentValue);
    public abstract virtual IMiddlewareContext Clone();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Resolvers.IOperationResultBuilder {
    public abstract virtual void SetResultState(string key, object value);
    public abstract virtual void SetResultState(string key, UpdateState`1<object> value);
    public abstract virtual void SetResultState(string key, TState state, UpdateState`2<object, TState> value);
    public abstract virtual void SetExtension(string key, TValue value);
    public abstract virtual void SetExtension(string key, UpdateState`1<TValue> value);
    public abstract virtual void SetExtension(string key, TState state, UpdateState`2<TValue, TState> value);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Resolvers.IPureResolverContext {
    public ISchema Schema { get; }
    public IObjectType ObjectType { get; }
    public IOperation Operation { get; }
    public ISelection Selection { get; }
    public IVariableValueCollection Variables { get; }
    public Path Path { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> ScopedContextData { get; }
    public abstract virtual ISchema get_Schema();
    public abstract virtual IObjectType get_ObjectType();
    public abstract virtual IOperation get_Operation();
    public abstract virtual ISelection get_Selection();
    public abstract virtual IVariableValueCollection get_Variables();
    public abstract virtual Path get_Path();
    public abstract virtual IReadOnlyDictionary`2<string, object> get_ScopedContextData();
    public abstract virtual T Parent();
    public abstract virtual T ArgumentValue(string name);
    public abstract virtual TValueNode ArgumentLiteral(string name);
    public abstract virtual Optional`1<T> ArgumentOptional(string name);
    public abstract virtual ValueKind ArgumentKind(string name);
    public abstract virtual T Service();
    public abstract virtual T Resolver();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Resolvers.IResolverCompiler {
    [NullableContextAttribute("2")]
public abstract virtual FieldResolverDelegates CompileResolve(Expression`1<Func`2<TResolver, object>> propertyOrMethod, Type sourceType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public abstract virtual FieldResolverDelegates CompileResolve(LambdaExpression lambda, Type sourceType, Type resolverType);
    [NullableContextAttribute("2")]
public abstract virtual FieldResolverDelegates CompileResolve(MemberInfo member, Type sourceType, Type resolverType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public abstract virtual SubscribeResolverDelegate CompileSubscribe(MemberInfo member, Type sourceType, Type resolverType, IReadOnlyDictionary`2<ParameterInfo, string> argumentNames, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public abstract virtual IEnumerable`1<ParameterInfo> GetArgumentParameters(ParameterInfo[] parameters, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
    public abstract virtual void ApplyConfiguration(ParameterInfo[] parameters, ObjectFieldDescriptor descriptor);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Resolvers.IResolverContext {
    public IServiceProvider Services { get; public set; }
    public IServiceProvider RequestServices { get; }
    public string ResponseName { get; }
    public bool HasErrors { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IImmutableDictionary`2<string, object> ScopedContextData { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IImmutableDictionary`2<string, object> LocalContextData { get; public set; }
    public CancellationToken RequestAborted { get; }
    public abstract virtual IServiceProvider get_Services();
    public abstract virtual void set_Services(IServiceProvider value);
    public abstract virtual IServiceProvider get_RequestServices();
    public abstract virtual string get_ResponseName();
    public abstract virtual bool get_HasErrors();
    public abstract virtual IImmutableDictionary`2<string, object> get_ScopedContextData();
    public abstract virtual void set_ScopedContextData(IImmutableDictionary`2<string, object> value);
    public abstract virtual IImmutableDictionary`2<string, object> get_LocalContextData();
    public abstract virtual void set_LocalContextData(IImmutableDictionary`2<string, object> value);
    public abstract virtual CancellationToken get_RequestAborted();
    public abstract virtual object Service(Type service);
    public abstract virtual void ReportError(string errorMessage);
    public abstract virtual void ReportError(IError error);
    public abstract virtual void ReportError(Exception exception, Action`1<IErrorBuilder> configure);
    public abstract virtual IReadOnlyList`1<ISelection> GetSelections(IObjectType typeContext, ISelection selection, bool allowInternals);
    public abstract virtual T GetQueryRoot();
    public abstract virtual IResolverContext Clone();
}
public class HotChocolate.Resolvers.PureFieldDelegate : MulticastDelegate {
    public PureFieldDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(IPureResolverContext context);
    public virtual IAsyncResult BeginInvoke(IPureResolverContext context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class HotChocolate.Resolvers.ReplaceArguments : MulticastDelegate {
    public ReplaceArguments(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IReadOnlyDictionary`2<string, ArgumentValue> Invoke(IReadOnlyDictionary`2<string, ArgumentValue> currentArgumentValues);
    public virtual IAsyncResult BeginInvoke(IReadOnlyDictionary`2<string, ArgumentValue> currentArgumentValues, AsyncCallback callback, object object);
    public virtual IReadOnlyDictionary`2<string, ArgumentValue> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Resolvers.ResolveResultHelper : object {
    private static MethodInfo _awaitTaskHelper;
    private static MethodInfo _awaitValueTaskHelper;
    private static MethodInfo _wrapResultHelper;
    private static ResolveResultHelper();
    public static Expression EnsureResolveResult(Expression resolver, Type result);
    private static MethodCallExpression AwaitTaskMethodCall(Expression taskExpression, Type value);
    private static MethodCallExpression AwaitValueTaskMethodCall(Expression taskExpression, Type value);
    private static MethodCallExpression WrapResult(Expression taskExpression, Type value);
}
public class HotChocolate.Resolvers.ResultFormatterDelegate : MulticastDelegate {
    public ResultFormatterDelegate(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual object Invoke(IPureResolverContext context, object result);
    public virtual IAsyncResult BeginInvoke(IPureResolverContext context, object result, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class HotChocolate.Resolvers.SubscribeResolverDelegate : MulticastDelegate {
    public SubscribeResolverDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ValueTask`1<ISourceStream> Invoke(IResolverContext context);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, AsyncCallback callback, object object);
    public virtual ValueTask`1<ISourceStream> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Resolvers.SubscribeResultHelper : object {
    private static MethodInfo _awaitTaskSourceStreamGeneric;
    private static MethodInfo _awaitTaskSourceStream;
    private static MethodInfo _awaitTaskAsyncEnumerable;
    private static MethodInfo _awaitTaskEnumerable;
    private static MethodInfo _awaitTaskQueryable;
    private static MethodInfo _awaitTaskObservable;
    private static MethodInfo _awaitValueTaskSourceStreamGeneric;
    private static MethodInfo _awaitValueTaskAsyncEnumerable;
    private static MethodInfo _awaitValueTaskEnumerable;
    private static MethodInfo _awaitValueTaskQueryable;
    private static MethodInfo _awaitValueTaskObservable;
    private static MethodInfo _wrapSourceStreamGeneric;
    private static MethodInfo _wrapSourceStream;
    private static MethodInfo _wrapAsyncEnumerable;
    private static MethodInfo _wrapEnumerable;
    private static MethodInfo _wrapQueryable;
    private static MethodInfo _wrapObservable;
    private static SubscribeResultHelper();
    public static Expression EnsureSubscribeResult(Expression resolverExpression, Type resultType);
    private static MethodCallExpression AwaitTaskSourceStream(Expression taskExpression);
    private static MethodCallExpression AwaitTaskSourceStreamGeneric(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitTaskAsyncEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitTaskEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitTaskQueryable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitTaskObservable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitValueTaskSourceStreamGeneric(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitValueTaskAsyncEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitValueTaskEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitValueTaskQueryable(Expression taskExpression, Type valueType);
    private static MethodCallExpression AwaitValueTaskObservable(Expression taskExpression, Type valueType);
    private static MethodCallExpression WrapSourceStream(Expression taskExpression);
    private static MethodCallExpression WrapSourceStreamGeneric(Expression taskExpression, Type valueType);
    private static MethodCallExpression WrapAsyncEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression WrapEnumerable(Expression taskExpression, Type valueType);
    private static MethodCallExpression WrapQueryable(Expression taskExpression, Type valueType);
    private static MethodCallExpression WrapObservable(Expression taskExpression, Type valueType);
}
public class HotChocolate.Resolvers.UpdateState`1 : MulticastDelegate {
    public UpdateState`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TValue Invoke(string key, TValue currentValue);
    public virtual IAsyncResult BeginInvoke(string key, TValue currentValue, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class HotChocolate.Resolvers.UpdateState`2 : MulticastDelegate {
    public UpdateState`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TValue Invoke(string key, TValue currentValue, TState state);
    public virtual IAsyncResult BeginInvoke(string key, TValue currentValue, TState state, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Schema : TypeSystemObjectBase`1<SchemaTypeDefinition> {
    private SchemaTypes _types;
    private Dictionary`2<string, DirectiveType> _directiveTypes;
    [CompilerGeneratedAttribute]
private IDirectiveCollection <Directives>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<DirectiveType> <DirectiveTypes>k__BackingField;
    [NullableAttribute("0")]
private Action`1<ISchemaTypeDescriptor> _configure;
    private bool _sealed;
    public IDirectiveCollection Directives { get; private set; }
    public IServiceProvider Services { get; private set; }
    public ObjectType QueryType { get; }
    [NullableAttribute("2")]
public ObjectType MutationType { get; }
    [NullableAttribute("2")]
public ObjectType SubscriptionType { get; }
    public IReadOnlyCollection`1<INamedType> Types { get; }
    public IReadOnlyCollection`1<DirectiveType> DirectiveTypes { get; private set; }
    public static string DefaultName { get; }
    [NullableContextAttribute("0")]
public Schema(Action`1<ISchemaTypeDescriptor> configure);
    [CompilerGeneratedAttribute]
public sealed virtual IDirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
private void set_Directives(IDirectiveCollection value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
private void set_Services(IServiceProvider value);
    public sealed virtual ObjectType get_QueryType();
    [NullableContextAttribute("2")]
public sealed virtual ObjectType get_MutationType();
    [NullableContextAttribute("2")]
public sealed virtual ObjectType get_SubscriptionType();
    public sealed virtual IReadOnlyCollection`1<INamedType> get_Types();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<DirectiveType> get_DirectiveTypes();
    [CompilerGeneratedAttribute]
private void set_DirectiveTypes(IReadOnlyCollection`1<DirectiveType> value);
    public static string get_DefaultName();
    public sealed virtual T GetType(string typeName);
    public sealed virtual bool TryGetType(string typeName, T& type);
    public sealed virtual bool TryGetRuntimeType(string typeName, Type& runtimeType);
    public sealed virtual IReadOnlyList`1<ObjectType> GetPossibleTypes(INamedType abstractType);
    public sealed virtual DirectiveType GetDirectiveType(string directiveName);
    public sealed virtual bool TryGetDirectiveType(string directiveName, DirectiveType& directiveType);
    public sealed virtual DocumentNode ToDocument(bool includeSpecScalars);
    public sealed virtual string Print();
    public virtual string ToString();
    [NullableContextAttribute("0")]
protected virtual void Configure(ISchemaTypeDescriptor descriptor);
    [NullableContextAttribute("0")]
protected sealed virtual SchemaTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    [NullableContextAttribute("0")]
protected virtual void OnAfterInitialize(ITypeDiscoveryContext context, DefinitionBase definition);
    [NullableContextAttribute("0")]
protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, SchemaTypeDefinition definition);
    [NullableContextAttribute("0")]
protected virtual void OnCompleteType(ITypeCompletionContext context, SchemaTypeDefinition definition);
    [NullableContextAttribute("0")]
internal void CompleteSchema(SchemaTypesDefinition schemaTypesDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.SchemaBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _contextData;
    private List`1<FieldMiddleware> _globalComponents;
    private List`1<LoadSchemaDocument> _documents;
    private List`1<CreateRef> _types;
    private Dictionary`2<OperationType, CreateRef> _operations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, string>, List`1<CreateConvention>> _conventions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, ValueTuple`2<CreateRef, CreateRef>> _clrTypes;
    private List`1<object> _typeInterceptors;
    private SchemaOptions _options;
    [NullableAttribute("2")]
private IsOfTypeFallback _isOfType;
    [NullableAttribute("2")]
private IServiceProvider _services;
    [NullableAttribute("2")]
private CreateRef _schema;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    public Schema Create();
    public Schema Create(IDescriptorContext context);
    public DescriptorContext CreateContext();
    private sealed virtual override IDescriptorContext HotChocolate.ISchemaBuilder.CreateContext();
    private sealed virtual override ISchema HotChocolate.ISchemaBuilder.Create();
    private sealed virtual override ISchema HotChocolate.ISchemaBuilder.Create(IDescriptorContext context);
    public sealed virtual IDictionary`2<string, object> get_ContextData();
    public sealed virtual ISchemaBuilder SetSchema(Type type);
    public sealed virtual ISchemaBuilder SetSchema(ISchema schema);
    public sealed virtual ISchemaBuilder SetSchema(Action`1<ISchemaTypeDescriptor> configure);
    public sealed virtual ISchemaBuilder SetOptions(IReadOnlySchemaOptions options);
    public sealed virtual ISchemaBuilder ModifyOptions(Action`1<SchemaOptions> configure);
    public sealed virtual ISchemaBuilder Use(FieldMiddleware middleware);
    public sealed virtual ISchemaBuilder AddDocument(LoadSchemaDocument loadSchemaDocument);
    public sealed virtual ISchemaBuilder AddType(Type type);
    public sealed virtual ISchemaBuilder TryAddConvention(Type convention, CreateConvention factory, string scope);
    public sealed virtual ISchemaBuilder AddConvention(Type convention, CreateConvention factory, string scope);
    [ObsoleteAttribute]
public sealed virtual ISchemaBuilder BindClrType(Type clrType, Type schemaType);
    public sealed virtual ISchemaBuilder BindRuntimeType(Type runtimeType, Type schemaType);
    public sealed virtual ISchemaBuilder AddType(INamedType namedType);
    public sealed virtual ISchemaBuilder AddType(INamedTypeExtension typeExtension);
    internal void AddTypeReference(TypeReference typeReference);
    public sealed virtual ISchemaBuilder AddDirectiveType(DirectiveType type);
    public sealed virtual ISchemaBuilder AddRootType(Type rootType, OperationType operation);
    public sealed virtual ISchemaBuilder AddRootType(ObjectType rootType, OperationType operation);
    public sealed virtual ISchemaBuilder TryAddRootType(Func`1<ObjectType> rootType, OperationType operation);
    public sealed virtual ISchemaBuilder SetTypeResolver(IsOfTypeFallback isOfType);
    public sealed virtual ISchemaBuilder AddServices(IServiceProvider services);
    public sealed virtual ISchemaBuilder SetContextData(string key, object value);
    public sealed virtual ISchemaBuilder SetContextData(string key, Func`2<object, object> update);
    public sealed virtual ISchemaBuilder TryAddTypeInterceptor(Type interceptor);
    public sealed virtual ISchemaBuilder TryAddTypeInterceptor(TypeInterceptor interceptor);
    public static SchemaBuilder New();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.SchemaBuilderExtensions : object {
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, Type type, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, CreateConvention conventionFactory, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, Type convention, CreateConvention conventionFactory, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, Type convention, IConvention concreteConvention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, Type convention, Type concreteConvention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, IConvention convention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder AddConvention(ISchemaBuilder builder, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, Type convention, CreateConvention conventionFactory, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, Type convention, IConvention concreteConvention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, Type convention, Type concreteConvention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, CreateConvention conventionFactory, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, Type type, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, IConvention convention, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddConvention(ISchemaBuilder builder, string scope);
    [ExtensionAttribute]
public static ISchemaBuilder TryAddSchemaDirective(ISchemaBuilder builder, ISchemaDirective directive);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder AddDocumentFromString(ISchemaBuilder builder, string schema);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder AddDocumentFromFile(ISchemaBuilder builder, string filePath);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder AddDocument(ISchemaBuilder builder, DocumentNode document);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder TryAddTypeInterceptor(ISchemaBuilder builder);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder Use(ISchemaBuilder builder);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder Use(ISchemaBuilder builder, Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder Map(ISchemaBuilder builder, FieldReference fieldReference, FieldMiddleware middleware);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder Map(ISchemaBuilder builder, FieldReference fieldReference);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder Map(ISchemaBuilder builder, FieldReference fieldReference, Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ISchemaBuilder SetPagingOptions(ISchemaBuilder builder, PagingOptions options);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, FieldCoordinate field, FieldResolverDelegate resolver, Type resultType);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`2<IResolverContext, object> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`2<IResolverContext, ValueTask`1<object>> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`2<IResolverContext, TResult> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`2<IResolverContext, ValueTask`1<TResult>> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`1<object> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`1<ValueTask`1<object>> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`1<TResult> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`1<ValueTask`1<TResult>> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`3<IResolverContext, CancellationToken, object> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`3<IResolverContext, CancellationToken, TResult> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, Func`3<IResolverContext, CancellationToken, ValueTask`1<TResult>> resolver);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, object constantResult);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName, string fieldName, TResult constantResult);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, Type resolverType, string typeName);
    [ExtensionAttribute]
public static ISchemaBuilder AddResolver(ISchemaBuilder builder, string typeName);
    [ExtensionAttribute]
public static ISchemaBuilder AddRootResolver(ISchemaBuilder builder, Type resolverType);
    [ExtensionAttribute]
public static ISchemaBuilder AddRootResolver(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddRootResolver(ISchemaBuilder builder, T root);
    private static ISchemaBuilder AddResolverInternal(ISchemaBuilder builder, string typeName, string fieldName, FieldResolverDelegate resolver);
    private static ISchemaBuilder AddResolverConfigInternal(ISchemaBuilder builder, FieldCoordinate field, FieldResolverDelegate resolver, Type resultType);
    private static ISchemaBuilder AddResolverTypeInternal(ISchemaBuilder builder, string typeName, Type resolverType);
    private static void InitializeResolverTypeInterceptor(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryType(ISchemaBuilder builder, Type type);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryType(ISchemaBuilder builder, ObjectType queryType);
    [ExtensionAttribute]
public static ISchemaBuilder AddQueryType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddMutationType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddMutationType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddMutationType(ISchemaBuilder builder, Type type);
    [ExtensionAttribute]
public static ISchemaBuilder AddMutationType(ISchemaBuilder builder, ObjectType queryType);
    [ExtensionAttribute]
public static ISchemaBuilder AddMutationType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddSubscriptionType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddSubscriptionType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddSubscriptionType(ISchemaBuilder builder, Type type);
    [ExtensionAttribute]
public static ISchemaBuilder AddSubscriptionType(ISchemaBuilder builder, ObjectType queryType);
    [ExtensionAttribute]
public static ISchemaBuilder AddSubscriptionType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddObjectType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddObjectType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddObjectType(ISchemaBuilder builder, Action`1<IObjectTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddUnionType(ISchemaBuilder builder, Action`1<IUnionTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddUnionType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddUnionType(ISchemaBuilder builder, Action`1<IUnionTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddEnumType(ISchemaBuilder builder, Action`1<IEnumTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddEnumType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddEnumType(ISchemaBuilder builder, Action`1<IEnumTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddInterfaceType(ISchemaBuilder builder, Action`1<IInterfaceTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddInterfaceType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddInterfaceType(ISchemaBuilder builder, Action`1<IInterfaceTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddInputObjectType(ISchemaBuilder builder, Action`1<IInputObjectTypeDescriptor> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddInputObjectType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddInputObjectType(ISchemaBuilder builder, Action`1<IInputObjectTypeDescriptor`1<T>> configure);
    [ExtensionAttribute]
public static ISchemaBuilder AddType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder AddTypes(ISchemaBuilder builder, INamedType[] types);
    [ExtensionAttribute]
public static ISchemaBuilder AddTypes(ISchemaBuilder builder, Type[] types);
    [ExtensionAttribute]
public static ISchemaBuilder AddDirectiveType(ISchemaBuilder builder, Type directiveType);
    [ExtensionAttribute]
public static ISchemaBuilder AddDirectiveType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder SetSchema(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder BindRuntimeType(ISchemaBuilder builder);
    [ExtensionAttribute]
public static ISchemaBuilder BindRuntimeType(ISchemaBuilder builder, string typeName);
    [ExtensionAttribute]
public static ISchemaBuilder BindRuntimeType(ISchemaBuilder builder, Type runtimeType, string typeName);
    [ExtensionAttribute]
public static void TryBindRuntimeType(IDescriptorContext context, string typeName, Type runtimeType);
    private static ISchemaBuilder BindRuntimeTypeInternal(ISchemaBuilder builder, string typeName, Type runtimeType);
    [CompilerGeneratedAttribute]
internal static bool <AddDirectiveType>g__IsDirectiveBaseType|81_0(<>c__DisplayClass81_0& );
}
public class HotChocolate.SchemaErrorBuilder : object {
    private Error _error;
    public sealed virtual ISchemaErrorBuilder SetMessage(string message);
    public sealed virtual ISchemaErrorBuilder SetCode(string code);
    public sealed virtual ISchemaErrorBuilder SetPath(IReadOnlyCollection`1<object> path);
    public sealed virtual ISchemaErrorBuilder SetPath(Path path);
    public sealed virtual ISchemaErrorBuilder SetTypeSystemObject(ITypeSystemObject typeSystemObject);
    public sealed virtual ISchemaErrorBuilder AddSyntaxNode(ISyntaxNode syntaxNode);
    public sealed virtual ISchemaErrorBuilder SetExtension(string key, object value);
    public sealed virtual ISchemaErrorBuilder SetException(Exception exception);
    public sealed virtual ISchemaError Build();
    public static SchemaErrorBuilder New();
}
[ExtensionAttribute]
public static class HotChocolate.SchemaErrorBuilderExtensions : object {
    [ExtensionAttribute]
public static ISchemaErrorBuilder SetMessage(ISchemaErrorBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static ISchemaErrorBuilder SpecifiedBy(ISchemaErrorBuilder errorBuilder, string section, bool condition);
}
public class HotChocolate.SchemaException : Exception {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ISchemaError> <Errors>k__BackingField;
    public IReadOnlyList`1<ISchemaError> Errors { get; }
    public SchemaException(ISchemaError[] errors);
    public SchemaException(IReadOnlyList`1<ISchemaError> errors);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ISchemaError> get_Errors();
    private static string CreateErrorMessage(IReadOnlyList`1<ISchemaError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.SchemaExtensions : object {
    [ExtensionAttribute]
public static ObjectType GetOperationType(ISchema schema, OperationType operation);
    [ExtensionAttribute]
public static bool TryGetMember(ISchema schema, string coordinateString, ITypeSystemMember& member);
    [ExtensionAttribute]
public static bool TryGetMember(ISchema schema, SchemaCoordinate coordinate, ITypeSystemMember& member);
    [ExtensionAttribute]
public static ITypeSystemMember GetMember(ISchema schema, string coordinateString);
    [ExtensionAttribute]
public static ITypeSystemMember GetMember(ISchema schema, SchemaCoordinate coordinate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.SchemaOptions : object {
    private BindingBehavior _defaultBindingBehavior;
    private FieldBindingFlags _defaultFieldBindingFlags;
    private string _queryTypeName;
    [CompilerGeneratedAttribute]
private string <MutationTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscriptionTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseXmlDocumentation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<Assembly, string> <ResolveXmlDocumentationFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortFieldsByName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveSyntaxNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveUnreachableTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveUnusedTypeSystemDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldMiddlewareApplication <FieldMiddleware>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDirectiveIntrospection>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveVisibility <DefaultDirectiveVisibility>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionStrategy <DefaultResolverStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidatePipelineOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictRuntimeTypeValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private IsOfTypeFallback <DefaultIsOfTypeCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableOneOf>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnsureAllNodesCanBeResolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableFlagEnums>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDefer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAllowedNodeBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripLeadingIFromInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTrueNullability>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTag>k__BackingField;
    public string QueryTypeName { get; public set; }
    public string MutationTypeName { get; public set; }
    public string SubscriptionTypeName { get; public set; }
    public bool StrictValidation { get; public set; }
    public bool UseXmlDocumentation { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Assembly, string> ResolveXmlDocumentationFileName { get; public set; }
    public bool SortFieldsByName { get; public set; }
    public bool PreserveSyntaxNodes { get; public set; }
    public bool RemoveUnreachableTypes { get; public set; }
    public bool RemoveUnusedTypeSystemDirectives { get; public set; }
    public BindingBehavior DefaultBindingBehavior { get; public set; }
    public FieldBindingFlags DefaultFieldBindingFlags { get; public set; }
    public FieldMiddlewareApplication FieldMiddleware { get; public set; }
    public bool EnableDirectiveIntrospection { get; public set; }
    public DirectiveVisibility DefaultDirectiveVisibility { get; public set; }
    public ExecutionStrategy DefaultResolverStrategy { get; public set; }
    public bool ValidatePipelineOrder { get; public set; }
    public bool StrictRuntimeTypeValidation { get; public set; }
    public IsOfTypeFallback DefaultIsOfTypeCheck { get; public set; }
    public bool EnableOneOf { get; public set; }
    public bool EnsureAllNodesCanBeResolved { get; public set; }
    public bool EnableFlagEnums { get; public set; }
    public bool EnableDefer { get; public set; }
    public bool EnableStream { get; public set; }
    public int MaxAllowedNodeBatchSize { get; public set; }
    public bool StripLeadingIFromInterface { get; public set; }
    public bool EnableTrueNullability { get; public set; }
    public bool EnableTag { get; public set; }
    public sealed virtual string get_QueryTypeName();
    public void set_QueryTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MutationTypeName();
    [CompilerGeneratedAttribute]
public void set_MutationTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SubscriptionTypeName();
    [CompilerGeneratedAttribute]
public void set_SubscriptionTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StrictValidation();
    [CompilerGeneratedAttribute]
public void set_StrictValidation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseXmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_UseXmlDocumentation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Assembly, string> get_ResolveXmlDocumentationFileName();
    [CompilerGeneratedAttribute]
public void set_ResolveXmlDocumentationFileName(Func`2<Assembly, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SortFieldsByName();
    [CompilerGeneratedAttribute]
public void set_SortFieldsByName(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreserveSyntaxNodes();
    [CompilerGeneratedAttribute]
public void set_PreserveSyntaxNodes(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RemoveUnreachableTypes();
    [CompilerGeneratedAttribute]
public void set_RemoveUnreachableTypes(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RemoveUnusedTypeSystemDirectives();
    [CompilerGeneratedAttribute]
public void set_RemoveUnusedTypeSystemDirectives(bool value);
    public sealed virtual BindingBehavior get_DefaultBindingBehavior();
    public void set_DefaultBindingBehavior(BindingBehavior value);
    public sealed virtual FieldBindingFlags get_DefaultFieldBindingFlags();
    public void set_DefaultFieldBindingFlags(FieldBindingFlags value);
    [CompilerGeneratedAttribute]
public sealed virtual FieldMiddlewareApplication get_FieldMiddleware();
    [CompilerGeneratedAttribute]
public void set_FieldMiddleware(FieldMiddlewareApplication value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableDirectiveIntrospection();
    [CompilerGeneratedAttribute]
public void set_EnableDirectiveIntrospection(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual DirectiveVisibility get_DefaultDirectiveVisibility();
    [CompilerGeneratedAttribute]
public void set_DefaultDirectiveVisibility(DirectiveVisibility value);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionStrategy get_DefaultResolverStrategy();
    [CompilerGeneratedAttribute]
public void set_DefaultResolverStrategy(ExecutionStrategy value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ValidatePipelineOrder();
    [CompilerGeneratedAttribute]
public void set_ValidatePipelineOrder(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StrictRuntimeTypeValidation();
    [CompilerGeneratedAttribute]
public void set_StrictRuntimeTypeValidation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IsOfTypeFallback get_DefaultIsOfTypeCheck();
    [CompilerGeneratedAttribute]
public void set_DefaultIsOfTypeCheck(IsOfTypeFallback value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableOneOf();
    [CompilerGeneratedAttribute]
public void set_EnableOneOf(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnsureAllNodesCanBeResolved();
    [CompilerGeneratedAttribute]
public void set_EnsureAllNodesCanBeResolved(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableFlagEnums();
    [CompilerGeneratedAttribute]
public void set_EnableFlagEnums(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableDefer();
    [CompilerGeneratedAttribute]
public void set_EnableDefer(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableStream();
    [CompilerGeneratedAttribute]
public void set_EnableStream(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxAllowedNodeBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxAllowedNodeBatchSize(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StripLeadingIFromInterface();
    [CompilerGeneratedAttribute]
public void set_StripLeadingIFromInterface(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableTrueNullability();
    [CompilerGeneratedAttribute]
public void set_EnableTrueNullability(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableTag();
    [CompilerGeneratedAttribute]
public void set_EnableTag(bool value);
    [NullableContextAttribute("1")]
public static SchemaOptions FromOptions(IReadOnlySchemaOptions options);
}
public static class HotChocolate.SchemaPrinter : object {
    public static string Print(ISchema schema);
    public static void Serialize(ISchema schema, TextWriter textWriter);
    [AsyncStateMachineAttribute("HotChocolate.SchemaPrinter/<PrintAsync>d__2")]
public static ValueTask PrintAsync(ISchema schema, Stream stream, bool indented, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("HotChocolate.SchemaPrinter/<PrintAsync>d__3")]
public static ValueTask PrintAsync(IEnumerable`1<INamedType> namedTypes, Stream stream, bool indented, CancellationToken cancellationToken);
    public static DocumentNode PrintSchema(ISchema schema, bool includeSpecScalars, bool printResolverKind);
    private static IEnumerable`1<INamedType> GetNonScalarTypes(ISchema schema);
    private static bool IsPublicAndNoScalar(INamedType type);
    private static DirectiveDefinitionNode PrintDirectiveTypeDefinition(DirectiveType directiveType);
    private static SchemaDefinitionNode PrintSchemaTypeDefinition(ISchema schema);
    private static OperationTypeDefinitionNode PrintOperationType(ObjectType type, OperationType operation);
    private static ITypeDefinitionNode PrintNonScalarTypeDefinition(INamedType namedType, bool printResolverKind);
    private static ObjectTypeDefinitionNode PrintObjectType(ObjectType objectType, bool printResolverKind);
    private static InterfaceTypeDefinitionNode PrintInterfaceType(InterfaceType interfaceType);
    private static InputObjectTypeDefinitionNode PrintInputObjectType(InputObjectType inputObjectType);
    private static UnionTypeDefinitionNode PrintUnionType(UnionType unionType);
    private static EnumTypeDefinitionNode PrintEnumType(EnumType enumType);
    private static EnumValueDefinitionNode PrintEnumValue(IEnumValue enumValue);
    private static ScalarTypeDefinitionNode PrintScalarType(ScalarType scalarType);
    private static FieldDefinitionNode PrintObjectField(ObjectField field, bool printResolverKind);
    private static FieldDefinitionNode PrintInterfaceField(InterfaceField field);
    private static void PrintDeprecationDirective(ICollection`1<DirectiveNode> directives, bool isDeprecated, string deprecationReason);
    private static InputValueDefinitionNode PrintInputField(IInputField inputValue);
    private static ITypeNode PrintType(IType type);
    private static NamedTypeNode PrintNamedType(INamedType namedType);
    private static DirectiveNode PrintDirective(Directive directive);
    private static StringValueNode PrintDescription(string description);
}
[ExtensionAttribute]
internal static class HotChocolate.SchemaTools : object {
    [ExtensionAttribute]
public static void AddSchemaConfiguration(ISchemaBuilder builder, Action`1<ISchemaTypeDescriptor> configure);
    [ExtensionAttribute]
public static void AddSchemaConfiguration(IDescriptorContext context, Action`1<ISchemaTypeDescriptor> configure);
    [ExtensionAttribute]
public static void ApplySchemaConfigurations(IDescriptorContext context, ISchemaTypeDescriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.SchemaTypes : object {
    private Dictionary`2<string, INamedType> _types;
    private Dictionary`2<string, List`1<ObjectType>> _possibleTypes;
    [CompilerGeneratedAttribute]
private ObjectType <QueryType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ObjectType <MutationType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ObjectType <SubscriptionType>k__BackingField;
    public ObjectType QueryType { get; }
    [NullableAttribute("2")]
public ObjectType MutationType { get; }
    [NullableAttribute("2")]
public ObjectType SubscriptionType { get; }
    public SchemaTypes(SchemaTypesDefinition definition);
    [CompilerGeneratedAttribute]
public ObjectType get_QueryType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ObjectType get_MutationType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ObjectType get_SubscriptionType();
    public T GetType(string typeName);
    public bool TryGetType(string typeName, T& type);
    public IReadOnlyCollection`1<INamedType> GetTypes();
    public bool TryGetClrType(string typeName, Type& clrType);
    public bool TryGetPossibleTypes(string abstractTypeName, IReadOnlyList`1& types);
    private static Dictionary`2<string, List`1<ObjectType>> CreatePossibleTypeLookup(IReadOnlyCollection`1<INamedType> types);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class HotChocolate.SchemaTypesDefinition : object {
    [CompilerGeneratedAttribute]
private ObjectType <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectType <MutationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectType <SubscriptionType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<INamedType> <Types>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<DirectiveType> <DirectiveTypes>k__BackingField;
    public ObjectType QueryType { get; public set; }
    public ObjectType MutationType { get; public set; }
    public ObjectType SubscriptionType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<INamedType> Types { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<DirectiveType> DirectiveTypes { get; public set; }
    [CompilerGeneratedAttribute]
public ObjectType get_QueryType();
    [CompilerGeneratedAttribute]
public void set_QueryType(ObjectType value);
    [CompilerGeneratedAttribute]
public ObjectType get_MutationType();
    [CompilerGeneratedAttribute]
public void set_MutationType(ObjectType value);
    [CompilerGeneratedAttribute]
public ObjectType get_SubscriptionType();
    [CompilerGeneratedAttribute]
public void set_SubscriptionType(ObjectType value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<INamedType> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(IReadOnlyList`1<INamedType> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DirectiveType> get_DirectiveTypes();
    [CompilerGeneratedAttribute]
public void set_DirectiveTypes(IReadOnlyList`1<DirectiveType> value);
}
internal static class HotChocolate.TypeErrorFields : object {
    public static string Reference;
    public static string Definition;
}
internal class HotChocolate.Types.AggregateInputValueFormatter : object {
    [NullableAttribute("1")]
private IInputValueFormatter[] _formatters;
    [NullableContextAttribute("1")]
public AggregateInputValueFormatter(IEnumerable`1<IInputValueFormatter> formatters);
    [NullableContextAttribute("2")]
public sealed virtual object Format(object runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.AnyType : ScalarType {
    private ObjectValueToDictionaryConverter _objectValueToDictConverter;
    private ObjectToDictionaryConverter _objectToDictConverter;
    public Type RuntimeType { get; }
    public AnyType(string name, string description, BindingBehavior bind);
    public virtual Type get_RuntimeType();
    protected virtual void OnCompleteType(ITypeCompletionContext context, ScalarTypeDefinition definition);
    public virtual bool IsInstanceOfType(IValueNode literal);
    public virtual object ParseLiteral(IValueNode literal);
    public virtual IValueNode ParseValue(object value);
    private IValueNode ParseValue(object value, ISet`1<object> set);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
public enum HotChocolate.Types.ApplyConfigurationOn : Enum {
    public int value__;
    public static ApplyConfigurationOn Create;
    public static ApplyConfigurationOn BeforeNaming;
    public static ApplyConfigurationOn AfterNaming;
    public static ApplyConfigurationOn BeforeCompletion;
    public static ApplyConfigurationOn AfterCompletion;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Argument : FieldBase`1<ArgumentDefinition> {
    private Type _runtimeType;
    [CompilerGeneratedAttribute]
private ITypeSystemMember <DeclaringMember>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeprecationReason>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IValueNode <DefaultValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IInputValueFormatter <Formatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [NullableAttribute("2")]
public InputValueDefinitionNode SyntaxNode { get; }
    public ITypeSystemMember DeclaringMember { get; private set; }
    public IInputType Type { get; private set; }
    public bool IsDeprecated { get; }
    [NullableAttribute("2")]
public string DeprecationReason { get; }
    public Type RuntimeType { get; }
    [NullableAttribute("2")]
public IValueNode DefaultValue { get; private set; }
    [NullableAttribute("2")]
public IInputValueFormatter Formatter { get; }
    internal bool IsOptional { get; private set; }
    public Argument(ArgumentDefinition definition, int index);
    [NullableContextAttribute("2")]
public InputValueDefinitionNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public ITypeSystemMember get_DeclaringMember();
    [CompilerGeneratedAttribute]
private void set_DeclaringMember(ITypeSystemMember value);
    [CompilerGeneratedAttribute]
public sealed virtual IInputType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IInputType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeprecated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationReason();
    public virtual Type get_RuntimeType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IValueNode get_DefaultValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DefaultValue(IValueNode value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IInputValueFormatter get_Formatter();
    [CompilerGeneratedAttribute]
internal bool get_IsOptional();
    [CompilerGeneratedAttribute]
private void set_IsOptional(bool value);
    protected virtual void OnCompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember, ArgumentDefinition definition);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public abstract class HotChocolate.Types.ArgumentDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IArgumentDescriptor descriptor, ParameterInfo parameter);
}
[ExtensionAttribute]
public static class HotChocolate.Types.ArgumentDescriptorExtensions : object {
    [ExtensionAttribute]
public static IArgumentDescriptor DefaultValueSyntax(IArgumentDescriptor descriptor, string syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.BindFieldAttribute : ObjectFieldDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Replace>k__BackingField;
    public string Name { get; }
    public bool Replace { get; public set; }
    public BindFieldAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Replace();
    [CompilerGeneratedAttribute]
public void set_Replace(bool value);
    protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
    [CompilerGeneratedAttribute]
private void <OnConfigure>b__8_0(ObjectFieldDefinition d);
}
public enum HotChocolate.Types.BindingBehavior : Enum {
    public int value__;
    public static BindingBehavior Implicit;
    public static BindingBehavior Explicit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.BindMemberAttribute : ObjectFieldDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Replace>k__BackingField;
    public string Name { get; }
    public bool Replace { get; public set; }
    public BindMemberAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Replace();
    [CompilerGeneratedAttribute]
public void set_Replace(bool value);
    protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
    [CompilerGeneratedAttribute]
private void <OnConfigure>b__8_0(ObjectFieldDefinition d);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[SpecScalarAttribute]
public class HotChocolate.Types.BooleanType : ScalarType`2<bool, BooleanValueNode> {
    public BooleanType(string name, string description, BindingBehavior bind);
    protected virtual bool ParseLiteral(BooleanValueNode valueSyntax);
    protected virtual BooleanValueNode ParseValue(bool runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.ByteArrayType : ScalarType`2<Byte[], StringValueNode> {
    public ByteArrayType(string name, string description, BindingBehavior bind);
    protected virtual Byte[] ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(Byte[] runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.ByteType : IntegerTypeBase`1<byte> {
    public ByteType(byte min, byte max);
    public ByteType(string name, string description, byte min, byte max, BindingBehavior bind);
    protected virtual byte ParseLiteral(IntValueNode valueSyntax);
    protected virtual IntValueNode ParseValue(byte runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.CostAttribute : ObjectFieldDescriptorAttribute {
    private int _complexity;
    private Nullable`1<int> _defaultMultiplier;
    private MultiplierPathString[] _multipliers;
    public CostAttribute(int complexity);
    public CostAttribute(int complexity, String[] multipliers);
    public CostAttribute(int complexity, int defaultMultiplier, String[] multipliers);
    protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
public class HotChocolate.Types.CostDirective : object {
    [CompilerGeneratedAttribute]
private int <Complexity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MultiplierPathString> <Multipliers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DefaultMultiplier>k__BackingField;
    public int Complexity { get; }
    public IReadOnlyList`1<MultiplierPathString> Multipliers { get; }
    public Nullable`1<int> DefaultMultiplier { get; }
    public CostDirective(int complexity);
    public CostDirective(int complexity, MultiplierPathString[] multipliers);
    public CostDirective(int complexity, int defaultMultiplier, MultiplierPathString[] multipliers);
    private CostDirective(int complexity, IReadOnlyList`1<MultiplierPathString> multipliers, Nullable`1<int> defaultMultiplier);
    [CompilerGeneratedAttribute]
public int get_Complexity();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MultiplierPathString> get_Multipliers();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DefaultMultiplier();
}
public class HotChocolate.Types.CostDirectiveType : DirectiveType`1<CostDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<CostDirective> descriptor);
}
[ExtensionAttribute]
public static class HotChocolate.Types.CostInterfaceFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor Cost(IInterfaceFieldDescriptor descriptor, int complexity);
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor Cost(IInterfaceFieldDescriptor descriptor, int complexity, MultiplierPathString multiplier);
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor Cost(IInterfaceFieldDescriptor descriptor, int complexity, MultiplierPathString[] multipliers);
}
[ExtensionAttribute]
public static class HotChocolate.Types.CostObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor Cost(IObjectFieldDescriptor descriptor, int complexity);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Cost(IObjectFieldDescriptor descriptor, int complexity, MultiplierPathString multiplier);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Cost(IObjectFieldDescriptor descriptor, int complexity, MultiplierPathString[] multipliers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.CostTypeInterceptor : TypeInterceptor {
    private static string _connectionType;
    private static string _complexitySettings;
    private bool _pagingSettingsResolved;
    private bool _costSettingsResolved;
    private PagingOptions _pagingOptions;
    private ICostSettings _costSettings;
    public virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    private void ApplyConnectionCosts(ObjectFieldDefinition field);
    private void ApplyDataResolverCosts(ObjectFieldDefinition field);
    private bool CanApplyDefaultCost(ObjectFieldDefinition field);
    private static bool IsCostDirective(DirectiveDefinition directive);
    internal static bool IsDataResolver(ObjectFieldDefinition field);
    private static bool IsConnection(ObjectFieldDefinition field);
    private void EnsurePagingSettingsAreLoaded(IDescriptorContext descriptorContext);
    private void EnsureCostSettingsAreLoaded(IDescriptorContext descriptorContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.DateTimeType : ScalarType`2<DateTimeOffset, StringValueNode> {
    private static string _utcFormat;
    private static string _localFormat;
    private static string _specifiedBy;
    public DateTimeType(string name, string description, BindingBehavior bind);
    protected virtual DateTimeOffset ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(DateTimeOffset runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    private static string Serialize(DateTimeOffset value);
    [NullableContextAttribute("2")]
private static bool TryDeserializeFromString(string serialized, Nullable`1& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.DateType : ScalarType`2<DateTime, StringValueNode> {
    private static string _dateFormat;
    public DateType(string name, string description, BindingBehavior bind);
    protected virtual DateTime ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(DateTime runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    private static string Serialize(DateTime value);
    [NullableContextAttribute("2")]
private static bool TryDeserializeFromString(string serialized, Nullable`1& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.DecimalType : FloatTypeBase`1<decimal> {
    public DecimalType(decimal min, decimal max);
    public DecimalType(string name, string description, decimal min, decimal max, BindingBehavior bind);
    protected virtual decimal ParseLiteral(IFloatValueLiteral valueSyntax);
    protected virtual FloatValueNode ParseValue(decimal runtimeValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2176")]
public class HotChocolate.Types.DefaultValueAttribute : DescriptorAttribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public DefaultValueAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("1")]
protected internal virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2176")]
public class HotChocolate.Types.DefaultValueSyntaxAttribute : DescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    public string Syntax { get; }
    public DefaultValueSyntaxAttribute(string syntax);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [NullableContextAttribute("1")]
protected internal virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.DeferDirective : object {
    [CompilerGeneratedAttribute]
private bool <If>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public bool If { get; }
    public string Label { get; }
    public DeferDirective(bool if, string label);
    [CompilerGeneratedAttribute]
public bool get_If();
    [CompilerGeneratedAttribute]
public string get_Label();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.DeferDirectiveType : DirectiveType`1<DeferDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<DeferDirective> descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.DeprecatedDirective : object {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public DeprecatedDirective(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [NullableContextAttribute("1")]
public DirectiveNode ToNode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static DirectiveNode CreateNode(string reason);
}
public class HotChocolate.Types.DeprecatedDirectiveType : DirectiveType`1<DeprecatedDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<DeprecatedDirective> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.DescriptorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    protected internal abstract virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected static void ApplyAttribute(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element, T attribute);
}
public class HotChocolate.Types.Descriptors.ArgumentDescriptor : ArgumentDescriptorBase`1<ArgumentDefinition> {
    protected internal ArgumentDescriptor(IDescriptorContext context, string argumentName);
    protected internal ArgumentDescriptor(IDescriptorContext context, string argumentName, Type argumentType);
    protected internal ArgumentDescriptor(IDescriptorContext context, ParameterInfo parameter);
    protected internal ArgumentDescriptor(IDescriptorContext context, ArgumentDefinition definition);
    protected virtual void OnCreateDefinition(ArgumentDefinition definition);
    public sealed virtual IArgumentDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public sealed virtual IArgumentDescriptor Deprecated(string reason);
    public sealed virtual IArgumentDescriptor Deprecated();
    public sealed virtual IArgumentDescriptor Description(string value);
    public sealed virtual IArgumentDescriptor Type();
    public sealed virtual IArgumentDescriptor Type(TInputType inputType);
    public sealed virtual IArgumentDescriptor Type(ITypeNode typeNode);
    public sealed virtual IArgumentDescriptor Type(Type type);
    public sealed virtual IArgumentDescriptor DefaultValue(IValueNode value);
    public sealed virtual IArgumentDescriptor DefaultValue(object value);
    public sealed virtual IArgumentDescriptor Directive(TDirective directiveInstance);
    public sealed virtual IArgumentDescriptor Directive();
    public sealed virtual IArgumentDescriptor Directive(string name, ArgumentNode[] arguments);
    public static ArgumentDescriptor New(IDescriptorContext context, string argumentName);
    public static ArgumentDescriptor New(IDescriptorContext context, string argumentName, Type argumentType);
    public static ArgumentDescriptor New(IDescriptorContext context, ParameterInfo parameter);
    public static ArgumentDescriptor From(IDescriptorContext context, ArgumentDefinition argumentDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.ArgumentDescriptorBase`1 : DescriptorBase`1<T> {
    [CompilerGeneratedAttribute]
private T <Definition>k__BackingField;
    protected internal T Definition { get; protected set; }
    protected ArgumentDescriptorBase`1(IDescriptorContext context);
    [CompilerGeneratedAttribute]
protected internal virtual T get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(T value);
    protected void SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    [NullableContextAttribute("2")]
protected void Deprecated(string reason);
    protected void Deprecated();
    protected void Description(string value);
    [NullableContextAttribute("0")]
public void Type();
    public void Type(Type type);
    public void Type(TInputType inputType);
    public void Type(TypeReference typeReference);
    public void Type(ITypeNode typeNode);
    [NullableContextAttribute("2")]
public void DefaultValue(IValueNode value);
    [NullableContextAttribute("2")]
public void DefaultValue(object value);
    public void Directive(TDirective directiveInstance);
    public void Directive();
    public void Directive(string name, ArgumentNode[] arguments);
}
internal class HotChocolate.Types.Descriptors.CompletedDependencyDescriptor : DependencyDescriptorBase {
    protected TypeDependencyFulfilled DependencyFulfilled { get; }
    public CompletedDependencyDescriptor(ITypeInspector typeInspector, CompleteConfiguration configuration);
    protected virtual TypeDependencyFulfilled get_DependencyFulfilled();
    public sealed virtual ICompletedDependencyDescriptor DependsOn();
    public sealed virtual ICompletedDependencyDescriptor DependsOn(bool mustBeCompleted);
    public sealed virtual ICompletedDependencyDescriptor DependsOn(Type schemaType);
    public sealed virtual ICompletedDependencyDescriptor DependsOn(Type schemaType, bool mustBeCompleted);
    public sealed virtual ICompletedDependencyDescriptor DependsOn(string typeName);
    public sealed virtual ICompletedDependencyDescriptor DependsOn(string typeName, bool mustBeCompleted);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.Convention : object {
    private string _scope;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public string Scope { get; protected set; }
    protected bool IsInitialized { get; private set; }
    public sealed virtual string get_Scope();
    protected void set_Scope(string value);
    [CompilerGeneratedAttribute]
protected bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    [NullableContextAttribute("1")]
protected internal virtual void Initialize(IConventionContext context);
    [NullableContextAttribute("1")]
protected internal virtual void Complete(IConventionContext context);
    protected void MarkInitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.Convention`1 : Convention {
    [NullableAttribute("2")]
private TDefinition _definition;
    [NullableAttribute("2")]
protected TDefinition Definition { get; }
    [NullableContextAttribute("2")]
protected virtual TDefinition get_Definition();
    protected internal sealed virtual void Initialize(IConventionContext context);
    protected internal virtual void Complete(IConventionContext context);
    protected abstract virtual TDefinition CreateDefinition(IConventionContext context);
    private void AssertUninitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Descriptors.ConventionContext : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IDescriptorContext <DescriptorContext>k__BackingField;
    [NullableAttribute("2")]
public string Scope { get; }
    public IServiceProvider Services { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    public IDescriptorContext DescriptorContext { get; }
    public ConventionContext(string scope, IServiceProvider services, IDescriptorContext descriptorContext);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Scope();
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProvider get_Services();
    public sealed virtual IDictionary`2<string, object> get_ContextData();
    [CompilerGeneratedAttribute]
public sealed virtual IDescriptorContext get_DescriptorContext();
    public static ConventionContext Create(string scope, IServiceProvider services, IDescriptorContext descriptorContext);
}
public abstract class HotChocolate.Types.Descriptors.ConventionExtension : Convention {
    public abstract virtual void Merge(IConventionContext context, Convention convention);
    protected internal sealed virtual void Complete(IConventionContext context);
}
public abstract class HotChocolate.Types.Descriptors.ConventionExtension`1 : Convention`1<TDefinition> {
    public abstract virtual void Merge(IConventionContext context, Convention convention);
}
internal enum HotChocolate.Types.Descriptors.ConventionStatus : Enum {
    public int value__;
    public static ConventionStatus Uninitialized;
    public static ConventionStatus Initialized;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.DefaultNamingConventions : Convention {
    private static string _inputPostfix;
    private static string _inputTypePostfix;
    private static string _directivePostfix;
    private static string _directiveTypePostfix;
    private IDocumentationProvider _documentation;
    private bool _formatInterfaceName;
    protected IDocumentationProvider DocumentationProvider { get; }
    public DefaultNamingConventions(IDocumentationProvider documentation);
    protected IDocumentationProvider get_DocumentationProvider();
    protected internal virtual void Initialize(IConventionContext context);
    public virtual string GetTypeName(Type type);
    public virtual string GetTypeName(Type type, TypeKind kind);
    public virtual string GetTypeDescription(Type type, TypeKind kind);
    public virtual string GetMemberName(MemberInfo member, MemberKind kind);
    public virtual string GetMemberDescription(MemberInfo member, MemberKind kind);
    public virtual string GetArgumentName(ParameterInfo parameter);
    public virtual string GetArgumentDescription(ParameterInfo parameter);
    public virtual string GetEnumValueName(object value);
    public virtual string GetEnumValueDescription(object value);
    public virtual bool IsDeprecated(MemberInfo member, String& reason);
    public virtual bool IsDeprecated(object value, String& reason);
    public sealed virtual string FormatFieldName(string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.DefaultTypeInspector : Convention {
    private static string _toString;
    private static string _getHashCode;
    private static string _compareTo;
    private static string _equals;
    private static string _clone;
    private TypeCache _typeCache;
    private Dictionary`2<MemberInfo, ExtendedMethodInfo> _methods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`3<Type, bool, bool>, MemberInfo[]> _memberCache;
    [CompilerGeneratedAttribute]
private bool <IgnoreRequiredAttribute>k__BackingField;
    public bool IgnoreRequiredAttribute { get; protected set; }
    public DefaultTypeInspector(bool ignoreRequiredAttribute);
    [CompilerGeneratedAttribute]
public bool get_IgnoreRequiredAttribute();
    [CompilerGeneratedAttribute]
protected void set_IgnoreRequiredAttribute(bool value);
    public sealed virtual ReadOnlySpan`1<MemberInfo> GetMembers(Type type, bool includeIgnored, bool includeStatic, bool allowObject);
    public virtual bool IsMemberIgnored(MemberInfo member);
    public virtual TypeReference GetReturnTypeRef(MemberInfo member, TypeContext context, string scope, bool ignoreAttributes);
    public virtual IExtendedType GetReturnType(MemberInfo member, bool ignoreAttributes);
    public sealed virtual TypeReference GetArgumentTypeRef(ParameterInfo parameter, string scope, bool ignoreAttributes);
    public virtual IExtendedType GetArgumentType(ParameterInfo parameter, bool ignoreAttributes);
    private IExtendedType GetArgumentTypeInternal(ParameterInfo parameter);
    public sealed virtual ExtendedTypeReference GetTypeRef(Type type, TypeContext context, string scope);
    public sealed virtual IExtendedType GetType(Type type);
    public sealed virtual IExtendedType GetType(Type type, Nullable`1[] nullable);
    public sealed virtual IExtendedType GetType(Type type, ReadOnlySpan`1<Nullable`1<bool>> nullable);
    public virtual IEnumerable`1<object> GetEnumValues(Type enumType);
    public sealed virtual MemberInfo GetEnumValueMember(object value);
    public virtual MemberInfo GetNodeIdMember(Type type);
    [NullableContextAttribute("2")]
public virtual MethodInfo GetNodeResolverMethod(Type nodeType, Type resolverType);
    private static bool IsPossibleNodeResolver(MemberInfo member, Type nodeType);
    private static bool IsPossibleExternalNodeResolver(MemberInfo member, Type nodeType);
    public sealed virtual Type ExtractNamedType(Type type);
    public sealed virtual bool IsSchemaType(Type type);
    public sealed virtual void ApplyAttributes(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider attributeProvider);
    public virtual bool TryGetDefaultValue(ParameterInfo parameter, Object& defaultValue);
    public virtual bool TryGetDefaultValue(PropertyInfo property, Object& defaultValue);
    public sealed virtual IExtendedType ChangeNullability(IExtendedType type, Nullable`1[] nullable);
    private IExtendedType ChangeNullabilityInternal(IExtendedType type, Boolean[] nullable);
    public sealed virtual IExtendedType ChangeNullability(IExtendedType type, ReadOnlySpan`1<Nullable`1<bool>> nullable);
    public sealed virtual Nullable`1[] CollectNullability(IExtendedType type);
    [NullableContextAttribute("0")]
public sealed virtual bool CollectNullability(IExtendedType type, Span`1<Nullable`1<bool>> buffer, Int32& written);
    public sealed virtual ITypeInfo CreateTypeInfo(Type type);
    public sealed virtual ITypeInfo CreateTypeInfo(IExtendedType type);
    public sealed virtual ITypeFactory CreateTypeFactory(IExtendedType type);
    public sealed virtual bool TryCreateTypeInfo(Type type, ITypeInfo& typeInfo);
    public sealed virtual bool TryCreateTypeInfo(IExtendedType type, ITypeInfo& typeInfo);
    private IExtendedType ApplyTypeAttributes(IExtendedType type, ICustomAttributeProvider attributeProvider);
    private static bool TryGetAttribute(ICustomAttributeProvider attributeProvider, T& attribute);
    private bool CanBeHandled(MemberInfo member, bool includeIgnored, bool allowObjectType);
    private static bool CanHandleReturnType(MemberInfo member, Type returnType, bool allowObjectType);
    private static bool CanHandleParameter(ParameterInfo parameter, bool allowObjectType);
    private static bool HasConfiguration(ICustomAttributeProvider element);
    private static bool IsSystemMember(MemberInfo member);
    private bool TryGetDefaultValueFromConstructor(PropertyInfo property, Object& defaultValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.ArgumentDefinition : FieldDefinitionBase`1<InputValueDefinitionNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IInputValueFormatter> _formatters;
    [CompilerGeneratedAttribute]
private IValueNode <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RuntimeDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    public IValueNode DefaultValue { get; public set; }
    public object RuntimeDefaultValue { get; public set; }
    public ParameterInfo Parameter { get; public set; }
    public Type RuntimeType { get; public set; }
    [NullableAttribute("1")]
public IList`1<IInputValueFormatter> Formatters { get; }
    public ArgumentDefinition(string name, string description, TypeReference type, IValueNode defaultValue, object runtimeDefaultValue);
    [CompilerGeneratedAttribute]
public IValueNode get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(IValueNode value);
    [CompilerGeneratedAttribute]
public object get_RuntimeDefaultValue();
    [CompilerGeneratedAttribute]
public void set_RuntimeDefaultValue(object value);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(ParameterInfo value);
    [CompilerGeneratedAttribute]
public Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public void set_RuntimeType(Type value);
    [NullableContextAttribute("1")]
public IList`1<IInputValueFormatter> get_Formatters();
    [NullableContextAttribute("1")]
public IReadOnlyList`1<IInputValueFormatter> GetFormatters();
    [NullableContextAttribute("1")]
internal void CopyTo(ArgumentDefinition target);
    [NullableContextAttribute("1")]
internal void MergeInto(ArgumentDefinition target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class HotChocolate.Types.Descriptors.Definitions.BindableList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<T> _list;
    [CompilerGeneratedAttribute]
private BindingBehavior <BindingBehavior>k__BackingField;
    public BindingBehavior BindingBehavior { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual BindingBehavior get_BindingBehavior();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BindingBehavior(BindingBehavior value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void AddRange(IEnumerable`1<T> items);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class HotChocolate.Types.Descriptors.Definitions.BindableListExtensions : object {
    [ExtensionAttribute]
public static bool IsImplicitBinding(IBindableList`1<T> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration : object {
    private Action`2<ITypeCompletionContext, IDefinition> _configure;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TypeDependency> _dependencies;
    [CompilerGeneratedAttribute]
private IDefinition <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplyConfigurationOn <On>k__BackingField;
    public IDefinition Owner { get; }
    public ApplyConfigurationOn On { get; }
    public IReadOnlyList`1<TypeDependency> Dependencies { get; }
    public CompleteConfiguration(Action`2<ITypeCompletionContext, IDefinition> configure, IDefinition owner, ApplyConfigurationOn on, TypeReference typeReference, TypeDependencyFulfilled fulfilled);
    public CompleteConfiguration(Action`2<ITypeCompletionContext, IDefinition> configure, IDefinition owner, ApplyConfigurationOn on, IEnumerable`1<TypeDependency> dependencies);
    [CompilerGeneratedAttribute]
public sealed virtual IDefinition get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual ApplyConfigurationOn get_On();
    public sealed virtual IReadOnlyList`1<TypeDependency> get_Dependencies();
    public sealed virtual void AddDependency(TypeDependency dependency);
    public void Configure(ITypeCompletionContext context);
    public sealed virtual ITypeSystemMemberConfiguration Copy(DefinitionBase newOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.CompleteConfiguration`1 : CompleteConfiguration {
    public CompleteConfiguration`1(Action`2<ITypeCompletionContext, TDefinition> configure, TDefinition owner, ApplyConfigurationOn on, TypeReference typeReference, TypeDependencyFulfilled fulfilled);
    public CompleteConfiguration`1(Action`2<ITypeCompletionContext, TDefinition> configure, TDefinition owner, ApplyConfigurationOn on, IEnumerable`1<TypeDependency> dependencies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.CreateConfiguration : object {
    private Action`2<IDescriptorContext, IDefinition> _configure;
    [CompilerGeneratedAttribute]
private IDefinition <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TypeDependency> <Dependencies>k__BackingField;
    public IDefinition Owner { get; }
    public ApplyConfigurationOn On { get; }
    public IReadOnlyList`1<TypeDependency> Dependencies { get; }
    public CreateConfiguration(Action`2<IDescriptorContext, IDefinition> configure, IDefinition owner);
    [CompilerGeneratedAttribute]
public sealed virtual IDefinition get_Owner();
    public sealed virtual ApplyConfigurationOn get_On();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<TypeDependency> get_Dependencies();
    public sealed virtual void AddDependency(TypeDependency dependency);
    public void Configure(IDescriptorContext context);
    public sealed virtual ITypeSystemMemberConfiguration Copy(DefinitionBase newOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.DefinitionBase : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TypeDependency> _dependencies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ITypeSystemMemberConfiguration> _configurations;
    [NullableAttribute("2")]
private ExtensionData _contextData;
    private string _name;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <BindTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AttributesAreApplied>k__BackingField;
    public string Name { get; public set; }
    [NullableAttribute("2")]
public string Description { get; public set; }
    [NullableAttribute("2")]
public string BindTo { get; public set; }
    public ExtensionData ContextData { get; }
    public IList`1<TypeDependency> Dependencies { get; }
    public bool HasDependencies { get; }
    public IList`1<ITypeSystemMemberConfiguration> Configurations { get; }
    public bool HasConfigurations { get; }
    public bool AttributesAreApplied { get; public set; }
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_BindTo();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_BindTo(string value);
    public virtual ExtensionData get_ContextData();
    public sealed virtual IList`1<TypeDependency> get_Dependencies();
    public sealed virtual bool get_HasDependencies();
    public sealed virtual IList`1<ITypeSystemMemberConfiguration> get_Configurations();
    public sealed virtual bool get_HasConfigurations();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AttributesAreApplied();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AttributesAreApplied(bool value);
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
    public IReadOnlyList`1<TypeDependency> GetDependencies();
    public IReadOnlyDictionary`2<string, object> GetContextData();
    public void TouchContextData();
    protected void CopyTo(DefinitionBase target);
    protected void MergeInto(DefinitionBase target);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.DefinitionBase`1 : DefinitionBase {
    [CompilerGeneratedAttribute]
private T <SyntaxNode>k__BackingField;
    public T SyntaxNode { get; public set; }
    private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    [CompilerGeneratedAttribute]
public T get_SyntaxNode();
    [CompilerGeneratedAttribute]
public void set_SyntaxNode(T value);
    private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    [NullableContextAttribute("1")]
protected void CopyTo(DefinitionBase`1<T> target);
    [NullableContextAttribute("1")]
protected void MergeInto(DefinitionBase`1<T> target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.DirectiveArgumentDefinition : ArgumentDefinition {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; public set; }
    public DirectiveArgumentDefinition(string name, string description, TypeReference type, IValueNode defaultValue, object runtimeDefaultValue);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(PropertyInfo value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.DirectiveDefinition : object {
    [CompilerGeneratedAttribute]
private TypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public TypeReference Type { get; }
    public object Value { get; }
    public DirectiveDefinition(DirectiveNode directiveNode);
    public DirectiveDefinition(object directive, ExtendedTypeDirectiveReference extendedTypeDirectiveType);
    [CompilerGeneratedAttribute]
public TypeReference get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.DirectiveTypeDefinition : DefinitionBase`1<DirectiveDefinitionNode> {
    private Type _clrType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DirectiveMiddleware> _middlewareComponents;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BindableList`1<DirectiveArgumentDefinition> _arguments;
    [CompilerGeneratedAttribute]
private bool <IsRepeatable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveLocation <Locations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<Object[], object> <CreateInstance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, Object[]> <GetFieldData>k__BackingField;
    public bool IsRepeatable { get; public set; }
    public bool IsPublic { get; public set; }
    public Type RuntimeType { get; public set; }
    public IList`1<DirectiveMiddleware> MiddlewareComponents { get; }
    public DirectiveLocation Locations { get; public set; }
    public IBindableList`1<DirectiveArgumentDefinition> Arguments { get; }
    public bool HasArguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], object> CreateInstance { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, Object[]> GetFieldData { get; public set; }
    [NullableContextAttribute("2")]
public DirectiveTypeDefinition(string name, string description, Type runtimeType, bool isRepeatable);
    [CompilerGeneratedAttribute]
public bool get_IsRepeatable();
    [CompilerGeneratedAttribute]
public void set_IsRepeatable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    public sealed virtual Type get_RuntimeType();
    public void set_RuntimeType(Type value);
    public IList`1<DirectiveMiddleware> get_MiddlewareComponents();
    [CompilerGeneratedAttribute]
public DirectiveLocation get_Locations();
    [CompilerGeneratedAttribute]
public void set_Locations(DirectiveLocation value);
    public IBindableList`1<DirectiveArgumentDefinition> get_Arguments();
    public bool get_HasArguments();
    [CompilerGeneratedAttribute]
public Func`2<Object[], object> get_CreateInstance();
    [CompilerGeneratedAttribute]
public void set_CreateInstance(Func`2<Object[], object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, Object[]> get_GetFieldData();
    [CompilerGeneratedAttribute]
public void set_GetFieldData(Action`2<object, Object[]> value);
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
    internal IReadOnlyList`1<DirectiveMiddleware> GetMiddlewareComponents();
    internal IReadOnlyList`1<DirectiveArgumentDefinition> GetArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.EnumTypeDefinition : TypeDefinitionBase`1<EnumTypeDefinitionNode> {
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<string> <NameComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<object> <ValueComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindableList`1<EnumValueDefinition> <Values>k__BackingField;
    public IEqualityComparer`1<string> NameComparer { get; public set; }
    public IEqualityComparer`1<object> ValueComparer { get; public set; }
    public IBindableList`1<EnumValueDefinition> Values { get; }
    [NullableContextAttribute("2")]
public EnumTypeDefinition(string name, string description, Type runtimeType);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<string> get_NameComparer();
    [CompilerGeneratedAttribute]
public void set_NameComparer(IEqualityComparer`1<string> value);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<object> get_ValueComparer();
    [CompilerGeneratedAttribute]
public void set_ValueComparer(IEqualityComparer`1<object> value);
    [CompilerGeneratedAttribute]
public IBindableList`1<EnumValueDefinition> get_Values();
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.EnumValueDefinition : TypeDefinitionBase`1<EnumValueDefinitionNode> {
    [CompilerGeneratedAttribute]
private string <DeprecationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignore>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RuntimeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public string DeprecationReason { get; public set; }
    public bool IsDeprecated { get; }
    public bool Ignore { get; public set; }
    public object RuntimeValue { get; public set; }
    public MemberInfo Member { get; public set; }
    public EnumValueDefinition(string name, string description, object runtimeValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationReason();
    [CompilerGeneratedAttribute]
public void set_DeprecationReason(string value);
    public sealed virtual bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Ignore();
    [CompilerGeneratedAttribute]
public void set_Ignore(bool value);
    [CompilerGeneratedAttribute]
public object get_RuntimeValue();
    [CompilerGeneratedAttribute]
public void set_RuntimeValue(object value);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(MemberInfo value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.Definitions.FieldDefinitionBase : DefinitionBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DirectiveDefinition> _directives;
    private string _deprecationReason;
    [CompilerGeneratedAttribute]
private FieldFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeReference <Type>k__BackingField;
    internal FieldFlags Flags { get; internal set; }
    public string DeprecationReason { get; public set; }
    public bool IsDeprecated { get; }
    public TypeReference Type { get; public set; }
    public bool Ignore { get; public set; }
    [NullableAttribute("1")]
public IList`1<DirectiveDefinition> Directives { get; }
    public bool HasDirectives { get; }
    [CompilerGeneratedAttribute]
internal FieldFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(FieldFlags value);
    public sealed virtual string get_DeprecationReason();
    public void set_DeprecationReason(string value);
    public sealed virtual bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public TypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TypeReference value);
    public sealed virtual bool get_Ignore();
    public void set_Ignore(bool value);
    [NullableContextAttribute("1")]
public sealed virtual IList`1<DirectiveDefinition> get_Directives();
    public sealed virtual bool get_HasDirectives();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyList`1<DirectiveDefinition> GetDirectives();
    [NullableContextAttribute("1")]
protected void CopyTo(FieldDefinitionBase target);
    [NullableContextAttribute("1")]
protected void MergeInto(FieldDefinitionBase target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.Definitions.FieldDefinitionBase`1 : FieldDefinitionBase {
    [CompilerGeneratedAttribute]
private T <SyntaxNode>k__BackingField;
    public T SyntaxNode { get; public set; }
    private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    [CompilerGeneratedAttribute]
public T get_SyntaxNode();
    [CompilerGeneratedAttribute]
public void set_SyntaxNode(T value);
    private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    [NullableContextAttribute("1")]
protected void CopyTo(FieldDefinitionBase`1<T> target);
    [NullableContextAttribute("1")]
protected void MergeInto(FieldDefinitionBase`1<T> target);
}
[FlagsAttribute]
internal enum HotChocolate.Types.Descriptors.Definitions.FieldFlags : Enum {
    public int value__;
    public static FieldFlags None;
    public static FieldFlags Introspection;
    public static FieldFlags Deprecated;
    public static FieldFlags Ignored;
    public static FieldFlags ParallelExecutable;
    public static FieldFlags Stream;
    public static FieldFlags Sealed;
    public static FieldFlags TypeNameField;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.FieldMiddlewareDefinition : object {
    [CompilerGeneratedAttribute]
private FieldMiddleware <Middleware>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRepeatable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public FieldMiddleware Middleware { get; }
    public bool IsRepeatable { get; }
    [NullableAttribute("2")]
public string Key { get; }
    public FieldMiddlewareDefinition(FieldMiddleware middleware, bool isRepeatable, string key);
    [CompilerGeneratedAttribute]
public FieldMiddleware get_Middleware();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRepeatable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Key();
}
[DefaultMemberAttribute("Item")]
public interface HotChocolate.Types.Descriptors.Definitions.IBindableList`1 {
    public int Count { get; }
    public T Item { get; public set; }
    public BindingBehavior BindingBehavior { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual BindingBehavior get_BindingBehavior();
    public abstract virtual void set_BindingBehavior(BindingBehavior value);
    public abstract virtual void AddRange(IEnumerable`1<T> items);
}
public interface HotChocolate.Types.Descriptors.Definitions.ICanBeDeprecated {
    public string DeprecationReason { get; }
    public bool IsDeprecated { get; }
    public abstract virtual string get_DeprecationReason();
    public abstract virtual bool get_IsDeprecated();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.Definitions.IComplexOutputTypeDefinition {
    public string Name { get; }
    public Type RuntimeType { get; }
    public IList`1<Type> KnownRuntimeTypes { get; }
    public IList`1<TypeReference> Interfaces { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_RuntimeType();
    public abstract virtual IList`1<Type> get_KnownRuntimeTypes();
    public abstract virtual IList`1<TypeReference> get_Interfaces();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.Definitions.IDefinition {
    public string Name { get; public set; }
    [NullableAttribute("2")]
public string Description { get; public set; }
    [NullableAttribute("2")]
public string BindTo { get; public set; }
    public bool AttributesAreApplied { get; public set; }
    public ExtensionData ContextData { get; }
    public IList`1<TypeDependency> Dependencies { get; }
    public bool HasDependencies { get; }
    public IList`1<ITypeSystemMemberConfiguration> Configurations { get; }
    public bool HasConfigurations { get; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_Description();
    [NullableContextAttribute("2")]
public abstract virtual void set_Description(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_BindTo();
    [NullableContextAttribute("2")]
public abstract virtual void set_BindTo(string value);
    public abstract virtual bool get_AttributesAreApplied();
    public abstract virtual void set_AttributesAreApplied(bool value);
    public abstract virtual ExtensionData get_ContextData();
    public abstract virtual IList`1<TypeDependency> get_Dependencies();
    public abstract virtual bool get_HasDependencies();
    public abstract virtual IList`1<ITypeSystemMemberConfiguration> get_Configurations();
    public abstract virtual bool get_HasConfigurations();
}
public interface HotChocolate.Types.Descriptors.Definitions.IDefinitionFactory {
    public abstract virtual DefinitionBase CreateDefinition();
}
public interface HotChocolate.Types.Descriptors.Definitions.IDefinitionFactory`1 {
    public abstract virtual T CreateDefinition();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.Definitions.IHasDirectiveDefinition {
    public bool HasDirectives { get; }
    public IList`1<DirectiveDefinition> Directives { get; }
    public abstract virtual bool get_HasDirectives();
    public abstract virtual IList`1<DirectiveDefinition> get_Directives();
    public abstract virtual IReadOnlyList`1<DirectiveDefinition> GetDirectives();
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.Descriptors.Definitions.IHasExtendsType {
    public Type ExtendsType { get; }
    public abstract virtual Type get_ExtendsType();
}
public interface HotChocolate.Types.Descriptors.Definitions.IHasIgnore {
    public bool Ignore { get; }
    public abstract virtual bool get_Ignore();
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.Descriptors.Definitions.IMiddlewareDefinition {
    public bool IsRepeatable { get; }
    public string Key { get; }
    public abstract virtual bool get_IsRepeatable();
    public abstract virtual string get_Key();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.InputFieldDefinition : ArgumentDefinition {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; public set; }
    public InputFieldDefinition(string name, string description, TypeReference type, IValueNode defaultValue, object runtimeDefaultValue);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(PropertyInfo value);
    [NullableContextAttribute("1")]
internal void CopyTo(InputFieldDefinition target);
    [NullableContextAttribute("1")]
internal void MergeInto(InputFieldDefinition target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.InputObjectTypeDefinition : TypeDefinitionBase`1<InputObjectTypeDefinitionNode> {
    [CompilerGeneratedAttribute]
private IBindableList`1<InputFieldDefinition> <Fields>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<Object[], object> <CreateInstance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, Object[]> <GetFieldData>k__BackingField;
    public IBindableList`1<InputFieldDefinition> Fields { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], object> CreateInstance { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, Object[]> GetFieldData { get; public set; }
    [NullableContextAttribute("2")]
public InputObjectTypeDefinition(string name, string description, Type runtimeType);
    [CompilerGeneratedAttribute]
public IBindableList`1<InputFieldDefinition> get_Fields();
    [CompilerGeneratedAttribute]
public Func`2<Object[], object> get_CreateInstance();
    [CompilerGeneratedAttribute]
public void set_CreateInstance(Func`2<Object[], object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, Object[]> get_GetFieldData();
    [CompilerGeneratedAttribute]
public void set_GetFieldData(Action`2<object, Object[]> value);
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
    protected internal void CopyTo(InputObjectTypeDefinition target);
    protected internal void MergeInto(InputObjectTypeDefinition target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.InterfaceFieldDefinition : OutputFieldDefinitionBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IParameterExpressionBuilder> _expressionBuilders;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [NullableAttribute("2")]
public MemberInfo Member { get; public set; }
    public IList`1<IParameterExpressionBuilder> ParameterExpressionBuilders { get; }
    [NullableContextAttribute("2")]
public InterfaceFieldDefinition(string name, string description, TypeReference type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Member(MemberInfo value);
    public IList`1<IParameterExpressionBuilder> get_ParameterExpressionBuilders();
    internal IReadOnlyList`1<IParameterExpressionBuilder> GetParameterExpressionBuilders();
    internal void CopyTo(InterfaceFieldDefinition target);
    internal void MergeInto(InterfaceFieldDefinition target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.InterfaceTypeDefinition : TypeDefinitionBase`1<InterfaceTypeDefinitionNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Type> _knownClrTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TypeReference> _interfaces;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ResolveAbstractType <ResolveAbstractType>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindableList`1<InterfaceFieldDefinition> <Fields>k__BackingField;
    public IList`1<Type> KnownRuntimeTypes { get; }
    [NullableAttribute("2")]
public ResolveAbstractType ResolveAbstractType { get; public set; }
    public IList`1<TypeReference> Interfaces { get; }
    public bool HasInterfaces { get; }
    public IBindableList`1<InterfaceFieldDefinition> Fields { get; }
    [NullableContextAttribute("2")]
public InterfaceTypeDefinition(string name, string description, Type runtimeType);
    public sealed virtual IList`1<Type> get_KnownRuntimeTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ResolveAbstractType get_ResolveAbstractType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ResolveAbstractType(ResolveAbstractType value);
    public sealed virtual IList`1<TypeReference> get_Interfaces();
    public bool get_HasInterfaces();
    [CompilerGeneratedAttribute]
public IBindableList`1<InterfaceFieldDefinition> get_Fields();
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
    internal IReadOnlyList`1<Type> GetKnownClrTypes();
    internal IReadOnlyList`1<TypeReference> GetInterfaces();
}
public interface HotChocolate.Types.Descriptors.Definitions.ITypeDefinition {
    public bool NeedsNameCompletion { get; public set; }
    public Type RuntimeType { get; public set; }
    public abstract virtual bool get_NeedsNameCompletion();
    public abstract virtual void set_NeedsNameCompletion(bool value);
    public abstract virtual Type get_RuntimeType();
    public abstract virtual void set_RuntimeType(Type value);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.Definitions.ITypeSystemMemberConfiguration {
    public IDefinition Owner { get; }
    public ApplyConfigurationOn On { get; }
    public IReadOnlyList`1<TypeDependency> Dependencies { get; }
    public abstract virtual IDefinition get_Owner();
    public abstract virtual ApplyConfigurationOn get_On();
    public abstract virtual IReadOnlyList`1<TypeDependency> get_Dependencies();
    public abstract virtual void AddDependency(TypeDependency dependency);
    public abstract virtual ITypeSystemMemberConfiguration Copy(DefinitionBase newOwner);
}
[IsReadOnlyAttribute]
public class HotChocolate.Types.Descriptors.Definitions.ObjectFieldBinding : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectFieldBindingType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Replace>k__BackingField;
    public string Name { get; }
    public ObjectFieldBindingType Type { get; }
    public bool Replace { get; }
    public ObjectFieldBinding(string name, ObjectFieldBindingType type, bool replace);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ObjectFieldBindingType get_Type();
    [CompilerGeneratedAttribute]
public bool get_Replace();
}
public enum HotChocolate.Types.Descriptors.Definitions.ObjectFieldBindingType : Enum {
    public int value__;
    public static ObjectFieldBindingType Property;
    public static ObjectFieldBindingType Field;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.ObjectFieldDefinition : OutputFieldDefinitionBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<FieldMiddlewareDefinition> _middlewareDefinitions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ResultFormatterDefinition> _resultConverters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IParameterExpressionBuilder> _expressionBuilders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<object> _customSettings;
    private bool _middlewareDefinitionsCleaned;
    private bool _resultConvertersCleaned;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResolverType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectFieldBinding> <BindToField>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <ResolverMember>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscribeWith>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldResolverDelegate <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private PureFieldDelegate <PureResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscribeResolverDelegate <SubscribeResolver>k__BackingField;
    public Type SourceType { get; public set; }
    public Type ResolverType { get; public set; }
    public MemberInfo Member { get; public set; }
    public Nullable`1<ObjectFieldBinding> BindToField { get; public set; }
    public MemberInfo ResolverMember { get; public set; }
    public Expression Expression { get; public set; }
    public Type ResultType { get; public set; }
    public string SubscribeWith { get; public set; }
    public FieldResolverDelegate Resolver { get; public set; }
    public PureFieldDelegate PureResolver { get; public set; }
    public FieldResolverDelegates Resolvers { get; public set; }
    public SubscribeResolverDelegate SubscribeResolver { get; public set; }
    [NullableAttribute("1")]
public IList`1<FieldMiddlewareDefinition> MiddlewareDefinitions { get; }
    [NullableAttribute("1")]
public IList`1<ResultFormatterDefinition> FormatterDefinitions { get; }
    [NullableAttribute("1")]
public IList`1<IParameterExpressionBuilder> ParameterExpressionBuilders { get; }
    [NullableAttribute("1")]
public IList`1<object> CustomSettings { get; }
    public bool IsIntrospectionField { get; internal set; }
    public bool IsParallelExecutable { get; public set; }
    public bool HasStreamResult { get; public set; }
    public ObjectFieldDefinition(string name, string description, TypeReference type, FieldResolverDelegate resolver, PureFieldDelegate pureResolver);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ResolverType();
    [CompilerGeneratedAttribute]
public void set_ResolverType(Type value);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(MemberInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectFieldBinding> get_BindToField();
    [CompilerGeneratedAttribute]
public void set_BindToField(Nullable`1<ObjectFieldBinding> value);
    [CompilerGeneratedAttribute]
public MemberInfo get_ResolverMember();
    [CompilerGeneratedAttribute]
public void set_ResolverMember(MemberInfo value);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public Type get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(Type value);
    [CompilerGeneratedAttribute]
public string get_SubscribeWith();
    [CompilerGeneratedAttribute]
public void set_SubscribeWith(string value);
    [CompilerGeneratedAttribute]
public FieldResolverDelegate get_Resolver();
    [CompilerGeneratedAttribute]
public void set_Resolver(FieldResolverDelegate value);
    [CompilerGeneratedAttribute]
public PureFieldDelegate get_PureResolver();
    [CompilerGeneratedAttribute]
public void set_PureResolver(PureFieldDelegate value);
    public FieldResolverDelegates get_Resolvers();
    public void set_Resolvers(FieldResolverDelegates value);
    [CompilerGeneratedAttribute]
public SubscribeResolverDelegate get_SubscribeResolver();
    [CompilerGeneratedAttribute]
public void set_SubscribeResolver(SubscribeResolverDelegate value);
    [NullableContextAttribute("1")]
public IList`1<FieldMiddlewareDefinition> get_MiddlewareDefinitions();
    [NullableContextAttribute("1")]
public IList`1<ResultFormatterDefinition> get_FormatterDefinitions();
    [NullableContextAttribute("1")]
public IList`1<IParameterExpressionBuilder> get_ParameterExpressionBuilders();
    [NullableContextAttribute("1")]
public IList`1<object> get_CustomSettings();
    public bool get_IsIntrospectionField();
    internal void set_IsIntrospectionField(bool value);
    public bool get_IsParallelExecutable();
    public void set_IsParallelExecutable(bool value);
    public bool get_HasStreamResult();
    public void set_HasStreamResult(bool value);
    [NullableContextAttribute("1")]
internal IReadOnlyList`1<FieldMiddlewareDefinition> GetMiddlewareDefinitions();
    [NullableContextAttribute("1")]
internal IReadOnlyList`1<ResultFormatterDefinition> GetResultConverters();
    [NullableContextAttribute("1")]
internal IReadOnlyList`1<IParameterExpressionBuilder> GetParameterExpressionBuilders();
    [NullableContextAttribute("1")]
internal IReadOnlyList`1<object> GetCustomSettings();
    private FieldResolverDelegates GetResolvers();
    [NullableContextAttribute("1")]
internal void CopyTo(ObjectFieldDefinition target);
    [NullableContextAttribute("1")]
internal void MergeInto(ObjectFieldDefinition target);
    [NullableContextAttribute("1")]
private static void CleanMiddlewareDefinitions(IList`1<T> definitions, Boolean& definitionsCleaned);
    [NullableContextAttribute("1")]
internal bool CustomSettingExists(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.ObjectTypeDefinition : TypeDefinitionBase`1<ObjectTypeDefinitionNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Type> _knownClrTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TypeReference> _interfaces;
    [NullableAttribute("2")]
private List`1<ObjectFieldBinding> _fieldIgnores;
    private FieldBindingFlags _fieldBindingFlags;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <FieldBindingType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IsOfType <IsOfType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindableList`1<ObjectFieldDefinition> <Fields>k__BackingField;
    public Type RuntimeType { get; public set; }
    [NullableAttribute("2")]
public Type FieldBindingType { get; public set; }
    public IList`1<Type> KnownRuntimeTypes { get; }
    public IList`1<ObjectFieldBinding> FieldIgnores { get; }
    [NullableAttribute("2")]
public IsOfType IsOfType { get; public set; }
    public bool IsExtension { get; public set; }
    public IList`1<TypeReference> Interfaces { get; }
    public bool HasInterfaces { get; }
    public IBindableList`1<ObjectFieldDefinition> Fields { get; }
    public FieldBindingFlags FieldBindingFlags { get; public set; }
    [NullableContextAttribute("2")]
public ObjectTypeDefinition(string name, string description, Type runtimeType);
    public virtual Type get_RuntimeType();
    public virtual void set_RuntimeType(Type value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_FieldBindingType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FieldBindingType(Type value);
    public sealed virtual IList`1<Type> get_KnownRuntimeTypes();
    public IList`1<ObjectFieldBinding> get_FieldIgnores();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IsOfType get_IsOfType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_IsOfType(IsOfType value);
    [CompilerGeneratedAttribute]
public bool get_IsExtension();
    [CompilerGeneratedAttribute]
public void set_IsExtension(bool value);
    public sealed virtual IList`1<TypeReference> get_Interfaces();
    public bool get_HasInterfaces();
    [CompilerGeneratedAttribute]
public IBindableList`1<ObjectFieldDefinition> get_Fields();
    public FieldBindingFlags get_FieldBindingFlags();
    public void set_FieldBindingFlags(FieldBindingFlags value);
    public virtual IEnumerable`1<ITypeSystemMemberConfiguration> GetConfigurations();
    internal IReadOnlyList`1<Type> GetKnownClrTypes();
    internal IReadOnlyList`1<TypeReference> GetInterfaces();
    internal IReadOnlyList`1<ObjectFieldBinding> GetFieldIgnores();
    protected internal void CopyTo(ObjectTypeDefinition target);
    protected internal void MergeInto(ObjectTypeDefinition target);
    private static void SetResolverMember(ObjectFieldDefinition sourceField, ObjectFieldDefinition targetField);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.OutputFieldDefinitionBase : FieldDefinitionBase`1<FieldDefinitionNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ArgumentDefinition> _arguments;
    public IList`1<ArgumentDefinition> Arguments { get; }
    public bool HasArguments { get; }
    public IList`1<ArgumentDefinition> get_Arguments();
    public bool get_HasArguments();
    public IReadOnlyList`1<ArgumentDefinition> GetArguments();
    protected void CopyTo(OutputFieldDefinitionBase target);
    protected void MergeInto(OutputFieldDefinitionBase target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.ResultFormatterDefinition : object {
    [CompilerGeneratedAttribute]
private ResultFormatterDelegate <Formatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRepeatable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public ResultFormatterDelegate Formatter { get; }
    public bool IsRepeatable { get; }
    [NullableAttribute("2")]
public string Key { get; }
    public ResultFormatterDefinition(ResultFormatterDelegate formatter, bool isRepeatable, string key);
    [CompilerGeneratedAttribute]
public ResultFormatterDelegate get_Formatter();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRepeatable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Key();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.ScalarTypeDefinition : TypeDefinitionBase`1<ScalarTypeDefinitionNode> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.SchemaTypeDefinition : DefinitionBase`1<SchemaDefinitionNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DirectiveDefinition> _directives;
    internal IList`1<DirectiveDefinition> Directives { get; }
    internal bool HasDirectives { get; }
    internal IList`1<DirectiveDefinition> get_Directives();
    internal bool get_HasDirectives();
    internal IReadOnlyList`1<DirectiveDefinition> GetDirectives();
    internal IHasDirectiveDefinition GetLegacyDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.TypeDefinitionBase`1 : DefinitionBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DirectiveDefinition> _directives;
    private Type _runtimeType;
    [CompilerGeneratedAttribute]
private bool <NeedsNameCompletion>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <ExtendsType>k__BackingField;
    public bool NeedsNameCompletion { get; public set; }
    public Type RuntimeType { get; public set; }
    [NullableAttribute("2")]
public Type ExtendsType { get; public set; }
    public IList`1<DirectiveDefinition> Directives { get; }
    public bool HasDirectives { get; }
    protected TypeDefinitionBase`1(Type runtimeType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NeedsNameCompletion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NeedsNameCompletion(bool value);
    public virtual Type get_RuntimeType();
    public virtual void set_RuntimeType(Type value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Type get_ExtendsType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ExtendsType(Type value);
    public sealed virtual IList`1<DirectiveDefinition> get_Directives();
    public sealed virtual bool get_HasDirectives();
    public sealed virtual IReadOnlyList`1<DirectiveDefinition> GetDirectives();
    protected void CopyTo(TypeDefinitionBase`1<T> target);
    protected void MergeInto(TypeDefinitionBase`1<T> target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.Definitions.TypeDependency : object {
    [CompilerGeneratedAttribute]
private TypeDependencyFulfilled <Fulfilled>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeReference <Type>k__BackingField;
    public TypeDependencyFulfilled Fulfilled { get; }
    public TypeReference Type { get; }
    public TypeDependency(TypeReference type, TypeDependencyFulfilled fulfilled);
    [CompilerGeneratedAttribute]
public TypeDependencyFulfilled get_Fulfilled();
    [CompilerGeneratedAttribute]
public TypeReference get_Type();
    public TypeDependency With(TypeReference typeReference, Nullable`1<TypeDependencyFulfilled> kind);
    public static TypeDependency FromSchemaType(IExtendedType type, TypeDependencyFulfilled fulfilled);
}
public enum HotChocolate.Types.Descriptors.Definitions.TypeDependencyFulfilled : Enum {
    public int value__;
    public static TypeDependencyFulfilled Default;
    public static TypeDependencyFulfilled Named;
    public static TypeDependencyFulfilled Completed;
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.Definitions.UnionTypeDefinition : TypeDefinitionBase`1<UnionTypeDefinitionNode> {
    [CompilerGeneratedAttribute]
private ResolveAbstractType <ResolveAbstractType>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<TypeReference> <Types>k__BackingField;
    public ResolveAbstractType ResolveAbstractType { get; public set; }
    [NullableAttribute("1")]
public IList`1<TypeReference> Types { get; }
    public UnionTypeDefinition(string name, string description, Type runtimeType);
    [CompilerGeneratedAttribute]
public ResolveAbstractType get_ResolveAbstractType();
    [CompilerGeneratedAttribute]
public void set_ResolveAbstractType(ResolveAbstractType value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<TypeReference> get_Types();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.DependantFactoryTypeReference : TypeReference {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeReference <Dependency>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDescriptorContext, TypeSystemObjectBase> <Factory>k__BackingField;
    public string Name { get; }
    public TypeReference Dependency { get; }
    public Func`2<IDescriptorContext, TypeSystemObjectBase> Factory { get; }
    internal DependantFactoryTypeReference(string name, TypeReference dependency, Func`2<IDescriptorContext, TypeSystemObjectBase> factory, TypeContext context, string scope);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public TypeReference get_Dependency();
    [CompilerGeneratedAttribute]
public Func`2<IDescriptorContext, TypeSystemObjectBase> get_Factory();
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DependantFactoryTypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("0")]
public DependantFactoryTypeReference With(Optional`1<string> name, Optional`1<TypeReference> dependency, Optional`1<Func`2<IDescriptorContext, TypeSystemObjectBase>> factory, Optional`1<TypeContext> context, Optional`1<string> scope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class HotChocolate.Types.Descriptors.DependencyDescriptorBase : object {
    private ITypeSystemMemberConfiguration _configuration;
    [CompilerGeneratedAttribute]
private ITypeInspector <TypeInspector>k__BackingField;
    protected ITypeInspector TypeInspector { get; }
    protected TypeDependencyFulfilled DependencyFulfilled { get; }
    protected DependencyDescriptorBase(ITypeInspector typeInspector, ITypeSystemMemberConfiguration configuration);
    [CompilerGeneratedAttribute]
protected ITypeInspector get_TypeInspector();
    protected abstract virtual TypeDependencyFulfilled get_DependencyFulfilled();
    [NullableContextAttribute("0")]
protected void DependsOn(bool mustBeNamedOrCompleted);
    protected void DependsOn(Type schemaType, bool mustBeNamedOrCompleted);
    protected void DependsOn(IExtendedType schemaType, bool mustBeNamedOrCompleted);
    protected void DependsOn(string typeName, bool mustBeNamedOrCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.DescriptorBase`1 : object {
    [CompilerGeneratedAttribute]
private IDescriptorContext <Context>k__BackingField;
    protected internal IDescriptorContext Context { get; }
    private IDescriptorContext HotChocolate.Types.IHasDescriptorContext.Context { get; }
    protected internal T Definition { get; protected set; }
    private T HotChocolate.Types.IDescriptorExtension<T>.Definition { get; }
    protected DescriptorBase`1(IDescriptorContext context);
    [CompilerGeneratedAttribute]
protected internal IDescriptorContext get_Context();
    private sealed virtual override IDescriptorContext HotChocolate.Types.IHasDescriptorContext.get_Context();
    protected internal abstract virtual T get_Definition();
    protected abstract virtual void set_Definition(T value);
    private sealed virtual override T HotChocolate.Types.IDescriptorExtension<T>.get_Definition();
    public sealed virtual IDescriptorExtension`1<T> Extend();
    public sealed virtual T CreateDefinition();
    protected virtual void OnCreateDefinition(T definition);
    private sealed virtual override DefinitionBase HotChocolate.Types.Descriptors.Definitions.IDefinitionFactory.CreateDefinition();
    private sealed virtual override void HotChocolate.Types.IDescriptorExtension<T>.OnBeforeCreate(Action`1<T> configure);
    private sealed virtual override void HotChocolate.Types.IDescriptorExtension<T>.OnBeforeCreate(Action`2<IDescriptorContext, T> configure);
    private sealed virtual override void HotChocolate.Types.IDescriptorExtension.OnBeforeCreate(Action`1<DefinitionBase> configure);
    private sealed virtual override void HotChocolate.Types.IDescriptorExtension.OnBeforeCreate(Action`2<IDescriptorContext, DefinitionBase> configure);
    private void OnBeforeCreate(Action`2<IDescriptorContext, T> configure);
    private sealed virtual override INamedDependencyDescriptor HotChocolate.Types.IDescriptorExtension<T>.OnBeforeNaming(Action`2<ITypeCompletionContext, T> configure);
    private sealed virtual override INamedDependencyDescriptor HotChocolate.Types.IDescriptorExtension.OnBeforeNaming(Action`2<ITypeCompletionContext, DefinitionBase> configure);
    private INamedDependencyDescriptor OnBeforeNaming(Action`2<ITypeCompletionContext, T> configure);
    private sealed virtual override ICompletedDependencyDescriptor HotChocolate.Types.IDescriptorExtension<T>.OnBeforeCompletion(Action`2<ITypeCompletionContext, T> configure);
    private sealed virtual override ICompletedDependencyDescriptor HotChocolate.Types.IDescriptorExtension.OnBeforeCompletion(Action`2<ITypeCompletionContext, DefinitionBase> configure);
    private ICompletedDependencyDescriptor OnBeforeCompletion(Action`2<ITypeCompletionContext, T> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.DescriptorContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, string>, IConvention> _conventionInstances;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<ValueTuple`2<Type, string>, List`1<CreateConvention>> _conventions;
    private Dictionary`2<string, ISchemaDirective> _schemaDirectives;
    private IServiceProvider _schemaServices;
    private ServiceHelper _serviceHelper;
    private Func`1<IReadOnlySchemaOptions> _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TypeDiscoveryHandler[] _typeDiscoveryHandlers;
    [NullableAttribute("2")]
private INamingConventions _naming;
    [NullableAttribute("2")]
private ITypeInspector _inspector;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<SchemaCompletedEventArgs> SchemaCompleted;
    [CompilerGeneratedAttribute]
private LazySchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInterceptor <TypeInterceptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolverCompiler <ResolverCompiler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeConverter <TypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private InputParser <InputParser>k__BackingField;
    [CompilerGeneratedAttribute]
private InputFormatter <InputFormatter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ContextData>k__BackingField;
    internal LazySchema Schema { get; }
    public IServiceProvider Services { get; }
    public IReadOnlySchemaOptions Options { get; }
    public INamingConventions Naming { get; }
    public ITypeInspector TypeInspector { get; }
    public TypeInterceptor TypeInterceptor { get; }
    public IResolverCompiler ResolverCompiler { get; }
    public ITypeConverter TypeConverter { get; }
    public InputParser InputParser { get; }
    public InputFormatter InputFormatter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    private DescriptorContext(Func`1<IReadOnlySchemaOptions> options, IReadOnlyDictionary`2<ValueTuple`2<Type, string>, List`1<CreateConvention>> conventions, IServiceProvider schemaServices, IDictionary`2<string, object> contextData, LazySchema schema, TypeInterceptor typeInterceptor);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SchemaCompleted(EventHandler`1<SchemaCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SchemaCompleted(EventHandler`1<SchemaCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
internal LazySchema get_Schema();
    public sealed virtual IServiceProvider get_Services();
    public sealed virtual IReadOnlySchemaOptions get_Options();
    public sealed virtual INamingConventions get_Naming();
    public sealed virtual ITypeInspector get_TypeInspector();
    [CompilerGeneratedAttribute]
public sealed virtual TypeInterceptor get_TypeInterceptor();
    [CompilerGeneratedAttribute]
public sealed virtual IResolverCompiler get_ResolverCompiler();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
public sealed virtual InputParser get_InputParser();
    [CompilerGeneratedAttribute]
public sealed virtual InputFormatter get_InputFormatter();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ContextData();
    public sealed virtual ReadOnlySpan`1<TypeDiscoveryHandler> GetTypeDiscoveryHandlers();
    public sealed virtual bool TryGetSchemaDirective(DirectiveNode directiveNode, ISchemaDirective& directive);
    public sealed virtual T GetConventionOrDefault(Func`1<T> defaultConvention, string scope);
    [NullableContextAttribute("2")]
private void CreateConventions(string scope, IConvention& createdConvention, IList`1& extensions);
    private static void MergeExtensions(IConventionContext context, Convention convention, IList`1<IConventionExtension> extensions);
    private static TypeDiscoveryHandler[] CreateTypeDiscoveryHandlers(IDescriptorContext self);
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
internal static DescriptorContext Create(IReadOnlySchemaOptions options, IServiceProvider services, IReadOnlyDictionary`2<ValueTuple`2<Type, string>, List`1<CreateConvention>> conventions, IDictionary`2<string, object> contextData, LazySchema schema, TypeInterceptor typeInterceptor);
    [NullableContextAttribute("2")]
internal static DescriptorContext Create(Func`1<IReadOnlySchemaOptions> options, IServiceProvider services, IReadOnlyDictionary`2<ValueTuple`2<Type, string>, List`1<CreateConvention>> conventions, IDictionary`2<string, object> contextData, LazySchema schema, TypeInterceptor typeInterceptor);
    [CompilerGeneratedAttribute]
private INamingConventions <get_Naming>b__21_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.Descriptors.DescriptorContextConventionExtensions : object {
    [ExtensionAttribute]
public static T GetConventionOrDefault(IDescriptorContext context, T defaultConvention);
    [ExtensionAttribute]
public static T GetConventionOrDefault(IDescriptorContext context, Func`1<T> defaultConvention);
    [ExtensionAttribute]
public static T GetConventionOrDefault(IDescriptorContext context, string scope, T defaultConvention);
}
[ExtensionAttribute]
public static class HotChocolate.Types.Descriptors.DescriptorExtensions : object {
    [ExtensionAttribute]
public static ObjectTypeDescriptor ToDescriptor(ObjectTypeDefinition definition, IDescriptorContext context);
    [ExtensionAttribute]
public static ObjectFieldDescriptor ToDescriptor(ObjectFieldDefinition definition, IDescriptorContext context);
    [ExtensionAttribute]
public static ArgumentDescriptor ToDescriptor(ArgumentDefinition definition, IDescriptorContext context);
    [ExtensionAttribute]
public static EnumTypeDescriptor ToDescriptor(EnumTypeDefinition definition, IDescriptorContext context);
    [ExtensionAttribute]
public static EnumValueDescriptor ToDescriptor(EnumValueDefinition definition, IDescriptorContext context);
    [ExtensionAttribute]
public static T ToDefinition(IDescriptor`1<T> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.DirectiveArgumentDescriptor : ArgumentDescriptorBase`1<DirectiveArgumentDefinition> {
    protected internal DirectiveArgumentDescriptor(IDescriptorContext context, string argumentName);
    protected internal DirectiveArgumentDescriptor(IDescriptorContext context, PropertyInfo property);
    protected internal DirectiveArgumentDescriptor(IDescriptorContext context, DirectiveArgumentDefinition definition);
    protected virtual void OnCreateDefinition(DirectiveArgumentDefinition definition);
    public sealed virtual IDirectiveArgumentDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public sealed virtual IDirectiveArgumentDescriptor Name(string value);
    public sealed virtual IDirectiveArgumentDescriptor Deprecated(string reason);
    public sealed virtual IDirectiveArgumentDescriptor Deprecated();
    public sealed virtual IDirectiveArgumentDescriptor Description(string value);
    public sealed virtual IDirectiveArgumentDescriptor Type();
    public sealed virtual IDirectiveArgumentDescriptor Type(TInputType inputType);
    public sealed virtual IDirectiveArgumentDescriptor Type(ITypeNode typeNode);
    public sealed virtual IDirectiveArgumentDescriptor Type(Type type);
    public sealed virtual IDirectiveArgumentDescriptor DefaultValue(IValueNode value);
    public sealed virtual IDirectiveArgumentDescriptor DefaultValue(object value);
    public sealed virtual IDirectiveArgumentDescriptor Ignore(bool ignore);
    public static DirectiveArgumentDescriptor New(IDescriptorContext context, string argumentName);
    public static DirectiveArgumentDescriptor New(IDescriptorContext context, PropertyInfo property);
    public static DirectiveArgumentDescriptor From(IDescriptorContext context, DirectiveArgumentDefinition definition);
}
public class HotChocolate.Types.Descriptors.DirectiveTypeDescriptor : DescriptorBase`1<DirectiveTypeDefinition> {
    [CompilerGeneratedAttribute]
private DirectiveTypeDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<DirectiveArgumentDescriptor> <Arguments>k__BackingField;
    protected internal DirectiveTypeDefinition Definition { get; protected set; }
    protected ICollection`1<DirectiveArgumentDescriptor> Arguments { get; }
    protected internal DirectiveTypeDescriptor(IDescriptorContext context, Type clrType);
    protected internal DirectiveTypeDescriptor(IDescriptorContext context);
    protected internal DirectiveTypeDescriptor(IDescriptorContext context, DirectiveTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual DirectiveTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(DirectiveTypeDefinition value);
    [CompilerGeneratedAttribute]
protected ICollection`1<DirectiveArgumentDescriptor> get_Arguments();
    protected virtual void OnCreateDefinition(DirectiveTypeDefinition definition);
    protected virtual void OnCompleteArguments(IDictionary`2<string, DirectiveArgumentDefinition> arguments, ISet`1<PropertyInfo> handledProperties);
    public sealed virtual IDirectiveTypeDescriptor SyntaxNode(DirectiveDefinitionNode directiveDefinitionNode);
    public sealed virtual IDirectiveTypeDescriptor Name(string value);
    public sealed virtual IDirectiveTypeDescriptor Description(string value);
    public sealed virtual IDirectiveArgumentDescriptor Argument(string name);
    public sealed virtual IDirectiveTypeDescriptor Location(DirectiveLocation value);
    public sealed virtual IDirectiveTypeDescriptor Use(DirectiveMiddleware middleware);
    public sealed virtual IDirectiveTypeDescriptor Use();
    public sealed virtual IDirectiveTypeDescriptor Use(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    [ObsoleteAttribute("Replace Middleware with `Use`.")]
public sealed virtual IDirectiveTypeDescriptor Middleware(DirectiveMiddleware middleware);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public sealed virtual IDirectiveTypeDescriptor Middleware(Expression`1<Func`2<T, object>> method);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public sealed virtual IDirectiveTypeDescriptor Middleware(Expression`1<Action`1<T>> method);
    public sealed virtual IDirectiveTypeDescriptor Repeatable();
    public sealed virtual IDirectiveTypeDescriptor Public();
    public sealed virtual IDirectiveTypeDescriptor Internal();
    public static DirectiveTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static DirectiveTypeDescriptor New(IDescriptorContext context);
    public static DirectiveTypeDescriptor`1<T> New(IDescriptorContext context);
    public static DirectiveTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static DirectiveTypeDescriptor From(IDescriptorContext context, DirectiveTypeDefinition definition);
    public static DirectiveTypeDescriptor From(IDescriptorContext context, DirectiveTypeDefinition definition);
}
public class HotChocolate.Types.Descriptors.DirectiveTypeDescriptor`1 : DirectiveTypeDescriptor {
    private Type HotChocolate.Types.IHasRuntimeType.RuntimeType { get; }
    protected internal DirectiveTypeDescriptor`1(IDescriptorContext context);
    protected internal DirectiveTypeDescriptor`1(IDescriptorContext context, DirectiveTypeDefinition definition);
    private sealed virtual override Type HotChocolate.Types.IHasRuntimeType.get_RuntimeType();
    protected virtual void OnCompleteArguments(IDictionary`2<string, DirectiveArgumentDefinition> arguments, ISet`1<PropertyInfo> handledProperties);
    public sealed virtual IDirectiveTypeDescriptor`1<T> SyntaxNode(DirectiveDefinitionNode directiveDefinitionNode);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Name(string value);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Description(string value);
    public sealed virtual IDirectiveTypeDescriptor`1<T> BindArguments(BindingBehavior behavior);
    public sealed virtual IDirectiveTypeDescriptor`1<T> BindArgumentsExplicitly();
    public sealed virtual IDirectiveTypeDescriptor`1<T> BindArgumentsImplicitly();
    public sealed virtual IDirectiveArgumentDescriptor Argument(Expression`1<Func`2<T, object>> property);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Location(DirectiveLocation value);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Use(DirectiveMiddleware middleware);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Use();
    public sealed virtual IDirectiveTypeDescriptor`1<T> Use(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    [ObsoleteAttribute("Replace Middleware with `Use`.")]
public sealed virtual IDirectiveTypeDescriptor`1<T> Middleware(DirectiveMiddleware middleware);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public sealed virtual IDirectiveTypeDescriptor`1<T> Middleware(Expression`1<Func`2<TMiddleware, object>> method);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public sealed virtual IDirectiveTypeDescriptor`1<T> Middleware(Expression`1<Action`1<TMiddleware>> method);
    public sealed virtual IDirectiveTypeDescriptor`1<T> Repeatable();
    public sealed virtual IDirectiveTypeDescriptor`1<T> Public();
    public sealed virtual IDirectiveTypeDescriptor`1<T> Internal();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private DirectiveArgumentDefinition <OnCompleteArguments>b__4_0(PropertyInfo p);
}
public class HotChocolate.Types.Descriptors.EnumTypeDescriptor : DescriptorBase`1<EnumTypeDefinition> {
    [CompilerGeneratedAttribute]
private EnumTypeDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EnumValueDescriptor> <Values>k__BackingField;
    protected internal EnumTypeDefinition Definition { get; protected set; }
    protected ICollection`1<EnumValueDescriptor> Values { get; }
    protected EnumTypeDescriptor(IDescriptorContext context);
    protected EnumTypeDescriptor(IDescriptorContext context, Type clrType);
    protected EnumTypeDescriptor(IDescriptorContext context, EnumTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual EnumTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(EnumTypeDefinition value);
    [CompilerGeneratedAttribute]
protected ICollection`1<EnumValueDescriptor> get_Values();
    protected virtual void OnCreateDefinition(EnumTypeDefinition definition);
    protected void AddImplicitValues(EnumTypeDefinition typeDefinition, IDictionary`2<object, EnumValueDefinition> values);
    public sealed virtual IEnumTypeDescriptor SyntaxNode(EnumTypeDefinitionNode enumTypeDefinition);
    public sealed virtual IEnumTypeDescriptor Name(string value);
    public sealed virtual IEnumTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use `BindValues`.")]
public sealed virtual IEnumTypeDescriptor BindItems(BindingBehavior behavior);
    public sealed virtual IEnumTypeDescriptor BindValues(BindingBehavior behavior);
    public sealed virtual IEnumTypeDescriptor BindValuesExplicitly();
    public sealed virtual IEnumTypeDescriptor BindValuesImplicitly();
    public sealed virtual IEnumTypeDescriptor NameComparer(IEqualityComparer`1<string> comparer);
    public sealed virtual IEnumTypeDescriptor ValueComparer(IEqualityComparer`1<object> comparer);
    [ObsoleteAttribute("Use `Value`.")]
public sealed virtual IEnumValueDescriptor Item(T value);
    public sealed virtual IEnumValueDescriptor Value(T value);
    public sealed virtual IEnumTypeDescriptor Directive(T directiveInstance);
    public sealed virtual IEnumTypeDescriptor Directive();
    public sealed virtual IEnumTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public static EnumTypeDescriptor New(IDescriptorContext context);
    public static EnumTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static EnumTypeDescriptor`1<T> New(IDescriptorContext context);
    public static EnumTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static EnumTypeDescriptor From(IDescriptorContext context, EnumTypeDefinition definition);
    public static EnumTypeDescriptor From(IDescriptorContext context, EnumTypeDefinition definition);
}
public class HotChocolate.Types.Descriptors.EnumTypeDescriptor`1 : EnumTypeDescriptor {
    protected internal EnumTypeDescriptor`1(IDescriptorContext context);
    protected internal EnumTypeDescriptor`1(IDescriptorContext context, EnumTypeDefinition definition);
    public sealed virtual IEnumTypeDescriptor`1<T> SyntaxNode(EnumTypeDefinitionNode enumTypeDefinition);
    public sealed virtual IEnumTypeDescriptor`1<T> Name(string value);
    public sealed virtual IEnumTypeDescriptor`1<T> Description(string value);
    [ObsoleteAttribute("Use `BindValues`.")]
public sealed virtual IEnumTypeDescriptor`1<T> BindItems(BindingBehavior behavior);
    public sealed virtual IEnumTypeDescriptor`1<T> BindValues(BindingBehavior behavior);
    public sealed virtual IEnumTypeDescriptor`1<T> BindValuesExplicitly();
    public sealed virtual IEnumTypeDescriptor`1<T> BindValuesImplicitly();
    [ObsoleteAttribute("Use `Value`.")]
public sealed virtual IEnumValueDescriptor Item(T value);
    public sealed virtual IEnumValueDescriptor Value(T value);
    public sealed virtual IEnumTypeDescriptor`1<T> Directive(TDirective directiveInstance);
    public sealed virtual IEnumTypeDescriptor`1<T> Directive();
    public sealed virtual IEnumTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
}
internal class HotChocolate.Types.Descriptors.EnumTypeNameDependencyDescriptor : object {
    private IEnumTypeDescriptor _descriptor;
    private Func`2<INamedType, string> _createName;
    public EnumTypeNameDependencyDescriptor(IEnumTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IEnumTypeDescriptor DependsOn();
    public sealed virtual IEnumTypeDescriptor DependsOn(Type schemaType);
}
internal class HotChocolate.Types.Descriptors.EnumTypeNameDependencyDescriptor`1 : object {
    private IEnumTypeDescriptor`1<T> _descriptor;
    private Func`2<INamedType, string> _createName;
    public EnumTypeNameDependencyDescriptor`1(IEnumTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IEnumTypeDescriptor`1<T> DependsOn();
    public sealed virtual IEnumTypeDescriptor`1<T> DependsOn(Type schemaType);
}
public class HotChocolate.Types.Descriptors.EnumValueDescriptor : DescriptorBase`1<EnumValueDefinition> {
    [CompilerGeneratedAttribute]
private EnumValueDefinition <Definition>k__BackingField;
    protected internal EnumValueDefinition Definition { get; protected set; }
    protected EnumValueDescriptor(IDescriptorContext context, object runtimeValue);
    protected EnumValueDescriptor(IDescriptorContext context, EnumValueDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual EnumValueDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(EnumValueDefinition value);
    protected virtual void OnCreateDefinition(EnumValueDefinition definition);
    public sealed virtual IEnumValueDescriptor SyntaxNode(EnumValueDefinitionNode enumValueDefinition);
    public sealed virtual IEnumValueDescriptor Name(string value);
    public sealed virtual IEnumValueDescriptor Description(string value);
    [ObsoleteAttribute("Use `Deprecated`.")]
public sealed virtual IEnumValueDescriptor DeprecationReason(string reason);
    public sealed virtual IEnumValueDescriptor Deprecated(string reason);
    public sealed virtual IEnumValueDescriptor Deprecated();
    public sealed virtual IEnumValueDescriptor Ignore(bool ignore);
    public sealed virtual IEnumValueDescriptor Directive(T directiveInstance);
    public sealed virtual IEnumValueDescriptor Directive();
    public sealed virtual IEnumValueDescriptor Directive(string name, ArgumentNode[] arguments);
    public static EnumValueDescriptor New(IDescriptorContext context, object value);
    public static EnumValueDescriptor From(IDescriptorContext context, EnumValueDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.ExtendedTypeDirectiveReference : TypeReference {
    [CompilerGeneratedAttribute]
private IExtendedType <Type>k__BackingField;
    public IExtendedType Type { get; }
    internal ExtendedTypeDirectiveReference(IExtendedType type);
    [CompilerGeneratedAttribute]
public IExtendedType get_Type();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtendedTypeDirectiveReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.ExtendedTypeReference : TypeReference {
    [CompilerGeneratedAttribute]
private IExtendedType <Type>k__BackingField;
    public IExtendedType Type { get; }
    internal ExtendedTypeReference(IExtendedType type, TypeContext context, string scope);
    [CompilerGeneratedAttribute]
public IExtendedType get_Type();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtendedTypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public ExtendedTypeReference WithType(IExtendedType type);
    public ExtendedTypeReference WithContext(TypeContext context);
    public ExtendedTypeReference WithScope(string scope);
    [NullableContextAttribute("0")]
public ExtendedTypeReference With(IExtendedType type, Optional`1<TypeContext> context, Optional`1<string> scope);
}
public interface HotChocolate.Types.Descriptors.IConvention {
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.IConventionContext {
    public IServiceProvider Services { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ContextData { get; }
    public IDescriptorContext DescriptorContext { get; }
    public abstract virtual IServiceProvider get_Services();
    public abstract virtual IDictionary`2<string, object> get_ContextData();
    public abstract virtual IDescriptorContext get_DescriptorContext();
}
public interface HotChocolate.Types.Descriptors.IConventionExtension {
    public abstract virtual void Merge(IConventionContext context, Convention convention);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.IDescriptorContext {
    public IReadOnlySchemaOptions Options { get; }
    public IServiceProvider Services { get; }
    public INamingConventions Naming { get; }
    public ITypeInspector TypeInspector { get; }
    public TypeInterceptor TypeInterceptor { get; }
    public IResolverCompiler ResolverCompiler { get; }
    public ITypeConverter TypeConverter { get; }
    public InputParser InputParser { get; }
    public InputFormatter InputFormatter { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_SchemaCompleted(EventHandler`1<SchemaCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SchemaCompleted(EventHandler`1<SchemaCompletedEventArgs> value);
    public abstract virtual IReadOnlySchemaOptions get_Options();
    public abstract virtual IServiceProvider get_Services();
    public abstract virtual INamingConventions get_Naming();
    public abstract virtual ITypeInspector get_TypeInspector();
    public abstract virtual TypeInterceptor get_TypeInterceptor();
    public abstract virtual IResolverCompiler get_ResolverCompiler();
    public abstract virtual ITypeConverter get_TypeConverter();
    public abstract virtual InputParser get_InputParser();
    public abstract virtual InputFormatter get_InputFormatter();
    public abstract virtual ReadOnlySpan`1<TypeDiscoveryHandler> GetTypeDiscoveryHandlers();
    public abstract virtual bool TryGetSchemaDirective(DirectiveNode directiveNode, ISchemaDirective& directive);
    public abstract virtual T GetConventionOrDefault(Func`1<T> defaultConvention, string scope);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.IDocumentationProvider {
    public abstract virtual string GetDescription(Type type);
    public abstract virtual string GetDescription(MemberInfo member);
    public abstract virtual string GetDescription(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.INamingConventions {
    public abstract virtual string GetTypeName(Type type);
    public abstract virtual string GetTypeName(Type type, TypeKind kind);
    public abstract virtual string GetTypeDescription(Type type, TypeKind kind);
    public abstract virtual string GetMemberName(MemberInfo member, MemberKind kind);
    public abstract virtual string GetMemberDescription(MemberInfo member, MemberKind kind);
    public abstract virtual string GetArgumentName(ParameterInfo parameter);
    public abstract virtual string GetArgumentDescription(ParameterInfo parameter);
    public abstract virtual string GetEnumValueName(object value);
    public abstract virtual string GetEnumValueDescription(object value);
    public abstract virtual bool IsDeprecated(MemberInfo member, String& reason);
    public abstract virtual bool IsDeprecated(object value, String& reason);
    public abstract virtual string FormatFieldName(string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.InputFieldDescriptor : ArgumentDescriptorBase`1<InputFieldDefinition> {
    protected internal InputFieldDescriptor(IDescriptorContext context, string fieldName);
    protected internal InputFieldDescriptor(IDescriptorContext context, InputFieldDefinition definition);
    protected internal InputFieldDescriptor(IDescriptorContext context, PropertyInfo property);
    protected virtual void OnCreateDefinition(InputFieldDefinition definition);
    public sealed virtual IInputFieldDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public sealed virtual IInputFieldDescriptor Name(string value);
    public sealed virtual IInputFieldDescriptor Deprecated(string reason);
    public sealed virtual IInputFieldDescriptor Deprecated();
    public sealed virtual IInputFieldDescriptor Description(string value);
    public sealed virtual IInputFieldDescriptor Type();
    public sealed virtual IInputFieldDescriptor Type(TInputType inputType);
    public sealed virtual IInputFieldDescriptor Type(ITypeNode typeNode);
    public sealed virtual IInputFieldDescriptor Type(Type type);
    public sealed virtual IInputFieldDescriptor DefaultValue(IValueNode value);
    public sealed virtual IInputFieldDescriptor DefaultValue(object value);
    public sealed virtual IInputFieldDescriptor Ignore(bool ignore);
    public sealed virtual IInputFieldDescriptor Directive(TDirective directiveInstance);
    public sealed virtual IInputFieldDescriptor Directive();
    public sealed virtual IInputFieldDescriptor Directive(string name, ArgumentNode[] arguments);
    public static InputFieldDescriptor New(IDescriptorContext context, string fieldName);
    public static InputFieldDescriptor New(IDescriptorContext context, PropertyInfo property);
    public static InputFieldDescriptor From(IDescriptorContext context, InputFieldDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.InputObjectTypeDescriptor : DescriptorBase`1<InputObjectTypeDefinition> {
    private List`1<InputFieldDescriptor> _fields;
    [CompilerGeneratedAttribute]
private InputObjectTypeDefinition <Definition>k__BackingField;
    protected internal InputObjectTypeDefinition Definition { get; protected set; }
    protected ICollection`1<InputFieldDescriptor> Fields { get; }
    protected InputObjectTypeDescriptor(IDescriptorContext context, Type runtimeType);
    protected InputObjectTypeDescriptor(IDescriptorContext context);
    protected InputObjectTypeDescriptor(IDescriptorContext context, InputObjectTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual InputObjectTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(InputObjectTypeDefinition value);
    protected ICollection`1<InputFieldDescriptor> get_Fields();
    protected virtual void OnCreateDefinition(InputObjectTypeDefinition definition);
    protected void InferFieldsFromFieldBindingType(IDictionary`2<string, InputFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    protected virtual void OnCompleteFields(IDictionary`2<string, InputFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IInputObjectTypeDescriptor SyntaxNode(InputObjectTypeDefinitionNode inputObjectTypeDefinition);
    public sealed virtual IInputObjectTypeDescriptor Name(string value);
    public sealed virtual IInputObjectTypeDescriptor Description(string value);
    public sealed virtual IInputFieldDescriptor Field(string name);
    public sealed virtual IInputObjectTypeDescriptor Directive(T directive);
    public sealed virtual IInputObjectTypeDescriptor Directive();
    public sealed virtual IInputObjectTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public static InputObjectTypeDescriptor New(IDescriptorContext context);
    public static InputObjectTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static InputObjectTypeDescriptor`1<T> New(IDescriptorContext context);
    public static InputObjectTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static InputObjectTypeDescriptor From(IDescriptorContext context, InputObjectTypeDefinition definition);
    public static InputObjectTypeDescriptor`1<T> From(IDescriptorContext context, InputObjectTypeDefinition definition);
}
public class HotChocolate.Types.Descriptors.InputObjectTypeDescriptor`1 : InputObjectTypeDescriptor {
    private Type HotChocolate.Types.IHasRuntimeType.RuntimeType { get; }
    protected internal InputObjectTypeDescriptor`1(IDescriptorContext context);
    protected internal InputObjectTypeDescriptor`1(IDescriptorContext context, InputObjectTypeDefinition definition);
    private sealed virtual override Type HotChocolate.Types.IHasRuntimeType.get_RuntimeType();
    protected virtual void OnCompleteFields(IDictionary`2<string, InputFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IInputObjectTypeDescriptor`1<T> SyntaxNode(InputObjectTypeDefinitionNode inputObjectTypeDefinition);
    public sealed virtual IInputObjectTypeDescriptor`1<T> Name(string value);
    public sealed virtual IInputObjectTypeDescriptor`1<T> Description(string value);
    public sealed virtual IInputObjectTypeDescriptor`1<T> BindFields(BindingBehavior behavior);
    public sealed virtual IInputObjectTypeDescriptor`1<T> BindFieldsExplicitly();
    public sealed virtual IInputObjectTypeDescriptor`1<T> BindFieldsImplicitly();
    public sealed virtual IInputFieldDescriptor Field(Expression`1<Func`2<T, TValue>> property);
    public sealed virtual IInputObjectTypeDescriptor`1<T> Directive(TDirective directive);
    public sealed virtual IInputObjectTypeDescriptor`1<T> Directive();
    public sealed virtual IInputObjectTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
}
internal class HotChocolate.Types.Descriptors.InputObjectTypeNameDependencyDescriptor : object {
    private IInputObjectTypeDescriptor _descriptor;
    private Func`2<INamedType, string> _createName;
    public InputObjectTypeNameDependencyDescriptor(IInputObjectTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IInputObjectTypeDescriptor DependsOn();
    public sealed virtual IInputObjectTypeDescriptor DependsOn(Type schemaType);
}
internal class HotChocolate.Types.Descriptors.InputObjectTypeNameDependencyDescriptor`1 : object {
    private IInputObjectTypeDescriptor`1<T> _descriptor;
    private Func`2<INamedType, string> _createName;
    public InputObjectTypeNameDependencyDescriptor`1(IInputObjectTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IInputObjectTypeDescriptor`1<T> DependsOn();
    public sealed virtual IInputObjectTypeDescriptor`1<T> DependsOn(Type schemaType);
}
public class HotChocolate.Types.Descriptors.InterfaceFieldDescriptor : OutputFieldDescriptorBase`1<InterfaceFieldDefinition> {
    private ParameterInfo[] _parameterInfos;
    private bool _argumentsInitialized;
    [CompilerGeneratedAttribute]
private InterfaceFieldDefinition <Definition>k__BackingField;
    protected internal InterfaceFieldDefinition Definition { get; protected set; }
    protected internal InterfaceFieldDescriptor(IDescriptorContext context, string fieldName);
    protected internal InterfaceFieldDescriptor(IDescriptorContext context, InterfaceFieldDefinition definition);
    protected internal InterfaceFieldDescriptor(IDescriptorContext context, MemberInfo member);
    [CompilerGeneratedAttribute]
protected internal virtual InterfaceFieldDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(InterfaceFieldDefinition value);
    protected virtual void OnCreateDefinition(InterfaceFieldDefinition definition);
    private void CompleteArguments(InterfaceFieldDefinition definition);
    public sealed virtual IInterfaceFieldDescriptor SyntaxNode(FieldDefinitionNode fieldDefinition);
    public sealed virtual IInterfaceFieldDescriptor Name(string name);
    public sealed virtual IInterfaceFieldDescriptor Description(string description);
    [ObsoleteAttribute("Use `Deprecated`.")]
public sealed virtual IInterfaceFieldDescriptor DeprecationReason(string reason);
    public sealed virtual IInterfaceFieldDescriptor Deprecated(string reason);
    public sealed virtual IInterfaceFieldDescriptor Deprecated();
    public sealed virtual IInterfaceFieldDescriptor Type();
    public sealed virtual IInterfaceFieldDescriptor Type(TOutputType outputType);
    public sealed virtual IInterfaceFieldDescriptor Type(ITypeNode type);
    public sealed virtual IInterfaceFieldDescriptor Type(Type type);
    public sealed virtual IInterfaceFieldDescriptor Argument(string name, Action`1<IArgumentDescriptor> argument);
    public sealed virtual IInterfaceFieldDescriptor Ignore(bool ignore);
    public sealed virtual IInterfaceFieldDescriptor Directive(T directive);
    public sealed virtual IInterfaceFieldDescriptor Directive();
    public sealed virtual IInterfaceFieldDescriptor Directive(string name, ArgumentNode[] arguments);
    public static InterfaceFieldDescriptor New(IDescriptorContext context, string fieldName);
    public static InterfaceFieldDescriptor New(IDescriptorContext context, MemberInfo member);
    public static InterfaceFieldDescriptor From(IDescriptorContext context, InterfaceFieldDefinition definition);
}
public class HotChocolate.Types.Descriptors.InterfaceTypeDescriptor : DescriptorBase`1<InterfaceTypeDefinition> {
    [CompilerGeneratedAttribute]
private InterfaceTypeDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<InterfaceFieldDescriptor> <Fields>k__BackingField;
    protected internal InterfaceTypeDefinition Definition { get; protected set; }
    protected ICollection`1<InterfaceFieldDescriptor> Fields { get; }
    protected InterfaceTypeDescriptor(IDescriptorContext context, Type clrType);
    protected InterfaceTypeDescriptor(IDescriptorContext context);
    protected InterfaceTypeDescriptor(IDescriptorContext context, InterfaceTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual InterfaceTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(InterfaceTypeDefinition value);
    [CompilerGeneratedAttribute]
protected ICollection`1<InterfaceFieldDescriptor> get_Fields();
    protected virtual void OnCreateDefinition(InterfaceTypeDefinition definition);
    protected virtual void OnCompleteFields(IDictionary`2<string, InterfaceFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IInterfaceTypeDescriptor SyntaxNode(InterfaceTypeDefinitionNode interfaceTypeDefinition);
    public sealed virtual IInterfaceTypeDescriptor Name(string value);
    public sealed virtual IInterfaceTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor Interface();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor Interface(NamedTypeNode namedType);
    public sealed virtual IInterfaceTypeDescriptor Implements();
    public sealed virtual IInterfaceTypeDescriptor Implements(T type);
    public sealed virtual IInterfaceTypeDescriptor Implements(NamedTypeNode type);
    public sealed virtual IInterfaceFieldDescriptor Field(string name);
    public sealed virtual IInterfaceTypeDescriptor ResolveAbstractType(ResolveAbstractType typeResolver);
    public sealed virtual IInterfaceTypeDescriptor Directive(T directiveInstance);
    public sealed virtual IInterfaceTypeDescriptor Directive();
    public sealed virtual IInterfaceTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public static InterfaceTypeDescriptor New(IDescriptorContext context);
    public static InterfaceTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static InterfaceTypeDescriptor`1<T> New(IDescriptorContext context);
    public static InterfaceTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static InterfaceTypeDescriptor From(IDescriptorContext context, InterfaceTypeDefinition definition);
    public static InterfaceTypeDescriptor`1<T> From(IDescriptorContext context, InterfaceTypeDefinition definition);
}
public class HotChocolate.Types.Descriptors.InterfaceTypeDescriptor`1 : InterfaceTypeDescriptor {
    private Type HotChocolate.Types.IHasRuntimeType.RuntimeType { get; }
    protected internal InterfaceTypeDescriptor`1(IDescriptorContext context);
    protected internal InterfaceTypeDescriptor`1(IDescriptorContext context, InterfaceTypeDefinition definition);
    private sealed virtual override Type HotChocolate.Types.IHasRuntimeType.get_RuntimeType();
    protected virtual void OnCompleteFields(IDictionary`2<string, InterfaceFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IInterfaceTypeDescriptor`1<T> SyntaxNode(InterfaceTypeDefinitionNode interfaceTypeDefinition);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Name(string value);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Description(string value);
    public sealed virtual IInterfaceTypeDescriptor`1<T> BindFields(BindingBehavior behavior);
    public sealed virtual IInterfaceTypeDescriptor`1<T> BindFieldsExplicitly();
    public sealed virtual IInterfaceTypeDescriptor`1<T> BindFieldsImplicitly();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor`1<T> Interface();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor`1<T> Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IInterfaceTypeDescriptor`1<T> Interface(NamedTypeNode type);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Implements();
    public sealed virtual IInterfaceTypeDescriptor`1<T> Implements(TInterface type);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Implements(NamedTypeNode type);
    public sealed virtual IInterfaceFieldDescriptor Field(Expression`1<Func`2<T, object>> propertyOrMethod);
    public sealed virtual IInterfaceTypeDescriptor`1<T> ResolveAbstractType(ResolveAbstractType typeResolver);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Directive(TDirective directiveInstance);
    public sealed virtual IInterfaceTypeDescriptor`1<T> Directive();
    public sealed virtual IInterfaceTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private InterfaceFieldDefinition <OnCompleteFields>b__4_0(MemberInfo p);
}
internal class HotChocolate.Types.Descriptors.InterfaceTypeNameDependencyDescriptor : object {
    private IInterfaceTypeDescriptor _descriptor;
    private Func`2<INamedType, string> _createName;
    public InterfaceTypeNameDependencyDescriptor(IInterfaceTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IInterfaceTypeDescriptor DependsOn();
    public sealed virtual IInterfaceTypeDescriptor DependsOn(Type schemaType);
}
internal class HotChocolate.Types.Descriptors.InterfaceTypeNameDependencyDescriptor`1 : object {
    private IInterfaceTypeDescriptor`1<T> _descriptor;
    private Func`2<INamedType, string> _createName;
    public InterfaceTypeNameDependencyDescriptor`1(IInterfaceTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IInterfaceTypeDescriptor`1<T> DependsOn();
    public sealed virtual IInterfaceTypeDescriptor`1<T> DependsOn(Type schemaType);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.ITypeInspector {
    public abstract virtual ReadOnlySpan`1<MemberInfo> GetMembers(Type type, bool includeIgnored, bool includeStatic, bool allowObject);
    public abstract virtual bool IsMemberIgnored(MemberInfo member);
    public abstract virtual TypeReference GetReturnTypeRef(MemberInfo member, TypeContext context, string scope, bool ignoreAttributes);
    public abstract virtual IExtendedType GetReturnType(MemberInfo member, bool ignoreAttributes);
    public abstract virtual TypeReference GetArgumentTypeRef(ParameterInfo parameter, string scope, bool ignoreAttributes);
    public abstract virtual IExtendedType GetArgumentType(ParameterInfo parameter, bool ignoreAttributes);
    public abstract virtual ExtendedTypeReference GetTypeRef(Type type, TypeContext context, string scope);
    public abstract virtual IExtendedType GetType(Type type);
    public abstract virtual IExtendedType GetType(Type type, Nullable`1[] nullable);
    public abstract virtual IExtendedType GetType(Type type, ReadOnlySpan`1<Nullable`1<bool>> nullable);
    public abstract virtual IEnumerable`1<object> GetEnumValues(Type enumType);
    public abstract virtual MemberInfo GetEnumValueMember(object value);
    public abstract virtual MemberInfo GetNodeIdMember(Type type);
    [NullableContextAttribute("2")]
public abstract virtual MethodInfo GetNodeResolverMethod(Type nodeType, Type resolverType);
    public abstract virtual Type ExtractNamedType(Type type);
    public abstract virtual bool IsSchemaType(Type type);
    public abstract virtual void ApplyAttributes(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider attributeProvider);
    public abstract virtual bool TryGetDefaultValue(ParameterInfo parameter, Object& defaultValue);
    public abstract virtual bool TryGetDefaultValue(PropertyInfo property, Object& defaultValue);
    public abstract virtual IExtendedType ChangeNullability(IExtendedType type, Nullable`1[] nullable);
    public abstract virtual IExtendedType ChangeNullability(IExtendedType type, ReadOnlySpan`1<Nullable`1<bool>> nullable);
    public abstract virtual Nullable`1[] CollectNullability(IExtendedType type);
    [NullableContextAttribute("0")]
public abstract virtual bool CollectNullability(IExtendedType type, Span`1<Nullable`1<bool>> buffer, Int32& written);
    public abstract virtual ITypeInfo CreateTypeInfo(Type type);
    public abstract virtual ITypeInfo CreateTypeInfo(IExtendedType type);
    public abstract virtual ITypeFactory CreateTypeFactory(IExtendedType type);
    public abstract virtual bool TryCreateTypeInfo(Type type, ITypeInfo& typeInfo);
    public abstract virtual bool TryCreateTypeInfo(IExtendedType type, ITypeInfo& typeInfo);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Descriptors.IXmlDocumentationFileResolver {
    public abstract virtual bool TryGetXmlDocument(Assembly assembly, XDocument& document);
}
internal class HotChocolate.Types.Descriptors.NamedDependencyDescriptor : DependencyDescriptorBase {
    protected TypeDependencyFulfilled DependencyFulfilled { get; }
    public NamedDependencyDescriptor(ITypeInspector typeInspector, CompleteConfiguration configuration);
    protected virtual TypeDependencyFulfilled get_DependencyFulfilled();
    public sealed virtual INamedDependencyDescriptor DependsOn();
    public sealed virtual INamedDependencyDescriptor DependsOn(bool mustBeNamed);
    public sealed virtual INamedDependencyDescriptor DependsOn(Type schemaType);
    public sealed virtual INamedDependencyDescriptor DependsOn(Type schemaType, bool mustBeNamed);
    public sealed virtual INamedDependencyDescriptor DependsOn(string typeName);
    public sealed virtual INamedDependencyDescriptor DependsOn(string typeName, bool mustBeNamed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.NameDirectiveReference : TypeReference {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    internal NameDirectiveReference(string directiveName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NameDirectiveReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Descriptors.NoopDocumentationProvider : object {
    public sealed virtual string GetDescription(Type type);
    public sealed virtual string GetDescription(MemberInfo member);
    public sealed virtual string GetDescription(ParameterInfo parameter);
}
public class HotChocolate.Types.Descriptors.NoOpStringBuilderPool : ObjectPool`1<StringBuilder> {
    public virtual StringBuilder Get();
    public virtual void Return(StringBuilder obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.ObjectFieldDescriptor : OutputFieldDescriptorBase`1<ObjectFieldDefinition> {
    private bool _argumentsInitialized;
    private ParameterInfo[] _parameterInfos;
    [CompilerGeneratedAttribute]
private ObjectFieldDefinition <Definition>k__BackingField;
    protected internal ObjectFieldDefinition Definition { get; protected set; }
    protected ObjectFieldDescriptor(IDescriptorContext context, string fieldName);
    protected ObjectFieldDescriptor(IDescriptorContext context, MemberInfo member, Type sourceType, Type resolverType);
    protected ObjectFieldDescriptor(IDescriptorContext context, LambdaExpression expression, Type sourceType, Type resolverType);
    protected ObjectFieldDescriptor(IDescriptorContext context, ObjectFieldDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual ObjectFieldDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(ObjectFieldDefinition value);
    protected virtual void OnCreateDefinition(ObjectFieldDefinition definition);
    private void CompleteArguments(ObjectFieldDefinition definition);
    public sealed virtual IObjectFieldDescriptor SyntaxNode(FieldDefinitionNode fieldDefinition);
    public sealed virtual IObjectFieldDescriptor Name(string value);
    public sealed virtual IObjectFieldDescriptor Description(string value);
    [ObsoleteAttribute("Use `Deprecated`.")]
public sealed virtual IObjectFieldDescriptor DeprecationReason(string reason);
    public sealed virtual IObjectFieldDescriptor Deprecated(string reason);
    public sealed virtual IObjectFieldDescriptor Deprecated();
    public sealed virtual IObjectFieldDescriptor Type();
    public sealed virtual IObjectFieldDescriptor Type(TOutputType outputType);
    public sealed virtual IObjectFieldDescriptor Type(ITypeNode typeNode);
    public sealed virtual IObjectFieldDescriptor Type(Type type);
    public sealed virtual IObjectFieldDescriptor StreamResult(bool hasStreamResult);
    public sealed virtual IObjectFieldDescriptor Argument(string argumentName, Action`1<IArgumentDescriptor> argumentDescriptor);
    public sealed virtual IObjectFieldDescriptor Ignore(bool ignore);
    public sealed virtual IObjectFieldDescriptor Resolver(FieldResolverDelegate fieldResolver);
    public sealed virtual IObjectFieldDescriptor Resolver(FieldResolverDelegate fieldResolver, Type resultType);
    public sealed virtual IObjectFieldDescriptor Resolve(FieldResolverDelegate fieldResolver);
    public sealed virtual IObjectFieldDescriptor Resolve(FieldResolverDelegate fieldResolver, Type resultType);
    public sealed virtual IObjectFieldDescriptor ResolveWith(Expression`1<Func`2<TResolver, object>> propertyOrMethod);
    public sealed virtual IObjectFieldDescriptor ResolveWith(MemberInfo propertyOrMethod);
    private IObjectFieldDescriptor ResolveWithInternal(MemberInfo propertyOrMethod, Type resolverType);
    public sealed virtual IObjectFieldDescriptor Subscribe(SubscribeResolverDelegate subscribeResolver);
    public sealed virtual IObjectFieldDescriptor Use(FieldMiddleware middleware);
    public sealed virtual IObjectFieldDescriptor Directive(T directiveInstance);
    public sealed virtual IObjectFieldDescriptor Directive();
    public sealed virtual IObjectFieldDescriptor Directive(string name, ArgumentNode[] arguments);
    public static ObjectFieldDescriptor New(IDescriptorContext context, string fieldName);
    public static ObjectFieldDescriptor New(IDescriptorContext context, MemberInfo member, Type sourceType, Type resolverType);
    public static ObjectFieldDescriptor New(IDescriptorContext context, LambdaExpression expression, Type sourceType, Type resolverType);
    public static ObjectFieldDescriptor From(IDescriptorContext context, ObjectFieldDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.ObjectTypeDescriptor : DescriptorBase`1<ObjectTypeDefinition> {
    private List`1<ObjectFieldDescriptor> _fields;
    [CompilerGeneratedAttribute]
private ObjectTypeDefinition <Definition>k__BackingField;
    protected internal ObjectTypeDefinition Definition { get; protected set; }
    protected ICollection`1<ObjectFieldDescriptor> Fields { get; }
    protected ObjectTypeDescriptor(IDescriptorContext context, Type clrType);
    protected ObjectTypeDescriptor(IDescriptorContext context);
    protected ObjectTypeDescriptor(IDescriptorContext context, ObjectTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual ObjectTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(ObjectTypeDefinition value);
    protected ICollection`1<ObjectFieldDescriptor> get_Fields();
    protected virtual void OnCreateDefinition(ObjectTypeDefinition definition);
    internal void InferFieldsFromFieldBindingType();
    private protected void InferFieldsFromFieldBindingType(IDictionary`2<string, ObjectFieldDefinition> fields, ISet`1<MemberInfo> handledMembers, bool createDefinition);
    protected virtual void OnCompleteFields(IDictionary`2<string, ObjectFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IObjectTypeDescriptor SyntaxNode(ObjectTypeDefinitionNode objectTypeDefinition);
    public sealed virtual IObjectTypeDescriptor Name(string value);
    public sealed virtual IObjectTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor Interface();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor Interface(NamedTypeNode namedType);
    public sealed virtual IObjectTypeDescriptor Implements();
    public sealed virtual IObjectTypeDescriptor Implements(T type);
    public sealed virtual IObjectTypeDescriptor Implements(NamedTypeNode type);
    public sealed virtual IObjectTypeDescriptor IsOfType(IsOfType isOfType);
    public sealed virtual IObjectFieldDescriptor Field(string name);
    public sealed virtual IObjectFieldDescriptor Field(Expression`1<Func`2<TResolver, object>> propertyOrMethod);
    public sealed virtual IObjectFieldDescriptor Field(MemberInfo propertyOrMethod);
    public IObjectFieldDescriptor Field(Expression`1<Func`2<TResolver, TPropertyType>> propertyOrMethod);
    public sealed virtual IObjectTypeDescriptor Directive(T directiveInstance);
    public sealed virtual IObjectTypeDescriptor Directive();
    public sealed virtual IObjectTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public sealed virtual IObjectTypeDescriptor ExtendsType(Type extendsType);
    public sealed virtual IObjectTypeDescriptor ExtendsType();
    public static ObjectTypeDescriptor New(IDescriptorContext context);
    public static ObjectTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static ObjectTypeDescriptor`1<T> New(IDescriptorContext context);
    public static ObjectTypeExtensionDescriptor`1<T> NewExtension(IDescriptorContext context);
    public static ObjectTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static ObjectTypeDescriptor From(IDescriptorContext context, ObjectTypeDefinition definition);
    public static ObjectTypeDescriptor`1<T> From(IDescriptorContext context, ObjectTypeDefinition definition);
    [CompilerGeneratedAttribute]
internal static bool <InferFieldsFromFieldBindingType>g__IncludeField|12_0(Boolean& skip, HashSet`1& subscribeResolver, Dictionary`2& subscribeResolverLookup, ReadOnlySpan`1<MemberInfo> allMembers, MemberInfo current);
}
public class HotChocolate.Types.Descriptors.ObjectTypeDescriptor`1 : ObjectTypeDescriptorBase`1<T> {
    protected internal ObjectTypeDescriptor`1(IDescriptorContext context);
    protected internal ObjectTypeDescriptor`1(IDescriptorContext context, ObjectTypeDefinition definition);
}
public abstract class HotChocolate.Types.Descriptors.ObjectTypeDescriptorBase`1 : ObjectTypeDescriptor {
    private Type HotChocolate.Types.IHasRuntimeType.RuntimeType { get; }
    protected ObjectTypeDescriptorBase`1(IDescriptorContext context, Type clrType);
    protected ObjectTypeDescriptorBase`1(IDescriptorContext context);
    protected ObjectTypeDescriptorBase`1(IDescriptorContext context, ObjectTypeDefinition definition);
    private sealed virtual override Type HotChocolate.Types.IHasRuntimeType.get_RuntimeType();
    protected virtual void OnCompleteFields(IDictionary`2<string, ObjectFieldDefinition> fields, ISet`1<MemberInfo> handledMembers);
    public sealed virtual IObjectTypeDescriptor`1<T> Name(string value);
    public sealed virtual IObjectTypeDescriptor`1<T> Description(string value);
    public sealed virtual IObjectTypeDescriptor`1<T> BindFields(BindingBehavior behavior);
    public sealed virtual IObjectTypeDescriptor`1<T> BindFields(FieldBindingFlags bindingFlags);
    public sealed virtual IObjectTypeDescriptor`1<T> BindFieldsExplicitly();
    public sealed virtual IObjectTypeDescriptor`1<T> BindFieldsImplicitly();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor`1<T> Interface();
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor`1<T> Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public sealed virtual IObjectTypeDescriptor`1<T> Interface(NamedTypeNode type);
    public sealed virtual IObjectTypeDescriptor`1<T> Implements();
    public sealed virtual IObjectTypeDescriptor`1<T> Implements(TInterface type);
    public sealed virtual IObjectTypeDescriptor`1<T> Implements(NamedTypeNode type);
    public sealed virtual IObjectTypeDescriptor`1<T> IsOfType(IsOfType isOfType);
    public sealed virtual IObjectFieldDescriptor Field(Expression`1<Func`2<T, object>> propertyOrMethod);
    public sealed virtual IObjectFieldDescriptor Field(Expression`1<Func`2<T, TValue>> propertyOrMethod);
    public sealed virtual IObjectTypeDescriptor`1<T> Directive(TDirective directiveInstance);
    public sealed virtual IObjectTypeDescriptor`1<T> Directive();
    public sealed virtual IObjectTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.Descriptors.ObjectTypeExtensionDescriptor`1 : ObjectTypeDescriptorBase`1<T> {
    protected internal ObjectTypeExtensionDescriptor`1(IDescriptorContext context);
}
internal class HotChocolate.Types.Descriptors.ObjectTypeNameDependencyDescriptor : object {
    private IObjectTypeDescriptor _descriptor;
    private Func`2<INamedType, string> _createName;
    public ObjectTypeNameDependencyDescriptor(IObjectTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IObjectTypeDescriptor DependsOn();
    public sealed virtual IObjectTypeDescriptor DependsOn(Type schemaType);
}
internal class HotChocolate.Types.Descriptors.ObjectTypeNameDependencyDescriptor`1 : object {
    private IObjectTypeDescriptor`1<T> _descriptor;
    private Func`2<INamedType, string> _createName;
    public ObjectTypeNameDependencyDescriptor`1(IObjectTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IObjectTypeDescriptor`1<T> DependsOn();
    public sealed virtual IObjectTypeDescriptor`1<T> DependsOn(Type schemaType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.Descriptors.OutputFieldDescriptorBase`1 : DescriptorBase`1<TDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<ArgumentDescriptor> _arguments;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ParameterInfo> <Parameters>k__BackingField;
    protected ICollection`1<ArgumentDescriptor> Arguments { get; }
    protected IReadOnlyDictionary`2<string, ParameterInfo> Parameters { get; protected set; }
    protected OutputFieldDescriptorBase`1(IDescriptorContext context);
    protected ICollection`1<ArgumentDescriptor> get_Arguments();
    [CompilerGeneratedAttribute]
protected IReadOnlyDictionary`2<string, ParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
protected void set_Parameters(IReadOnlyDictionary`2<string, ParameterInfo> value);
    protected virtual void OnCreateDefinition(TDefinition definition);
    [NullableContextAttribute("2")]
protected void SyntaxNode(FieldDefinitionNode syntaxNode);
    protected void Name(string name);
    [NullableContextAttribute("2")]
protected void Description(string description);
    [NullableContextAttribute("0")]
protected void Type();
    protected void Type(Type type);
    protected void Type(TOutputType outputType);
    protected void Type(ITypeNode typeNode);
    protected void Argument(string name, Action`1<IArgumentDescriptor> argument);
    [NullableContextAttribute("2")]
public void Deprecated(string reason);
    public void Deprecated();
    protected void Ignore(bool ignore);
    protected void Directive(T directive);
    protected void Directive();
    protected void Directive(string name, ArgumentNode[] arguments);
}
public class HotChocolate.Types.Descriptors.SchemaCompletedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ISchema <Schema>k__BackingField;
    public ISchema Schema { get; }
    public SchemaCompletedEventArgs(ISchema schema);
    [CompilerGeneratedAttribute]
public ISchema get_Schema();
}
public class HotChocolate.Types.Descriptors.SchemaTypeDescriptor : DescriptorBase`1<SchemaTypeDefinition> {
    [CompilerGeneratedAttribute]
private SchemaTypeDefinition <Definition>k__BackingField;
    protected internal SchemaTypeDefinition Definition { get; protected set; }
    protected SchemaTypeDescriptor(IDescriptorContext context, Type type);
    protected SchemaTypeDescriptor(IDescriptorContext context, SchemaTypeDefinition definition);
    [CompilerGeneratedAttribute]
protected internal virtual SchemaTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(SchemaTypeDefinition value);
    public sealed virtual ISchemaTypeDescriptor Name(string value);
    public sealed virtual ISchemaTypeDescriptor Description(string value);
    public sealed virtual ISchemaTypeDescriptor Directive(T directiveInstance);
    public sealed virtual ISchemaTypeDescriptor Directive();
    public sealed virtual ISchemaTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public static SchemaTypeDescriptor New(IDescriptorContext context, Type type);
    public static SchemaTypeDescriptor From(IDescriptorContext context, SchemaTypeDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.SchemaTypeReference : TypeReference {
    [CompilerGeneratedAttribute]
private ITypeSystemMember <Type>k__BackingField;
    public ITypeSystemMember Type { get; }
    internal SchemaTypeReference(ITypeSystemMember type, Nullable`1<TypeContext> context, string scope);
    [CompilerGeneratedAttribute]
public ITypeSystemMember get_Type();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SchemaTypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public SchemaTypeReference WithType(ITypeSystemMember type);
    public SchemaTypeReference WithContext(TypeContext context);
    public SchemaTypeReference WithScope(string scope);
    [NullableContextAttribute("0")]
public SchemaTypeReference With(Optional`1<ITypeSystemMember> type, Optional`1<TypeContext> context, Optional`1<string> scope);
    [NullableContextAttribute("2")]
internal static TypeContext InferTypeContext(object type);
    internal static TypeContext InferTypeContext(IExtendedType type);
    internal static TypeContext InferTypeContext(Type type);
    private static TypeContext InferTypeContextInternal(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.SyntaxTypeReference : TypeReference {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeNode <Type>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IDescriptorContext, TypeSystemObjectBase> <Factory>k__BackingField;
    public string Name { get; }
    public ITypeNode Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IDescriptorContext, TypeSystemObjectBase> Factory { get; }
    internal SyntaxTypeReference(ITypeNode type, TypeContext context, string scope, Func`2<IDescriptorContext, TypeSystemObjectBase> factory);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ITypeNode get_Type();
    [CompilerGeneratedAttribute]
public Func`2<IDescriptorContext, TypeSystemObjectBase> get_Factory();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SyntaxTypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public SyntaxTypeReference WithType(ITypeNode type);
    public SyntaxTypeReference WithContext(TypeContext context);
    public SyntaxTypeReference WithScope(string scope);
    public SyntaxTypeReference WithFactory(Func`2<IDescriptorContext, TypeSystemObjectBase> factory);
    [NullableContextAttribute("0")]
public SyntaxTypeReference With(Optional`1<ITypeNode> type, Optional`1<TypeContext> context, Optional`1<string> scope, Optional`1<Func`2<IDescriptorContext, TypeSystemObjectBase>> factory);
}
[ExtensionAttribute]
public static class HotChocolate.Types.Descriptors.TypeInspectorExtensions : object {
    [ExtensionAttribute]
public static TypeReference GetInputReturnTypeRef(ITypeInspector typeInspector, MemberInfo member);
    [ExtensionAttribute]
public static TypeReference GetInputTypeRef(ITypeInspector typeInspector, Type type);
    [ExtensionAttribute]
public static TypeReference GetOutputReturnTypeRef(ITypeInspector typeInspector, MemberInfo member);
    [ExtensionAttribute]
public static ExtendedTypeReference GetOutputTypeRef(ITypeInspector typeInspector, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.Descriptors.TypeReference : object {
    [CompilerGeneratedAttribute]
private TypeReferenceKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeContext <Context>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    public TypeReferenceKind Kind { get; }
    public TypeContext Context { get; }
    [NullableAttribute("2")]
public string Scope { get; }
    [NullableContextAttribute("2")]
protected TypeReference(TypeReferenceKind kind, TypeContext context, string scope);
    [CompilerGeneratedAttribute]
public TypeReferenceKind get_Kind();
    [CompilerGeneratedAttribute]
public TypeContext get_Context();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Scope();
    protected bool IsEqual(TypeReference other);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(TypeReference other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected string ToString(object name);
    public static DependantFactoryTypeReference Create(string name, TypeReference dependency, Func`2<IDescriptorContext, TypeSystemObjectBase> factory, TypeContext context, string scope);
    public static SchemaTypeReference Create(ITypeSystemMember type, string scope);
    public static NameDirectiveReference CreateDirective(string directiveName);
    public static ExtendedTypeDirectiveReference CreateDirective(IExtendedType type);
    public static SyntaxTypeReference Create(ITypeNode type, TypeContext context, string scope, Func`2<IDescriptorContext, TypeSystemObjectBase> factory);
    public static SyntaxTypeReference Create(string typeName, TypeContext context, string scope, Func`2<IDescriptorContext, TypeSystemObjectBase> factory);
    public static SyntaxTypeReference Parse(string sourceText, TypeContext context, string scope, Func`2<IDescriptorContext, TypeSystemObjectBase> factory);
    public static ExtendedTypeReference Create(IExtendedType type, TypeContext context, string scope);
}
[ExtensionAttribute]
public static class HotChocolate.Types.Descriptors.TypeReferenceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeReference With(TypeReference typeReference, Optional`1<TypeContext> context, Optional`1<string> scope);
}
public enum HotChocolate.Types.Descriptors.TypeReferenceKind : Enum {
    public int value__;
    public static TypeReferenceKind ExtendedType;
    public static TypeReferenceKind SchemaType;
    public static TypeReferenceKind Syntax;
    public static TypeReferenceKind Factory;
    public static TypeReferenceKind DependantFactory;
    public static TypeReferenceKind DirectiveExtendedType;
    public static TypeReferenceKind DirectiveName;
}
public class HotChocolate.Types.Descriptors.UnionTypeDescriptor : DescriptorBase`1<UnionTypeDefinition> {
    [CompilerGeneratedAttribute]
private UnionTypeDefinition <Definition>k__BackingField;
    protected internal UnionTypeDefinition Definition { get; protected set; }
    protected UnionTypeDescriptor(IDescriptorContext context, Type clrType);
    protected UnionTypeDescriptor(IDescriptorContext context, UnionTypeDefinition definition);
    protected UnionTypeDescriptor(IDescriptorContext context);
    [CompilerGeneratedAttribute]
protected internal virtual UnionTypeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected virtual void set_Definition(UnionTypeDefinition value);
    protected virtual void OnCreateDefinition(UnionTypeDefinition definition);
    public sealed virtual IUnionTypeDescriptor SyntaxNode(UnionTypeDefinitionNode unionTypeDefinition);
    public sealed virtual IUnionTypeDescriptor Name(string value);
    public sealed virtual IUnionTypeDescriptor Description(string value);
    public sealed virtual IUnionTypeDescriptor Type();
    public sealed virtual IUnionTypeDescriptor Type(TObjectType objectType);
    public sealed virtual IUnionTypeDescriptor Type(NamedTypeNode objectType);
    public sealed virtual IUnionTypeDescriptor ResolveAbstractType(ResolveAbstractType resolveAbstractType);
    public sealed virtual IUnionTypeDescriptor Directive(T directiveInstance);
    public sealed virtual IUnionTypeDescriptor Directive();
    public sealed virtual IUnionTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public static UnionTypeDescriptor New(IDescriptorContext context, Type clrType);
    public static UnionTypeDescriptor New(IDescriptorContext context);
    public static UnionTypeDescriptor FromSchemaType(IDescriptorContext context, Type schemaType);
    public static UnionTypeDescriptor From(IDescriptorContext context, UnionTypeDefinition definition);
}
internal class HotChocolate.Types.Descriptors.UnionTypeNameDependencyDescriptor : object {
    private IUnionTypeDescriptor _descriptor;
    private Func`2<INamedType, string> _createName;
    public UnionTypeNameDependencyDescriptor(IUnionTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    public sealed virtual IUnionTypeDescriptor DependsOn();
    public sealed virtual IUnionTypeDescriptor DependsOn(Type schemaType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.XmlDocumentationFileResolver : object {
    private static string _bin;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Assembly, string> _resolveXmlDocumentationFileName;
    private ConcurrentDictionary`2<string, XDocument> _cache;
    public XmlDocumentationFileResolver(Func`2<Assembly, string> resolveXmlDocumentationFileName);
    public sealed virtual bool TryGetXmlDocument(Assembly assembly, XDocument& document);
    [NullableContextAttribute("2")]
private string GetXmlDocumentationPath(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Descriptors.XmlDocumentationProvider : object {
    private static string _summaryElementName;
    private static string _exceptionElementName;
    private static string _returnsElementName;
    private static string _inheritdoc;
    private static string _see;
    private static string _langword;
    private static string _cref;
    private static string _href;
    private static string _code;
    private IXmlDocumentationFileResolver _fileResolver;
    private ObjectPool`1<StringBuilder> _stringBuilderPool;
    public XmlDocumentationProvider(IXmlDocumentationFileResolver fileResolver, ObjectPool`1<StringBuilder> stringBuilderPool);
    public sealed virtual string GetDescription(Type type);
    public sealed virtual string GetDescription(MemberInfo member);
    public sealed virtual string GetDescription(ParameterInfo parameter);
    private string GetDescriptionInternal(MemberInfo member);
    [NullableContextAttribute("2")]
private string ComposeMemberDescription(XElement summary, XElement returns, IEnumerable`1<XElement> errors);
    private void AppendErrorDescription(IEnumerable`1<XElement> errors, StringBuilder description, bool needsNewLine);
    private static void AppendText(XElement element, StringBuilder description);
    private void AppendNewLineIfNeeded(StringBuilder description, bool condition);
    private XElement GetMemberElement(MemberInfo member);
    private XElement GetParameterElement(ParameterInfo parameter);
    private void ReplaceInheritdocElements(MemberInfo member, XElement element);
    private void ProcessInheritdocInterfaceElements(MemberInfo member, XElement child);
    [NullableContextAttribute("2")]
private static string RemoveLineBreakWhiteSpaces(string documentation);
    private static MemberName GetMemberElementName(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Directive : object {
    private DirectiveNode _syntaxNode;
    private object _runtimeValue;
    [CompilerGeneratedAttribute]
private DirectiveType <Type>k__BackingField;
    public DirectiveType Type { get; }
    internal Directive(DirectiveType type, DirectiveNode syntaxNode, object runtimeValue);
    [CompilerGeneratedAttribute]
public DirectiveType get_Type();
    public T GetArgumentValue(string name);
    private IValueNode GetArgumentValueOrNull(string argumentValue);
    public T AsValue();
    public DirectiveNode AsSyntaxNode(bool removeDefaults);
    public static DirectiveNode op_Implicit(Directive directive);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.DirectiveArgument : Argument {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; }
    [NullableContextAttribute("1")]
public DirectiveArgument(DirectiveArgumentDefinition definition, int index);
    [CompilerGeneratedAttribute]
public sealed virtual PropertyInfo get_Property();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public abstract class HotChocolate.Types.DirectiveArgumentDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IDirectiveArgumentDescriptor descriptor, PropertyInfo property);
}
[ExtensionAttribute]
public static class HotChocolate.Types.DirectiveArgumentDescriptorExtensions : object {
    [ExtensionAttribute]
public static IDirectiveArgumentDescriptor DefaultValueSyntax(IDirectiveArgumentDescriptor descriptor, string syntax);
}
public abstract class HotChocolate.Types.DirectiveAttribute`1 : DescriptorAttribute {
    private TDirective _directive;
    protected DirectiveAttribute`1(TDirective directive);
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected virtual void OnConfigure(IDescriptorContext context, TDirective descriptor, ICustomAttributeProvider element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class HotChocolate.Types.DirectiveCollection : object {
    private Directive[] _directives;
    public int Count { get; }
    public IEnumerable`1<Directive> Item { get; }
    public Directive Item { get; }
    private DirectiveCollection(Directive[] directives);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<Directive> get_Item(string directiveName);
    [IteratorStateMachineAttribute("HotChocolate.Types.DirectiveCollection/<FindDirectives>d__6")]
private static IEnumerable`1<Directive> FindDirectives(Directive[] directives, string name);
    public sealed virtual Directive get_Item(int index);
    public sealed virtual Directive FirstOrDefault(string directiveName);
    [NullableContextAttribute("2")]
public sealed virtual Directive FirstOrDefault();
    public sealed virtual bool ContainsDirective(string directiveName);
    [NullableContextAttribute("2")]
public sealed virtual bool ContainsDirective();
    internal static DirectiveCollection CreateAndComplete(ITypeCompletionContext context, object source, IReadOnlyList`1<DirectiveDefinition> definitions);
    internal static DirectiveCollection CreateAndComplete(ITypeCompletionContext context, DirectiveLocation location, object source, IReadOnlyList`1<DirectiveDefinition> definitions);
    internal ReadOnlySpan`1<Directive> AsSpan();
    internal Directive& GetReference();
    public sealed virtual IEnumerator`1<Directive> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.DirectiveCollectionExtensions : object {
    [ExtensionAttribute]
public static T SingleOrDefault(IDirectiveCollection directives);
    [ExtensionAttribute]
internal static IValueNode SkipValue(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
internal static IValueNode IncludeValue(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
internal static bool IsDeferrable(InlineFragmentNode fragmentNode);
    [ExtensionAttribute]
internal static bool IsDeferrable(FragmentSpreadNode fragmentSpreadNode);
    [ExtensionAttribute]
internal static bool IsDeferrable(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
internal static bool IsStreamable(FieldNode field);
    [ExtensionAttribute]
internal static bool HasStreamOrDeferDirective(IReadOnlyList`1<DirectiveNode> directives);
    private static IValueNode GetIfArgumentValue(DirectiveNode directive);
    [ExtensionAttribute]
private static DirectiveNode GetSkipDirectiveNode(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
private static DirectiveNode GetIncludeDirectiveNode(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
internal static DeferDirective GetDeferDirective(IReadOnlyList`1<DirectiveNode> directives, IVariableValueCollection variables);
    [ExtensionAttribute]
internal static StreamDirective GetStreamDirective(ISelection selection, IVariableValueCollection variables);
    [ExtensionAttribute]
internal static StreamDirective GetStreamDirective(FieldNode fieldNode, IVariableValueCollection variables);
    [ExtensionAttribute]
internal static IValueNode GetIfArgumentValueOrDefault(DirectiveNode directive);
    [ExtensionAttribute]
internal static IValueNode GetLabelArgumentValueOrDefault(DirectiveNode directive);
    [ExtensionAttribute]
internal static bool StreamDirectiveEquals(DirectiveNode streamA, DirectiveNode streamB);
    private static StreamArgs CreateStreamArgs(DirectiveNode directiveNode);
    [ExtensionAttribute]
internal static DirectiveNode GetDeferDirectiveNode(IHasDirectives container);
    [ExtensionAttribute]
internal static DirectiveNode GetDeferDirectiveNode(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
internal static DirectiveNode GetStreamDirectiveNode(FieldNode selection);
    [ExtensionAttribute]
internal static DirectiveNode GetStreamDirectiveNode(IReadOnlyList`1<DirectiveNode> directives);
    [ExtensionAttribute]
private static DirectiveNode GetDirectiveNode(IReadOnlyList`1<DirectiveNode> directives, string name);
}
[FlagsAttribute]
public enum HotChocolate.Types.DirectiveLocation : Enum {
    public int value__;
    public static DirectiveLocation Query;
    public static DirectiveLocation Mutation;
    public static DirectiveLocation Subscription;
    public static DirectiveLocation Field;
    public static DirectiveLocation FragmentDefinition;
    public static DirectiveLocation FragmentSpread;
    public static DirectiveLocation InlineFragment;
    public static DirectiveLocation VariableDefinition;
    public static DirectiveLocation Schema;
    public static DirectiveLocation Scalar;
    public static DirectiveLocation Object;
    public static DirectiveLocation FieldDefinition;
    public static DirectiveLocation ArgumentDefinition;
    public static DirectiveLocation Interface;
    public static DirectiveLocation Union;
    public static DirectiveLocation Enum;
    public static DirectiveLocation EnumValue;
    public static DirectiveLocation InputObject;
    public static DirectiveLocation InputFieldDefinition;
    public static DirectiveLocation Executable;
    public static DirectiveLocation TypeSystem;
    public static DirectiveLocation Operation;
    public static DirectiveLocation Fragment;
}
[ExtensionAttribute]
public static class HotChocolate.Types.DirectiveLocationExtensions : object {
    private static Dictionary`2<DirectiveLocation, DirectiveLocation> _locs;
    private static DirectiveLocationExtensions();
    [ExtensionAttribute]
public static DirectiveLocation MapDirectiveLocation(DirectiveLocation location);
    [IteratorStateMachineAttribute("HotChocolate.Types.DirectiveLocationExtensions/<AsEnumerable>d__2")]
[ExtensionAttribute]
internal static IEnumerable`1<DirectiveLocation> AsEnumerable(DirectiveLocation locations);
}
public static class HotChocolate.Types.Directives : object {
    private static HashSet`1<string> _directiveNames;
    private static Directives();
    internal static IReadOnlyList`1<TypeReference> CreateReferences(IDescriptorContext descriptorContext);
    public static bool IsBuiltIn(string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.DirectiveType : TypeSystemObjectBase`1<DirectiveTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IDirectiveTypeDescriptor> _configure;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Object[], object> _createInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, Object[]> _getFieldValues;
    private InputParser _inputParser;
    private InputFormatter _inputFormatter;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DirectiveDefinitionNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRepeatable>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveLocation <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<DirectiveArgument> <Arguments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DirectiveMiddleware <Middleware>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExecutableDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeSystemDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <TypeIdentity>k__BackingField;
    [NullableAttribute("2")]
public DirectiveDefinitionNode SyntaxNode { get; private set; }
    public Type RuntimeType { get; private set; }
    public bool IsRepeatable { get; private set; }
    public DirectiveLocation Locations { get; private set; }
    public FieldCollection`1<DirectiveArgument> Arguments { get; private set; }
    [NullableAttribute("2")]
public DirectiveMiddleware Middleware { get; private set; }
    public bool IsExecutableDirective { get; private set; }
    public bool IsTypeSystemDirective { get; private set; }
    internal bool IsPublic { get; private set; }
    [NullableAttribute("2")]
private Type TypeIdentity { get; private set; }
    [NullableAttribute("2")]
private Type HotChocolate.Types.IHasTypeIdentity.TypeIdentity { get; }
    public DirectiveType(Action`1<IDirectiveTypeDescriptor> configure);
    public static DirectiveType CreateUnsafe(DirectiveTypeDefinition definition);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DirectiveDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(DirectiveDefinitionNode value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
private void set_RuntimeType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsRepeatable();
    [CompilerGeneratedAttribute]
private void set_IsRepeatable(bool value);
    [CompilerGeneratedAttribute]
public DirectiveLocation get_Locations();
    [CompilerGeneratedAttribute]
private void set_Locations(DirectiveLocation value);
    [CompilerGeneratedAttribute]
public FieldCollection`1<DirectiveArgument> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(FieldCollection`1<DirectiveArgument> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DirectiveMiddleware get_Middleware();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Middleware(DirectiveMiddleware value);
    [CompilerGeneratedAttribute]
public bool get_IsExecutableDirective();
    [CompilerGeneratedAttribute]
private void set_IsExecutableDirective(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTypeSystemDirective();
    [CompilerGeneratedAttribute]
private void set_IsTypeSystemDirective(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsPublic();
    [CompilerGeneratedAttribute]
private void set_IsPublic(bool value);
    internal object CreateInstance(Object[] fieldValues);
    internal void GetFieldValues(object runtimeValue, Object[] fieldValues);
    public object Parse(DirectiveNode directiveNode);
    public DirectiveNode Format(object runtimeValue);
    public T ParseArgument(string name, IValueNode value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Type get_TypeIdentity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_TypeIdentity(Type value);
    [NullableContextAttribute("2")]
private sealed virtual override Type HotChocolate.Types.IHasTypeIdentity.get_TypeIdentity();
    protected virtual DirectiveTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IDirectiveTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, DirectiveTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, DirectiveTypeDefinition definition);
    protected virtual FieldCollection`1<DirectiveArgument> OnCompleteFields(ITypeCompletionContext context, DirectiveTypeDefinition definition);
    protected virtual Func`2<Object[], object> OnCompleteCreateInstance(ITypeCompletionContext context, DirectiveTypeDefinition definition);
    protected virtual Action`2<object, Object[]> OnCompleteGetFieldValues(ITypeCompletionContext context, DirectiveTypeDefinition definition);
    protected virtual DirectiveMiddleware OnCompleteMiddleware(ITypeCompletionContext context, DirectiveTypeDefinition definition);
    private object CreateDictionaryInstance(Object[] fieldValues);
    private void CreateDictionaryGetValues(object obj, Object[] fieldValues);
    [CompilerGeneratedAttribute]
internal static DirectiveArgument <OnCompleteFields>g__CreateArgument|59_0(DirectiveArgumentDefinition argDef, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.DirectiveType`1 : DirectiveType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IDirectiveTypeDescriptor`1<TDirective>> _configure;
    public DirectiveType`1(Action`1<IDirectiveTypeDescriptor`1<TDirective>> configure);
    protected virtual DirectiveTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IDirectiveTypeDescriptor`1<TDirective> descriptor);
    protected sealed virtual void Configure(IDirectiveTypeDescriptor descriptor);
    public TDirective Parse(DirectiveNode directiveNode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class HotChocolate.Types.DirectiveTypeAttribute : DirectiveTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRepeatable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    public string Name { get; public set; }
    public DirectiveLocation Location { get; }
    public bool IsRepeatable { get; public set; }
    public bool Inherited { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public DirectiveTypeAttribute(DirectiveLocation location);
    [NullableContextAttribute("1")]
public DirectiveTypeAttribute(string name, DirectiveLocation location);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DirectiveLocation get_Location();
    [CompilerGeneratedAttribute]
public bool get_IsRepeatable();
    [CompilerGeneratedAttribute]
public void set_IsRepeatable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IDirectiveTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public abstract class HotChocolate.Types.DirectiveTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IDirectiveTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.DirectiveTypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static IDirectiveTypeDescriptor`1<T> Ignore(IDirectiveTypeDescriptor`1<T> descriptor, Expression`1<Func`2<T, object>> property);
    [ExtensionAttribute]
public static IDirectiveArgumentDescriptor Type(IDirectiveArgumentDescriptor descriptor, string typeSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.DirectiveTypeInterceptor : TypeInterceptor {
    private HashSet`1<DirectiveType> _usedDirectives;
    public virtual void OnAfterCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    internal virtual void OnBeforeRegisterSchemaTypes(IDescriptorContext context, SchemaTypesDefinition schemaTypesDefinition);
    private void InspectType(ITypeSystemObject obj);
    private void RegisterDirectiveUsage(IHasDirectives member);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.EnumType : NamedTypeBase`1<EnumTypeDefinition> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EnumTypeDefinitionNode <SyntaxNode>k__BackingField;
    private Dictionary`2<string, IEnumValue> _enumValues;
    private Dictionary`2<object, IEnumValue> _valueLookup;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IEnumTypeDescriptor> _configure;
    private INamingConventions _naming;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public EnumTypeDefinitionNode SyntaxNode { get; private set; }
    public IReadOnlyCollection`1<IEnumValue> Values { get; }
    protected IReadOnlyDictionary`2<string, IEnumValue> NameLookup { get; }
    protected IReadOnlyDictionary`2<object, IEnumValue> ValueLookup { get; }
    public EnumType(Action`1<IEnumTypeDescriptor> configure);
    public virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual EnumTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(EnumTypeDefinitionNode value);
    public sealed virtual IReadOnlyCollection`1<IEnumValue> get_Values();
    protected IReadOnlyDictionary`2<string, IEnumValue> get_NameLookup();
    protected IReadOnlyDictionary`2<object, IEnumValue> get_ValueLookup();
    public sealed virtual bool TryGetValue(string name, IEnumValue& value);
    public sealed virtual bool TryGetRuntimeValue(string name, Object& runtimeValue);
    public sealed virtual bool IsInstanceOfType(IValueNode valueSyntax);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInstanceOfType(object runtimeValue);
    public sealed virtual object ParseLiteral(IValueNode valueSyntax);
    public sealed virtual IValueNode ParseValue(object runtimeValue);
    public sealed virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public sealed virtual object Serialize(object runtimeValue);
    [NullableContextAttribute("2")]
public sealed virtual object Deserialize(object resultValue);
    [NullableContextAttribute("2")]
public sealed virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    public static EnumType CreateUnsafe(EnumTypeDefinition definition);
    protected virtual void Configure(IEnumTypeDescriptor descriptor);
    protected virtual EnumTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, EnumTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, EnumTypeDefinition definition);
    protected virtual bool TryCreateEnumValue(ITypeCompletionContext context, EnumValueDefinition definition, IEnumValue& enumValue);
}
public class HotChocolate.Types.EnumType`1 : EnumType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IEnumTypeDescriptor`1<T>> _configure;
    [NullableContextAttribute("1")]
public EnumType`1(Action`1<IEnumTypeDescriptor`1<T>> configure);
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetRuntimeValue(string name, T& runtimeValue);
    [NullableContextAttribute("1")]
protected virtual void Configure(IEnumTypeDescriptor`1<T> descriptor);
    [NullableContextAttribute("1")]
protected sealed virtual void Configure(IEnumTypeDescriptor descriptor);
    [NullableContextAttribute("1")]
protected virtual EnumTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("28")]
public class HotChocolate.Types.EnumTypeAttribute : EnumTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public EnumTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IEnumTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("28")]
public abstract class HotChocolate.Types.EnumTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IEnumTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.EnumTypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static IEnumTypeDescriptor`1<T> Ignore(IEnumTypeDescriptor`1<T> descriptor, T value);
    [ExtensionAttribute]
public static IEnumTypeDescriptor Ignore(IEnumTypeDescriptor descriptor, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.EnumTypeExtension : NamedTypeExtensionBase`1<EnumTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IEnumTypeDescriptor> _configure;
    public TypeKind Kind { get; }
    public EnumTypeExtension(Action`1<IEnumTypeDescriptor> configure);
    public static EnumTypeExtension CreateUnsafe(EnumTypeDefinition definition);
    public virtual TypeKind get_Kind();
    protected virtual EnumTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IEnumTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, EnumTypeDefinition definition);
    protected virtual void Merge(ITypeCompletionContext context, INamedType type);
    private void MergeValues(ITypeCompletionContext context, EnumTypeDefinition extension, EnumTypeDefinition type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.EnumValue : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EnumValueDefinitionNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeprecationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectiveCollection <Directives>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <ContextData>k__BackingField;
    [NullableAttribute("2")]
public EnumValueDefinitionNode SyntaxNode { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Description { get; }
    public bool IsDeprecated { get; }
    [NullableAttribute("2")]
public string DeprecationReason { get; }
    public object Value { get; }
    public IDirectiveCollection Directives { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> ContextData { get; }
    public EnumValue(ITypeCompletionContext completionContext, EnumValueDefinition enumValueDefinition);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual EnumValueDefinitionNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeprecated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationReason();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, object> get_ContextData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public abstract class HotChocolate.Types.EnumValueDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IEnumValueDescriptor descriptor, FieldInfo field);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class HotChocolate.Types.ExtendObjectTypeAttribute : ObjectTypeDescriptorAttribute {
    private string _name;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStaticMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExtendsType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <IgnoreFields>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <IgnoreProperties>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    public bool IncludeStaticMembers { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public Type ExtendsType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] IgnoreFields { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] IgnoreProperties { get; public set; }
    public ExtendObjectTypeAttribute(string name);
    public ExtendObjectTypeAttribute(OperationType operationType);
    [NullableContextAttribute("1")]
public ExtendObjectTypeAttribute(Type extendsType);
    public string get_Name();
    [ObsoleteAttribute("Use the new constructor.")]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStaticMembers();
    [CompilerGeneratedAttribute]
public void set_IncludeStaticMembers(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [CompilerGeneratedAttribute]
public Type get_ExtendsType();
    [CompilerGeneratedAttribute]
public String[] get_IgnoreFields();
    [CompilerGeneratedAttribute]
public void set_IgnoreFields(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_IgnoreProperties();
    [CompilerGeneratedAttribute]
public void set_IgnoreProperties(String[] value);
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <OnConfigure>b__30_0(ObjectTypeDefinition d);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <OnConfigure>b__30_1(ObjectTypeDefinition d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Types.Factories.BindDirectiveHelper : object {
    public static string Name;
    public static string ToArgument;
    [ExtensionAttribute]
public static bool IsBindingDirective(DirectiveNode directiveNode);
    [ExtensionAttribute]
public static string GetBindingValue(IHasDirectives syntaxNode);
}
internal class HotChocolate.Types.Factories.DirectiveTypeFactory : object {
    private static Dictionary`2<DirectiveLocation, DirectiveLocation> _locs;
    private static DirectiveTypeFactory();
    public sealed virtual DirectiveType Create(IDescriptorContext context, DirectiveDefinitionNode node);
    private static void DeclareArguments(DirectiveTypeDefinition parent, IReadOnlyCollection`1<InputValueDefinitionNode> arguments, bool preserveSyntaxNodes);
    private static void DeclareLocations(DirectiveTypeDefinition parent, DirectiveDefinitionNode node);
    private static DirectiveLocation MapDirectiveLocation(DirectiveLocation location);
}
internal class HotChocolate.Types.Factories.EnumTypeFactory : object {
    public sealed virtual EnumType Create(IDescriptorContext context, EnumTypeDefinitionNode node);
    public sealed virtual EnumTypeExtension Create(IDescriptorContext context, EnumTypeExtensionNode node);
    private static void DeclareValues(IDescriptorContext context, EnumTypeDefinition parent, IReadOnlyCollection`1<EnumValueDefinitionNode> values, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
}
internal class HotChocolate.Types.Factories.InputObjectTypeFactory : object {
    public sealed virtual InputObjectType Create(IDescriptorContext context, InputObjectTypeDefinitionNode node);
    public sealed virtual InputObjectTypeExtension Create(IDescriptorContext context, InputObjectTypeExtensionNode node);
    private static void DeclareFields(IDescriptorContext context, InputObjectTypeDefinition parent, IReadOnlyCollection`1<InputValueDefinitionNode> fields, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
}
internal class HotChocolate.Types.Factories.InterfaceTypeFactory : object {
    public sealed virtual InterfaceType Create(IDescriptorContext context, InterfaceTypeDefinitionNode node);
    public sealed virtual InterfaceTypeExtension Create(IDescriptorContext context, InterfaceTypeExtensionNode node);
    private static void DeclareFields(IDescriptorContext context, InterfaceTypeDefinition parent, IReadOnlyCollection`1<FieldDefinitionNode> fields, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
    private static void DeclareFieldArguments(IDescriptorContext context, InterfaceFieldDefinition parent, FieldDefinitionNode field, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
}
internal interface HotChocolate.Types.Factories.ITypeFactory`2 {
    public abstract virtual TType Create(IDescriptorContext context, TNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Factories.ObjectTypeFactory : object {
    public sealed virtual ObjectType Create(IDescriptorContext context, ObjectTypeDefinitionNode node);
    public sealed virtual ObjectTypeExtension Create(IDescriptorContext context, ObjectTypeExtensionNode node);
    private static void DeclareFields(IDescriptorContext context, ObjectTypeDefinition parent, IReadOnlyCollection`1<FieldDefinitionNode> fields, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
    private static void DeclareFieldArguments(IDescriptorContext context, ObjectFieldDefinition parent, FieldDefinitionNode field, Stack`1<IDefinition> path, bool preserveSyntaxNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Types.Factories.SchemaBuildingDirectiveHelper : object {
    private static string _definitionStackKey;
    [ExtensionAttribute]
public static Stack`1<IDefinition> GetOrCreateDefinitionStack(IDescriptorContext context);
}
internal class HotChocolate.Types.Factories.SchemaSyntaxVisitor : SyntaxVisitor`1<SchemaSyntaxVisitorContext> {
    private ObjectTypeFactory _objectTypeFactory;
    private InterfaceTypeFactory _interfaceTypeFactory;
    private UnionTypeFactory _unionTypeFactory;
    private InputObjectTypeFactory _inputObjectTypeFactory;
    private EnumTypeFactory _enumTypeFactory;
    private DirectiveTypeFactory _directiveTypeFactory;
    protected ISyntaxVisitorAction DefaultAction { get; }
    protected virtual ISyntaxVisitorAction get_DefaultAction();
    protected virtual ISyntaxVisitorAction VisitChildren(ObjectTypeDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(ObjectTypeExtensionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(InterfaceTypeDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(InterfaceTypeExtensionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(UnionTypeDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(UnionTypeExtensionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(InputObjectTypeDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(InputObjectTypeExtensionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(EnumTypeDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(EnumTypeExtensionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(DirectiveDefinitionNode node, SchemaSyntaxVisitorContext context);
    protected virtual ISyntaxVisitorAction VisitChildren(SchemaDefinitionNode node, SchemaSyntaxVisitorContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Factories.SchemaSyntaxVisitorContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<TypeReference> <Types>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<DirectiveNode> <Directives>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MutationTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscriptionTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDescriptorContext <DirectiveContext>k__BackingField;
    [NullableAttribute("1")]
public List`1<TypeReference> Types { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<DirectiveNode> Directives { get; public set; }
    public string QueryTypeName { get; public set; }
    public string MutationTypeName { get; public set; }
    public string SubscriptionTypeName { get; public set; }
    public string Description { get; public set; }
    [NullableAttribute("1")]
public IDescriptorContext DirectiveContext { get; }
    [NullableContextAttribute("1")]
public SchemaSyntaxVisitorContext(IDescriptorContext directiveContext);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<TypeReference> get_Types();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<DirectiveNode> get_Directives();
    [CompilerGeneratedAttribute]
public void set_Directives(IReadOnlyCollection`1<DirectiveNode> value);
    [CompilerGeneratedAttribute]
public string get_QueryTypeName();
    [CompilerGeneratedAttribute]
public void set_QueryTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_MutationTypeName();
    [CompilerGeneratedAttribute]
public void set_MutationTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_SubscriptionTypeName();
    [CompilerGeneratedAttribute]
public void set_SubscriptionTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDescriptorContext get_DirectiveContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Types.Factories.SdlToTypeSystemHelper : object {
    public static void AddDirectives(IDescriptorContext context, TOwner owner, IHasDirectives ownerSyntax, Stack`1<IDefinition> path);
    [ExtensionAttribute]
public static string DeprecationReason(IHasDirectives syntaxNode);
    [ExtensionAttribute]
public static bool IsDeprecationReason(DirectiveNode directiveNode);
}
internal class HotChocolate.Types.Factories.UnionTypeFactory : object {
    public sealed virtual UnionType Create(IDescriptorContext context, UnionTypeDefinitionNode node);
    public sealed virtual UnionTypeExtension Create(IDescriptorContext context, UnionTypeExtensionNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.FieldBase`1 : object {
    [NullableAttribute("2")]
private TDefinition _definition;
    private FieldFlags _flags;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISyntaxNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSystemObject <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCoordinate <Coordinate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectiveCollection <Directives>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <ContextData>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public string Description { get; }
    [NullableAttribute("2")]
public ISyntaxNode SyntaxNode { get; }
    public ITypeSystemObject DeclaringType { get; private set; }
    public FieldCoordinate Coordinate { get; private set; }
    public int Index { get; }
    public IDirectiveCollection Directives { get; private set; }
    public Type RuntimeType { get; }
    internal FieldFlags Flags { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> ContextData { get; private set; }
    protected FieldBase`1(TDefinition definition, int index);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ISyntaxNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSystemObject get_DeclaringType();
    [CompilerGeneratedAttribute]
private void set_DeclaringType(ITypeSystemObject value);
    [CompilerGeneratedAttribute]
public sealed virtual FieldCoordinate get_Coordinate();
    [CompilerGeneratedAttribute]
private void set_Coordinate(FieldCoordinate value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
private void set_Directives(IDirectiveCollection value);
    public abstract virtual Type get_RuntimeType();
    internal FieldFlags get_Flags();
    internal void set_Flags(FieldFlags value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, object> get_ContextData();
    [CompilerGeneratedAttribute]
private void set_ContextData(IReadOnlyDictionary`2<string, object> value);
    internal void CompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember);
    protected virtual void OnCompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember, TDefinition definition);
    private sealed virtual override void HotChocolate.Types.Helpers.IFieldCompletion.CompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember);
    private void AssertMutable();
}
[FlagsAttribute]
public enum HotChocolate.Types.FieldBindingFlags : Enum {
    public int value__;
    public static FieldBindingFlags Default;
    public static FieldBindingFlags Instance;
    public static FieldBindingFlags Static;
    public static FieldBindingFlags InstanceAndStatic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class HotChocolate.Types.FieldCollection`1 : object {
    private Dictionary`2<string, T> _fieldsLookup;
    private T[] _fields;
    [CompilerGeneratedAttribute]
private static FieldCollection`1<T> <Empty>k__BackingField;
    public T Item { get; }
    public T Item { get; }
    public int Count { get; }
    public static FieldCollection`1<T> Empty { get; }
    internal FieldCollection`1(T[] fields);
    private FieldCollection`1(Dictionary`2<string, T> fieldsLookup, T[] fields);
    private static FieldCollection`1();
    public sealed virtual T get_Item(string fieldName);
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsField(string fieldName);
    public bool TryGetField(string fieldName, T& field);
    internal ReadOnlySpan`1<T> AsSpan();
    internal T& GetReference();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public static FieldCollection`1<T> get_Empty();
    internal static FieldCollection`1<T> TryCreate(T[] fields, IReadOnlyCollection`1& duplicateFieldNames);
}
[ExtensionAttribute]
public static class HotChocolate.Types.FieldCollectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryGetField(IFieldCollection`1<T> collection, string fieldName, T& field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SpecScalarAttribute]
public class HotChocolate.Types.FloatType : FloatTypeBase`1<double> {
    public FloatType(double min, double max);
    public FloatType(string name, string description, double min, double max, BindingBehavior bind);
    protected virtual double ParseLiteral(IFloatValueLiteral valueSyntax);
    protected virtual FloatValueNode ParseValue(double runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.FloatTypeBase`1 : ScalarType`1<TRuntimeType> {
    [CompilerGeneratedAttribute]
private TRuntimeType <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private TRuntimeType <MaxValue>k__BackingField;
    public TRuntimeType MinValue { get; }
    public TRuntimeType MaxValue { get; }
    protected FloatTypeBase`1(string name, TRuntimeType min, TRuntimeType max, BindingBehavior bind);
    [CompilerGeneratedAttribute]
public TRuntimeType get_MinValue();
    [CompilerGeneratedAttribute]
public TRuntimeType get_MaxValue();
    public virtual bool IsInstanceOfType(IValueNode valueSyntax);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInstanceOfType(object runtimeValue);
    protected virtual bool IsInstanceOfType(IFloatValueLiteral valueSyntax);
    protected virtual bool IsInstanceOfType(TRuntimeType value);
    public virtual object ParseLiteral(IValueNode valueSyntax);
    protected abstract virtual TRuntimeType ParseLiteral(IFloatValueLiteral valueSyntax);
    public virtual IValueNode ParseValue(object runtimeValue);
    protected abstract virtual FloatValueNode ParseValue(TRuntimeType runtimeValue);
    public sealed virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    protected virtual SerializationException CreateParseValueError(object runtimeValue);
    protected virtual SerializationException CreateParseLiteralError(IValueNode valueSyntax);
    protected virtual SerializationException CreateParseResultError(object runtimeValue);
}
public abstract class HotChocolate.Types.FluentWrapperType : object {
    [NullableAttribute("1")]
private Type HotChocolate.Types.IHasRuntimeType.RuntimeType { get; }
    private TypeKind HotChocolate.Types.IType.Kind { get; }
    [NullableContextAttribute("1")]
private sealed virtual override Type HotChocolate.Types.IHasRuntimeType.get_RuntimeType();
    private sealed virtual override TypeKind HotChocolate.Types.IType.get_Kind();
}
internal static class HotChocolate.Types.Helpers.CompleteInterfacesHelper : object {
    [NullableContextAttribute("1")]
public static InterfaceType[] CompleteInterfaces(ITypeCompletionContext context, IReadOnlyList`1<TypeReference> interfaceReferences, TInterfaceOrObject interfaceOrObject);
}
[ExtensionAttribute]
internal static class HotChocolate.Types.Helpers.DescriptorHelpers : object {
    [ExtensionAttribute]
public static TDefinition SetMoreSpecificType(TDefinition definition, IExtendedType type, TypeContext context);
    [ExtensionAttribute]
public static TDefinition SetMoreSpecificType(TDefinition definition, ITypeNode typeNode, TypeContext context);
    private static bool IsTypeMoreSpecific(TypeReference typeReference, IExtendedType type);
    private static bool IsTypeMoreSpecific(TypeReference typeReference, ITypeNode typeNode);
}
internal static class HotChocolate.Types.Helpers.DirectiveHelper : object {
    public static DirectiveLocation InferDirectiveLocation(object source);
}
[ExtensionAttribute]
public static class HotChocolate.Types.Helpers.DirectiveUtils : object {
    [ExtensionAttribute]
public static void AddDirective(IHasDirectiveDefinition directivesContainer, T directive, ITypeInspector typeInspector);
    [ExtensionAttribute]
public static void AddDirective(IHasDirectiveDefinition directivesContainer, string name, IEnumerable`1<ArgumentNode> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Types.Helpers.FieldDescriptorUtilities : object {
    public static void AddExplicitFields(IEnumerable`1<TField> fieldDefinitions, Func`2<TField, TMember> resolveMember, IDictionary`2<string, TField> fields, ISet`1<TMember> handledMembers);
    public static void AddImplicitFields(TDescriptor descriptor, Func`2<TMember, TField> createdFieldDefinition, IDictionary`2<string, TField> fields, ISet`1<TMember> handledMembers);
    public static void AddImplicitFields(TDescriptor descriptor, Type fieldBindingType, Func`2<TMember, TField> createdFieldDefinition, IDictionary`2<string, TField> fields, ISet`1<TMember> handledMembers, Func`3<IReadOnlyList`1<TMember>, TMember, bool> include, bool includeIgnoredMembers);
    public static void DiscoverArguments(IDescriptorContext context, ICollection`1<ArgumentDefinition> arguments, MemberInfo member, ParameterInfo[] parameters, IReadOnlyList`1<IParameterExpressionBuilder> parameterExpressionBuilders);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Types.Helpers.FieldMiddlewareCompiler : object {
    public static FieldDelegate Compile(IReadOnlyList`1<FieldMiddleware> globalComponents, IReadOnlyList`1<FieldMiddlewareDefinition> fieldComponents, IReadOnlyList`1<ResultFormatterDefinition> resultConverters, FieldResolverDelegate fieldResolver, bool skipMiddleware);
    public static PureFieldDelegate Compile(IReadOnlyList`1<ResultFormatterDefinition> resultConverters, PureFieldDelegate fieldResolver, bool skipMiddleware);
    private static FieldDelegate CompilePipeline(IReadOnlyList`1<FieldMiddleware> components, IReadOnlyList`1<FieldMiddlewareDefinition> mappedComponents, IReadOnlyList`1<ResultFormatterDefinition> resultConverters, FieldResolverDelegate fieldResolver);
    private static FieldDelegate CompileMiddlewareComponents(IReadOnlyList`1<FieldMiddleware> components, FieldDelegate first);
    private static FieldDelegate CompileMiddlewareComponents(IReadOnlyList`1<FieldMiddlewareDefinition> components, FieldDelegate first);
    private static FieldDelegate CompileResultConverters(IReadOnlyList`1<ResultFormatterDefinition> components, FieldDelegate first);
    private static PureFieldDelegate CompileResultConverters(IReadOnlyList`1<ResultFormatterDefinition> components, PureFieldDelegate first);
    private static FieldMiddleware CreateConverterMiddleware(ResultFormatterDelegate convert);
    private static PureFieldDelegate CreatePureConverterMiddleware(ResultFormatterDelegate convert, PureFieldDelegate next);
    private static FieldDelegate CreateResolverMiddleware(FieldResolverDelegate fieldResolver);
}
internal interface HotChocolate.Types.Helpers.IFieldCompletion {
    public abstract virtual void CompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Types.Helpers.TypeMemHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ObjectFieldDefinition> _objectFieldDefinitionMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, InputFieldDefinition> _inputFieldDefinitionMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, InputField> _inputFieldMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, InputField> _inputFieldMapOrdinalIgnoreCase;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DirectiveArgument> _directiveArgumentMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DirectiveArgument> _directiveArgumentMapOrdinalIgnoreCase;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ParameterInfo, string> _argumentNameMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HashSet`1<MemberInfo> _memberSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HashSet`1<string> _nameSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HashSet`1<string> _nameSetOrdinalIgnoreCase;
    public static Dictionary`2<string, ObjectFieldDefinition> RentObjectFieldDefinitionMap();
    public static void Return(Dictionary`2<string, ObjectFieldDefinition> map);
    public static Dictionary`2<string, InputFieldDefinition> RentInputFieldDefinitionMap();
    public static void Return(Dictionary`2<string, InputFieldDefinition> map);
    public static Dictionary`2<string, InputField> RentInputFieldMap();
    public static Dictionary`2<string, InputField> RentInputFieldMapOrdinalIgnoreCase();
    public static void Return(Dictionary`2<string, InputField> map);
    public static Dictionary`2<string, DirectiveArgument> RentDirectiveArgumentMap();
    public static Dictionary`2<string, DirectiveArgument> RentDirectiveArgumentMapOrdinalIgnoreCase();
    public static void Return(Dictionary`2<string, DirectiveArgument> map);
    public static HashSet`1<MemberInfo> RentMemberSet();
    public static void Return(HashSet`1<MemberInfo> set);
    public static HashSet`1<string> RentNameSet();
    public static HashSet`1<string> RentNameSetOrdinalIgnoreCase();
    public static void Return(HashSet`1<string> set);
    public static Dictionary`2<ParameterInfo, string> RentArgumentNameMap();
    public static void Return(Dictionary`2<ParameterInfo, string> map);
    public static void Clear();
}
public static class HotChocolate.Types.Helpers.TypeNameHelper : object {
    public static void AddNameFunction(IDescriptor`1<TDefinition> descriptor, Func`2<INamedType, string> createName, Type dependency);
}
public interface HotChocolate.Types.IArgumentDescriptor {
    public abstract virtual IArgumentDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public abstract virtual IArgumentDescriptor Deprecated(string reason);
    public abstract virtual IArgumentDescriptor Deprecated();
    public abstract virtual IArgumentDescriptor Description(string value);
    public abstract virtual IArgumentDescriptor Type();
    public abstract virtual IArgumentDescriptor Type(TInputType inputType);
    public abstract virtual IArgumentDescriptor Type(ITypeNode typeNode);
    public abstract virtual IArgumentDescriptor Type(Type type);
    public abstract virtual IArgumentDescriptor DefaultValue(IValueNode value);
    public abstract virtual IArgumentDescriptor DefaultValue(object value);
    public abstract virtual IArgumentDescriptor Directive(T directiveInstance);
    public abstract virtual IArgumentDescriptor Directive();
    public abstract virtual IArgumentDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.ICompletedDependencyDescriptor {
    public abstract virtual ICompletedDependencyDescriptor DependsOn();
    public abstract virtual ICompletedDependencyDescriptor DependsOn(bool mustBeCompleted);
    public abstract virtual ICompletedDependencyDescriptor DependsOn(Type schemaType);
    public abstract virtual ICompletedDependencyDescriptor DependsOn(Type schemaType, bool mustBeCompleted);
    public abstract virtual ICompletedDependencyDescriptor DependsOn(string typeName);
    public abstract virtual ICompletedDependencyDescriptor DependsOn(string typeName, bool mustBeCompleted);
}
public interface HotChocolate.Types.IComplexOutputType {
    public IReadOnlyList`1<IInterfaceType> Implements { get; }
    public IFieldCollection`1<IOutputField> Fields { get; }
    public abstract virtual IReadOnlyList`1<IInterfaceType> get_Implements();
    public abstract virtual IFieldCollection`1<IOutputField> get_Fields();
    public abstract virtual bool IsImplementing(string typeName);
    public abstract virtual bool IsImplementing(IInterfaceType interfaceType);
}
public interface HotChocolate.Types.ICostSettings {
    public bool Enable { get; }
    public bool ApplyDefaults { get; }
    public int DefaultComplexity { get; }
    public int DefaultResolverComplexity { get; }
    public abstract virtual bool get_Enable();
    public abstract virtual bool get_ApplyDefaults();
    public abstract virtual int get_DefaultComplexity();
    public abstract virtual int get_DefaultResolverComplexity();
}
public interface HotChocolate.Types.IDescriptor {
}
public interface HotChocolate.Types.IDescriptor`1 {
    [NullableContextAttribute("1")]
public abstract virtual IDescriptorExtension`1<T> Extend();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IDescriptorExtension {
    public abstract virtual void OnBeforeCreate(Action`1<DefinitionBase> configure);
    public abstract virtual void OnBeforeCreate(Action`2<IDescriptorContext, DefinitionBase> configure);
    public abstract virtual INamedDependencyDescriptor OnBeforeNaming(Action`2<ITypeCompletionContext, DefinitionBase> configure);
    public abstract virtual ICompletedDependencyDescriptor OnBeforeCompletion(Action`2<ITypeCompletionContext, DefinitionBase> configure);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IDescriptorExtension`1 {
    public T Definition { get; }
    public abstract virtual T get_Definition();
    public abstract virtual void OnBeforeCreate(Action`1<T> configure);
    public abstract virtual void OnBeforeCreate(Action`2<IDescriptorContext, T> configure);
    public abstract virtual INamedDependencyDescriptor OnBeforeNaming(Action`2<ITypeCompletionContext, T> configure);
    public abstract virtual ICompletedDependencyDescriptor OnBeforeCompletion(Action`2<ITypeCompletionContext, T> configure);
}
public interface HotChocolate.Types.IDirectiveArgumentDescriptor {
    public abstract virtual IDirectiveArgumentDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public abstract virtual IDirectiveArgumentDescriptor Deprecated(string reason);
    public abstract virtual IDirectiveArgumentDescriptor Deprecated();
    public abstract virtual IDirectiveArgumentDescriptor Name(string value);
    public abstract virtual IDirectiveArgumentDescriptor Description(string value);
    public abstract virtual IDirectiveArgumentDescriptor Type();
    public abstract virtual IDirectiveArgumentDescriptor Type(TInputType inputType);
    public abstract virtual IDirectiveArgumentDescriptor Type(ITypeNode typeNode);
    public abstract virtual IDirectiveArgumentDescriptor Type(Type type);
    public abstract virtual IDirectiveArgumentDescriptor DefaultValue(IValueNode value);
    public abstract virtual IDirectiveArgumentDescriptor DefaultValue(object value);
    public abstract virtual IDirectiveArgumentDescriptor Ignore(bool ignore);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface HotChocolate.Types.IDirectiveCollection {
    public IEnumerable`1<Directive> Item { get; }
    public Directive Item { get; }
    public abstract virtual IEnumerable`1<Directive> get_Item(string directiveName);
    public abstract virtual Directive get_Item(int index);
    public abstract virtual Directive FirstOrDefault(string directiveName);
    [NullableContextAttribute("2")]
public abstract virtual Directive FirstOrDefault();
    public abstract virtual bool ContainsDirective(string directiveName);
    [NullableContextAttribute("2")]
public abstract virtual bool ContainsDirective();
}
public interface HotChocolate.Types.IDirectiveTypeDescriptor {
    public abstract virtual IDirectiveTypeDescriptor SyntaxNode(DirectiveDefinitionNode directiveDefinitionNode);
    public abstract virtual IDirectiveTypeDescriptor Name(string value);
    public abstract virtual IDirectiveTypeDescriptor Description(string value);
    public abstract virtual IDirectiveArgumentDescriptor Argument(string name);
    public abstract virtual IDirectiveTypeDescriptor Location(DirectiveLocation value);
    [ObsoleteAttribute("Replace Middleware with `Use`.")]
public abstract virtual IDirectiveTypeDescriptor Middleware(DirectiveMiddleware middleware);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public abstract virtual IDirectiveTypeDescriptor Middleware(Expression`1<Func`2<T, object>> method);
    [ObsoleteAttribute("Replace Middleware with `Use`.", "True")]
public abstract virtual IDirectiveTypeDescriptor Middleware(Expression`1<Action`1<T>> method);
    public abstract virtual IDirectiveTypeDescriptor Use(DirectiveMiddleware middleware);
    public abstract virtual IDirectiveTypeDescriptor Use();
    public abstract virtual IDirectiveTypeDescriptor Use(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    public abstract virtual IDirectiveTypeDescriptor Repeatable();
    public abstract virtual IDirectiveTypeDescriptor Public();
    public abstract virtual IDirectiveTypeDescriptor Internal();
}
public interface HotChocolate.Types.IDirectiveTypeDescriptor`1 {
    public abstract virtual IDirectiveTypeDescriptor`1<T> SyntaxNode(DirectiveDefinitionNode directiveDefinitionNode);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Name(string value);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Description(string value);
    public abstract virtual IDirectiveTypeDescriptor`1<T> BindArguments(BindingBehavior behavior);
    public abstract virtual IDirectiveTypeDescriptor`1<T> BindArgumentsExplicitly();
    public abstract virtual IDirectiveTypeDescriptor`1<T> BindArgumentsImplicitly();
    public abstract virtual IDirectiveArgumentDescriptor Argument(Expression`1<Func`2<T, object>> property);
    public abstract virtual IDirectiveArgumentDescriptor Argument(string name);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Location(DirectiveLocation value);
    [ObsoleteAttribute("Use `Use(DirectiveMiddleware)`.")]
public abstract virtual IDirectiveTypeDescriptor`1<T> Middleware(DirectiveMiddleware middleware);
    [ObsoleteAttribute("Use `Use(DirectiveMiddleware)`.")]
public abstract virtual IDirectiveTypeDescriptor`1<T> Middleware(Expression`1<Func`2<TMiddleware, object>> method);
    [ObsoleteAttribute("Use `Use(DirectiveMiddleware)`.")]
public abstract virtual IDirectiveTypeDescriptor`1<T> Middleware(Expression`1<Action`1<TMiddleware>> method);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Use(DirectiveMiddleware middleware);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Use();
    public abstract virtual IDirectiveTypeDescriptor`1<T> Use(Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
    public abstract virtual IDirectiveTypeDescriptor`1<T> Repeatable();
    public abstract virtual IDirectiveTypeDescriptor`1<T> Public();
    public abstract virtual IDirectiveTypeDescriptor`1<T> Internal();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[SpecScalarAttribute]
public class HotChocolate.Types.IdType : ScalarType`1<string> {
    public IdType(string name, string description, BindingBehavior bind);
    public virtual bool IsInstanceOfType(IValueNode literal);
    public virtual object ParseLiteral(IValueNode literal);
    public virtual IValueNode ParseValue(object runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
public interface HotChocolate.Types.IEnumType {
    [NullableAttribute("2")]
public EnumTypeDefinitionNode SyntaxNode { get; }
    [NullableAttribute("1")]
public IReadOnlyCollection`1<IEnumValue> Values { get; }
    [NullableContextAttribute("2")]
public abstract virtual EnumTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyCollection`1<IEnumValue> get_Values();
    [NullableContextAttribute("1")]
public abstract virtual bool TryGetValue(string name, IEnumValue& value);
    [NullableContextAttribute("1")]
public abstract virtual bool TryGetRuntimeValue(string name, Object& runtimeValue);
}
public interface HotChocolate.Types.IEnumType`1 {
    [NullableContextAttribute("1")]
public abstract virtual bool TryGetRuntimeValue(string name, T& runtimeValue);
}
public interface HotChocolate.Types.IEnumTypeDescriptor {
    public abstract virtual IEnumTypeDescriptor SyntaxNode(EnumTypeDefinitionNode enumTypeDefinition);
    public abstract virtual IEnumTypeDescriptor Name(string value);
    public abstract virtual IEnumTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use `Value`.")]
public abstract virtual IEnumValueDescriptor Item(T value);
    public abstract virtual IEnumValueDescriptor Value(T value);
    [ObsoleteAttribute("Use `BindValues`.")]
public abstract virtual IEnumTypeDescriptor BindItems(BindingBehavior behavior);
    public abstract virtual IEnumTypeDescriptor BindValues(BindingBehavior behavior);
    public abstract virtual IEnumTypeDescriptor BindValuesExplicitly();
    public abstract virtual IEnumTypeDescriptor BindValuesImplicitly();
    public abstract virtual IEnumTypeDescriptor NameComparer(IEqualityComparer`1<string> comparer);
    public abstract virtual IEnumTypeDescriptor ValueComparer(IEqualityComparer`1<object> comparer);
    public abstract virtual IEnumTypeDescriptor Directive(TDirective directiveInstance);
    public abstract virtual IEnumTypeDescriptor Directive();
    public abstract virtual IEnumTypeDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IEnumTypeDescriptor`1 {
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> SyntaxNode(EnumTypeDefinitionNode enumTypeDefinition);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> Name(string value);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> Description(string value);
    [ObsoleteAttribute("Use `Value`.")]
public abstract virtual IEnumValueDescriptor Item(TRuntimeType value);
    public abstract virtual IEnumValueDescriptor Value(TRuntimeType value);
    [ObsoleteAttribute("Use `BindValues`.")]
public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> BindItems(BindingBehavior behavior);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> BindValues(BindingBehavior behavior);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> BindValuesExplicitly();
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> BindValuesImplicitly();
    public abstract virtual IEnumTypeDescriptor NameComparer(IEqualityComparer`1<string> comparer);
    public abstract virtual IEnumTypeDescriptor ValueComparer(IEqualityComparer`1<object> comparer);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> Directive(TDirective directiveInstance);
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> Directive();
    public abstract virtual IEnumTypeDescriptor`1<TRuntimeType> Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IEnumTypeNameDependencyDescriptor {
    public abstract virtual IEnumTypeDescriptor DependsOn();
    public abstract virtual IEnumTypeDescriptor DependsOn(Type schemaType);
}
public interface HotChocolate.Types.IEnumTypeNameDependencyDescriptor`1 {
    public abstract virtual IEnumTypeDescriptor`1<T> DependsOn();
    public abstract virtual IEnumTypeDescriptor`1<T> DependsOn(Type schemaType);
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IEnumValue {
    public EnumValueDefinitionNode SyntaxNode { get; }
    [NullableAttribute("1")]
public string Name { get; }
    public string Description { get; }
    public bool IsDeprecated { get; }
    public string DeprecationReason { get; }
    [NullableAttribute("1")]
public object Value { get; }
    public abstract virtual EnumValueDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual bool get_IsDeprecated();
    public abstract virtual string get_DeprecationReason();
    [NullableContextAttribute("1")]
public abstract virtual object get_Value();
}
public interface HotChocolate.Types.IEnumValueDescriptor {
    public abstract virtual IEnumValueDescriptor SyntaxNode(EnumValueDefinitionNode enumValueDefinition);
    public abstract virtual IEnumValueDescriptor Name(string value);
    public abstract virtual IEnumValueDescriptor Description(string value);
    [ObsoleteAttribute("Use `Deprecated`.")]
public abstract virtual IEnumValueDescriptor DeprecationReason(string reason);
    public abstract virtual IEnumValueDescriptor Deprecated(string reason);
    public abstract virtual IEnumValueDescriptor Deprecated();
    public abstract virtual IEnumValueDescriptor Ignore(bool ignore);
    public abstract virtual IEnumValueDescriptor Directive(T directiveInstance);
    public abstract virtual IEnumValueDescriptor Directive();
    public abstract virtual IEnumValueDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IField {
    [NullableAttribute("1")]
public ITypeSystemObject DeclaringType { get; }
    public int Index { get; }
    [NullableContextAttribute("1")]
public abstract virtual ITypeSystemObject get_DeclaringType();
    public abstract virtual int get_Index();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface HotChocolate.Types.IFieldCollection`1 {
    public T Item { get; }
    public T Item { get; }
    public abstract virtual T get_Item(string fieldName);
    public abstract virtual T get_Item(int index);
    public abstract virtual bool ContainsField(string fieldName);
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IHasDescription {
    public string Description { get; }
    public abstract virtual string get_Description();
}
public interface HotChocolate.Types.IHasDescriptorContext {
    public IDescriptorContext Context { get; }
    public abstract virtual IDescriptorContext get_Context();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IHasDirectives {
    public IDirectiveCollection Directives { get; }
    public abstract virtual IDirectiveCollection get_Directives();
}
public interface HotChocolate.Types.IHasFieldCoordinate {
    public FieldCoordinate Coordinate { get; }
    public abstract virtual FieldCoordinate get_Coordinate();
}
public interface HotChocolate.Types.IHasName {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface HotChocolate.Types.IHasOptional {
    public bool IsOptional { get; }
    public abstract virtual bool get_IsOptional();
}
[NullableContextAttribute("2")]
internal interface HotChocolate.Types.IHasProperty {
    public PropertyInfo Property { get; }
    public abstract virtual PropertyInfo get_Property();
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IHasScope {
    public string Scope { get; }
    public abstract virtual string get_Scope();
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IHasSyntaxNode {
    public ISyntaxNode SyntaxNode { get; }
    public abstract virtual ISyntaxNode get_SyntaxNode();
}
[NullableContextAttribute("2")]
internal interface HotChocolate.Types.IHasTypeDefinition {
    public ITypeDefinition Definition { get; }
    public abstract virtual ITypeDefinition get_Definition();
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IHasTypeIdentity {
    public Type TypeIdentity { get; }
    public abstract virtual Type get_TypeIdentity();
}
public interface HotChocolate.Types.IInputField {
    public bool IsDeprecated { get; }
    [NullableAttribute("2")]
public string DeprecationReason { get; }
    public abstract virtual bool get_IsDeprecated();
    [NullableContextAttribute("2")]
public abstract virtual string get_DeprecationReason();
}
public interface HotChocolate.Types.IInputFieldDescriptor {
    public abstract virtual IInputFieldDescriptor SyntaxNode(InputValueDefinitionNode inputValueDefinition);
    public abstract virtual IInputFieldDescriptor Name(string value);
    public abstract virtual IInputFieldDescriptor Deprecated(string reason);
    public abstract virtual IInputFieldDescriptor Deprecated();
    public abstract virtual IInputFieldDescriptor Description(string value);
    public abstract virtual IInputFieldDescriptor Type();
    public abstract virtual IInputFieldDescriptor Type(TInputType inputType);
    public abstract virtual IInputFieldDescriptor Type(ITypeNode typeNode);
    public abstract virtual IInputFieldDescriptor Type(Type type);
    public abstract virtual IInputFieldDescriptor Ignore(bool ignore);
    public abstract virtual IInputFieldDescriptor DefaultValue(IValueNode value);
    public abstract virtual IInputFieldDescriptor DefaultValue(object value);
    public abstract virtual IInputFieldDescriptor Directive(T directiveInstance);
    public abstract virtual IInputFieldDescriptor Directive();
    public abstract virtual IInputFieldDescriptor Directive(string name, ArgumentNode[] arguments);
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IInputFieldInfo {
    [NullableAttribute("1")]
public IInputType Type { get; }
    public IValueNode DefaultValue { get; }
    public IInputValueFormatter Formatter { get; }
    [NullableContextAttribute("1")]
public abstract virtual IInputType get_Type();
    public abstract virtual IValueNode get_DefaultValue();
    public abstract virtual IInputValueFormatter get_Formatter();
}
public interface HotChocolate.Types.IInputObjectType {
    [NullableAttribute("1")]
public IFieldCollection`1<IInputField> Fields { get; }
    [NullableContextAttribute("1")]
public abstract virtual IFieldCollection`1<IInputField> get_Fields();
}
public interface HotChocolate.Types.IInputObjectTypeDescriptor {
    public abstract virtual IInputObjectTypeDescriptor SyntaxNode(InputObjectTypeDefinitionNode inputObjectTypeDefinition);
    public abstract virtual IInputObjectTypeDescriptor Name(string value);
    public abstract virtual IInputObjectTypeDescriptor Description(string value);
    public abstract virtual IInputFieldDescriptor Field(string name);
    public abstract virtual IInputObjectTypeDescriptor Directive(T directiveInstance);
    public abstract virtual IInputObjectTypeDescriptor Directive();
    public abstract virtual IInputObjectTypeDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IInputObjectTypeDescriptor`1 {
    public abstract virtual IInputObjectTypeDescriptor`1<T> SyntaxNode(InputObjectTypeDefinitionNode inputObjectTypeDefinition);
    public abstract virtual IInputObjectTypeDescriptor`1<T> Name(string value);
    public abstract virtual IInputObjectTypeDescriptor`1<T> Description(string value);
    public abstract virtual IInputObjectTypeDescriptor`1<T> BindFields(BindingBehavior behavior);
    public abstract virtual IInputObjectTypeDescriptor`1<T> BindFieldsExplicitly();
    public abstract virtual IInputObjectTypeDescriptor`1<T> BindFieldsImplicitly();
    public abstract virtual IInputFieldDescriptor Field(string name);
    public abstract virtual IInputFieldDescriptor Field(Expression`1<Func`2<T, TValue>> property);
    public abstract virtual IInputObjectTypeDescriptor`1<T> Directive(TDirective directiveInstance);
    public abstract virtual IInputObjectTypeDescriptor`1<T> Directive();
    public abstract virtual IInputObjectTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IInputObjectTypeNameDependencyDescriptor {
    public abstract virtual IInputObjectTypeDescriptor DependsOn();
    public abstract virtual IInputObjectTypeDescriptor DependsOn(Type schemaType);
}
public interface HotChocolate.Types.IInputObjectTypeNameDependencyDescriptor`1 {
    public abstract virtual IInputObjectTypeDescriptor`1<T> DependsOn();
    public abstract virtual IInputObjectTypeDescriptor`1<T> DependsOn(Type schemaType);
}
[NullableContextAttribute("2")]
public interface HotChocolate.Types.IInputValueFormatter {
    public abstract virtual object Format(object runtimeValue);
}
public interface HotChocolate.Types.IInterfaceFieldDescriptor {
    public abstract virtual IInterfaceFieldDescriptor SyntaxNode(FieldDefinitionNode fieldDefinition);
    public abstract virtual IInterfaceFieldDescriptor Name(string value);
    public abstract virtual IInterfaceFieldDescriptor Description(string value);
    [ObsoleteAttribute("Use `Deprecated`.")]
public abstract virtual IInterfaceFieldDescriptor DeprecationReason(string reason);
    public abstract virtual IInterfaceFieldDescriptor Deprecated(string reason);
    public abstract virtual IInterfaceFieldDescriptor Deprecated();
    public abstract virtual IInterfaceFieldDescriptor Type();
    public abstract virtual IInterfaceFieldDescriptor Type(TOutputType type);
    public abstract virtual IInterfaceFieldDescriptor Type(ITypeNode type);
    public abstract virtual IInterfaceFieldDescriptor Type(Type type);
    public abstract virtual IInterfaceFieldDescriptor Ignore(bool ignore);
    public abstract virtual IInterfaceFieldDescriptor Argument(string name, Action`1<IArgumentDescriptor> argument);
    public abstract virtual IInterfaceFieldDescriptor Directive(T directiveInstance);
    public abstract virtual IInterfaceFieldDescriptor Directive();
    public abstract virtual IInterfaceFieldDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IInterfaceType {
    [NullableAttribute("2")]
public InterfaceTypeDefinitionNode SyntaxNode { get; }
    [NullableContextAttribute("2")]
public abstract virtual InterfaceTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
public abstract virtual IObjectType ResolveConcreteType(IResolverContext context, object resolverResult);
}
public interface HotChocolate.Types.IInterfaceTypeDescriptor {
    public abstract virtual IInterfaceTypeDescriptor SyntaxNode(InterfaceTypeDefinitionNode interfaceTypeDefinition);
    public abstract virtual IInterfaceTypeDescriptor Name(string value);
    public abstract virtual IInterfaceTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor Interface();
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor Interface(T type);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor Interface(NamedTypeNode type);
    public abstract virtual IInterfaceTypeDescriptor Implements();
    public abstract virtual IInterfaceTypeDescriptor Implements(T type);
    public abstract virtual IInterfaceTypeDescriptor Implements(NamedTypeNode type);
    public abstract virtual IInterfaceTypeDescriptor ResolveAbstractType(ResolveAbstractType typeResolver);
    public abstract virtual IInterfaceFieldDescriptor Field(string name);
    public abstract virtual IInterfaceTypeDescriptor Directive(T directiveInstance);
    public abstract virtual IInterfaceTypeDescriptor Directive();
    public abstract virtual IInterfaceTypeDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IInterfaceTypeDescriptor`1 {
    public abstract virtual IInterfaceTypeDescriptor`1<T> SyntaxNode(InterfaceTypeDefinitionNode interfaceTypeDefinition);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Name(string value);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Description(string value);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor`1<T> Interface();
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor`1<T> Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IInterfaceTypeDescriptor`1<T> Interface(NamedTypeNode type);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Implements();
    public abstract virtual IInterfaceTypeDescriptor`1<T> Implements(TInterface type);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Implements(NamedTypeNode type);
    public abstract virtual IInterfaceTypeDescriptor`1<T> BindFields(BindingBehavior behavior);
    public abstract virtual IInterfaceTypeDescriptor`1<T> BindFieldsExplicitly();
    public abstract virtual IInterfaceTypeDescriptor`1<T> BindFieldsImplicitly();
    public abstract virtual IInterfaceTypeDescriptor`1<T> ResolveAbstractType(ResolveAbstractType typeResolver);
    public abstract virtual IInterfaceFieldDescriptor Field(Expression`1<Func`2<T, object>> propertyOrMethod);
    public abstract virtual IInterfaceFieldDescriptor Field(string name);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Directive(TDirective directiveInstance);
    public abstract virtual IInterfaceTypeDescriptor`1<T> Directive();
    public abstract virtual IInterfaceTypeDescriptor`1<T> Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IInterfaceTypeNameDependencyDescriptor {
    public abstract virtual IInterfaceTypeDescriptor DependsOn();
    public abstract virtual IInterfaceTypeDescriptor DependsOn(Type schemaType);
}
public interface HotChocolate.Types.IInterfaceTypeNameDependencyDescriptor`1 {
    public abstract virtual IInterfaceTypeDescriptor`1<T> DependsOn();
    public abstract virtual IInterfaceTypeDescriptor`1<T> DependsOn(Type schemaType);
}
public interface HotChocolate.Types.ILeafType {
    [NullableContextAttribute("1")]
public abstract virtual bool IsInstanceOfType(IValueNode valueSyntax);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInstanceOfType(object runtimeValue);
    [NullableContextAttribute("1")]
public abstract virtual object ParseLiteral(IValueNode valueSyntax);
    [NullableContextAttribute("1")]
public abstract virtual IValueNode ParseValue(object runtimeValue);
    [NullableContextAttribute("1")]
public abstract virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public abstract virtual object Serialize(object runtimeValue);
    [NullableContextAttribute("2")]
public abstract virtual object Deserialize(object resultValue);
    [NullableContextAttribute("2")]
public abstract virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
public interface HotChocolate.Types.ILiteralParser {
    public abstract virtual object ParseLiteral(IValueNode literal);
}
public interface HotChocolate.Types.INamedDependencyDescriptor {
    public abstract virtual INamedDependencyDescriptor DependsOn();
    public abstract virtual INamedDependencyDescriptor DependsOn(bool mustBeNamed);
    public abstract virtual INamedDependencyDescriptor DependsOn(Type schemaType);
    public abstract virtual INamedDependencyDescriptor DependsOn(Type schemaType, bool mustBeNamed);
    public abstract virtual INamedDependencyDescriptor DependsOn(string typeName);
    public abstract virtual INamedDependencyDescriptor DependsOn(string typeName, bool mustBeNamed);
}
public interface HotChocolate.Types.INamedInputType {
}
public interface HotChocolate.Types.INamedOutputType {
}
public interface HotChocolate.Types.INamedType {
    [NullableContextAttribute("1")]
public abstract virtual bool IsAssignableFrom(INamedType type);
}
public interface HotChocolate.Types.INamedTypeExtension {
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public Type ExtendsType { get; }
    public abstract virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
public abstract virtual Type get_ExtendsType();
}
internal interface HotChocolate.Types.INamedTypeExtensionMerger {
    [NullableContextAttribute("1")]
public abstract virtual void Merge(ITypeCompletionContext context, INamedType type);
}
public class HotChocolate.Types.IncludeDirectiveType : DirectiveType {
    protected virtual void Configure(IDirectiveTypeDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.InputField : FieldBase`1<InputFieldDefinition> {
    [NullableAttribute("1")]
private Type _runtimeType;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IInputType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueNode <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputValueFormatter <Formatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public InputValueDefinitionNode SyntaxNode { get; }
    [NullableAttribute("1")]
public IInputType Type { get; private set; }
    [NullableAttribute("1")]
public InputObjectType DeclaringType { get; }
    [NullableAttribute("1")]
public Type RuntimeType { get; }
    public IValueNode DefaultValue { get; private set; }
    public IInputValueFormatter Formatter { get; }
    internal bool IsOptional { get; private set; }
    public bool IsDeprecated { get; }
    public string DeprecationReason { get; }
    public PropertyInfo Property { get; }
    [NullableContextAttribute("1")]
public InputField(InputFieldDefinition definition, int index);
    public InputValueDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IInputType get_Type();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Type(IInputType value);
    [NullableContextAttribute("1")]
public InputObjectType get_DeclaringType();
    [NullableContextAttribute("1")]
public virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public sealed virtual IValueNode get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(IValueNode value);
    [CompilerGeneratedAttribute]
public sealed virtual IInputValueFormatter get_Formatter();
    [CompilerGeneratedAttribute]
internal bool get_IsOptional();
    [CompilerGeneratedAttribute]
private void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationReason();
    [CompilerGeneratedAttribute]
public sealed virtual PropertyInfo get_Property();
    [NullableContextAttribute("1")]
protected virtual void OnCompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember, InputFieldDefinition definition);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public abstract class HotChocolate.Types.InputFieldDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IInputFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.InputFormatter : object {
    private ITypeConverter _converter;
    public InputFormatter(ITypeConverter converter);
    public IValueNode FormatValue(object runtimeValue, IType type, Path path);
    private IValueNode FormatValueInternal(object runtimeValue, IType type, Path path);
    private ObjectValueNode FormatValueObject(object runtimeValue, InputObjectType type, Path path);
    private ListValueNode FormatValueList(object runtimeValue, ListType type, Path path);
    private IValueNode FormatValueLeaf(object runtimeValue, ILeafType type, Path path);
    public DirectiveNode FormatDirective(object runtimeValue, DirectiveType type, Path path);
    public IValueNode FormatResult(object resultValue, IType type, Path path);
    private IValueNode FormatResultInternal(object resultValue, IType type, Path path);
    private ObjectValueNode FormatResultObject(object resultValue, InputObjectType type, Path path);
    private ListValueNode FormatResultList(object resultValue, ListType type, Path path);
    private static IValueNode FormatResultLeaf(object resultValue, ILeafType type, Path path);
    [CompilerGeneratedAttribute]
private void <FormatValueObject>g__AddField|5_0(object fieldValue, string fieldName, IInputType fieldType, Path fieldPath, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
private void <FormatDirective>g__AddField|8_0(object fieldValue, string fieldName, IInputType fieldType, Path fieldPath, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.InputObjectType : NamedTypeBase`1<InputObjectTypeDefinition> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InputObjectTypeDefinitionNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<InputField> <Fields>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInputObjectTypeDescriptor> _configure;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Object[], object> _createInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, Object[]> _getFieldValues;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public InputObjectTypeDefinitionNode SyntaxNode { get; private set; }
    public FieldCollection`1<InputField> Fields { get; private set; }
    private IFieldCollection`1<IInputField> HotChocolate.Types.IInputObjectType.Fields { get; }
    public InputObjectType(Action`1<IInputObjectTypeDescriptor> configure);
    public static InputObjectType CreateUnsafe(InputObjectTypeDefinition definition);
    public virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public InputObjectTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(InputObjectTypeDefinitionNode value);
    [CompilerGeneratedAttribute]
public FieldCollection`1<InputField> get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(FieldCollection`1<InputField> value);
    private sealed virtual override IFieldCollection`1<IInputField> HotChocolate.Types.IInputObjectType.get_Fields();
    internal object CreateInstance(Object[] fieldValues);
    internal void GetFieldValues(object runtimeValue, Object[] fieldValues);
    protected virtual void Configure(IInputObjectTypeDescriptor descriptor);
    protected virtual InputObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, InputObjectTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, InputObjectTypeDefinition definition);
    protected virtual FieldCollection`1<InputField> OnCompleteFields(ITypeCompletionContext context, InputObjectTypeDefinition definition);
    protected virtual Func`2<Object[], object> OnCompleteCreateInstance(ITypeCompletionContext context, InputObjectTypeDefinition definition);
    protected virtual Action`2<object, Object[]> OnCompleteGetFieldValues(ITypeCompletionContext context, InputObjectTypeDefinition definition);
    private object CreateDictionaryInstance(Object[] fieldValues);
    private void CreateDictionaryGetValues(object obj, Object[] fieldValues);
    [CompilerGeneratedAttribute]
internal static InputField <OnCompleteFields>g__CreateField|24_0(InputFieldDefinition fieldDef, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.InputObjectType`1 : InputObjectType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInputObjectTypeDescriptor`1<T>> _configure;
    public InputObjectType`1(Action`1<IInputObjectTypeDescriptor`1<T>> configure);
    protected virtual InputObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IInputObjectTypeDescriptor`1<T> descriptor);
    protected sealed virtual void Configure(IInputObjectTypeDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class HotChocolate.Types.InputObjectTypeAttribute : InputObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public InputObjectTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IInputObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public abstract class HotChocolate.Types.InputObjectTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IInputObjectTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.InputObjectTypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static IInputObjectTypeDescriptor`1<T> Ignore(IInputObjectTypeDescriptor`1<T> descriptor, Expression`1<Func`2<T, object>> property);
    [ExtensionAttribute]
public static IInputObjectTypeDescriptor OneOf(IInputObjectTypeDescriptor descriptor);
    [ExtensionAttribute]
public static IInputObjectTypeDescriptor`1<T> OneOf(IInputObjectTypeDescriptor`1<T> descriptor);
    [ExtensionAttribute]
public static IInputFieldDescriptor Type(IInputFieldDescriptor descriptor, string typeSyntax);
    [ExtensionAttribute]
public static IInputFieldDescriptor DefaultValueSyntax(IInputFieldDescriptor descriptor, string syntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.InputObjectTypeExtension : NamedTypeExtensionBase`1<InputObjectTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInputObjectTypeDescriptor> _configure;
    public TypeKind Kind { get; }
    public InputObjectTypeExtension(Action`1<IInputObjectTypeDescriptor> configure);
    public static InputObjectTypeExtension CreateUnsafe(InputObjectTypeDefinition definition);
    public virtual TypeKind get_Kind();
    protected virtual InputObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IInputObjectTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, InputObjectTypeDefinition definition);
    protected virtual void Merge(ITypeCompletionContext context, INamedType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.InputParser : object {
    private static Path _root;
    private ITypeConverter _converter;
    private DictionaryToObjectConverter _dictToObjConverter;
    private bool _ignoreAdditionalInputFields;
    public InputParser(ITypeConverter converter);
    public InputParser(ITypeConverter converter, InputParserOptions options);
    private static InputParser();
    public object ParseLiteral(IValueNode value, IInputFieldInfo field, Type targetType);
    public object ParseLiteral(IValueNode value, IType type, Path path);
    private object ParseLiteralInternal(IValueNode value, IType type, Path path, int stack, bool defaults, IInputFieldInfo field);
    private IList ParseList(IValueNode resultValue, ListType type, Path path, int stack, bool defaults, IInputFieldInfo field);
    private object ParseObject(IValueNode resultValue, InputObjectType type, Path path, int stack, bool defaults);
    private static object ParseLeaf(IValueNode resultValue, ILeafType type, Path path, IInputFieldInfo field);
    public object ParseDirective(DirectiveNode node, DirectiveType type, Path path);
    private object ParseDirective(DirectiveNode node, DirectiveType type, Path path, int stack, bool defaults);
    [NullableContextAttribute("2")]
public object ParseResult(object resultValue, IType type, Path path);
    [NullableContextAttribute("2")]
private object Deserialize(object resultValue, IType type, Path path, IInputField field);
    private object DeserializeList(object resultValue, ListType type, Path path, IInputField field);
    private object DeserializeObject(object resultValue, InputObjectType type, Path path);
    private object DeserializeLeaf(object resultValue, ILeafType type, Path path, IInputField field);
    private object CreateDefaultValue(InputField field, Path path, int stack);
    private object CreateDefaultValue(DirectiveArgument field, Path path, int stack);
    [NullableContextAttribute("2")]
private static object FormatValue(IInputFieldInfo field, object value);
    [NullableContextAttribute("2")]
private object ConvertValue(Type requestedType, object value);
    private static IList CreateList(ListType type);
}
public class HotChocolate.Types.InputParserOptions : object {
    [CompilerGeneratedAttribute]
private bool <IgnoreAdditionalInputFields>k__BackingField;
    public bool IgnoreAdditionalInputFields { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreAdditionalInputFields();
    [CompilerGeneratedAttribute]
public void set_IgnoreAdditionalInputFields(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.IntegerTypeBase`1 : ScalarType`2<TRuntimeType, IntValueNode> {
    [CompilerGeneratedAttribute]
private TRuntimeType <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private TRuntimeType <MaxValue>k__BackingField;
    public TRuntimeType MinValue { get; }
    public TRuntimeType MaxValue { get; }
    protected IntegerTypeBase`1(string name, TRuntimeType min, TRuntimeType max, BindingBehavior bind);
    [CompilerGeneratedAttribute]
public TRuntimeType get_MinValue();
    [CompilerGeneratedAttribute]
public TRuntimeType get_MaxValue();
    protected virtual bool IsInstanceOfType(IntValueNode valueSyntax);
    protected virtual bool IsInstanceOfType(TRuntimeType runtimeValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    public sealed virtual IValueNode ParseResult(object resultValue);
    protected virtual SerializationException CreateParseResultError(object runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Interceptors.EnableTrueNullabilityTypeInterceptor : TypeInterceptor {
    internal virtual bool IsEnabled(IDescriptorContext context);
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Interceptors.FlagsEnumInterceptor : TypeInterceptor {
    private static string _flagNameAddition;
    private Dictionary`2<Type, string> _outputTypeCache;
    private Dictionary`2<Type, RegisteredInputType> _inputTypeCache;
    private INamingConventions _namingConventions;
    private TypeInitializer _typeInitializer;
    internal virtual void InitializeContext(IDescriptorContext context, TypeInitializer typeInitializer, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeReferenceResolver typeReferenceResolver);
    public virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    private void ProcessOutputFields(IEnumerable`1<OutputFieldDefinitionBase> fields);
    private void ProcessArguments(IEnumerable`1<ArgumentDefinition> argumentDefinitions);
    private void ProcessInputFields(IEnumerable`1<InputFieldDefinition> fields);
    private void RegisterType(TypeSystemObjectBase type);
    private string CreateObjectType(Type type);
    private RegisteredInputType CreateInputObjectType(Type type);
    [NullableContextAttribute("2")]
private static bool IsFlagsEnum(TypeReference reference, Type& type);
    private static string GetFlagFieldName(Type type, object value);
    [NullableContextAttribute("2")]
private static TypeReference CreateTypeReference(TypeReference reference, string typeName);
    [CompilerGeneratedAttribute]
internal static string <CreateTypeReference>g__Rewrite|15_0(IExtendedType reference, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Interceptors.InterfaceCompletionTypeInterceptor : TypeInterceptor {
    private Dictionary`2<ITypeSystemObject, TypeInfo> _typeInfos;
    private Dictionary`2<Type, TypeInfo> _allInterfaceRuntimeTypes;
    private HashSet`1<Type> _interfaceRuntimeTypes;
    private HashSet`1<string> _completed;
    private HashSet`1<string> _completedFields;
    private Queue`1<InterfaceType> _backlog;
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual void OnTypesInitialized();
    private bool IsRelevant(TypeInfo typeInfo);
    private Type GetRuntimeType(TypeInfo typeInfo);
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    private void CompleteInterfacesAndFields(IComplexOutputTypeDefinition definition);
    private static void TryInferInterfaceFromRuntimeType(Type runtimeType, ICollection`1<Type> allInterfaces, ICollection`1<Type> interfaces);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Interceptors.MiddlewareValidationTypeInterceptor : TypeInterceptor {
    private static string _useDbContext;
    private static string _usePaging;
    private static string _useProjection;
    private static string _useFiltering;
    private static string _useSorting;
    private HashSet`1<string> _names;
    public virtual void OnValidateType(ITypeSystemObjectContext validationContext, DefinitionBase definition);
    private void ValidatePipeline(ITypeSystemObject type, FieldCoordinate field, ISyntaxNode syntaxNode, IList`1<FieldMiddlewareDefinition> middlewareDefinitions);
    private static string PrintPipeline(IList`1<FieldMiddlewareDefinition> middlewareDefinitions);
    [CompilerGeneratedAttribute]
internal static void <PrintPipeline>g__PrintNext|8_0(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static void <PrintPipeline>g__PrintOther|8_1(<>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Interceptors.ResolverTypeInterceptor : TypeInterceptor {
    private List`1<ITypeDefinition> _typeDefs;
    private List`1<FieldResolverConfig> _fieldResolvers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, Type>> _resolverTypeList;
    private Dictionary`2<string, Type> _runtimeTypes;
    private Dictionary`2<string, ParameterInfo> _parameters;
    private IDescriptorContext _context;
    private INamingConventions _naming;
    private ITypeInspector _typeInspector;
    private IResolverCompiler _resolverCompiler;
    private TypeReferenceResolver _typeReferenceResolver;
    private ILookup`2<string, Type> _resolverTypes;
    private ILookup`2<string, FieldResolverConfig> _configs;
    public ResolverTypeInterceptor(List`1<FieldResolverConfig> fieldResolvers, List`1<ValueTuple`2<string, Type>> resolverTypes, Dictionary`2<string, Type> runtimeTypes);
    internal virtual void InitializeContext(IDescriptorContext context, TypeInitializer typeInitializer, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeReferenceResolver typeReferenceResolver);
    public virtual void OnAfterInitialize(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    public virtual IEnumerable`1<TypeReference> RegisterMoreTypes(IReadOnlyCollection`1<ITypeDiscoveryContext> discoveryContexts);
    public virtual void OnAfterCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    public virtual void OnAfterCompleteTypeNames();
    private void ApplyResolver(CompletionContext context);
    private void ApplyResolverTypes(CompletionContext context, ObjectTypeDefinition objectTypeDef);
    private void ApplySourceMembers(CompletionContext context);
    private void ApplyObjectSourceMembers(CompletionContext context, ObjectTypeDefinition objectTypeDef);
    private void ApplyInputSourceMembers(CompletionContext context, InputObjectTypeDefinition inputTypeDef);
    private void ApplyEnumSourceMembers(CompletionContext context, EnumTypeDefinition enumTypeDef);
    private void CollectResolverMembers(CompletionContext context, string typeName);
    private void CollectSourceMembers(CompletionContext context, Type runtimeType);
    private void TrySetRuntimeType(CompletionContext context, ObjectFieldDefinition field, FieldResolverConfig config);
    private void TryBindArgumentRuntimeType(ObjectFieldDefinition field, MemberInfo member);
    private IReadOnlyCollection`1<ITypeDefinition> TrySetRuntimeTypeFromMember(CompletionContext context, TypeReference typeRef, MemberInfo member);
    private Type Unwrap(Type resultType, IType type);
    private Type Unwrap(IExtendedType extendedType, IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Interceptors.TypeValidationTypeInterceptor : TypeInterceptor {
    public virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext discoveryContext, DefinitionBase definition);
    private void ValidateInputObjectType(ITypeDiscoveryContext context, InputObjectTypeDefinition definition);
    private void ValidateDirectiveType(ITypeDiscoveryContext context, DirectiveTypeDefinition definition);
    private void ValidateUnionType(ITypeDiscoveryContext context, UnionTypeDefinition definition);
    private void ValidateObjectType(ITypeDiscoveryContext context, ObjectTypeDefinition definition);
    private void ValidateInterfaceType(ITypeDiscoveryContext context, InterfaceTypeDefinition definition);
    private bool IsTypeSystemType(Type type);
    private void ReportRuntimeTypeError(ITypeDiscoveryContext discoveryContext, Type runtimeType);
}
public class HotChocolate.Types.InterfaceField : OutputFieldBase`1<InterfaceFieldDefinition> {
    public InterfaceType DeclaringType { get; }
    public InterfaceField(InterfaceFieldDefinition definition, int index);
    public InterfaceType get_DeclaringType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public abstract class HotChocolate.Types.InterfaceFieldDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IInterfaceFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.InterfaceType : NamedTypeBase`1<InterfaceTypeDefinition> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InterfaceTypeDefinitionNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<InterfaceField> <Fields>k__BackingField;
    private InterfaceType[] _implements;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInterfaceTypeDescriptor> _configure;
    [NullableAttribute("2")]
private ResolveAbstractType _resolveAbstractType;
    private ISchema _schema;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public InterfaceTypeDefinitionNode SyntaxNode { get; private set; }
    [NullableAttribute("2")]
private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    public IReadOnlyList`1<InterfaceType> Implements { get; }
    private IReadOnlyList`1<IInterfaceType> HotChocolate.Types.IComplexOutputType.Implements { get; }
    public FieldCollection`1<InterfaceField> Fields { get; private set; }
    private IFieldCollection`1<IOutputField> HotChocolate.Types.IComplexOutputType.Fields { get; }
    public InterfaceType(Action`1<IInterfaceTypeDescriptor> configure);
    public static InterfaceType CreateUnsafe(InterfaceTypeDefinition definition);
    public virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual InterfaceTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(InterfaceTypeDefinitionNode value);
    [NullableContextAttribute("2")]
private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    public IReadOnlyList`1<InterfaceType> get_Implements();
    private sealed virtual override IReadOnlyList`1<IInterfaceType> HotChocolate.Types.IComplexOutputType.get_Implements();
    [CompilerGeneratedAttribute]
public FieldCollection`1<InterfaceField> get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(FieldCollection`1<InterfaceField> value);
    private sealed virtual override IFieldCollection`1<IOutputField> HotChocolate.Types.IComplexOutputType.get_Fields();
    public sealed virtual bool IsImplementing(string typeName);
    public bool IsImplementing(InterfaceType interfaceType);
    public sealed virtual bool IsImplementing(IInterfaceType interfaceType);
    public virtual bool IsAssignableFrom(INamedType namedType);
    public ObjectType ResolveConcreteType(IResolverContext context, object resolverResult);
    private sealed virtual override IObjectType HotChocolate.Types.IInterfaceType.ResolveConcreteType(IResolverContext context, object resolverResult);
    protected virtual void Configure(IInterfaceTypeDescriptor descriptor);
    protected virtual InterfaceTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, InterfaceTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, InterfaceTypeDefinition definition);
    protected virtual FieldCollection`1<InterfaceField> OnCompleteFields(ITypeCompletionContext context, InterfaceTypeDefinition definition);
    [NullableContextAttribute("2")]
private void CompleteAbstractTypeResolver(ResolveAbstractType resolveAbstractType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnCompleteType>b__34_0(object _, SchemaCompletedEventArgs args);
    [CompilerGeneratedAttribute]
internal static InterfaceField <OnCompleteFields>g__CreateField|35_0(InterfaceFieldDefinition fieldDef, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.InterfaceType`1 : InterfaceType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInterfaceTypeDescriptor`1<T>> _configure;
    public InterfaceType`1(Action`1<IInterfaceTypeDescriptor`1<T>> configure);
    protected virtual InterfaceTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IInterfaceTypeDescriptor`1<T> descriptor);
    protected sealed virtual void Configure(IInterfaceTypeDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class HotChocolate.Types.InterfaceTypeAttribute : InterfaceTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public InterfaceTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IInterfaceTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public abstract class HotChocolate.Types.InterfaceTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IInterfaceTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.InterfaceTypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static IInterfaceTypeDescriptor`1<T> Ignore(IInterfaceTypeDescriptor`1<T> descriptor, Expression`1<Func`2<T, object>> propertyOrMethod);
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor Type(IInterfaceFieldDescriptor descriptor, string typeSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.InterfaceTypeExtension : NamedTypeExtensionBase`1<InterfaceTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IInterfaceTypeDescriptor> _configure;
    public TypeKind Kind { get; }
    public InterfaceTypeExtension(Action`1<IInterfaceTypeDescriptor> configure);
    public static InterfaceTypeExtension CreateUnsafe(InterfaceTypeDefinition definition);
    public virtual TypeKind get_Kind();
    protected virtual InterfaceTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IInterfaceTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, InterfaceTypeDefinition definition);
    protected virtual void Merge(ITypeCompletionContext context, INamedType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__AppliedDirective : ObjectType`1<DirectiveNode> {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__Directive : ObjectType`1<DirectiveType> {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__DirectiveArgument : ObjectType`1<ArgumentNode> {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__DirectiveLocation : EnumType`1<DirectiveLocation> {
    [NullableContextAttribute("1")]
protected virtual EnumTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__EnumValue : ObjectType`1<IEnumValue> {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__Field : ObjectType`1<IOutputField> {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__InputValue : ObjectType {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__Schema : ObjectType {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__Type : ObjectType {
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IntrospectionAttribute]
internal class HotChocolate.Types.Introspection.__TypeKind : EnumType {
    protected virtual EnumTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Types.Introspection.IntrospectionFields : object {
    private static PureFieldDelegate _typeNameResolver;
    public static string TypeName { get; }
    public static string Schema { get; }
    public static string Type { get; }
    private static IntrospectionFields();
    public static string get_TypeName();
    public static string get_Schema();
    public static string get_Type();
    internal static ObjectFieldDefinition CreateSchemaField(IDescriptorContext context);
    internal static ObjectFieldDefinition CreateTypeField(IDescriptorContext context);
    internal static ObjectFieldDefinition CreateTypeNameField(IDescriptorContext context);
    private static ObjectFieldDefinition CreateDefinition(ObjectFieldDescriptor descriptor);
    [CompilerGeneratedAttribute]
internal static ISchema <CreateSchemaField>g__Resolve|7_0(IPureResolverContext ctx);
    [CompilerGeneratedAttribute]
internal static INamedType <CreateTypeField>g__Resolve|8_1(IPureResolverContext ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Introspection.IntrospectionTypeInterceptor : TypeInterceptor {
    private List`1<ObjectTypeDefinition> _objectTypeDefinitions;
    private IDescriptorContext _context;
    [NullableAttribute("2")]
private ObjectTypeDefinition _queryTypeDefinition;
    internal UInt32 Position { get; }
    internal virtual UInt32 get_Position();
    internal virtual void InitializeContext(IDescriptorContext context, TypeInitializer typeInitializer, TypeRegistry typeRegistry, TypeLookup typeLookup, TypeReferenceResolver typeReferenceResolver);
    public virtual void OnAfterCompleteName(ITypeCompletionContext completionContext, DefinitionBase definition);
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnBeforeCompleteTypes();
}
public static class HotChocolate.Types.Introspection.IntrospectionTypes : object {
    private static HashSet`1<string> _typeNames;
    private static IntrospectionTypes();
    internal static IReadOnlyList`1<TypeReference> CreateReferences(IDescriptorContext context);
    public static bool IsIntrospectionType(string typeName);
    public static bool IsIntrospectionType(INamedType type);
}
[AttributeUsageAttribute("4")]
internal class HotChocolate.Types.IntrospectionAttribute : Attribute {
}
[ExtensionAttribute]
internal static class HotChocolate.Types.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static bool IsIntrospectionType(IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SpecScalarAttribute]
public class HotChocolate.Types.IntType : IntegerTypeBase`1<int> {
    public IntType(int min, int max);
    public IntType(string name, string description, int min, int max, BindingBehavior bind);
    protected virtual int ParseLiteral(IntValueNode valueSyntax);
    protected virtual IntValueNode ParseValue(int runtimeValue);
}
public interface HotChocolate.Types.IObjectField {
    [NullableAttribute("1")]
public IObjectType DeclaringType { get; }
    public bool IsParallelExecutable { get; }
    public bool HasStreamResult { get; }
    [NullableAttribute("1")]
public FieldDelegate Middleware { get; }
    [NullableAttribute("2")]
public FieldResolverDelegate Resolver { get; }
    [NullableAttribute("2")]
public PureFieldDelegate PureResolver { get; }
    [NullableAttribute("2")]
public SubscribeResolverDelegate SubscribeResolver { get; }
    [NullableAttribute("2")]
public MemberInfo Member { get; }
    [NullableAttribute("2")]
public MemberInfo ResolverMember { get; }
    [NullableContextAttribute("1")]
public abstract virtual IObjectType get_DeclaringType();
    public abstract virtual bool get_IsParallelExecutable();
    public abstract virtual bool get_HasStreamResult();
    [NullableContextAttribute("1")]
public abstract virtual FieldDelegate get_Middleware();
    [NullableContextAttribute("2")]
public abstract virtual FieldResolverDelegate get_Resolver();
    [NullableContextAttribute("2")]
public abstract virtual PureFieldDelegate get_PureResolver();
    [NullableContextAttribute("2")]
public abstract virtual SubscribeResolverDelegate get_SubscribeResolver();
    [NullableContextAttribute("2")]
public abstract virtual MemberInfo get_Member();
    [NullableContextAttribute("2")]
public abstract virtual MemberInfo get_ResolverMember();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IObjectFieldDescriptor {
    public abstract virtual IObjectFieldDescriptor SyntaxNode(FieldDefinitionNode fieldDefinition);
    public abstract virtual IObjectFieldDescriptor Name(string value);
    public abstract virtual IObjectFieldDescriptor Description(string value);
    [ObsoleteAttribute("Use `Deprecated`.")]
public abstract virtual IObjectFieldDescriptor DeprecationReason(string reason);
    public abstract virtual IObjectFieldDescriptor Deprecated(string reason);
    public abstract virtual IObjectFieldDescriptor Deprecated();
    public abstract virtual IObjectFieldDescriptor Type();
    public abstract virtual IObjectFieldDescriptor Type(TOutputType outputType);
    public abstract virtual IObjectFieldDescriptor Type(ITypeNode typeNode);
    public abstract virtual IObjectFieldDescriptor Type(Type type);
    public abstract virtual IObjectFieldDescriptor StreamResult(bool hasStreamResult);
    public abstract virtual IObjectFieldDescriptor Argument(string argumentName, Action`1<IArgumentDescriptor> argumentDescriptor);
    public abstract virtual IObjectFieldDescriptor Ignore(bool ignore);
    [ObsoleteAttribute("Use Resolve(...)")]
public abstract virtual IObjectFieldDescriptor Resolver(FieldResolverDelegate fieldResolver);
    [ObsoleteAttribute("Use Resolve(...)")]
public abstract virtual IObjectFieldDescriptor Resolver(FieldResolverDelegate fieldResolver, Type resultType);
    public abstract virtual IObjectFieldDescriptor Resolve(FieldResolverDelegate fieldResolver);
    public abstract virtual IObjectFieldDescriptor Resolve(FieldResolverDelegate fieldResolver, Type resultType);
    public abstract virtual IObjectFieldDescriptor ResolveWith(Expression`1<Func`2<TResolver, object>> propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor ResolveWith(MemberInfo propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor Subscribe(SubscribeResolverDelegate subscribeResolver);
    public abstract virtual IObjectFieldDescriptor Use(FieldMiddleware middleware);
    public abstract virtual IObjectFieldDescriptor Directive(T directiveInstance);
    public abstract virtual IObjectFieldDescriptor Directive();
    public abstract virtual IObjectFieldDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IObjectType {
    [NullableAttribute("2")]
public ObjectTypeDefinitionNode SyntaxNode { get; }
    [NullableAttribute("1")]
public IFieldCollection`1<IObjectField> Fields { get; }
    [NullableContextAttribute("2")]
public abstract virtual ObjectTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
public abstract virtual IFieldCollection`1<IObjectField> get_Fields();
    [NullableContextAttribute("1")]
public abstract virtual bool IsInstanceOfType(IResolverContext context, object resolverResult);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IObjectTypeDescriptor {
    public abstract virtual IObjectTypeDescriptor SyntaxNode(ObjectTypeDefinitionNode objectTypeDefinition);
    public abstract virtual IObjectTypeDescriptor Name(string value);
    public abstract virtual IObjectTypeDescriptor Description(string value);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor Interface();
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor Interface(T type);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor Interface(NamedTypeNode type);
    public abstract virtual IObjectTypeDescriptor Implements();
    public abstract virtual IObjectTypeDescriptor Implements(T type);
    public abstract virtual IObjectTypeDescriptor Implements(NamedTypeNode type);
    public abstract virtual IObjectTypeDescriptor IsOfType(IsOfType isOfType);
    public abstract virtual IObjectFieldDescriptor Field(string name);
    public abstract virtual IObjectFieldDescriptor Field(Expression`1<Func`2<TResolver, object>> propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor Field(MemberInfo propertyOrMethod);
    public abstract virtual IObjectTypeDescriptor Directive(T directiveInstance);
    public abstract virtual IObjectTypeDescriptor Directive();
    public abstract virtual IObjectTypeDescriptor Directive(string name, ArgumentNode[] arguments);
    public abstract virtual IObjectTypeDescriptor ExtendsType(Type extendsType);
    public abstract virtual IObjectTypeDescriptor ExtendsType();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.IObjectTypeDescriptor`1 {
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Name(string value);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Description(string value);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> BindFields(BindingBehavior behavior);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> BindFields(FieldBindingFlags bindingFlags);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> BindFieldsExplicitly();
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> BindFieldsImplicitly();
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Interface();
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Interface(TInterface type);
    [ObsoleteAttribute("Use Implements.")]
public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Interface(NamedTypeNode type);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Implements();
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Implements(TInterface type);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Implements(NamedTypeNode type);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> IsOfType(IsOfType isOfType);
    public abstract virtual IObjectFieldDescriptor Field(Expression`1<Func`2<TRuntimeType, object>> propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor Field(Expression`1<Func`2<TRuntimeType, TValue>> propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor Field(string name);
    public abstract virtual IObjectFieldDescriptor Field(Expression`1<Func`2<TResolver, object>> propertyOrMethod);
    public abstract virtual IObjectFieldDescriptor Field(MemberInfo propertyOrMethod);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Directive(TDirective directiveInstance);
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Directive();
    public abstract virtual IObjectTypeDescriptor`1<TRuntimeType> Directive(string name, ArgumentNode[] arguments);
    public abstract virtual IObjectTypeDescriptor ExtendsType(Type extendsType);
    public abstract virtual IObjectTypeDescriptor ExtendsType();
}
public interface HotChocolate.Types.IObjectTypeNameDependencyDescriptor {
    public abstract virtual IObjectTypeDescriptor DependsOn();
    public abstract virtual IObjectTypeDescriptor DependsOn(Type schemaType);
}
public interface HotChocolate.Types.IObjectTypeNameDependencyDescriptor`1 {
    public abstract virtual IObjectTypeDescriptor`1<T> DependsOn();
    public abstract virtual IObjectTypeDescriptor`1<T> DependsOn(Type schemaType);
}
public interface HotChocolate.Types.IOutputField {
    public bool IsIntrospectionField { get; }
    public bool IsDeprecated { get; }
    [NullableAttribute("2")]
public string DeprecationReason { get; }
    [NullableAttribute("1")]
public IComplexOutputType DeclaringType { get; }
    public abstract virtual bool get_IsIntrospectionField();
    public abstract virtual bool get_IsDeprecated();
    [NullableContextAttribute("2")]
public abstract virtual string get_DeprecationReason();
    [NullableContextAttribute("1")]
public abstract virtual IComplexOutputType get_DeclaringType();
}
public interface HotChocolate.Types.IOutputFieldInfo {
    public IOutputType Type { get; }
    public IFieldCollection`1<IInputField> Arguments { get; }
    public abstract virtual IOutputType get_Type();
    public abstract virtual IFieldCollection`1<IInputField> get_Arguments();
}
public interface HotChocolate.Types.ISchemaDirective {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void ApplyConfiguration(IDescriptorContext context, DirectiveNode directiveNode, IDefinition definition, Stack`1<IDefinition> path);
}
public interface HotChocolate.Types.ISchemaTypeDescriptor {
    public abstract virtual ISchemaTypeDescriptor Name(string value);
    public abstract virtual ISchemaTypeDescriptor Description(string value);
    public abstract virtual ISchemaTypeDescriptor Directive(T directiveInstance);
    public abstract virtual ISchemaTypeDescriptor Directive();
    public abstract virtual ISchemaTypeDescriptor Directive(string name, ArgumentNode[] arguments);
}
internal class HotChocolate.Types.Iso8601Duration : ValueType {
    internal static bool TryToTimeSpan(int years, int months, int weeks, int days, int hours, int minutes, int seconds, UInt32 nanoseconds, bool isNegative, Nullable`1& result);
    internal static bool TryParse(string s, Nullable`1& result);
    private static bool TryParseDigits(string s, Int32& offset, bool eatDigits, Int32& result, Int32& numDigits);
}
public class HotChocolate.Types.IsOfType : MulticastDelegate {
    public IsOfType(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(IResolverContext context, object resolverResult);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, object resolverResult, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class HotChocolate.Types.IsOfTypeFallback : MulticastDelegate {
    public IsOfTypeFallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(ObjectType objectType, IResolverContext context, object resolverResult);
    public virtual IAsyncResult BeginInvoke(ObjectType objectType, IResolverContext context, object resolverResult, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public interface HotChocolate.Types.ITypeSystemObject {
}
public interface HotChocolate.Types.IUnionType {
    [NullableAttribute("2")]
public UnionTypeDefinitionNode SyntaxNode { get; }
    [NullableAttribute("1")]
public IReadOnlyCollection`1<IObjectType> Types { get; }
    [NullableContextAttribute("2")]
public abstract virtual UnionTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyCollection`1<IObjectType> get_Types();
    [NullableContextAttribute("1")]
public abstract virtual IObjectType ResolveConcreteType(IResolverContext context, object resolverResult);
    [NullableContextAttribute("1")]
public abstract virtual bool ContainsType(IObjectType objectType);
    [NullableContextAttribute("1")]
public abstract virtual bool ContainsType(string typeName);
}
public interface HotChocolate.Types.IUnionTypeDescriptor {
    public abstract virtual IUnionTypeDescriptor SyntaxNode(UnionTypeDefinitionNode unionTypeDefinition);
    public abstract virtual IUnionTypeDescriptor Name(string value);
    public abstract virtual IUnionTypeDescriptor Description(string value);
    public abstract virtual IUnionTypeDescriptor Type();
    public abstract virtual IUnionTypeDescriptor Type(TObjectType objectType);
    public abstract virtual IUnionTypeDescriptor Type(NamedTypeNode objectType);
    public abstract virtual IUnionTypeDescriptor ResolveAbstractType(ResolveAbstractType resolveAbstractType);
    public abstract virtual IUnionTypeDescriptor Directive(T directiveInstance);
    public abstract virtual IUnionTypeDescriptor Directive();
    public abstract virtual IUnionTypeDescriptor Directive(string name, ArgumentNode[] arguments);
}
public interface HotChocolate.Types.IUnionTypeNameDependencyDescriptor {
    public abstract virtual IUnionTypeDescriptor DependsOn();
    public abstract virtual IUnionTypeDescriptor DependsOn(Type schemaType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.JsonType : ScalarType`1<JsonElement> {
    public JsonType(string name, BindingBehavior bind);
    public virtual bool IsInstanceOfType(IValueNode valueSyntax);
    public virtual object ParseLiteral(IValueNode valueSyntax);
    public virtual IValueNode ParseValue(object runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    private SerializationException CreateParseValueError(object runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.ListType : NonNamedType {
    public TypeKind Kind { get; }
    public IType ElementType { get; }
    public ListType(IType elementType);
    public virtual TypeKind get_Kind();
    public IType get_ElementType();
}
public class HotChocolate.Types.ListType`1 : FluentWrapperType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.LongType : IntegerTypeBase`1<long> {
    public LongType(long min, long max);
    public LongType(string name, string description, long min, long max, BindingBehavior bind);
    protected virtual long ParseLiteral(IntValueNode valueSyntax);
    protected virtual IntValueNode ParseValue(long runtimeValue);
}
public enum HotChocolate.Types.MemberKind : Enum {
    public int value__;
    public static MemberKind Field;
    public static MemberKind InterfaceField;
    public static MemberKind ObjectField;
    public static MemberKind InputObjectField;
    public static MemberKind Argument;
    public static MemberKind DirectiveArgument;
}
[ExtensionAttribute]
public static class HotChocolate.Types.MiddlewareObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor Use(IObjectFieldDescriptor descriptor);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Use(IObjectFieldDescriptor descriptor, Func`3<IServiceProvider, FieldDelegate, TMiddleware> factory);
}
[TypeConverterAttribute("HotChocolate.Types.MultiplierPathStringConverter")]
public class HotChocolate.Types.MultiplierPathString : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public bool HasValue { get; }
    public bool IsEmpty { get; }
    public MultiplierPathString(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    public bool get_HasValue();
    public bool get_IsEmpty();
    public virtual string ToString();
    public MultiplierPathString Add(MultiplierPathString other);
    public bool Equals(MultiplierPathString other, StringComparison comparisonType);
    public sealed virtual bool Equals(MultiplierPathString other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MultiplierPathString left, MultiplierPathString right);
    public static bool op_Inequality(MultiplierPathString left, MultiplierPathString right);
    public static string op_Addition(string left, MultiplierPathString right);
    public static string op_Addition(MultiplierPathString left, string right);
    public static MultiplierPathString op_Addition(MultiplierPathString left, MultiplierPathString right);
    public static MultiplierPathString op_Implicit(string s);
    public static string op_Implicit(MultiplierPathString name);
    internal static MultiplierPathString ConvertFromString(string s);
    public static bool IsValidPath(string name);
    public static bool IsValidPath(ReadOnlySpan`1<byte> name);
}
internal class HotChocolate.Types.MultiplierPathStringConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ExtensionAttribute]
public static class HotChocolate.Types.MultiplierPathStringExtensions : object {
    [ExtensionAttribute]
public static MultiplierPathString EnsureNotEmpty(MultiplierPathString name, string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.MultiplierPathType : ScalarType`2<MultiplierPathString, StringValueNode> {
    public MultiplierPathType(string name, string description, BindingBehavior bind);
    protected virtual bool IsInstanceOfType(StringValueNode valueSyntax);
    protected virtual MultiplierPathString ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(MultiplierPathString runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
public class HotChocolate.Types.MutationTypeAttribute : ObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStaticMembers>k__BackingField;
    public bool Inherited { get; public set; }
    public bool IncludeStaticMembers { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStaticMembers();
    [CompilerGeneratedAttribute]
public void set_IncludeStaticMembers(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.NamedTypeBase`1 : TypeSystemObjectBase`1<TDefinition> {
    [NullableAttribute("2")]
private IDirectiveCollection _directives;
    [NullableAttribute("2")]
private Type _runtimeType;
    [NullableAttribute("2")]
private ISyntaxNode _syntaxNode;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <TypeIdentity>k__BackingField;
    [NullableAttribute("2")]
private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    [NullableAttribute("2")]
private ITypeDefinition HotChocolate.Types.IHasTypeDefinition.Definition { get; }
    public TypeKind Kind { get; }
    public IDirectiveCollection Directives { get; internal set; }
    public Type RuntimeType { get; }
    [NullableAttribute("2")]
public Type TypeIdentity { get; private set; }
    [NullableContextAttribute("2")]
private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    [NullableContextAttribute("2")]
private sealed virtual override ITypeDefinition HotChocolate.Types.IHasTypeDefinition.get_Definition();
    public abstract virtual TypeKind get_Kind();
    public sealed virtual IDirectiveCollection get_Directives();
    internal void set_Directives(IDirectiveCollection value);
    public sealed virtual Type get_RuntimeType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Type get_TypeIdentity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_TypeIdentity(Type value);
    public virtual bool IsAssignableFrom(INamedType type);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, TDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, TDefinition definition);
    protected void SetTypeIdentity(Type typeDefinitionOrIdentity);
    private void UpdateRuntimeType(ITypeDefinition definition);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.NamedTypeExtensionBase`1 : TypeSystemObjectBase`1<TDefinition> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <ExtendsType>k__BackingField;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public Type ExtendsType { get; private set; }
    public abstract virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Type get_ExtendsType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ExtendsType(Type value);
    [NullableContextAttribute("1")]
protected abstract virtual void Merge(ITypeCompletionContext context, INamedType type);
    [NullableContextAttribute("1")]
private sealed virtual override void HotChocolate.Types.INamedTypeExtensionMerger.Merge(ITypeCompletionContext context, INamedType type);
    [NullableContextAttribute("1")]
protected virtual void OnAfterCompleteName(ITypeCompletionContext context, DefinitionBase definition);
}
internal class HotChocolate.Types.NativeType`1 : FluentWrapperType {
}
[ExtensionAttribute]
public static class HotChocolate.Types.NodeObjectTypeExtensions : object {
    [ExtensionAttribute]
public static INodeDescriptor ImplementsNode(IObjectTypeDescriptor descriptor);
    [ExtensionAttribute]
public static INodeDescriptor`1<T> ImplementsNode(IObjectTypeDescriptor`1<T> descriptor);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ImplementsNode.")]
public static INodeDescriptor AsNode(IObjectTypeDescriptor descriptor);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ImplementsNode.")]
public static INodeDescriptor`1<T> AsNode(IObjectTypeDescriptor`1<T> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.NonNamedType : object {
    [NullableAttribute("2")]
private Type _innerClrType;
    [NullableAttribute("2")]
private Type _clrType;
    [CompilerGeneratedAttribute]
private IType <InnerType>k__BackingField;
    public TypeKind Kind { get; }
    protected IType InnerType { get; }
    protected Type InnerClrType { get; }
    public Type RuntimeType { get; }
    protected NonNamedType(IType innerType);
    public abstract virtual TypeKind get_Kind();
    [CompilerGeneratedAttribute]
protected IType get_InnerType();
    protected Type get_InnerClrType();
    public sealed virtual Type get_RuntimeType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.NonNullType : NonNamedType {
    public TypeKind Kind { get; }
    public IType Type { get; }
    public NonNullType(IType type);
    public virtual TypeKind get_Kind();
    public IType get_Type();
}
public class HotChocolate.Types.NonNullType`1 : FluentWrapperType {
}
[DirectiveTypeAttribute("nullBubbling", "7")]
public class HotChocolate.Types.NullBubblingDirective : object {
    [CompilerGeneratedAttribute]
private bool <Enable>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[GraphQLNameAttribute("enable")]
public bool Enable { get; }
    public NullBubblingDirective(bool enable);
    [CompilerGeneratedAttribute]
public bool get_Enable();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.ObjectField : OutputFieldBase`1<ObjectFieldDefinition> {
    [NullableAttribute("1")]
private static FieldDelegate _empty;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private FieldDelegate <Middleware>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldResolverDelegate <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private PureFieldDelegate <PureResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscribeResolverDelegate <SubscribeResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <ResolverMember>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <ResolverExpression>k__BackingField;
    [NullableAttribute("1")]
public ObjectType DeclaringType { get; }
    [NullableAttribute("1")]
private IObjectType HotChocolate.Types.IObjectField.DeclaringType { get; }
    public bool IsParallelExecutable { get; private set; }
    public bool HasStreamResult { get; }
    [NullableAttribute("1")]
public FieldDelegate Middleware { get; private set; }
    public FieldResolverDelegate Resolver { get; private set; }
    public PureFieldDelegate PureResolver { get; private set; }
    public SubscribeResolverDelegate SubscribeResolver { get; }
    public MemberInfo Member { get; }
    public MemberInfo ResolverMember { get; }
    [ObsoleteAttribute("Use resolver expression.")]
public Expression Expression { get; }
    public Expression ResolverExpression { get; }
    [NullableContextAttribute("1")]
internal ObjectField(ObjectFieldDefinition definition, int index);
    private static ObjectField();
    [NullableContextAttribute("1")]
public ObjectType get_DeclaringType();
    [NullableContextAttribute("1")]
private sealed virtual override IObjectType HotChocolate.Types.IObjectField.get_DeclaringType();
    public sealed virtual bool get_IsParallelExecutable();
    private void set_IsParallelExecutable(bool value);
    public sealed virtual bool get_HasStreamResult();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual FieldDelegate get_Middleware();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Middleware(FieldDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual FieldResolverDelegate get_Resolver();
    [CompilerGeneratedAttribute]
private void set_Resolver(FieldResolverDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual PureFieldDelegate get_PureResolver();
    [CompilerGeneratedAttribute]
private void set_PureResolver(PureFieldDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual SubscribeResolverDelegate get_SubscribeResolver();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_ResolverMember();
    public Expression get_Expression();
    [CompilerGeneratedAttribute]
public Expression get_ResolverExpression();
    [NullableContextAttribute("1")]
protected virtual void OnCompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember, ObjectFieldDefinition definition);
    [NullableContextAttribute("1")]
private void CompleteResolver(ITypeCompletionContext context, ObjectFieldDefinition definition);
    [NullableContextAttribute("1")]
private static FieldResolverDelegates CompileResolver(ITypeCompletionContext context, ObjectFieldDefinition definition);
    [CompilerGeneratedAttribute]
internal static bool <CompleteResolver>g__IsPureContext|38_0(<>c__DisplayClass38_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <CompileResolver>g__BuildArgumentLookup|39_0(ObjectFieldDefinition definition, Dictionary`2<ParameterInfo, string> argumentNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public abstract class HotChocolate.Types.ObjectFieldDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
[ExtensionAttribute]
public static class HotChocolate.Types.ObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor Serial(IObjectFieldDescriptor descriptor);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Parallel(IObjectFieldDescriptor descriptor);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Type(IObjectFieldDescriptor descriptor, string typeSyntax);
    [ExtensionAttribute]
public static IArgumentDescriptor Type(IArgumentDescriptor descriptor, string typeSyntax);
    [ExtensionAttribute]
public static IObjectFieldDescriptor UseServiceScope(IObjectFieldDescriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.ObjectType : NamedTypeBase`1<ObjectTypeDefinition> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ObjectTypeDefinitionNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<ObjectField> <Fields>k__BackingField;
    private InterfaceType[] _implements;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IObjectTypeDescriptor> _configure;
    [NullableAttribute("2")]
private IsOfType _isOfType;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public ObjectTypeDefinitionNode SyntaxNode { get; private set; }
    [NullableAttribute("2")]
private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    public IReadOnlyList`1<InterfaceType> Implements { get; }
    private IReadOnlyList`1<IInterfaceType> HotChocolate.Types.IComplexOutputType.Implements { get; }
    public FieldCollection`1<ObjectField> Fields { get; private set; }
    private IFieldCollection`1<IObjectField> HotChocolate.Types.IObjectType.Fields { get; }
    private IFieldCollection`1<IOutputField> HotChocolate.Types.IComplexOutputType.Fields { get; }
    public ObjectType(Action`1<IObjectTypeDescriptor> configure);
    public static ObjectType CreateUnsafe(ObjectTypeDefinition definition);
    public virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ObjectTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(ObjectTypeDefinitionNode value);
    [NullableContextAttribute("2")]
private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    public IReadOnlyList`1<InterfaceType> get_Implements();
    private sealed virtual override IReadOnlyList`1<IInterfaceType> HotChocolate.Types.IComplexOutputType.get_Implements();
    [CompilerGeneratedAttribute]
public FieldCollection`1<ObjectField> get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(FieldCollection`1<ObjectField> value);
    private sealed virtual override IFieldCollection`1<IObjectField> HotChocolate.Types.IObjectType.get_Fields();
    private sealed virtual override IFieldCollection`1<IOutputField> HotChocolate.Types.IComplexOutputType.get_Fields();
    public virtual bool IsInstanceOfType(IResolverContext context, object resolverResult);
    [ObsoleteAttribute("Use IsInstanceOfType")]
public bool IsOfType(IResolverContext context, object resolverResult);
    public sealed virtual bool IsImplementing(string interfaceTypeName);
    public bool IsImplementing(InterfaceType interfaceType);
    public sealed virtual bool IsImplementing(IInterfaceType interfaceType);
    protected virtual void Configure(IObjectTypeDescriptor descriptor);
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, ObjectTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, ObjectTypeDefinition definition);
    protected virtual FieldCollection`1<ObjectField> OnCompleteFields(ITypeCompletionContext context, ObjectTypeDefinition definition);
    private void CompleteTypeResolver(ITypeCompletionContext context);
    private bool ValidateFields(ITypeCompletionContext context, ObjectTypeDefinition definition);
    private bool IsOfTypeWithRuntimeType(IResolverContext context, object result);
    private bool IsOfTypeWithName(IResolverContext context, object result);
    [CompilerGeneratedAttribute]
internal static ObjectField <OnCompleteFields>g__CreateField|35_0(ObjectFieldDefinition fieldDef, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.ObjectType`1 : ObjectType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IObjectTypeDescriptor`1<T>> _configure;
    public ObjectType`1(Action`1<IObjectTypeDescriptor`1<T>> configure);
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IObjectTypeDescriptor`1<T> descriptor);
    protected sealed virtual void Configure(IObjectTypeDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class HotChocolate.Types.ObjectTypeAttribute : ObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStaticMembers>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    public bool IncludeStaticMembers { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public ObjectTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStaticMembers();
    [CompilerGeneratedAttribute]
public void set_IncludeStaticMembers(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public abstract class HotChocolate.Types.ObjectTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.ObjectTypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectTypeDescriptor`1<T> Ignore(IObjectTypeDescriptor`1<T> descriptor, Expression`1<Func`2<T, object>> propertyOrMethod);
    [ExtensionAttribute]
public static IObjectTypeDescriptor Implements(IObjectTypeDescriptor descriptor, string typeName);
    [ExtensionAttribute]
public static IObjectTypeDescriptor`1<T> Implements(IObjectTypeDescriptor`1<T> descriptor, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.ObjectTypeExtension : NamedTypeExtensionBase`1<ObjectTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IObjectTypeDescriptor> _configure;
    public TypeKind Kind { get; }
    public ObjectTypeExtension(Action`1<IObjectTypeDescriptor> configure);
    public static ObjectTypeExtension CreateUnsafe(ObjectTypeDefinition definition);
    public virtual TypeKind get_Kind();
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IObjectTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, ObjectTypeDefinition definition);
    protected virtual void Merge(ITypeCompletionContext context, INamedType type);
    private void ApplyGlobalFieldIgnores(ObjectTypeDefinition extensionDef, ObjectTypeDefinition typeDef);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.ObjectTypeExtension`1 : ObjectTypeExtension {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IObjectTypeDescriptor`1<T>> _configure;
    public ObjectTypeExtension`1(Action`1<IObjectTypeDescriptor`1<T>> configure);
    protected virtual ObjectTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IObjectTypeDescriptor`1<T> descriptor);
    protected sealed virtual void Configure(IObjectTypeDescriptor descriptor);
}
public class HotChocolate.Types.OneOfAttribute : InputObjectTypeDescriptorAttribute {
    protected virtual void OnConfigure(IDescriptorContext context, IInputObjectTypeDescriptor descriptor, Type type);
}
public class HotChocolate.Types.OneOfDirectiveType : DirectiveType {
    protected virtual void Configure(IDirectiveTypeDescriptor descriptor);
}
public static class HotChocolate.Types.OperationTypeNames : object {
    public static string Query;
    public static string Mutation;
    public static string Subscription;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.OutputFieldBase`1 : FieldBase`1<TDefinition> {
    private Type _runtimeType;
    [CompilerGeneratedAttribute]
private IOutputType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<Argument> <Arguments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeprecationReason>k__BackingField;
    public IComplexOutputType DeclaringType { get; }
    [NullableAttribute("2")]
public FieldDefinitionNode SyntaxNode { get; }
    public IOutputType Type { get; private set; }
    public Type RuntimeType { get; }
    public FieldCollection`1<Argument> Arguments { get; private set; }
    private IFieldCollection`1<IInputField> HotChocolate.Types.IOutputFieldInfo.Arguments { get; }
    public bool IsIntrospectionField { get; }
    internal bool IsTypeNameField { get; }
    public bool IsDeprecated { get; }
    [NullableAttribute("2")]
public string DeprecationReason { get; }
    internal OutputFieldBase`1(TDefinition definition, int index);
    public sealed virtual IComplexOutputType get_DeclaringType();
    [NullableContextAttribute("2")]
public FieldDefinitionNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public sealed virtual IOutputType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IOutputType value);
    public virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public FieldCollection`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(FieldCollection`1<Argument> value);
    private sealed virtual override IFieldCollection`1<IInputField> HotChocolate.Types.IOutputFieldInfo.get_Arguments();
    public sealed virtual bool get_IsIntrospectionField();
    internal bool get_IsTypeNameField();
    public sealed virtual bool get_IsDeprecated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationReason();
    protected virtual void OnCompleteField(ITypeCompletionContext context, ITypeSystemMember declaringMember, TDefinition definition);
    protected virtual FieldCollection`1<Argument> OnCompleteFields(ITypeCompletionContext context, TDefinition definition);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static Argument <OnCompleteFields>g__CreateArgument|28_0(ArgumentDefinition argDef, int index);
}
public class HotChocolate.Types.Pagination.GetPagingProvider : MulticastDelegate {
    public GetPagingProvider(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IPagingProvider Invoke(IServiceProvider services, IExtendedType sourceType, string providerName);
    public virtual IAsyncResult BeginInvoke(IServiceProvider services, IExtendedType sourceType, string providerName, AsyncCallback callback, object object);
    public virtual IPagingProvider EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Pagination.IPage {
    public IReadOnlyCollection`1<object> Items { get; }
    public IPageInfo Info { get; }
    public abstract virtual IReadOnlyCollection`1<object> get_Items();
    public abstract virtual IPageInfo get_Info();
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<int> GetTotalCountAsync(CancellationToken cancellationToken);
}
public interface HotChocolate.Types.Pagination.IPageInfo {
    public bool HasNextPage { get; }
    public bool HasPreviousPage { get; }
    public abstract virtual bool get_HasNextPage();
    public abstract virtual bool get_HasPreviousPage();
}
public interface HotChocolate.Types.Pagination.IPageType {
    [NullableAttribute("1")]
public IOutputType ItemType { get; }
    [NullableContextAttribute("1")]
public abstract virtual IOutputType get_ItemType();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Pagination.IPagingContext {
    public IResolverContext ResolverContext { get; }
    public object Source { get; }
    public bool IncludeTotalCount { get; }
    public abstract virtual IResolverContext get_ResolverContext();
    public abstract virtual object get_Source();
    public abstract virtual bool get_IncludeTotalCount();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Pagination.IPagingHandler {
    public abstract virtual void ValidateContext(IResolverContext context);
    public abstract virtual ValueTask`1<IPage> SliceAsync(IResolverContext context, object source);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Pagination.IPagingProvider {
    public abstract virtual bool CanHandle(IExtendedType source);
    public abstract virtual IPagingHandler CreateHandler(IExtendedType source, PagingOptions options);
}
public static class HotChocolate.Types.Pagination.PagingDefaults : object {
    public static int DefaultPageSize;
    public static int MaxPageSize;
    public static bool IncludeTotalCount;
    public static bool AllowBackwardPagination;
    public static bool InferConnectionNameFromField;
    public static bool InferCollectionSegmentNameFromField;
    public static bool RequirePagingBoundaries;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.Pagination.PagingHelper : object {
    public static IObjectFieldDescriptor UsePaging(IObjectFieldDescriptor descriptor, Type entityType, GetPagingProvider resolvePagingProvider, PagingOptions options);
    private static void ApplyConfiguration(ITypeCompletionContext context, ObjectFieldDefinition definition, Type entityType, string name, GetPagingProvider resolvePagingProvider, PagingOptions options, FieldMiddlewareDefinition placeholder);
    private static IExtendedType GetSourceType(ITypeInspector typeInspector, ObjectFieldDefinition definition, Type entityType);
    private static FieldMiddleware CreateMiddleware(IPagingHandler handler);
    public static IExtendedType GetSchemaType(IDescriptorContext context, MemberInfo member, Type type);
    [NullableContextAttribute("2")]
public static bool TryGetNamedType(ITypeInspector typeInspector, MemberInfo member, Type& namedType);
    [ExtensionAttribute]
public static PagingOptions GetSettings(ITypeCompletionContext context, PagingOptions options);
    [ExtensionAttribute]
public static PagingOptions GetSettings(IDescriptorContext context, PagingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Pagination.PagingMiddleware : object {
    private FieldDelegate _next;
    private IPagingHandler _pagingHandler;
    public PagingMiddleware(FieldDelegate next, IPagingHandler pagingHandler);
    [AsyncStateMachineAttribute("HotChocolate.Types.Pagination.PagingMiddleware/<InvokeAsync>d__3")]
public Task InvokeAsync(IMiddlewareContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Pagination.PagingOptions : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DefaultPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeTotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowBackwardPagination>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RequirePagingBoundaries>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InferConnectionNameFromField>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InferCollectionSegmentNameFromField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LegacySupport>k__BackingField;
    public Nullable`1<int> DefaultPageSize { get; public set; }
    public Nullable`1<int> MaxPageSize { get; public set; }
    public Nullable`1<bool> IncludeTotalCount { get; public set; }
    public Nullable`1<bool> AllowBackwardPagination { get; public set; }
    public Nullable`1<bool> RequirePagingBoundaries { get; public set; }
    public Nullable`1<bool> InferConnectionNameFromField { get; public set; }
    public Nullable`1<bool> InferCollectionSegmentNameFromField { get; public set; }
    public string ProviderName { get; public set; }
    public Nullable`1<bool> LegacySupport { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_DefaultPageSize();
    [CompilerGeneratedAttribute]
public void set_DefaultPageSize(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPageSize();
    [CompilerGeneratedAttribute]
public void set_MaxPageSize(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeTotalCount();
    [CompilerGeneratedAttribute]
public void set_IncludeTotalCount(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowBackwardPagination();
    [CompilerGeneratedAttribute]
public void set_AllowBackwardPagination(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_RequirePagingBoundaries();
    [CompilerGeneratedAttribute]
public void set_RequirePagingBoundaries(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_InferConnectionNameFromField();
    [CompilerGeneratedAttribute]
public void set_InferConnectionNameFromField(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_InferCollectionSegmentNameFromField();
    [CompilerGeneratedAttribute]
public void set_InferCollectionSegmentNameFromField(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public void set_ProviderName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_LegacySupport();
    [CompilerGeneratedAttribute]
public void set_LegacySupport(Nullable`1<bool> value);
    internal void Merge(PagingOptions other);
    internal PagingOptions Copy();
}
internal class HotChocolate.Types.PaginationAmountType : IntType {
}
[AttributeUsageAttribute("192")]
public class HotChocolate.Types.ParallelAttribute : ObjectFieldDescriptorAttribute {
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
public class HotChocolate.Types.QueryTypeAttribute : ObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStaticMembers>k__BackingField;
    public bool Inherited { get; public set; }
    public bool IncludeStaticMembers { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStaticMembers();
    [CompilerGeneratedAttribute]
public void set_IncludeStaticMembers(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Relay.Descriptors.INodeDescriptor {
    public abstract virtual INodeDescriptor IdField(MemberInfo propertyOrMethod);
    [ObsoleteAttribute("Use ResolveNode.")]
public abstract virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<object, object> nodeResolver);
    [ObsoleteAttribute("Use ResolveNode.")]
public abstract virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<object, TId> nodeResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(FieldResolverDelegate fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<object, TId> fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(Type type);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Expression`1<Func`2<TResolver, object>> method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith();
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(MethodInfo method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Relay.Descriptors.INodeDescriptor`1 {
    public abstract virtual INodeDescriptor`2<TNode, TId> IdField(Expression`1<Func`2<TNode, TId>> propertyOrMethod);
    public abstract virtual INodeDescriptor`1<TNode> IdField(MemberInfo propertyOrMethod);
    [ObsoleteAttribute("Use ResolveNode.")]
public abstract virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, object> nodeResolver);
    [ObsoleteAttribute("Use ResolveNode.")]
public abstract virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, TId> nodeResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(FieldResolverDelegate fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<TNode, TId> fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Expression`1<Func`2<TResolver, object>> method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith();
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(MethodInfo method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Relay.Descriptors.INodeDescriptor`2 {
    [ObsoleteAttribute("Use ResolveNode.")]
public abstract virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, TId> nodeResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(FieldResolverDelegate fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<TNode, TId> fieldResolver);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Expression`1<Func`2<TResolver, object>> method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith();
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(MethodInfo method);
    public abstract virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.Descriptors.NodeDefinition : DefinitionBase {
    [CompilerGeneratedAttribute]
private Type <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <IdMember>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectFieldDefinition <ResolverField>k__BackingField;
    public Type NodeType { get; public set; }
    public MemberInfo IdMember { get; public set; }
    public ObjectFieldDefinition ResolverField { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_NodeType();
    [CompilerGeneratedAttribute]
public void set_NodeType(Type value);
    [CompilerGeneratedAttribute]
public MemberInfo get_IdMember();
    [CompilerGeneratedAttribute]
public void set_IdMember(MemberInfo value);
    [CompilerGeneratedAttribute]
public ObjectFieldDefinition get_ResolverField();
    [CompilerGeneratedAttribute]
public void set_ResolverField(ObjectFieldDefinition value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.Descriptors.NodeDescriptor : NodeDescriptorBase {
    private IObjectTypeDescriptor _typeDescriptor;
    public NodeDescriptor(IObjectTypeDescriptor descriptor, Type nodeType);
    internal void OnCompleteDefinition(ITypeCompletionContext context, ObjectTypeDefinition definition);
    internal void ConfigureNodeField(IObjectTypeDescriptor typeDescriptor);
    protected virtual IObjectFieldDescriptor ConfigureNodeField();
    public sealed virtual INodeDescriptor IdField(MemberInfo propertyOrMethod);
    public sealed virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<object, object> nodeResolver);
    public sealed virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<object, TId> nodeResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNode(Type type);
    internal void TryResolveNode(Type type);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith();
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.Descriptors.NodeDescriptor`1 : NodeDescriptorBase {
    private IObjectTypeDescriptor`1<TNode> _typeDescriptor;
    public NodeDescriptor`1(IObjectTypeDescriptor`1<TNode> descriptor);
    private void OnCompleteDefinition(ITypeCompletionContext context, ObjectTypeDefinition definition);
    protected virtual IObjectFieldDescriptor ConfigureNodeField();
    public sealed virtual INodeDescriptor`2<TNode, TId> IdField(Expression`1<Func`2<TNode, TId>> propertyOrMethod);
    public sealed virtual INodeDescriptor`1<TNode> IdField(MemberInfo propertyOrMethod);
    public sealed virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, object> nodeResolver);
    public sealed virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, TId> nodeResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<TNode, TId> fieldResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith();
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(ITypeCompletionContext c, IDefinition d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.Descriptors.NodeDescriptor`2 : object {
    private Func`1<IObjectFieldDescriptor> _configureNodeField;
    [CompilerGeneratedAttribute]
private IDescriptorContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeDefinition <Definition>k__BackingField;
    private IDescriptorContext Context { get; }
    private NodeDefinition Definition { get; }
    public NodeDescriptor`2(IDescriptorContext context, NodeDefinition definition, Func`1<IObjectFieldDescriptor> configureNodeField);
    [CompilerGeneratedAttribute]
private IDescriptorContext get_Context();
    [CompilerGeneratedAttribute]
private NodeDefinition get_Definition();
    public sealed virtual IObjectFieldDescriptor NodeResolver(NodeResolverDelegate`2<TNode, TId> nodeResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNode(FieldResolverDelegate fieldResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<TNode, TId> fieldResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(Expression`1<Func`2<TResolver, object>> method);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(MethodInfo method);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith();
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.Relay.Descriptors.NodeDescriptorBase : DescriptorBase`1<NodeDefinition> {
    [CompilerGeneratedAttribute]
private NodeDefinition <Definition>k__BackingField;
    protected internal NodeDefinition Definition { get; protected set; }
    protected NodeDescriptorBase(IDescriptorContext context);
    [CompilerGeneratedAttribute]
protected internal sealed virtual NodeDefinition get_Definition();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_Definition(NodeDefinition value);
    protected abstract virtual IObjectFieldDescriptor ConfigureNodeField();
    public virtual IObjectFieldDescriptor ResolveNode(FieldResolverDelegate fieldResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNode(NodeResolverDelegate`2<object, TId> fieldResolver);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(Expression`1<Func`2<TResolver, object>> method);
    public sealed virtual IObjectFieldDescriptor ResolveNodeWith(MethodInfo method);
    protected void CompleteResolver(ITypeCompletionContext context, ObjectTypeDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.GlobalIdInputValueFormatter : object {
    private string _typeName;
    private IIdSerializer _idSerializer;
    private bool _validateType;
    private Func`1<IList> _createList;
    public GlobalIdInputValueFormatter(string typeName, IIdSerializer idSerializer, IExtendedType resultType, bool validateType);
    [NullableContextAttribute("2")]
public sealed virtual object Format(object runtimeValue);
    private static Func`1<IList> CreateListFactory(IExtendedType resultType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2240")]
public class HotChocolate.Types.Relay.IDAttribute : DescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public IDAttribute(string typeName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [NullableContextAttribute("1")]
protected internal virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2240")]
public class HotChocolate.Types.Relay.IDAttribute`1 : DescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [NullableContextAttribute("1")]
protected internal virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
}
public static class HotChocolate.Types.Relay.IdMiddleware : object {
    public static ResultFormatterDefinition Create();
}
public class HotChocolate.Types.Relay.IdSerializationException : GraphQLException {
    [ObsoleteAttribute("Use constructor with operationStatus and originalValue")]
public IdSerializationException(string message);
    public IdSerializationException(string message, OperationStatus operationStatus, string originalValue);
    protected IdSerializationException(SerializationInfo info, StreamingContext context);
}
public class HotChocolate.Types.Relay.IdSerializer : object {
    private static int _stackallocThreshold;
    private static int _divisor;
    private static byte _separator;
    private static byte _guid;
    private static byte _short;
    private static byte _int;
    private static byte _long;
    private static byte _default;
    private static char _equals;
    private static byte _schema;
    [NullableAttribute("1")]
private static Encoding _utf8;
    private bool _includeSchemaName;
    public IdSerializer(bool includeSchemaName);
    private static IdSerializer();
    [NullableContextAttribute("1")]
public string Serialize(string typeName, T id);
    [NullableContextAttribute("2")]
public sealed virtual string Serialize(string schemaName, string typeName, T id);
    private int CopyString(string value, Span`1<byte> serialized);
    private string CreateString(Span`1<byte> serialized);
    [NullableContextAttribute("1")]
public sealed virtual IdValue Deserialize(string serializedId);
    [NullableContextAttribute("1")]
public static bool IsPossibleBase64String(string s);
    private static bool IsBase64Char(Char& c);
    [NullableContextAttribute("1")]
private static int GetAllocationSize(T& value);
    private static int NextSeparator(ReadOnlySpan`1<byte> serializedId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class HotChocolate.Types.Relay.IdValue : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [NullableAttribute("2")]
public string SchemaName { get; }
    public string TypeName { get; }
    public object Value { get; }
    public IdValue(string schemaName, string typeName, object value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SchemaName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public object get_Value();
}
[NullableContextAttribute("1")]
public interface HotChocolate.Types.Relay.IIdSerializer {
    [NullableContextAttribute("2")]
public abstract virtual string Serialize(string schemaName, string typeName, T id);
    public abstract virtual IdValue Deserialize(string serializedId);
}
public interface HotChocolate.Types.Relay.INode {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.MutationPayloadOptions : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <QueryFieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<INamedType, bool> <MutationPayloadPredicate>k__BackingField;
    [NullableAttribute("2")]
public string QueryFieldName { get; public set; }
    public Func`2<INamedType, bool> MutationPayloadPredicate { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_QueryFieldName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_QueryFieldName(string value);
    [CompilerGeneratedAttribute]
public Func`2<INamedType, bool> get_MutationPayloadPredicate();
    [CompilerGeneratedAttribute]
public void set_MutationPayloadPredicate(Func`2<INamedType, bool> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.Relay.NodeAttribute : ObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <IdField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NodeResolverType>k__BackingField;
    public string IdField { get; public set; }
    public string NodeResolver { get; public set; }
    public Type NodeResolverType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IdField();
    [CompilerGeneratedAttribute]
public void set_IdField(string value);
    [CompilerGeneratedAttribute]
public string get_NodeResolver();
    [CompilerGeneratedAttribute]
public void set_NodeResolver(string value);
    [CompilerGeneratedAttribute]
public Type get_NodeResolverType();
    [CompilerGeneratedAttribute]
public void set_NodeResolverType(Type value);
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Types.Relay.NodeConstants : object {
    public static string Node;
    public static string Nodes;
    public static string Id;
    public static string Ids;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Types.Relay.NodeFieldResolvers : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Task`1<object> _nullTask;
    private static NodeFieldResolvers();
    [AsyncStateMachineAttribute("HotChocolate.Types.Relay.NodeFieldResolvers/<ResolveSingleNodeAsync>d__1")]
public static ValueTask ResolveSingleNodeAsync(IMiddlewareContext context, IIdSerializer serializer);
    [AsyncStateMachineAttribute("HotChocolate.Types.Relay.NodeFieldResolvers/<ResolveManyNodeAsync>d__2")]
public static ValueTask ResolveManyNodeAsync(IMiddlewareContext context, IIdSerializer serializer, int maxAllowedNodes);
    private static void SetLocalContext(IMiddlewareContext context, StringValueNode nodeId, IdValue deserializedId, ObjectType type);
    private static void TryReplaceArguments(IMiddlewareContext context, NodeResolverInfo nodeResolverInfo, string argumentName, StringValueNode argumentLiteral);
    private static void ReportError(IResolverContext context, int item, Exception ex);
    [AsyncStateMachineAttribute("HotChocolate.Types.Relay.NodeFieldResolvers/<<ResolveManyNodeAsync>g__ExecutePipelineAsync|2_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<object> <ResolveManyNodeAsync>g__ExecutePipelineAsync|2_0(IMiddlewareContext nodeResolverContext, NodeResolverInfo nodeResolverInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.NodeFieldTypeInterceptor : TypeInterceptor {
    [NullableAttribute("2")]
private ITypeCompletionContext _queryContext;
    [NullableAttribute("2")]
private ObjectTypeDefinition _queryTypeDefinition;
    internal UInt32 Position { get; }
    internal virtual UInt32 get_Position();
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnBeforeCompleteTypes();
    private static void CreateNodeField(ITypeInspector typeInspector, IIdSerializer serializer, IList`1<ObjectFieldDefinition> fields, int index);
    private static void CreateNodesField(ITypeInspector typeInspector, IIdSerializer serializer, IList`1<ObjectFieldDefinition> fields, int index, int maxAllowedNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.NodeIdParameterExpressionBuilder : ScopedStateParameterExpressionBuilder {
    [CompilerGeneratedAttribute]
private PropertyInfo <ContextDataProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private static NodeIdParameterExpressionBuilder <Instance>k__BackingField;
    public ArgumentKind Kind { get; }
    protected PropertyInfo ContextDataProperty { get; }
    protected MethodInfo SetStateMethod { get; }
    protected MethodInfo SetStateGenericMethod { get; }
    public static NodeIdParameterExpressionBuilder Instance { get; }
    private static NodeIdParameterExpressionBuilder();
    public virtual ArgumentKind get_Kind();
    [CompilerGeneratedAttribute]
protected virtual PropertyInfo get_ContextDataProperty();
    protected virtual MethodInfo get_SetStateMethod();
    protected virtual MethodInfo get_SetStateGenericMethod();
    public virtual bool CanHandle(ParameterInfo parameter);
    protected virtual string GetKey(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
public static NodeIdParameterExpressionBuilder get_Instance();
}
[AttributeUsageAttribute("64")]
public class HotChocolate.Types.Relay.NodeResolverAttribute : Attribute {
}
internal static class HotChocolate.Types.Relay.NodeResolverCompilerHelper : object {
    public static IParameterExpressionBuilder[] ParameterExpressionBuilders;
    private static NodeResolverCompilerHelper();
}
public class HotChocolate.Types.Relay.NodeResolverDelegate`1 : MulticastDelegate {
    public NodeResolverDelegate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<TNode> Invoke(IResolverContext context, object id);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, object id, AsyncCallback callback, object object);
    public virtual Task`1<TNode> EndInvoke(IAsyncResult result);
}
public class HotChocolate.Types.Relay.NodeResolverDelegate`2 : MulticastDelegate {
    public NodeResolverDelegate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<TNode> Invoke(IResolverContext context, TId id);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, TId id, AsyncCallback callback, object object);
    public virtual Task`1<TNode> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.NodeResolverInfo : object {
    [CompilerGeneratedAttribute]
private Argument <Id>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private FieldDelegate <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectField <QueryField>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQueryFieldResolver>k__BackingField;
    public Argument Id { get; }
    [NullableAttribute("1")]
public FieldDelegate Pipeline { get; }
    public ObjectField QueryField { get; }
    public bool IsQueryFieldResolver { get; }
    [NullableContextAttribute("1")]
public NodeResolverInfo(ObjectField resolverField, FieldDelegate pipeline);
    [CompilerGeneratedAttribute]
public Argument get_Id();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public FieldDelegate get_Pipeline();
    [CompilerGeneratedAttribute]
public ObjectField get_QueryField();
    [CompilerGeneratedAttribute]
public bool get_IsQueryFieldResolver();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.NodeResolverTypeInterceptor : TypeInterceptor {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDictionary`2<string, object>> _nodes;
    [CompilerGeneratedAttribute]
private ITypeCompletionContext <CompletionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectType <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectTypeDefinition <TypeDef>k__BackingField;
    internal UInt32 Position { get; }
    private ITypeCompletionContext CompletionContext { get; private set; }
    private ObjectType QueryType { get; private set; }
    private ObjectTypeDefinition TypeDef { get; private set; }
    private bool IsInitialized { get; }
    internal virtual UInt32 get_Position();
    [CompilerGeneratedAttribute]
private ITypeCompletionContext get_CompletionContext();
    [CompilerGeneratedAttribute]
private void set_CompletionContext(ITypeCompletionContext value);
    [CompilerGeneratedAttribute]
private ObjectType get_QueryType();
    [CompilerGeneratedAttribute]
private void set_QueryType(ObjectType value);
    [CompilerGeneratedAttribute]
private ObjectTypeDefinition get_TypeDef();
    [CompilerGeneratedAttribute]
private void set_TypeDef(ObjectTypeDefinition value);
    private bool get_IsInitialized();
    [NullableContextAttribute("1")]
internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnAfterMergeTypeExtensions();
    public virtual void OnAfterCompleteTypes();
    [NullableContextAttribute("1")]
private static bool ImplementsNode(ITypeCompletionContext context, ObjectTypeDefinition typeDef);
}
public class HotChocolate.Types.Relay.NodeType : InterfaceType`1<INode> {
    protected virtual void Configure(IInterfaceTypeDescriptor`1<INode> descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.Relay.QueryFieldTypeInterceptor : TypeInterceptor {
    private static string _defaultFieldName;
    private HashSet`1<string> _payloads;
    private ITypeCompletionContext _context;
    [NullableAttribute("2")]
private ObjectType _queryType;
    private ObjectFieldDefinition _queryField;
    [NullableAttribute("2")]
private ObjectTypeDefinition _mutationDefinition;
    internal virtual void OnAfterResolveRootType(ITypeCompletionContext completionContext, ObjectTypeDefinition definition, OperationType operationType);
    public virtual void OnBeforeCompleteTypes();
    public virtual void OnBeforeCompleteType(ITypeCompletionContext completionContext, DefinitionBase definition);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <OnBeforeCompleteType>b__8_0(ObjectFieldDefinition t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Types.Relay.RelayHelper : object {
    [ExtensionAttribute]
public static MutationPayloadOptions GetMutationPayloadOptions(IDescriptorContext context);
    [ExtensionAttribute]
public static ISchemaBuilder SetMutationPayloadOptions(ISchemaBuilder schemaBuilder, MutationPayloadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Types.Relay.RelayIdFieldHelpers : object {
    [NullableAttribute("2")]
private static IdSerializer _idSerializer;
    public static void ApplyIdToField(IDescriptor`1<ArgumentDefinition> descriptor, string typeName);
    public static void ApplyIdToField(IDescriptor`1<OutputFieldDefinitionBase> descriptor, string typeName);
    internal static void ApplyIdToField(ObjectFieldDefinition definition, string typeName);
    private static void RewriteDefinition(IDescriptorContext context, FieldDefinitionBase definition);
    private static IExtendedType RewriteType(ITypeInspector typeInspector, ITypeInfo typeInfo);
    internal static void AddSerializerToInputField(ITypeCompletionContext completionContext, ArgumentDefinition definition, string typeName);
    private static void AddSerializerToObjectField(ITypeCompletionContext completionContext, ObjectFieldDefinition definition, ResultFormatterDefinition placeholder, string typeName);
    private static IInputValueFormatter CreateSerializer(ITypeCompletionContext completionContext, IExtendedType resultType, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute]
public class HotChocolate.Types.Relay.RelayOptions : object {
    [CompilerGeneratedAttribute]
private bool <AddQueryFieldToMutationPayloads>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <QueryFieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<INamedType, bool> <MutationPayloadPredicate>k__BackingField;
    public bool AddQueryFieldToMutationPayloads { get; public set; }
    [NullableAttribute("2")]
public string QueryFieldName { get; public set; }
    public Func`2<INamedType, bool> MutationPayloadPredicate { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AddQueryFieldToMutationPayloads();
    [CompilerGeneratedAttribute]
public void set_AddQueryFieldToMutationPayloads(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_QueryFieldName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_QueryFieldName(string value);
    [CompilerGeneratedAttribute]
public Func`2<INamedType, bool> get_MutationPayloadPredicate();
    [CompilerGeneratedAttribute]
public void set_MutationPayloadPredicate(Func`2<INamedType, bool> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.RelayIdFieldExtensions : object {
    [ExtensionAttribute]
public static IInputFieldDescriptor ID(IInputFieldDescriptor descriptor, string typeName);
    [ExtensionAttribute]
public static IArgumentDescriptor ID(IArgumentDescriptor descriptor, string typeName);
    [ExtensionAttribute]
public static IObjectFieldDescriptor ID(IObjectFieldDescriptor descriptor, string typeName);
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor ID(IInterfaceFieldDescriptor descriptor);
}
public class HotChocolate.Types.ResolveAbstractType : MulticastDelegate {
    public ResolveAbstractType(object object, IntPtr method);
    public virtual ObjectType Invoke(IResolverContext context, object resolverResult);
    public virtual IAsyncResult BeginInvoke(IResolverContext context, object resolverResult, AsyncCallback callback, object object);
    public virtual ObjectType EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.ResolveObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, object> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<object>> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, TResult> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<TResult>> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`1<object> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`1<Task`1<object>> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`1<TResult> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`1<Task`1<TResult>> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, object> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, TResult> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, Task`1<TResult>> resolver);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, object constantResult);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Resolve(IObjectFieldDescriptor descriptor, TResult constantResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static class HotChocolate.Types.ResolverObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, object> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<object>> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, TResult> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<TResult>> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`1<object> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`1<Task`1<object>> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`1<TResult> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`1<Task`1<TResult>> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, object> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, TResult> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, Func`3<IResolverContext, CancellationToken, Task`1<TResult>> resolver);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, object constantResult);
    [ExtensionAttribute]
[ObsoleteAttribute("Use Resolve(...)")]
public static IObjectFieldDescriptor Resolver(IObjectFieldDescriptor descriptor, TResult constantResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.ResolveWithObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor ResolveWith(IObjectFieldDescriptor descriptor, Expression`1<Func`2<TResolver, TResult>> propertyOrMethod);
    [ExtensionAttribute]
public static IObjectFieldDescriptor ResolveWith(IObjectFieldDescriptor descriptor, Expression`1<Func`2<TResolver, Task`1<TResult>>> propertyOrMethod);
}
public static class HotChocolate.Types.ScalarNames : object {
    public static string String;
    public static string ID;
    public static string Boolean;
    public static string Short;
    public static string Int;
    public static string Long;
    public static string Float;
    public static string Decimal;
    public static string URL;
    public static string UUID;
    public static string Byte;
    public static string ByteArray;
    public static string Any;
    public static string DateTime;
    public static string Date;
    public static string TimeSpan;
    public static string MultiplierPath;
    public static string Name;
    public static string PaginationAmount;
    public static string JSON;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class HotChocolate.Types.Scalars : object {
    private static Dictionary`2<Type, Type> _lookup;
    private static Dictionary`2<string, Type> _nameLookup;
    private static Dictionary`2<Type, ValueKind> _scalarKinds;
    private static Scalars();
    internal static bool TryGetScalar(Type runtimeType, Type& schemaType);
    internal static bool TryGetScalar(string typeName, Type& schemaType);
    public static bool IsBuiltIn(string typeName);
    [NullableContextAttribute("2")]
public static bool TryGetKind(object value, ValueKind& kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.ScalarType : TypeSystemObjectBase`1<ScalarTypeDefinition> {
    [NullableAttribute("2")]
private Uri _specifiedBy;
    [CompilerGeneratedAttribute]
private BindingBehavior <Bind>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectiveCollection <Directives>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ScalarTypeDefinitionNode <SyntaxNode>k__BackingField;
    private ITypeConverter _converter;
    public TypeKind Kind { get; }
    public BindingBehavior Bind { get; }
    public Type RuntimeType { get; }
    [NullableAttribute("2")]
public Uri SpecifiedBy { get; protected set; }
    public IDirectiveCollection Directives { get; private set; }
    [NullableAttribute("2")]
public ScalarTypeDefinitionNode SyntaxNode { get; private set; }
    [NullableAttribute("2")]
private ISyntaxNode HotChocolate.Types.IHasSyntaxNode.SyntaxNode { get; }
    protected ITypeConverter Converter { get; }
    protected ScalarType(string name, BindingBehavior bind);
    public sealed virtual TypeKind get_Kind();
    [CompilerGeneratedAttribute]
public BindingBehavior get_Bind();
    public abstract virtual Type get_RuntimeType();
    [NullableContextAttribute("2")]
public Uri get_SpecifiedBy();
    [NullableContextAttribute("2")]
protected void set_SpecifiedBy(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual IDirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
private void set_Directives(IDirectiveCollection value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ScalarTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(ScalarTypeDefinitionNode value);
    [NullableContextAttribute("2")]
private sealed virtual override ISyntaxNode HotChocolate.Types.IHasSyntaxNode.get_SyntaxNode();
    protected ITypeConverter get_Converter();
    public sealed virtual bool IsAssignableFrom(INamedType type);
    public abstract virtual bool IsInstanceOfType(IValueNode valueSyntax);
    [NullableContextAttribute("2")]
public virtual bool IsInstanceOfType(object runtimeValue);
    public abstract virtual object ParseLiteral(IValueNode valueSyntax);
    public abstract virtual IValueNode ParseValue(object runtimeValue);
    public abstract virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual object Serialize(object runtimeValue);
    [NullableContextAttribute("2")]
public abstract virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual object Deserialize(object resultValue);
    [NullableContextAttribute("2")]
public abstract virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    protected bool TryConvertSerialized(object serialized, ValueKind expectedKind, T& value);
    protected virtual ScalarTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, ScalarTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, ScalarTypeDefinition definition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.ScalarType`1 : ScalarType {
    public Type RuntimeType { get; }
    protected ScalarType`1(string name, BindingBehavior bind);
    public sealed virtual Type get_RuntimeType();
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class HotChocolate.Types.ScalarType`2 : ScalarType`1<TRuntimeType> {
    protected ScalarType`2(string name, BindingBehavior bind);
    public sealed virtual bool IsInstanceOfType(IValueNode valueSyntax);
    protected virtual bool IsInstanceOfType(TLiteral valueSyntax);
    [NullableContextAttribute("2")]
public sealed virtual bool IsInstanceOfType(object runtimeValue);
    protected virtual bool IsInstanceOfType(TRuntimeType runtimeValue);
    public sealed virtual object ParseLiteral(IValueNode valueSyntax);
    protected abstract virtual TRuntimeType ParseLiteral(TLiteral valueSyntax);
    public sealed virtual IValueNode ParseValue(object runtimeValue);
    protected abstract virtual TLiteral ParseValue(TRuntimeType runtimeValue);
    protected virtual SerializationException CreateParseLiteralError(IValueNode valueSyntax);
    protected virtual SerializationException CreateParseValueError(object runtimeValue);
}
[ExtensionAttribute]
public static class HotChocolate.Types.ScopedServiceObjectFieldDescriptorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IObjectFieldDescriptor UseScopedService(IObjectFieldDescriptor descriptor, Func`2<IServiceProvider, TService> create, Action`2<IServiceProvider, TService> dispose, Func`3<IServiceProvider, TService, ValueTask> disposeAsync);
}
[AttributeUsageAttribute("192")]
public class HotChocolate.Types.SerialAttribute : ObjectFieldDescriptorAttribute {
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.SerializationException : GraphQLException {
    [CompilerGeneratedAttribute]
private ITypeSystemMember <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Path <Path>k__BackingField;
    public ITypeSystemMember Type { get; }
    [NullableAttribute("2")]
public Path Path { get; }
    public SerializationException(string message, ITypeSystemMember type, Path path);
    public SerializationException(IError error, ITypeSystemMember type, Path path);
    [CompilerGeneratedAttribute]
public ITypeSystemMember get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Path get_Path();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.ShortType : IntegerTypeBase`1<short> {
    public ShortType(short min, short max);
    public ShortType(string name, string description, short min, short max, BindingBehavior bind);
    protected virtual short ParseLiteral(IntValueNode valueSyntax);
    protected virtual IntValueNode ParseValue(short runtimeValue);
}
public class HotChocolate.Types.SkipDirectiveType : DirectiveType {
    protected virtual void Configure(IDirectiveTypeDescriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.SpecifiedByDirective : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Url { get; }
    public SpecifiedByDirective(string url);
    [CompilerGeneratedAttribute]
public string get_Url();
}
public class HotChocolate.Types.SpecifiedByDirectiveType : DirectiveType`1<SpecifiedByDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<SpecifiedByDirective> descriptor);
}
[AttributeUsageAttribute("4")]
internal class HotChocolate.Types.SpecScalarAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Types.StaticObjectTypeExtension : ObjectTypeExtension {
    private Type _staticExtType;
    public StaticObjectTypeExtension(Type staticExtType);
    protected virtual void Configure(IObjectTypeDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class HotChocolate.Types.StreamDirective : object {
    [CompilerGeneratedAttribute]
private bool <If>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialCount>k__BackingField;
    public bool If { get; }
    public string Label { get; }
    public int InitialCount { get; }
    public StreamDirective(bool if, int initialCount, string label);
    [CompilerGeneratedAttribute]
public bool get_If();
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public int get_InitialCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.StreamDirectiveType : DirectiveType`1<StreamDirective> {
    protected virtual void Configure(IDirectiveTypeDescriptor`1<StreamDirective> descriptor);
}
[AttributeUsageAttribute("192")]
public class HotChocolate.Types.StreamResultAttribute : ObjectFieldDescriptorAttribute {
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[SpecScalarAttribute]
public class HotChocolate.Types.StringType : ScalarType`2<string, StringValueNode> {
    public StringType(string name, string description, BindingBehavior bind);
    protected virtual string ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(string runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
}
[ObsoleteAttribute("Use the SubscribeAttribute.")]
[AttributeUsageAttribute("192")]
public class HotChocolate.Types.SubscribeAndResolveAttribute : ObjectFieldDescriptorAttribute {
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class HotChocolate.Types.SubscribeAttribute : ObjectFieldDescriptorAttribute {
    [NullableAttribute("1")]
private static MethodInfo _subscribeFactory;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <With>k__BackingField;
    public Type MessageType { get; public set; }
    public string With { get; public set; }
    private static SubscribeAttribute();
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(Type value);
    [CompilerGeneratedAttribute]
public string get_With();
    [CompilerGeneratedAttribute]
public void set_With(string value);
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
    [NullableContextAttribute("1")]
private static string ResolveTopicString(MethodInfo method);
    [NullableContextAttribute("1")]
private static void SubscribeFactory(ObjectFieldDefinition fieldDef, string topicString);
    [NullableContextAttribute("1")]
private static SubscribeResolverDelegate CreateSubscribeResolver(string topicString);
    [NullableContextAttribute("1")]
private static SubscribeResolverDelegate CreateArgumentSubscribeResolver(string topicFormatString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.SubscribeResolverObjectFieldDescriptorExtensions : object {
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<IObservable`1<TMessage>>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, IObservable`1<TMessage>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<IEnumerable`1<TMessage>>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, IEnumerable`1<TMessage>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, Task`1<IAsyncEnumerable`1<TMessage>>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Subscribe(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, IAsyncEnumerable`1<TMessage>> subscribe);
    [ExtensionAttribute]
public static IObjectFieldDescriptor SubscribeToTopic(IObjectFieldDescriptor descriptor, string topicName);
    [ExtensionAttribute]
public static IObjectFieldDescriptor SubscribeToTopicByArgument(IObjectFieldDescriptor descriptor, string argumentName);
    [ExtensionAttribute]
public static IObjectFieldDescriptor SubscribeToTopic(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, string> resolveTopic);
    [ExtensionAttribute]
public static IObjectFieldDescriptor SubscribeToTopic(IObjectFieldDescriptor descriptor, Func`2<IResolverContext, ValueTask`1<string>> resolveTopic);
}
public class HotChocolate.Types.SubscriptionTypeAttribute : ObjectTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStaticMembers>k__BackingField;
    public bool Inherited { get; public set; }
    public bool IncludeStaticMembers { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStaticMembers();
    [CompilerGeneratedAttribute]
public void set_IncludeStaticMembers(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    protected virtual void OnConfigure(IDescriptorContext context, IObjectTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DirectiveTypeAttribute("tag", "262016")]
[TagDirectiveConfigAttribute]
public class HotChocolate.Types.Tag : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public Tag(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("3548")]
public class HotChocolate.Types.TagAttribute : DescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public TagAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    protected internal virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
}
internal class HotChocolate.Types.TagDirectiveConfigAttribute : DirectiveTypeDescriptorAttribute {
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IDirectiveTypeDescriptor descriptor, Type type);
}
[ExtensionAttribute]
public static class HotChocolate.Types.TagDirectiveExtensions : object {
    [ExtensionAttribute]
public static IObjectTypeDescriptor Tag(IObjectTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IInterfaceTypeDescriptor Tag(IInterfaceTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IUnionTypeDescriptor Tag(IUnionTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IInputObjectTypeDescriptor Tag(IInputObjectTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IEnumTypeDescriptor Tag(IEnumTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IObjectFieldDescriptor Tag(IObjectFieldDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IInterfaceFieldDescriptor Tag(IInterfaceFieldDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IInputFieldDescriptor Tag(IInputFieldDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IArgumentDescriptor Tag(IArgumentDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IDirectiveArgumentDescriptor Tag(IDirectiveArgumentDescriptor descriptor, string name);
    [ExtensionAttribute]
public static IEnumValueDescriptor Tag(IEnumValueDescriptor descriptor, string name);
    [ExtensionAttribute]
public static ISchemaTypeDescriptor Tag(ISchemaTypeDescriptor descriptor, string name);
    [ExtensionAttribute]
private static void ApplyTag(IDescriptor descriptor, string name);
}
internal static class HotChocolate.Types.TagHelper : object {
    [NullableContextAttribute("1")]
public static void ModifyOptions(IDescriptorContext context, Action`1<TagOptions> configure);
}
internal enum HotChocolate.Types.TagMode : Enum {
    public int value__;
    public static TagMode GraphQLFusion;
    public static TagMode ApolloFederation;
}
internal class HotChocolate.Types.TagOptions : object {
    [CompilerGeneratedAttribute]
private TagMode <Mode>k__BackingField;
    public TagMode Mode { get; public set; }
    [CompilerGeneratedAttribute]
public TagMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(TagMode value);
}
public enum HotChocolate.Types.TimeSpanFormat : Enum {
    public int value__;
    public static TimeSpanFormat Iso8601;
    public static TimeSpanFormat DotNet;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.TimeSpanType : ScalarType`2<TimeSpan, StringValueNode> {
    private TimeSpanFormat _format;
    public TimeSpanType(TimeSpanFormat format, BindingBehavior bind);
    public TimeSpanType(string name, string description, TimeSpanFormat format, BindingBehavior bind);
    protected virtual TimeSpan ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(TimeSpan runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    private static bool TryDeserializeFromString(string serialized, TimeSpanFormat format, Nullable`1& value);
    private static bool TryDeserializeIso8601(string serialized, Nullable`1& value);
    private static bool TryDeserializeDotNet(string serialized, Nullable`1& value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class HotChocolate.Types.TopicAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public TopicAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public enum HotChocolate.Types.TypeContext : Enum {
    public int value__;
    public static TypeContext None;
    public static TypeContext Output;
    public static TypeContext Input;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class HotChocolate.Types.TypeExtensions : object {
    [ExtensionAttribute]
public static int Depth(IType type);
    [ExtensionAttribute]
public static bool IsNullableType(IType type);
    [ExtensionAttribute]
public static bool IsNonNullType(IType type);
    [ExtensionAttribute]
public static bool IsCompositeType(IType type);
    [ExtensionAttribute]
public static bool IsComplexType(IType type);
    [ExtensionAttribute]
public static bool IsLeafType(IType type);
    [ExtensionAttribute]
public static bool IsListType(IType type);
    [ExtensionAttribute]
public static bool IsScalarType(IType type);
    [ExtensionAttribute]
public static bool IsObjectType(IType type);
    [ExtensionAttribute]
public static bool IsEnumType(IType type);
    [ExtensionAttribute]
public static bool IsInterfaceType(IType type);
    [ExtensionAttribute]
public static bool IsInputObjectType(IType type);
    [ExtensionAttribute]
public static bool IsInputType(IType type);
    [ExtensionAttribute]
internal static IInputType EnsureInputType(IType type);
    [ExtensionAttribute]
public static bool IsOutputType(IType type);
    [ExtensionAttribute]
internal static IOutputType EnsureOutputType(IType type);
    [ExtensionAttribute]
public static bool IsUnionType(IType type);
    [ExtensionAttribute]
public static bool IsAbstractType(IType type);
    [ExtensionAttribute]
public static bool IsNamedType(IType type);
    [ExtensionAttribute]
internal static bool IsType(IType type, TypeKind kind);
    [ExtensionAttribute]
internal static bool IsType(IType type, TypeKind kind1, TypeKind kind2);
    [ExtensionAttribute]
internal static bool IsType(IType type, TypeKind kind1, TypeKind kind2, TypeKind kind3);
    [ExtensionAttribute]
public static IType InnerType(IType type);
    [ExtensionAttribute]
public static IType NullableType(IType type);
    [ExtensionAttribute]
public static string TypeName(IType type);
    [ExtensionAttribute]
public static ListType ListType(IType type);
    [ExtensionAttribute]
public static INamedType NamedType(IType type);
    [ExtensionAttribute]
public static IType ElementType(IType type);
    [ExtensionAttribute]
public static bool IsEqualTo(IType x, IType y);
    [ExtensionAttribute]
public static Type ToRuntimeType(IType type);
    private static Type LeafTypeToClrType(IType type);
    [ExtensionAttribute]
public static ITypeNode ToTypeNode(IType type);
    [ExtensionAttribute]
public static ITypeNode ToTypeNode(IType original, INamedType namedType);
    [ExtensionAttribute]
public static IType ToType(ITypeNode typeNode, INamedType namedType);
    [ExtensionAttribute]
public static ITypeNode RenameName(ITypeNode typeNode, string name);
    [ExtensionAttribute]
public static bool IsInstanceOfType(IInputType type, IValueNode literal);
    [ExtensionAttribute]
public static IType RewriteNullability(IType type, INullabilityNode nullability);
    [ExtensionAttribute]
public static IType RewriteToNullableType(IType type);
    [CompilerGeneratedAttribute]
internal static bool <NamedType>g__IsNamed|26_0(IType type);
}
public class HotChocolate.Types.TypeInitializationException : Exception {
    public TypeInitializationException(string message);
    public TypeInitializationException(string message, Exception inner);
}
[ExtensionAttribute]
public static class HotChocolate.Types.TypeNameExtensions : object {
    [ExtensionAttribute]
public static IObjectTypeNameDependencyDescriptor Name(IObjectTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IObjectTypeNameDependencyDescriptor`1<T> Name(IObjectTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IEnumTypeNameDependencyDescriptor Name(IEnumTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IEnumTypeNameDependencyDescriptor`1<T> Name(IEnumTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IInputObjectTypeNameDependencyDescriptor Name(IInputObjectTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IInputObjectTypeNameDependencyDescriptor`1<T> Name(IInputObjectTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IInterfaceTypeNameDependencyDescriptor Name(IInterfaceTypeDescriptor descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IInterfaceTypeNameDependencyDescriptor`1<T> Name(IInterfaceTypeDescriptor`1<T> descriptor, Func`2<INamedType, string> createName);
    [ExtensionAttribute]
public static IUnionTypeNameDependencyDescriptor Name(IUnionTypeDescriptor descriptor, Func`2<INamedType, string> createName);
}
[ExtensionAttribute]
public static class HotChocolate.Types.TypeNamePrinter : object {
    private static int _maxTypeDepth;
    [ExtensionAttribute]
public static string Print(IType type);
    private static string Print(IType type, int count);
}
internal enum HotChocolate.Types.TypeStatus : Enum {
    public int value__;
    public static TypeStatus Uninitialized;
    public static TypeStatus Initialized;
    public static TypeStatus Named;
    public static TypeStatus Completed;
    public static TypeStatus Finalized;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.TypeSystemObjectBase : object {
    private TypeStatus _status;
    private string _name;
    private string _scope;
    private string _description;
    public string Scope { get; protected set; }
    [NullableAttribute("1")]
public string Name { get; protected set; }
    public string Description { get; protected set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> ContextData { get; }
    protected internal bool IsInitialized { get; }
    protected internal bool IsNamed { get; }
    protected internal bool IsCompleted { get; }
    public sealed virtual string get_Scope();
    protected void set_Scope(string value);
    [NullableContextAttribute("1")]
public sealed virtual string get_Name();
    [NullableContextAttribute("1")]
protected void set_Name(string value);
    public sealed virtual string get_Description();
    protected void set_Description(string value);
    public abstract virtual IReadOnlyDictionary`2<string, object> get_ContextData();
    protected internal bool get_IsInitialized();
    protected internal bool get_IsNamed();
    protected internal bool get_IsCompleted();
    [NullableContextAttribute("1")]
internal virtual void Initialize(ITypeDiscoveryContext context);
    [NullableContextAttribute("1")]
internal virtual void CompleteName(ITypeCompletionContext context);
    [NullableContextAttribute("1")]
internal virtual void CompleteType(ITypeCompletionContext context);
    [NullableContextAttribute("1")]
internal virtual void FinalizeType(ITypeCompletionContext context);
    protected void MarkInitialized();
    protected void MarkNamed();
    protected void MarkCompleted();
    protected void MarkFinalized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class HotChocolate.Types.TypeSystemObjectBase`1 : TypeSystemObjectBase {
    [NullableAttribute("2")]
private TDefinition _definition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, object> _contextData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> ContextData { get; }
    [NullableAttribute("2")]
protected internal TDefinition Definition { get; protected set; }
    public virtual IReadOnlyDictionary`2<string, object> get_ContextData();
    [NullableContextAttribute("2")]
protected internal TDefinition get_Definition();
    [NullableContextAttribute("2")]
protected void set_Definition(TDefinition value);
    internal sealed virtual void Initialize(ITypeDiscoveryContext context);
    protected abstract virtual TDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, TDefinition definition);
    internal sealed virtual void CompleteName(ITypeCompletionContext context);
    protected virtual void OnCompleteName(ITypeCompletionContext context, TDefinition definition);
    internal sealed virtual void CompleteType(ITypeCompletionContext context);
    internal sealed virtual void FinalizeType(ITypeCompletionContext context);
    protected virtual void OnCompleteType(ITypeCompletionContext context, TDefinition definition);
    private void RegisterConfigurationDependencies(ITypeDiscoveryContext context, TDefinition definition);
    private static void ExecuteConfigurations(ITypeCompletionContext context, TDefinition definition, ApplyConfigurationOn on);
    protected virtual void OnBeforeInitialize(ITypeDiscoveryContext context);
    protected virtual void OnAfterInitialize(ITypeDiscoveryContext context, DefinitionBase definition);
    protected virtual void OnBeforeRegisterDependencies(ITypeDiscoveryContext context, DefinitionBase definition);
    protected virtual void OnAfterRegisterDependencies(ITypeDiscoveryContext context, DefinitionBase definition);
    protected virtual void OnBeforeCompleteName(ITypeCompletionContext context, DefinitionBase definition);
    protected virtual void OnAfterCompleteName(ITypeCompletionContext context, DefinitionBase definition);
    protected virtual void OnBeforeCompleteType(ITypeCompletionContext context, DefinitionBase definition);
    protected virtual void OnAfterCompleteType(ITypeCompletionContext context, DefinitionBase definition);
    protected virtual void OnValidateType(ITypeSystemObjectContext context, DefinitionBase definition);
    private void AssertUninitialized();
    private void AssertInitialized();
    private void AssertNamed();
    protected internal void AssertMutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.UnionType : NamedTypeBase`1<UnionTypeDefinition> {
    private static string _typeReference;
    private Dictionary`2<string, ObjectType> _typeMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IUnionTypeDescriptor> _configure;
    [NullableAttribute("2")]
private ResolveAbstractType _resolveAbstractType;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private UnionTypeDefinitionNode <SyntaxNode>k__BackingField;
    public TypeKind Kind { get; }
    [NullableAttribute("2")]
public UnionTypeDefinitionNode SyntaxNode { get; private set; }
    public IReadOnlyDictionary`2<string, ObjectType> Types { get; }
    private IReadOnlyCollection`1<IObjectType> HotChocolate.Types.IUnionType.Types { get; }
    public UnionType(Action`1<IUnionTypeDescriptor> configure);
    public static UnionType CreateUnsafe(UnionTypeDefinition definition);
    public virtual TypeKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual UnionTypeDefinitionNode get_SyntaxNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SyntaxNode(UnionTypeDefinitionNode value);
    public IReadOnlyDictionary`2<string, ObjectType> get_Types();
    private sealed virtual override IReadOnlyCollection`1<IObjectType> HotChocolate.Types.IUnionType.get_Types();
    public virtual bool IsAssignableFrom(INamedType namedType);
    public bool ContainsType(ObjectType objectType);
    private sealed virtual override bool HotChocolate.Types.IUnionType.ContainsType(IObjectType objectType);
    public sealed virtual bool ContainsType(string typeName);
    public ObjectType ResolveConcreteType(IResolverContext context, object resolverResult);
    private sealed virtual override IObjectType HotChocolate.Types.IUnionType.ResolveConcreteType(IResolverContext context, object resolverResult);
    protected virtual UnionTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IUnionTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, UnionTypeDefinition definition);
    protected virtual void OnCompleteType(ITypeCompletionContext context, UnionTypeDefinition definition);
    private void CompleteTypeSet(ITypeCompletionContext context, UnionTypeDefinition definition);
    protected virtual void OnCompleteTypeSet(ITypeCompletionContext context, UnionTypeDefinition definition, ISet`1<ObjectType> typeSet);
    [NullableContextAttribute("2")]
private void CompleteResolveAbstractType(ResolveAbstractType resolveAbstractType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ObjectType <CompleteResolveAbstractType>b__29_0(IResolverContext c, object r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Types.UnionType`1 : UnionType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IUnionTypeDescriptor> _configure;
    public UnionType`1(Action`1<IUnionTypeDescriptor> configure);
    protected virtual UnionTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class HotChocolate.Types.UnionTypeAttribute : UnionTypeDescriptorAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    public string Name { get; public set; }
    public bool Inherited { get; public set; }
    private TypeKind HotChocolate.Internal.ITypeAttribute.Kind { get; }
    private bool HotChocolate.Internal.ITypeAttribute.IsTypeExtension { get; }
    public UnionTypeAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherited();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Inherited(bool value);
    private sealed virtual override TypeKind HotChocolate.Internal.ITypeAttribute.get_Kind();
    private sealed virtual override bool HotChocolate.Internal.ITypeAttribute.get_IsTypeExtension();
    [NullableContextAttribute("1")]
protected virtual void OnConfigure(IDescriptorContext context, IUnionTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public abstract class HotChocolate.Types.UnionTypeDescriptorAttribute : DescriptorAttribute {
    protected internal sealed virtual void TryConfigure(IDescriptorContext context, IDescriptor descriptor, ICustomAttributeProvider element);
    protected abstract virtual void OnConfigure(IDescriptorContext context, IUnionTypeDescriptor descriptor, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.UnionTypeExtension : NamedTypeExtensionBase`1<UnionTypeDefinition> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IUnionTypeDescriptor> _configure;
    public TypeKind Kind { get; }
    public UnionTypeExtension(Action`1<IUnionTypeDescriptor> configure);
    public static UnionTypeExtension CreateUnsafe(UnionTypeDefinition definition);
    public virtual TypeKind get_Kind();
    protected virtual UnionTypeDefinition CreateDefinition(ITypeDiscoveryContext context);
    protected virtual void Configure(IUnionTypeDescriptor descriptor);
    protected virtual void OnRegisterDependencies(ITypeDiscoveryContext context, UnionTypeDefinition definition);
    protected virtual void Merge(ITypeCompletionContext context, INamedType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.UrlType : ScalarType`2<Uri, StringValueNode> {
    private static string _specifiedBy;
    public UrlType(string name, string description, BindingBehavior bind);
    protected virtual bool IsInstanceOfType(StringValueNode valueSyntax);
    protected virtual Uri ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(Uri runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    private bool TryParseUri(string value, Uri& uri);
}
public class HotChocolate.Types.UseServiceScopeAttribute : ObjectFieldDescriptorAttribute {
    public UseServiceScopeAttribute(int order);
    protected virtual void OnConfigure(IDescriptorContext context, IObjectFieldDescriptor descriptor, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class HotChocolate.Types.UuidType : ScalarType`2<Guid, StringValueNode> {
    private static string _specifiedBy;
    private string _format;
    private bool _enforceFormat;
    public UuidType(char defaultFormat, bool enforceFormat);
    public UuidType(string name, string description, char defaultFormat, bool enforceFormat, BindingBehavior bind);
    protected virtual bool IsInstanceOfType(StringValueNode valueSyntax);
    protected virtual Guid ParseLiteral(StringValueNode valueSyntax);
    protected virtual StringValueNode ParseValue(Guid runtimeValue);
    public virtual IValueNode ParseResult(object resultValue);
    [NullableContextAttribute("2")]
public virtual bool TrySerialize(object runtimeValue, Object& resultValue);
    [NullableContextAttribute("2")]
public virtual bool TryDeserialize(object resultValue, Object& runtimeValue);
    private static string CreateFormatString(char format);
}
[ExtensionAttribute]
public static class HotChocolate.Utilities.AstUtilities : object {
    [ExtensionAttribute]
public static bool TryGetTypeFromAst(ISchema schema, ITypeNode typeNode, T& type);
    private static bool TryGetTypeFromAst(ISchema schema, ITypeNode typeNode, IType& type);
}
public class HotChocolate.Utilities.ChangeType : MulticastDelegate {
    public ChangeType(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual object Invoke(object source);
    public virtual IAsyncResult BeginInvoke(object source, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class HotChocolate.Utilities.ChangeType`2 : MulticastDelegate {
    public ChangeType`2(object object, IntPtr method);
    public virtual TTo Invoke(TFrom source);
    public virtual IAsyncResult BeginInvoke(TFrom source, AsyncCallback callback, object object);
    public virtual TTo EndInvoke(IAsyncResult result);
}
public class HotChocolate.Utilities.ChangeTypeProvider : MulticastDelegate {
    public ChangeTypeProvider(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Type source, Type target, ChangeType& converter);
    public virtual IAsyncResult BeginInvoke(Type source, Type target, ChangeType& converter, AsyncCallback callback, object object);
    public virtual bool EndInvoke(ChangeType& converter, IAsyncResult result);
}
internal class HotChocolate.Utilities.CompilerServices.NullableAttribute : object {
    private Byte[] _flags;
    public ReadOnlySpan`1<byte> Flags { get; }
    public NullableAttribute(byte flag);
    public NullableAttribute(Byte[] flags);
    public ReadOnlySpan`1<byte> get_Flags();
}
internal class HotChocolate.Utilities.CompilerServices.NullableContextAttribute : object {
    public byte Flag;
    public NullableContextAttribute(byte flag);
}
public class HotChocolate.Utilities.ConverterContext : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputType <InputType>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldCollection`1<InputField> <InputFields>k__BackingField;
    [CompilerGeneratedAttribute]
private ILookup`2<string, PropertyInfo> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private ISyntaxNode <Node>k__BackingField;
    public string Name { get; public set; }
    public object Object { get; public set; }
    public Type ClrType { get; public set; }
    public IInputType InputType { get; public set; }
    public FieldCollection`1<InputField> InputFields { get; public set; }
    public ILookup`2<string, PropertyInfo> Fields { get; public set; }
    public ISyntaxNode Node { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(object value);
    [CompilerGeneratedAttribute]
public Type get_ClrType();
    [CompilerGeneratedAttribute]
public void set_ClrType(Type value);
    [CompilerGeneratedAttribute]
public IInputType get_InputType();
    [CompilerGeneratedAttribute]
public void set_InputType(IInputType value);
    [CompilerGeneratedAttribute]
public FieldCollection`1<InputField> get_InputFields();
    [CompilerGeneratedAttribute]
public void set_InputFields(FieldCollection`1<InputField> value);
    [CompilerGeneratedAttribute]
public ILookup`2<string, PropertyInfo> get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(ILookup`2<string, PropertyInfo> value);
    [CompilerGeneratedAttribute]
public ISyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(ISyntaxNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class HotChocolate.Utilities.DefaultTypeConverter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<Type, Type>, ChangeType> _converters;
    private List`1<IChangeTypeProvider> _changeTypeProvider;
    [CompilerGeneratedAttribute]
private static DefaultTypeConverter <Default>k__BackingField;
    private static string _utcFormat;
    private static string _localFormat;
    public static DefaultTypeConverter Default { get; }
    public DefaultTypeConverter(IEnumerable`1<IChangeTypeProvider> providers);
    private static DefaultTypeConverter();
    public sealed virtual object Convert(Type from, Type to, object source);
    public sealed virtual bool TryConvert(Type from, Type to, object source, Object& converted);
    private bool TryConvertInternal(Type from, Type to, object source, Object& converted);
    private bool TryGetOrCreateConverter(Type from, Type to, ChangeType& converter);
    private bool TryCreateConverterFromFactory(Type source, Type target, ChangeType& converter);
    private bool TryGetConverter(Type source, Type target, ChangeType& converter);
    [NullableContextAttribute("2")]
private void Register(ChangeType`2<TSource, TTarget> converter);
    [CompilerGeneratedAttribute]
public static DefaultTypeConverter get_Default();
    private static void RegisterConverters(DefaultTypeConverter registry);
    private static void RegisterDateTimeConversions(DefaultTypeConverter registry);
    private static void RegisterGuidConversions(DefaultTypeConverter registry);
    private static void RegisterUriConversions(DefaultTypeConverter registry);
    private static void RegisterBooleanConversions(DefaultTypeConverter registry);
    private static void RegisterStringConversions(DefaultTypeConverter registry);
    private static void RegisterByteConversions(DefaultTypeConverter registry);
    private static void RegisterSByteConversions(DefaultTypeConverter registry);
    private static void RegisterUInt16Conversions(DefaultTypeConverter registry);
    private static void RegisterUInt32Conversions(DefaultTypeConverter registry);
    private static void RegisterUInt64Conversions(DefaultTypeConverter registry);
    private static void RegisterInt16Conversions(DefaultTypeConverter registry);
    private static void RegisterInt32Conversions(DefaultTypeConverter registry);
    private static void RegisterInt64Conversions(DefaultTypeConverter registry);
    private static void RegisterSingleConversions(DefaultTypeConverter registry);
    private static void RegisterDoubleConversions(DefaultTypeConverter registry);
    private static void RegisterDecimalConversions(DefaultTypeConverter registry);
    private static void RegisterStringListConversions(DefaultTypeConverter registry);
}
public class HotChocolate.Utilities.DictionaryToObjectConverter : DictionaryVisitor`1<ConverterContext> {
    private ITypeConverter _converter;
    public DictionaryToObjectConverter(ITypeConverter converter);
    public object Convert(object from, Type to);
    protected virtual void VisitObject(IReadOnlyDictionary`2<string, object> dictionary, ConverterContext context);
    protected virtual void VisitField(KeyValuePair`2<string, object> field, ConverterContext context);
    protected virtual void VisitList(IReadOnlyList`1<object> list, ConverterContext context);
    protected virtual void VisitValue(object value, ConverterContext context);
}
public class HotChocolate.Utilities.DictionaryVisitor`1 : object {
    protected virtual void Visit(object value, TContext context);
    protected virtual void VisitObject(IReadOnlyDictionary`2<string, object> dictionary, TContext context);
    protected virtual void VisitField(KeyValuePair`2<string, object> field, TContext context);
    protected virtual void VisitList(IReadOnlyList`1<object> list, TContext context);
    protected virtual void VisitValue(object value, TContext context);
}
internal class HotChocolate.Utilities.EnumTypeConverter : object {
    public sealed virtual bool TryCreateConverter(Type source, Type target, ChangeTypeProvider root, ChangeType& converter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Utilities.ErrorHelper : object {
    private static string _interfaceTypeValidation;
    private static string _objectTypeValidation;
    private static string _inputObjectTypeValidation;
    private static string _directiveValidation;
    public static ISchemaError NeedsOneAtLeastField(INamedType type);
    public static ISchemaError TwoUnderscoresNotAllowedField(INamedType type, IField field);
    public static ISchemaError TwoUnderscoresNotAllowedOnArgument(IComplexOutputType type, IOutputField field, IInputField argument);
    public static ISchemaError TwoUnderscoresNotAllowedOnArgument(DirectiveType type, IInputField argument);
    public static ISchemaError TwoUnderscoresNotAllowedOnDirectiveName(DirectiveType type);
    public static ISchemaError NotTransitivelyImplemented(IComplexOutputType type, IComplexOutputType implementedType);
    public static ISchemaError InvalidFieldType(IComplexOutputType type, IOutputField field, IOutputField implementedField);
    public static ISchemaError FieldNotImplemented(IComplexOutputType type, IOutputField implementedField);
    public static ISchemaError InvalidArgumentType(IOutputField field, IOutputField implementedField, IInputField argument, IInputField implementedArgument);
    public static ISchemaError AdditionalArgumentNotNullable(IOutputField field, IOutputField implementedField, IInputField argument);
    public static ISchemaError ArgumentNotImplemented(IOutputField field, IOutputField implementedField, IInputField missingArgument);
    public static ISchemaError OneofInputObjectMustHaveNullableFieldsWithoutDefaults(InputObjectType type, String[] fieldNames);
    public static ISchemaError InputObjectMustNotHaveRecursiveNonNullableReferencesToSelf(InputObjectType type, IEnumerable`1<string> path);
    public static ISchemaError RequiredArgumentCannotBeDeprecated(IComplexOutputType type, IOutputField field, IInputField argument);
    public static ISchemaError RequiredArgumentCannotBeDeprecated(DirectiveType directive, IInputField argument);
    public static ISchemaError RequiredFieldCannotBeDeprecated(IInputObjectType type, IInputField field);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetType(ISchemaErrorBuilder errorBuilder, INamedType type);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetDirective(ISchemaErrorBuilder errorBuilder, DirectiveType type);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetField(ISchemaErrorBuilder errorBuilder, IField field, string name);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetArgument(ISchemaErrorBuilder errorBuilder, IInputField field);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetImplementedType(ISchemaErrorBuilder errorBuilder, IComplexOutputType type);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetImplementedField(ISchemaErrorBuilder errorBuilder, IOutputField field);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetImplementedArgument(ISchemaErrorBuilder errorBuilder, IInputField field);
    [ExtensionAttribute]
private static ISchemaErrorBuilder SetSpecifiedBy(ISchemaErrorBuilder errorBuilder, TypeKind kind, Nullable`1<int> rfc);
    public static ISchemaError InterfaceHasNoImplementation(InterfaceType interfaceType);
    public static ISchemaError CompleteInterfacesHelper_UnableToResolveInterface(ITypeSystemObject interfaceOrObject, ISyntaxNode node);
    public static ISchemaError DirectiveCollection_DirectiveIsUnique(DirectiveType directiveType, ITypeSystemObject type, DirectiveNode syntaxNode, object source);
    public static ISchemaError DirectiveCollection_LocationNotAllowed(DirectiveType directiveType, DirectiveLocation location, ITypeSystemObject type, DirectiveNode syntaxNode, object source);
    public static ISchemaError DirectiveCollection_ArgumentError(DirectiveType directiveType, DirectiveNode syntaxNode, object source, Path path, SerializationException exception);
    public static ISchemaError ObjectType_UnableToInferOrResolveType(string typeName, ObjectType type, ObjectFieldDefinition field);
    public static ISchemaError ObjectField_HasNoResolver(string typeName, string fieldName, ITypeSystemObject type, ISyntaxNode syntaxNode);
    public static ISchemaError MiddlewareOrderInvalid(FieldCoordinate field, ITypeSystemObject type, ISyntaxNode syntaxNode, string currentOrder);
    public static ISchemaError DuplicateDataMiddlewareDetected(FieldCoordinate field, ITypeSystemObject type, ISyntaxNode syntaxNode, IEnumerable`1<string> duplicateMiddleware);
    public static ISchemaError NoSchemaTypesAllowedAsRuntimeType(ITypeSystemObject type, Type runtimeType);
    public static IError Relay_NoNodeResolver(string typeName, Path path, FieldNode fieldNode);
    public static ISchemaError NodeResolver_MustHaveExactlyOneIdArg(string fieldName, ITypeSystemObject type);
    public static ISchemaError NodeResolver_MustReturnObject(string fieldName, ITypeSystemObject type);
    public static ISchemaError NodeResolver_NodeTypeHasNoId(ObjectType type);
    public static ISchemaError NodeResolverMissing(ObjectType type);
    public static IError FetchedToManyNodesAtOnce(FieldNode fieldNode, Path path, int maxAllowedNodes, int requestNodes);
    public static ISchemaError NoFields(ITypeSystemObject typeSystemObj, IType type);
    public static ISchemaError DuplicateFieldName(ITypeSystemObject type, ITypeSystemMember declaringMember, IReadOnlyCollection`1<string> duplicateFieldNames);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Utilities.IChangeTypeProvider {
    public abstract virtual bool TryCreateConverter(Type source, Type target, ChangeTypeProvider root, ChangeType& converter);
}
internal class HotChocolate.Utilities.InputObjectToDictionaryConverter : object {
    private ITypeConverter _converter;
    public InputObjectToDictionaryConverter(ITypeConverter converter);
    public Dictionary`2<string, object> Convert(InputObjectType type, object obj);
    private void VisitValue(IInputType type, object obj, Action`1<object> setValue, ISet`1<object> processed);
    private void VisitInputObject(InputObjectType type, object obj, Action`1<object> setValue, ISet`1<object> processed);
    private void VisitList(ListType type, object obj, Action`1<object> setValue, ISet`1<object> processed);
    private void VisitLeaf(INamedInputType type, object obj, Action`1<object> setValue);
}
[NullableContextAttribute("1")]
public interface HotChocolate.Utilities.ITypeConverter {
    public abstract virtual bool TryConvert(Type from, Type to, object source, Object& converted);
    public abstract virtual object Convert(Type from, Type to, object source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class HotChocolate.Utilities.ListTypeConverter : object {
    private static MethodInfo _dictionaryConvert;
    private static MethodInfo _setConvert;
    private static MethodInfo _collectionConvert;
    private static ListTypeConverter();
    public sealed virtual bool TryCreateConverter(Type source, Type target, ChangeTypeProvider root, ChangeType& converter);
    private static void ChangeListType(IEnumerable source, Action`2<object, int> addToDestination);
    private static object GenericArrayConverter(ICollection input, Type elementType, ChangeType elementConverter);
    private static object GenericListConverter(ICollection input, Type listType, ChangeType elementConverter);
    [NullableContextAttribute("2")]
private static object GenericCollectionConverter(ICollection input, Type listType, ChangeType elementConverter);
    [NullableContextAttribute("2")]
private static object GenericDictionaryConverter(ICollection input, ChangeType elementConverter);
    [NullableContextAttribute("2")]
private static object HashSetConverter(ICollection input, ChangeType elementConverter);
    private static bool IsGenericCollection(Type type);
}
internal enum HotChocolate.Utilities.Nullable : Enum {
    public byte value__;
    public static Nullable Skip;
    public static Nullable Yes;
    public static Nullable No;
    public static Nullable Undefined;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class HotChocolate.Utilities.NullableHelper : ValueType {
    private static string _nullableContextAttributeName;
    private static string _nullableAttributeName;
    private Nullable`1<bool> _context;
    public NullableHelper(Type type);
    public static bool IsParameterNullable(ParameterInfo parameter);
    public Nullable`1<bool> GetContext(MemberInfo member);
    private Nullable`1<bool> GetContext(ParameterInfo parameter);
    [NullableContextAttribute("2")]
private Nullable`1<bool> GetContext(NullableContextAttribute attribute);
    [NullableContextAttribute("2")]
private static Nullable`1<bool> GetContext(NullableContextAttribute attribute, Nullable`1<bool> parent);
    public Nullable`1[] GetFlags(MemberInfo member);
    public Nullable`1[] GetFlags(ParameterInfo parameter);
    private static Nullable`1[] GetFlags(NullableAttribute attribute);
    private static NullableContextAttribute GetNullableContextAttribute(MemberInfo member);
    private static NullableContextAttribute GetNullableContextAttribute(ParameterInfo member);
    private static NullableContextAttribute GetNullableContextAttribute(Assembly assembly);
    private static NullableContextAttribute GetNullableContextAttribute(IList`1<CustomAttributeData> attributes);
    private static NullableAttribute GetNullableAttribute(MethodInfo method);
    private static NullableAttribute GetNullableAttribute(MemberInfo member);
    private static NullableAttribute GetNullableAttribute(ParameterInfo parameter);
    private static NullableAttribute GetNullableAttribute(IList`1<CustomAttributeData> attributes);
}
public class HotChocolate.Utilities.NullableTypeConverter : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryCreateConverter(Type source, Type target, ChangeTypeProvider root, ChangeType& converter);
    [NullableContextAttribute("1")]
private Type GetUnderlyingNullableType(Type type);
}
internal class HotChocolate.Utilities.ObjectToDictionaryConverter : object {
    private ITypeConverter _converter;
    private ConcurrentDictionary`2<Type, PropertyInfo[]> _properties;
    public ObjectToDictionaryConverter(ITypeConverter converter);
    public object Convert(object obj);
    private void VisitValue(object obj, Action`1<object> setValue, HashSet`1<object> processed);
    private void VisitObject(object obj, Action`1<object> setValue, HashSet`1<object> processed);
    private void VisitList(ICollection list, Action`1<object> setValue, HashSet`1<object> processed);
    private ReadOnlySpan`1<PropertyInfo> GetProperties(object value);
}
public class HotChocolate.Utilities.ObjectValueToDictionaryConverter : SyntaxWalkerBase`2<IValueNode, Action`1<object>> {
    public Dictionary`2<string, object> Convert(ObjectValueNode objectValue);
    public List`1<object> Convert(ListValueNode listValue);
    protected virtual void VisitObjectValue(ObjectValueNode node, Action`1<object> setValue);
    protected virtual void VisitListValue(ListValueNode node, Action`1<object> setValue);
    protected virtual void VisitIntValue(IntValueNode node, Action`1<object> setValue);
    protected virtual void VisitFloatValue(FloatValueNode node, Action`1<object> setValue);
    protected virtual void VisitStringValue(StringValueNode node, Action`1<object> setValue);
    protected virtual void VisitBooleanValue(BooleanValueNode node, Action`1<object> setValue);
    protected virtual void VisitEnumValue(EnumValueNode node, Action`1<object> setValue);
    protected virtual void VisitNullValue(NullValueNode node, Action`1<object> setValue);
}
[ExtensionAttribute]
public static class HotChocolate.Utilities.ReflectionUtils : object {
    [ExtensionAttribute]
public static MemberInfo TryExtractMember(Expression`1<Func`2<T, TPropertyType>> memberExpression, bool allowStatic);
    [ExtensionAttribute]
internal static MemberInfo TryExtractCallMember(Expression expression);
    private static MemberInfo TryExtractMemberInternal(Expression expression, bool allowStatic);
    [ExtensionAttribute]
public static MethodInfo ExtractMethod(Expression`1<Action`1<T>> memberExpression, bool allowStatic);
    [ExtensionAttribute]
public static MemberInfo ExtractMember(Expression`1<Action`1<T>> memberExpression, bool allowStatic);
    [ExtensionAttribute]
public static MemberInfo ExtractMember(Expression`1<Func`2<T, TPropertyType>> memberExpression, bool allowStatic);
    private static MemberInfo ExtractMemberInternal(Expression expression, bool allowStatic);
    private static Expression UnwrapAction(Expression`1<Action`1<T>> memberExpression);
    private static bool TryExtractMemberFromMemberExpression(Type type, Expression memberExpression, bool allowStatic, MemberInfo& member);
    private static Expression UnwrapFunc(Expression`1<Func`2<T, TPropertyType>> memberExpression);
    private static MemberInfo ExtractMember(Type type, Expression unwrappedExpr, bool allowStatic);
    private static bool TryExtractMemberFromMemberCallExpression(Type type, Expression memberExpression, bool allowStatic, MemberInfo& member);
    private static bool IsInstanceMethod(Type type, MethodInfo method);
    private static bool IsStaticMethod(MethodInfo method);
    [ExtensionAttribute]
public static string GetTypeName(Type type);
    private static string CreateGenericTypeName(Type type);
    private static string CreateTypeName(Type type, string typeName);
    private static string GetNamespace(Type type);
    [ExtensionAttribute]
public static Type GetReturnType(MemberInfo member);
    public static Dictionary`2<string, PropertyInfo> GetProperties(Type type);
    private static void AddProperties(Func`2<string, bool> exists, Action`2<string, PropertyInfo> add, Type type);
    private static bool IsIgnored(MemberInfo member);
    private static MethodInfo GetBestMatchingMethod(Type type, MethodInfo method);
    private static PropertyInfo GetBestMatchingProperty(Type type, PropertyInfo property);
    [ExtensionAttribute]
public static ILookup`2<string, PropertyInfo> CreatePropertyLookup(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Utilities.Serialization.InputObjectCompiler : object {
    private static ParameterExpression _obj;
    private static ParameterExpression _fieldValues;
    private static InputObjectCompiler();
    public static Func`2<Object[], object> CompileFactory(InputObjectType inputType, ConstructorInfo constructor);
    public static Func`2<Object[], object> CompileFactory(DirectiveType directiveType, ConstructorInfo constructor);
    public static Action`2<object, Object[]> CompileGetFieldValues(InputObjectType inputType);
    public static Action`2<object, Object[]> CompileGetFieldValues(DirectiveType inputType);
    private static Expression CreateInstance(Dictionary`2<string, T> fields, ConstructorInfo constructor, Expression fieldValues);
    private static Expression[] CompileAssignParameters(Dictionary`2<string, T> fields, ConstructorInfo constructor, Expression fieldValues);
    private static void CompileSetProperties(Expression instance, IEnumerable`1<T> fields, Expression fieldValues, List`1<Expression> currentBlock);
    private static Expression GetFieldValue(T field, Expression fieldValues);
    private static Expression SetFieldValue(IInputField field, Expression fieldValues, Expression fieldValue);
    private static bool FieldsAreUnique(InputObjectType type, HashSet`1<string> nameSetIgnoreCase);
    private static bool FieldsAreUnique(DirectiveType type, HashSet`1<string> nameSetIgnoreCase);
    private static void BuildFieldMap(InputObjectType type, Dictionary`2<string, InputField> fields);
    private static void BuildFieldMap(DirectiveType type, Dictionary`2<string, DirectiveArgument> fields);
    private static Expression CreateOptional(Expression fieldValue, Type runtimeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class HotChocolate.Utilities.Serialization.InputObjectConstructorResolver : object {
    public static ConstructorInfo GetCompatibleConstructor(Type type, FieldCollection`1<T> fields, Dictionary`2<string, T> fieldMap, HashSet`1<string> required);
    private static bool AllPropertiesCanWrite(FieldCollection`1<T> fields);
    private static bool IsCompatibleConstructor(ConstructorInfo constructor, IReadOnlyDictionary`2<string, T> fields, HashSet`1<string> required);
    private static void CollectReadOnlyProperties(FieldCollection`1<T> fields, ISet`1<string> required);
    [ExtensionAttribute]
public static bool TryGetParameter(IReadOnlyDictionary`2<string, T> fields, ParameterInfo parameter, T& field);
    private static string GetAlternativeParameterName(string name);
}
internal class HotChocolate.Utilities.Subscriptions.ObservableSourceStreamAdapter`1 : object {
    private ConcurrentQueue`1<T> _queue;
    private IDisposable _subscription;
    private TaskCompletionSource`1<object> _wait;
    private Exception _exception;
    private bool _isCompleted;
    public ObservableSourceStreamAdapter`1(IObservable`1<T> observable);
    [AsyncIteratorStateMachineAttribute("HotChocolate.Utilities.Subscriptions.ObservableSourceStreamAdapter`1/<GetAsyncEnumerator>d__6")]
public sealed virtual IAsyncEnumerator`1<object> GetAsyncEnumerator(CancellationToken cancellationToken);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    [CompilerGeneratedAttribute]
private void <GetAsyncEnumerator>b__6_0();
}
internal class HotChocolate.Utilities.Subscriptions.SourceStreamWrapper : object {
    private IAsyncEnumerable`1<object> _stream;
    public SourceStreamWrapper(IAsyncEnumerable`1<object> stream);
    public sealed virtual IAsyncEnumerable`1<object> ReadEventsAsync();
    public sealed virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class HotChocolate.Utilities.ThrowHelper : object {
    [NullableContextAttribute("0")]
public static ArgumentException String_NullOrEmpty(string parameterName);
    [NullableContextAttribute("0")]
public static GraphQLException EventMessage_InvalidCast(Type expectedType, Type messageType);
    [NullableContextAttribute("0")]
public static GraphQLException EventMessage_NotFound();
    [NullableContextAttribute("0")]
public static SchemaException SubscribeAttribute_MessageTypeUnspecified(MemberInfo member);
    [NullableContextAttribute("0")]
public static SchemaException SubscribeAttribute_TopicTypeUnspecified(MemberInfo member);
    [NullableContextAttribute("0")]
public static SchemaException SubscribeAttribute_SubscribeResolverNotFound(MemberInfo member, string subscribeResolverName);
    [NullableContextAttribute("0")]
public static SchemaException Convention_UnableToCreateConvention(Type convention);
    [NullableContextAttribute("0")]
public static SchemaException UsePagingAttribute_NodeTypeUnknown(MemberInfo member);
    [NullableContextAttribute("0")]
public static SchemaException TypeRegistrar_CreateInstanceFailed(Type namedSchemaType, Exception exception);
    [NullableContextAttribute("0")]
public static SchemaException TypeCompletionContext_UnableToResolveType(ITypeSystemObject type, TypeReference typeRef);
    [NullableContextAttribute("0")]
public static SchemaException TypeInitializer_DuplicateTypeName(ITypeSystemObject type, ITypeSystemObject otherType);
    [NullableContextAttribute("0")]
public static SchemaException TypeInitializer_MutationDuplicateErrorName(ITypeSystemObject type, string mutationName, string errorName, IReadOnlyList`1<ISchemaError> originalErrors);
    [NullableContextAttribute("0")]
public static SchemaException NodeAttribute_IdFieldNotFound(Type type, string idField);
    public static SchemaException Convention_TwoConventionsRegisteredForScope(Type conventionType, IConvention first, IConvention other, string scope);
    public static SchemaException Convention_ConventionCouldNotBeCreated(Type conventionType, string scope);
    public static SchemaException DataLoader_InvalidType(Type dataLoaderType);
    public static SchemaException NonGenericExecutableNotAllowed();
    public static SerializationException RequiredInputFieldIsMissing(IInputField field, Path fieldPath);
    public static SerializationException InvalidInputFieldNames(T type, IReadOnlyList`1<string> invalidFieldNames, Path path);
    public static SerializationException OneOfNoFieldSet(InputObjectType type, Path path);
    public static SerializationException OneOfMoreThanOneFieldSet(InputObjectType type, Path path);
    public static SerializationException OneOfFieldIsNull(InputObjectType type, Path path, InputField field);
    public static SerializationException NonNullInputViolation(ITypeSystemMember type, Path path, IInputField field);
    public static SerializationException ParseInputObject_InvalidSyntaxKind(InputObjectType type, SyntaxKind kind, Path path);
    public static SerializationException ParseInputObject_InvalidObjectKind(InputObjectType type, Type objectType, Path path);
    public static SerializationException ParseNestedList_InvalidSyntaxKind(ListType type, SyntaxKind kind, Path path);
    public static SerializationException ParseList_InvalidObjectKind(ListType type, Type listType, Path path);
    public static SerializationException FormatValueList_InvalidObjectKind(ListType type, Type listType, Path path);
    public static SerializationException FormatResultObject_InvalidObjectKind(InputObjectType type, Type objectType, Path path);
    public static SerializationException FormatResultList_InvalidObjectKind(ListType type, Type listType, Path path);
    public static SerializationException FormatResultLeaf_InvalidSyntaxKind(IType type, SyntaxKind kind, Path path);
    public static InvalidOperationException RewriteNullability_InvalidNullabilityStructure();
    public static InvalidSchemaCoordinateException Schema_GetMember_DirectiveArgumentNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_DirectiveNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_EnumValueNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_InputFieldNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_InvalidCoordinate(SchemaCoordinate coordinate, INamedType type);
    public static InvalidSchemaCoordinateException Schema_GetMember_FieldArgNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_FieldNotFound(SchemaCoordinate coordinate);
    public static InvalidSchemaCoordinateException Schema_GetMember_TypeNotFound(SchemaCoordinate coordinate);
    public static InvalidOperationException FieldBase_Sealed();
    public static InvalidOperationException NodeResolver_ArgumentTypeMissing();
    public static InvalidOperationException NodeResolver_ObjNoDefinition();
    public static SchemaException RelayIdFieldHelpers_NoFieldType(string fieldName, ITypeSystemObject type);
    public static GraphQLException MissingIfArgument(DirectiveNode directive);
    public static InvalidOperationException Flags_Enum_Shape_Unknown(Type type);
    public static GraphQLException Flags_Parser_NoSelection(InputObjectType type);
    public static GraphQLException Flags_Parser_UnknownSelection(string value, InputObjectType type);
    public static SchemaException Flags_IllegalFlagEnumName(Type type, string valueName);
    public static SchemaException InputTypeExpected(IType type);
    public static SchemaException OutputTypeExpected(IType type);
}
[ExtensionAttribute]
public static class HotChocolate.Utilities.TypeConverterExtensions : object {
    [ExtensionAttribute]
public static bool TryConvert(ITypeConverter typeConverter, Type to, object source, Object& converted);
    [ExtensionAttribute]
public static bool TryConvert(ITypeConverter typeConverter, TFrom source, TTo& converted);
    [ExtensionAttribute]
public static TTo Convert(ITypeConverter typeConverter, object source);
}
internal static class HotChocolate.Utilities.TypeFactoryHelper : object {
    [CompilerGeneratedAttribute]
private static INamedType <PlaceHolder>k__BackingField;
    public static INamedType PlaceHolder { get; }
    private static TypeFactoryHelper();
    [CompilerGeneratedAttribute]
public static INamedType get_PlaceHolder();
    public static bool IsTypeStructureValid(IType type);
    public static bool IsTypeStructureValid(IType type, int listCount);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
