internal class Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BitAccess : object {
    private Byte[] buffer;
    private int offset;
    internal Byte[] Buffer { get; }
    internal int Position { get; internal set; }
    internal BitAccess(Byte[] buffer);
    internal BitAccess(int capacity);
    internal Byte[] get_Buffer();
    internal void FillBuffer(Stream stream, int capacity);
    internal void Append(Stream stream, int count);
    internal int get_Position();
    internal void set_Position(int value);
    internal void MinCapacity(int capacity);
    internal void Align(int alignment);
    internal void ReadInt16(Int16& value);
    internal void ReadInt8(SByte& value);
    internal void ReadInt32(Int32& value);
    internal void ReadInt64(Int64& value);
    internal void ReadUInt16(UInt16& value);
    internal void ReadUInt8(Byte& value);
    internal void ReadUInt32(UInt32& value);
    internal void ReadUInt64(UInt64& value);
    internal void ReadInt32(Int32[] values);
    internal void ReadUInt32(UInt32[] values);
    internal void ReadBytes(Byte[] bytes);
    internal float ReadFloat();
    internal double ReadDouble();
    internal decimal ReadDecimal();
    internal void ReadBString(String& value);
    internal string ReadBString(int len);
    internal void ReadCString(String& value);
    internal void SkipCString(String& value);
    internal void ReadGuid(Guid& guid);
    internal string ReadString();
}
internal class Microsoft.Cci.Pdb.BitSet : ValueType {
    private int size;
    private UInt32[] words;
    internal bool IsEmpty { get; }
    internal BitSet(BitAccess bits);
    internal bool IsSet(int index);
    private static UInt32 GetBit(int index);
    internal bool get_IsEmpty();
}
internal class Microsoft.Cci.Pdb.BlockSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
    public int value__;
    public static CV_CFL_CODE CV_CFL_CNEAR;
    public static CV_CFL_CODE CV_CFL_CFAR;
    public static CV_CFL_CODE CV_CFL_CHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
    public int value__;
    public static CV_CFL_DATA CV_CFL_DNEAR;
    public static CV_CFL_DATA CV_CFL_DFAR;
    public static CV_CFL_DATA CV_CFL_DHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
    public int value__;
    public static CV_CFL_FPKG CV_CFL_NDP;
    public static CV_CFL_FPKG CV_CFL_EMU;
    public static CV_CFL_FPKG CV_CFL_ALT;
}
internal class Microsoft.Cci.Pdb.CV_Column : ValueType {
    internal ushort offColumnStart;
    internal ushort offColumnEnd;
}
internal enum Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
    public byte value__;
    public static CV_FILE_CHECKSUM_TYPE None;
    public static CV_FILE_CHECKSUM_TYPE MD5;
}
internal class Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
    internal UInt32 name;
    internal byte len;
    internal byte type;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_fldattr : Enum {
    public int value__;
    public static CV_fldattr access;
    public static CV_fldattr mprop;
    public static CV_fldattr pseudo;
    public static CV_fldattr noinherit;
    public static CV_fldattr noconstruct;
    public static CV_fldattr compgenx;
}
internal enum Microsoft.Cci.Pdb.CV_int : Enum {
    public int value__;
    public static CV_int CV_RI_CHAR;
    public static CV_int CV_RI_INT1;
    public static CV_int CV_RI_WCHAR;
    public static CV_int CV_RI_UINT1;
    public static CV_int CV_RI_INT2;
    public static CV_int CV_RI_UINT2;
    public static CV_int CV_RI_INT4;
    public static CV_int CV_RI_UINT4;
    public static CV_int CV_RI_INT8;
    public static CV_int CV_RI_UINT8;
    public static CV_int CV_RI_INT16;
    public static CV_int CV_RI_UINT16;
}
internal enum Microsoft.Cci.Pdb.CV_integral : Enum {
    public int value__;
    public static CV_integral CV_IN_1BYTE;
    public static CV_integral CV_IN_2BYTE;
    public static CV_integral CV_IN_4BYTE;
    public static CV_integral CV_IN_8BYTE;
    public static CV_integral CV_IN_16BYTE;
}
internal enum Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
    public int value__;
    public static CV_LABEL_TYPE CV_LABEL_NEAR;
    public static CV_LABEL_TYPE CV_LABEL_FAR;
}
internal class Microsoft.Cci.Pdb.CV_Line : ValueType {
    internal UInt32 offset;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags linenumStart;
    public static CV_Line_Flags deltaLineEnd;
    public static CV_Line_Flags fStatement;
}
internal enum Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
    public ushort value__;
    public static CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS;
}
internal class Microsoft.Cci.Pdb.CV_LineSection : ValueType {
    internal UInt32 off;
    internal ushort sec;
    internal ushort flags;
    internal UInt32 cod;
}
internal enum Microsoft.Cci.Pdb.CV_methodprop : Enum {
    public int value__;
    public static CV_methodprop CV_MTvanilla;
    public static CV_methodprop CV_MTvirtual;
    public static CV_methodprop CV_MTstatic;
    public static CV_methodprop CV_MTfriend;
    public static CV_methodprop CV_MTintro;
    public static CV_methodprop CV_MTpurevirt;
    public static CV_methodprop CV_MTpureintro;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_modifier : Enum {
    public ushort value__;
    public static CV_modifier MOD_const;
    public static CV_modifier MOD_volatile;
    public static CV_modifier MOD_unaligned;
}
internal enum Microsoft.Cci.Pdb.CV_pmtype : Enum {
    public int value__;
    public static CV_pmtype CV_PMTYPE_Undef;
    public static CV_pmtype CV_PMTYPE_D_Single;
    public static CV_pmtype CV_PMTYPE_D_Multiple;
    public static CV_pmtype CV_PMTYPE_D_Virtual;
    public static CV_pmtype CV_PMTYPE_D_General;
    public static CV_pmtype CV_PMTYPE_F_Single;
    public static CV_pmtype CV_PMTYPE_F_Multiple;
    public static CV_pmtype CV_PMTYPE_F_Virtual;
    public static CV_pmtype CV_PMTYPE_F_General;
}
internal class Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
    private static UInt32 CV_MMASK;
    private static UInt32 CV_TMASK;
    private static UInt32 CV_SMASK;
    private static int CV_MSHIFT;
    private static int CV_TSHIFT;
    private static int CV_SSHIFT;
    private static UInt32 CV_FIRST_NONPRIM;
}
internal enum Microsoft.Cci.Pdb.CV_prmode : Enum {
    public int value__;
    public static CV_prmode CV_TM_DIRECT;
    public static CV_prmode CV_TM_NPTR32;
    public static CV_prmode CV_TM_NPTR64;
    public static CV_prmode CV_TM_NPTR128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
    public byte value__;
    public static CV_PROCFLAGS CV_PFLAG_NOFPO;
    public static CV_PROCFLAGS CV_PFLAG_INT;
    public static CV_PROCFLAGS CV_PFLAG_FAR;
    public static CV_PROCFLAGS CV_PFLAG_NEVER;
    public static CV_PROCFLAGS CV_PFLAG_NOTREACHED;
    public static CV_PROCFLAGS CV_PFLAG_CUST_CALL;
    public static CV_PROCFLAGS CV_PFLAG_NOINLINE;
    public static CV_PROCFLAGS CV_PFLAG_OPTDBGINFO;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_prop : Enum {
    public ushort value__;
    public static CV_prop packed;
    public static CV_prop ctor;
    public static CV_prop ovlops;
    public static CV_prop isnested;
    public static CV_prop cnested;
    public static CV_prop opassign;
    public static CV_prop opcast;
    public static CV_prop fwdref;
    public static CV_prop scoped;
}
internal enum Microsoft.Cci.Pdb.CV_ptrmode : Enum {
    public int value__;
    public static CV_ptrmode CV_PTR_MODE_PTR;
    public static CV_ptrmode CV_PTR_MODE_REF;
    public static CV_ptrmode CV_PTR_MODE_PMEM;
    public static CV_ptrmode CV_PTR_MODE_PMFUNC;
    public static CV_ptrmode CV_PTR_MODE_RESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_ptrtype : Enum {
    public int value__;
    public static CV_ptrtype CV_PTR_BASE_SEG;
    public static CV_ptrtype CV_PTR_BASE_VAL;
    public static CV_ptrtype CV_PTR_BASE_SEGVAL;
    public static CV_ptrtype CV_PTR_BASE_ADDR;
    public static CV_ptrtype CV_PTR_BASE_SEGADDR;
    public static CV_ptrtype CV_PTR_BASE_TYPE;
    public static CV_ptrtype CV_PTR_BASE_SELF;
    public static CV_ptrtype CV_PTR_NEAR32;
    public static CV_ptrtype CV_PTR_64;
    public static CV_ptrtype CV_PTR_UNUSEDPTR;
}
internal enum Microsoft.Cci.Pdb.CV_real : Enum {
    public int value__;
    public static CV_real CV_RC_REAL32;
    public static CV_real CV_RC_REAL64;
    public static CV_real CV_RC_REAL80;
    public static CV_real CV_RC_REAL128;
}
internal enum Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
    public int value__;
    public static CV_SIGNATURE C6;
    public static CV_SIGNATURE C7;
    public static CV_SIGNATURE C11;
    public static CV_SIGNATURE C13;
    public static CV_SIGNATURE RESERVERD;
}
internal class Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
    internal UInt32 index;
    internal UInt32 count;
    internal UInt32 linsiz;
}
internal enum Microsoft.Cci.Pdb.CV_special : Enum {
    public int value__;
    public static CV_special CV_SP_NOTYPE;
    public static CV_special CV_SP_ABS;
    public static CV_special CV_SP_SEGMENT;
    public static CV_special CV_SP_VOID;
    public static CV_special CV_SP_CURRENCY;
    public static CV_special CV_SP_NBASICSTR;
    public static CV_special CV_SP_FBASICSTR;
    public static CV_special CV_SP_NOTTRANS;
    public static CV_special CV_SP_HRESULT;
}
internal enum Microsoft.Cci.Pdb.CV_special2 : Enum {
    public int value__;
    public static CV_special2 CV_S2_BIT;
    public static CV_special2 CV_S2_PASCHAR;
}
internal enum Microsoft.Cci.Pdb.CV_type : Enum {
    public int value__;
    public static CV_type CV_SPECIAL;
    public static CV_type CV_SIGNED;
    public static CV_type CV_UNSIGNED;
    public static CV_type CV_BOOLEAN;
    public static CV_type CV_REAL;
    public static CV_type CV_COMPLEX;
    public static CV_type CV_SPECIAL2;
    public static CV_type CV_INT;
    public static CV_type CV_CVRESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
    public int value__;
    public static CV_VTS_desc CV_VTS_near;
    public static CV_VTS_desc CV_VTS_far;
    public static CV_VTS_desc CV_VTS_thin;
    public static CV_VTS_desc CV_VTS_outer;
    public static CV_VTS_desc CV_VTS_meta;
    public static CV_VTS_desc CV_VTS_near32;
    public static CV_VTS_desc CV_VTS_far32;
    public static CV_VTS_desc CV_VTS_unused;
}
internal class Microsoft.Cci.Pdb.DataStream : object {
    internal int contentSize;
    internal Int32[] pages;
    internal int Length { get; }
    internal DataStream(int contentSize, BitAccess bits, int count);
    internal void Read(PdbReader reader, BitAccess bits);
    internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data);
    internal int get_Length();
}
internal class Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
    internal ushort snFPO;
    internal ushort snException;
    internal ushort snFixup;
    internal ushort snOmapToSrc;
    internal ushort snOmapFromSrc;
    internal ushort snSectionHdr;
    internal ushort snTokenRidMap;
    internal ushort snXdata;
    internal ushort snPdata;
    internal ushort snNewFPO;
    internal ushort snSectionHdrOrig;
    internal DbiDbgHdr(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiHeader : ValueType {
    internal int sig;
    internal int ver;
    internal int age;
    internal short gssymStream;
    internal ushort vers;
    internal short pssymStream;
    internal ushort pdbver;
    internal short symrecStream;
    internal ushort pdbver2;
    internal int gpmodiSize;
    internal int secconSize;
    internal int secmapSize;
    internal int filinfSize;
    internal int tsmapSize;
    internal int mfcIndex;
    internal int dbghdrSize;
    internal int ecinfoSize;
    internal ushort flags;
    internal ushort machine;
    internal int reserved;
    internal DbiHeader(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiModuleInfo : object {
    internal int opened;
    internal ushort flags;
    internal short stream;
    internal int cbSyms;
    internal int cbOldLines;
    internal int cbLines;
    internal short files;
    internal short pad1;
    internal UInt32 offsets;
    internal int niSource;
    internal int niCompiler;
    internal string moduleName;
    internal string objectName;
    internal DbiModuleInfo(BitAccess bits, bool readStrings);
}
internal class Microsoft.Cci.Pdb.DbiSecCon : ValueType {
    internal short section;
    internal short pad1;
    internal int offset;
    internal int size;
    internal UInt32 flags;
    internal short module;
    internal short pad2;
    internal UInt32 dataCrc;
    internal UInt32 relocCrc;
    internal DbiSecCon(BitAccess bits);
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
    public int value__;
    public static DEBUG_S_SUBSECTION SYMBOLS;
    public static DEBUG_S_SUBSECTION LINES;
    public static DEBUG_S_SUBSECTION STRINGTABLE;
    public static DEBUG_S_SUBSECTION FILECHKSMS;
    public static DEBUG_S_SUBSECTION FRAMEDATA;
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
    public UInt32 value__;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEDATA_FLAGS fHasSEH;
    public static FRAMEDATA_FLAGS fHasEH;
    public static FRAMEDATA_FLAGS fIsFunctionStart;
}
public interface Microsoft.Cci.Pdb.ILocalScope {
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public Method MethodDefinition { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Length();
    public abstract virtual Method get_MethodDefinition();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.Pdb.IntHashTable : object {
    private static Int32[] primes;
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private int loadFactorPerc;
    private int version;
    internal object Item { get; }
    internal IntHashTable(int capacity, int loadFactorPerc);
    private static IntHashTable();
    private static int GetPrime(int minSize);
    private static UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr);
    internal void Add(int key, object value);
    internal object get_Item(int key);
    private void expand();
    private void rehash();
    private void rehash(int newsize);
    private void Insert(int key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode);
}
internal enum Microsoft.Cci.Pdb.LEAF : Enum {
    public int value__;
    public static LEAF LF_VTSHAPE;
    public static LEAF LF_COBOL1;
    public static LEAF LF_LABEL;
    public static LEAF LF_NULL;
    public static LEAF LF_NOTTRAN;
    public static LEAF LF_ENDPRECOMP;
    public static LEAF LF_TYPESERVER_ST;
    public static LEAF LF_LIST;
    public static LEAF LF_REFSYM;
    public static LEAF LF_ENUMERATE_ST;
    public static LEAF LF_TI16_MAX;
    public static LEAF LF_MODIFIER;
    public static LEAF LF_POINTER;
    public static LEAF LF_ARRAY_ST;
    public static LEAF LF_CLASS_ST;
    public static LEAF LF_STRUCTURE_ST;
    public static LEAF LF_UNION_ST;
    public static LEAF LF_ENUM_ST;
    public static LEAF LF_PROCEDURE;
    public static LEAF LF_MFUNCTION;
    public static LEAF LF_COBOL0;
    public static LEAF LF_BARRAY;
    public static LEAF LF_DIMARRAY_ST;
    public static LEAF LF_VFTPATH;
    public static LEAF LF_PRECOMP_ST;
    public static LEAF LF_OEM;
    public static LEAF LF_ALIAS_ST;
    public static LEAF LF_OEM2;
    public static LEAF LF_SKIP;
    public static LEAF LF_ARGLIST;
    public static LEAF LF_DEFARG_ST;
    public static LEAF LF_FIELDLIST;
    public static LEAF LF_DERIVED;
    public static LEAF LF_BITFIELD;
    public static LEAF LF_METHODLIST;
    public static LEAF LF_DIMCONU;
    public static LEAF LF_DIMCONLU;
    public static LEAF LF_DIMVARU;
    public static LEAF LF_DIMVARLU;
    public static LEAF LF_BCLASS;
    public static LEAF LF_VBCLASS;
    public static LEAF LF_IVBCLASS;
    public static LEAF LF_FRIENDFCN_ST;
    public static LEAF LF_INDEX;
    public static LEAF LF_MEMBER_ST;
    public static LEAF LF_STMEMBER_ST;
    public static LEAF LF_METHOD_ST;
    public static LEAF LF_NESTTYPE_ST;
    public static LEAF LF_VFUNCTAB;
    public static LEAF LF_FRIENDCLS;
    public static LEAF LF_ONEMETHOD_ST;
    public static LEAF LF_VFUNCOFF;
    public static LEAF LF_NESTTYPEEX_ST;
    public static LEAF LF_MEMBERMODIFY_ST;
    public static LEAF LF_MANAGED_ST;
    public static LEAF LF_ST_MAX;
    public static LEAF LF_TYPESERVER;
    public static LEAF LF_ENUMERATE;
    public static LEAF LF_ARRAY;
    public static LEAF LF_CLASS;
    public static LEAF LF_STRUCTURE;
    public static LEAF LF_UNION;
    public static LEAF LF_ENUM;
    public static LEAF LF_DIMARRAY;
    public static LEAF LF_PRECOMP;
    public static LEAF LF_ALIAS;
    public static LEAF LF_DEFARG;
    public static LEAF LF_FRIENDFCN;
    public static LEAF LF_MEMBER;
    public static LEAF LF_STMEMBER;
    public static LEAF LF_METHOD;
    public static LEAF LF_NESTTYPE;
    public static LEAF LF_ONEMETHOD;
    public static LEAF LF_NESTTYPEEX;
    public static LEAF LF_MEMBERMODIFY;
    public static LEAF LF_MANAGED;
    public static LEAF LF_TYPESERVER2;
    public static LEAF LF_NUMERIC;
    public static LEAF LF_CHAR;
    public static LEAF LF_SHORT;
    public static LEAF LF_USHORT;
    public static LEAF LF_LONG;
    public static LEAF LF_ULONG;
    public static LEAF LF_REAL32;
    public static LEAF LF_REAL64;
    public static LEAF LF_REAL80;
    public static LEAF LF_REAL128;
    public static LEAF LF_QUADWORD;
    public static LEAF LF_UQUADWORD;
    public static LEAF LF_COMPLEX32;
    public static LEAF LF_COMPLEX64;
    public static LEAF LF_COMPLEX80;
    public static LEAF LF_COMPLEX128;
    public static LEAF LF_VARSTRING;
    public static LEAF LF_OCTWORD;
    public static LEAF LF_UOCTWORD;
    public static LEAF LF_DECIMAL;
    public static LEAF LF_DATE;
    public static LEAF LF_UTF8STRING;
    public static LEAF LF_PAD0;
    public static LEAF LF_PAD1;
    public static LEAF LF_PAD2;
    public static LEAF LF_PAD3;
    public static LEAF LF_PAD4;
    public static LEAF LF_PAD5;
    public static LEAF LF_PAD6;
    public static LEAF LF_PAD7;
    public static LEAF LF_PAD8;
    public static LEAF LF_PAD9;
    public static LEAF LF_PAD10;
    public static LEAF LF_PAD11;
    public static LEAF LF_PAD12;
    public static LEAF LF_PAD13;
    public static LEAF LF_PAD14;
    public static LEAF LF_PAD15;
}
internal class Microsoft.Cci.Pdb.ManProcSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal ushort retReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.MsfDirectory : object {
    internal DataStream[] streams;
    internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.OemSymbol : ValueType {
    internal Guid idOem;
    internal UInt32 typind;
    internal Byte[] rgl;
}
internal class Microsoft.Cci.Pdb.PdbConstant : object {
    internal string name;
    internal UInt32 token;
    internal object value;
    internal PdbConstant(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbDebugException : IOException {
    internal PdbDebugException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbFile : object {
    private static PdbFunction match;
    private static PdbFile();
    private static void LoadGuidStream(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor);
    private static Dictionary`2<string, int> LoadNameIndex(BitAccess bits);
    private static IntHashTable LoadNameStream(BitAccess bits);
    private static int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off);
    private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, ArrayList funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Reader ilreader, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings);
    internal static PdbFunction[] LoadFunctions(Stream read, Dictionary`2& tokenToSourceMapping, String& sourceServerData, Reader ilreader);
    internal static UInt32[] LoadRemapTable(Stream read);
    private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping, Dictionary`2<string, PdbSource> sourceCache);
    private static IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache);
    internal static Dictionary`2<UInt32, PdbFunction> LoadFunctionMap(FileStream inputStream, Dictionary`2& tokenToSourceMapping, String& sourceServerData, Reader reader);
}
internal class Microsoft.Cci.Pdb.PdbFileHeader : object {
    internal Byte[] magic;
    internal int pageSize;
    internal int freePageMap;
    internal int pagesUsed;
    internal int directorySize;
    internal int zero;
    internal Int32[] directoryRoot;
    internal PdbFileHeader(Stream reader, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbFunction : object {
    internal static Guid msilMetaData;
    internal static IComparer byAddress;
    internal static IComparer byAddressAndToken;
    internal UInt32 token;
    internal UInt32 unmappedToken;
    internal UInt32 slotToken;
    internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
    internal string name;
    internal UInt32 segment;
    internal UInt32 address;
    internal PdbScope[] scopes;
    internal PdbSlot[] slots;
    internal PdbConstant[] constants;
    internal String[] usedNamespaces;
    internal PdbLines[] lines;
    internal UInt16[] usingCounts;
    internal string iteratorClass;
    internal List`1<ILocalScope> iteratorScopes;
    internal PdbSynchronizationInformation synchronizationInformation;
    internal Method method;
    internal PdbFunction(ManProcSym proc, BitAccess bits, Reader reader);
    private static PdbFunction();
    private static string StripNamespace(string module);
    internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings, Reader reader);
    internal static void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces);
    private void ReadCustomMetadata_OLD(BitAccess bits);
    private void ReadCustomMetadata(BitAccess bits);
    private void ReadForwardIterator(BitAccess bits);
    private void ReadIteratorLocals(BitAccess bits);
    private void ReadForwardInfo(BitAccess bits);
    private void ReadUsingInfo(BitAccess bits);
    private static void MapToken(UInt32& token, UInt32[] ridMap);
    internal void MapTokens(UInt32[] ridMap, Reader reader);
    private void MapTokens(PdbSynchronizationInformation pdbSynchronizationInformation, UInt32[] ridMap, Reader reader);
    private void MapTokens(PdbSynchronizationPoint[] syncPoints, UInt32[] ridMap, Reader reader);
    private void MapTokens(PdbSynchronizationPoint syncpoint, UInt32[] ridMap, Reader reader);
}
internal class Microsoft.Cci.Pdb.PdbIteratorScope : object {
    private UInt32 offset;
    private UInt32 length;
    private Method methodDefinition;
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public Method MethodDefinition { get; public set; }
    internal PdbIteratorScope(UInt32 offset, UInt32 length);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
    public sealed virtual Method get_MethodDefinition();
    public void set_MethodDefinition(Method value);
}
internal class Microsoft.Cci.Pdb.PdbLine : ValueType {
    internal UInt32 offset;
    internal UInt32 lineBegin;
    internal UInt32 lineEnd;
    internal ushort colBegin;
    internal ushort colEnd;
    internal PdbLine(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd);
}
internal class Microsoft.Cci.Pdb.PdbLines : object {
    internal PdbSource file;
    internal PdbLine[] lines;
    internal PdbLines(PdbSource file, UInt32 count);
}
internal class Microsoft.Cci.Pdb.PdbReader : object {
    internal int pageSize;
    internal Stream reader;
    internal PdbReader(Stream reader, int pageSize);
    internal void Seek(int page, int offset);
    internal void Read(Byte[] bytes, int offset, int count);
    internal int PagesFromSize(int size);
}
internal class Microsoft.Cci.Pdb.PdbScope : object {
    internal PdbConstant[] constants;
    internal PdbSlot[] slots;
    internal PdbScope[] scopes;
    internal String[] usedNamespaces;
    internal UInt32 address;
    internal UInt32 offset;
    internal UInt32 length;
    internal PdbScope(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind);
}
internal class Microsoft.Cci.Pdb.PdbSlot : object {
    internal UInt32 slot;
    internal UInt32 typeToken;
    internal string name;
    internal ushort flags;
    internal PdbSlot(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbSource : object {
    internal string name;
    internal Guid doctype;
    internal Guid language;
    internal Guid vendor;
    internal PdbSource(string name, Guid doctype, Guid language, Guid vendor);
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
    internal UInt32 kickoffMethodToken;
    internal Method moveNextMethod;
    internal UInt32 generatedCatchHandlerIlOffset;
    internal PdbSynchronizationPoint[] synchronizationPoints;
    private Reader reader;
    public Method AsyncMethod { get; }
    public Method MoveNextMethod { get; }
    public UInt32 GeneratedCatchHandlerOffset { get; }
    public PdbSynchronizationPoint[] SynchronizationPoints { get; }
    internal PdbSynchronizationInformation(Method moveNext, BitAccess bits, Reader reader);
    public Method get_AsyncMethod();
    public Method get_MoveNextMethod();
    public UInt32 get_GeneratedCatchHandlerOffset();
    public PdbSynchronizationPoint[] get_SynchronizationPoints();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
    internal UInt32 synchronizeOffset;
    internal UInt32 continuationMethodToken;
    internal UInt32 continuationOffset;
    private Reader reader;
    public UInt32 SynchronizeOffset { get; }
    public Method ContinuationMethod { get; }
    public UInt32 ContinuationOffset { get; }
    internal PdbSynchronizationPoint(BitAccess bits, Reader reader);
    public UInt32 get_SynchronizeOffset();
    public Method get_ContinuationMethod();
    public UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.Pdb.PdbTokenLine : object {
    internal UInt32 token;
    internal UInt32 file_id;
    internal UInt32 line;
    internal UInt32 column;
    internal UInt32 endLine;
    internal UInt32 endColumn;
    internal PdbSource sourceFile;
    internal PdbTokenLine nextLine;
    internal PdbTokenLine(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
internal enum Microsoft.Cci.Pdb.SYM : Enum {
    public int value__;
    public static SYM S_END;
    public static SYM S_OEM;
    public static SYM S_REGISTER_ST;
    public static SYM S_CONSTANT_ST;
    public static SYM S_UDT_ST;
    public static SYM S_COBOLUDT_ST;
    public static SYM S_MANYREG_ST;
    public static SYM S_BPREL32_ST;
    public static SYM S_LDATA32_ST;
    public static SYM S_GDATA32_ST;
    public static SYM S_PUB32_ST;
    public static SYM S_LPROC32_ST;
    public static SYM S_GPROC32_ST;
    public static SYM S_VFTABLE32;
    public static SYM S_REGREL32_ST;
    public static SYM S_LTHREAD32_ST;
    public static SYM S_GTHREAD32_ST;
    public static SYM S_LPROCMIPS_ST;
    public static SYM S_GPROCMIPS_ST;
    public static SYM S_FRAMEPROC;
    public static SYM S_COMPILE2_ST;
    public static SYM S_MANYREG2_ST;
    public static SYM S_LPROCIA64_ST;
    public static SYM S_GPROCIA64_ST;
    public static SYM S_LOCALSLOT_ST;
    public static SYM S_PARAMSLOT_ST;
    public static SYM S_ANNOTATION;
    public static SYM S_GMANPROC_ST;
    public static SYM S_LMANPROC_ST;
    public static SYM S_RESERVED1;
    public static SYM S_RESERVED2;
    public static SYM S_RESERVED3;
    public static SYM S_RESERVED4;
    public static SYM S_LMANDATA_ST;
    public static SYM S_GMANDATA_ST;
    public static SYM S_MANFRAMEREL_ST;
    public static SYM S_MANREGISTER_ST;
    public static SYM S_MANSLOT_ST;
    public static SYM S_MANMANYREG_ST;
    public static SYM S_MANREGREL_ST;
    public static SYM S_MANMANYREG2_ST;
    public static SYM S_MANTYPREF;
    public static SYM S_UNAMESPACE_ST;
    public static SYM S_ST_MAX;
    public static SYM S_OBJNAME;
    public static SYM S_THUNK32;
    public static SYM S_BLOCK32;
    public static SYM S_WITH32;
    public static SYM S_LABEL32;
    public static SYM S_REGISTER;
    public static SYM S_CONSTANT;
    public static SYM S_UDT;
    public static SYM S_COBOLUDT;
    public static SYM S_MANYREG;
    public static SYM S_BPREL32;
    public static SYM S_LDATA32;
    public static SYM S_GDATA32;
    public static SYM S_PUB32;
    public static SYM S_LPROC32;
    public static SYM S_GPROC32;
    public static SYM S_REGREL32;
    public static SYM S_LTHREAD32;
    public static SYM S_GTHREAD32;
    public static SYM S_LPROCMIPS;
    public static SYM S_GPROCMIPS;
    public static SYM S_COMPILE2;
    public static SYM S_MANYREG2;
    public static SYM S_LPROCIA64;
    public static SYM S_GPROCIA64;
    public static SYM S_LOCALSLOT;
    public static SYM S_SLOT;
    public static SYM S_PARAMSLOT;
    public static SYM S_LMANDATA;
    public static SYM S_GMANDATA;
    public static SYM S_MANFRAMEREL;
    public static SYM S_MANREGISTER;
    public static SYM S_MANSLOT;
    public static SYM S_MANMANYREG;
    public static SYM S_MANREGREL;
    public static SYM S_MANMANYREG2;
    public static SYM S_UNAMESPACE;
    public static SYM S_PROCREF;
    public static SYM S_DATAREF;
    public static SYM S_LPROCREF;
    public static SYM S_ANNOTATIONREF;
    public static SYM S_TOKENREF;
    public static SYM S_GMANPROC;
    public static SYM S_LMANPROC;
    public static SYM S_TRAMPOLINE;
    public static SYM S_MANCONSTANT;
    public static SYM S_ATTR_FRAMEREL;
    public static SYM S_ATTR_REGISTER;
    public static SYM S_ATTR_REGREL;
    public static SYM S_ATTR_MANYREG;
    public static SYM S_SEPCODE;
    public static SYM S_LOCAL;
    public static SYM S_DEFRANGE;
    public static SYM S_DEFRANGE2;
    public static SYM S_SECTION;
    public static SYM S_COFFGROUP;
    public static SYM S_EXPORT;
    public static SYM S_CALLSITEINFO;
    public static SYM S_FRAMECOOKIE;
    public static SYM S_DISCARDED;
    public static SYM S_RECTYPE_MAX;
    public static SYM S_RECTYPE_LAST;
}
internal enum Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
    public int value__;
    public static TYPE_ENUM T_NOTYPE;
    public static TYPE_ENUM T_ABS;
    public static TYPE_ENUM T_SEGMENT;
    public static TYPE_ENUM T_VOID;
    public static TYPE_ENUM T_HRESULT;
    public static TYPE_ENUM T_32PHRESULT;
    public static TYPE_ENUM T_64PHRESULT;
    public static TYPE_ENUM T_PVOID;
    public static TYPE_ENUM T_PFVOID;
    public static TYPE_ENUM T_PHVOID;
    public static TYPE_ENUM T_32PVOID;
    public static TYPE_ENUM T_64PVOID;
    public static TYPE_ENUM T_CURRENCY;
    public static TYPE_ENUM T_NOTTRANS;
    public static TYPE_ENUM T_BIT;
    public static TYPE_ENUM T_PASCHAR;
    public static TYPE_ENUM T_CHAR;
    public static TYPE_ENUM T_32PCHAR;
    public static TYPE_ENUM T_64PCHAR;
    public static TYPE_ENUM T_UCHAR;
    public static TYPE_ENUM T_32PUCHAR;
    public static TYPE_ENUM T_64PUCHAR;
    public static TYPE_ENUM T_RCHAR;
    public static TYPE_ENUM T_32PRCHAR;
    public static TYPE_ENUM T_64PRCHAR;
    public static TYPE_ENUM T_WCHAR;
    public static TYPE_ENUM T_32PWCHAR;
    public static TYPE_ENUM T_64PWCHAR;
    public static TYPE_ENUM T_INT1;
    public static TYPE_ENUM T_32PINT1;
    public static TYPE_ENUM T_64PINT1;
    public static TYPE_ENUM T_UINT1;
    public static TYPE_ENUM T_32PUINT1;
    public static TYPE_ENUM T_64PUINT1;
    public static TYPE_ENUM T_SHORT;
    public static TYPE_ENUM T_32PSHORT;
    public static TYPE_ENUM T_64PSHORT;
    public static TYPE_ENUM T_USHORT;
    public static TYPE_ENUM T_32PUSHORT;
    public static TYPE_ENUM T_64PUSHORT;
    public static TYPE_ENUM T_INT2;
    public static TYPE_ENUM T_32PINT2;
    public static TYPE_ENUM T_64PINT2;
    public static TYPE_ENUM T_UINT2;
    public static TYPE_ENUM T_32PUINT2;
    public static TYPE_ENUM T_64PUINT2;
    public static TYPE_ENUM T_LONG;
    public static TYPE_ENUM T_ULONG;
    public static TYPE_ENUM T_32PLONG;
    public static TYPE_ENUM T_32PULONG;
    public static TYPE_ENUM T_64PLONG;
    public static TYPE_ENUM T_64PULONG;
    public static TYPE_ENUM T_INT4;
    public static TYPE_ENUM T_32PINT4;
    public static TYPE_ENUM T_64PINT4;
    public static TYPE_ENUM T_UINT4;
    public static TYPE_ENUM T_32PUINT4;
    public static TYPE_ENUM T_64PUINT4;
    public static TYPE_ENUM T_QUAD;
    public static TYPE_ENUM T_32PQUAD;
    public static TYPE_ENUM T_64PQUAD;
    public static TYPE_ENUM T_UQUAD;
    public static TYPE_ENUM T_32PUQUAD;
    public static TYPE_ENUM T_64PUQUAD;
    public static TYPE_ENUM T_INT8;
    public static TYPE_ENUM T_32PINT8;
    public static TYPE_ENUM T_64PINT8;
    public static TYPE_ENUM T_UINT8;
    public static TYPE_ENUM T_32PUINT8;
    public static TYPE_ENUM T_64PUINT8;
    public static TYPE_ENUM T_OCT;
    public static TYPE_ENUM T_32POCT;
    public static TYPE_ENUM T_64POCT;
    public static TYPE_ENUM T_UOCT;
    public static TYPE_ENUM T_32PUOCT;
    public static TYPE_ENUM T_64PUOCT;
    public static TYPE_ENUM T_INT16;
    public static TYPE_ENUM T_32PINT16;
    public static TYPE_ENUM T_64PINT16;
    public static TYPE_ENUM T_UINT16;
    public static TYPE_ENUM T_32PUINT16;
    public static TYPE_ENUM T_64PUINT16;
    public static TYPE_ENUM T_REAL32;
    public static TYPE_ENUM T_32PREAL32;
    public static TYPE_ENUM T_64PREAL32;
    public static TYPE_ENUM T_REAL64;
    public static TYPE_ENUM T_32PREAL64;
    public static TYPE_ENUM T_64PREAL64;
    public static TYPE_ENUM T_REAL80;
    public static TYPE_ENUM T_32PREAL80;
    public static TYPE_ENUM T_64PREAL80;
    public static TYPE_ENUM T_REAL128;
    public static TYPE_ENUM T_32PREAL128;
    public static TYPE_ENUM T_64PREAL128;
    public static TYPE_ENUM T_CPLX32;
    public static TYPE_ENUM T_32PCPLX32;
    public static TYPE_ENUM T_64PCPLX32;
    public static TYPE_ENUM T_CPLX64;
    public static TYPE_ENUM T_32PCPLX64;
    public static TYPE_ENUM T_64PCPLX64;
    public static TYPE_ENUM T_CPLX80;
    public static TYPE_ENUM T_32PCPLX80;
    public static TYPE_ENUM T_64PCPLX80;
    public static TYPE_ENUM T_CPLX128;
    public static TYPE_ENUM T_32PCPLX128;
    public static TYPE_ENUM T_64PCPLX128;
    public static TYPE_ENUM T_BOOL08;
    public static TYPE_ENUM T_32PBOOL08;
    public static TYPE_ENUM T_64PBOOL08;
    public static TYPE_ENUM T_BOOL16;
    public static TYPE_ENUM T_32PBOOL16;
    public static TYPE_ENUM T_64PBOOL16;
    public static TYPE_ENUM T_BOOL32;
    public static TYPE_ENUM T_32PBOOL32;
    public static TYPE_ENUM T_64PBOOL32;
    public static TYPE_ENUM T_BOOL64;
    public static TYPE_ENUM T_32PBOOL64;
    public static TYPE_ENUM T_64PBOOL64;
}
public class System.Compiler.AddressDereference : Expression {
    private Expression address;
    private int alignment;
    private bool isVolatile;
    private ExplicitOp explicitOperation;
    public Expression Address { get; public set; }
    public int Alignment { get; public set; }
    public bool Volatile { get; public set; }
    public bool Explicit { get; }
    public ExplicitOp ExplicitOperator { get; public set; }
    public AddressDereference(Expression address, TypeNode type);
    public AddressDereference(Expression address, TypeNode type, SourceContext sctx);
    public AddressDereference(Expression address, TypeNode type, bool isVolatile, int alignment);
    public AddressDereference(Expression address, TypeNode type, bool Volatile, int alignment, SourceContext sctx);
    public Expression get_Address();
    public void set_Address(Expression value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public bool get_Volatile();
    public void set_Volatile(bool value);
    public bool get_Explicit();
    public ExplicitOp get_ExplicitOperator();
    public void set_ExplicitOperator(ExplicitOp value);
}
public class System.Compiler.AnonymousNestedFunction : Expression {
    public ParameterList Parameters;
    public Block Body;
    public Method Method;
    public Expression Invocation;
    public AnonymousNestedFunction(ParameterList parameters, Block body);
    public AnonymousNestedFunction(ParameterList parameters, Block body, SourceContext sctx);
}
public class System.Compiler.ApplyToAll : BinaryExpression {
    public Local ElementLocal;
    public Method ResultIterator;
    public ApplyToAll(Expression operand1, Expression operand2);
    public ApplyToAll(Expression operand1, Expression operand2, SourceContext ctx);
}
public class System.Compiler.ArglistArgumentExpression : NaryExpression {
    public ArglistArgumentExpression(ExpressionList args, SourceContext sctx);
}
public class System.Compiler.ArglistExpression : Expression {
    public ArglistExpression(SourceContext sctx);
}
public class System.Compiler.ArrayType : TypeNode {
    private TypeNode elementType;
    private int rank;
    private Int32[] lowerBounds;
    private Int32[] sizes;
    private MemberList ctorList;
    private MemberList getterList;
    private MemberList setterList;
    private MemberList addressList;
    protected TypeNodeList structuralElementTypes;
    public TypeNode ElementType { get; public set; }
    public InterfaceList Interfaces { get; public set; }
    public int Rank { get; public set; }
    public Int32[] LowerBounds { get; public set; }
    public Int32[] Sizes { get; public set; }
    public MemberList Members { get; public set; }
    public string FullName { get; }
    public Method Constructor { get; }
    public Method Getter { get; }
    public Method Setter { get; }
    public Method Address { get; }
    public bool IsStructural { get; }
    public TypeNodeList StructuralElementTypes { get; }
    internal ArrayType(TypeNode elementType, int rank);
    internal ArrayType(TypeNode elementType, int rank, Int32[] sizes);
    internal ArrayType(TypeNode elementType, int rank, Int32[] sizes, Int32[] lowerBounds);
    public TypeNode get_ElementType();
    public void set_ElementType(TypeNode value);
    public virtual InterfaceList get_Interfaces();
    public virtual void set_Interfaces(InterfaceList value);
    public int get_Rank();
    public void set_Rank(int value);
    public Int32[] get_LowerBounds();
    public void set_LowerBounds(Int32[] value);
    public Int32[] get_Sizes();
    public void set_Sizes(Int32[] value);
    public bool IsSzArray();
    public virtual MemberList get_Members();
    public virtual void set_Members(MemberList value);
    public virtual string get_FullName();
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    public virtual void SetLowerBoundToUnknown();
    public virtual int GetLowerBound(int dimension);
    public virtual int GetSize(int dimension);
    public virtual MemberList GetMembersNamed(Identifier name);
    public virtual Type GetRuntimeType();
    public Method get_Constructor();
    public Method get_Getter();
    public Method get_Setter();
    public Method get_Address();
    public virtual bool IsAssignableTo(TypeNode targetType, Func`2<TypeNode, TypeNode> targetTypeSubstitution);
    public virtual bool get_IsStructural();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.ArrayTypeExpression : ArrayType {
    public bool LowerBoundIsUnknown;
    public ArrayTypeExpression(TypeNode elementType, int rank);
    public ArrayTypeExpression(TypeNode elementType, int rank, Int32[] sizes);
    public ArrayTypeExpression(TypeNode elementType, int rank, Int32[] sizes, Int32[] lowerBounds);
    public ArrayTypeExpression(TypeNode elementType, int rank, SourceContext sctx);
    public ArrayTypeExpression(TypeNode elementType, int rank, Int32[] sizes, SourceContext sctx);
    public ArrayTypeExpression(TypeNode elementType, int rank, Int32[] sizes, Int32[] lowerBounds, SourceContext sctx);
}
public class System.Compiler.AssemblyCouldNotBeSignedException : ApplicationException {
    public static string DefaultMessage;
    public AssemblyCouldNotBeSignedException(Exception innerException);
    public AssemblyCouldNotBeSignedException(string message, Exception innerException);
}
[FlagsAttribute]
public enum System.Compiler.AssemblyFlags : Enum {
    public int value__;
    public static AssemblyFlags None;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Library;
    public static AssemblyFlags Platform;
    public static AssemblyFlags NowPlatform;
    public static AssemblyFlags SideBySideCompatible;
    public static AssemblyFlags NonSideBySideCompatible;
    public static AssemblyFlags NonSideBySideProcess;
    public static AssemblyFlags NonSideBySideMachine;
    public static AssemblyFlags CompatibilityMask;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags ContainsForeignTypes;
    public static AssemblyFlags DisableJITcompileOptimizer;
    public static AssemblyFlags EnableJITcompileTracking;
}
public enum System.Compiler.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
}
internal class System.Compiler.AssemblyName : object {
    private IAssemblyName assemblyName;
    internal string Name { get; }
    internal Version Version { get; }
    internal string Culture { get; }
    internal Byte[] PublicKeyToken { get; }
    internal string StrongName { get; }
    internal string CodeBase { get; }
    internal AssemblyName(IAssemblyName assemblyName);
    internal string get_Name();
    internal Version get_Version();
    internal string get_Culture();
    internal Byte[] get_PublicKeyToken();
    internal string get_StrongName();
    internal string get_CodeBase();
    public virtual string ToString();
    internal string GetLocation();
    private string ReadString(UInt32 assemblyNameProperty);
    private ushort ReadUInt16(UInt32 assemblyNameProperty);
    private Byte[] ReadBytes(UInt32 assemblyNameProperty);
    private static int CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
}
public class System.Compiler.AssemblyNode : Module {
    public string KeyContainerName;
    public Byte[] KeyBlob;
    private static Hashtable CompiledAssemblies;
    protected AssemblyNode contractAssembly;
    internal static AssemblyNode Dummy;
    protected string strongName;
    private string culture;
    private AssemblyFlags flags;
    private string moduleName;
    private Byte[] publicKeyOrToken;
    private Version version;
    private DateTime fileLastWriteTimeUtc;
    protected TypeNodeList exportedTypes;
    private AssemblyName assemblyName;
    private CachedRuntimeAssembly cachedRuntimeAssembly;
    protected TrivialHashtable friends;
    protected AttributeList moduleAttributes;
    protected Byte[] token;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private PostAssemblyLoadProcessor AfterAssemblyLoad;
    public AssemblyNode ContractAssembly { get; public set; }
    public string StrongName { get; }
    public string Culture { get; public set; }
    public AssemblyFlags Flags { get; public set; }
    public string ModuleName { get; public set; }
    public Byte[] PublicKeyOrToken { get; public set; }
    public Version Version { get; public set; }
    public DateTime FileLastWriteTimeUtc { get; public set; }
    public TypeNodeList ExportedTypes { get; public set; }
    public bool GetDebugSymbols { get; public set; }
    public AttributeList ModuleAttributes { get; public set; }
    public Byte[] PublicKeyToken { get; }
    public AssemblyNode(TypeNodeProvider provider, TypeNodeListProvider listProvider, CustomAttributeProvider provideCustomAttributes, ResourceProvider provideResources, string directory);
    private static AssemblyNode();
    public virtual AssemblyNode get_ContractAssembly();
    public virtual void set_ContractAssembly(AssemblyNode value);
    public virtual string get_StrongName();
    [ObsoleteAttribute("Please use GetAttribute(TypeNode attributeType)")]
public virtual AttributeNode GetAttributeByName(TypeNode attributeType);
    public virtual AttributeNode GetModuleAttribute(TypeNode attributeType);
    public virtual void Dispose();
    public string get_Culture();
    public void set_Culture(string value);
    public AssemblyFlags get_Flags();
    public void set_Flags(AssemblyFlags value);
    public string get_ModuleName();
    public void set_ModuleName(string value);
    public Byte[] get_PublicKeyOrToken();
    public void set_PublicKeyOrToken(Byte[] value);
    public Version get_Version();
    public void set_Version(Version value);
    public DateTime get_FileLastWriteTimeUtc();
    public void set_FileLastWriteTimeUtc(DateTime value);
    public virtual TypeNodeList get_ExportedTypes();
    public virtual void set_ExportedTypes(TypeNodeList value);
    public bool get_GetDebugSymbols();
    public void set_GetDebugSymbols(bool value);
    public static AssemblyNode GetAssembly(Byte[] buffer);
    public static AssemblyNode GetAssembly(Byte[] buffer, IDictionary cache);
    public static AssemblyNode GetAssembly(Byte[] buffer, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(Byte[] buffer, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public static AssemblyNode GetAssembly(string location);
    public static AssemblyNode GetAssembly(string location, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(string location, IDictionary cache);
    public static AssemblyNode GetAssembly(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(string location, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, PostAssemblyLoadProcessor postLoadEvent);
    public static AssemblyNode GetAssembly(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, PostAssemblyLoadProcessor postLoadEvent);
    public static AssemblyNode GetAssembly(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public static AssemblyNode GetAssembly(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches, PostAssemblyLoadProcessor postLoadEvent);
    public static AssemblyNode GetAssembly(AssemblyReference assemblyReference);
    public static AssemblyNode GetAssembly(AssemblyReference assemblyReference, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(AssemblyReference assemblyReference, IDictionary cache);
    public static AssemblyNode GetAssembly(AssemblyReference assemblyReference, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(AssemblyReference assemblyReference, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public static AssemblyNode GetAssembly(Assembly runtimeAssembly);
    public static AssemblyNode GetAssembly(Assembly runtimeAssembly, IDictionary cache);
    public static AssemblyNode GetAssembly(Assembly runtimeAssembly, IDictionary cache, bool getDebugInfo, bool useGlobalCache);
    public static AssemblyNode GetAssembly(Assembly runtimeAssembly, IDictionary cache, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public void SetupDebugReader(string pdbSearchPath);
    internal static string GetStrongName(string name, Version version, string culture, Byte[] publicKey, bool retargetable);
    public AssemblyName GetAssemblyName();
    public Assembly GetRuntimeAssembly();
    public Assembly GetRuntimeAssembly(Evidence evidence);
    public Assembly GetRuntimeAssembly(AppDomain targetAppDomain);
    public Assembly GetRuntimeAssembly(Evidence evidence, AppDomain targetAppDomain);
    private void AddCachedAssembly(Assembly runtimeAssembly);
    private static string GetKeyString(Byte[] publicKey);
    public virtual bool MayAccessInternalTypesOf(AssemblyNode assembly);
    public AssemblyReferenceList GetFriendAssemblies();
    public virtual AttributeList get_ModuleAttributes();
    public virtual void set_ModuleAttributes(AttributeList value);
    public virtual Byte[] get_PublicKeyToken();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public void add_AfterAssemblyLoad(PostAssemblyLoadProcessor value);
    [CompilerGeneratedAttribute]
public void remove_AfterAssemblyLoad(PostAssemblyLoadProcessor value);
    public PostAssemblyLoadProcessor GetAfterAssemblyLoad();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.AssemblyNodeList : object {
    private AssemblyNode[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public AssemblyNode Item { get; public set; }
    public AssemblyNodeList(int capacity);
    public AssemblyNodeList(AssemblyNode[] elements);
    public void Add(AssemblyNode element);
    public int get_Count();
    public int get_Length();
    public AssemblyNode get_Item(int index);
    public void set_Item(int index, AssemblyNode value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.AssemblyReference : Node {
    public IdentifierList Aliases;
    private Byte[] token;
    internal Reader Reader;
    private string culture;
    private AssemblyFlags flags;
    private Byte[] hashValue;
    private string name;
    private Byte[] publicKeyOrToken;
    private Version version;
    private string location;
    protected internal AssemblyNode assembly;
    protected string strongName;
    private AssemblyName assemblyName;
    public string Culture { get; public set; }
    public AssemblyFlags Flags { get; public set; }
    public Byte[] HashValue { get; public set; }
    public string Name { get; public set; }
    public Byte[] PublicKeyOrToken { get; public set; }
    public Version Version { get; public set; }
    public string Location { get; public set; }
    public AssemblyNode Assembly { get; public set; }
    public string StrongName { get; }
    public Byte[] PublicKeyToken { get; }
    public AssemblyReference(AssemblyNode assembly);
    public AssemblyReference(string assemblyStrongName, SourceContext sctx);
    public AssemblyReference(string assemblyStrongName);
    private static string ParseToken(string assemblyStrongName, Int32& i);
    private static string ParseAssignment(string assemblyStrongName, string target, Int32& i);
    public string get_Culture();
    public void set_Culture(string value);
    public AssemblyFlags get_Flags();
    public void set_Flags(AssemblyFlags value);
    public Byte[] get_HashValue();
    public void set_HashValue(Byte[] value);
    public string get_Name();
    public void set_Name(string value);
    public Byte[] get_PublicKeyOrToken();
    public void set_PublicKeyOrToken(Byte[] value);
    public Version get_Version();
    public void set_Version(Version value);
    public string get_Location();
    public void set_Location(string value);
    public virtual AssemblyNode get_Assembly();
    public virtual void set_Assembly(AssemblyNode value);
    public virtual string get_StrongName();
    public AssemblyName GetAssemblyName();
    public bool Matches(string name, Version version, string culture, Byte[] publicKeyToken);
    public bool MatchesIgnoringVersion(AssemblyReference reference);
    public Byte[] get_PublicKeyToken();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.AssemblyReferenceList : object {
    private AssemblyReference[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public AssemblyReference Item { get; public set; }
    public AssemblyReferenceList(int capacity);
    public void Add(AssemblyReference element);
    public AssemblyReferenceList Clone();
    public int get_Count();
    public int get_Length();
    public AssemblyReference get_Item(int index);
    public void set_Item(int index, AssemblyReference value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.Assertion : Statement {
    public Expression Condition;
    public Literal userMessage;
    public Assertion(Expression condition);
}
public class System.Compiler.AssignmentExpression : Expression {
    public Statement AssignmentStatement;
    public AssignmentExpression(AssignmentStatement assignment);
}
public class System.Compiler.AssignmentStatement : Statement {
    private NodeType operator;
    private Expression source;
    private Expression target;
    public Method OperatorOverload;
    public TypeNode UnifiedType;
    public NodeType Operator { get; public set; }
    public Expression Source { get; public set; }
    public Expression Target { get; public set; }
    public AssignmentStatement(Expression target, Expression source);
    public AssignmentStatement(Expression target, Expression source, SourceContext context);
    public AssignmentStatement(Expression target, Expression source, NodeType operator);
    public AssignmentStatement(Expression target, Expression source, NodeType Operator, SourceContext context);
    public NodeType get_Operator();
    public void set_Operator(NodeType value);
    public Expression get_Source();
    public void set_Source(Expression value);
    public Expression get_Target();
    public void set_Target(Expression value);
}
public class System.Compiler.Assumption : Statement {
    public Expression Condition;
    public Literal userMessage;
    public Assumption(Expression condition);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.AttributeList : object {
    private AttributeNode[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public AttributeNode Item { get; public set; }
    public AttributeList(int capacity);
    public AttributeList(AttributeNode[] elements);
    public void Add(AttributeNode element);
    public AttributeList Clone();
    public int get_Count();
    public int get_Length();
    public AttributeNode get_Item(int index);
    public void set_Item(int index, AttributeNode value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.AttributeNode : Node {
    public bool IsPseudoAttribute;
    private Expression constructor;
    private ExpressionList expressions;
    private AttributeTargets target;
    private bool allowMultiple;
    private bool inherited;
    private AttributeTargets validOn;
    private TypeNode type;
    private AttributeNode usageAttribute;
    public static AttributeNode DoesNotExist;
    public Expression Constructor { get; public set; }
    public ExpressionList Expressions { get; public set; }
    public AttributeTargets Target { get; public set; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeTargets ValidOn { get; public set; }
    public TypeNode Type { get; public set; }
    public AttributeNode(Expression constructor, ExpressionList expressions);
    public AttributeNode(Expression constructor, ExpressionList expressions, AttributeTargets target);
    private static AttributeNode();
    public Expression get_Constructor();
    public void set_Constructor(Expression value);
    public ExpressionList get_Expressions();
    public void set_Expressions(ExpressionList value);
    public AttributeTargets get_Target();
    public void set_Target(AttributeTargets value);
    public virtual bool get_AllowMultiple();
    public virtual void set_AllowMultiple(bool value);
    public virtual bool get_Inherited();
    public virtual void set_Inherited(bool value);
    public virtual AttributeTargets get_ValidOn();
    public virtual void set_ValidOn(AttributeTargets value);
    public virtual TypeNode get_Type();
    public virtual void set_Type(TypeNode value);
    private void GetUsageInformation();
    public virtual Attribute GetRuntimeAttribute();
    protected object GetCoercedLiteralValue(TypeNode type, object value);
    protected Array GetCoercedArrayLiteral(ArrayType arrayType, Array arrayValue);
    private static void SetAttributeProperty(Property prop, Attribute attr, object val);
    private static Attribute ConstructAttribute(InstanceInitializer constr, Object[] argumentValues);
    public Expression GetPositionalArgument(int position);
    public Expression GetNamedArgument(Identifier name);
}
public class System.Compiler.BetterPath : object {
    public static char AltDirectorySeparatorChar;
    public static char DirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    private static BetterPath();
    public static string ChangeExtension(string path, string extension);
    public static string Combine(string path1, string path2);
    public static string GetExtension(string path);
    public static string GetFileName(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetDirectoryName(string path);
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetTempFileName();
    public static bool HasExtension(string path);
}
public class System.Compiler.BinaryExpression : Expression {
    private Expression operand1;
    private Expression operand2;
    public Expression Operand1 { get; public set; }
    public Expression Operand2 { get; public set; }
    public BinaryExpression(Expression operand1, Expression operand2, NodeType nodeType);
    public BinaryExpression(Expression operand1, Expression operand2, NodeType nodeType, TypeNode resultType);
    public BinaryExpression(Expression operand1, Expression operand2, NodeType nodeType, SourceContext ctx);
    public BinaryExpression(Expression operand1, Expression operand2, NodeType nodeType, TypeNode resultType, SourceContext ctx);
    public Expression get_Operand1();
    public void set_Operand1(Expression value);
    public Expression get_Operand2();
    public void set_Operand2(Expression value);
}
public class System.Compiler.BinaryWriter : object {
    public MemoryStream BaseStream;
    private bool UTF8;
    public BinaryWriter(MemoryStream output);
    public BinaryWriter(MemoryStream output, bool unicode);
    public BinaryWriter(MemoryStream output, Encoding encoding);
    public void Align(UInt32 alignment);
    public void Write(bool value);
    public void Write(byte value);
    public void Write(sbyte value);
    public void Write(Byte[] buffer);
    public void Write(char ch);
    public void Write(Char[] chars);
    public void Write(double value);
    public void Write(short value);
    public void Write(ushort value);
    public void Write(int value);
    public void Write(UInt32 value);
    public void Write(long value);
    public void Write(ulong value);
    public void Write(float value);
    public void Write(string str);
    public void Write(string str, bool emitNullTerminator);
    public static int GetUTF8ByteCount(string str);
}
public class System.Compiler.Block : Statement {
    private StatementList statements;
    public bool Checked;
    public bool SuppressCheck;
    public bool HasLocals;
    public StatementList Statements { get; public set; }
    public Block(StatementList statements);
    public StatementList get_Statements();
    public void set_Statements(StatementList value);
}
public class System.Compiler.BlockExpression : Expression {
    public Block Block;
    public BlockExpression(Block block);
    public BlockExpression(Block block, TypeNode type);
    public BlockExpression(Block block, TypeNode type, SourceContext sctx);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.BlockList : object {
    private Block[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Block Item { get; public set; }
    public BlockList(int n);
    public void Add(Block element);
    public BlockList Clone();
    public int get_Count();
    public int get_Length();
    public Block get_Item(int index);
    public void set_Item(int index, Block value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.BoxedTypeExpression : TypeNode {
    public TypeNode ElementType;
    public BoxedTypeExpression(TypeNode elementType);
    public BoxedTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.Branch : Statement {
    private Expression condition;
    private bool leavesExceptionBlock;
    internal bool shortOffset;
    private Block target;
    public bool BranchIfUnordered;
    public Expression Condition { get; public set; }
    public bool LeavesExceptionBlock { get; public set; }
    public bool ShortOffset { get; public set; }
    public Block Target { get; public set; }
    public Branch(Expression condition, Block target);
    public Branch(Expression condition, Block target, SourceContext sourceContext);
    public Branch(Expression condition, Block target, SourceContext sourceContext, bool unordered);
    public Branch(Expression condition, Block target, bool shortOffset, bool unordered, bool leavesExceptionBlock);
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public bool get_LeavesExceptionBlock();
    public void set_LeavesExceptionBlock(bool value);
    public bool get_ShortOffset();
    public void set_ShortOffset(bool value);
    public Block get_Target();
    public void set_Target(Block value);
}
public class System.Compiler.ByteArrayKeyComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object x);
}
[FlagsAttribute]
public enum System.Compiler.CallingConventionFlags : Enum {
    public int value__;
    public static CallingConventionFlags Default;
    public static CallingConventionFlags C;
    public static CallingConventionFlags StandardCall;
    public static CallingConventionFlags ThisCall;
    public static CallingConventionFlags FastCall;
    public static CallingConventionFlags VarArg;
    public static CallingConventionFlags ArgumentConvention;
    public static CallingConventionFlags Generic;
    public static CallingConventionFlags HasThis;
    public static CallingConventionFlags ExplicitThis;
}
public class System.Compiler.Class : TypeNode {
    internal static Class DoesNotExist;
    internal static Class Dummy;
    internal Class baseClass;
    public Class BaseClassExpression;
    public bool IsAbstractSealedContainerForStatics;
    public Class BaseClass { get; public set; }
    public Class(NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public Class(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags flags, Identifier Namespace, Identifier name, Class baseClass, InterfaceList interfaces, MemberList members);
    private static Class();
    public virtual Class get_BaseClass();
    public virtual void set_BaseClass(Class value);
    public virtual void GetAbstractMethods(MethodList result);
    protected static bool AlreadyInList(MethodList list, Method method);
}
public class System.Compiler.ClassExpression : Class {
    public Expression Expression;
    public ClassExpression(Expression expression);
    public ClassExpression(Expression expression, TypeNodeList templateArguments);
    public ClassExpression(Expression expression, SourceContext sctx);
    public ClassExpression(Expression expression, TypeNodeList templateArguments, SourceContext sctx);
}
public class System.Compiler.ClassParameter : Class {
    protected TrivialHashtable jointMemberTable;
    private Member declaringMember;
    private int parameterListIndex;
    private TypeParameterFlags typeParameterFlags;
    protected internal TypeNodeList structuralElementTypes;
    public Member DeclaringMember { get; public set; }
    public int ParameterListIndex { get; public set; }
    public TypeParameterFlags TypeParameterFlags { get; public set; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public bool IsValueType { get; }
    public bool IsStructural { get; }
    public bool IsTemplateParameter { get; }
    public bool IsReferenceType { get; }
    public XmlNode Documentation { get; public set; }
    public string HelpText { get; public set; }
    public TypeNodeList StructuralElementTypes { get; }
    private SourceContext System.Compiler.ITypeParameter.SourceContext { get; }
    private Module System.Compiler.ITypeParameter.DeclaringModule { get; }
    private TypeFlags System.Compiler.ITypeParameter.Flags { get; }
    public ClassParameter(NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public sealed virtual Member get_DeclaringMember();
    public sealed virtual void set_DeclaringMember(Member value);
    public virtual MemberList GetAllMembersNamed(Identifier name);
    public virtual Type GetRuntimeType();
    public sealed virtual int get_ParameterListIndex();
    public sealed virtual void set_ParameterListIndex(int value);
    public sealed virtual TypeParameterFlags get_TypeParameterFlags();
    public sealed virtual void set_TypeParameterFlags(TypeParameterFlags value);
    public sealed virtual bool get_IsCovariant();
    public sealed virtual bool get_IsContravariant();
    public virtual bool get_IsValueType();
    public virtual bool get_IsStructural();
    public virtual bool get_IsTemplateParameter();
    public virtual bool get_IsReferenceType();
    public virtual XmlNode get_Documentation();
    public virtual void set_Documentation(XmlNode value);
    public virtual string get_HelpText();
    public virtual void set_HelpText(string value);
    public virtual TypeNodeList get_StructuralElementTypes();
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    public virtual string GetFullUnmangledNameWithoutTypeParameters();
    public virtual string GetFullUnmangledNameWithTypeParameters();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
    private sealed virtual override SourceContext System.Compiler.ITypeParameter.get_SourceContext();
    private sealed virtual override Module System.Compiler.ITypeParameter.get_DeclaringModule();
    private sealed virtual override TypeFlags System.Compiler.ITypeParameter.get_Flags();
}
public static class System.Compiler.ClrStrongName : object {
    private static IClrStrongName clrStrongName;
    private static IClrStrongName GetClrStrongName();
    public static void SignatureGeneration(string filePath, string keyContainer, Byte[] keyBlob);
}
public class System.Compiler.CoerceTuple : ConstructTuple {
    public Expression OriginalTuple;
    public Local Temp;
}
public class System.Compiler.CollectibleSourceText : object {
    private string filePath;
    private WeakReference fileContent;
    private int length;
    private int System.Compiler.ISourceText.Length { get; }
    private char System.Compiler.ISourceText.Item { get; }
    public CollectibleSourceText(string filePath, int length);
    public CollectibleSourceText(string filePath, string fileContent);
    private string ReadFile();
    public string GetSourceText();
    private sealed virtual override int System.Compiler.ISourceText.get_Length();
    private sealed virtual override string System.Compiler.ISourceText.Substring(int startIndex, int length);
    private sealed virtual override char System.Compiler.ISourceText.get_Item(int index);
    private sealed virtual override void System.Compiler.ISourceText.MakeCollectible();
}
public class System.Compiler.CollectionEnumerator : Expression {
    public Expression Collection;
    public Method DefaultIndexerGetter;
    public Method LengthPropertyGetter;
    public Method GetEnumerator;
    public Method MoveNext;
    public Method GetCurrent;
    public Local ElementLocal;
    public Expression ElementCoercion;
}
public class System.Compiler.CompilerOptions : CompilerParameters {
    public StringCollection AliasesForReferencedAssemblies;
    public ModuleKindFlags ModuleKind;
    public bool EmitManifest;
    public StringList DefinedPreProcessorSymbols;
    public string XMLDocFileName;
    public string RecursiveWildcard;
    public StringList ReferencedModules;
    public string Win32Icon;
    public bool PDBOnly;
    public bool Optimize;
    public bool IncrementalCompile;
    public Int32List SuppressedWarnings;
    public bool CheckedArithmetic;
    public bool AllowUnsafeCode;
    public bool DisplayCommandLineHelp;
    public bool SuppressLogo;
    public long BaseAddress;
    public string BugReportFileName;
    public object CodePage;
    public bool EncodeOutputInUTF8;
    public bool FullyQualifyPaths;
    public int FileAlignment;
    public bool NoStandardLibrary;
    public StringList AdditionalSearchPaths;
    public bool HeuristicReferenceResolution;
    public string RootNamespace;
    public bool CompileAndExecute;
    public object UserLocaleId;
    public string StandardLibraryLocation;
    public PlatformType TargetPlatform;
    public ProcessorType TargetProcessor;
    public string TargetPlatformLocation;
    public string AssemblyKeyFile;
    public string AssemblyKeyName;
    public bool DelaySign;
    public TargetInformation TargetInformation;
    public Int32List SpecificWarningsToTreatAsErrors;
    public Int32List SpecificWarningsNotToTreatAsErrors;
    public string OutputPath;
    public string ExplicitOutputExtension;
    public AppDomain TargetAppDomain;
    public bool MayLockFiles;
    public string ShadowedAssembly;
    public bool UseStandardConfigFile;
    public CompilerSite Site;
    public CompilerOptions(CompilerOptions source);
    public virtual string GetOptionHelp();
    public virtual CompilerOptions Clone();
}
public class System.Compiler.CompilerSite : object {
    public bool ShouldCancel { get; }
    public virtual void OutputMessage(string message);
    public virtual bool get_ShouldCancel();
}
public class System.Compiler.Construct : NaryExpression {
    private Expression constructor;
    public Expression Owner;
    public Expression Constructor { get; public set; }
    public Construct(Expression constructor, ExpressionList arguments);
    public Construct(Expression constructor, ExpressionList arguments, SourceContext sctx);
    public Construct(Expression constructor, ExpressionList arguments, TypeNode type);
    public Construct(Expression constructor, ExpressionList arguments, TypeNode type, SourceContext sctx);
    public Expression get_Constructor();
    public void set_Constructor(Expression value);
}
public class System.Compiler.ConstructArray : NaryExpression {
    private TypeNode elementType;
    private int rank;
    public TypeNode ElementTypeExpression;
    public ExpressionList Initializers;
    public Expression Owner;
    public TypeNode ElementType { get; public set; }
    public int Rank { get; public set; }
    public ConstructArray(TypeNode elementType, ExpressionList sizes, ExpressionList initializers);
    public ConstructArray(TypeNode elementType, ExpressionList initializers);
    public ConstructArray(TypeNode elementType, int rank, ExpressionList initializers);
    public TypeNode get_ElementType();
    public void set_ElementType(TypeNode value);
    public int get_Rank();
    public void set_Rank(int value);
}
public class System.Compiler.ConstructDelegate : Expression {
    public TypeNode DelegateType;
    public TypeNode DelegateTypeExpression;
    public Identifier MethodName;
    public Expression TargetObject;
    public ConstructDelegate(TypeNode delegateType, Expression targetObject, Identifier methodName);
    public ConstructDelegate(TypeNode delegateType, Expression targetObject, Identifier methodName, SourceContext sctx);
}
public class System.Compiler.ConstructFlexArray : NaryExpression {
    public TypeNode ElementType;
    public TypeNode ElementTypeExpression;
    public ExpressionList Initializers;
    public ConstructFlexArray(TypeNode elementType, ExpressionList sizes, ExpressionList initializers);
}
public class System.Compiler.ConstructIterator : Expression {
    public Class State;
    public Block Body;
    public TypeNode ElementType;
    public ConstructIterator(Class state, Block body, TypeNode elementType, TypeNode type);
}
public class System.Compiler.ConstructTuple : Expression {
    public FieldList Fields;
}
public class System.Compiler.COR_FIELD_OFFSET : ValueType {
    public UInt32 ridOfField;
    public UInt32 ulOffset;
}
public class System.Compiler.CoreSystemTypes : object {
    internal static bool Initialized;
    internal static bool doNotLockFile;
    internal static bool getDebugInfo;
    internal static PostAssemblyLoadProcessor postAssemblyLoad;
    public static AssemblyNode SystemAssembly;
    public static Class Object;
    public static Class String;
    public static Class ValueType;
    public static Class Enum;
    public static Class MulticastDelegate;
    public static Class Array;
    public static Class Type;
    public static Class Delegate;
    public static Class Exception;
    public static Class Attribute;
    public static Struct Boolean;
    public static Struct Char;
    public static Struct Int8;
    public static Struct UInt8;
    public static Struct Int16;
    public static Struct UInt16;
    public static Struct Int32;
    public static Struct UInt32;
    public static Struct Int64;
    public static Struct UInt64;
    public static Struct Single;
    public static Struct Double;
    public static Struct IntPtr;
    public static Struct UIntPtr;
    public static Struct DynamicallyTypedReference;
    public static Class DBNull;
    public static Struct DateTime;
    public static Struct Decimal;
    public static Class IsVolatile;
    public static Struct Void;
    public static Struct ArgIterator;
    public static Struct RuntimeFieldHandle;
    public static Struct RuntimeMethodHandle;
    public static Struct RuntimeTypeHandle;
    public static Struct RuntimeArgumentHandle;
    public static EnumNode SecurityAction;
    internal static bool IsInitialized { get; }
    private static CoreSystemTypes();
    internal static bool get_IsInitialized();
    public static void Clear();
    public static void Initialize(bool doNotLockFile, bool getDebugInfo, PostAssemblyLoadProcessor postAssemblyLoad);
    private static void ClearStatics();
    private static void InstantiateGenericInterfaces();
    private static void InstantiateGenericInterfaces(TypeNode type);
    private static AssemblyNode GetSystemAssembly(bool doNotLockFile, bool getDebugInfo, PostAssemblyLoadProcessor postAssemblyLoad);
    private static TypeNode GetTypeNodeFor(string nspace, string name, ElementType typeCode);
    internal static TypeNode GetDummyTypeNode(AssemblyNode declaringAssembly, string nspace, string name, ElementType typeCode);
}
public class System.Compiler.DebugSymbolsCouldNotBeWrittenException : ApplicationException {
}
internal class System.Compiler.Delayed`1 : ValueType {
    private T cached;
    private Func`1<TypeNode> delayed;
    public Delayed`1(Func`1<TypeNode> delayed);
    public static T op_Implicit(Delayed`1<T> delayed);
    public static Delayed`1<T> op_Implicit(Func`1<TypeNode> delayed);
    private T GetValue();
    public void Clear();
}
public class System.Compiler.DelegateNode : TypeNode {
    internal static DelegateNode Dummy;
    protected ParameterList parameters;
    protected TypeNode returnType;
    public TypeNode ReturnTypeExpression;
    private bool membersAlreadyProvided;
    public ParameterList Parameters { get; public set; }
    public TypeNode ReturnType { get; public set; }
    public DelegateNode(NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public DelegateNode(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags flags, Identifier Namespace, Identifier name, TypeNode returnType, ParameterList parameters);
    private static DelegateNode();
    public virtual ParameterList get_Parameters();
    public virtual void set_Parameters(ParameterList value);
    public virtual TypeNode get_ReturnType();
    public virtual void set_ReturnType(TypeNode value);
    public virtual void ProvideMembers();
}
public class System.Compiler.Document : object {
    public Guid DocumentType;
    public Guid Language;
    public Guid LanguageVendor;
    public int LineNumber;
    public bool Hidden;
    public string Name;
    public DocumentText Text;
    private Int32[] lineOffsets;
    private int lines;
    private static int uniqueKeyCounter;
    private int uniqueKey;
    public int UniqueKey { get; }
    public Document(string name, int lineNumber, string text, Guid documentType, Guid language, Guid languageVendor);
    public Document(string name, int lineNumber, DocumentText text, Guid documentType, Guid language, Guid languageVendor);
    public virtual int GetLine(int position);
    public virtual int GetColumn(int position);
    public virtual void GetOffsets(int startLine, int startColumn, int endLine, int endColumn, Int32& startPos, Int32& endPos);
    public virtual string Substring(int position, int length);
    protected static int GetLineCount(string text);
    private int Search(int offset);
    private void GetPosition(int offset, Int32& line, Int32& column);
    private void AddOffset(int offset);
    public virtual void InsertOrDeleteLines(int offset, int lineCount);
    private void DeleteLines(int offset, int lineCount);
    private void InsertLines(int offset, int lineCount);
    private void ComputeLineOffsets();
    public int get_UniqueKey();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.DocumentText : object {
    public Byte* AsciiStringPtr;
    public string Source;
    public ISourceText TextProvider;
    public int Length;
    public char Item { get; }
    public DocumentText(string source);
    public DocumentText(ISourceText textProvider);
    public DocumentText(ISourceTextBuffer textProvider);
    public bool Equals(string str, int position, int length);
    public bool Equals(int offset, DocumentText text, int textOffset, int length);
    public string Substring(int position, int length);
    public char get_Item(int position);
}
public class System.Compiler.Duplicator : StandardVisitor {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TrivialHashtable <DuplicateFor>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TrivialHashtable <TypesToBeDuplicated>k__BackingField;
    public Module TargetModule;
    public TypeNode TargetType;
    public Method TargetMethod;
    public TypeNode OriginalTargetType;
    public bool SkipBodies;
    public bool RecordOriginalAsTemplate;
    public bool CopyDocumentation;
    public Block DummyBody;
    public TrivialHashtable DuplicateFor { get; private set; }
    public TrivialHashtable TypesToBeDuplicated { get; private set; }
    public Duplicator(Module module, TypeNode type);
    public Duplicator(Module module, TypeNode type, int initialCapacity);
    [CompilerGeneratedAttribute]
public TrivialHashtable get_DuplicateFor();
    [CompilerGeneratedAttribute]
private void set_DuplicateFor(TrivialHashtable value);
    [CompilerGeneratedAttribute]
public TrivialHashtable get_TypesToBeDuplicated();
    [CompilerGeneratedAttribute]
private void set_TypesToBeDuplicated(TrivialHashtable value);
    private void ObjectInvariant();
    public virtual void FindTypesToBeDuplicated(NamespaceList namespaces);
    public virtual void FindTypesToBeDuplicated(TypeNodeList types);
    private bool RegisterTypeToBeDuplicated(TypeNode t);
    private bool RegisterMemberToBeDuplicated(Member m);
    public virtual void FindMembersToBeDuplicated(MemberList members);
    public virtual Node Visit(Node node);
    public virtual Expression VisitAddressDereference(AddressDereference addr);
    public virtual AssemblyNode VisitAssembly(AssemblyNode assembly);
    public virtual AssemblyReference VisitAssemblyReference(AssemblyReference assemblyReference);
    public virtual Statement VisitAssertion(Assertion assertion);
    public virtual Statement VisitAssumption(Assumption Assumption);
    public virtual Expression VisitAssignmentExpression(AssignmentExpression assignment);
    public virtual Statement VisitAssignmentStatement(AssignmentStatement assignment);
    public virtual Expression VisitAttributeConstructor(AttributeNode attribute);
    public virtual AttributeNode VisitAttributeNode(AttributeNode attribute);
    public virtual AttributeList VisitAttributeList(AttributeList attributes);
    public virtual Expression VisitBinaryExpression(BinaryExpression binaryExpression);
    public virtual Block VisitBlock(Block block);
    public virtual Expression VisitBlockExpression(BlockExpression blockExpression);
    public virtual BlockList VisitBlockList(BlockList blockList);
    public virtual Statement VisitBranch(Branch branch);
    public virtual Expression VisitConstruct(Construct cons);
    public virtual Expression VisitConstructArray(ConstructArray consArr);
    public virtual DelegateNode VisitDelegateNode(DelegateNode delegateNode);
    public virtual Statement VisitEndFilter(EndFilter endFilter);
    public virtual Statement VisitEndFinally(EndFinally endFinally);
    public virtual EnsuresList VisitEnsuresList(EnsuresList Ensures);
    public virtual Event VisitEvent(Event evnt);
    public virtual ExceptionHandler VisitExceptionHandler(ExceptionHandler handler);
    public virtual ExceptionHandlerList VisitExceptionHandlerList(ExceptionHandlerList handlers);
    public virtual EnsuresExceptional VisitEnsuresExceptional(EnsuresExceptional exceptional);
    public virtual Expression VisitExpression(Expression expression);
    public virtual ExpressionList VisitExpressionList(ExpressionList expressions);
    public virtual Statement VisitExpressionStatement(ExpressionStatement statement);
    public virtual Statement VisitFaultHandler(FaultHandler faultHandler);
    public virtual FaultHandlerList VisitFaultHandlerList(FaultHandlerList faultHandlers);
    public virtual Field VisitField(Field field);
    public virtual Expression VisitIdentifier(Identifier identifier);
    public virtual Expression VisitIndexer(Indexer indexer);
    public virtual InterfaceList VisitInterfaceReferenceList(InterfaceList interfaceReferences);
    public virtual Statement VisitLabeledStatement(LabeledStatement lStatement);
    public virtual Expression VisitLiteral(Literal literal);
    public virtual Expression VisitLocal(Local local);
    public virtual Expression VisitMemberBinding(MemberBinding memberBinding);
    public virtual MemberList VisitMemberList(MemberList members);
    public virtual Member VisitMemberReference(Member member);
    public virtual MemberList VisitMemberReferenceList(MemberList members);
    public virtual Method VisitMethod(Method method);
    public Method VisitMethodInternal(Method method);
    public virtual Expression VisitMethodCall(MethodCall call);
    public virtual MethodContract VisitMethodContract(MethodContract contract);
    public virtual MethodList VisitMethodList(MethodList methods);
    public virtual MethodList VisitMethodReferenceList(MethodList methods);
    public virtual Module VisitModule(Module module);
    public virtual Module VisitModuleReference(Module module);
    public virtual ModuleReference VisitModuleReference(ModuleReference moduleReference);
    public virtual Expression VisitNamedArgument(NamedArgument namedArgument);
    public virtual EnsuresNormal VisitEnsuresNormal(EnsuresNormal normal);
    public virtual Expression VisitOldExpression(OldExpression oldExpression);
    public virtual Expression VisitReturnValue(ReturnValue retval);
    public virtual RequiresOtherwise VisitRequiresOtherwise(RequiresOtherwise otherwise);
    public virtual Expression VisitParameter(Parameter parameter);
    public virtual ParameterList VisitParameterList(ParameterList parameterList);
    public virtual RequiresPlain VisitRequiresPlain(RequiresPlain plain);
    public virtual Expression VisitPrefixExpression(PrefixExpression pExpr);
    public virtual Expression VisitPostfixExpression(PostfixExpression pExpr);
    public virtual Property VisitProperty(Property property);
    public virtual RequiresList VisitRequiresList(RequiresList Requires);
    public virtual Statement VisitReturn(Return Return);
    public virtual SecurityAttribute VisitSecurityAttribute(SecurityAttribute attribute);
    public virtual SecurityAttributeList VisitSecurityAttributeList(SecurityAttributeList attributes);
    public virtual StatementList VisitStatementList(StatementList statements);
    public virtual Statement VisitSwitchInstruction(SwitchInstruction switchInstruction);
    public virtual Expression VisitTernaryExpression(TernaryExpression expression);
    public virtual Expression VisitThis(This This);
    public virtual Statement VisitThrow(Throw Throw);
    public virtual TypeContract VisitTypeContract(TypeContract contract);
    public virtual TypeModifier VisitTypeModifier(TypeModifier typeModifier);
    public virtual TypeNode VisitTypeNode(TypeNode type);
    internal TypeNode VisitTypeNode(TypeNode type, Identifier mangledName, TypeNodeList templateArguments, TypeNode template, bool delayVisitToNestedTypes);
    private void ProvideTypeSignature(TypeNode dup, object handle);
    private void ProvideNestedTypes(TypeNode dup, object handle);
    private void ProvideTypeMembers(TypeNode dup, object handle);
    protected virtual void ProvideMethodBody(Method dup, object handle, bool asInstructionList);
    protected virtual void ProvideMethodAttributes(Method dup, object handle);
    protected virtual void ProvideMethodContract(Method dup, object handle);
    private void ProvideTypeAttributes(TypeNode dup, object handle);
    public virtual TypeNodeList VisitNestedTypes(TypeNode declaringType, TypeNodeList types);
    public virtual TypeNodeList VisitTypeNodeList(TypeNodeList types);
    public virtual TypeNode VisitTypeParameter(TypeNode typeParameter);
    public virtual TypeNodeList VisitTypeParameterList(TypeNodeList typeParameters);
    public virtual TypeNode VisitTypeReference(TypeNode type);
    public virtual TypeNode VisitTemplateTypeReference(TypeNode type);
    public virtual TypeNodeList VisitTypeReferenceList(TypeNodeList typeReferences);
    public virtual Expression VisitUnaryExpression(UnaryExpression unaryExpression);
}
public class System.Compiler.EndFilter : Statement {
    private Expression value;
    public Expression Value { get; public set; }
    public EndFilter(Expression value);
    public Expression get_Value();
    public void set_Value(Expression value);
}
public class System.Compiler.EndFinally : Statement {
}
public abstract class System.Compiler.Ensures : MethodContractElement {
    public Expression PostCondition;
    public Expression Assertion { get; }
    protected Ensures(NodeType nodeType);
    protected Ensures(NodeType nodeType, Expression expression);
    public virtual Expression get_Assertion();
}
public class System.Compiler.EnsuresExceptional : Ensures {
    public TypeNode Type;
    public TypeNode TypeExpression;
    public Expression Variable;
    public EnsuresExceptional(Expression expression);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.EnsuresList : object {
    private Ensures[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Ensures Item { get; public set; }
    public EnsuresList(int capacity);
    public void Add(Ensures element);
    public EnsuresList Clone();
    public int get_Count();
    public int get_Length();
    public Ensures get_Item(int index);
    public void set_Item(int index, Ensures value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.EnsuresNormal : Ensures {
    public EnsuresNormal(Expression expression);
}
public class System.Compiler.EnumNode : TypeNode {
    internal static EnumNode Dummy;
    protected internal TypeNode underlyingType;
    public TypeNode UnderlyingTypeExpression;
    public bool IsUnmanaged { get; }
    public TypeNode UnderlyingType { get; public set; }
    public EnumNode(NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public EnumNode(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags typeAttributes, Identifier Namespace, Identifier name, InterfaceList interfaces, MemberList members);
    private static EnumNode();
    public virtual bool get_IsUnmanaged();
    public virtual TypeNode get_UnderlyingType();
    public virtual void set_UnderlyingType(TypeNode value);
}
public class System.Compiler.Event : Member {
    private EventFlags flags;
    private Method handlerAdder;
    private Method handlerCaller;
    private MethodFlags handlerFlags;
    private Method handlerRemover;
    private TypeNode handlerType;
    private MethodList otherMethods;
    public TypeNode HandlerTypeExpression;
    public TypeNodeList ImplementedTypes;
    public TypeNodeList ImplementedTypeExpressions;
    public Expression InitialHandler;
    public Field BackingField;
    protected string fullName;
    protected EventInfo eventInfo;
    public static Event NotSpecified;
    protected Property hiddenEvent;
    protected Property overriddenEvent;
    public EventFlags Flags { get; public set; }
    public Method HandlerAdder { get; public set; }
    public Method HandlerCaller { get; public set; }
    public MethodFlags HandlerFlags { get; public set; }
    public Method HandlerRemover { get; public set; }
    public TypeNode HandlerType { get; public set; }
    public MethodList OtherMethods { get; public set; }
    public string FullName { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public Member HiddenMember { get; public set; }
    public Event HiddenEvent { get; public set; }
    public Member OverriddenMember { get; public set; }
    public Event OverriddenEvent { get; public set; }
    public Event(TypeNode declaringType, AttributeList attributes, EventFlags flags, Identifier name, Method handlerAdder, Method handlerCaller, Method handlerRemover, TypeNode handlerType);
    private static Event();
    public EventFlags get_Flags();
    public void set_Flags(EventFlags value);
    public Method get_HandlerAdder();
    public void set_HandlerAdder(Method value);
    public Method get_HandlerCaller();
    public void set_HandlerCaller(Method value);
    public MethodFlags get_HandlerFlags();
    public void set_HandlerFlags(MethodFlags value);
    public Method get_HandlerRemover();
    public void set_HandlerRemover(Method value);
    public TypeNode get_HandlerType();
    public void set_HandlerType(TypeNode value);
    public MethodList get_OtherMethods();
    public void set_OtherMethods(MethodList value);
    public virtual string get_FullName();
    protected virtual Identifier GetDocumentationId();
    public static Event GetEvent(EventInfo eventInfo);
    public virtual EventInfo GetEventInfo();
    public bool get_IsAbstract();
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public bool get_IsFinal();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPublic();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public bool get_IsVirtual();
    public virtual bool get_IsVisibleOutsideAssembly();
    public virtual Member get_HiddenMember();
    public virtual void set_HiddenMember(Member value);
    public virtual Event get_HiddenEvent();
    public virtual void set_HiddenEvent(Event value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual Event get_OverriddenEvent();
    public virtual void set_OverriddenEvent(Event value);
}
[FlagsAttribute]
public enum System.Compiler.EventFlags : Enum {
    public int value__;
    public static EventFlags None;
    public static EventFlags SpecialName;
    public static EventFlags ReservedMask;
    public static EventFlags RTSpecialName;
    public static EventFlags Extend;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.EventList : object {
    private Event[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Event Item { get; public set; }
    public EventList(int n);
    public void Add(Event element);
    public int get_Count();
    public int get_Length();
    public Event get_Item(int index);
    public void set_Item(int index, Event value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.ExceptionHandler : Node {
    private NodeType handlerType;
    private Block tryStartBlock;
    private Block blockAfterTryEnd;
    private Block handlerStartBlock;
    private Block blockAfterHandlerEnd;
    private Block filterExpression;
    private TypeNode filterType;
    public NodeType HandlerType { get; public set; }
    public Block TryStartBlock { get; public set; }
    public Block BlockAfterTryEnd { get; public set; }
    public Block HandlerStartBlock { get; public set; }
    public Block BlockAfterHandlerEnd { get; public set; }
    public Block FilterExpression { get; public set; }
    public TypeNode FilterType { get; public set; }
    public NodeType get_HandlerType();
    public void set_HandlerType(NodeType value);
    public Block get_TryStartBlock();
    public void set_TryStartBlock(Block value);
    public Block get_BlockAfterTryEnd();
    public void set_BlockAfterTryEnd(Block value);
    public Block get_HandlerStartBlock();
    public void set_HandlerStartBlock(Block value);
    public Block get_BlockAfterHandlerEnd();
    public void set_BlockAfterHandlerEnd(Block value);
    public Block get_FilterExpression();
    public void set_FilterExpression(Block value);
    public TypeNode get_FilterType();
    public void set_FilterType(TypeNode value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ExceptionHandlerList : object {
    private ExceptionHandler[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public ExceptionHandler Item { get; public set; }
    public ExceptionHandlerList(int n);
    public void Add(ExceptionHandler element);
    public ExceptionHandlerList Clone();
    public int get_Count();
    public int get_Length();
    public ExceptionHandler get_Item(int index);
    public void set_Item(int index, ExceptionHandler value);
    public Enumerator GetEnumerator();
}
internal class System.Compiler.ExceptionStrings : object {
    private static WeakReference resMgr;
    internal static ResourceManager ResourceManager { get; }
    internal static string AssemblyReferenceNotResolved { get; }
    internal static string BadBlobHeapIndex { get; }
    internal static string BadCLIHeader { get; }
    internal static string BadCOFFHeaderSignature { get; }
    internal static string BadConstantParentIndex { get; }
    internal static string BadCustomAttributeTypeEncodedToken { get; }
    internal static string BaddCalliSignature { get; }
    internal static string BadExceptionHandlerType { get; }
    internal static string BadGuidHeapIndex { get; }
    internal static string BadMagicNumber { get; }
    internal static string BadMemberToken { get; }
    internal static string BadMetadataHeaderSignature { get; }
    internal static string BadMetadataInExportTypeTableNoSuchAssemblyReference { get; }
    internal static string BadMetadataInExportTypeTableNoSuchParentType { get; }
    internal static string BadMethodHeaderSection { get; }
    internal static string BadMethodTypeParameterInPosition { get; }
    internal static string BadPEHeaderMagicNumber { get; }
    internal static string BadSecurityPermissionSetBlob { get; }
    internal static string BadSerializedTypeName { get; }
    internal static string BadStringHeapIndex { get; }
    internal static string BadTargetPlatformLocation { get; }
    internal static string BadTypeDefOrRef { get; }
    internal static string BadTypeParameterInPositionForType { get; }
    internal static string BadUserStringHeapIndex { get; }
    internal static string CannotLoadTypeExtension { get; }
    internal static string CollectionIsReadOnly { get; }
    internal static string CouldNotFindExportedNestedTypeInType { get; }
    internal static string CouldNotFindExportedTypeInAssembly { get; }
    internal static string CouldNotFindExportedTypeInModule { get; }
    internal static string CouldNotFindReferencedModule { get; }
    internal static string CouldNotResolveMemberReference { get; }
    internal static string CouldNotResolveType { get; }
    internal static string CouldNotResolveTypeReference { get; }
    internal static string CreateFileMappingReturnedErrorCode { get; }
    internal static string ENCLogTableEncountered { get; }
    internal static string ENCMapTableEncountered { get; }
    internal static string FileTooBig { get; }
    internal static string GetReaderForFileReturnedUnexpectedHResult { get; }
    internal static string InternalCompilerError { get; }
    internal static string InvalidBaseClass { get; }
    internal static string InvalidFatMethodHeader { get; }
    internal static string InvalidLocalSignature { get; }
    internal static string InvalidModuleTable { get; }
    internal static string InvalidTypeTableIndex { get; }
    internal static string MalformedSignature { get; }
    internal static string MapViewOfFileReturnedErrorCode { get; }
    internal static string ModuleOrAssemblyDependsOnMoreRecentVersionOfCoreLibrary { get; }
    internal static string ModuleError { get; }
    internal static string NoMetadataStream { get; }
    internal static string PdbAssociatedWithFileIsOutOfDate { get; }
    internal static string SecurityAttributeTypeDoesNotHaveADefaultConstructor { get; }
    internal static string TooManyMethodHeaderSections { get; }
    internal static string UnexpectedTypeInCustomAttribute { get; }
    internal static string UnknownConstantType { get; }
    internal static string UnknownOpCode { get; }
    internal static string UnknownOpCodeEncountered { get; }
    internal static string UnknownVirtualAddress { get; }
    internal static string UnresolvedAssemblyReferenceNotAllowed { get; }
    internal static string UnresolvedModuleReferenceNotAllowed { get; }
    internal static string UnsupportedTableEncountered { get; }
    internal static string InvalidAssemblyStrongName { get; }
    internal static string KeyNeedsToBeGreaterThanZero { get; }
    private static ExceptionStrings();
    internal static ResourceManager get_ResourceManager();
    internal static string get_AssemblyReferenceNotResolved();
    internal static string get_BadBlobHeapIndex();
    internal static string get_BadCLIHeader();
    internal static string get_BadCOFFHeaderSignature();
    internal static string get_BadConstantParentIndex();
    internal static string get_BadCustomAttributeTypeEncodedToken();
    internal static string get_BaddCalliSignature();
    internal static string get_BadExceptionHandlerType();
    internal static string get_BadGuidHeapIndex();
    internal static string get_BadMagicNumber();
    internal static string get_BadMemberToken();
    internal static string get_BadMetadataHeaderSignature();
    internal static string get_BadMetadataInExportTypeTableNoSuchAssemblyReference();
    internal static string get_BadMetadataInExportTypeTableNoSuchParentType();
    internal static string get_BadMethodHeaderSection();
    internal static string get_BadMethodTypeParameterInPosition();
    internal static string get_BadPEHeaderMagicNumber();
    internal static string get_BadSecurityPermissionSetBlob();
    internal static string get_BadSerializedTypeName();
    internal static string get_BadStringHeapIndex();
    internal static string get_BadTargetPlatformLocation();
    internal static string get_BadTypeDefOrRef();
    internal static string get_BadTypeParameterInPositionForType();
    internal static string get_BadUserStringHeapIndex();
    internal static string get_CannotLoadTypeExtension();
    internal static string get_CollectionIsReadOnly();
    internal static string get_CouldNotFindExportedNestedTypeInType();
    internal static string get_CouldNotFindExportedTypeInAssembly();
    internal static string get_CouldNotFindExportedTypeInModule();
    internal static string get_CouldNotFindReferencedModule();
    internal static string get_CouldNotResolveMemberReference();
    internal static string get_CouldNotResolveType();
    internal static string get_CouldNotResolveTypeReference();
    internal static string get_CreateFileMappingReturnedErrorCode();
    internal static string get_ENCLogTableEncountered();
    internal static string get_ENCMapTableEncountered();
    internal static string get_FileTooBig();
    internal static string get_GetReaderForFileReturnedUnexpectedHResult();
    internal static string get_InternalCompilerError();
    internal static string get_InvalidBaseClass();
    internal static string get_InvalidFatMethodHeader();
    internal static string get_InvalidLocalSignature();
    internal static string get_InvalidModuleTable();
    internal static string get_InvalidTypeTableIndex();
    internal static string get_MalformedSignature();
    internal static string get_MapViewOfFileReturnedErrorCode();
    internal static string get_ModuleOrAssemblyDependsOnMoreRecentVersionOfCoreLibrary();
    internal static string get_ModuleError();
    internal static string get_NoMetadataStream();
    internal static string get_PdbAssociatedWithFileIsOutOfDate();
    internal static string get_SecurityAttributeTypeDoesNotHaveADefaultConstructor();
    internal static string get_TooManyMethodHeaderSections();
    internal static string get_UnexpectedTypeInCustomAttribute();
    internal static string get_UnknownConstantType();
    internal static string get_UnknownOpCode();
    internal static string get_UnknownOpCodeEncountered();
    internal static string get_UnknownVirtualAddress();
    internal static string get_UnresolvedAssemblyReferenceNotAllowed();
    internal static string get_UnresolvedModuleReferenceNotAllowed();
    internal static string get_UnsupportedTableEncountered();
    internal static string get_InvalidAssemblyStrongName();
    internal static string get_KeyNeedsToBeGreaterThanZero();
}
public class System.Compiler.Expression : Node {
    private TypeNode type;
    public int ILOffset;
    public TypeNode Type { get; public set; }
    public Expression(NodeType nodeType);
    public Expression(NodeType nodeType, TypeNode type);
    public virtual TypeNode get_Type();
    public virtual void set_Type(TypeNode value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ExpressionList : object {
    private Expression[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Expression Item { get; public set; }
    public ExpressionList(int n);
    public ExpressionList(Expression[] elements);
    public void Add(Expression element);
    public ExpressionList Clone();
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Expression get_Item(int index);
    public void set_Item(int index, Expression value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.ExpressionStatement : Statement {
    private Expression expression;
    public Expression Expression { get; public set; }
    public ExpressionStatement(Expression expression);
    public ExpressionStatement(Expression expression, SourceContext sctx);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
public class System.Compiler.ExtraPDBInfo : object {
    private Byte[] MD2;
    private Byte[] asyncMethodInfo;
    private Reader reader;
    private List`1<MemoryStream> customDebugMetadataForCurrentMethod;
    private PdbFunction pdbfun;
    internal ExtraPDBInfo(Reader reader);
    internal static ExtraPDBInfo Parse(UInt32 parent, Method method, ISymUnmanagedReader symreader, Reader reader);
    internal void Write(UInt32 token, ISymUnmanagedWriter writer, Ir2md ir2md);
    private void SerializeCustomDebugMetadata();
    private void SerializeReferenceToLastMethodWithUsingInfo();
    private void SerializeReferenceToIteratorClass();
    private void SerializeIteratorLocalScopes();
    private void Write(UInt32 token, ISymUnmanagedWriter writer, Byte[] data, string section);
    private bool IsEmitted(Member member);
    private void SerializeSynchronizationInformation(Ir2md writer);
}
public class System.Compiler.FaultHandler : Statement {
    private Block block;
    public Block Block { get; public set; }
    public FaultHandler(Block block);
    public Block get_Block();
    public void set_Block(Block value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.FaultHandlerList : object {
    private FaultHandler[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public FaultHandler Item { get; public set; }
    public FaultHandlerList(int n);
    public void Add(FaultHandler element);
    public FaultHandlerList Clone();
    public int get_Count();
    public int get_Length();
    public FaultHandler get_Item(int index);
    public void set_Item(int index, FaultHandler value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.Field : Member {
    public Expression Initializer;
    public TypeNode TypeExpression;
    public bool HasOutOfBandContract;
    public InterfaceList ImplementedInterfaces;
    public InterfaceList ImplementedInterfaceExpressions;
    public Event ForEvent;
    public bool IsModelfield;
    private Literal defaultValue;
    private FieldFlags flags;
    private int offset;
    private bool isVolatile;
    private TypeNode type;
    private MarshallingInformation marshallingInformation;
    private Byte[] initialData;
    internal PESection section;
    protected string fullName;
    protected FieldInfo fieldInfo;
    public Literal DefaultValue { get; public set; }
    public FieldFlags Flags { get; public set; }
    public int Offset { get; public set; }
    public bool IsVolatile { get; public set; }
    public TypeNode Type { get; public set; }
    public MarshallingInformation MarshallingInformation { get; public set; }
    public Byte[] InitialData { get; public set; }
    public PESection Section { get; public set; }
    public string FullName { get; }
    public bool IsLiteral { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public Field(Identifier name);
    public Field(TypeNode declaringType, AttributeList attributes, FieldFlags flags, Identifier name, TypeNode type, Literal defaultValue);
    public Literal get_DefaultValue();
    public void set_DefaultValue(Literal value);
    public FieldFlags get_Flags();
    public void set_Flags(FieldFlags value);
    public int get_Offset();
    public void set_Offset(int value);
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public TypeNode get_Type();
    public void set_Type(TypeNode value);
    public MarshallingInformation get_MarshallingInformation();
    public void set_MarshallingInformation(MarshallingInformation value);
    public Byte[] get_InitialData();
    public void set_InitialData(Byte[] value);
    public PESection get_Section();
    public void set_Section(PESection value);
    public virtual string get_FullName();
    protected virtual Identifier GetDocumentationId();
    public static Field GetField(FieldInfo fieldInfo);
    public virtual FieldInfo GetFieldInfo();
    public virtual bool get_IsLiteral();
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPublic();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVisibleOutsideAssembly();
    public virtual object GetValue(object targetObject);
    public virtual Literal GetValue(Literal targetObject);
    public virtual void SetValue(object targetObject, object value);
    public virtual void SetValue(Literal targetObject, Literal value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Compiler.FieldFlags : Enum {
    public int value__;
    public static FieldFlags None;
    public static FieldFlags FieldAccessMask;
    public static FieldFlags CompilerControlled;
    public static FieldFlags Private;
    public static FieldFlags FamANDAssem;
    public static FieldFlags Assembly;
    public static FieldFlags Family;
    public static FieldFlags FamORAssem;
    public static FieldFlags Public;
    public static FieldFlags Static;
    public static FieldFlags InitOnly;
    public static FieldFlags Literal;
    public static FieldFlags NotSerialized;
    public static FieldFlags SpecialName;
    public static FieldFlags PinvokeImpl;
    public static FieldFlags ReservedMask;
    public static FieldFlags RTSpecialName;
    public static FieldFlags HasFieldMarshal;
    public static FieldFlags HasDefault;
    public static FieldFlags HasFieldRVA;
}
internal class System.Compiler.FieldInfo : object {
    public bool IsStatic;
}
public class System.Compiler.FieldInitializerBlock : Block {
    public TypeNode Type;
    public bool IsStatic;
    public FieldInitializerBlock(TypeNode type, bool isStatic);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.FieldList : object {
    private Field[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Field Item { get; public set; }
    public FieldList(int capacity);
    public FieldList(Field[] elements);
    public void Add(Field element);
    public FieldList Clone();
    public int get_Count();
    public int get_Length();
    public Field get_Item(int index);
    public void set_Item(int index, Field value);
    public Enumerator GetEnumerator();
}
[FlagsAttribute]
public enum System.Compiler.FileFlags : Enum {
    public int value__;
    public static FileFlags ContainsMetaData;
    public static FileFlags ContainsNoMetaData;
}
public class System.Compiler.Filter : Statement {
    private Block block;
    private Expression expression;
    public Block Block { get; public set; }
    public Expression Expression { get; public set; }
    public Filter(Block block, Expression expression);
    public Block get_Block();
    public void set_Block(Block value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.FilterList : object {
    private Filter[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Filter Item { get; public set; }
    public FilterList(int capacity);
    public void Add(Filter element);
    public FilterList Clone();
    public int get_Count();
    public int get_Length();
    public Filter get_Item(int index);
    public void set_Item(int index, Filter value);
    public Enumerator GetEnumerator();
}
internal class System.Compiler.Fixup : object {
    internal int fixupLocation;
    internal int addressOfNextInstruction;
    internal bool shortOffset;
    internal Fixup nextFixUp;
}
public class System.Compiler.FlexArrayTypeExpression : TypeNode {
    public TypeNode ElementType;
    public FlexArrayTypeExpression(TypeNode elementType);
    public FlexArrayTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.FunctionDeclaration : Statement {
    public Identifier Name;
    public ParameterList Parameters;
    public TypeNode ReturnType;
    public TypeNode ReturnTypeExpression;
    public Block Body;
    public Method Method;
    public FunctionDeclaration(Identifier name, ParameterList parameters, TypeNode returnType, Block body);
}
public class System.Compiler.FunctionPointer : TypeNode {
    private CallingConventionFlags callingConvention;
    private TypeNodeList parameterTypes;
    private TypeNode returnType;
    private int varArgStart;
    protected TypeNodeList structuralElementTypes;
    public CallingConventionFlags CallingConvention { get; public set; }
    public TypeNodeList ParameterTypes { get; public set; }
    public TypeNode ReturnType { get; public set; }
    public int VarArgStart { get; public set; }
    public bool IsStatic { get; }
    public bool IsStructural { get; }
    public TypeNodeList StructuralElementTypes { get; }
    internal FunctionPointer(TypeNodeList parameterTypes, TypeNode returnType, Identifier name);
    public CallingConventionFlags get_CallingConvention();
    public void set_CallingConvention(CallingConventionFlags value);
    public TypeNodeList get_ParameterTypes();
    public void set_ParameterTypes(TypeNodeList value);
    public TypeNode get_ReturnType();
    public void set_ReturnType(TypeNode value);
    public int get_VarArgStart();
    public void set_VarArgStart(int value);
    public virtual bool get_IsStatic();
    public virtual bool get_IsStructural();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
    public static FunctionPointer For(TypeNodeList parameterTypes, TypeNode returnType);
    private static bool ParameterTypesAreEquivalent(TypeNodeList list1, TypeNodeList list2);
}
public class System.Compiler.FunctionType : DelegateNode {
    protected TypeNodeList structuralElementTypes;
    public bool IsStructural { get; }
    public TypeNodeList StructuralElementTypes { get; }
    private FunctionType(Identifier name, TypeNode returnType, ParameterList parameters);
    public static FunctionType For(TypeNode returnType, ParameterList parameters, TypeNode referringType);
    public virtual bool get_IsStructural();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.FunctionTypeExpression : TypeNode {
    public ParameterList Parameters;
    public TypeNode ReturnType;
    public FunctionTypeExpression(TypeNode returnType, ParameterList parameters);
    public FunctionTypeExpression(TypeNode returnType, ParameterList parameters, SourceContext sctx);
}
public class System.Compiler.GlobalAssemblyCache : object {
    private static object Lock;
    private static bool FusionLoaded;
    public static bool probeGAC;
    private static GlobalAssemblyCache();
    public static bool Contains(Uri codeBaseUri);
    public static string GetLocation(AssemblyReference assemblyReference);
    private static IntPtr LoadLibrary(string lpFileName);
    private static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, UInt32 dwFlags, int pvReserved);
}
public class System.Compiler.HiddenDocument : Document {
    public static HiddenDocument Document;
    private static HiddenDocument();
    public virtual int GetColumn(int position);
    public virtual int GetLine(int position);
}
[GuidAttribute("7C23FF90-33AF-11D3-95DA-00A024A85B51")]
[InterfaceTypeAttribute("1")]
internal interface System.Compiler.IApplicationContext {
    public abstract virtual void SetContextNameObject(IAssemblyName pName);
    public abstract virtual void GetContextNameObject(IAssemblyName& ppName);
    public abstract virtual void Set(string szName, int pvValue, UInt32 cbValue, UInt32 dwFlags);
    public abstract virtual void Get(string szName, Int32& pvValue, UInt32& pcbValue, UInt32 dwFlags);
    public abstract virtual void GetDynamicDirectory(Int32& wzDynamicDir, UInt32& pdwSize);
}
[GuidAttribute("21B8916C-F28E-11D2-A473-00C04F8EF448")]
[InterfaceTypeAttribute("1")]
internal interface System.Compiler.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IApplicationContext& ppAppCtx, IAssemblyName& ppName, UInt32 dwFlags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[GuidAttribute("CD193BC0-B4BC-11D2-9833-00C04FC31D2E")]
[InterfaceTypeAttribute("1")]
internal interface System.Compiler.IAssemblyName {
    public abstract virtual int SetProperty(UInt32 PropertyId, IntPtr pvProperty, UInt32 cbProperty);
    public abstract virtual int GetProperty(UInt32 PropertyId, IntPtr pvProperty, UInt32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(StringBuilder szDisplayName, UInt32& pccDisplayName, UInt32 dwDisplayFlags);
    public abstract virtual int BindToObject(object refIID, object pAsmBindSink, IApplicationContext pApplicationContext, string szCodeBase, long llFlags, int pvReserved, UInt32 cbReserved, Int32& ppv);
    public abstract virtual int GetName(UInt32& lpcwBuffer, Int32& pwzName);
    public abstract virtual int GetVersion(UInt32& pdwVersionHi, UInt32& pdwVersionLow);
    public abstract virtual int IsEqual(IAssemblyName pName, UInt32 dwCmpFlags);
    public abstract virtual int Clone(IAssemblyName& pName);
}
public class System.Compiler.Identifier : Expression {
    private int hashCode;
    internal int length;
    private string name;
    private int offset;
    public Identifier Prefix;
    public static Identifier Empty;
    private static object Lock;
    private static CanonicalIdentifier[] HashTable;
    private static int count;
    private int uniqueIdKey;
    public string Name { get; }
    public int UniqueIdKey { get; }
    [ObsoleteAttribute("Use Identifier.UniqueIdKey instead")]
public int UniqueKey { get; }
    public Identifier(string name);
    public Identifier(string name, SourceContext sctx);
    private Identifier(Byte* pointer, int offset);
    private Identifier(Byte* pointer, UInt32 length);
    private static Identifier();
    public static Identifier For(string name);
    private static bool ComputeHash(Byte* pointer, int offset, Int32& length, UInt64& hcode);
    internal static Identifier For(Byte* pointer, int offset);
    internal static Identifier For(Byte* pointer, UInt32 length);
    private int GetUniqueIdKey();
    private static Identifier TryHashLookup(Byte* ptr, int offset, int slen, int hcode);
    private static bool HasSameNameAs(string name, Byte* ptr, int offset, int slen);
    private bool HasSameNameAs(CanonicalIdentifier id);
    public string get_Name();
    private static void Rehash();
    public virtual string ToString();
    public int get_UniqueIdKey();
    public int get_UniqueKey();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.IdentifierList : object {
    private Identifier[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Identifier Item { get; public set; }
    public IdentifierList(int capacity);
    public void Add(Identifier element);
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Identifier get_Item(int index);
    public void set_Item(int index, Identifier value);
    public Enumerator GetEnumerator();
}
internal class System.Compiler.ImageDebugDirectory : ValueType {
    internal int Characteristics;
    internal int TimeDateStamp;
    internal short MajorVersion;
    internal short MinorVersion;
    internal int Type;
    internal int SizeOfData;
    internal int AddressOfRawData;
    internal int PointerToRawData;
    public ImageDebugDirectory(bool zeroFill);
}
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
public interface System.Compiler.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string szName);
    public abstract virtual void Save(string szFile, UInt32 dwSaveFlags);
    public abstract virtual void SaveToStream(Void* pIStream, UInt32 dwSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 fSave);
    public abstract virtual UInt32 DefineTypeDef(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    public abstract virtual UInt32 DefineNestedType(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements, UInt32 tdEncloser);
    public abstract virtual void SetHandler(object pUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, Char* zName, UInt32 dwMethodFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, Char* szName);
    public abstract virtual UInt32 DefineImportType(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, Byte* pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, COR_FIELD_OFFSET* rFieldOffsets, UInt32 ulClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, Byte* pvNativeType, UInt32 cbNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public abstract virtual UInt32 GetTokenFromSig(Byte* pvSig, UInt32 cbSig);
    public abstract virtual UInt32 DefineModuleRef(string szName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(Byte* pvSig, UInt32 cbSig);
    public abstract virtual void SaveToMemory(Void* pbData, UInt32 cbData);
    public abstract virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tkObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, Byte* pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport import, Byte* pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, Byte* pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public abstract virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public abstract virtual void MergeEnd();
}
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
public interface System.Compiler.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 hEnum);
    public abstract virtual UInt32 CountEnum(UInt32 hEnum);
    public abstract virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public abstract virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, UInt32* rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, UInt32* rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, UInt32* rProperties, UInt32 cMax);
    public abstract virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, UInt32* rEvents, UInt32 cMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 mdSig, Byte*& ppvSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, Void*& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(Void* pvSig, UInt32 cbSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
public class System.Compiler.Indexer : NaryExpression {
    public Property CorrespondingDefaultIndexedProperty;
    public bool ArgumentListIsIncomplete;
    private Expression object;
    private TypeNode elementType;
    public Expression Object { get; public set; }
    public TypeNode ElementType { get; public set; }
    public Indexer(Expression object, ExpressionList arguments);
    public Indexer(Expression Object, ExpressionList arguments, SourceContext sctx);
    public Indexer(Expression Object, ExpressionList arguments, TypeNode elementType);
    public Indexer(Expression Object, ExpressionList arguments, TypeNode elementType, SourceContext sctx);
    public Expression get_Object();
    public void set_Object(Expression value);
    public TypeNode get_ElementType();
    public void set_ElementType(TypeNode value);
}
public class System.Compiler.Inspector : object {
    public virtual void VisitUnknownNodeType(Node node);
    public virtual void Visit(Node node);
    public virtual void VisitAddressDereference(AddressDereference addr);
    public virtual void VisitAssembly(AssemblyNode assembly);
    public virtual AssemblyReference VisitAssemblyReference(AssemblyReference assemblyReference);
    public virtual void VisitAssertion(Assertion assertion);
    public virtual void VisitAssumption(Assumption assumption);
    public virtual void VisitAssignmentExpression(AssignmentExpression assignment);
    public virtual void VisitAssignmentStatement(AssignmentStatement assignment);
    public virtual void VisitAttributeConstructor(AttributeNode attribute);
    public virtual void VisitAttributeNode(AttributeNode attribute);
    public virtual void VisitAttributeList(AttributeList attributes);
    public virtual void VisitBinaryExpression(BinaryExpression binaryExpression);
    public virtual void VisitBlock(Block block);
    public virtual void VisitBlockExpression(BlockExpression blockExpression);
    public virtual void VisitBlockList(BlockList blockList);
    public virtual void VisitBranch(Branch branch);
    public virtual void VisitClass(Class Class);
    public virtual void VisitConstruct(Construct cons);
    public virtual void VisitConstructArray(ConstructArray consArr);
    public virtual void VisitDelegateNode(DelegateNode delegateNode);
    public virtual void VisitEndFilter(EndFilter endFilter);
    public virtual Statement VisitEndFinally(EndFinally endFinally);
    public virtual void VisitEnsuresList(EnsuresList Ensures);
    public virtual void VisitEnumNode(EnumNode enumNode);
    public virtual void VisitEvent(Event evnt);
    public virtual void VisitEnsuresExceptional(EnsuresExceptional exceptional);
    public virtual void VisitExpression(Expression expression);
    public void VisitExpressionList(ExpressionList expressions);
    public virtual void VisitExpressionStatement(ExpressionStatement statement);
    public virtual void VisitField(Field field);
    public virtual void VisitIdentifier(Identifier identifier);
    public virtual void VisitIndexer(Indexer indexer);
    public virtual void VisitInterface(Interface Interface);
    public virtual void VisitInterfaceReference(Interface Interface);
    public virtual void VisitInterfaceReferenceList(InterfaceList interfaceReferences);
    public virtual void VisitInvariant(Invariant invariant);
    public virtual void VisitInvariantList(InvariantList invariants);
    public virtual void VisitInstanceInitializer(InstanceInitializer cons);
    public virtual void VisitLiteral(Literal literal);
    public virtual void VisitLocal(Local local);
    public virtual void VisitMemberBinding(MemberBinding memberBinding);
    public virtual void VisitMemberList(MemberList members);
    public virtual void VisitMethod(Method method);
    public virtual void VisitMethodCall(MethodCall call);
    public virtual void VisitMethodContract(MethodContract contract);
    public virtual void VisitModule(Module module);
    public virtual void VisitModuleReference(ModuleReference moduleReference);
    public virtual void VisitNamedArgument(NamedArgument namedArgument);
    public virtual void VisitEnsuresNormal(EnsuresNormal normal);
    public virtual void VisitOldExpression(OldExpression oldExpression);
    public virtual void VisitReturnValue(ReturnValue returnValue);
    public virtual void VisitRequiresOtherwise(RequiresOtherwise otherwise);
    public virtual void VisitRequiresPlain(RequiresPlain plain);
    public virtual void VisitParameter(Parameter parameter);
    public virtual void VisitParameterList(ParameterList parameterList);
    public virtual void VisitProperty(Property property);
    public virtual void VisitRequiresList(RequiresList Requires);
    public virtual void VisitReturn(Return Return);
    public virtual void VisitSecurityAttribute(SecurityAttribute attribute);
    public virtual void VisitSecurityAttributeList(SecurityAttributeList attributes);
    public virtual void VisitStatementList(StatementList statements);
    public virtual void VisitStaticInitializer(StaticInitializer cons);
    public virtual void VisitStruct(Struct Struct);
    public virtual void VisitSwitchInstruction(SwitchInstruction switchInstruction);
    public virtual void VisitTargetExpression(Expression expression);
    public virtual void VisitTernaryExpression(TernaryExpression expression);
    public virtual void VisitThis(This This);
    public virtual void VisitThrow(Throw Throw);
    public virtual void VisitTypeContract(TypeContract contract);
    public virtual void VisitTypeModifier(TypeModifier typeModifier);
    public virtual void VisitTypeNode(TypeNode typeNode);
    public virtual void VisitTypeNodeList(TypeNodeList types);
    public virtual void VisitTypeParameter(TypeNode typeParameter);
    public virtual void VisitTypeParameterList(TypeNodeList typeParameters);
    public virtual void VisitTypeReference(TypeNode type);
    public virtual void VisitTypeReference(TypeReference type);
    public virtual void VisitTypeReferenceList(TypeNodeList typeReferences);
    public virtual void VisitUnaryExpression(UnaryExpression unaryExpression);
}
public class System.Compiler.InstanceInitializer : Method {
    public bool IsDeferringConstructor;
    public bool ContainsBaseMarkerBecauseOfNonNullFields;
    public Block BaseOrDefferingCallBlock;
    public bool IsCompilerGenerated;
    protected ConstructorInfo constructorInfo;
    public bool OverridesBaseClassMember { get; public set; }
    public Member OverriddenMember { get; public set; }
    public Method OverriddenMethod { get; public set; }
    public InstanceInitializer(MethodBodyProvider provider, object handle);
    public InstanceInitializer(MethodBodyProvider provider, object handle, int methodToken);
    public InstanceInitializer(TypeNode declaringType, AttributeList attributes, ParameterList parameters, Block body);
    public InstanceInitializer(TypeNode declaringType, AttributeList attributes, ParameterList parameters, Block body, TypeNode returnType);
    public virtual ConstructorInfo GetConstructorInfo();
    public virtual MethodInfo GetMethodInfo();
    public virtual object Invoke(Object[] arguments);
    public virtual Literal Invoke(Literal[] arguments);
    public virtual bool get_OverridesBaseClassMember();
    public virtual void set_OverridesBaseClassMember(bool value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual Method get_OverriddenMethod();
    public virtual void set_OverriddenMethod(Method value);
    public virtual string ToString();
    public virtual MemberList GetAttributeConstructorNamedParameters();
}
public class System.Compiler.Instruction : Node {
    private OpCode opCode;
    private int offset;
    private object value;
    public OpCode OpCode { get; public set; }
    public int Offset { get; public set; }
    public object Value { get; public set; }
    public Instruction(OpCode opCode, int offset);
    public Instruction(OpCode opCode, int offset, object value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public int get_Offset();
    public void set_Offset(int value);
    public object get_Value();
    public void set_Value(object value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.InstructionList : object {
    private Instruction[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Instruction Item { get; public set; }
    public InstructionList(int capacity);
    public void Add(Instruction element);
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Instruction get_Item(int index);
    public void set_Item(int index, Instruction value);
    public Enumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.Int32List : object {
    private Int32[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public int Item { get; public set; }
    public Int32List(int capacity);
    public Int32List(Int32[] elements);
    public void Add(int element);
    public int get_Count();
    public int get_Length();
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.Interface : TypeNode {
    protected TrivialHashtable jointMemberTable;
    protected MemberList jointDefaultMembers;
    internal static Interface Dummy;
    public Interface(InterfaceList baseInterfaces);
    public Interface(InterfaceList baseInterfaces, NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public Interface(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags flags, Identifier Namespace, Identifier name, InterfaceList baseInterfaces, MemberList members);
    private static Interface();
    public virtual void GetAbstractMethods(MethodList result);
    public virtual MemberList GetAllDefaultMembers();
    public virtual MemberList GetAllMembersNamed(Identifier name);
}
public class System.Compiler.InterfaceExpression : Interface {
    private Expression expression;
    public Expression Expression { get; public set; }
    public InterfaceExpression(Expression expression);
    public InterfaceExpression(Expression expression, SourceContext sctx);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.InterfaceList : object {
    private Interface[] elements;
    private int count;
    private AttributeList[] attributes;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Interface Item { get; public set; }
    public InterfaceList(int capacity);
    public InterfaceList(Interface[] elements);
    public void Add(Interface element);
    public void AddAttributes(int index, AttributeList attributes);
    public AttributeList AttributesFor(int index);
    public InterfaceList Clone();
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public int SearchFor(Interface element);
    public Interface get_Item(int index);
    public void set_Item(int index, Interface value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.Invariant : Method {
    public Expression Condition;
    public int ILOffset;
    public Literal UserMessage;
    public Literal SourceConditionText;
    public bool UsesModels;
    public Invariant(TypeNode declaringType, Expression invariant, string name);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.InvariantList : object {
    private Invariant[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Invariant Item { get; public set; }
    public InvariantList(int n);
    public InvariantList(Invariant[] elements);
    public void Add(Invariant element);
    public InvariantList Clone();
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Invariant get_Item(int index);
    public void set_Item(int index, Invariant value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.InvariantTypeExpression : TypeNode {
    public TypeNode ElementType;
    public InvariantTypeExpression(TypeNode elementType);
    public InvariantTypeExpression(TypeNode elementType, SourceContext sctx);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Compiler.Ir2md : object {
    private AssemblyNode assembly;
    private Module module;
    private MetadataWriter writer;
    private bool UseGenerics;
    private BinaryWriter blobHeap;
    private Hashtable blobHeapIndex;
    private Hashtable blobHeapStringIndex;
    private NodeList nodesWithCustomAttributes;
    private int customAttributeCount;
    private NodeList nodesWithSecurityAttributes;
    private int securityAttributeCount;
    private NodeList constantTableEntries;
    private TrivialHashtable assemblyRefIndex;
    private AssemblyReferenceList assemblyRefEntries;
    private TypeNodeList classLayoutEntries;
    private TrivialHashtable documentMap;
    private TrivialHashtable eventIndex;
    private EventList eventEntries;
    private TrivialHashtable eventMapIndex;
    private EventList eventMapEntries;
    private TrivialHashtable exceptionBlock;
    private TrivialHashtable fieldIndex;
    private FieldList fieldEntries;
    private FieldList fieldLayoutEntries;
    private FieldList fieldRvaEntries;
    private Hashtable fileTableIndex;
    private ModuleList fileTableEntries;
    private Hashtable genericParamIndex;
    private MemberList genericParamEntries;
    private TypeNodeList genericParameters;
    private TypeNodeList genericParamConstraintEntries;
    private ArrayList guidEntries;
    private Hashtable guidIndex;
    private MethodList implMapEntries;
    private TypeNodeList interfaceEntries;
    private NodeList marshalEntries;
    private TrivialHashtable`1<int> memberRefIndex;
    private MemberList memberRefEntries;
    private TrivialHashtable methodBodiesHeapIndex;
    private BinaryWriter methodBodiesHeap;
    private BinaryWriter methodBodyHeap;
    private MethodList methodEntries;
    private TrivialHashtable`1<int> methodIndex;
    private MethodList methodImplEntries;
    private MethodInfo methodInfo;
    private MemberList methodSemanticsEntries;
    private MethodList methodSpecEntries;
    private Hashtable methodSpecIndex;
    private ModuleReferenceList moduleRefEntries;
    private Hashtable moduleRefIndex;
    private TypeNodeList nestedClassEntries;
    private TrivialHashtable`1<int> paramIndex;
    private ParameterList paramEntries;
    private TrivialHashtable propertyIndex;
    private PropertyList propertyEntries;
    private TrivialHashtable propertyMapIndex;
    private PropertyList propertyMapEntries;
    private BinaryWriter resourceDataHeap;
    private BinaryWriter sdataHeap;
    private ISymUnmanagedWriter symWriter;
    private int stackHeight;
    private int stackHeightMax;
    private int stackHeightExitTotal;
    private ArrayList standAloneSignatureEntries;
    private BinaryWriter stringHeap;
    private Hashtable stringHeapIndex;
    private BinaryWriter tlsHeap;
    private TrivialHashtable typeDefIndex;
    private TypeNodeList typeDefEntries;
    private TrivialHashtable typeRefIndex;
    private TypeNodeList typeRefEntries;
    private TrivialHashtable typeSpecIndex;
    private TrivialHashtable structuralTypeSpecIndexFor;
    private TypeNodeList typeSpecEntries;
    private TrivialHashtable typeParameterNumber;
    private BinaryWriter userStringHeap;
    private Hashtable userStringHeapIndex;
    private Byte[] PublicKey;
    private int SignatureKeyLength;
    private static Guid IID_IUnknown;
    private static Guid IID_IClassFactory;
    private TrivialHashtable unspecializedFieldFor;
    private TrivialHashtable unspecializedMethodFor;
    private bool StripOptionalModifiersFromLocals { get; }
    internal Ir2md(Module module);
    private static Ir2md();
    private bool get_StripOptionalModifiersFromLocals();
    internal static void WritePE(Module module, string debugSymbolsLocation, BinaryWriter writer);
    private static int LoadLibrary(string lpFileName);
    private static GetClassObjectDelegate GetProcAddress(int hModule, string lpProcName);
    private static object CrossCompileActivate(string server, Guid guid);
    private void SetupMetadataWriter(string debugSymbolsLocation);
    private int GetAssemblyRefIndex(AssemblyNode assembly);
    private int GetBlobIndex(ExpressionList expressions, ParameterList parameters);
    private void WriteCustomAttributeSignature(ExpressionList expressions, ParameterList parameters, bool onlyWriteNamedArguments, BinaryWriter signature);
    private int GetBlobIndex(Byte[] blob);
    private int GetBlobIndex(string str);
    private int GetBlobIndex(Field field);
    private int GetBlobIndex(MarshallingInformation marshallingInformation);
    private int GetBlobIndex(Literal literal);
    private int GetBlobIndex(FunctionPointer fp);
    private int GetBlobIndex(Method method, bool methodSpecSignature);
    private int GetBlobIndex(AttributeList securityAttributes);
    private void WriteSecurityAttribute(BinaryWriter signature, AttributeNode attr);
    private int GetBlobIndex(Property prop);
    private int GetBlobIndex(TypeNode type);
    private int GetCustomAttributeParentCodedIndex(Node node);
    private ISymUnmanagedDocumentWriter GetDocumentWriter(Document doc);
    private ISymUnmanagedDocumentWriter GetArbitraryDocWriter();
    private int GetEventIndex(Event e);
    private int GetFieldIndex(Field f);
    private int GetGenericParamIndex(TypeNode gp);
    private int GetFieldToken(Field f);
    private bool IsStructural(TypeNode type);
    private int GetFileTableIndex(Module module);
    private int GetGuidIndex(Guid guid);
    internal int GetLocalVarIndex(Local loc);
    private int GetMemberRefParentEncoded(TypeNode type);
    private int GetMemberRefIndex(Member m);
    private int GetMemberRefToken(Method m, ExpressionList arguments);
    private int GetMethodDefOrRefEncoded(Method m);
    private int GetMethodIndex(Method m);
    private int GetMethodSpecIndex(Method m);
    private int GetMethodToken(Method m);
    internal int GetMethodDefToken(Method m);
    private int GetMethodBodiesHeapIndex(Method m);
    private int GetModuleRefIndex(Module module);
    private int GetOffset(Block target, int addressOfNextInstruction);
    private int GetOffset(Block target, Boolean& shortOffset);
    private int GetParamIndex(Parameter p);
    private int GetPropertyIndex(Property p);
    private int GetSecurityAttributeParentCodedIndex(Node node);
    private int GetStandAloneSignatureIndex(BinaryWriter signatureWriter);
    private int GetStaticDataIndex(Byte[] data, PESection targetSection);
    private int GetResourceDataIndex(Byte[] data);
    private int GetStringIndex(string str);
    private int GetUserStringIndex(string str);
    private int GetTypeDefIndex(TypeNode type);
    private int GetTypeDefOrRefOrSpecEncoded(TypeNode type);
    private int GetTypeToken(TypeNode type);
    private int GetTypeDefToken(TypeNode type);
    private int GetTypeRefIndex(TypeNode type);
    private int GetTypeSpecIndex(TypeNode type);
    private Field GetUnspecializedField(Field field);
    private Method GetUnspecializedMethod(Method method);
    internal void IncrementStackHeight();
    private void PopulateAssemblyTable();
    private void PopulateAssemblyRefTable();
    private void PopulateClassLayoutTable();
    private void PopulateConstantTable();
    private void SetConstantTableEntryValueAndTypeCode(ConstantRow[] cr, int i, Literal defaultValue);
    private void PopulateCustomAttributeTable();
    private void PopulateDeclSecurityTable();
    private void PopulateEventMapTable();
    private void PopulateEventTable();
    private void PopulateExportedTypeTable();
    private void PopulateFieldTable();
    private void PopulateFieldLayoutTable();
    private void PopulateFieldRVATable();
    private void PopulateFileTable();
    private void PopulateGuidTable();
    private void PopulateGenericParamTable();
    private void PopulateGenericParamConstraintTable();
    private void PopulateImplMapTable();
    private void PopulateInterfaceImplTable();
    private void PopulateManifestResourceTable();
    private void PopulateMarshalTable();
    private void PopulateMemberRefTable();
    private void PopulateMethodTable();
    private void PopulateMethodImplTable();
    private void PopulateMethodSpecTable();
    private void PopulateMethodSemanticsTable();
    private void PopulateModuleTable();
    private void PopulateModuleRefTable();
    private void PopulateNestedClassTable();
    private void PopulateParamTable();
    private void PopulatePropertyTable();
    private void PopulatePropertyMapTable();
    private void PopulateStandAloneSigTable();
    private void PopulateTypeDefTable();
    private void PopulateTypeRefTable();
    private void PopulateTypeSpecTable();
    private void Visit(Node node);
    private void VisitAddressDereference(AddressDereference adr);
    private void VisitAttributeList(AttributeList attrs, Node node);
    private void VisitAddressOf(UnaryExpression expr);
    private void VisitAssignmentStatement(AssignmentStatement assignment);
    private void VisitBinaryExpression(BinaryExpression binaryExpression);
    private void VisitBlock(Block block);
    private void VisitBlockExpression(BlockExpression blockExpression);
    private void VisitBranch(Branch branch);
    private void VisitMethodCall(MethodCall call);
    private void VisitClass(Class Class);
    private void VisitConstruct(Construct cons);
    private void VisitConstructArray(ConstructArray consArr);
    private void VisitDelegateNode(DelegateNode delegateNode);
    private void VisitEndFilter(EndFilter endFilter);
    private void VisitEnumNode(EnumNode enumNode);
    private void VisitEvent(Event Event);
    private void VisitExpression(Expression expression);
    private void VisitExpressionList(ExpressionList expressions);
    private void VisitExpressionStatement(ExpressionStatement statement);
    private void VisitField(Field field);
    private void VisitFixupList(Fixup fixup, int targetAddress);
    private void VisitGenericParameterList(Member member, TypeNodeList parameters);
    private void VisitIndexer(Indexer indexer);
    private void VisitInterface(Interface Interface);
    private void VisitLocal(Local local);
    private void VisitLiteral(Literal literal);
    private void VisitMemberBinding(MemberBinding memberBinding);
    private void VisitMethod(Method method);
    private void VisitMethodBody(Method method);
    private void DefineLocalVariables(int startAddress, LocalList locals);
    private void DefineSequencePoint(Node node);
    private void DefineSequencePoints(NodeList statementNodes, Int32List statementOffsets, int start, int count, ISymUnmanagedDocumentWriter doc);
    private void VisitModule(Module module);
    private void VisitParameter(Parameter parameter);
    private void VisitProperty(Property property);
    private void VisitReferencedType(TypeNode type);
    private void VisitReturn(Return Return);
    private void VisitSecurityAttributeList(SecurityAttributeList attrs, Node node);
    private void VisitStatement(Statement statement);
    private void VisitStruct(Struct Struct);
    private void VisitSwitchInstruction(SwitchInstruction switchInstruction);
    private void VisitTernaryExpression(TernaryExpression expression);
    private void VisitThis(This This);
    private void VisitThrow(Throw Throw);
    private void VisitUnaryExpression(UnaryExpression unaryExpression);
    private static void WriteArrayShape(BinaryWriter target, ArrayType arrayType);
    internal static void WriteCompressedInt(BinaryWriter target, int val);
    private TypeNode WriteCustomModifiers(BinaryWriter target, TypeNode type);
    private void WriteCustomAttributeLiteral(BinaryWriter writer, Literal literal, bool needsTag);
    private static bool AttributesContains(AttributeList al, TypeNode a);
    private void WriteMethodSignature(BinaryWriter target, Method method);
    private void WriteMethodSpecSignature(BinaryWriter target, Method method);
    private void WriteMethodSignature(BinaryWriter target, FunctionPointer fp);
    private void WritePropertySignature(BinaryWriter target, Property prop);
    private void WriteSerializedTypeName(BinaryWriter target, TypeNode type);
    private string GetSerializedTypeName(TypeNode type);
    private string GetSerializedTypeName(TypeNode type, Boolean& isAssemblyQualified);
    private void AppendAssemblyQualifierIfNecessary(StringBuilder sb, TypeNode type, Boolean& isAssemQualified);
    private void AppendSerializedTypeName(StringBuilder sb, TypeNode type, Boolean& isAssemQualified);
    private void WriteTypeDefOrRefEncoded(BinaryWriter target, TypeNode type);
    private void WriteTypeDefEncoded(BinaryWriter target, TypeNode type);
    private void WriteTypeRefEncoded(BinaryWriter target, TypeNode type);
    private void WriteTypeSpecEncoded(BinaryWriter target, TypeNode type);
    private void WriteTypeSignature(BinaryWriter target, TypeNode type);
    private void WriteTypeSignature(BinaryWriter target, TypeNode type, bool instantiateGenericTypes);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetModuleProps(string szName);
    private sealed virtual override void System.Compiler.IMetaDataEmit.Save(string szFile, UInt32 dwSaveFlags);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SaveToStream(Void* pIStream, UInt32 dwSaveFlags);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.GetSaveSize(UInt32 fSave);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineTypeDef(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineNestedType(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements, UInt32 tdEncloser);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetHandler(object pUnk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineMethod(UInt32 td, Char* zName, UInt32 dwMethodFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineTypeRefByName(UInt32 tkResolutionScope, Char* szName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineImportType(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineMemberRef(UInt32 tkImport, string szName, Byte* pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineImportMember(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetClassLayout(UInt32 td, UInt32 dwPackSize, COR_FIELD_OFFSET* rFieldOffsets, UInt32 ulClassSize);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DeleteClassLayout(UInt32 td);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetFieldMarshal(UInt32 tk, Byte* pvNativeType, UInt32 cbNativeType);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DeleteFieldMarshal(UInt32 tk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefinePermissionSet(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetRVA(UInt32 md, UInt32 ulRVA);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.GetTokenFromSig(Byte* pvSig, UInt32 cbSig);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineModuleRef(string szName);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetParent(UInt32 mr, UInt32 tk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.GetTokenFromTypeSpec(Byte* pvSig, UInt32 cbSig);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SaveToMemory(Void* pbData, UInt32 cbData);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineUserString(string szString, UInt32 cchString);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DeleteToken(UInt32 tkObj);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.SetPermissionSetProps(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    private sealed virtual override void System.Compiler.IMetaDataEmit.DeletePinvokeMap(UInt32 tk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetCustomAttributeValue(UInt32 pcv, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, Byte* pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    private sealed virtual override void System.Compiler.IMetaDataEmit.ApplyEditAndContinue(object pImport);
    private sealed virtual override UInt32 System.Compiler.IMetaDataEmit.TranslateSigWithScope(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport import, Byte* pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, Byte* pvTranslatedSig, UInt32 cbTranslatedSigMax);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    private sealed virtual override void System.Compiler.IMetaDataEmit.SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    private sealed virtual override void System.Compiler.IMetaDataEmit.Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    private sealed virtual override void System.Compiler.IMetaDataEmit.MergeEnd();
    private sealed virtual override void System.Compiler.IMetaDataImport.CloseEnum(UInt32 hEnum);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.CountEnum(UInt32 hEnum);
    private sealed virtual override void System.Compiler.IMetaDataImport.ResetEnum(UInt32 hEnum, UInt32 ulPos);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    private sealed virtual override Guid System.Compiler.IMetaDataImport.GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetModuleFromScope();
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    private static string GetProperFullTypeName(TypeNode type);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMethods(UInt32& phEnum, UInt32 cl, UInt32* rMethods, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumFields(UInt32& phEnum, UInt32 cl, UInt32* rFields, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumProperties(UInt32& phEnum, UInt32 td, UInt32* rProperties, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumEvents(UInt32& phEnum, UInt32 td, UInt32* rEvents, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetSigFromToken(UInt32 mdSig, Byte*& ppvSig);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetNameFromToken(UInt32 tk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    private sealed virtual override int System.Compiler.IMetaDataImport.GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.FindTypeRef(UInt32 tkResolutionScope, string szName);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetCustomAttributeByName(UInt32 tkObj, string szName, Void*& ppData);
    private sealed virtual override bool System.Compiler.IMetaDataImport.IsValidToken(UInt32 tk);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetNestedClassProps(UInt32 tdNestedClass);
    private sealed virtual override UInt32 System.Compiler.IMetaDataImport.GetNativeCallConvFromSig(Void* pvSig, UInt32 cbSig);
    private sealed virtual override int System.Compiler.IMetaDataImport.IsGlobal(UInt32 pd);
}
[DefaultMemberAttribute("Item")]
public interface System.Compiler.ISourceText {
    public int Length { get; }
    public char Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual string Substring(int startIndex, int length);
    public abstract virtual char get_Item(int position);
    public abstract virtual void MakeCollectible();
}
public interface System.Compiler.ISourceTextBuffer {
    public Byte* Buffer { get; }
    public abstract virtual Byte* get_Buffer();
}
public interface System.Compiler.ISymbolicTypeReference {
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface System.Compiler.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid& algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2DE91396-3844-3B1D-8E91-41C24FD672EA")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface System.Compiler.ISymUnmanagedWriter {
    public abstract virtual ISymUnmanagedDocumentWriter DefineDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void SetUserEntryPoint(UInt32 entryMethod);
    public abstract virtual void OpenMethod(UInt32 method);
    public abstract virtual void CloseMethod();
    public abstract virtual UInt32 OpenScope(UInt32 startOffset);
    public abstract virtual void CloseScope(UInt32 endOffset);
    public abstract virtual void SetScopeRange(UInt32 scopeID, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineLocalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineParameter(string name, UInt32 attributes, UInt32 sequence, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineField(UInt32 parent, string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineGlobalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 cData, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymUnmanagedDocumentWriter startDoc, UInt32 startLine, UInt32 startColumn, object endDoc, UInt32 endLine, UInt32 endColumn);
    public abstract virtual void Initialize(object emitter, string filename, object pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, UInt32 cData, UInt32& pcData, IntPtr data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, UInt32 spCount, UInt32[] offsets, UInt32[] lines, UInt32[] columns, UInt32[] endLines, UInt32[] endColumns);
    public abstract virtual void RemapToken(UInt32 oldToken, UInt32 newToken);
    public abstract virtual void Initialize2(object emitter, string tempfilename, object pIStream, bool fFullBuild, string finalfilename);
    public abstract virtual void DefineConstant(string name, object value, UInt32 cSig, IntPtr signature);
}
public interface System.Compiler.ITypeParameter {
    public Member DeclaringMember { get; public set; }
    public int ParameterListIndex { get; public set; }
    public TypeParameterFlags TypeParameterFlags { get; public set; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public bool IsUnmanaged { get; }
    public Identifier Name { get; }
    public Module DeclaringModule { get; }
    public TypeNode DeclaringType { get; }
    public SourceContext SourceContext { get; }
    public int UniqueKey { get; }
    public TypeFlags Flags { get; }
    public abstract virtual Member get_DeclaringMember();
    public abstract virtual void set_DeclaringMember(Member value);
    public abstract virtual int get_ParameterListIndex();
    public abstract virtual void set_ParameterListIndex(int value);
    public abstract virtual TypeParameterFlags get_TypeParameterFlags();
    public abstract virtual void set_TypeParameterFlags(TypeParameterFlags value);
    public abstract virtual bool get_IsCovariant();
    public abstract virtual bool get_IsContravariant();
    public abstract virtual bool get_IsUnmanaged();
    public abstract virtual Identifier get_Name();
    public abstract virtual Module get_DeclaringModule();
    public abstract virtual TypeNode get_DeclaringType();
    public abstract virtual SourceContext get_SourceContext();
    public abstract virtual int get_UniqueKey();
    public abstract virtual TypeFlags get_Flags();
}
public interface System.Compiler.IUniqueKey {
    public int UniqueId { get; }
    public abstract virtual int get_UniqueId();
}
public class System.Compiler.KeyFileNotFoundException : ArgumentException {
}
public class System.Compiler.LabeledStatement : Block {
    public Identifier Label;
    public Statement Statement;
}
public class System.Compiler.Literal : Expression {
    private object value;
    public bool TypeWasExplicitlySpecifiedInSource;
    public Expression SourceExpression;
    public static Literal DoubleOne;
    public static Literal False;
    public static Literal Int32MinusOne;
    public static Literal Int32Zero;
    public static Literal Int32One;
    public static Literal Int32Two;
    public static Literal Int32Sixteen;
    public static Literal Int64Zero;
    public static Literal Int64One;
    public static Literal Null;
    public static Literal SingleOne;
    public static Literal True;
    public object Value { get; }
    public Literal(object Value);
    public Literal(object value, TypeNode type);
    public Literal(object value, TypeNode type, SourceContext sourceContext);
    public object get_Value();
    public virtual string ToString();
    public static bool IsNullLiteral(Expression expr);
    public static void Initialize();
    public static void ClearStatics();
}
public class System.Compiler.Local : Variable {
    public Block DeclaringBlock;
    public bool InitOnly;
    public int Index;
    private bool pinned;
    public UInt32 Attributes;
    public bool HasNoPDBInfo;
    public bool Pinned { get; public set; }
    public Local(TypeNode type);
    public Local(Identifier name, TypeNode type);
    public Local(TypeNode type, SourceContext context);
    public Local(Identifier name, TypeNode type, SourceContext context);
    public Local(Identifier name, TypeNode type, Block declaringBlock);
    public bool get_Pinned();
    public void set_Pinned(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Compiler.LocalBinding : Local {
    public Local BoundLocal;
    private int System.Compiler.IUniqueKey.UniqueId { get; }
    public LocalBinding(Local boundLocal, SourceContext sctx);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private sealed virtual override int System.Compiler.IUniqueKey.get_UniqueId();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.LocalList : object {
    private Local[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Local Item { get; public set; }
    public LocalList(int capacity);
    public void Add(Local element);
    public int get_Count();
    public int get_Length();
    public Local get_Item(int index);
    public void set_Item(int index, Local value);
}
public class System.Compiler.LRExpression : Expression {
    public Expression Expression;
    public LocalList Temporaries;
    public ExpressionList SubexpressionsToEvaluateOnce;
    public LRExpression(Expression expression);
}
public class System.Compiler.MarshallingInformation : object {
    private string class;
    private string cookie;
    private int elementSize;
    private NativeType elementType;
    private NativeType nativeType;
    private int numberOfElements;
    private int paramIndex;
    private int size;
    public string Class { get; public set; }
    public string Cookie { get; public set; }
    public int ElementSize { get; public set; }
    public NativeType ElementType { get; public set; }
    public NativeType NativeType { get; public set; }
    public int NumberOfElements { get; public set; }
    public int ParamIndex { get; public set; }
    public int Size { get; public set; }
    public MarshallingInformation Clone();
    public string get_Class();
    public void set_Class(string value);
    public string get_Cookie();
    public void set_Cookie(string value);
    public int get_ElementSize();
    public void set_ElementSize(int value);
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
    public int get_NumberOfElements();
    public void set_NumberOfElements(int value);
    public int get_ParamIndex();
    public void set_ParamIndex(int value);
    public int get_Size();
    public void set_Size(int value);
}
public abstract class System.Compiler.Member : Node {
    public Namespace DeclaringNamespace;
    public bool IsUnsafe;
    public NodeList References;
    private TypeNode declaringType;
    private Identifier name;
    protected AttributeList attributes;
    private bool notObsolete;
    private ObsoleteAttribute obsoleteAttribute;
    protected Member hiddenMember;
    protected bool hidesBaseClassMemberSpecifiedExplicitly;
    protected bool hidesBaseClassMember;
    protected Member overriddenMember;
    protected bool overridesBaseClassMemberSpecifiedExplicitly;
    protected bool overridesBaseClassMember;
    public Node DocumentationNode;
    protected XmlNode documentation;
    protected Identifier documentationId;
    protected string helpText;
    private int filterPriority;
    private static Char[] tags;
    public TypeNode DeclaringType { get; public set; }
    public Identifier Name { get; public set; }
    public AttributeList Attributes { get; public set; }
    public Member HiddenMember { get; public set; }
    public bool HidesBaseClassMember { get; public set; }
    public Member OverriddenMember { get; public set; }
    public bool OverridesBaseClassMember { get; public set; }
    public string FullName { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public ObsoleteAttribute ObsoleteAttribute { get; public set; }
    public XmlNode Documentation { get; public set; }
    public Identifier DocumentationId { get; public set; }
    public string HelpText { get; public set; }
    public EditorBrowsableState FilterPriority { get; public set; }
    protected Member(NodeType nodeType);
    protected Member(TypeNode declaringType, AttributeList attributes, Identifier name, NodeType nodeType);
    private static Member();
    public virtual TypeNode get_DeclaringType();
    public virtual void set_DeclaringType(TypeNode value);
    public sealed virtual Identifier get_Name();
    public void set_Name(Identifier value);
    public virtual AttributeList get_Attributes();
    public virtual void set_Attributes(AttributeList value);
    public virtual Member get_HiddenMember();
    public virtual void set_HiddenMember(Member value);
    public bool get_HidesBaseClassMember();
    public void set_HidesBaseClassMember(bool value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual bool get_OverridesBaseClassMember();
    public virtual void set_OverridesBaseClassMember(bool value);
    public virtual AttributeNode GetAttribute(TypeNode attributeType);
    public virtual AttributeList GetFilteredAttributes(TypeNode attributeType);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsCompilerControlled();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVisibleOutsideAssembly();
    public ObsoleteAttribute get_ObsoleteAttribute();
    public void set_ObsoleteAttribute(ObsoleteAttribute value);
    public virtual XmlNode get_Documentation();
    public virtual void set_Documentation(XmlNode value);
    protected virtual Identifier GetDocumentationId();
    public Identifier get_DocumentationId();
    public void set_DocumentationId(Identifier value);
    public virtual string get_HelpText();
    public virtual void set_HelpText(string value);
    public virtual string GetParameterHelpText(string parameterName);
    private string GetHelpText(XmlNode node);
    public virtual EditorBrowsableState get_FilterPriority();
    public virtual void set_FilterPriority(EditorBrowsableState value);
    public virtual void WriteDocumentation(XmlTextWriter xwriter);
    private void AppendValue(StringBuilder sb, XmlNode node);
    public void EnsureMangledName();
}
public class System.Compiler.MemberBinding : Expression {
    private int alignment;
    private Member boundMember;
    public Expression BoundMemberExpression;
    private Expression targetObject;
    private bool volatile;
    public int Alignment { get; public set; }
    public Member BoundMember { get; public set; }
    public Expression TargetObject { get; public set; }
    public bool Volatile { get; public set; }
    public MemberBinding(Expression targetObject, Member boundMember);
    public MemberBinding(Expression targetObject, Member boundMember, Expression boundMemberExpression);
    public MemberBinding(Expression targetObject, Member boundMember, SourceContext sctx);
    public MemberBinding(Expression targetObject, Member boundMember, SourceContext sctx, Expression boundMemberExpression);
    public MemberBinding(Expression targetObject, Member boundMember, bool volatile, int alignment);
    public int get_Alignment();
    public void set_Alignment(int value);
    public Member get_BoundMember();
    public void set_BoundMember(Member value);
    public Expression get_TargetObject();
    public void set_TargetObject(Expression value);
    public bool get_Volatile();
    public void set_Volatile(bool value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.MemberBindingList : object {
    private MemberBinding[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public MemberBinding Item { get; public set; }
    public MemberBindingList(int capacity);
    public void Add(MemberBinding element);
    public int get_Count();
    public int get_Length();
    public MemberBinding get_Item(int index);
    public void set_Item(int index, MemberBinding value);
    public Enumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.MemberList : object {
    private Member[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Member Item { get; public set; }
    public MemberList(int capacity);
    public MemberList(Member[] elements);
    public void Add(Member element);
    public bool Contains(Member element);
    public void AddList(MemberList memberList);
    public void Remove(Member member);
    public void RemoveAt(int index);
    public MemberList Clone();
    public int get_Count();
    public int get_Length();
    public Member get_Item(int index);
    public void set_Item(int index, Member value);
    public Enumerator GetEnumerator();
    public Member[] ToArray();
}
public class System.Compiler.MemoryStream : object {
    public Byte[] Buffer;
    public int Length;
    public int position;
    public int Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] bytes);
    public int get_Position();
    public void set_Position(int value);
    private void Grow(Byte[] myBuffer, int n, int m);
    public void Seek(long offset, SeekOrigin loc);
    public Byte[] ToArray();
    public void Write(Byte[] buffer, int index, int count);
    public void WriteTo(MemoryStream stream);
    public void WriteTo(Stream stream);
}
internal class System.Compiler.Metadata.AssemblyRefRow : ValueType {
    internal int MajorVersion;
    internal int MinorVersion;
    internal int BuildNumber;
    internal int RevisionNumber;
    internal int Flags;
    internal int PublicKeyOrToken;
    internal int Name;
    internal int Culture;
    internal int HashValue;
    internal AssemblyReference AssemblyReference;
}
internal class System.Compiler.Metadata.AssemblyRow : ValueType {
    internal int HashAlgId;
    internal int MajorVersion;
    internal int MinorVersion;
    internal int BuildNumber;
    internal int RevisionNumber;
    internal int Flags;
    internal int PublicKey;
    internal int Name;
    internal int Culture;
}
internal class System.Compiler.Metadata.BodyParser : ILParser {
    private ExpressionStack operandStack;
    private TrivialHashtable blockMap;
    private int alignment;
    private bool isReadOnly;
    private bool isTailCall;
    private bool isVolatile;
    private TypeNode constraint;
    private OpCode opCode;
    private int ilOffset;
    private SourceContext lastSourceContext;
    internal BodyParser(Reader reader, Method method, int methodIndex, int RVA);
    protected virtual void ParseExceptionHandlerEntry(bool smallSection);
    private AssignmentStatement ParseArrayElementAssignment(OpCode opCode);
    private Indexer ParseArrayElementLoad(OpCode opCode, TypeNode elementType);
    private UnaryExpression ParseArrayElementLoadAddress();
    private static UnaryExpression SetType(UnaryExpression uex);
    private BinaryExpression ParseBinaryComparison(NodeType oper);
    private BinaryExpression ParseBinaryOperation(NodeType oper);
    private UnaryExpression ParseUnaryOperation(NodeType oper);
    private Branch ParseBranch(NodeType operatorType, int operandCount, bool shortOffset, bool unordered);
    private Branch ParseBranch(NodeType operatorType, int operandCount, bool shortOffset, bool unordered, bool leavesExceptionBlock);
    private MethodCall ParseCall(NodeType typeOfCall, Boolean& isStatement);
    private static bool TypeIsVoid(TypeNode t);
    private MethodCall ParseCalli(Boolean& isStatement);
    private static Expression ParseTypeCheck(Expression operand, TypeNode type, NodeType typeOfCheck);
    private Construct ParseConstruct();
    private AssignmentStatement ParseCopyObject();
    private UnaryExpression ParseLoadRuntimeMetadataToken();
    private AssignmentStatement ParseInitObject();
    private ConstructArray ParseNewArray();
    internal StatementList ParseStatements();
    private bool ParseStatement(Block block);
    private AssignmentStatement ParseStoreField();
    private AssignmentStatement ParseStoreIndirect(TypeNode type);
    private SwitchInstruction ParseSwitchInstruction();
    private TernaryExpression ParseTernaryOperation(NodeType oper);
    private void CreateBlocksForBranchTargets();
    private void ProcessOneILInstruction();
    private void SkipBranch(bool shortOffset);
    private void SkipSwitch();
    private Expression PopOperand();
}
internal class System.Compiler.Metadata.ClassLayoutRow : ValueType {
    internal int PackingSize;
    internal int ClassSize;
    internal int Parent;
}
internal class System.Compiler.Metadata.CLIHeader : object {
    internal int cb;
    internal ushort majorRuntimeVersion;
    internal ushort minorRuntimeVersion;
    internal DirectoryEntry metaData;
    internal int flags;
    internal int entryPointToken;
    internal DirectoryEntry resources;
    internal DirectoryEntry strongNameSignature;
    internal DirectoryEntry codeManagerTable;
    internal DirectoryEntry vtableFixups;
    internal DirectoryEntry exportAddressTableJumps;
}
internal class System.Compiler.Metadata.ConstantRow : ValueType {
    internal int Type;
    internal int Parent;
    internal int Value;
}
internal enum System.Compiler.Metadata.CorOpenFlags : Enum {
    public UInt32 value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofCacheImage;
    public static CorOpenFlags ofNoTypeLib;
}
[GuidAttribute("AA544D41-28CB-11d3-BD22-0000F80849BD")]
internal class System.Compiler.Metadata.CorSymBinder : object {
}
[GuidAttribute("0A29FF9E-7F9C-4437-8B11-F424491E3931")]
internal class System.Compiler.Metadata.CorSymBinder2 : object {
}
internal class System.Compiler.Metadata.CustomAttributeRow : ValueType {
    internal int Parent;
    internal int Constructor;
    internal int Value;
}
internal class System.Compiler.Metadata.DeclSecurityRow : ValueType {
    internal int Action;
    internal int Parent;
    internal int PermissionSet;
}
internal class System.Compiler.Metadata.DirectoryEntry : ValueType {
    internal int virtualAddress;
    internal int size;
}
internal enum System.Compiler.Metadata.ElementType : Enum {
    public int value__;
    public static ElementType End;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType Int8;
    public static ElementType UInt8;
    public static ElementType Int16;
    public static ElementType UInt16;
    public static ElementType Int32;
    public static ElementType UInt32;
    public static ElementType Int64;
    public static ElementType UInt64;
    public static ElementType Single;
    public static ElementType Double;
    public static ElementType String;
    public static ElementType Pointer;
    public static ElementType Reference;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType TypeParameter;
    public static ElementType Array;
    public static ElementType GenericTypeInstance;
    public static ElementType DynamicallyTypedReference;
    public static ElementType IntPtr;
    public static ElementType UIntPtr;
    public static ElementType FunctionPointer;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MethodParameter;
    public static ElementType RequiredModifier;
    public static ElementType OptionalModifier;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType BoxedEnum;
    public static ElementType Enum;
}
internal class System.Compiler.Metadata.EventMapRow : ValueType {
    internal int Parent;
    internal int EventList;
}
internal class System.Compiler.Metadata.EventPtrRow : ValueType {
    internal int Event;
}
internal class System.Compiler.Metadata.EventRow : ValueType {
    internal int Flags;
    internal int Name;
    internal int EventType;
}
internal class System.Compiler.Metadata.ExportedTypeRow : ValueType {
    internal int Flags;
    internal int TypeDefId;
    internal int TypeName;
    internal int TypeNamespace;
    internal int Implementation;
}
internal class System.Compiler.Metadata.ExpressionStack : object {
    internal Expression[] elements;
    internal int top;
    private void Grow();
    internal Expression Pop();
    internal void Push(Expression e);
}
internal class System.Compiler.Metadata.FieldLayoutRow : ValueType {
    internal int Offset;
    internal int Field;
}
internal class System.Compiler.Metadata.FieldMarshalRow : ValueType {
    internal int Parent;
    internal int NativeType;
}
internal class System.Compiler.Metadata.FieldPtrRow : ValueType {
    internal int Field;
}
internal class System.Compiler.Metadata.FieldRow : ValueType {
    internal int Flags;
    internal int Name;
    internal int Signature;
    internal Field Field;
}
internal class System.Compiler.Metadata.FieldRvaRow : ValueType {
    internal int RVA;
    internal int Field;
    internal PESection TargetSection;
}
internal class System.Compiler.Metadata.FileRow : ValueType {
    internal int Flags;
    internal int Name;
    internal int HashValue;
}
internal class System.Compiler.Metadata.GenericParamConstraintRow : ValueType {
    internal int Param;
    internal int Constraint;
}
internal class System.Compiler.Metadata.GenericParamRow : ValueType {
    internal int Number;
    internal int Flags;
    internal int Owner;
    internal int Name;
    internal Member GenericParameter;
}
internal abstract class System.Compiler.Metadata.ILParser : object {
    internal int counter;
    protected Reader reader;
    protected MemoryCursor bodyReader;
    internal int size;
    protected Method method;
    protected int methodIndex;
    protected int RVA;
    protected LocalList locals;
    internal ILParser(Reader reader, Method method, int methodIndex, int RVA);
    protected Expression Parameters(int i);
    protected void ParseHeader();
    protected abstract virtual void ParseExceptionHandlerEntry(bool smallSection);
    protected byte GetByte();
    protected sbyte GetSByte();
    protected short GetInt16();
    protected int GetInt32();
    protected long GetInt64();
    protected float GetSingle();
    protected double GetDouble();
    protected Member GetMemberFromToken(object memberInfo);
    protected Member GetMemberFromToken(TypeNodeList& varArgTypes);
    protected string GetStringFromToken();
    protected OpCode GetOpCode();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("809c652e-7396-11d2-9771-00A0C9B4D50C")]
internal interface System.Compiler.Metadata.IMetaDataDispenser {
    public abstract virtual void DefineScope(Guid& clsid, UInt32 createFlags, Guid& iid, Object& retval);
    public abstract virtual int OpenScope(string scope, UInt32 openFlags, Guid& iid, Object& import);
    public abstract virtual void OpenScopeOnMemory(IntPtr data, UInt32 dataSize, UInt32 openFlags, Guid& iid, Object& retval);
}
internal class System.Compiler.Metadata.ImplMapRow : ValueType {
    internal int MappingFlags;
    internal int MemberForwarded;
    internal int ImportName;
    internal int ImportScope;
}
internal class System.Compiler.Metadata.InstructionParser : ILParser {
    private TrivialHashtable ehMap;
    private SourceContext sourceContext;
    internal InstructionParser(Reader reader, Method method, int methodIndex, int RVA);
    protected virtual void ParseExceptionHandlerEntry(bool smallSection);
    private Instruction AddInstruction(OpCode opCode, int offset);
    private Instruction AddInstruction(OpCode opCode, int offset, object value);
    private Int32List ParseSwitchInstruction();
    internal InstructionList ParseInstructions();
    internal Instruction ParseInstruction();
}
internal class System.Compiler.Metadata.InterfaceImplRow : ValueType {
    internal int Class;
    internal int Interface;
}
public class System.Compiler.Metadata.InvalidMetadataException : Exception {
    public InvalidMetadataException(string message);
    public InvalidMetadataException(string message, Exception innerException);
    private InvalidMetadataException(SerializationInfo info, StreamingContext context);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("AA544D42-28CB-11d3-BD22-0000F80849BD")]
internal interface System.Compiler.Metadata.ISymUnmanagedBinder {
    public abstract virtual int GetReaderForFile(object importer, string filename, string searchPath, ISymUnmanagedReader& reader);
    public abstract virtual ISymUnmanagedReader GetReaderForStream(object importer, object stream);
}
[GuidAttribute("ACCEE350-89AF-4ccb-8B40-1C2C4C6F9434")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("False")]
internal interface System.Compiler.Metadata.ISymUnmanagedBinder2 {
    public abstract virtual void GetReaderForFile(IntPtr importer, string filename, string SearchPath, ISymUnmanagedReader& retVal);
    public abstract virtual void GetReaderFromStream(IntPtr importer, IntPtr stream, ISymUnmanagedReader& retVal);
    public abstract virtual int GetReaderForFile2(object importer, string fileName, string searchPath, int searchPolicy, ISymUnmanagedReader& pRetVal);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08")]
internal interface System.Compiler.Metadata.ISymUnmanagedDocument {
    public abstract virtual void GetURL(UInt32 size, UInt32& length, Char[] url);
    public abstract virtual void GetDocumentType(Guid& retval);
    public abstract virtual void GetLanguage(Guid& retval);
    public abstract virtual void GetLanguageVendor(Guid& retval);
    public abstract virtual void GetCheckSumAlgorithmId(Guid& retval);
    public abstract virtual void GetCheckSum(UInt32 size, UInt32& length, Byte[] data);
    public abstract virtual UInt32 FindClosestLine(UInt32 line);
    public abstract virtual bool HasEmbeddedSource();
    public abstract virtual UInt32 GetSourceLength();
    public abstract virtual void GetSourceRange(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, UInt32 size, UInt32& length, Byte[] source);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B62B923C-B500-3158-A543-24F307A8B7E1")]
internal interface System.Compiler.Metadata.ISymUnmanagedMethod {
    public abstract virtual UInt32 GetToken();
    public abstract virtual UInt32 GetSequencePointCount();
    public abstract virtual ISymUnmanagedScope GetRootScope();
    public abstract virtual ISymUnmanagedScope GetScopeFromOffset(UInt32 offset);
    public abstract virtual UInt32 Getoffset(ISymUnmanagedDocument document, UInt32 line, UInt32 column);
    public abstract virtual void GetRanges(ISymUnmanagedDocument document, UInt32 line, UInt32 column, UInt32 size, UInt32& length, UInt32[] ranges);
    public abstract virtual void GetParameters(UInt32 size, UInt32& length, ISymUnmanagedVariable[] parms);
    public abstract virtual IntPtr GetNamespace();
    public abstract virtual bool GetSourceStartEnd(ISymUnmanagedDocument[] docs, UInt32[] lines, UInt32[] columns);
    public abstract virtual void GetSequencePoints(UInt32 size, UInt32& length, UInt32[] offsets, IntPtr[] documents, UInt32[] lines, UInt32[] columns, UInt32[] endLines, UInt32[] endColumns);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5")]
internal interface System.Compiler.Metadata.ISymUnmanagedReader {
    public abstract virtual ISymUnmanagedDocument GetDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void GetDocuments(UInt32 size, UInt32& length, ISymUnmanagedDocument[] docs);
    public abstract virtual UInt32 GetUserEntryPoint();
    public abstract virtual int GetMethod(UInt32 token, ISymUnmanagedMethod& method);
    public abstract virtual ISymUnmanagedMethod GetMethodByVersion(UInt32 token, int version);
    public abstract virtual void GetVariables(UInt32 parent, UInt32 size, UInt32& length, ISymUnmanagedVariable[] vars);
    public abstract virtual void GetGlobalVariables(UInt32 size, UInt32& length, ISymUnmanagedVariable[] vars);
    public abstract virtual ISymUnmanagedMethod GetMethodFromDocumentPosition(ISymUnmanagedDocument document, UInt32 line, UInt32 column);
    public abstract virtual void GetSymAttribute(UInt32 parent, string name, ulong size, UInt32& length, Byte[] buffer);
    public abstract virtual void GetNamespaces(UInt32 size, UInt32& length, IntPtr[] namespaces);
    public abstract virtual void Initialize(object importer, string filename, string searchPath, object stream);
    public abstract virtual void UpdateSymbolStore(string filename, object stream);
    public abstract virtual void ReplaceSymbolStore(string filename, object stream);
    public abstract virtual void GetSymbolStoreFileName(UInt32 size, UInt32& length, Char[] name);
    public abstract virtual void GetMethodsFromDocumentPosition(ISymUnmanagedDocument document, UInt32 line, UInt32 column, UInt32 size, UInt32& length, ISymUnmanagedMethod[] retval);
    public abstract virtual void GetDocumentVersion(ISymUnmanagedDocument doc, Int32& version, Boolean& isLatest);
    public abstract virtual void GetMethodVersion(ISymUnmanagedMethod method, Int32& version);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("68005D0F-B8E0-3B01-84D5-A11A94154942")]
internal interface System.Compiler.Metadata.ISymUnmanagedScope {
    public abstract virtual ISymUnmanagedMethod GetMethod();
    public abstract virtual ISymUnmanagedScope GetParent();
    public abstract virtual void GetChildren(UInt32 size, UInt32& length, IntPtr[] children);
    public abstract virtual UInt32 GetStartOffset();
    public abstract virtual UInt32 GetEndOffset();
    public abstract virtual UInt32 GetLocalCount();
    public abstract virtual void GetLocals(UInt32 size, UInt32& length, IntPtr[] locals);
    public abstract virtual void GetNamespaces(UInt32 size, UInt32& length, IntPtr[] namespaces);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB")]
internal interface System.Compiler.Metadata.ISymUnmanagedVariable {
    public abstract virtual void GetName(UInt32 size, UInt32& length, Char[] name);
    public abstract virtual UInt32 GetAttributes();
    public abstract virtual void GetSignature(UInt32 size, UInt32& length, Byte[] name);
    public abstract virtual UInt32 GetAddressKind();
    public abstract virtual UInt32 GetAddressField1();
    public abstract virtual UInt32 GetAddressField2();
    public abstract virtual UInt32 GetAddressField3();
    public abstract virtual UInt32 GetStartOffset();
    public abstract virtual UInt32 GetEndOffset();
}
internal class System.Compiler.Metadata.LocalInfo : ValueType {
    public string Name;
    public UInt32 Attributes;
    public LocalInfo(string name, UInt32 attributes);
}
internal class System.Compiler.Metadata.ManifestResourceRow : ValueType {
    internal int Offset;
    internal int Flags;
    internal int Name;
    internal int Implementation;
}
internal class System.Compiler.Metadata.MemberRefRow : ValueType {
    internal int Class;
    internal int Name;
    internal int Signature;
    internal Member Member;
    internal TypeNodeList VarargTypes;
}
internal class System.Compiler.Metadata.MemoryCursor : object {
    private Byte* buffer;
    private Byte* pb;
    internal int Length;
    internal int Position { get; internal set; }
    internal MemoryCursor(MemoryMappedFile memoryMap);
    internal MemoryCursor(Byte* buffer, int length, int position);
    internal MemoryCursor(Byte* buffer, int length);
    internal MemoryCursor(MemoryCursor c);
    internal Byte* GetBuffer();
    internal int get_Position();
    internal void set_Position(int value);
    internal void Align(int size);
    internal short Int16(int i);
    internal int Int32(int i);
    internal byte Byte(int i);
    internal ushort UInt16(int i);
    internal void SkipInt16(int c);
    internal void SkipInt32(int c);
    internal void SkipByte(int c);
    internal void SkipUInt16(int c);
    internal char ReadChar();
    internal sbyte ReadSByte();
    internal short ReadInt16();
    internal int ReadInt32();
    internal long ReadInt64();
    internal byte ReadByte();
    internal ushort ReadUInt16();
    internal UInt32 ReadUInt32();
    internal ulong ReadUInt64();
    internal bool ReadBoolean();
    internal float ReadSingle();
    internal double ReadDouble();
    internal int ReadReference(int refSize);
    internal int ReadCompressedInt();
    internal Byte[] ReadBytes(int c);
    internal Identifier ReadIdentifierFromSerString();
    internal string ReadUTF8(int bytesToRead);
    internal string ReadUTF8();
    internal string ReadUTF16(int charsToRead);
    internal string ReadUTF16();
    internal string ReadASCII(int bytesToRead);
    internal string ReadASCII();
}
public class System.Compiler.Metadata.MemoryMappedFile : object {
    private Byte* buffer;
    private int length;
    public Byte* Buffer { get; }
    public int Length { get; }
    private char System.Compiler.ISourceText.Item { get; }
    public MemoryMappedFile(string fileName);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual Byte* get_Buffer();
    public sealed virtual int get_Length();
    private sealed virtual override string System.Compiler.ISourceText.Substring(int start, int length);
    private sealed virtual override char System.Compiler.ISourceText.get_Item(int index);
    private void OpenMap(string filename);
    private void CloseMap();
    private sealed virtual override void System.Compiler.ISourceText.MakeCollectible();
    private static IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpAttributes, PageAccess flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, string lpName);
    private static Void* MapViewOfFile(IntPtr hFileMappingObject, FileMapAccess dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    private static bool UnmapViewOfFile(Void* lpBaseAddress);
    private static bool CloseHandle(IntPtr hObject);
}
internal class System.Compiler.Metadata.MetadataHeader : object {
    internal int signature;
    internal ushort majorVersion;
    internal ushort minorVersion;
    internal int reserved;
    internal string versionString;
    internal int flags;
    internal StreamHeader[] streamHeaders;
}
internal class System.Compiler.Metadata.MetadataReader : object {
    private MemoryMappedFile memmap;
    private MemoryCursor cursor;
    internal int entryPointToken;
    internal int fileAlignment;
    internal ModuleKindFlags moduleKind;
    internal PEKindFlags peKind;
    internal bool TrackDebugData;
    private int mdOffset;
    private int resourcesOffset;
    private int win32ResourcesOffset;
    private SectionHeader[] sectionHeaders;
    private StreamHeader identifierStringHeap;
    private StreamHeader generalStringHeap;
    private StreamHeader blobHeap;
    private StreamHeader guidHeap;
    private StreamHeader tables;
    internal TablesHeader tablesHeader;
    internal string targetRuntimeVersion;
    internal ushort dllCharacteristics;
    internal int linkerMajorVersion;
    internal int linkerMinorVersion;
    internal int metadataFormatMajorVersion;
    internal int metadataFormatMinorVersion;
    private int blobRefSize;
    private int constantParentRefSize;
    private int customAttributeParentRefSize;
    private int customAttributeConstructorRefSize;
    private int declSecurityParentRefSize;
    private int fieldMarshalParentRefSize;
    private int guidRefSize;
    private int hasSemanticRefSize;
    private int implementationRefSize;
    private int methodDefOrRefSize;
    private int memberRefParentSize;
    private int memberForwardedRefSize;
    private int typeDefOrRefOrSpecSize;
    private int typeDefOrMethodDefSize;
    private int resolutionScopeRefSize;
    private int stringRefSize;
    private Int32[] tableSize;
    private Int32[] tableRefSize;
    private Int32[] tableOffset;
    internal Byte[] HashValue;
    private AssemblyRow[] assemblyTable;
    private AssemblyRefRow[] assemblyRefTable;
    private ClassLayoutRow[] classLayoutTable;
    private ConstantRow[] constantTable;
    private CustomAttributeRow[] customAttributeTable;
    private DeclSecurityRow[] declSecurityTable;
    private EventMapRow[] eventMapTable;
    private EventPtrRow[] eventPtrTable;
    private EventRow[] eventTable;
    private ExportedTypeRow[] exportedTypeTable;
    private FieldRow[] fieldTable;
    private FieldLayoutRow[] fieldLayoutTable;
    private FieldMarshalRow[] fieldMarshalTable;
    private FieldPtrRow[] fieldPtrTable;
    private FieldRvaRow[] fieldRvaTable;
    private FileRow[] fileTable;
    private GenericParamRow[] genericParamTable;
    private GenericParamConstraintRow[] genericParamConstraintTable;
    private ImplMapRow[] implMapTable;
    private InterfaceImplRow[] interfaceImplTable;
    private ManifestResourceRow[] manifestResourceTable;
    private MemberRefRow[] memberRefTable;
    private MethodRow[] methodTable;
    private MethodPtrRow[] methodPtrTable;
    private MethodImplRow[] methodImplTable;
    private MethodSemanticsRow[] methodSemanticsTable;
    private MethodSpecRow[] methodSpecTable;
    private ModuleRow[] moduleTable;
    private ModuleRefRow[] moduleRefTable;
    private NestedClassRow[] nestedClassTable;
    private ParamRow[] paramTable;
    private ParamPtrRow[] paramPtrTable;
    private PropertyRow[] propertyTable;
    private PropertyMapRow[] propertyMapTable;
    private PropertyPtrRow[] propertyPtrTable;
    private StandAloneSigRow[] standAloneSigTable;
    private TypeDefRow[] typeDefTable;
    private TypeRefRow[] typeRefTable;
    private TypeSpecRow[] typeSpecTable;
    internal Byte[] emptyBlob;
    internal AssemblyRow[] AssemblyTable { get; }
    internal AssemblyRefRow[] AssemblyRefTable { get; }
    internal ClassLayoutRow[] ClassLayoutTable { get; }
    internal ConstantRow[] ConstantTable { get; }
    internal CustomAttributeRow[] CustomAttributeTable { get; }
    internal DeclSecurityRow[] DeclSecurityTable { get; }
    internal EventMapRow[] EventMapTable { get; }
    internal EventPtrRow[] EventPtrTable { get; }
    internal EventRow[] EventTable { get; }
    internal ExportedTypeRow[] ExportedTypeTable { get; }
    internal FieldRow[] FieldTable { get; }
    internal FieldLayoutRow[] FieldLayoutTable { get; }
    internal FieldMarshalRow[] FieldMarshalTable { get; }
    internal FieldPtrRow[] FieldPtrTable { get; }
    internal FieldRvaRow[] FieldRvaTable { get; }
    internal FileRow[] FileTable { get; }
    internal GenericParamRow[] GenericParamTable { get; }
    internal GenericParamConstraintRow[] GenericParamConstraintTable { get; }
    internal ImplMapRow[] ImplMapTable { get; }
    internal InterfaceImplRow[] InterfaceImplTable { get; }
    internal ManifestResourceRow[] ManifestResourceTable { get; }
    internal MemberRefRow[] MemberRefTable { get; }
    internal MethodRow[] MethodTable { get; }
    internal MethodImplRow[] MethodImplTable { get; }
    internal MethodPtrRow[] MethodPtrTable { get; }
    internal MethodSemanticsRow[] MethodSemanticsTable { get; }
    internal MethodSpecRow[] MethodSpecTable { get; }
    internal ModuleRow[] ModuleTable { get; }
    internal ModuleRefRow[] ModuleRefTable { get; }
    internal NestedClassRow[] NestedClassTable { get; }
    internal ParamRow[] ParamTable { get; }
    internal ParamPtrRow[] ParamPtrTable { get; }
    internal PropertyRow[] PropertyTable { get; }
    internal PropertyMapRow[] PropertyMapTable { get; }
    internal PropertyPtrRow[] PropertyPtrTable { get; }
    internal StandAloneSigRow[] StandAloneSigTable { get; }
    internal TypeDefRow[] TypeDefTable { get; }
    internal TypeRefRow[] TypeRefTable { get; }
    internal TypeSpecRow[] TypeSpecTable { get; }
    internal Byte[] EmptyBlob { get; }
    internal MetadataReader(string path);
    internal MetadataReader(Byte* buffer, int length);
    public sealed virtual void Dispose();
    internal AssemblyRow[] get_AssemblyTable();
    internal AssemblyRefRow[] get_AssemblyRefTable();
    internal ClassLayoutRow[] get_ClassLayoutTable();
    internal ConstantRow[] get_ConstantTable();
    internal CustomAttributeRow[] get_CustomAttributeTable();
    internal DeclSecurityRow[] get_DeclSecurityTable();
    internal EventMapRow[] get_EventMapTable();
    internal EventPtrRow[] get_EventPtrTable();
    internal EventRow[] get_EventTable();
    internal ExportedTypeRow[] get_ExportedTypeTable();
    internal FieldRow[] get_FieldTable();
    internal FieldLayoutRow[] get_FieldLayoutTable();
    internal FieldMarshalRow[] get_FieldMarshalTable();
    internal FieldPtrRow[] get_FieldPtrTable();
    internal FieldRvaRow[] get_FieldRvaTable();
    internal FileRow[] get_FileTable();
    internal GenericParamRow[] get_GenericParamTable();
    internal GenericParamConstraintRow[] get_GenericParamConstraintTable();
    internal ImplMapRow[] get_ImplMapTable();
    internal InterfaceImplRow[] get_InterfaceImplTable();
    internal ManifestResourceRow[] get_ManifestResourceTable();
    internal MemberRefRow[] get_MemberRefTable();
    internal MethodRow[] get_MethodTable();
    internal MethodImplRow[] get_MethodImplTable();
    internal MethodPtrRow[] get_MethodPtrTable();
    internal MethodSemanticsRow[] get_MethodSemanticsTable();
    internal MethodSpecRow[] get_MethodSpecTable();
    internal ModuleRow[] get_ModuleTable();
    internal ModuleRefRow[] get_ModuleRefTable();
    internal NestedClassRow[] get_NestedClassTable();
    internal ParamRow[] get_ParamTable();
    internal ParamPtrRow[] get_ParamPtrTable();
    internal PropertyRow[] get_PropertyTable();
    internal PropertyMapRow[] get_PropertyMapTable();
    internal PropertyPtrRow[] get_PropertyPtrTable();
    internal StandAloneSigRow[] get_StandAloneSigTable();
    internal TypeDefRow[] get_TypeDefTable();
    internal TypeRefRow[] get_TypeRefTable();
    internal TypeSpecRow[] get_TypeSpecTable();
    internal void SetCurrentPosition(int pos);
    internal void AlignTo32BitBoundary();
    internal void Skip(int bytes);
    internal Byte[] get_EmptyBlob();
    internal Byte[] GetBlob(int blobIndex);
    internal MemoryCursor GetBlobCursor(int blobIndex);
    internal MemoryCursor GetBlobCursor(int blobIndex, Int32& blobLength);
    internal Guid GetGuid(int guidIndex);
    internal Identifier GetIdentifier(int stringHeapIndex);
    internal byte GetMethodBodyHeaderByte(int RVA);
    internal MemoryCursor GetNewCursor();
    internal MemoryCursor GetNewCursor(int RVA, PESection& targetSection);
    internal byte GetByte();
    internal int GetCurrentPosition();
    internal int GetInt32();
    internal short GetInt16();
    internal ushort GetUInt16();
    internal int GetSignatureLength(int blobIndex);
    internal string GetString(int stringHeapIndex);
    internal string GetUserString(int stringHeapIndex);
    internal string GetBlobString(int blobIndex);
    internal object GetValueFromBlob(int type, int blobIndex);
    internal Byte[] GetResourceData(int resourceOffset);
    private int PositionOfBlob(int blobIndex);
    private void ReadHeader();
    internal Win32ResourceList ReadWin32Resources();
    private static int ReadWin32ResourceDirectoryHeader(MemoryCursor c);
    private Win32Resource ReadWin32ResourceDataEntry(MemoryCursor c, int position, string TypeName, int TypeID, string Name, int ID, int LanguageID);
    private void ReadAssemblyTable();
    private void ReadAssemblyRefTable();
    private void ReadClassLayoutTable();
    private void ReadConstantTable();
    private void ReadCustomAttributeTable();
    private void ReadDeclSecurityTable();
    private void ReadEventMapTable();
    private void ReadEventPtrTable();
    private void ReadEventTable();
    private void ReadExportedTypeTable();
    private void ReadFieldTable();
    private void ReadFieldLayoutTable();
    private void ReadFieldMarshalTable();
    private void ReadFieldPtrTable();
    private void ReadFieldRvaTable();
    private void ReadFileTable();
    private void ReadGenericParamTable();
    private void ReadGenericParamConstraintTable();
    private void ReadImplMapTable();
    private void ReadInterfaceImplTable();
    private void ReadManifestResourceTable();
    private void ReadMemberRefTable();
    private void ReadMethodTable();
    private void ReadMethodImplTable();
    private void ReadMethodPtrTable();
    private void ReadMethodSemanticsTable();
    private void ReadMethodSpecTable();
    private void ReadModuleTable();
    private void ReadModuleRefTable();
    private void ReadNestedClassTable();
    private void ReadParamTable();
    private void ReadParamPtrTable();
    private void ReadPropertyTable();
    private void ReadPropertyMapTable();
    private void ReadPropertyPtrTable();
    private void ReadStandAloneSigTable();
    private void ReadTypeDefTable();
    private void ReadTypeRefTable();
    private void ReadTypeSpecTable();
    internal int GetOffsetToEndOfSection(int virtualAddress);
    internal bool NoOffsetFor(int virtualAddress);
    private int RvaToOffset(int virtualAddress);
    private int RvaToOffset(int virtualAddress, PESection& targetSection);
    private static CLIHeader ReadCLIHeader(MemoryCursor c);
    private static DirectoryEntry ReadDirectoryEntry(MemoryCursor c);
    internal static void ReadDOSHeader(MemoryCursor c);
    private static MetadataHeader ReadMetadataHeader(MemoryCursor c);
    internal static NTHeader ReadNTHeader(MemoryCursor c);
    internal static SectionHeader ReadSectionHeader(MemoryCursor c);
    private static StreamHeader ReadStreamHeader(MemoryCursor c);
    private static TablesHeader ReadTablesHeader(MemoryCursor c);
}
internal class System.Compiler.Metadata.MetadataWriter : object {
    internal MemoryStream StringHeap;
    internal MemoryStream BlobHeap;
    internal MemoryStream UserstringHeap;
    internal MemoryStream ResourceDataHeap;
    internal MemoryStream SdataHeap;
    internal MemoryStream TlsHeap;
    internal Guid[] GuidHeap;
    internal MemoryStream MethodBodiesHeap;
    internal Win32ResourceList Win32Resources;
    internal AssemblyRow[] assemblyTable;
    internal AssemblyRefRow[] assemblyRefTable;
    internal ClassLayoutRow[] classLayoutTable;
    internal ConstantRow[] constantTable;
    internal CustomAttributeRow[] customAttributeTable;
    internal DeclSecurityRow[] declSecurityTable;
    internal EventMapRow[] eventMapTable;
    internal EventRow[] eventTable;
    internal ExportedTypeRow[] exportedTypeTable;
    internal FieldRow[] fieldTable;
    internal FieldLayoutRow[] fieldLayoutTable;
    internal FieldMarshalRow[] fieldMarshalTable;
    internal FieldRvaRow[] fieldRvaTable;
    internal FileRow[] fileTable;
    internal GenericParamRow[] genericParamTable;
    internal GenericParamConstraintRow[] genericParamConstraintTable;
    internal ImplMapRow[] implMapTable;
    internal InterfaceImplRow[] interfaceImplTable;
    internal ManifestResourceRow[] manifestResourceTable;
    internal MemberRefRow[] memberRefTable;
    internal MethodRow[] methodTable;
    internal MethodImplRow[] methodImplTable;
    internal MethodSemanticsRow[] methodSemanticsTable;
    internal MethodSpecRow[] methodSpecTable;
    internal ModuleRow[] moduleTable;
    internal ModuleRefRow[] moduleRefTable;
    internal NestedClassRow[] nestedClassTable;
    internal ParamRow[] paramTable;
    internal PropertyRow[] propertyTable;
    internal PropertyMapRow[] propertyMapTable;
    internal StandAloneSigRow[] standAloneSigTable;
    internal TypeDefRow[] typeDefTable;
    internal TypeRefRow[] typeRefTable;
    internal TypeSpecRow[] typeSpecTable;
    internal int entryPointToken;
    internal int fileAlignment;
    internal ModuleKindFlags moduleKind;
    internal ushort dllCharacteristics;
    internal PEKindFlags peKind;
    internal bool TrackDebugData;
    internal bool UseGenerics;
    internal Byte[] PublicKey;
    internal int SignatureKeyLength;
    private int blobRefSize;
    private int constantParentRefSize;
    private int customAttributeParentRefSize;
    private int customAttributeConstructorRefSize;
    private int declSecurityParentRefSize;
    private int fieldMarshalParentRefSize;
    private int guidRefSize;
    private int hasSemanticRefSize;
    private int implementationRefSize;
    private int methodDefOrRefSize;
    private int memberRefParentSize;
    private int memberForwardedRefSize;
    private int typeDefOrMethodDefSize;
    private int typeDefOrRefOrSpecSize;
    private int resolutionScopeRefSize;
    private int stringRefSize;
    private ISymUnmanagedWriter symWriter;
    private Int32[] tableRefSize;
    private Int32[] tableSize;
    private long validMask;
    private NTHeader ntHeader;
    private CLIHeader cliHeader;
    private SectionHeader[] sectionHeaders;
    private static Byte[] dosHeader;
    private static DateTime NineteenSeventy;
    internal MetadataWriter(ISymUnmanagedWriter symWriter);
    private static MetadataWriter();
    private void SerializeMetadata(BinaryWriter writer, int virtualAddressBase, Fixup sdataFixup, Fixup tlsFixup);
    private void WriteReferenceToPDBFile(BinaryWriter writer, int virtualAddressBase, int fileBase);
    private void SerializeTables(BinaryWriter writer, int mbRVAOffset, Fixup sdataFixup, Fixup tlsFixup);
    private void SerializeAssemblyTable(BinaryWriter writer);
    private void SerializeAssemblyRefTable(BinaryWriter writer);
    private void SerializeClassLayoutTable(BinaryWriter writer);
    private void SerializeConstantTable(BinaryWriter writer);
    private void SerializeCustomAttributeTable(BinaryWriter writer);
    private void SerializeDeclSecurityTable(BinaryWriter writer);
    private void SerializeEventMapTable(BinaryWriter writer);
    private void SerializeEventTable(BinaryWriter writer);
    private void SerializeExportedTypeTable(BinaryWriter writer);
    private void SerializeFieldTable(BinaryWriter writer);
    private void SerializeFieldLayoutTable(BinaryWriter writer);
    private void SerializeFieldMarshalTable(BinaryWriter writer);
    private void SerializeFieldRvaTable(BinaryWriter writer, int mbRVAOffset, Fixup sdataFixup, Fixup tlsFixup);
    private void SerializeFileTable(BinaryWriter writer);
    private void SerializeGenericParamTable(BinaryWriter writer);
    private void SerializeGenericParamConstraintTable(BinaryWriter writer);
    private void SerializeImplMapTable(BinaryWriter writer);
    private void SerializeInterfaceImplTable(BinaryWriter writer);
    private void SerializeManifestResourceTable(BinaryWriter writer);
    private void SerializeMemberRefTable(BinaryWriter writer);
    private void SerializeMethodTable(BinaryWriter writer, int mbRVAOffset);
    private void SerializeMethodImplTable(BinaryWriter writer);
    private void SerializeMethodSemanticsTable(BinaryWriter writer);
    private void SerializeMethodSpecTable(BinaryWriter writer);
    private void SerializeModuleTable(BinaryWriter writer);
    private void SerializeModuleRefTable(BinaryWriter writer);
    private void SerializeNestedClassTable(BinaryWriter writer);
    private void SerializeParamTable(BinaryWriter writer);
    private void SerializePropertyTable(BinaryWriter writer);
    private void SerializePropertyMapTable(BinaryWriter writer);
    private void SerializeStandAloneSigTable(BinaryWriter writer);
    private void SerializeTypeDefTable(BinaryWriter writer);
    private void SerializeTypeRefTable(BinaryWriter writer);
    private void SerializeTypeSpecTable(BinaryWriter writer);
    private int TablesLength();
    internal void WritePE(BinaryWriter writer);
    private void WriteWin32Resources(BinaryWriter writer, int virtualAddressBase);
    private void WriteDirectory(Directory directory, BinaryWriter writer, int offset, int level, int sizeOfDirectoryTree, int virtualAddressBase, BinaryWriter dataHeap);
    private int SizeOfDirectory(Directory directory);
    private void WriteNTHeader(BinaryWriter writer);
    private void WriteSectionHeaders(BinaryWriter writer);
    private void WriteCLIHeader(BinaryWriter writer);
    private int WriteImportTableAndEntryPointStub(BinaryWriter writer, SectionHeader& textSection);
    private void WriteReference(BinaryWriter writer, int index, int refSize);
    private int ComputeStrongNameSignatureSize();
}
internal class System.Compiler.Metadata.MethodImplRow : ValueType {
    internal int Class;
    internal int MethodBody;
    internal int MethodDeclaration;
}
internal class System.Compiler.Metadata.MethodPtrRow : ValueType {
    internal int Method;
}
internal class System.Compiler.Metadata.MethodRow : ValueType {
    internal int RVA;
    internal int ImplFlags;
    internal int Flags;
    internal int Name;
    internal int Signature;
    internal int ParamList;
    internal Method Method;
}
internal class System.Compiler.Metadata.MethodSemanticsRow : ValueType {
    internal int Semantics;
    internal int Method;
    internal int Association;
}
internal class System.Compiler.Metadata.MethodSpecRow : ValueType {
    internal int Method;
    internal int Instantiation;
    internal Method InstantiatedMethod;
}
internal class System.Compiler.Metadata.ModuleRefRow : ValueType {
    internal int Name;
    internal Module Module;
}
internal class System.Compiler.Metadata.ModuleRow : ValueType {
    internal int Generation;
    internal int Name;
    internal int Mvid;
    internal int EncId;
    internal int EncBaseId;
}
internal class System.Compiler.Metadata.NestedClassRow : ValueType {
    internal int NestedClass;
    internal int EnclosingClass;
}
internal class System.Compiler.Metadata.NTHeader : object {
    internal int signature;
    internal ushort machine;
    internal ushort numberOfSections;
    internal int timeDateStamp;
    internal int pointerToSymbolTable;
    internal int numberOfSymbols;
    internal ushort sizeOfOptionalHeader;
    internal ushort characteristics;
    internal ushort magic;
    internal byte majorLinkerVersion;
    internal byte minorLinkerVersion;
    internal int sizeOfCode;
    internal int sizeOfInitializedData;
    internal int sizeOfUninitializedData;
    internal int addressOfEntryPoint;
    internal int baseOfCode;
    internal int baseOfData;
    internal long imageBase;
    internal int sectionAlignment;
    internal int fileAlignment;
    internal ushort majorOperatingSystemVersion;
    internal ushort minorOperatingSystemVersion;
    internal ushort majorImageVersion;
    internal ushort minorImageVersion;
    internal ushort majorSubsystemVersion;
    internal ushort minorSubsystemVersion;
    internal int win32VersionValue;
    internal int sizeOfImage;
    internal int sizeOfHeaders;
    internal int checkSum;
    internal ushort subsystem;
    internal ushort dllCharacteristics;
    internal long sizeOfStackReserve;
    internal long sizeOfStackCommit;
    internal long sizeOfHeapReserve;
    internal long sizeOfHeapCommit;
    internal int loaderFlags;
    internal int numberOfDataDirectories;
    internal DirectoryEntry exportTable;
    internal DirectoryEntry importTable;
    internal DirectoryEntry resourceTable;
    internal DirectoryEntry exceptionTable;
    internal DirectoryEntry certificateTable;
    internal DirectoryEntry baseRelocationTable;
    internal DirectoryEntry debugTable;
    internal DirectoryEntry copyrightTable;
    internal DirectoryEntry globalPointerTable;
    internal DirectoryEntry threadLocalStorageTable;
    internal DirectoryEntry loadConfigTable;
    internal DirectoryEntry boundImportTable;
    internal DirectoryEntry importAddressTable;
    internal DirectoryEntry delayImportTable;
    internal DirectoryEntry cliHeaderTable;
    internal DirectoryEntry reserved;
}
internal class System.Compiler.Metadata.ParamPtrRow : ValueType {
    internal int Param;
}
internal class System.Compiler.Metadata.ParamRow : ValueType {
    internal int Flags;
    internal int Sequence;
    internal int Name;
}
internal class System.Compiler.Metadata.PropertyMapRow : ValueType {
    internal int Parent;
    internal int PropertyList;
}
internal class System.Compiler.Metadata.PropertyPtrRow : ValueType {
    internal int Property;
}
internal class System.Compiler.Metadata.PropertyRow : ValueType {
    internal int Flags;
    internal int Name;
    internal int Signature;
}
internal class System.Compiler.Metadata.Reader : object {
    private string directory;
    private string fileName;
    private bool doNotLockFile;
    private Module module;
    internal TypeNode currentType;
    private long sortedTablesMask;
    internal MetadataReader tables;
    private UnmanagedBuffer unmanagedBuffer;
    private int bufferLength;
    private IDictionary localAssemblyCache;
    internal static IDictionary StaticAssemblyCache;
    private bool useStaticCache;
    private TrivialHashtable namespaceTable;
    internal NamespaceList namespaceList;
    internal PdbInfo pdbInfo;
    internal ISymUnmanagedReader debugReader;
    private Dictionary`2<IntPtr, UnmanagedDocument> debugDocuments;
    internal bool getDebugSymbols;
    private bool getDebugSymbolsFailed;
    private TypeNodeList currentTypeParameters;
    private TypeNodeList currentMethodTypeParameters;
    internal bool preserveShortBranches;
    private TrivialHashtable TypeExtensionTable;
    private TypeExtensionProvider dummyTEProvider;
    private PostAssemblyLoadProcessor ReferringAssemblyPostLoad { get; }
    internal Reader(Byte[] buffer, IDictionary localAssemblyCache, bool doNotLockFile, bool getDebugInfo, bool useStaticCache, bool preserveShortBranches);
    internal Reader(string fileName, IDictionary localAssemblyCache, bool doNotLockFile, bool getDebugInfo, bool useStaticCache, bool preserveShortBranches);
    internal Reader(IDictionary localAssemblyCache, bool doNotLockFile, bool getDebugInfo, bool useStaticCache, bool preserveShortBranches);
    private static Reader();
    public sealed virtual void Dispose();
    private void SetupReader();
    private static bool ReadFile(IntPtr FileHandle, Byte* Buffer, int NumberOfBytesToRead, Int32* NumberOfBytesRead, IntPtr Overlapped);
    private void ReadFileIntoUnmanagedBuffer(FileStream inputStream);
    internal void SetupDebugReader(string filename, string pdbSearchPath);
    private AssemblyNode ReadAssembly();
    private AssemblyNode ReadAssembly(PostAssemblyLoadProcessor postLoadEvent);
    private AssemblyNode GetCachedAssembly(AssemblyNode assembly);
    internal Module ReadModule();
    internal Module ReadModule(PostAssemblyLoadProcessor postLoadEvent);
    private void ReadModuleProperties(Module module);
    private void ReadAssemblyProperties(AssemblyNode assembly);
    private void ReadAssemblyReferences(Module module);
    private void ReadModuleReferences(Module module);
    private static string ReadSerString(MemoryCursor sigReader);
    private void AddFieldsToType(TypeNode type, FieldRow[] fieldDefs, FieldPtrRow[] fieldPtrs, int start, int end);
    private void GetUnderlyingTypeOfEnumNode(EnumNode enumNode, FieldRow[] fieldDefs, FieldPtrRow[] fieldPtrs, int start, int end);
    private void AddMethodsToType(TypeNode type, MethodPtrRow[] methodPtrs, int start, int end);
    private void AddMoreStuffToParameters(Method method, ParameterList parameters, int start, int end);
    private void AddPropertiesToType(TypeNode type, PropertyRow[] propertyDefs, PropertyPtrRow[] propertyPtrs, int start, int end);
    private void AddMethodsToProperty(int propIndex, Property property);
    private void AddEventsToType(TypeNode type, EventRow[] eventDefs, EventPtrRow[] eventPtrs, int start, int end);
    private void AddMethodsToEvent(int eventIndex, Event evnt);
    private bool TypeDefOrRefOrSpecIsClass(int codedIndex);
    private bool TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass(int codedIndex);
    private TypeNode DecodeAndGetTypeDefOrRefOrSpec(int codedIndex);
    private TypeNode DecodeAndGetTypeDefOrRefOrSpec(int codedIndex, bool expectStruct);
    private TypeNode GetTypeIfNotGenericInstance(int codedIndex);
    internal AssemblyNode GetAssemblyFromReference(AssemblyReference assemblyReference);
    private PostAssemblyLoadProcessor get_ReferringAssemblyPostLoad();
    private static void GetAndCheckSignatureToken(int expectedToken, MemoryCursor sigReader);
    private Method GetConstructorDefOrRef(int codedIndex, TypeNodeList& varArgTypes);
    private void GetResources(Module module);
    private SecurityAttribute GetSecurityAttribute(int i);
    private AttributeList GetPermissionAttributes(int blobIndex, SecurityAction action);
    private AttributeNode GetPermissionAttribute(MemoryCursor sigReader);
    private AttributeList GetPermissionAttributes2(int blobIndex, SecurityAction action);
    private AttributeNode GetPermissionAttribute2(MemoryCursor sigReader, SecurityAction action);
    private static void HandleError(Module mod, string errorMessage);
    private AttributeNode GetCustomAttribute(int i);
    private AttributeNode GetCustomAttribute(Method cons, MemoryCursor sigReader, int blobLength);
    private void GetCustomAttributeNamedArguments(ExpressionList arguments, ushort numNamed, MemoryCursor sigReader);
    private object GetCustomAttributeLiteralValue(MemoryCursor sigReader, TypeNode type);
    private object GetCustomAttributeLiteralValue(MemoryCursor sigReader, TypeNode& type);
    private static EnumNode GetCustomAttributeEnumNode(TypeNode& type);
    private Array GetCustomAttributeLiteralArray(MemoryCursor sigReader, int numElems, TypeNode elemType);
    private Array ConstructCustomAttributeLiteralArray(int numElems, TypeNode elemType);
    private TypeNode GetTypeFromSerializedName(string serializedName);
    private static int FindFirstCommaOutsideBrackets(string serializedName);
    private TypeNode GetTypeFromSerializedName(string typeName, string assemblyName);
    private TypeNode GetTypeFromSerializedName(string typeName, TypeNode nestingType);
    private TypeNode ParseArrayOrGenericType(string typeName, TypeNode rootType);
    private static void ParseSimpleTypeName(string source, String& name, Int32& i);
    private static void ParseTypeName(string source, String& nspace, String& name, Int32& i);
    private TypeNode LookupType(string nameSpace, string name, string assemblyName, Module& module);
    private void GetCustomAttributesFor(Module module);
    private AttributeList GetCustomAttributesNonNullFor(int parentIndex);
    private AttributeList GetCustomAttributesFor(int parentIndex);
    private SecurityAttributeList GetSecurityAttributesFor(int parentIndex);
    private void GetTypeParameterConstraints(int parentIndex, TypeNodeList parameters);
    private TypeNodeList GetTypeParametersFor(int parentIndex, Member parent);
    private TypeNode GetGenericParameter(int index, int parameterListIndex, Member parent);
    private void GetGenericParameterConstraints(int index, TypeNode& parameter);
    internal static Block GetOrCreateBlock(TrivialHashtable blockMap, int address);
    internal Field GetFieldFromDef(int i);
    internal Field GetFieldFromDef(int i, TypeNode declaringType);
    private Byte[] GetInitialData(int fieldIndex, TypeNode fieldType, PESection& targetSection);
    private Literal GetLiteral(int parentCodedIndex, TypeNode type);
    internal FunctionPointer GetCalliSignature(int ssigToken);
    internal void GetLocals(int localIndex, LocalList locals, Dictionary`2<int, LocalInfo> localSourceNames);
    internal void GetLocalSourceNames(ISymUnmanagedScope scope, Dictionary`2<int, LocalInfo> localSourceNames);
    private MarshallingInformation GetMarshallingInformation(int parentCodedIndex);
    private void GetMethodBody(Method method, object i, bool asInstructionList);
    private void GetMethodDebugSymbols(Method method, UInt32 methodToken);
    private void GetMethodInstructions(Method method, object i);
    internal Method GetMethodDefOrRef(int codedIndex);
    private Method GetMethodDefOrRef(int codedIndex, int numberOfGenericArguments);
    internal Method GetMethodFromDef(int index);
    internal Method GetMethodFromDef(int index, TypeNode declaringType);
    private void GetMethodAttributes(Method method, object handle);
    private Method GetMethodFromSpec(int i);
    internal Member GetMemberFromToken(int tok, object memberInfo);
    internal Member GetMemberFromToken(int tok, TypeNodeList& varArgTypes, object memberInfo);
    internal Member GetMemberFromRef(int i, TypeNodeList& varArgTypes, object memberInfo);
    internal Member GetMemberFromRef(int i, TypeNodeList& varArgTypes, int numGenericArgs, object memberInfo);
    private Method SearchBaseInterface(Interface iface, Identifier memberName, TypeNode returnType, TypeNodeList paramTypes, int typeParamCount, CallingConventionFlags callingConvention);
    private static bool CanCacheMethodHelper(Method method);
    private static bool CanCacheMember(Member member);
    private TypeNodeList ParseParameterTypes(TypeNodeList& varArgTypes, MemoryCursor sigReader, int paramCount, Boolean& genericParameterEncountered);
    private bool TypeDefIsClass(int i);
    private bool TypeDefIsClassButNotValueTypeBaseClass(int i);
    internal TypeNodeList GetInstantiatedTypes();
    internal TypeNode GetTypeFromDef(int i);
    internal TypeNode GetTypeFromDefHelper(int i);
    private void GetInterfaceIndices(int i, Int32& firstInterfaceIndex, Int32& lastInterfaceIndex);
    private void GetClassSizeAndPackingSize(int i, TypeNode result);
    private void GetInterfaces(int i, int firstInterfaceIndex, InterfaceList interfaces);
    private void RemoveTypeParametersBelongingToDeclaringType(int i, TypeNodeList& typeParameters, TypeNode type);
    private TypeNode ConstructCorrectTypeNodeSubclass(int i, Identifier namesp, int firstInterfaceIndex, int lastInterfaceIndex, TypeFlags flags, InterfaceList interfaces, int baseTypeCodedIndex, bool isSystemEnum);
    private static TypeNode DummyTypeExtensionProvider(NestedTypeProvider nprovider, TypeAttributeProvider aprovider, TypeMemberProvider mprovider, TypeNode baseType, object handle);
    private TypeNode GetTypeExtensionFromDef(NestedTypeProvider nestedTypeProvider, TypeAttributeProvider attributeProvider, TypeMemberProvider memberProvider, object handle, TypeNode baseType, Interface lastInterface);
    private static int GetInheritedTypeParameterCount(TypeNode type);
    private TypeNode GetTypeGlobalMemberContainerTypeFromModule(int i);
    internal void GetNamespaces();
    private TypeNode GetTypeFromName(Identifier Namespace, Identifier name);
    private TypeNode GetForwardedTypeFromName(Identifier Namespace, Identifier name);
    private TypeNode GetReplacedTypeFromName(Identifier Namespace, Identifier name);
    internal bool IsValidTypeName(Identifier Namespace, Identifier name);
    internal TypeNode GetTypeFromRef(int i);
    internal TypeNode GetTypeFromRef(int i, bool expectStruct);
    private TypeNode GetDummyTypeNode(Identifier namesp, Identifier name, Module declaringModule, TypeNode declaringType, bool expectStruct);
    private bool TypeSpecIsClass(int i);
    internal TypeNode GetTypeFromSpec(int i);
    private static bool CanCacheTypeNode(TypeNode type);
    private static Module GetNestedModule(Module module, string modName, String& modLocation);
    private void GetTypeList(Module module);
    private void GetNestedTypes(TypeNode type, object handle);
    private void GetTypeMembers(TypeNode type, object handle);
    private void GetTypeAttributes(TypeNode type, object handle);
    private void GetTypeParameterAttributes(TypeNode type, object handle);
    private TypeNodeList ParseTypeList(MemoryCursor sigReader);
    private bool TypeSignatureIsClass(MemoryCursor sigReader);
    private TypeNode ParseTypeSignature(MemoryCursor sigReader);
    private TypeNode ParseTypeSignature(MemoryCursor sigReader, Boolean& pinned);
    private TypeNode ParseTypeSignature(MemoryCursor sigReader, Boolean& pinned, Boolean& isTypeArgument);
    private FunctionPointer ParseFunctionPointer(MemoryCursor sigReader);
    private StatementList ParseMethodBody(Method method, int methodIndex, int RVA);
    private InstructionList ParseMethodInstructions(Method method, int methodIndex, int RVA);
}
internal class System.Compiler.Metadata.SectionHeader : ValueType {
    internal string name;
    internal int virtualSize;
    internal int virtualAddress;
    internal int sizeOfRawData;
    internal int pointerToRawData;
    internal int pointerToRelocations;
    internal int pointerToLinenumbers;
    internal ushort numberOfRelocations;
    internal ushort numberOfLinenumbers;
    internal int characteristics;
}
internal class System.Compiler.Metadata.StandAloneSigRow : ValueType {
    internal int Signature;
}
internal class System.Compiler.Metadata.StreamHeader : object {
    internal int offset;
    internal int size;
    internal string name;
}
[DefaultMemberAttribute("Item")]
internal class System.Compiler.Metadata.SynchronizedWeakDictionary : object {
    private Hashtable Hashtable;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum System.Compiler.Metadata.TableIndices : Enum {
    public int value__;
    public static TableIndices Module;
    public static TableIndices TypeRef;
    public static TableIndices TypeDef;
    public static TableIndices FieldPtr;
    public static TableIndices Field;
    public static TableIndices MethodPtr;
    public static TableIndices Method;
    public static TableIndices ParamPtr;
    public static TableIndices Param;
    public static TableIndices InterfaceImpl;
    public static TableIndices MemberRef;
    public static TableIndices Constant;
    public static TableIndices CustomAttribute;
    public static TableIndices FieldMarshal;
    public static TableIndices DeclSecurity;
    public static TableIndices ClassLayout;
    public static TableIndices FieldLayout;
    public static TableIndices StandAloneSig;
    public static TableIndices EventMap;
    public static TableIndices EventPtr;
    public static TableIndices Event;
    public static TableIndices PropertyMap;
    public static TableIndices PropertyPtr;
    public static TableIndices Property;
    public static TableIndices MethodSemantics;
    public static TableIndices MethodImpl;
    public static TableIndices ModuleRef;
    public static TableIndices TypeSpec;
    public static TableIndices ImplMap;
    public static TableIndices FieldRva;
    public static TableIndices EncLog;
    public static TableIndices EncMap;
    public static TableIndices Assembly;
    public static TableIndices AssemblyProcessor;
    public static TableIndices AssemblyOS;
    public static TableIndices AssemblyRef;
    public static TableIndices AssemblyRefProcessor;
    public static TableIndices AssemblyRefOS;
    public static TableIndices File;
    public static TableIndices ExportedType;
    public static TableIndices ManifestResource;
    public static TableIndices NestedClass;
    public static TableIndices GenericParam;
    public static TableIndices MethodSpec;
    public static TableIndices GenericParamConstraint;
    public static TableIndices Count;
}
internal class System.Compiler.Metadata.TablesHeader : object {
    internal int reserved;
    internal byte majorVersion;
    internal byte minorVersion;
    internal byte heapSizes;
    internal byte rowId;
    internal long maskValid;
    internal long maskSorted;
    internal Int32[] countArray;
}
internal class System.Compiler.Metadata.TypeDefRow : ValueType {
    internal int Flags;
    internal int Name;
    internal int Namespace;
    internal int Extends;
    internal int FieldList;
    internal int MethodList;
    internal TypeNode Type;
    internal Identifier NamespaceId;
    internal int NamespaceKey;
    internal int NameKey;
}
internal class System.Compiler.Metadata.TypeRefRow : ValueType {
    internal int ResolutionScope;
    internal int Name;
    internal int Namespace;
    internal TypeNode Type;
}
internal class System.Compiler.Metadata.TypeSpecRow : ValueType {
    internal int Signature;
    internal TypeNode Type;
}
internal class System.Compiler.Metadata.UnmanagedBuffer : object {
    internal IntPtr Pointer;
    internal UnmanagedBuffer(int length);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class System.Compiler.Metadata.WeakValuesCollection : object {
    private ICollection collection;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal WeakValuesCollection(ICollection collection);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class System.Compiler.Metadata.WeakValuesEnumerator : object {
    private IEnumerator enumerator;
    public object Current { get; }
    internal WeakValuesEnumerator(IEnumerator enumerator);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Compiler.Method : Member {
    internal MethodContractProvider ProvideContract;
    protected internal MethodContract contract;
    internal static MethodContract DummyContract;
    public LocalList LocalList;
    protected SecurityAttributeList securityAttributes;
    public MethodBodyProvider ProvideBody;
    public object ProviderHandle;
    public int MethodToken;
    private MethodFlags flags;
    private MethodImplFlags implFlags;
    private MethodList implementedInterfaceMethods;
    private MethodList implicitlyImplementedInterfaceMethods;
    private MethodList shallowImplicitlyImplementedInterfaceMethods;
    private CallingConventionFlags callingConvention;
    private bool initLocals;
    private bool isGeneric;
    private ParameterList parameters;
    private PInvokeFlags pInvokeFlags;
    private Module pInvokeModule;
    private string pInvokeImportName;
    private AttributeList returnAttributes;
    private MarshallingInformation returnTypeMarshallingInformation;
    private TypeNode returnType;
    private Member declaringMember;
    private This thisParameter;
    protected internal Block body;
    public MethodAttributeProvider ProvideMethodAttributes;
    protected string conditionalSymbol;
    protected bool doesNotHaveAConditionalSymbol;
    protected InstructionList instructions;
    protected ExceptionHandlerList exceptionHandlers;
    protected internal string fullName;
    protected bool isNormalized;
    protected MethodInfo methodInfo;
    protected TypeNode[] parameterTypes;
    internal TrivialHashtable contextForOffset;
    private static Method NotSpecified;
    private Method template;
    private TypeNodeList templateArguments;
    internal TypeNodeList templateParameters;
    public ExtraPDBInfo ExtraDebugInfo;
    public bool IsAsync;
    public Nullable`1<int> MoveNextStartState;
    public MethodContract Contract { get; public set; }
    public SecurityAttributeList SecurityAttributes { get; public set; }
    public MethodFlags Flags { get; public set; }
    public MethodImplFlags ImplFlags { get; public set; }
    public MethodList ImplementedInterfaceMethods { get; public set; }
    public MethodList ImplicitlyImplementedInterfaceMethods { get; public set; }
    public MethodList ShallowImplicitlyImplementedInterfaceMethods { get; }
    public CallingConventionFlags CallingConvention { get; public set; }
    public bool InitLocals { get; public set; }
    public bool IsGeneric { get; public set; }
    public ParameterList Parameters { get; public set; }
    public int ParameterCount { get; }
    public PInvokeFlags PInvokeFlags { get; public set; }
    public Module PInvokeModule { get; public set; }
    public string PInvokeImportName { get; public set; }
    public AttributeList ReturnAttributes { get; public set; }
    public MarshallingInformation ReturnTypeMarshallingInformation { get; public set; }
    public TypeNode ReturnType { get; public set; }
    public Member DeclaringMember { get; public set; }
    public This ThisParameter { get; public set; }
    public Block Body { get; public set; }
    public AttributeList Attributes { get; public set; }
    public string ConditionalSymbol { get; public set; }
    public InstructionList Instructions { get; public set; }
    public ExceptionHandlerList ExceptionHandlers { get; public set; }
    public string FullName { get; }
    public bool IsNormalized { get; public set; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsExtern { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsInternalCall { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsNonSealedVirtual { get; }
    public bool IsVirtualAndNotDeclaredInStruct { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public bool IsPropertyGetter { get; }
    public bool IsPropertySetter { get; }
    public bool IsVarArg { get; }
    public bool IsFieldInitializerMethod { get; }
    public Member HiddenMember { get; public set; }
    public Method HiddenMethod { get; public set; }
    public Member OverriddenMember { get; public set; }
    public Method OverriddenMethod { get; public set; }
    public Method Template { get; public set; }
    public TypeNodeList TemplateArguments { get; public set; }
    public TypeNodeList TemplateParameters { get; public set; }
    public Method(MethodBodyProvider provider, object handle, int methodToken);
    public Method(MethodBodyProvider provider, object handle);
    public Method(TypeNode declaringType, AttributeList attributes, Identifier name, ParameterList parameters, TypeNode returnType, Block body);
    private static Method();
    public sealed virtual bool Equals(Method other);
    public virtual MethodContract get_Contract();
    public virtual void set_Contract(MethodContract value);
    public void SetDelayedContract(MethodContractProvider provider);
    public SecurityAttributeList get_SecurityAttributes();
    public void set_SecurityAttributes(SecurityAttributeList value);
    public MethodFlags get_Flags();
    public void set_Flags(MethodFlags value);
    public MethodImplFlags get_ImplFlags();
    public void set_ImplFlags(MethodImplFlags value);
    public MethodList get_ImplementedInterfaceMethods();
    public void set_ImplementedInterfaceMethods(MethodList value);
    public MethodList get_ImplicitlyImplementedInterfaceMethods();
    public void set_ImplicitlyImplementedInterfaceMethods(MethodList value);
    public MethodList get_ShallowImplicitlyImplementedInterfaceMethods();
    public CallingConventionFlags get_CallingConvention();
    public void set_CallingConvention(CallingConventionFlags value);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public bool get_IsGeneric();
    public void set_IsGeneric(bool value);
    public ParameterList get_Parameters();
    public void set_Parameters(ParameterList value);
    public int get_ParameterCount();
    public PInvokeFlags get_PInvokeFlags();
    public void set_PInvokeFlags(PInvokeFlags value);
    public Module get_PInvokeModule();
    public void set_PInvokeModule(Module value);
    public string get_PInvokeImportName();
    public void set_PInvokeImportName(string value);
    public AttributeList get_ReturnAttributes();
    public void set_ReturnAttributes(AttributeList value);
    public MarshallingInformation get_ReturnTypeMarshallingInformation();
    public void set_ReturnTypeMarshallingInformation(MarshallingInformation value);
    public TypeNode get_ReturnType();
    public void set_ReturnType(TypeNode value);
    public Member get_DeclaringMember();
    public void set_DeclaringMember(Member value);
    public This get_ThisParameter();
    public void set_ThisParameter(This value);
    public virtual Block get_Body();
    public virtual void set_Body(Block value);
    public virtual AttributeList get_Attributes();
    public virtual void set_Attributes(AttributeList value);
    public void ClearBody();
    public string get_ConditionalSymbol();
    public void set_ConditionalSymbol(string value);
    public virtual InstructionList get_Instructions();
    public virtual void set_Instructions(InstructionList value);
    public virtual ExceptionHandlerList get_ExceptionHandlers();
    public virtual void set_ExceptionHandlers(ExceptionHandlerList value);
    protected virtual Identifier GetDocumentationId();
    public virtual string get_FullName();
    public virtual string GetUnmangledNameWithoutTypeParameters();
    public virtual string GetUnmangledNameWithoutTypeParameters(bool omitParameterTypes);
    public virtual string GetUnmangledNameWithTypeParameters();
    public virtual string GetUnmangledNameWithTypeParameters(bool omitParameterTypes);
    public virtual string GetFullUnmangledNameWithTypeParameters();
    public virtual string GetFullUnmangledNameWithTypeParameters(bool omitParameterTypes);
    public static MethodFlags GetVisibilityUnion(Method m1, Method m2);
    public static MethodFlags GetVisibilityUnion(MethodFlags vis1, MethodFlags vis2);
    public virtual object Invoke(object targetObject, Object[] arguments);
    public virtual Literal Invoke(Literal targetObject, Literal[] arguments);
    public virtual bool get_IsNormalized();
    public virtual void set_IsNormalized(bool value);
    public virtual bool get_IsAbstract();
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsExtern();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public virtual bool get_IsFinal();
    public virtual bool get_IsInternalCall();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPublic();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNonSealedVirtual();
    public virtual bool get_IsVirtualAndNotDeclaredInStruct();
    public virtual bool get_IsVisibleOutsideAssembly();
    public bool get_IsPropertyGetter();
    public bool get_IsPropertySetter();
    public bool get_IsVarArg();
    public virtual bool get_IsFieldInitializerMethod();
    public virtual Member get_HiddenMember();
    public virtual void set_HiddenMember(Member value);
    public virtual Method get_HiddenMethod();
    public virtual void set_HiddenMethod(Method value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual Method get_OverriddenMethod();
    public virtual void set_OverriddenMethod(Method value);
    public static Method GetMethod(MethodInfo methodInfo);
    public virtual MethodInfo GetMethodInfo();
    public virtual TypeNode[] GetParameterTypes();
    public virtual bool ParametersMatch(ParameterList parameters);
    public virtual bool ParametersMatchExceptLast(ParameterList parameters);
    public virtual bool ParametersMatchStructurally(ParameterList parameters);
    public virtual bool ParametersMatchStructurallyIncludingOutFlag(ParameterList parameters);
    public virtual bool ParametersMatchStructurallyIncludingOutFlag(ParameterList parameters, bool allowCoVariance);
    public virtual bool ParametersMatchStructurallyExceptLast(ParameterList parameters);
    public virtual bool ParametersMatchIncludingOutFlag(ParameterList parameters);
    public virtual bool ParameterTypesMatch(TypeNodeList argumentTypes);
    public virtual bool ParameterTypesMatchStructurally(TypeNodeList argumentTypes);
    public virtual bool TemplateParametersMatch(TypeNodeList templateParameters);
    internal void RecordSequencePoints(ISymUnmanagedMethod methodInfo, Dictionary`2<IntPtr, UnmanagedDocument> documentCache);
    public Method get_Template();
    public void set_Template(Method value);
    public TypeNodeList get_TemplateArguments();
    public void set_TemplateArguments(TypeNodeList value);
    public virtual TypeNodeList get_TemplateParameters();
    public virtual void set_TemplateParameters(TypeNodeList value);
    public virtual Method GetTemplateInstance(TypeNode referringType, TypeNode[] typeArguments);
    public virtual Method GetTemplateInstance(TypeNode referringType, TypeNodeList typeArguments);
    private static bool TypeListsAreEquivalent(TypeNodeList list1, TypeNodeList list2);
    public Method CreateExplicitImplementation(TypeNode implementingType, ParameterList parameters, StatementList body);
    public virtual bool TypeParameterCountsMatch(Method meth2);
    public virtual string ToString();
}
public class System.Compiler.MethodBodySpecializer : Specializer {
    public TrivialHashtable alreadyVisitedNodes;
    public Method methodBeingSpecialized;
    public Method dummyMethod;
    public MethodBodySpecializer(Module module, TypeNodeList pars, TypeNodeList args);
    public MethodBodySpecializer(Visitor callingVisitor);
    public virtual Node Visit(Node node);
    public virtual Expression VisitAddressDereference(AddressDereference addr);
    public virtual Statement VisitAssignmentStatement(AssignmentStatement assignment);
    public virtual Expression VisitBinaryExpression(BinaryExpression binaryExpression);
    public virtual Statement VisitBranch(Branch branch);
    public virtual Expression VisitExpression(Expression expression);
    public virtual Expression VisitIndexer(Indexer indexer);
    public virtual Expression VisitLiteral(Literal literal);
    public virtual Expression VisitLocal(Local local);
    public virtual Expression VisitParameter(Parameter parameter);
    public virtual Expression VisitMemberBinding(MemberBinding memberBinding);
    public virtual Method VisitMethod(Method method);
    public virtual Expression VisitConstruct(Construct cons);
    public virtual Expression VisitMethodCall(MethodCall call);
    public virtual Statement VisitReturn(Return Return);
    public virtual TypeNode VisitTypeNode(TypeNode typeNode);
    public virtual Expression VisitUnaryExpression(UnaryExpression unaryExpression);
}
public class System.Compiler.MethodCall : NaryExpression {
    private Expression callee;
    private TypeNode constraint;
    private bool isTailCall;
    public Expression CalleeExpression;
    public bool GiveErrorIfSpecialNameMethod;
    public bool ArgumentListIsIncomplete;
    public Expression Callee { get; public set; }
    public bool IsTailCall { get; public set; }
    public TypeNode Constraint { get; public set; }
    public MethodCall(Expression callee, ExpressionList arguments);
    public MethodCall(Expression callee, ExpressionList arguments, NodeType typeOfCall);
    public MethodCall(Expression callee, ExpressionList arguments, NodeType typeOfCall, TypeNode resultType);
    public MethodCall(Expression callee, ExpressionList arguments, NodeType typeOfCall, TypeNode resultType, SourceContext sctx);
    public Expression get_Callee();
    public void set_Callee(Expression value);
    public bool get_IsTailCall();
    public void set_IsTailCall(bool value);
    public TypeNode get_Constraint();
    public void set_Constraint(TypeNode value);
}
public class System.Compiler.MethodClassParameter : ClassParameter {
    public virtual Type GetRuntimeType();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.MethodContract : Node {
    public Method DeclaringMethod;
    public Method OriginalDeclaringMethod;
    protected internal Block contractInitializer;
    protected internal Block postPreamble;
    protected internal RequiresList requires;
    protected internal EnsuresList ensures;
    protected internal EnsuresList modelEnsures;
    protected internal RequiresList validations;
    protected internal ExpressionList modifies;
    protected internal Nullable`1<bool> isPure;
    protected internal EnsuresList asyncEnsures;
    private int legacyValidations;
    public Block ContractInitializer { get; public set; }
    public Block PostPreamble { get; public set; }
    public int RequiresCount { get; }
    public int EnsuresCount { get; }
    public int ModelEnsuresCount { get; }
    public int AsyncEnsuresCount { get; }
    public bool HasLegacyValidations { get; }
    public int ValidationsCount { get; }
    public int ModifiesCount { get; }
    public RequiresList Requires { get; public set; }
    public EnsuresList Ensures { get; public set; }
    public EnsuresList AsyncEnsures { get; public set; }
    public EnsuresList ModelEnsures { get; public set; }
    public RequiresList Validations { get; public set; }
    public bool IsPure { get; public set; }
    public ExpressionList Modifies { get; public set; }
    public MethodContract(Method declaringMethod);
    public Block get_ContractInitializer();
    public void set_ContractInitializer(Block value);
    public Block get_PostPreamble();
    public void set_PostPreamble(Block value);
    public int get_RequiresCount();
    public int get_EnsuresCount();
    public int get_ModelEnsuresCount();
    public int get_AsyncEnsuresCount();
    public bool get_HasLegacyValidations();
    public int get_ValidationsCount();
    public int get_ModifiesCount();
    public RequiresList get_Requires();
    public void set_Requires(RequiresList value);
    public EnsuresList get_Ensures();
    public void set_Ensures(EnsuresList value);
    public EnsuresList get_AsyncEnsures();
    public void set_AsyncEnsures(EnsuresList value);
    public EnsuresList get_ModelEnsures();
    public void set_ModelEnsures(EnsuresList value);
    public RequiresList get_Validations();
    public void set_Validations(RequiresList value);
    public bool get_IsPure();
    public void set_IsPure(bool value);
    public ExpressionList get_Modifies();
    public void set_Modifies(ExpressionList value);
}
public abstract class System.Compiler.MethodContractElement : Node {
    public SourceContext DefSite;
    public bool UsesModels;
    public bool Inherited;
    public int ILOffset;
    public Expression UserMessage;
    public Literal SourceConditionText;
    public Expression Assertion { get; }
    protected MethodContractElement(NodeType nodeType);
    public abstract virtual Expression get_Assertion();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.MethodContractElementList : object {
    private MethodContractElement[] elements;
    private int count;
    public int Count { get; }
    public MethodContractElement Item { get; public set; }
    public MethodContractElementList(int capacity);
    public void Add(MethodContractElement element);
    public MethodContractElementList Clone();
    public int get_Count();
    public MethodContractElement get_Item(int index);
    public void set_Item(int index, MethodContractElement value);
    public Enumerator GetEnumerator();
}
[FlagsAttribute]
public enum System.Compiler.MethodFlags : Enum {
    public int value__;
    public static MethodFlags MethodAccessMask;
    public static MethodFlags CompilerControlled;
    public static MethodFlags Private;
    public static MethodFlags FamANDAssem;
    public static MethodFlags Assembly;
    public static MethodFlags Family;
    public static MethodFlags FamORAssem;
    public static MethodFlags Public;
    public static MethodFlags Static;
    public static MethodFlags Final;
    public static MethodFlags Virtual;
    public static MethodFlags HideBySig;
    public static MethodFlags VtableLayoutMask;
    public static MethodFlags ReuseSlot;
    public static MethodFlags NewSlot;
    public static MethodFlags CheckAccessOnOverride;
    public static MethodFlags Abstract;
    public static MethodFlags SpecialName;
    public static MethodFlags PInvokeImpl;
    public static MethodFlags UnmanagedExport;
    public static MethodFlags ReservedMask;
    public static MethodFlags RTSpecialName;
    public static MethodFlags HasSecurity;
    public static MethodFlags RequireSecObject;
    public static MethodFlags Extend;
}
[FlagsAttribute]
public enum System.Compiler.MethodImplFlags : Enum {
    public int value__;
    public static MethodImplFlags CodeTypeMask;
    public static MethodImplFlags IL;
    public static MethodImplFlags Native;
    public static MethodImplFlags OPTIL;
    public static MethodImplFlags Runtime;
    public static MethodImplFlags ManagedMask;
    public static MethodImplFlags Unmanaged;
    public static MethodImplFlags Managed;
    public static MethodImplFlags ForwardRef;
    public static MethodImplFlags PreserveSig;
    public static MethodImplFlags InternalCall;
    public static MethodImplFlags Synchronized;
    public static MethodImplFlags NoInlining;
    public static MethodImplFlags MaxMethodImplVal;
}
internal class System.Compiler.MethodInfo : object {
    internal TrivialHashtable fixupIndex;
    internal int localVarSigTok;
    internal BinaryWriter localVarSignature;
    internal TrivialHashtable`1<int> localVarIndex;
    internal NodeList statementNodes;
    internal LocalList debugLocals;
    internal Int32List signatureLengths;
    internal Int32List signatureOffsets;
    internal Int32List statementOffsets;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.MethodList : object {
    private Method[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Method Item { get; public set; }
    public MethodList(int capacity);
    public MethodList(Method[] elements);
    public void Add(Method element);
    public MethodList Clone();
    public int get_Count();
    public int get_Length();
    public Method get_Item(int index);
    public void set_Item(int index, Method value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.MethodTypeParameter : TypeParameter {
    public MethodTypeParameter(InterfaceList baseInterfaces, NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public virtual Type GetRuntimeType();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.Module : Node {
    internal Reader reader;
    protected TypeNodeListProvider provideTypeNodeList;
    protected TypeNodeProvider provideTypeNode;
    protected TrivialHashtable namespaceTable;
    protected NamespaceList namespaceList;
    protected int savedTypesLength;
    protected CustomAttributeProvider provideCustomAttributes;
    protected ResourceProvider provideResources;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssemblyReferenceResolver AssemblyReferenceResolution;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssemblyReferenceResolver AssemblyReferenceResolutionAfterProbingFailed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DocumentationResolver DocumentationResolution;
    public bool IsNormalized;
    public bool UsePublicKeyTokensForAssemblyReferences;
    internal int FileAlignment;
    internal static object GlobalLock;
    public bool StripOptionalModifiersFromLocals;
    private AssemblyReferenceList assemblyReferences;
    private AssemblyNode containingAssembly;
    private ushort dllCharacteristics;
    private string directory;
    private AssemblyHashAlgorithm hashAlgorithm;
    private Byte[] hashValue;
    private ModuleKindFlags kind;
    private string location;
    private Guid mvid;
    private string targetRuntimeVersion;
    private int linkerMajorVersion;
    private int linkerMinorVersion;
    private int metadataFormatMajorVersion;
    private int metadataFormatMinorVersion;
    private Nullable`1<bool> projectModule;
    private string name;
    private PEKindFlags peKind;
    private bool trackDebugData;
    private ArrayList metadataImportErrors;
    protected AttributeList attributes;
    protected SecurityAttributeList securityAttributes;
    public Node DocumentationNode;
    protected XmlDocument documentation;
    protected internal static Method NoSuchMethod;
    protected Method entryPoint;
    protected ModuleReferenceList moduleReferences;
    protected ResourceList resources;
    protected Win32ResourceList win32Resources;
    protected TrivialHashtable memberDocumentationCache;
    protected TrivialHashtable validNamespaces;
    private TrivialHashtableUsingWeakReferences structurallyEquivalentType;
    protected internal TypeNodeList types;
    protected TrivialHashtable referencedModulesAndAssemblies;
    public MethodBodySpecializerFactory CreateMethodBodySpecializer;
    public AssemblyReferenceList AssemblyReferences { get; public set; }
    public AssemblyNode ContainingAssembly { get; public set; }
    public ushort DllCharacteristics { get; public set; }
    public string Directory { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HashValue { get; public set; }
    public ModuleKindFlags Kind { get; public set; }
    public string Location { get; public set; }
    public Guid Mvid { get; public set; }
    public string TargetRuntimeVersion { get; public set; }
    public int LinkerMajorVersion { get; public set; }
    public int LinkerMinorVersion { get; public set; }
    public int MetadataFormatMajorVersion { get; public set; }
    public int MetadataFormatMinorVersion { get; public set; }
    public bool ProjectTypesContainedInModule { get; public set; }
    public string Name { get; public set; }
    public PEKindFlags PEKind { get; public set; }
    public bool TrackDebugData { get; public set; }
    public ArrayList MetadataImportErrors { get; public set; }
    public AttributeList Attributes { get; public set; }
    public SecurityAttributeList SecurityAttributes { get; public set; }
    public XmlDocument Documentation { get; public set; }
    public Method EntryPoint { get; public set; }
    public ModuleReferenceList ModuleReferences { get; public set; }
    public ResourceList Resources { get; public set; }
    public Win32ResourceList Win32Resources { get; public set; }
    internal TrivialHashtableUsingWeakReferences StructurallyEquivalentType { get; }
    public TypeNodeList Types { get; public set; }
    public Module(TypeNodeProvider provider, TypeNodeListProvider listProvider, CustomAttributeProvider provideCustomAttributes, ResourceProvider provideResources);
    private static Module();
    [CompilerGeneratedAttribute]
public void add_AssemblyReferenceResolution(AssemblyReferenceResolver value);
    [CompilerGeneratedAttribute]
public void remove_AssemblyReferenceResolution(AssemblyReferenceResolver value);
    [CompilerGeneratedAttribute]
public void add_AssemblyReferenceResolutionAfterProbingFailed(AssemblyReferenceResolver value);
    [CompilerGeneratedAttribute]
public void remove_AssemblyReferenceResolutionAfterProbingFailed(AssemblyReferenceResolver value);
    [CompilerGeneratedAttribute]
public void add_DocumentationResolution(DocumentationResolver value);
    [CompilerGeneratedAttribute]
public void remove_DocumentationResolution(DocumentationResolver value);
    public virtual void Dispose();
    public AssemblyReferenceList get_AssemblyReferences();
    public void set_AssemblyReferences(AssemblyReferenceList value);
    public AssemblyNode get_ContainingAssembly();
    public void set_ContainingAssembly(AssemblyNode value);
    public ushort get_DllCharacteristics();
    public void set_DllCharacteristics(ushort value);
    public string get_Directory();
    public void set_Directory(string value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public Byte[] get_HashValue();
    public void set_HashValue(Byte[] value);
    public ModuleKindFlags get_Kind();
    public void set_Kind(ModuleKindFlags value);
    public string get_Location();
    public void set_Location(string value);
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    public string get_TargetRuntimeVersion();
    public void set_TargetRuntimeVersion(string value);
    public int get_LinkerMajorVersion();
    public void set_LinkerMajorVersion(int value);
    public int get_LinkerMinorVersion();
    public void set_LinkerMinorVersion(int value);
    public int get_MetadataFormatMajorVersion();
    public void set_MetadataFormatMajorVersion(int value);
    public int get_MetadataFormatMinorVersion();
    public void set_MetadataFormatMinorVersion(int value);
    public bool get_ProjectTypesContainedInModule();
    public void set_ProjectTypesContainedInModule(bool value);
    public string get_Name();
    public void set_Name(string value);
    public PEKindFlags get_PEKind();
    public void set_PEKind(PEKindFlags value);
    public bool get_TrackDebugData();
    public void set_TrackDebugData(bool value);
    public ArrayList get_MetadataImportErrors();
    public void set_MetadataImportErrors(ArrayList value);
    public virtual AttributeList get_Attributes();
    public virtual void set_Attributes(AttributeList value);
    public virtual SecurityAttributeList get_SecurityAttributes();
    public virtual void set_SecurityAttributes(SecurityAttributeList value);
    public virtual XmlDocument get_Documentation();
    public virtual void set_Documentation(XmlDocument value);
    public virtual XmlDocument ProbeForXmlDocumentation(string dir, string subDir, string fileName);
    public virtual Method get_EntryPoint();
    public virtual void set_EntryPoint(Method value);
    public ModuleReferenceList get_ModuleReferences();
    public void set_ModuleReferences(ModuleReferenceList value);
    public virtual bool ContainsModule(Module module);
    public virtual ResourceList get_Resources();
    public virtual void set_Resources(ResourceList value);
    public virtual Win32ResourceList get_Win32Resources();
    public virtual void set_Win32Resources(Win32ResourceList value);
    public virtual void AddWin32ResourceFile(string win32ResourceFilePath);
    public virtual void AddWin32ResourceFile(Stream win32ResourceStream);
    public virtual void AddWin32Icon(string win32IconFilePath);
    public virtual void AddWin32Icon(Stream win32IconStream);
    public void AddWin32VersionInfo(CompilerOptions options);
    public virtual AttributeNode GetAttribute(TypeNode attributeType);
    public virtual AttributeList GetAttributes(TypeNode attributeType);
    public virtual AttributeList GetAttributes(TypeNode attributeType, int maxCount);
    public TrivialHashtable GetMemberDocumentationCache();
    public NamespaceList GetNamespaceList();
    private NamespaceList GetNamespaceListFromReader();
    private void GetTypesForNamespace(Namespace nspace, object handle);
    public bool IsValidNamespace(Identifier nsName);
    public bool IsValidTypeName(Identifier nsName, Identifier typeName);
    public Module GetNestedModule(string moduleName);
    internal TrivialHashtableUsingWeakReferences get_StructurallyEquivalentType();
    public virtual TypeNode GetStructurallyEquivalentType(Identifier ns, Identifier id);
    public virtual TypeNode TryGetTemplateInstance(Identifier uniqueMangledName);
    public virtual TypeNode GetStructurallyEquivalentType(Identifier ns, Identifier id, Identifier uniqueMangledName, bool lookInReferencedAssemblies);
    public virtual TypeNode GetType(Identifier namespace, Identifier name, bool lookInReferencedAssemblies);
    protected virtual TypeNode GetType(Identifier namespace, Identifier name, bool lookInReferencedAssemblies, TrivialHashtable assembliesAlreadyVisited);
    public virtual TypeNode GetType(Identifier namespace, Identifier name);
    public virtual TypeNodeList get_Types();
    public virtual void set_Types(TypeNodeList value);
    public virtual bool HasReferenceTo(Module module);
    internal void InitializeAssemblyReferenceResolution(Module referringModule);
    public static Module GetModule(Byte[] buffer);
    public static Module GetModule(Byte[] buffer, IDictionary cache);
    public static Module GetModule(Byte[] buffer, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static Module GetModule(Byte[] buffer, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public static Module GetModule(string location);
    public static Module GetModule(string location, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static Module GetModule(string location, IDictionary cache);
    public static Module GetModule(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache);
    public static Module GetModule(string location, IDictionary cache, bool doNotLockFile, bool getDebugInfo, bool useGlobalCache, bool preserveShortBranches);
    public virtual AssemblyNode Resolve(AssemblyReference assemblyReference);
    public virtual AssemblyNode ResolveAfterProbingFailed(AssemblyReference assemblyReference);
    public virtual void WriteModule(string location, bool writeDebugSymbols);
    public virtual void WriteModule(Stream executable, Stream debugSymbols);
    public virtual void WriteModule(Byte[]& executable);
    public virtual void WriteModule(Byte[]& executable, Byte[]& debugSymbols);
    public virtual void WriteModule(string location, CompilerParameters options);
    public virtual void WriteDocumentation(TextWriter doc);
    public MethodBodySpecializer GetMethodBodySpecializer(TypeNodeList pars, TypeNodeList args);
}
public enum System.Compiler.ModuleKindFlags : Enum {
    public int value__;
    public static ModuleKindFlags ConsoleApplication;
    public static ModuleKindFlags WindowsApplication;
    public static ModuleKindFlags DynamicallyLinkedLibrary;
    public static ModuleKindFlags ManifestResourceFile;
    public static ModuleKindFlags UnmanagedDynamicallyLinkedLibrary;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ModuleList : object {
    private Module[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Module Item { get; public set; }
    public ModuleList(int capacity);
    public void Add(Module element);
    public int get_Count();
    public int get_Length();
    public Module get_Item(int index);
    public void set_Item(int index, Module value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.ModuleReference : Node {
    private Module module;
    private string name;
    public Module Module { get; public set; }
    public string Name { get; public set; }
    public ModuleReference(string name, Module module);
    public Module get_Module();
    public void set_Module(Module value);
    public string get_Name();
    public void set_Name(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ModuleReferenceList : object {
    private ModuleReference[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public ModuleReference Item { get; public set; }
    public ModuleReferenceList(int capacity);
    public ModuleReferenceList(ModuleReference[] elements);
    public void Add(ModuleReference element);
    public ModuleReferenceList Clone();
    public int get_Count();
    public int get_Length();
    public ModuleReference get_Item(int index);
    public void set_Item(int index, ModuleReference value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.NamedArgument : Expression {
    private bool isCustomAttributeProperty;
    private Identifier name;
    private Expression value;
    private bool valueIsBoxed;
    public bool IsCustomAttributeProperty { get; public set; }
    public Identifier Name { get; public set; }
    public Expression Value { get; public set; }
    public bool ValueIsBoxed { get; public set; }
    public NamedArgument(Identifier name, Expression value);
    public NamedArgument(Identifier name, Expression value, SourceContext ctx);
    public bool get_IsCustomAttributeProperty();
    public void set_IsCustomAttributeProperty(bool value);
    public Identifier get_Name();
    public void set_Name(Identifier value);
    public Expression get_Value();
    public void set_Value(Expression value);
    public bool get_ValueIsBoxed();
    public void set_ValueIsBoxed(bool value);
}
public class System.Compiler.Namespace : Member {
    public Identifier FullNameId;
    public TypeProvider ProvideTypes;
    public object ProviderHandle;
    protected string fullName;
    protected TypeNodeList types;
    protected internal bool isPublic;
    public string FullName { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public TypeNodeList Types { get; public set; }
    public Namespace(Identifier name);
    public virtual string get_FullName();
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPublic();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVisibleOutsideAssembly();
    public TypeNodeList get_Types();
    public void set_Types(TypeNodeList value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.NamespaceList : object {
    private Namespace[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Namespace Item { get; public set; }
    public NamespaceList(int capacity);
    public void Add(Namespace element);
    public NamespaceList Clone();
    public int get_Count();
    public int get_Length();
    public Namespace get_Item(int index);
    public void set_Item(int index, Namespace value);
    public Enumerator GetEnumerator();
}
public abstract class System.Compiler.NaryExpression : Expression {
    public ExpressionList Operands;
    protected NaryExpression(ExpressionList operands, NodeType nodeType);
}
public enum System.Compiler.NativeType : Enum {
    public int value__;
    public static NativeType Bool;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType Currency;
    public static NativeType BStr;
    public static NativeType LPStr;
    public static NativeType LPWStr;
    public static NativeType LPTStr;
    public static NativeType ByValTStr;
    public static NativeType IUnknown;
    public static NativeType IDispatch;
    public static NativeType Struct;
    public static NativeType Interface;
    public static NativeType SafeArray;
    public static NativeType ByValArray;
    public static NativeType SysInt;
    public static NativeType SysUInt;
    public static NativeType VBByRefStr;
    public static NativeType AnsiBStr;
    public static NativeType TBStr;
    public static NativeType VariantBool;
    public static NativeType FunctionPtr;
    public static NativeType AsAny;
    public static NativeType LPArray;
    public static NativeType LPStruct;
    public static NativeType CustomMarshaler;
    public static NativeType Error;
    public static NativeType NotSpecified;
}
public abstract class System.Compiler.Node : object {
    public bool IsErroneous;
    public SourceContext SourceContext;
    private NodeType nodeType;
    private static int uniqueKeyCounter;
    private int uniqueKey;
    private static Hashtable VisitorTypeFor;
    public NodeType NodeType { get; public set; }
    public int UniqueKey { get; }
    private int System.Compiler.IUniqueKey.UniqueId { get; }
    protected Node(NodeType nodeType);
    public NodeType get_NodeType();
    public void set_NodeType(NodeType value);
    public virtual int get_UniqueKey();
    public virtual Node Clone();
    public virtual object GetVisitorFor(object callingVisitor, string visitorClassName);
    private static object GetVisitorFor(Type nodeType, object callingVisitor, string visitorClassName);
    private sealed virtual override int System.Compiler.IUniqueKey.get_UniqueId();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.NodeList : object {
    private Node[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Node Item { get; public set; }
    public NodeList(int capacity);
    public NodeList(Node[] elements);
    public void Add(Node element);
    public NodeList Clone();
    public int get_Count();
    public int get_Length();
    public Node get_Item(int index);
    public void set_Item(int index, Node value);
    public Enumerator GetEnumerator();
}
public enum System.Compiler.NodeType : Enum {
    public int value__;
    public static NodeType Undefined;
    public static NodeType Add;
    public static NodeType Add_Ovf;
    public static NodeType Add_Ovf_Un;
    public static NodeType And;
    public static NodeType Arglist;
    public static NodeType Box;
    public static NodeType Branch;
    public static NodeType Call;
    public static NodeType Calli;
    public static NodeType Callvirt;
    public static NodeType Castclass;
    public static NodeType Ceq;
    public static NodeType Cgt;
    public static NodeType Cgt_Un;
    public static NodeType Ckfinite;
    public static NodeType Clt;
    public static NodeType Clt_Un;
    public static NodeType Conv_I;
    public static NodeType Conv_I1;
    public static NodeType Conv_I2;
    public static NodeType Conv_I4;
    public static NodeType Conv_I8;
    public static NodeType Conv_Ovf_I;
    public static NodeType Conv_Ovf_I_Un;
    public static NodeType Conv_Ovf_I1;
    public static NodeType Conv_Ovf_I1_Un;
    public static NodeType Conv_Ovf_I2;
    public static NodeType Conv_Ovf_I2_Un;
    public static NodeType Conv_Ovf_I4;
    public static NodeType Conv_Ovf_I4_Un;
    public static NodeType Conv_Ovf_I8;
    public static NodeType Conv_Ovf_I8_Un;
    public static NodeType Conv_Ovf_U;
    public static NodeType Conv_Ovf_U_Un;
    public static NodeType Conv_Ovf_U1;
    public static NodeType Conv_Ovf_U1_Un;
    public static NodeType Conv_Ovf_U2;
    public static NodeType Conv_Ovf_U2_Un;
    public static NodeType Conv_Ovf_U4;
    public static NodeType Conv_Ovf_U4_Un;
    public static NodeType Conv_Ovf_U8;
    public static NodeType Conv_Ovf_U8_Un;
    public static NodeType Conv_R_Un;
    public static NodeType Conv_R4;
    public static NodeType Conv_R8;
    public static NodeType Conv_U;
    public static NodeType Conv_U1;
    public static NodeType Conv_U2;
    public static NodeType Conv_U4;
    public static NodeType Conv_U8;
    public static NodeType Cpblk;
    public static NodeType DebugBreak;
    public static NodeType Div;
    public static NodeType Div_Un;
    public static NodeType Dup;
    public static NodeType EndFilter;
    public static NodeType EndFinally;
    public static NodeType ExceptionHandler;
    public static NodeType Initblk;
    public static NodeType Isinst;
    public static NodeType Jmp;
    public static NodeType Ldftn;
    public static NodeType Ldlen;
    public static NodeType Ldtoken;
    public static NodeType Ldvirtftn;
    public static NodeType Localloc;
    public static NodeType Mkrefany;
    public static NodeType Mul;
    public static NodeType Mul_Ovf;
    public static NodeType Mul_Ovf_Un;
    public static NodeType Neg;
    public static NodeType Nop;
    public static NodeType Not;
    public static NodeType Or;
    public static NodeType Pop;
    public static NodeType ReadOnlyAddressOf;
    public static NodeType Refanytype;
    public static NodeType Refanyval;
    public static NodeType Rem;
    public static NodeType Rem_Un;
    public static NodeType Rethrow;
    public static NodeType Shl;
    public static NodeType Shr;
    public static NodeType Shr_Un;
    public static NodeType Sizeof;
    public static NodeType SkipCheck;
    public static NodeType Sub;
    public static NodeType Sub_Ovf;
    public static NodeType Sub_Ovf_Un;
    public static NodeType SwitchInstruction;
    public static NodeType Throw;
    public static NodeType Unbox;
    public static NodeType UnboxAny;
    public static NodeType Xor;
    public static NodeType AddressDereference;
    public static NodeType AddressOf;
    public static NodeType AssignmentStatement;
    public static NodeType Block;
    public static NodeType Catch;
    public static NodeType Construct;
    public static NodeType ConstructArray;
    public static NodeType Eq;
    public static NodeType ExpressionStatement;
    public static NodeType FaultHandler;
    public static NodeType Filter;
    public static NodeType Finally;
    public static NodeType Ge;
    public static NodeType Gt;
    public static NodeType Identifier;
    public static NodeType Indexer;
    public static NodeType Instruction;
    public static NodeType InterfaceExpression;
    public static NodeType Le;
    public static NodeType Literal;
    public static NodeType LogicalNot;
    public static NodeType Lt;
    public static NodeType MemberBinding;
    public static NodeType NamedArgument;
    public static NodeType Namespace;
    public static NodeType Ne;
    public static NodeType Return;
    public static NodeType This;
    public static NodeType Try;
    public static NodeType ArrayType;
    public static NodeType Assembly;
    public static NodeType AssemblyReference;
    public static NodeType Attribute;
    public static NodeType Class;
    public static NodeType ClassParameter;
    public static NodeType DelegateNode;
    public static NodeType EnumNode;
    public static NodeType Event;
    public static NodeType Field;
    public static NodeType FunctionPointer;
    public static NodeType InstanceInitializer;
    public static NodeType Interface;
    public static NodeType Local;
    public static NodeType Method;
    public static NodeType Module;
    public static NodeType ModuleReference;
    public static NodeType OptionalModifier;
    public static NodeType Parameter;
    public static NodeType Pointer;
    public static NodeType Property;
    public static NodeType Reference;
    public static NodeType RequiredModifier;
    public static NodeType SecurityAttribute;
    public static NodeType StaticInitializer;
    public static NodeType Struct;
    public static NodeType TypeParameter;
    public static NodeType Array;
    public static NodeType BlockReference;
    public static NodeType CompilationParameters;
    public static NodeType Document;
    public static NodeType EndOfRecord;
    public static NodeType Expression;
    public static NodeType Guid;
    public static NodeType List;
    public static NodeType MarshallingInformation;
    public static NodeType Member;
    public static NodeType MemberReference;
    public static NodeType MissingBlockReference;
    public static NodeType MissingExpression;
    public static NodeType MissingMemberReference;
    public static NodeType String;
    public static NodeType StringDictionary;
    public static NodeType TypeNode;
    public static NodeType Uri;
    public static NodeType XmlNode;
    public static NodeType AddEventHandler;
    public static NodeType AliasDefinition;
    public static NodeType AnonymousNestedFunction;
    public static NodeType ApplyToAll;
    public static NodeType ArglistArgumentExpression;
    public static NodeType ArglistExpression;
    public static NodeType ArrayTypeExpression;
    public static NodeType As;
    public static NodeType Assertion;
    public static NodeType AssignmentExpression;
    public static NodeType Assumption;
    public static NodeType Base;
    public static NodeType BlockExpression;
    public static NodeType BoxedTypeExpression;
    public static NodeType ClassExpression;
    public static NodeType CoerceTuple;
    public static NodeType CollectionEnumerator;
    public static NodeType Comma;
    public static NodeType Compilation;
    public static NodeType CompilationUnit;
    public static NodeType CompilationUnitSnippet;
    public static NodeType Conditional;
    public static NodeType ConstructDelegate;
    public static NodeType ConstructFlexArray;
    public static NodeType ConstructIterator;
    public static NodeType ConstructTuple;
    public static NodeType Continue;
    public static NodeType CopyReference;
    public static NodeType CurrentClosure;
    public static NodeType Decrement;
    public static NodeType DefaultValue;
    public static NodeType DoWhile;
    public static NodeType Exit;
    public static NodeType ExplicitCoercion;
    public static NodeType ExpressionSnippet;
    public static NodeType FieldInitializerBlock;
    public static NodeType Fixed;
    public static NodeType FlexArrayTypeExpression;
    public static NodeType For;
    public static NodeType ForEach;
    public static NodeType FunctionDeclaration;
    public static NodeType FunctionTypeExpression;
    public static NodeType Goto;
    public static NodeType GotoCase;
    public static NodeType If;
    public static NodeType ImplicitThis;
    public static NodeType Increment;
    public static NodeType InvariantTypeExpression;
    public static NodeType Is;
    public static NodeType LabeledStatement;
    public static NodeType LocalDeclaration;
    public static NodeType LocalDeclarationsStatement;
    public static NodeType Lock;
    public static NodeType LogicalAnd;
    public static NodeType LogicalOr;
    public static NodeType LRExpression;
    public static NodeType MethodCall;
    public static NodeType NameBinding;
    public static NodeType NonEmptyStreamTypeExpression;
    public static NodeType NonNullableTypeExpression;
    public static NodeType NonNullTypeExpression;
    public static NodeType NullableTypeExpression;
    public static NodeType NullCoalesingExpression;
    public static NodeType OutAddress;
    public static NodeType Parentheses;
    public static NodeType PointerTypeExpression;
    public static NodeType PostfixExpression;
    public static NodeType PrefixExpression;
    public static NodeType QualifiedIdentifer;
    public static NodeType RefAddress;
    public static NodeType ReferenceTypeExpression;
    public static NodeType RefTypeExpression;
    public static NodeType RefValueExpression;
    public static NodeType RemoveEventHandler;
    public static NodeType Repeat;
    public static NodeType ResourceUse;
    public static NodeType SetterValue;
    public static NodeType StackAlloc;
    public static NodeType StatementSnippet;
    public static NodeType StreamTypeExpression;
    public static NodeType Switch;
    public static NodeType SwitchCase;
    public static NodeType SwitchCaseBottom;
    public static NodeType TemplateInstance;
    public static NodeType TupleTypeExpression;
    public static NodeType TypeExpression;
    public static NodeType TypeIntersectionExpression;
    public static NodeType TypeMemberSnippet;
    public static NodeType Typeof;
    public static NodeType TypeReference;
    public static NodeType Typeswitch;
    public static NodeType TypeswitchCase;
    public static NodeType TypeUnionExpression;
    public static NodeType UnaryPlus;
    public static NodeType UsedNamespace;
    public static NodeType VariableDeclaration;
    public static NodeType While;
    public static NodeType Yield;
    public static NodeType ConstrainedType;
    public static NodeType TupleType;
    public static NodeType TypeAlias;
    public static NodeType TypeIntersection;
    public static NodeType TypeUnion;
    public static NodeType Composition;
    public static NodeType QueryAggregate;
    public static NodeType QueryAlias;
    public static NodeType QueryAll;
    public static NodeType QueryAny;
    public static NodeType QueryAxis;
    public static NodeType QueryCommit;
    public static NodeType QueryContext;
    public static NodeType QueryDelete;
    public static NodeType QueryDifference;
    public static NodeType QueryDistinct;
    public static NodeType QueryExists;
    public static NodeType QueryFilter;
    public static NodeType QueryGeneratedType;
    public static NodeType QueryGroupBy;
    public static NodeType QueryInsert;
    public static NodeType QueryIntersection;
    public static NodeType QueryIterator;
    public static NodeType QueryJoin;
    public static NodeType QueryLimit;
    public static NodeType QueryOrderBy;
    public static NodeType QueryOrderItem;
    public static NodeType QueryPosition;
    public static NodeType QueryProject;
    public static NodeType QueryQuantifiedExpression;
    public static NodeType QueryRollback;
    public static NodeType QuerySelect;
    public static NodeType QuerySingleton;
    public static NodeType QueryTransact;
    public static NodeType QueryTypeFilter;
    public static NodeType QueryUnion;
    public static NodeType QueryUpdate;
    public static NodeType QueryYielder;
    public static NodeType Acquire;
    public static NodeType Comprehension;
    public static NodeType ComprehensionBinding;
    public static NodeType Ensures;
    public static NodeType EnsuresExceptional;
    public static NodeType EnsuresNormal;
    public static NodeType Iff;
    public static NodeType Implies;
    public static NodeType Invariant;
    public static NodeType LogicalEqual;
    public static NodeType LogicalImply;
    public static NodeType Maplet;
    public static NodeType MethodContract;
    public static NodeType Modelfield;
    public static NodeType ModelfieldContract;
    public static NodeType OldExpression;
    public static NodeType Range;
    public static NodeType Read;
    public static NodeType Requires;
    public static NodeType RequiresOtherwise;
    public static NodeType RequiresPlain;
    public static NodeType RequiresValidation;
    public static NodeType ReturnValue;
    public static NodeType TypeContract;
    public static NodeType Write;
    public static NodeType OptionalModifierTypeExpression;
    public static NodeType RequiredModifierTypeExpression;
    public static NodeType Count;
    public static NodeType Exists;
    public static NodeType ExistsUnique;
    public static NodeType Forall;
    public static NodeType Max;
    public static NodeType Min;
    public static NodeType Product;
    public static NodeType Sum;
    public static NodeType Quantifier;
}
public class System.Compiler.NonEmptyStreamTypeExpression : TypeNode {
    public TypeNode ElementType;
    public NonEmptyStreamTypeExpression(TypeNode elementType);
    public NonEmptyStreamTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.NonNullableTypeExpression : TypeNode {
    public TypeNode ElementType;
    public NonNullableTypeExpression(TypeNode elementType);
    public NonNullableTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.NonNullTypeExpression : TypeNode {
    public TypeNode ElementType;
    public NonNullTypeExpression(TypeNode elementType);
    public NonNullTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.NullableTypeExpression : TypeNode {
    public TypeNode ElementType;
    public NullableTypeExpression(TypeNode elementType);
    public NullableTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.OldExpression : Expression {
    public Expression expression;
    private int copyLevel;
    public int ShallowCopyUptoDimension { get; public set; }
    public OldExpression(Expression expression);
    public int get_ShallowCopyUptoDimension();
    public void set_ShallowCopyUptoDimension(int value);
}
public enum System.Compiler.OpCode : Enum {
    public int value__;
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode PrefixRef;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned_;
    public static OpCode Volatile_;
    public static OpCode Tail_;
    public static OpCode Initobj;
    public static OpCode Constrained_;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly_;
    [CLSCompliantAttribute("False")]
public static OpCode _Locals;
    [CLSCompliantAttribute("False")]
public static OpCode _Try;
    [CLSCompliantAttribute("False")]
public static OpCode _EndTry;
    [CLSCompliantAttribute("False")]
public static OpCode _Filter;
    [CLSCompliantAttribute("False")]
public static OpCode _EndFilter;
    [CLSCompliantAttribute("False")]
public static OpCode _Catch;
    [CLSCompliantAttribute("False")]
public static OpCode _Finally;
    [CLSCompliantAttribute("False")]
public static OpCode _Fault;
    [CLSCompliantAttribute("False")]
public static OpCode _EndHandler;
}
public class System.Compiler.OptionalModifier : TypeModifier {
    internal OptionalModifier(TypeNode modifier, TypeNode modified);
    public static OptionalModifier For(TypeNode modifier, TypeNode modified);
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
}
public class System.Compiler.OptionalModifierTypeExpression : TypeNode {
    public TypeNode ModifiedType;
    public TypeNode Modifier;
    public bool IsUnmanaged { get; }
    public OptionalModifierTypeExpression(TypeNode elementType, TypeNode modifier);
    public OptionalModifierTypeExpression(TypeNode elementType, TypeNode modifier, SourceContext sctx);
    public virtual bool get_IsUnmanaged();
}
public class System.Compiler.Parameter : Variable {
    private AttributeList attributes;
    private Expression defaultValue;
    private ParameterFlags flags;
    private MarshallingInformation marshallingInformation;
    private Method declaringMethod;
    private int parameterListIndex;
    private int argumentListIndex;
    protected internal TypeNode paramArrayElementType;
    protected AttributeNode paramArrayAttribute;
    public AttributeList Attributes { get; public set; }
    public Expression DefaultValue { get; public set; }
    public ParameterFlags Flags { get; public set; }
    public MarshallingInformation MarshallingInformation { get; public set; }
    public Method DeclaringMethod { get; public set; }
    public int ParameterListIndex { get; public set; }
    public int ArgumentListIndex { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsOptional { get; public set; }
    public bool IsOut { get; public set; }
    public Parameter(Identifier name, TypeNode type);
    public Parameter(AttributeList attributes, ParameterFlags flags, Identifier name, TypeNode type, Literal defaultValue, MarshallingInformation marshallingInformation);
    public AttributeList get_Attributes();
    public void set_Attributes(AttributeList value);
    public Expression get_DefaultValue();
    public void set_DefaultValue(Expression value);
    public ParameterFlags get_Flags();
    public void set_Flags(ParameterFlags value);
    public MarshallingInformation get_MarshallingInformation();
    public void set_MarshallingInformation(MarshallingInformation value);
    public Method get_DeclaringMethod();
    public void set_DeclaringMethod(Method value);
    public int get_ParameterListIndex();
    public void set_ParameterListIndex(int value);
    public int get_ArgumentListIndex();
    public void set_ArgumentListIndex(int value);
    public virtual bool get_IsIn();
    public virtual void set_IsIn(bool value);
    public virtual bool get_IsOptional();
    public virtual void set_IsOptional(bool value);
    public virtual bool get_IsOut();
    public virtual void set_IsOut(bool value);
    public virtual TypeNode GetParamArrayElementType();
    public virtual AttributeNode GetParamArrayAttribute();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual AttributeNode GetAttribute(TypeNode attributeType);
    public virtual string ToString();
}
public class System.Compiler.ParameterBinding : Parameter {
    public Parameter BoundParameter;
    private int System.Compiler.IUniqueKey.UniqueId { get; }
    public ParameterBinding(Parameter boundParameter, SourceContext sctx);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private sealed virtual override int System.Compiler.IUniqueKey.get_UniqueId();
}
public class System.Compiler.ParameterField : Field {
    protected Parameter parameter;
    public Parameter Parameter { get; public set; }
    public ParameterField(TypeNode declaringType, AttributeList attributes, FieldFlags flags, Identifier name, TypeNode Type, Literal defaultValue);
    public virtual Parameter get_Parameter();
    public virtual void set_Parameter(Parameter value);
}
[FlagsAttribute]
public enum System.Compiler.ParameterFlags : Enum {
    public int value__;
    public static ParameterFlags None;
    public static ParameterFlags In;
    public static ParameterFlags Out;
    public static ParameterFlags Optional;
    public static ParameterFlags ReservedMask;
    public static ParameterFlags HasDefault;
    public static ParameterFlags HasFieldMarshal;
    public static ParameterFlags ParameterNameMissing;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ParameterList : object {
    public static ParameterList Empty;
    private Parameter[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Parameter Item { get; public set; }
    public ParameterList(int capacity);
    public ParameterList(Parameter[] elements);
    private static ParameterList();
    public void Add(Parameter element);
    public ParameterList Clone();
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Parameter get_Item(int index);
    public void set_Item(int index, Parameter value);
    public Enumerator GetEnumerator();
    public virtual string ToString();
}
internal class System.Compiler.PdbInfo : object {
    private Reader reader;
    private string sourceServerData;
    private Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping;
    private Dictionary`2<UInt32, PdbFunction> pdbFunctionMap;
    public PdbInfo(FileStream inputStream, Reader reader);
    public PdbFunction GetMethodInfo(UInt32 token);
}
[FlagsAttribute]
public enum System.Compiler.PEKindFlags : Enum {
    public int value__;
    public static PEKindFlags ILonly;
    public static PEKindFlags Requires32bits;
    public static PEKindFlags Requires64bits;
    public static PEKindFlags AMD;
    public static PEKindFlags Prefers32bits;
}
public enum System.Compiler.PESection : Enum {
    public int value__;
    public static PESection Text;
    public static PESection SData;
    public static PESection TLS;
}
[FlagsAttribute]
public enum System.Compiler.PInvokeFlags : Enum {
    public int value__;
    public static PInvokeFlags None;
    public static PInvokeFlags NoMangle;
    public static PInvokeFlags BestFitDisabled;
    public static PInvokeFlags BestFitEnabled;
    public static PInvokeFlags BestFitUseAsm;
    public static PInvokeFlags BestFitMask;
    public static PInvokeFlags CharSetMask;
    public static PInvokeFlags CharSetNotSpec;
    public static PInvokeFlags CharSetAns;
    public static PInvokeFlags CharSetUnicode;
    public static PInvokeFlags CharSetAuto;
    public static PInvokeFlags SupportsLastError;
    public static PInvokeFlags CallingConvMask;
    public static PInvokeFlags CallConvWinapi;
    public static PInvokeFlags CallConvCdecl;
    public static PInvokeFlags CallConvStdcall;
    public static PInvokeFlags CallConvThiscall;
    public static PInvokeFlags CallConvFastcall;
    public static PInvokeFlags ThrowOnUnmappableCharMask;
    public static PInvokeFlags ThrowOnUnmappableCharEnabled;
    public static PInvokeFlags ThrowOnUnmappableCharDisabled;
    public static PInvokeFlags ThrowOnUnmappableCharUseAsm;
}
internal static class System.Compiler.PlatformHelpers : object {
    internal static bool TryParseInt32(string s, Int32& result);
    internal static int StringCompareOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int length);
    internal static int StringCompareOrdinalIgnoreCase(string strA, string strB);
}
public enum System.Compiler.PlatformType : Enum {
    public int value__;
    public static PlatformType notSpecified;
    public static PlatformType v1;
    public static PlatformType v11;
    public static PlatformType v2;
    public static PlatformType cli1;
}
public class System.Compiler.Pointer : TypeNode {
    private TypeNode elementType;
    protected TypeNodeList structuralElementTypes;
    public TypeNode ElementType { get; public set; }
    public string FullName { get; }
    public bool IsUnmanaged { get; }
    public bool IsStructural { get; }
    public bool IsPointerType { get; }
    public TypeNodeList StructuralElementTypes { get; }
    internal Pointer(TypeNode elementType);
    public TypeNode get_ElementType();
    public void set_ElementType(TypeNode value);
    public virtual string get_FullName();
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    public virtual Type GetRuntimeType();
    public virtual bool IsAssignableTo(TypeNode targetType, Func`2<TypeNode, TypeNode> targetTypeSubstitution);
    public virtual bool get_IsUnmanaged();
    public virtual bool get_IsStructural();
    public virtual bool get_IsPointerType();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.PointerTypeExpression : Pointer {
    public bool IsUnmanaged { get; }
    public PointerTypeExpression(TypeNode elementType);
    public PointerTypeExpression(TypeNode elementType, SourceContext sctx);
    public virtual bool get_IsUnmanaged();
}
public class System.Compiler.PostfixExpression : Expression {
    public Expression Expression;
    public NodeType Operator;
    public Method OperatorOverload;
    public PostfixExpression(Expression expression, NodeType Operator, SourceContext sourceContext);
}
public class System.Compiler.PrefixExpression : Expression {
    public Expression Expression;
    public NodeType Operator;
    public Method OperatorOverload;
    public PrefixExpression(Expression expression, NodeType Operator, SourceContext sourceContext);
}
public enum System.Compiler.ProcessorType : Enum {
    public int value__;
    public static ProcessorType Any;
    public static ProcessorType x86;
    public static ProcessorType x64;
    public static ProcessorType Itanium;
}
public class System.Compiler.Property : Member {
    public TypeNodeList ImplementedTypes;
    public TypeNodeList ImplementedTypeExpressions;
    public bool IsModelfield;
    private PropertyFlags flags;
    private Method getter;
    private Method setter;
    private MethodList otherMethods;
    protected string fullName;
    protected PropertyInfo propertyInfo;
    public static Property NotSpecified;
    protected Property hiddenProperty;
    protected Property overriddenProperty;
    private ParameterList parameters;
    protected TypeNode type;
    public TypeNode TypeExpression;
    public PropertyFlags Flags { get; public set; }
    public Method Getter { get; public set; }
    public Method Setter { get; public set; }
    public MethodList OtherMethods { get; public set; }
    public string FullName { get; }
    public string HelpText { get; public set; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public Member HiddenMember { get; public set; }
    public Property HiddenProperty { get; public set; }
    public Member OverriddenMember { get; public set; }
    public Property OverriddenProperty { get; public set; }
    public ParameterList Parameters { get; public set; }
    public TypeNode Type { get; public set; }
    public Property(TypeNode declaringType, AttributeList attributes, PropertyFlags flags, Identifier name, Method getter, Method setter);
    private static Property();
    public PropertyFlags get_Flags();
    public void set_Flags(PropertyFlags value);
    public Method get_Getter();
    public void set_Getter(Method value);
    public Method get_Setter();
    public void set_Setter(Method value);
    public MethodList get_OtherMethods();
    public void set_OtherMethods(MethodList value);
    public virtual string get_FullName();
    public virtual Method GetBaseGetter();
    public virtual Method GetBaseSetter();
    protected virtual Identifier GetDocumentationId();
    public static Property GetProperty(PropertyInfo propertyInfo);
    public virtual PropertyInfo GetPropertyInfo();
    public virtual object GetValue(object targetObject, Object[] indices);
    public virtual Literal GetValue(Literal targetObject, Literal[] indices);
    public virtual void SetValue(object targetObject, object value, Object[] indices);
    public virtual void SetValue(Literal targetObject, Literal value, Literal[] indices);
    public virtual string get_HelpText();
    public virtual void set_HelpText(string value);
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public bool get_IsFinal();
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPublic();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public bool get_IsVirtual();
    public virtual bool get_IsVisibleOutsideAssembly();
    public virtual Member get_HiddenMember();
    public virtual void set_HiddenMember(Member value);
    public virtual Property get_HiddenProperty();
    public virtual void set_HiddenProperty(Property value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual Property get_OverriddenProperty();
    public virtual void set_OverriddenProperty(Property value);
    public ParameterList get_Parameters();
    public void set_Parameters(ParameterList value);
    public virtual bool ParametersMatch(ParameterList parameters);
    public virtual bool ParametersMatchStructurally(ParameterList parameters);
    public virtual bool ParameterTypesMatch(TypeNodeList argumentTypes);
    public virtual TypeNode get_Type();
    public virtual void set_Type(TypeNode value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Compiler.PropertyFlags : Enum {
    public int value__;
    public static PropertyFlags None;
    public static PropertyFlags SpecialName;
    public static PropertyFlags ReservedMask;
    public static PropertyFlags RTSpecialName;
    public static PropertyFlags Extend;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.PropertyList : object {
    private Property[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Property Item { get; public set; }
    public PropertyList(int capacity);
    public void Add(Property element);
    public int get_Count();
    public int get_Length();
    public Property get_Item(int index);
    public void set_Item(int index, Property value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.ProxyMethod : Method {
    public Method ProxyFor;
    public ProxyMethod(TypeNode declaringType, AttributeList attributes, Identifier name, ParameterList parameters, TypeNode returnType, Block body);
}
public class System.Compiler.Reference : TypeNode {
    private TypeNode elementType;
    protected TypeNodeList structuralElementTypes;
    public TypeNode ElementType { get; public set; }
    public string FullName { get; }
    public bool IsStructural { get; }
    public TypeNodeList StructuralElementTypes { get; }
    internal Reference(TypeNode elementType);
    public TypeNode get_ElementType();
    public void set_ElementType(TypeNode value);
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    public virtual bool IsAssignableTo(TypeNode targetType, Func`2<TypeNode, TypeNode> targetTypeSubstitution);
    public virtual string get_FullName();
    public virtual Type GetRuntimeType();
    public virtual bool get_IsStructural();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
}
public class System.Compiler.ReferenceTypeExpression : Reference {
    public ReferenceTypeExpression(TypeNode elementType);
    public ReferenceTypeExpression(TypeNode elementType, SourceContext sctx);
}
public class System.Compiler.RefTypeExpression : UnaryExpression {
    public RefTypeExpression(Expression typedreference, SourceContext sctx);
}
public class System.Compiler.RefValueExpression : BinaryExpression {
    public RefValueExpression(Expression typedreference, Expression type, SourceContext sctx);
}
public class System.Compiler.RequiredModifier : TypeModifier {
    internal RequiredModifier(TypeNode modifier, TypeNode modified);
    public static RequiredModifier For(TypeNode modifier, TypeNode modified);
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
}
public class System.Compiler.RequiredModifierTypeExpression : TypeNode {
    public TypeNode ModifiedType;
    public TypeNode Modifier;
    public bool IsUnmanaged { get; }
    public RequiredModifierTypeExpression(TypeNode elementType, TypeNode modifier);
    public RequiredModifierTypeExpression(TypeNode elementType, TypeNode modifier, SourceContext sctx);
    public virtual bool get_IsUnmanaged();
}
public abstract class System.Compiler.Requires : MethodContractElement {
    public Expression Condition;
    public Expression Assertion { get; }
    protected Requires(NodeType nodeType);
    protected Requires(NodeType nodeType, Expression expression);
    public virtual Expression get_Assertion();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.RequiresList : object {
    private Requires[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Requires Item { get; public set; }
    public RequiresList(int capacity);
    public void Add(Requires element);
    public RequiresList Clone();
    public int get_Count();
    public int get_Length();
    public Requires get_Item(int index);
    public void set_Item(int index, Requires value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.RequiresOtherwise : Requires {
    public Expression ThrowException;
    public RequiresOtherwise(Expression cond, Expression exc);
}
public class System.Compiler.RequiresPlain : Requires {
    public TypeNode ExceptionType;
    public bool IsFromValidation;
    public bool IsWithException { get; }
    public RequiresPlain(Expression expression);
    public RequiresPlain(Expression expression, TypeNode texception);
    public virtual bool get_IsWithException();
}
public class System.Compiler.Resource : ValueType {
    private bool isPublic;
    private string name;
    private Module definingModule;
    private Byte[] data;
    public bool IsPublic { get; public set; }
    public string Name { get; public set; }
    public Module DefiningModule { get; public set; }
    public Byte[] Data { get; public set; }
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public string get_Name();
    public void set_Name(string value);
    public Module get_DefiningModule();
    public void set_DefiningModule(Module value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.ResourceList : object {
    private Resource[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Resource Item { get; public set; }
    public ResourceList(int capacity);
    public void Add(Resource element);
    public ResourceList Clone();
    public int get_Count();
    public int get_Length();
    public Resource get_Item(int index);
    public void set_Item(int index, Resource value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.Return : ExpressionStatement {
    public Return(Expression expression);
    public Return(SourceContext sctx);
    public Return(Expression expression, SourceContext sctx);
}
public class System.Compiler.ReturnValue : Expression {
    public ReturnValue(SourceContext sc);
    public ReturnValue(TypeNode returnType, SourceContext sc);
    public ReturnValue(TypeNode returnType);
}
public class System.Compiler.SecurityAttribute : Node {
    private SecurityAction action;
    private AttributeList permissionAttributes;
    protected string serializedPermissions;
    protected PermissionSet permissions;
    public SecurityAction Action { get; public set; }
    public AttributeList PermissionAttributes { get; public set; }
    public string SerializedPermissions { get; public set; }
    public PermissionSet Permissions { get; public set; }
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public AttributeList get_PermissionAttributes();
    public void set_PermissionAttributes(AttributeList value);
    public string get_SerializedPermissions();
    public void set_SerializedPermissions(string value);
    public PermissionSet get_Permissions();
    public void set_Permissions(PermissionSet value);
    protected SecurityElement GetSecurityElement();
    protected PermissionSet InstantiatePermissionAttributes();
    protected object GetPermissionOrSetOfPermissionsFromAttribute(AttributeNode attr);
    private IPermission CreatePermission(SecurityAttribute secAttr);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.SecurityAttributeList : object {
    private SecurityAttribute[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public SecurityAttribute Item { get; public set; }
    public SecurityAttributeList(int capacity);
    public void Add(SecurityAttribute element);
    public SecurityAttributeList Clone();
    public int get_Count();
    public int get_Length();
    public SecurityAttribute get_Item(int index);
    public void set_Item(int index, SecurityAttribute value);
    public Enumerator GetEnumerator();
}
public enum System.Compiler.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public class System.Compiler.SourceChange : ValueType {
    public SourceContext SourceContext;
    public string ChangedText;
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.SourceChangeList : object {
    private SourceChange[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public SourceChange Item { get; public set; }
    public SourceChangeList(int capacity);
    public SourceChangeList(SourceChange[] elements);
    public void Add(SourceChange element);
    public SourceChangeList Clone();
    public int get_Count();
    public int get_Length();
    public SourceChange get_Item(int index);
    public void set_Item(int index, SourceChange value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.SourceContext : ValueType {
    public Document Document;
    public int EndPos;
    public int StartPos;
    public bool Hidden { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsValid { get; }
    public string SourceText { get; }
    public SourceContext(Document document);
    public SourceContext(Document document, int startPos, int endPos);
    public SourceContext(Document document, int startLine, int startColumn, int endLine, int endColumn);
    public bool get_Hidden();
    public int get_StartLine();
    public int get_StartColumn();
    public int get_EndLine();
    public int get_EndColumn();
    public bool Encloses(int line, int column);
    public bool Encloses(SourceContext sourceContext);
    public bool get_IsValid();
    public string get_SourceText();
    public void Hide();
}
public class System.Compiler.Specializer : StandardVisitor {
    public TypeNodeList pars;
    public TypeNodeList args;
    public Method CurrentMethod;
    public TypeNode CurrentType;
    public Module TargetModule;
    private TrivialHashtable forwarding;
    public Block DummyBody;
    public Specializer(Module targetModule, TypeNodeList pars, TypeNodeList args);
    public Specializer(Visitor callingVisitor);
    public virtual void TransferStateTo(Visitor targetVisitor);
    public virtual DelegateNode VisitDelegateNode(DelegateNode delegateNode);
    public virtual Interface VisitInterfaceReference(Interface Interface);
    public virtual Expression VisitMemberBinding(MemberBinding memberBinding);
    public virtual Member VisitMemberReference(Member member);
    public static Member GetCorrespondingMember(Member member, TypeNode specializedType);
    public virtual Method VisitMethod(Method method);
    private TypeNodeList FreshTypeParameterListIfNecessary(TypeNodeList typeNodeList);
    private TypeNode FreshTypeParameterIfNecessary(TypeNode typeParameter);
    private TypeNode CopyTypeParameter(TypeNode typeParameter);
    private TypeNode ConvertToClassParameter(TypeNode baseType, TypeNode typeParameter);
    public virtual MethodContract VisitMethodContract(MethodContract contract);
    public virtual object VisitContractPart(Method method, object part);
    public virtual MethodList VisitMethodList(MethodList methods);
    public virtual TypeNode VisitTypeNode(TypeNode typeNode);
    private void ProvideTypeAttributes(TypeNode typeNode, object handle);
    private void ProvideTypeSignature(TypeNode typeNode, object handle);
    private void ProvideNestedTypes(TypeNode typeNode, object handle);
    private void ProvideTypeMembers(TypeNode typeNode, object handle);
    public virtual Expression VisitTypeExpression(Expression expr);
    public virtual TypeNode VisitTypeParameter(TypeNode typeParameter);
    public virtual TypeNode VisitTypeReference(TypeNode type);
}
public class System.Compiler.StandardIds : object {
    public static Identifier Address;
    public static Identifier AllowMultiple;
    public static Identifier ClassParameter;
    public static Identifier Ctor;
    public static Identifier CCtor;
    public static Identifier Enum;
    public static Identifier Get;
    public static Identifier Inherited;
    public static Identifier Invoke;
    public static Identifier Set;
    public static Identifier System;
    public static Identifier This;
    public static Identifier TypeParameter;
    public static Identifier Value__;
    public static Identifier _Deleted;
    public static Identifier opExplicit;
    public static Identifier opImplicit;
    public static Identifier Add;
    public static Identifier AllowMultipleAttribute;
    public static Identifier Anonymity;
    public static Identifier ArgumentOutOfRangeException;
    public static Identifier Assembly;
    public static Identifier Assert;
    public static Identifier BeginInvoke;
    public static Identifier callback;
    public static Identifier CallingConvention;
    public static Identifier CapitalObject;
    public static Identifier CharSet;
    public static Identifier Class;
    public static Identifier Clear;
    public static Identifier Closure;
    public static Identifier Collection;
    public static Identifier Combine;
    public static Identifier Concat;
    public static Identifier Count;
    public static Identifier CreateInstance;
    public static Identifier CultureName;
    public static Identifier Current;
    public static Identifier Dispose;
    public static Identifier ElementType;
    public static Identifier Enter;
    public static Identifier EntryPoint;
    public static Identifier ExactSpelling;
    public static Identifier Exit;
    public static Identifier EndInvoke;
    public static Identifier Equals;
    public static Identifier Finalize;
    public static Identifier FromObject;
    public static Identifier getCurrent;
    public static Identifier getCount;
    public static Identifier GetEnumerator;
    public static Identifier GetHashCode;
    public static Identifier getHasValue;
    public static Identifier getItem;
    public static Identifier GetTag;
    public static Identifier GetTagAsType;
    public static Identifier getValue;
    public static Identifier GetValue;
    public static Identifier GetValueOrDefault;
    public static Identifier GetType;
    public static Identifier Global;
    public static Identifier HResult;
    public static Identifier IBindableIterable;
    public static Identifier IBindableVector;
    public static Identifier IClosable;
    public static Identifier ICommand;
    public static Identifier IFactory;
    public static Identifier IEnumerableGetEnumerator;
    public static Identifier IEnumeratorGetCurrent;
    public static Identifier IEnumeratorReset;
    public static Identifier IIterable1;
    public static Identifier IKeyValuePair2;
    public static Identifier IMap2;
    public static Identifier IMapView2;
    public static Identifier INotifyCollectionChanged;
    public static Identifier IndexOf;
    public static Identifier Insert;
    public static Identifier IsInterned;
    public static Identifier IsNull;
    public static Identifier IReference1;
    public static Identifier It;
    public static Identifier Item;
    public static Identifier IVector1;
    public static Identifier IVectorView1;
    public static Identifier Length;
    public static Identifier Main;
    public static Identifier Method;
    public static Identifier MemberwiseClone;
    public static Identifier MoveNext;
    public static Identifier Namespace;
    public static Identifier New;
    public static Identifier NewObj;
    public static Identifier NotifyCollectionChangedAction;
    public static Identifier NotifyCollectionChangedEventArgs;
    public static Identifier NotifyCollectionChangedEventHandler;
    public static Identifier Object;
    public static Identifier opAddition;
    public static Identifier opBitwiseAnd;
    public static Identifier opBitwiseOr;
    public static Identifier opComma;
    public static Identifier opDecrement;
    public static Identifier opDivision;
    public static Identifier opEquality;
    public static Identifier opExclusiveOr;
    public static Identifier opFalse;
    public static Identifier opGreaterThan;
    public static Identifier opGreaterThanOrEqual;
    public static Identifier opIncrement;
    public static Identifier opInequality;
    public static Identifier opLeftShift;
    public static Identifier opLessThan;
    public static Identifier opLessThanOrEqual;
    public static Identifier opLogicalNot;
    public static Identifier opModulus;
    public static Identifier opMultiply;
    public static Identifier opOnesComplement;
    public static Identifier opRightShift;
    public static Identifier opSubtraction;
    public static Identifier opTrue;
    public static Identifier opUnaryNegation;
    public static Identifier opUnaryPlus;
    public static Identifier Pack;
    public static Identifier Phase;
    public static Identifier Position;
    public static Identifier PreserveSig;
    public static Identifier ReferenceEquals;
    public static Identifier Remove;
    public static Identifier Replace;
    public static Identifier Reset;
    public static Identifier result;
    public static Identifier SetLastError;
    public static Identifier SetValue;
    public static Identifier Size;
    public static Identifier StructuralTypes;
    public static Identifier Tag;
    public static Identifier TagType;
    public static Identifier ThisValue;
    public static Identifier ToObject;
    public static Identifier ToString;
    public static Identifier TypeName;
    public static Identifier CciTypeExtensions;
    public static Identifier Value;
    public static Identifier Var;
    public static Identifier WindowsFoundation;
    public static Identifier WindowsFoundationMetadata;
    public static Identifier WindowsFoundationCollections;
    public static Identifier WindowsUI;
    public static Identifier WindowsUIXaml;
    public static Identifier WindowsUIXamlData;
    public static Identifier WindowsUIXamlInput;
    public static Identifier WindowsUIXamlInterop;
    public static Identifier WindowsUIXamlControlsPrimitives;
    public static Identifier WindowsUIXamlMedia;
    public static Identifier WindowsUIXamlMediaAnimation;
    public static Identifier WindowsUIXamlMediaMedia3D;
    public static Identifier __Arglist;
    private static StandardIds();
}
public class System.Compiler.StandardVisitor : Visitor {
    public Visitor callingVisitor;
    protected bool memberListNamesChanged;
    public TypeViewer TypeViewer { get; }
    public StandardVisitor(Visitor callingVisitor);
    public virtual Node VisitUnknownNodeType(Node node);
    public virtual Visitor GetVisitorFor(Node node);
    public virtual Node Visit(Node node);
    public virtual Expression VisitAddressDereference(AddressDereference addr);
    public virtual AssemblyNode VisitAssembly(AssemblyNode assembly);
    public virtual AssemblyReference VisitAssemblyReference(AssemblyReference assemblyReference);
    public virtual Statement VisitAssertion(Assertion assertion);
    public virtual Statement VisitAssumption(Assumption assumption);
    public virtual Expression VisitAssignmentExpression(AssignmentExpression assignment);
    public virtual Statement VisitAssignmentStatement(AssignmentStatement assignment);
    public virtual Expression VisitAttributeConstructor(AttributeNode attribute);
    public virtual AttributeNode VisitAttributeNode(AttributeNode attribute);
    public virtual AttributeList VisitAttributeList(AttributeList attributes);
    public virtual Expression VisitBinaryExpression(BinaryExpression binaryExpression);
    public virtual Block VisitBlock(Block block);
    public virtual Expression VisitBlockExpression(BlockExpression blockExpression);
    public virtual BlockList VisitBlockList(BlockList blockList);
    public virtual Statement VisitBranch(Branch branch);
    public virtual Class VisitClass(Class Class);
    public virtual Expression VisitConstruct(Construct cons);
    public virtual Expression VisitConstructArray(ConstructArray consArr);
    public virtual DelegateNode VisitDelegateNode(DelegateNode delegateNode);
    public virtual Statement VisitEndFilter(EndFilter endFilter);
    public virtual Statement VisitEndFinally(EndFinally endFinally);
    public virtual EnsuresList VisitEnsuresList(EnsuresList Ensures);
    public virtual EnumNode VisitEnumNode(EnumNode enumNode);
    public virtual Event VisitEvent(Event evnt);
    public virtual EnsuresExceptional VisitEnsuresExceptional(EnsuresExceptional exceptional);
    public virtual Expression VisitExpression(Expression expression);
    public virtual ExpressionList VisitExpressionList(ExpressionList expressions);
    public virtual Statement VisitExpressionStatement(ExpressionStatement statement);
    public virtual Statement VisitFaultHandler(FaultHandler faultHandler);
    public virtual FaultHandlerList VisitFaultHandlerList(FaultHandlerList faultHandlers);
    public virtual Field VisitField(Field field);
    public virtual Expression VisitIdentifier(Identifier identifier);
    public virtual Expression VisitIndexer(Indexer indexer);
    public virtual Interface VisitInterface(Interface Interface);
    public virtual Interface VisitInterfaceReference(Interface Interface);
    public virtual InterfaceList VisitInterfaceReferenceList(InterfaceList interfaceReferences);
    public virtual Invariant VisitInvariant(Invariant invariant);
    public virtual InvariantList VisitInvariantList(InvariantList invariants);
    public virtual InstanceInitializer VisitInstanceInitializer(InstanceInitializer cons);
    public virtual Statement VisitLabeledStatement(LabeledStatement lStatement);
    public virtual Expression VisitLiteral(Literal literal);
    public virtual Expression VisitLocal(Local local);
    public virtual Expression VisitMemberBinding(MemberBinding memberBinding);
    public virtual MemberList VisitMemberList(MemberList members);
    public virtual Method VisitMethod(Method method);
    public virtual Expression VisitMethodCall(MethodCall call);
    public virtual Expression VisitArglistArgumentExpression(ArglistArgumentExpression argexp);
    public virtual Expression VisitArglistExpression(ArglistExpression argexp);
    public virtual MethodContract VisitMethodContract(MethodContract contract);
    public virtual Module VisitModule(Module module);
    public virtual ModuleReference VisitModuleReference(ModuleReference moduleReference);
    public virtual Expression VisitNamedArgument(NamedArgument namedArgument);
    public virtual EnsuresNormal VisitEnsuresNormal(EnsuresNormal normal);
    public virtual Expression VisitOldExpression(OldExpression oldExpression);
    public virtual Expression VisitReturnValue(ReturnValue returnValue);
    public virtual RequiresOtherwise VisitRequiresOtherwise(RequiresOtherwise otherwise);
    public virtual RequiresPlain VisitRequiresPlain(RequiresPlain plain);
    public virtual Expression VisitParameter(Parameter parameter);
    public virtual ParameterList VisitParameterList(ParameterList parameterList);
    public virtual Expression VisitPrefixExpression(PrefixExpression pExpr);
    public virtual Expression VisitPostfixExpression(PostfixExpression pExpr);
    public virtual Property VisitProperty(Property property);
    public virtual RequiresList VisitRequiresList(RequiresList Requires);
    public virtual Statement VisitReturn(Return Return);
    public virtual SecurityAttribute VisitSecurityAttribute(SecurityAttribute attribute);
    public virtual SecurityAttributeList VisitSecurityAttributeList(SecurityAttributeList attributes);
    public virtual StatementList VisitStatementList(StatementList statements);
    public virtual StaticInitializer VisitStaticInitializer(StaticInitializer cons);
    public virtual Struct VisitStruct(Struct Struct);
    public virtual Statement VisitSwitchInstruction(SwitchInstruction switchInstruction);
    public virtual Expression VisitTargetExpression(Expression expression);
    public virtual Expression VisitTernaryExpression(TernaryExpression expression);
    public virtual Expression VisitThis(This This);
    public virtual Statement VisitThrow(Throw Throw);
    public virtual TypeContract VisitTypeContract(TypeContract contract);
    public virtual TypeModifier VisitTypeModifier(TypeModifier typeModifier);
    public virtual TypeNode VisitTypeNode(TypeNode typeNode);
    public virtual TypeNodeList VisitTypeNodeList(TypeNodeList types);
    public virtual TypeNode VisitTypeParameter(TypeNode typeParameter);
    public virtual TypeNodeList VisitTypeParameterList(TypeNodeList typeParameters);
    public virtual TypeNode VisitTypeReference(TypeNode type);
    public virtual TypeReference VisitTypeReference(TypeReference type);
    public virtual TypeNodeList VisitTypeReferenceList(TypeNodeList typeReferences);
    public virtual Expression VisitUnaryExpression(UnaryExpression unaryExpression);
    public virtual TypeViewer get_TypeViewer();
    public virtual TypeNode GetTypeView(TypeNode type);
}
public class System.Compiler.Statement : Node {
    public int ILOffset;
    public Statement(NodeType nodeType);
    public Statement(NodeType nodeType, SourceContext sctx);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.StatementList : object {
    private Statement[] elements;
    private int count;
    public int Count { get; public set; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; public set; }
    public Statement Item { get; public set; }
    public StatementList(int capacity);
    public StatementList(Statement[] elements);
    public void Add(Statement statement);
    public StatementList Clone();
    public int get_Count();
    public void set_Count(int value);
    public int get_Length();
    public void set_Length(int value);
    public Statement get_Item(int index);
    public void set_Item(int index, Statement value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.StaticInitializer : Method {
    protected ConstructorInfo constructorInfo;
    public bool OverridesBaseClassMember { get; public set; }
    public Member OverriddenMember { get; public set; }
    public Method OverriddenMethod { get; public set; }
    public StaticInitializer(MethodBodyProvider provider, object handle, int methodToken);
    public StaticInitializer(MethodBodyProvider provider, object handle);
    public StaticInitializer(TypeNode declaringType, AttributeList attributes, Block body);
    public StaticInitializer(TypeNode declaringType, AttributeList attributes, Block body, TypeNode voidTypeExpression);
    public virtual ConstructorInfo GetConstructorInfo();
    public virtual MethodInfo GetMethodInfo();
    public virtual bool get_OverridesBaseClassMember();
    public virtual void set_OverridesBaseClassMember(bool value);
    public virtual Member get_OverriddenMember();
    public virtual void set_OverriddenMember(Member value);
    public virtual Method get_OverriddenMethod();
    public virtual void set_OverriddenMethod(Method value);
}
public class System.Compiler.StreamTypeExpression : TypeNode {
    public TypeNode ElementType;
    public StreamTypeExpression(TypeNode elementType);
    public StreamTypeExpression(TypeNode elementType, SourceContext sctx);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.StringList : object {
    private String[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public string Item { get; public set; }
    public StringList(int capacity);
    public StringList(String[] elements);
    public StringList(StringCollection stringCollection);
    public void Add(string element);
    public int get_Count();
    public int get_Length();
    public string get_Item(int index);
    public void set_Item(int index, string value);
    public Enumerator GetEnumerator();
}
public class System.Compiler.StringSourceText : object {
    public string SourceText;
    public bool IsSameAsFileContents;
    private int System.Compiler.ISourceText.Length { get; }
    private char System.Compiler.ISourceText.Item { get; }
    public StringSourceText(string sourceText, bool isSameAsFileContents);
    private sealed virtual override int System.Compiler.ISourceText.get_Length();
    private sealed virtual override string System.Compiler.ISourceText.Substring(int startIndex, int length);
    private sealed virtual override char System.Compiler.ISourceText.get_Item(int index);
    private sealed virtual override void System.Compiler.ISourceText.MakeCollectible();
}
public class System.Compiler.Struct : TypeNode {
    internal static Struct Dummy;
    protected bool cachedUnmanaged;
    protected bool cachedUnmanagedIsValid;
    public bool IsUnmanaged { get; }
    public Struct(NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public Struct(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags flags, Identifier Namespace, Identifier name, InterfaceList interfaces, MemberList members);
    private static Struct();
    public virtual bool get_IsUnmanaged();
}
public class System.Compiler.SwitchInstruction : Statement {
    private Expression expression;
    private BlockList targets;
    public Expression Expression { get; public set; }
    public BlockList Targets { get; public set; }
    public SwitchInstruction(Expression expression, BlockList targets);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public BlockList get_Targets();
    public void set_Targets(BlockList value);
}
public class System.Compiler.SystemAssemblyLocation : object {
    private static string location;
    public static AssemblyNode ParsedAssembly;
    public static IDictionary SystemAssemblyCache;
    public static string Location { get; public set; }
    private static SystemAssemblyLocation();
    public static string get_Location();
    public static void set_Location(string value);
}
public class System.Compiler.SystemDiagnosticsDebugAssemblyLocation : object {
    public static string Location;
    private static SystemDiagnosticsDebugAssemblyLocation();
}
public class System.Compiler.SystemDiagnosticsToolsAssemblyLocation : object {
    public static string Location;
    private static SystemDiagnosticsToolsAssemblyLocation();
}
public class System.Compiler.SystemDllAssemblyLocation : object {
    public static string Location;
    private static SystemDllAssemblyLocation();
}
public class System.Compiler.SystemGlobalizationAssemblyLocation : object {
    public static string Location;
    private static SystemGlobalizationAssemblyLocation();
}
public class System.Compiler.SystemReflectionAssemblyLocation : object {
    public static string Location;
    private static SystemReflectionAssemblyLocation();
}
public class System.Compiler.SystemResourceManagerAssemblyLocation : object {
    public static string Location;
    private static SystemResourceManagerAssemblyLocation();
}
public class System.Compiler.SystemRuntimeCollectionsAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeCollectionsAssemblyLocation();
}
public class System.Compiler.SystemRuntimeExtensionsAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeExtensionsAssemblyLocation();
}
public class System.Compiler.SystemRuntimeInteropServicesAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeInteropServicesAssemblyLocation();
}
public class System.Compiler.SystemRuntimeIOServicesAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeIOServicesAssemblyLocation();
}
public class System.Compiler.SystemRuntimeSerializationAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeSerializationAssemblyLocation();
}
public class System.Compiler.SystemRuntimeWindowsRuntimeAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeWindowsRuntimeAssemblyLocation();
}
public class System.Compiler.SystemRuntimeWindowsRuntimeInteropServicesAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeWindowsRuntimeInteropServicesAssemblyLocation();
}
public class System.Compiler.SystemRuntimeWindowsRuntimeUIXamlAssemblyLocation : object {
    public static string Location;
    private static SystemRuntimeWindowsRuntimeUIXamlAssemblyLocation();
}
public class System.Compiler.SystemThreadingAssemblyLocation : object {
    public static string Location;
    private static SystemThreadingAssemblyLocation();
}
public class System.Compiler.SystemTypes : object {
    internal static bool Initialized;
    public static AssemblyNode CollectionsAssembly;
    public static AssemblyNode DiagnosticsDebugAssembly;
    public static AssemblyNode DiagnosticsToolsAssembly;
    public static AssemblyNode GlobalizationAssembly;
    public static AssemblyNode InteropAssembly;
    public static AssemblyNode IOAssembly;
    public static AssemblyNode ReflectionAssembly;
    public static AssemblyNode ResourceManagerAssembly;
    public static AssemblyNode SystemDllAssembly;
    public static AssemblyNode SystemRuntimeExtensionsAssembly;
    public static AssemblyNode SystemRuntimeSerializationAssembly;
    private static AssemblyNode systemRuntimeWindowsRuntimeAssembly;
    public static AssemblyNode SystemRuntimeWindowsRuntimeInteropAssembly;
    private static AssemblyNode systemRuntimeWindowsRuntimeUIXamlAssembly;
    public static AssemblyNode ThreadingAssembly;
    public static Class AttributeUsageAttribute;
    public static Class ConditionalAttribute;
    public static Class DefaultMemberAttribute;
    public static Class InternalsVisibleToAttribute;
    public static Class ObsoleteAttribute;
    public static Interface GenericICollection;
    public static Interface GenericIEnumerable;
    public static Interface GenericIList;
    public static Interface ICloneable;
    public static Interface ICollection;
    public static Interface IEnumerable;
    public static Interface IList;
    public static Class AllowPartiallyTrustedCallersAttribute;
    public static Class AssemblyCompanyAttribute;
    public static Class AssemblyConfigurationAttribute;
    public static Class AssemblyCopyrightAttribute;
    public static Class AssemblyCultureAttribute;
    public static Class AssemblyDelaySignAttribute;
    public static Class AssemblyDescriptionAttribute;
    public static Class AssemblyFileVersionAttribute;
    public static Class AssemblyFlagsAttribute;
    public static Class AssemblyInformationalVersionAttribute;
    public static Class AssemblyKeyFileAttribute;
    public static Class AssemblyKeyNameAttribute;
    public static Class AssemblyProductAttribute;
    public static Class AssemblyTitleAttribute;
    public static Class AssemblyTrademarkAttribute;
    public static Class AssemblyVersionAttribute;
    public static Class ClassInterfaceAttribute;
    public static Class CLSCompliantAttribute;
    public static Class ComImportAttribute;
    public static Class ComRegisterFunctionAttribute;
    public static Class ComSourceInterfacesAttribute;
    public static Class ComUnregisterFunctionAttribute;
    public static Class ComVisibleAttribute;
    public static Class DebuggableAttribute;
    public static Class DebuggerHiddenAttribute;
    public static Class DebuggerStepThroughAttribute;
    public static EnumNode DebuggingModes;
    public static Class DllImportAttribute;
    public static Class FieldOffsetAttribute;
    public static Class FlagsAttribute;
    public static Class GuidAttribute;
    public static Class ImportedFromTypeLibAttribute;
    public static Class InAttribute;
    public static Class IndexerNameAttribute;
    public static Class InterfaceTypeAttribute;
    public static Class MethodImplAttribute;
    public static Class NonSerializedAttribute;
    public static Class OptionalAttribute;
    public static Class OutAttribute;
    public static Class ParamArrayAttribute;
    public static Class RuntimeCompatibilityAttribute;
    public static Class SatelliteContractVersionAttribute;
    public static Class SerializableAttribute;
    public static Class SecurityAttribute;
    public static Class SecurityCriticalAttribute;
    public static Class SecurityTransparentAttribute;
    public static Class SecurityTreatAsSafeAttribute;
    public static Class STAThreadAttribute;
    public static Class StructLayoutAttribute;
    public static Class SuppressMessageAttribute;
    public static Class SuppressUnmanagedCodeSecurityAttribute;
    public static EnumNode SecurityAction;
    public static Class DBNull;
    public static Struct DateTime;
    public static Struct DateTimeOffset;
    public static Struct TimeSpan;
    public static Class Activator;
    public static Class AppDomain;
    public static Class ApplicationException;
    public static Class ArgumentException;
    public static Class ArgumentNullException;
    public static Class ArgumentOutOfRangeException;
    public static Class ArrayList;
    public static DelegateNode AsyncCallback;
    public static Class Assembly;
    public static EnumNode AttributeTargets;
    public static Class CodeAccessPermission;
    public static Class CollectionBase;
    private static Delayed`1<Struct> color;
    private static Delayed`1<Struct> cornerRadius;
    public static Class CultureInfo;
    public static Class DictionaryBase;
    public static Struct DictionaryEntry;
    public static Class DuplicateWaitObjectException;
    private static Delayed`1<Struct> duration;
    private static Delayed`1<EnumNode> durationType;
    public static Class Environment;
    public static Class EventArgs;
    public static DelegateNode EventHandler1;
    public static Struct EventRegistrationToken;
    public static Class ExecutionEngineException;
    private static Delayed`1<Struct> generatorPosition;
    public static Struct GenericArraySegment;
    public static Class GenericArrayToIEnumerableAdapter;
    public static Class GenericDictionary;
    public static Interface GenericIComparable;
    public static Interface GenericIComparer;
    public static Interface GenericIDictionary;
    public static Interface GenericIEnumerator;
    public static Interface GenericIReadOnlyList;
    public static Interface GenericIReadOnlyDictionary;
    public static Struct GenericKeyValuePair;
    public static Class GenericList;
    public static Struct GenericNullable;
    public static Class GenericQueue;
    public static Class GenericSortedDictionary;
    public static Class GenericStack;
    public static Class GC;
    private static Delayed`1<Struct> gridLength;
    private static Delayed`1<EnumNode> gridUnitType;
    public static Struct Guid;
    public static Class __HandleProtector;
    public static Struct HandleRef;
    public static Class Hashtable;
    public static Interface IASyncResult;
    public static Interface ICommand;
    public static Interface IComparable;
    public static Interface IDictionary;
    public static Interface IComparer;
    public static Interface IDisposable;
    public static Interface IEnumerator;
    public static Interface IFormatProvider;
    public static Interface IHashCodeProvider;
    public static Interface IMembershipCondition;
    public static Interface INotifyPropertyChanged;
    public static Interface IBindableIterable;
    public static Interface IBindableVector;
    public static Interface INotifyCollectionChanged;
    public static Class IndexOutOfRangeException;
    public static Class InvalidCastException;
    public static Class InvalidOperationException;
    public static Interface IPermission;
    public static Interface ISerializable;
    public static Interface IStackWalk;
    private static Delayed`1<Struct> keyTime;
    public static Class Marshal;
    public static Class MarshalByRefObject;
    private static Delayed`1<Struct> matrix;
    private static Delayed`1<Struct> matrix3D;
    public static Class MemberInfo;
    public static Struct NativeOverlapped;
    public static Class Monitor;
    public static EnumNode NotifyCollectionChangedAction;
    public static Class NotifyCollectionChangedEventArgs;
    public static DelegateNode NotifyCollectionChangedEventHandler;
    public static Class NotSupportedException;
    public static Class NullReferenceException;
    public static Class OutOfMemoryException;
    public static Class ParameterInfo;
    public static Class PropertyChangedEventArgs;
    public static DelegateNode PropertyChangedEventHandler;
    private static Delayed`1<Struct> point;
    public static Class Queue;
    public static Class ReadOnlyCollectionBase;
    private static Delayed`1<Struct> rect;
    private static Delayed`1<Struct> repeatBehavior;
    private static Delayed`1<EnumNode> repeatBehaviorType;
    public static Class ResourceManager;
    public static Class ResourceSet;
    public static Class SerializationInfo;
    private static Delayed`1<Struct> size;
    public static Class Stack;
    public static Class StackOverflowException;
    public static Class Stream;
    public static Struct StreamingContext;
    public static Class StringBuilder;
    public static Class StringComparer;
    public static EnumNode StringComparison;
    public static Class SystemException;
    private static Delayed`1<Struct> thickness;
    public static Class Thread;
    public static Class Uri;
    public static Class WindowsImpersonationContext;
    public static bool IsInitialized { get; }
    public static AssemblyNode SystemAssembly { get; public set; }
    public static AssemblyNode SystemRuntimeWindowsRuntimeAssembly { get; }
    public static AssemblyNode SystemRuntimeWindowsRuntimeUIXamlAssembly { get; }
    public static Class Object { get; }
    public static Class String { get; }
    public static Class ValueType { get; }
    public static Class Enum { get; }
    public static Class Delegate { get; }
    public static Class MulticastDelegate { get; }
    public static Class Array { get; }
    public static Class Type { get; }
    public static Class Exception { get; }
    public static Class Attribute { get; }
    public static Struct Boolean { get; }
    public static Struct Char { get; }
    public static Struct Int8 { get; }
    public static Struct UInt8 { get; }
    public static Struct Int16 { get; }
    public static Struct UInt16 { get; }
    public static Struct Int32 { get; }
    public static Struct UInt32 { get; }
    public static Struct Int64 { get; }
    public static Struct UInt64 { get; }
    public static Struct Single { get; }
    public static Struct Double { get; }
    public static Struct IntPtr { get; }
    public static Struct UIntPtr { get; }
    public static Struct DynamicallyTypedReference { get; }
    public static Struct ArgIterator { get; }
    public static Class IsVolatile { get; }
    public static Struct Void { get; }
    public static Struct RuntimeFieldHandle { get; }
    public static Struct RuntimeMethodHandle { get; }
    public static Struct RuntimeTypeHandle { get; }
    public static Struct RuntimeArgumentHandle { get; }
    public static Struct Decimal { get; }
    public static Struct Color { get; }
    public static Struct CornerRadius { get; }
    public static Struct Duration { get; }
    public static EnumNode DurationType { get; }
    public static Struct GeneratorPosition { get; }
    public static Struct GridLength { get; }
    public static EnumNode GridUnitType { get; }
    public static Struct KeyTime { get; }
    public static Struct Matrix { get; }
    public static Struct Matrix3D { get; }
    public static Struct Point { get; }
    public static Struct Rect { get; }
    public static Struct RepeatBehavior { get; }
    public static EnumNode RepeatBehaviorType { get; }
    public static Struct Size { get; }
    public static Struct Thickness { get; }
    private static SystemTypes();
    public static bool get_IsInitialized();
    public static AssemblyNode get_SystemAssembly();
    public static void set_SystemAssembly(AssemblyNode value);
    public static AssemblyNode get_SystemRuntimeWindowsRuntimeAssembly();
    public static AssemblyNode get_SystemRuntimeWindowsRuntimeUIXamlAssembly();
    public static Class get_Object();
    public static Class get_String();
    public static Class get_ValueType();
    public static Class get_Enum();
    public static Class get_Delegate();
    public static Class get_MulticastDelegate();
    public static Class get_Array();
    public static Class get_Type();
    public static Class get_Exception();
    public static Class get_Attribute();
    public static Struct get_Boolean();
    public static Struct get_Char();
    public static Struct get_Int8();
    public static Struct get_UInt8();
    public static Struct get_Int16();
    public static Struct get_UInt16();
    public static Struct get_Int32();
    public static Struct get_UInt32();
    public static Struct get_Int64();
    public static Struct get_UInt64();
    public static Struct get_Single();
    public static Struct get_Double();
    public static Struct get_IntPtr();
    public static Struct get_UIntPtr();
    public static Struct get_DynamicallyTypedReference();
    public static Struct get_ArgIterator();
    public static Class get_IsVolatile();
    public static Struct get_Void();
    public static Struct get_RuntimeFieldHandle();
    public static Struct get_RuntimeMethodHandle();
    public static Struct get_RuntimeTypeHandle();
    public static Struct get_RuntimeArgumentHandle();
    public static Struct get_Decimal();
    public static Struct get_Color();
    public static Struct get_CornerRadius();
    public static Struct get_Duration();
    public static EnumNode get_DurationType();
    public static Struct get_GeneratorPosition();
    public static Struct get_GridLength();
    public static EnumNode get_GridUnitType();
    public static Struct get_KeyTime();
    public static Struct get_Matrix();
    public static Struct get_Matrix3D();
    public static Struct get_Point();
    public static Struct get_Rect();
    public static Struct get_RepeatBehavior();
    public static EnumNode get_RepeatBehaviorType();
    public static Struct get_Size();
    public static Struct get_Thickness();
    public static void Clear();
    public static void Initialize(bool doNotLockFile, bool getDebugInfo, PostAssemblyLoadProcessor postAssemblyLoad);
    private static void ClearStatics();
    private static AssemblyNode GetSystemDllAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetGenericRuntimeTypeNodeFor(string nspace, string name, int numParams, ElementType typeCode);
    private static TypeNode GetTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static TypeNode GetSystemTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetCollectionsAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetCollectionsGenericRuntimeTypeNodeFor(string nspace, string name, int numParams, ElementType typeCode);
    private static TypeNode GetCollectionsTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetDiagnosticsDebugAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetDiagnosticsDebugTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetDiagnosticsToolsAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetDiagnosticsToolsTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetInteropAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetInteropTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetIOAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetIOTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetReflectionAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetReflectionTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetResourceManagerAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetResourceManagerTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetGlobalizationAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetGlobalizationTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetRuntimeExtensionsAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetRuntimeExtensionsTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetRuntimeSerializationAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetRuntimeSerializationTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetThreadingAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetThreadingTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetWindowsRuntimeInteropAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetWindowsRuntimeInteropTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetSystemRuntimeWindowsRuntimeAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetGenericWindowsRuntimeTypeNodeFor(string nspace, string name, int numParams, ElementType typeCode);
    private static TypeNode GetWindowsRuntimeTypeNodeFor(string nspace, string name, ElementType typeCode);
    private static AssemblyNode GetSystemRuntimeWindowsRuntimeUIXamlAssembly(bool doNotLockFile, bool getDebugInfo);
    private static TypeNode GetGenericWindowsRuntimeUIXamlTypeNodeFor(string nspace, string name, int numParams, ElementType typeCode);
    private static TypeNode GetWindowsRuntimeUIXamlTypeNodeFor(string nspace, string name, ElementType typeCode);
}
public class System.Compiler.TargetInformation : ValueType {
    public string Company;
    public string Configuration;
    public string Copyright;
    public string Culture;
    public string Description;
    public string Product;
    public string ProductVersion;
    public string Title;
    public string Trademark;
    public string Version;
}
public class System.Compiler.TargetPlatform : object {
    public static bool BusyWithClear;
    public static bool DoNotLockFiles;
    public static bool GetDebugInfo;
    public static char GenericTypeNamesMangleChar;
    private static bool useGenerics;
    public static Version TargetVersion;
    public static string TargetRuntimeVersion;
    public static string PlatformAssembliesLocation;
    private static TrivialHashtable assemblyReferenceFor;
    private static String[] FxAssemblyNames;
    private static String[] FxAssemblyToken;
    private static String[] FxAssemblyVersion1;
    private static String[] FxAssemblyVersion1_1;
    private static String[] FxAssemblyVersion2Build3600;
    private static String[] FxAssemblyVersion2;
    private static String[] FxAssemblyVersion4;
    public static bool UseGenerics { get; public set; }
    public static IDictionary StaticAssemblyCache { get; }
    public static int LinkerMajorVersion { get; }
    public static int LinkerMinorVersion { get; }
    public static int MajorVersion { get; }
    public static int MinorVersion { get; }
    public static int Build { get; }
    internal static bool AssemblyReferenceForInitialized { get; }
    public static TrivialHashtable AssemblyReferenceFor { get; public set; }
    private static TargetPlatform();
    public static bool get_UseGenerics();
    public static void set_UseGenerics(bool value);
    public static void Clear();
    public static IDictionary get_StaticAssemblyCache();
    public static int get_LinkerMajorVersion();
    public static int get_LinkerMinorVersion();
    public static int get_MajorVersion();
    public static int get_MinorVersion();
    public static int get_Build();
    internal static bool get_AssemblyReferenceForInitialized();
    public static TrivialHashtable get_AssemblyReferenceFor();
    public static void set_AssemblyReferenceFor(TrivialHashtable value);
    private static void SetupAssemblyReferenceFor();
    public static void SetTo(Version version);
    public static void SetTo(Version version, string platformAssembliesLocation);
    public static void SetToV1();
    public static void SetToV1(string platformAssembliesLocation);
    public static void SetToV1_1();
    public static void SetToV1_1(string platformAssembliesLocation);
    public static void SetToV2();
    public static void SetToV2(string platformAssembliesLocation);
    public static void SetToV2Beta1();
    public static void SetToV2Beta1(string platformAssembliesLocation);
    public static void SetToV4();
    public static void SetToV4(string platformAssembliesLocation);
    public static void SetToV4_5();
    public static void SetToV4_5(string platformAssembliesLocation);
    public static void SetToPostV2();
    public static void SetToPostV2(string platformAssembliesLocation);
    public static void SetToPostV1_1(string platformAssembliesLocation);
    private static void InitializeStandardAssemblyLocationsWithDefaultValues(string platformAssembliesLocation);
    private static void InitializeStandardAssemblyLocationsWithDefaultValues(string platformAssembliesLocation, string mscorlibName, string alternateName);
    private static void InitializeStandardAssemblyLocationsWithDefaultValues(string platformAssembliesLocation, string mscorlibName);
    public static void ResetCci(string platformAssembliesLocation, Version targetVersion, bool doNotLockFile, bool getDebugInfo, PostAssemblyLoadProcessor postAssemblyLoad);
}
public class System.Compiler.TernaryExpression : Expression {
    private Expression operand1;
    private Expression operand2;
    private Expression operand3;
    public Expression Operand1 { get; public set; }
    public Expression Operand2 { get; public set; }
    public Expression Operand3 { get; public set; }
    public TernaryExpression(Expression operand1, Expression operand2, Expression operand3, NodeType nodeType, TypeNode resultType);
    public Expression get_Operand1();
    public void set_Operand1(Expression value);
    public Expression get_Operand2();
    public void set_Operand2(Expression value);
    public Expression get_Operand3();
    public void set_Operand3(Expression value);
}
public class System.Compiler.This : Parameter {
    public This(TypeNode type);
}
public class System.Compiler.Throw : Statement {
    private Expression expression;
    public Expression Expression { get; public set; }
    public Throw(Expression expression);
    public Throw(Expression expression, SourceContext context);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.TrivialHashtable : object {
    private static int InitialSize;
    private HashEntry[] entries;
    private int count;
    public int Count { get; }
    public object Item { get; public set; }
    public IEnumerable Values { get; }
    private TrivialHashtable(HashEntry[] entries, int count);
    public TrivialHashtable(int expectedEntries);
    public int get_Count();
    private void Expand();
    public object get_Item(int key);
    public void set_Item(int key, object value);
    [IteratorStateMachineAttribute("System.Compiler.TrivialHashtable/<get_Values>d__14")]
public IEnumerable get_Values();
    public TrivialHashtable Clone();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.TrivialHashtable`1 : object {
    private static int InitialSize;
    private HashEntry[] entries;
    private int count;
    public int Count { get; }
    public T Item { get; public set; }
    private TrivialHashtable`1(HashEntry[] entries, int count);
    public TrivialHashtable`1(int expectedEntries);
    public int get_Count();
    private void Expand();
    public bool TryGetValue(int key, T& result);
    public T get_Item(int key);
    public void set_Item(int key, T value);
    public TrivialHashtable`1<T> Clone();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.TrivialHashtableUsingWeakReferences : object {
    private HashEntry[] entries;
    private int count;
    public int Count { get; }
    public object Item { get; public set; }
    private TrivialHashtableUsingWeakReferences(HashEntry[] entries, int count);
    public TrivialHashtableUsingWeakReferences(int expectedEntries);
    public int get_Count();
    private void Expand();
    private void Contract();
    private void WeedOutCollectedEntries();
    public object get_Item(int key);
    public void set_Item(int key, object value);
    public TrivialHashtableUsingWeakReferences Clone();
}
public class System.Compiler.TupleTypeExpression : TypeNode {
    public FieldList Domains;
    public TupleTypeExpression(FieldList domains);
    public TupleTypeExpression(FieldList domains, SourceContext sctx);
}
public class System.Compiler.TypeContract : Node {
    public TypeNode DeclaringType;
    public InvariantList InheritedInvariants;
    protected internal InvariantList invariants;
    public InvariantList Invariants { get; public set; }
    public int InvariantCount { get; }
    public TypeContract(TypeNode containingType);
    public TypeContract(TypeNode containingType, bool initInvariantList);
    public InvariantList get_Invariants();
    public void set_Invariants(InvariantList value);
    public int get_InvariantCount();
}
public class System.Compiler.TypeExpression : TypeNode {
    public Expression Expression;
    public int Arity;
    public bool IsUnmanaged { get; }
    public TypeExpression(Expression expression);
    public TypeExpression(Expression expression, TypeNodeList templateArguments);
    public TypeExpression(Expression expression, int arity);
    public TypeExpression(Expression expression, SourceContext sctx);
    public TypeExpression(Expression expression, TypeNodeList templateArguments, SourceContext sctx);
    public TypeExpression(Expression expression, int arity, SourceContext sctx);
    public virtual bool get_IsUnmanaged();
}
[FlagsAttribute]
public enum System.Compiler.TypeFlags : Enum {
    public int value__;
    public static TypeFlags None;
    public static TypeFlags VisibilityMask;
    public static TypeFlags NotPublic;
    public static TypeFlags Public;
    public static TypeFlags NestedPublic;
    public static TypeFlags NestedPrivate;
    public static TypeFlags NestedFamily;
    public static TypeFlags NestedAssembly;
    public static TypeFlags NestedFamANDAssem;
    public static TypeFlags NestedFamORAssem;
    public static TypeFlags LayoutMask;
    public static TypeFlags AutoLayout;
    public static TypeFlags SequentialLayout;
    public static TypeFlags ExplicitLayout;
    public static TypeFlags ClassSemanticsMask;
    public static TypeFlags Class;
    public static TypeFlags Interface;
    public static TypeFlags LayoutOverridden;
    public static TypeFlags Abstract;
    public static TypeFlags Sealed;
    public static TypeFlags SpecialName;
    public static TypeFlags Import;
    public static TypeFlags Serializable;
    public static TypeFlags IsForeign;
    public static TypeFlags StringFormatMask;
    public static TypeFlags AnsiClass;
    public static TypeFlags UnicodeClass;
    public static TypeFlags AutoClass;
    public static TypeFlags BeforeFieldInit;
    public static TypeFlags ReservedMask;
    public static TypeFlags RTSpecialName;
    public static TypeFlags HasSecurity;
    public static TypeFlags Forwarder;
    public static TypeFlags Extend;
}
public class System.Compiler.TypeIntersectionExpression : TypeNode {
    public TypeNodeList Types;
    public TypeIntersectionExpression(TypeNodeList types);
    public TypeIntersectionExpression(TypeNodeList types, SourceContext sctx);
}
public abstract class System.Compiler.TypeModifier : TypeNode {
    private TypeNode modifier;
    private TypeNode modifiedType;
    public TypeNode ModifierExpression;
    public TypeNode ModifiedTypeExpression;
    protected TypeNodeList structuralElementTypes;
    public TypeNode Modifier { get; public set; }
    public TypeNode ModifiedType { get; public set; }
    public bool IsUnmanaged { get; }
    public bool IsStructural { get; }
    public bool IsValueType { get; }
    public bool IsPointerType { get; }
    public bool IsReferenceType { get; }
    public bool IsTemplateParameter { get; }
    public TypeNodeList StructuralElementTypes { get; }
    internal TypeModifier(NodeType type, TypeNode modifier, TypeNode modified);
    public TypeNode get_Modifier();
    public void set_Modifier(TypeNode value);
    public TypeNode get_ModifiedType();
    public void set_ModifiedType(TypeNode value);
    public virtual Node Clone();
    public virtual string GetFullUnmangledNameWithoutTypeParameters();
    public virtual string GetFullUnmangledNameWithTypeParameters();
    public virtual string GetUnmangledNameWithoutTypeParameters();
    public virtual bool get_IsUnmanaged();
    public virtual bool get_IsStructural();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
    public virtual bool get_IsValueType();
    public virtual bool get_IsPointerType();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsTemplateParameter();
    public virtual TypeNodeList get_StructuralElementTypes();
}
public abstract class System.Compiler.TypeNode : Member {
    private TypeContract contract;
    private int classSize;
    private Module declaringModule;
    private TypeFlags flags;
    protected InterfaceList interfaces;
    public InterfaceList InterfaceExpressions;
    private Identifier namespace;
    private int packingSize;
    public TypeNodeList IsDefinedBy;
    public bool IsNotFullySpecialized;
    public bool NewTemplateInstanceIsRecursive;
    public TypeNode PartiallyDefines;
    private TypeNodeList extensions;
    private bool extensionsExamined;
    public TypeMemberProvider ProvideTypeMembers;
    public NestedTypeProvider ProvideNestedTypes;
    public TypeAttributeProvider ProvideTypeAttributes;
    public TypeSignatureProvider ProvideTypeSignature;
    public object ProviderHandle;
    protected SecurityAttributeList securityAttributes;
    protected internal MemberList defaultMembers;
    protected string fullName;
    protected static Char[] MangleChars;
    private Identifier constructorName;
    protected bool isGeneric;
    protected bool isNormalized;
    protected internal MemberList members;
    protected internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) membersBeingPopulated;
    protected TypeNode template;
    public TypeNode TemplateExpression;
    protected TypeNodeList templateArguments;
    public TypeNodeList TemplateArgumentExpressions;
    internal TypeNodeList consolidatedTemplateArguments;
    internal TypeNodeList templateParameters;
    protected internal TypeNodeList consolidatedTemplateParameters;
    internal ElementType typeCode;
    private static TypeNode NotSpecified;
    protected internal TrivialHashtableUsingWeakReferences structurallyEquivalentMethod;
    protected internal TrivialHashtable szArrayTypes;
    protected internal TrivialHashtable arrayTypes;
    protected internal MemberList constructors;
    internal TrivialHashtable modifierTable;
    private TemplateInstanceCache templateInstanceCache;
    private TypeNodeList currentlyInstantiating;
    protected internal Pointer pointerType;
    protected internal Reference referenceType;
    protected internal TrivialHashtable memberTable;
    protected internal int memberCount;
    protected internal TypeNodeList nestedTypes;
    protected internal MemberList explicitCoercionMethods;
    protected internal MemberList implicitCoercionMethods;
    protected static Method MethodDoesNotExist;
    protected internal TrivialHashtable explicitCoercionFromTable;
    protected internal TrivialHashtable explicitCoercionToTable;
    protected internal TrivialHashtable implicitCoercionFromTable;
    protected internal TrivialHashtable implicitCoercionToTable;
    protected Method opFalse;
    protected Method opTrue;
    private static Hashtable typeMap;
    protected internal Type runtimeType;
    private TrivialHashtable explicitInterfaceImplementations;
    private bool isCheckingInheritedFrom;
    public TypeContract Contract { get; public set; }
    public int ClassSize { get; public set; }
    public Module DeclaringModule { get; public set; }
    public TypeNode DeclaringType { get; public set; }
    public TypeFlags Flags { get; public set; }
    public InterfaceList Interfaces { get; public set; }
    public Identifier Namespace { get; public set; }
    public int PackingSize { get; public set; }
    public TypeNodeList Extensions { get; public set; }
    public TypeNodeList ExtensionsNoTouch { get; }
    public TypeNode EffectiveTypeNode { get; }
    public AttributeList Attributes { get; public set; }
    public SecurityAttributeList SecurityAttributes { get; public set; }
    public TypeNode BaseType { get; }
    public MemberList DefaultMembers { get; public set; }
    public string FullName { get; }
    public string FullNameDuringParsing { get; }
    public Identifier ConstructorName { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsCompilerControlled { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsGeneric { get; public set; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamilyAndAssembly { get; }
    public bool IsNestedInternal { get; }
    public bool IsNestedPublic { get; }
    public bool IsNonPublic { get; }
    public bool IsNormalized { get; public set; }
    public bool IsPrivate { get; }
    public bool IsPrimitiveComparable { get; }
    public bool IsPrimitiveInteger { get; }
    public bool IsPrimitiveNumeric { get; }
    public bool IsPrimitiveUnsignedInteger { get; }
    public bool IsPublic { get; }
    public bool IsPrimitive { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsStructural { get; }
    public bool IsTemplateParameter { get; }
    public bool IsUnmanaged { get; }
    public TypeNodeList StructuralElementTypes { get; }
    public bool IsUnsignedPrimitiveNumeric { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsPointerType { get; }
    public bool IsVisibleOutsideAssembly { get; }
    public MemberList Members { get; public set; }
    public TypeNode Template { get; public set; }
    public TypeNodeList TemplateArguments { get; public set; }
    public TypeNodeList ConsolidatedTemplateArguments { get; public set; }
    public TypeNodeList TemplateParameters { get; public set; }
    public TypeNodeList ConsolidatedTemplateParameters { get; public set; }
    public TypeCode TypeCode { get; }
    public TypeNodeList NestedTypes { get; public set; }
    public MemberList ExplicitCoercionMethods { get; }
    public MemberList ImplicitCoercionMethods { get; }
    internal TypeNode(NodeType nodeType);
    internal TypeNode(NodeType nodeType, NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    internal TypeNode(Module declaringModule, TypeNode declaringType, AttributeList attributes, TypeFlags flags, Identifier Namespace, Identifier name, InterfaceList interfaces, MemberList members, NodeType nodeType);
    private static TypeNode();
    public TypeContract get_Contract();
    public void set_Contract(TypeContract value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public Module get_DeclaringModule();
    public void set_DeclaringModule(Module value);
    public virtual TypeNode get_DeclaringType();
    public virtual void set_DeclaringType(TypeNode value);
    public TypeFlags get_Flags();
    public void set_Flags(TypeFlags value);
    public virtual InterfaceList get_Interfaces();
    public virtual void set_Interfaces(InterfaceList value);
    public Identifier get_Namespace();
    public void set_Namespace(Identifier value);
    public int get_PackingSize();
    public void set_PackingSize(int value);
    public void RecordExtension(TypeNode extension);
    public TypeNodeList get_Extensions();
    public void set_Extensions(TypeNodeList value);
    public TypeNodeList get_ExtensionsNoTouch();
    public void DuplicateExtensions(TypeNode source, TypeNodeList newExtensions);
    public virtual TypeNode get_EffectiveTypeNode();
    public static bool op_Equality(TypeNode t1, TypeNode t2);
    public static bool op_Inequality(TypeNode t1, TypeNode t2);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(TypeNode other);
    public virtual int GetHashCode();
    public virtual AttributeList get_Attributes();
    public virtual void set_Attributes(AttributeList value);
    public SecurityAttributeList get_SecurityAttributes();
    public void set_SecurityAttributes(SecurityAttributeList value);
    public virtual TypeNode get_BaseType();
    public virtual MemberList get_DefaultMembers();
    public virtual void set_DefaultMembers(MemberList value);
    public virtual string get_FullName();
    public virtual string get_FullNameDuringParsing();
    public virtual string GetFullUnmangledNameWithoutTypeParameters();
    public virtual string GetFullUnmangledNameWithTypeParameters();
    public virtual string GetUnmangledNameWithTypeParameters();
    private string GetUnmangledNameWithTypeParameters(bool fullNamesForTypeParameters);
    public virtual string GetUnmangledNameWithoutTypeParameters();
    public virtual string GetSerializedTypeName();
    private string GetSerializedTypeName(TypeNode type, Boolean& isAssemblyQualified);
    private void AppendAssemblyQualifierIfNecessary(StringBuilder sb, TypeNode type, Boolean& isAssemQualified);
    private void AppendSerializedTypeName(StringBuilder sb, TypeNode type, Boolean& isAssemQualified);
    public virtual Identifier get_ConstructorName();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsAssembly();
    public virtual bool get_IsCompilerControlled();
    public virtual bool get_IsFamily();
    public virtual bool get_IsFamilyAndAssembly();
    public virtual bool get_IsFamilyOrAssembly();
    public virtual bool get_IsGeneric();
    public virtual void set_IsGeneric(bool value);
    public virtual bool get_IsNestedAssembly();
    public virtual bool get_IsNestedFamily();
    public virtual bool get_IsNestedFamilyAndAssembly();
    public virtual bool get_IsNestedInternal();
    public virtual bool IsNestedIn(TypeNode type);
    public virtual bool get_IsNestedPublic();
    public virtual bool get_IsNonPublic();
    public virtual bool get_IsNormalized();
    public virtual void set_IsNormalized(bool value);
    public virtual bool get_IsPrivate();
    public virtual bool get_IsPrimitiveComparable();
    public virtual bool get_IsPrimitiveInteger();
    public virtual bool get_IsPrimitiveNumeric();
    public virtual bool get_IsPrimitiveUnsignedInteger();
    public virtual bool get_IsPublic();
    public virtual bool get_IsPrimitive();
    public virtual bool get_IsSealed();
    public virtual bool get_IsSpecialName();
    public virtual bool get_IsStatic();
    public virtual bool get_IsStructural();
    public virtual bool get_IsTemplateParameter();
    public virtual bool get_IsUnmanaged();
    public virtual TypeNodeList get_StructuralElementTypes();
    public virtual bool get_IsUnsignedPrimitiveNumeric();
    public virtual bool get_IsValueType();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsPointerType();
    public virtual bool get_IsVisibleOutsideAssembly();
    public virtual MemberList get_Members();
    public virtual void set_Members(MemberList value);
    public virtual TypeNode get_Template();
    public virtual void set_Template(TypeNode value);
    public virtual TypeNodeList get_TemplateArguments();
    public virtual void set_TemplateArguments(TypeNodeList value);
    public virtual TypeNodeList get_ConsolidatedTemplateArguments();
    public virtual void set_ConsolidatedTemplateArguments(TypeNodeList value);
    private void AddTemplateParametersFromAttributeEncoding(TypeNodeList result);
    public virtual TypeNodeList get_TemplateParameters();
    public virtual void set_TemplateParameters(TypeNodeList value);
    public virtual TypeNodeList get_ConsolidatedTemplateParameters();
    public virtual void set_ConsolidatedTemplateParameters(TypeNodeList value);
    public virtual TypeCode get_TypeCode();
    public virtual void GetAbstractMethods(MethodList result);
    public virtual ArrayType GetArrayType(int rank);
    public virtual ArrayType GetArrayType(int rank, bool lowerBoundIsUnknown);
    public virtual ArrayType GetArrayType(int rank, Int32[] sizes, Int32[] loBounds);
    internal ArrayType GetArrayType(int rank, int numSizes, int numLoBounds, Int32[] sizes, Int32[] loBounds);
    public virtual MemberList GetConstructors();
    public virtual InstanceInitializer GetConstructor(TypeNode[] types);
    protected virtual Identifier GetDocumentationId();
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    internal TypeNode GetModified(TypeNode modifierType, bool optionalModifier);
    public static bool IsCompleteTemplate(TypeNode t);
    public virtual TypeNode GetGenericTemplateInstance(Module module, TypeNodeList consolidatedArguments);
    public virtual TypeNode GetTemplateInstance(Module module, TypeNode[] typeArguments);
    protected virtual TypeNode TryToFindExistingInstance(Module module, Identifier uniqueMangledName);
    private Identifier GetUniqueMangledTemplateInstanceName(TypeNodeList templateArguments);
    internal static Identifier GetUniqueMangledTemplateInstanceName(int templateId, TypeNodeList templateArguments);
    public virtual Identifier GetMangledTemplateInstanceName(TypeNodeList templateArguments, Boolean& notFullySpecialized);
    private static bool TypeIsNotFullySpecialized(TypeNode t);
    public virtual TypeNode GetTemplateInstance(TypeNode referringType, TypeNode[] templateArguments);
    public virtual TypeNode GetTemplateInstance(TypeNode referringType, TypeNodeList templateArguments);
    private static int CompareArgs(TypeNodeList templateArguments, TypeNodeList typeNodeList);
    private TypeNode TryToFindExistingInstance(TypeNodeList consolidatedTemplateArguments);
    private void AddInstance(TypeNodeList consolidatedTemplateArguments, TypeNode instance);
    internal void ClearTemplateInstanceCache();
    public virtual TypeNode GetConsolidatedTemplateInstance(Module module, TypeNode referringType, TypeNode declaringType, TypeNodeList templateArguments, TypeNodeList consolidatedTemplateArguments);
    public virtual TypeNode GetTemplateInstance(Module module, TypeNode referringType, TypeNode declaringType, TypeNodeList templateArguments);
    private TypeNode BuildConsolidatedTemplateInstance(Module module, TypeNode referringType, TypeNode declaringType, TypeNodeList templateArguments, TypeNodeList consolidatedTemplateArguments);
    protected virtual TypeNodeList GetConsolidatedTemplateArguments();
    protected virtual TypeNodeList GetConsolidatedTemplateArguments(TypeNodeList typeArgs);
    protected virtual TypeNodeList GetConsolidatedTemplateParameters();
    protected virtual TypeNodeList GetOwnTemplateArguments(TypeNodeList consolidatedTemplateArguments);
    public TypeNode SelfInstantiation();
    public virtual Pointer GetPointerType();
    public virtual Reference GetReferenceType();
    public virtual MemberList GetMembersNamed(Identifier name);
    public virtual Event GetEvent(Identifier name);
    public virtual Field GetField(Identifier name);
    public virtual Method GetMethod(Identifier name, TypeNode[] types);
    private static Method GetFirstMethod(MemberList members, TypeNode[] types);
    public virtual MethodList GetMethods(Identifier name, TypeNode[] types);
    private static MethodList GetMethods(MemberList members, TypeNode[] types);
    public Method GetMatchingMethod(Method method);
    public Method GetExactMatchingMethod(Method method);
    public virtual TypeNode GetNestedType(Identifier name);
    public virtual TypeNodeList get_NestedTypes();
    public virtual void set_NestedTypes(TypeNodeList value);
    public virtual Property GetProperty(Identifier name, TypeNode[] types);
    private static Property GetProperty(MemberList members, TypeNode[] types);
    public virtual MemberList get_ExplicitCoercionMethods();
    public virtual MemberList get_ImplicitCoercionMethods();
    public virtual Method GetExplicitCoercionFromMethod(TypeNode sourceType);
    public virtual Method GetExplicitCoercionToMethod(TypeNode targetType);
    public virtual Method GetImplicitCoercionFromMethod(TypeNode sourceType);
    public virtual Method GetImplicitCoercionToMethod(TypeNode targetType);
    public virtual Method GetOpFalse();
    public virtual Method GetOpTrue();
    public static TypeNode GetTypeNode(Type type);
    public virtual Type GetRuntimeType();
    public static TypeFlags GetVisibilityIntersection(TypeFlags vis1, TypeFlags vis2);
    public bool ImplementsExplicitly(Method method);
    public Method ExplicitImplementation(Method method);
    internal bool ImplementsMethod(Method meth, bool checkPublic);
    public Method GetImplementingMethod(Method meth, bool checkPublic);
    public virtual bool IsAssignableTo(TypeNode targetType, Func`2<TypeNode, TypeNode> targetSubstitution);
    public virtual bool IsAssignableToInstanceOf(TypeNode targetTemplate);
    public virtual bool IsAssignableToInstanceOf(TypeNode targetTemplate, TypeNodeList& templateArguments);
    public virtual bool IsDerivedFrom(TypeNode otherType);
    public virtual bool IsInheritedFrom(TypeNode otherType);
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
    public virtual bool IsStructurallyEquivalentList(TypeNodeList list1, TypeNodeList list2, Func`2<TypeNode, TypeNode> typeSubstitution);
    public static TypeNode StripModifiers(TypeNode type);
    public static TypeNode DeepStripModifiers(TypeNode type);
    public static TypeNode DeepStripModifiers(TypeNode type, TypeNode templateType, TypeNode[] modifiers);
    public static TypeNode DeepStripModifiers(TypeNode type, TypeNode[] modifiers);
    public static bool HasModifier(TypeNode type, TypeNode modifier);
    public static TypeNode StripModifier(TypeNode type, TypeNode modifier);
    public virtual void ClearMemberTable();
    protected virtual void UpdateMemberTable(int range);
    protected static MemberList WeedOutNonSpecialMethods(MemberList members, MethodFlags mask);
    public virtual void WriteDocumentation(XmlTextWriter xwriter);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.TypeNodeList : object {
    private TypeNode[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public TypeNode Item { get; public set; }
    public TypeNodeList(int capacity);
    public TypeNodeList(TypeNode[] elements);
    public void Add(TypeNode element);
    public TypeNodeList Clone();
    public void Insert(TypeNode element, int index);
    public int get_Count();
    public int get_Length();
    public int SearchFor(TypeNode element);
    public TypeNode get_Item(int index);
    public void set_Item(int index, TypeNode value);
    public Enumerator GetEnumerator();
    internal bool Contains(TypeNode asType);
}
public class System.Compiler.TypeParameter : Interface {
    private Member declaringMember;
    private int parameterListIndex;
    private TypeParameterFlags typeParameterFlags;
    protected internal TypeNodeList structuralElementTypes;
    public Member DeclaringMember { get; public set; }
    public int ParameterListIndex { get; public set; }
    public TypeParameterFlags TypeParameterFlags { get; public set; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public bool IsStructural { get; }
    public bool IsTemplateParameter { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public XmlNode Documentation { get; public set; }
    public string HelpText { get; public set; }
    public TypeNodeList StructuralElementTypes { get; }
    private Module System.Compiler.ITypeParameter.DeclaringModule { get; }
    private TypeFlags System.Compiler.ITypeParameter.Flags { get; }
    private SourceContext System.Compiler.ITypeParameter.SourceContext { get; }
    public TypeParameter(InterfaceList baseInterfaces, NestedTypeProvider provideNestedTypes, TypeAttributeProvider provideAttributes, TypeMemberProvider provideMembers, object handle);
    public sealed virtual Member get_DeclaringMember();
    public sealed virtual void set_DeclaringMember(Member value);
    public virtual Type GetRuntimeType();
    public sealed virtual int get_ParameterListIndex();
    public sealed virtual void set_ParameterListIndex(int value);
    public sealed virtual TypeParameterFlags get_TypeParameterFlags();
    public sealed virtual void set_TypeParameterFlags(TypeParameterFlags value);
    public sealed virtual bool get_IsCovariant();
    public sealed virtual bool get_IsContravariant();
    public virtual bool get_IsStructural();
    public virtual bool get_IsTemplateParameter();
    public virtual bool get_IsValueType();
    public virtual bool get_IsReferenceType();
    public virtual XmlNode get_Documentation();
    public virtual void set_Documentation(XmlNode value);
    public virtual string get_HelpText();
    public virtual void set_HelpText(string value);
    public virtual TypeNodeList get_StructuralElementTypes();
    internal virtual void AppendDocumentIdMangledName(StringBuilder sb, TypeNodeList methodTypeParameters, TypeNodeList typeParameters);
    public virtual string GetFullUnmangledNameWithoutTypeParameters();
    public virtual string GetFullUnmangledNameWithTypeParameters();
    public virtual bool IsStructurallyEquivalentTo(TypeNode type, Func`2<TypeNode, TypeNode> typeSubstitution);
    private sealed virtual override Module System.Compiler.ITypeParameter.get_DeclaringModule();
    private sealed virtual override TypeFlags System.Compiler.ITypeParameter.get_Flags();
    private sealed virtual override SourceContext System.Compiler.ITypeParameter.get_SourceContext();
}
[FlagsAttribute]
public enum System.Compiler.TypeParameterFlags : Enum {
    public int value__;
    public static TypeParameterFlags NonVariant;
    public static TypeParameterFlags Covariant;
    public static TypeParameterFlags Contravariant;
    public static TypeParameterFlags VarianceMask;
    public static TypeParameterFlags NoSpecialConstraint;
    public static TypeParameterFlags ReferenceTypeConstraint;
    public static TypeParameterFlags ValueTypeConstraint;
    public static TypeParameterFlags DefaultConstructorConstraint;
    public static TypeParameterFlags SpecialConstraintMask;
}
public class System.Compiler.TypeReference : Node {
    public TypeNode Type;
    public TypeNode Expression;
    public TypeReference(TypeNode typeExpression);
    public TypeReference(TypeNode typeExpression, TypeNode type);
    public static TypeNode op_Explicit(TypeReference typeReference);
    public static bool op_Equality(TypeReference typeReference, TypeNode type);
    public static bool op_Equality(TypeNode type, TypeReference typeReference);
    public static bool op_Inequality(TypeReference typeReference, TypeNode type);
    public static bool op_Inequality(TypeNode type, TypeReference typeReference);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Compiler.TypeUnionExpression : TypeNode {
    public TypeNodeList Types;
    public TypeUnionExpression(TypeNodeList types);
    public TypeUnionExpression(TypeNodeList types, SourceContext sctx);
}
public class System.Compiler.TypeViewer : object {
    public static TypeNode GetTypeView(TypeViewer typeViewer, TypeNode type);
    protected virtual TypeNode GetTypeView(TypeNode type);
}
public class System.Compiler.UnaryExpression : Expression {
    private Expression operand;
    public Expression Operand { get; public set; }
    public UnaryExpression(Expression operand, NodeType nodeType);
    public UnaryExpression(Expression operand, NodeType nodeType, SourceContext sctx);
    public UnaryExpression(Expression operand, NodeType nodeType, TypeNode type);
    public UnaryExpression(Expression operand, NodeType nodeType, TypeNode type, SourceContext sctx);
    public Expression get_Operand();
    public void set_Operand(Expression value);
}
internal class System.Compiler.UnmanagedDocument : Document {
    private Int32List lineList;
    private Int32List columnList;
    private UnmanagedDocument(IntPtr ptrToISymUnmanagedDocument);
    public virtual int GetLine(int offset);
    public virtual int GetColumn(int offset);
    public virtual void GetOffsets(int startLine, int startColumn, int endLine, int endColumn, Int32& startCol, Int32& endCol);
    private static int BinarySearch(Int32List list, int value);
    public virtual void InsertOrDeleteLines(int offset, int lineCount);
    internal int GetOffset(UInt32 line, UInt32 column);
    internal static UnmanagedDocument For(Dictionary`2<IntPtr, UnmanagedDocument> documentCache, IntPtr intPtr);
}
public class System.Compiler.Variable : Expression {
    private Identifier name;
    public TypeNode TypeExpression;
    public Identifier Name { get; public set; }
    public Variable(NodeType type);
    public Identifier get_Name();
    public void set_Name(Identifier value);
}
public abstract class System.Compiler.Visitor : object {
    public abstract virtual Node Visit(Node node);
    public virtual void TransferStateTo(Visitor targetVisitor);
    public virtual ExpressionList VisitExpressionList(ExpressionList list);
}
public class System.Compiler.Win32Resource : ValueType {
    private string typeName;
    private int typeId;
    private string name;
    private int id;
    private int languageId;
    private int codePage;
    private Byte[] data;
    public string TypeName { get; public set; }
    public int TypeId { get; public set; }
    public string Name { get; public set; }
    public int Id { get; public set; }
    public int LanguageId { get; public set; }
    public int CodePage { get; public set; }
    public Byte[] Data { get; public set; }
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TypeId();
    public void set_TypeId(int value);
    public string get_Name();
    public void set_Name(string value);
    public int get_Id();
    public void set_Id(int value);
    public int get_LanguageId();
    public void set_LanguageId(int value);
    public int get_CodePage();
    public void set_CodePage(int value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
}
[DefaultMemberAttribute("Item")]
public class System.Compiler.Win32ResourceList : object {
    private Win32Resource[] elements;
    private int count;
    public int Count { get; }
    [ObsoleteAttribute("Use Count property instead.")]
public int Length { get; }
    public Win32Resource Item { get; public set; }
    public Win32ResourceList(int capacity);
    public void Add(Win32Resource element);
    public Win32ResourceList Clone();
    public int get_Count();
    public int get_Length();
    public Win32Resource get_Item(int index);
    public void set_Item(int index, Win32Resource value);
    public Enumerator GetEnumerator();
}
internal class System.Compiler.Writer : object {
    internal static void WritePE(CompilerParameters compilerParameters, Module module);
    internal static void WritePE(string location, bool writeDebugSymbols, Module module);
    private static void WritePE(string location, bool writeDebugSymbols, Module module, bool delaySign, string keyFileName, string keyName);
    private static Byte[] GetPublicKey(AssemblyNode assem, bool delaySign);
    internal static void WritePE(Stream executable, Stream debugSymbols, Module module);
    internal static void WritePE(Byte[]& executable, Module module);
    internal static void WritePE(Byte[]& executable, Byte[]& debugSymbols, Module module);
    internal static void AddWin32Icon(Module module, string win32IconFilePath);
    internal static void AddWin32Icon(Module module, Stream win32IconStream);
    internal static void AddWin32ResourceFileToModule(Module module, string win32ResourceFilePath);
    internal static void AddWin32ResourceFileToModule(Module module, Stream win32ResourceStream);
    internal static void AddWin32VersionInfo(Module module, CompilerOptions options);
    private static Byte[] FillInVsVersionStructure(Module module, CompilerOptions options);
    private static void WriteVersionString(BinaryWriter data, string value, string key);
    private static string ConvertToString(Version version);
    private static Version ParseVersion(string vString, bool allowWildcards);
    private static ushort DaysSince2000();
    private static ushort SecondsSinceMidnight();
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
