internal enum ImageProcessor.BitDepth : Enum {
    public long value__;
    public static BitDepth Bit1;
    public static BitDepth Bit4;
    public static BitDepth Bit8;
    public static BitDepth Bit16;
    public static BitDepth Bit24;
    public static BitDepth Bit32;
}
public class ImageProcessor.Common.Exceptions.DefaultLogger : object {
    public sealed virtual void Log(string text, string callerName, int lineNumber);
    public sealed virtual void Log(Type type, string text, string callerName, int lineNumber);
    [ConditionalAttribute("TRACE")]
private void LogInternal(Type type, string text, string callerName, int lineNumber);
}
public interface ImageProcessor.Common.Exceptions.ILogger {
    public abstract virtual void Log(string text, string callerName, int lineNumber);
    public abstract virtual void Log(Type type, string text, string callerName, int lineNumber);
}
public class ImageProcessor.Common.Exceptions.ImageFormatException : Exception {
    public ImageFormatException(string message);
    public ImageFormatException(string message, Exception innerException);
    private ImageFormatException(SerializationInfo info, StreamingContext context);
}
public class ImageProcessor.Common.Exceptions.ImageProcessingException : Exception {
    public ImageProcessingException(string message);
    public ImageProcessingException(string message, Exception innerException);
    private ImageProcessingException(SerializationInfo info, StreamingContext context);
}
public class ImageProcessor.Common.Exceptions.QuantizationException : Exception {
    public QuantizationException(string message);
    public QuantizationException(string message, Exception innerException);
    private QuantizationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class ImageProcessor.Common.Extensions.AssemblyExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetLoadableTypes(Assembly assembly);
    [ExtensionAttribute]
public static string GetResourceAsString(Assembly assembly, string resource, Encoding encoding);
    [ExtensionAttribute]
public static FileInfo GetAssemblyFile(Assembly assembly);
    [ExtensionAttribute]
public static FileInfo GetAssemblyFile(AssemblyName assemblyName);
}
[ExtensionAttribute]
public static class ImageProcessor.Common.Extensions.DoubleExtensions : object {
    [ExtensionAttribute]
public static byte ToByte(double value);
}
[ExtensionAttribute]
public static class ImageProcessor.Common.Extensions.EnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<int> SteppedRange(int fromInclusive, int toExclusive, int step);
    [ExtensionAttribute]
public static IEnumerable`1<int> SteppedRange(int fromInclusive, Func`2<int, bool> toDelegate, int step);
    [IteratorStateMachineAttribute("ImageProcessor.Common.Extensions.EnumerableExtensions/<RangeIterator>d__2")]
private static IEnumerable`1<int> RangeIterator(int fromInclusive, Func`2<int, bool> toDelegate, int step);
}
[ExtensionAttribute]
public static class ImageProcessor.Common.Extensions.FloatExtensions : object {
    [ExtensionAttribute]
public static byte ToByte(float value);
}
[ExtensionAttribute]
internal static class ImageProcessor.Common.Extensions.ImageExtensions : object {
    [ExtensionAttribute]
public static Image Copy(Image source, AnimationProcessMode animationProcessMode, PixelFormat format, bool preserveExifData);
    [ExtensionAttribute]
public static Image Copy(Image source, PixelFormat format);
}
[ExtensionAttribute]
public static class ImageProcessor.Common.Extensions.IntegerExtensions : object {
    [ExtensionAttribute]
public static byte ToByte(int value);
}
[ExtensionAttribute]
internal static class ImageProcessor.Common.Extensions.RectangleExtensions : object {
    [ExtensionAttribute]
public static bool IsEqual(Rectangle first, Rectangle second, int threshold);
}
internal static class ImageProcessor.Common.Helpers.IOHelper : object {
    private static string rootDirectory;
    public static string MapPath(string virtualPath);
    public static string GetRootDirectoryBinFolder();
    internal static string GetRootDirectorySafe();
}
internal static class ImageProcessor.Common.Helpers.TypeFinder : object {
    private static HashSet`1<Assembly> LocalFilteredAssemblyCache;
    private static ReaderWriterLockSlim LocalFilteredAssemblyCacheLocker;
    private static ReaderWriterLockSlim Locker;
    private static String[] KnownAssemblyExclusionFilter;
    private static HashSet`1<Assembly> allAssemblies;
    private static HashSet`1<Assembly> binFolderAssemblies;
    private static TypeFinder();
    internal static HashSet`1<Assembly> GetAllAssemblies();
    internal static HashSet`1<Assembly> GetBinAssemblies();
    internal static HashSet`1<Assembly> GetAssembliesWithKnownExclusions(IEnumerable`1<Assembly> excludeFromResults);
    private static IEnumerable`1<Assembly> GetFilteredAssemblies(IEnumerable`1<Assembly> excludeFromResults, String[] exclusionFilter);
}
internal class ImageProcessor.Common.Helpers.UpgradeableReadLock : object {
    private ReaderWriterLockSlim locker;
    private bool upgraded;
    private bool isDisposed;
    public UpgradeableReadLock(ReaderWriterLockSlim locker);
    protected virtual override void Finalize();
    public void UpgradeToWriteLock();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class ImageProcessor.Common.Helpers.WriteLock : object {
    private ReaderWriterLockSlim locker;
    private bool isDisposed;
    public WriteLock(ReaderWriterLockSlim locker);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class ImageProcessor.Configuration.ImageProcessorBootstrapper : object {
    private static Lazy`1<ImageProcessorBootstrapper> Lazy;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISupportedImageFormat> <SupportedImageFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private NativeBinaryFactory <NativeBinaryFactory>k__BackingField;
    public static ImageProcessorBootstrapper Instance { get; }
    public IEnumerable`1<ISupportedImageFormat> SupportedImageFormats { get; private set; }
    public ILogger Logger { get; private set; }
    public NativeBinaryFactory NativeBinaryFactory { get; }
    private static ImageProcessorBootstrapper();
    public static ImageProcessorBootstrapper get_Instance();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISupportedImageFormat> get_SupportedImageFormats();
    [CompilerGeneratedAttribute]
private void set_SupportedImageFormats(IEnumerable`1<ISupportedImageFormat> value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public NativeBinaryFactory get_NativeBinaryFactory();
    public void AddImageFormats(ISupportedImageFormat[] format);
    public void SetLogger(ILogger logger);
    private void LoadSupportedImageFormats();
    private void LoadLogger();
}
public class ImageProcessor.Configuration.NativeBinaryFactory : object {
    private static bool Is64Bit;
    private static ConcurrentDictionary`2<string, IntPtr> nativeBinaries;
    private bool isDisposed;
    public bool Is64BitEnvironment { get; }
    private static NativeBinaryFactory();
    protected virtual override void Finalize();
    public bool get_Is64BitEnvironment();
    public void RegisterNativeBinary(string name, Byte[] resourceBytes);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void FreeNativeBinaries();
}
internal static class ImageProcessor.Configuration.NativeMethods : object {
    public static IntPtr LoadLibrary(string libname);
    public static bool FreeLibrary(IntPtr hModule);
    public static IntPtr dlopen(string libname, int flags);
    public static int dlclose(IntPtr hModule);
}
public class ImageProcessor.ImageFactory : object {
    private static int DefaultQuality;
    private bool preserveExifData;
    private ISupportedImageFormat backupFormat;
    private ConcurrentDictionary`2<int, PropertyItem> backupExifPropertyItems;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private long <CurrentBitDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private ISupportedImageFormat <CurrentImageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private MetaDataMode <MetaDataMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixGamma>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CurrentGamma>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<int, PropertyItem> <ExifPropertyItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Image <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private AnimationProcessMode <AnimationProcessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <InputStream>k__BackingField;
    public long CurrentBitDepth { get; internal set; }
    public string ImagePath { get; private set; }
    public bool ShouldProcess { get; private set; }
    public ISupportedImageFormat CurrentImageFormat { get; private set; }
    public MetaDataMode MetaDataMode { get; private set; }
    public bool PreserveExifData { get; public set; }
    public bool FixGamma { get; public set; }
    public float CurrentGamma { get; private set; }
    public ConcurrentDictionary`2<int, PropertyItem> ExifPropertyItems { get; public set; }
    public Image Image { get; internal set; }
    public AnimationProcessMode AnimationProcessMode { get; public set; }
    internal Stream InputStream { get; internal set; }
    public ImageFactory(bool preserveExifData);
    public ImageFactory(bool preserveExifData, bool fixGamma);
    public ImageFactory(MetaDataMode metaDataMode);
    public ImageFactory(MetaDataMode metaDataMode, bool fixGamma);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public long get_CurrentBitDepth();
    [CompilerGeneratedAttribute]
internal void set_CurrentBitDepth(long value);
    [CompilerGeneratedAttribute]
public string get_ImagePath();
    [CompilerGeneratedAttribute]
private void set_ImagePath(string value);
    [CompilerGeneratedAttribute]
public bool get_ShouldProcess();
    [CompilerGeneratedAttribute]
private void set_ShouldProcess(bool value);
    [CompilerGeneratedAttribute]
public ISupportedImageFormat get_CurrentImageFormat();
    [CompilerGeneratedAttribute]
private void set_CurrentImageFormat(ISupportedImageFormat value);
    [CompilerGeneratedAttribute]
public MetaDataMode get_MetaDataMode();
    [CompilerGeneratedAttribute]
private void set_MetaDataMode(MetaDataMode value);
    public bool get_PreserveExifData();
    public void set_PreserveExifData(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixGamma();
    [CompilerGeneratedAttribute]
public void set_FixGamma(bool value);
    [CompilerGeneratedAttribute]
public float get_CurrentGamma();
    [CompilerGeneratedAttribute]
private void set_CurrentGamma(float value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<int, PropertyItem> get_ExifPropertyItems();
    [CompilerGeneratedAttribute]
public void set_ExifPropertyItems(ConcurrentDictionary`2<int, PropertyItem> value);
    [CompilerGeneratedAttribute]
public Image get_Image();
    [CompilerGeneratedAttribute]
internal void set_Image(Image value);
    [CompilerGeneratedAttribute]
public AnimationProcessMode get_AnimationProcessMode();
    [CompilerGeneratedAttribute]
public void set_AnimationProcessMode(AnimationProcessMode value);
    [CompilerGeneratedAttribute]
internal Stream get_InputStream();
    [CompilerGeneratedAttribute]
internal void set_InputStream(Stream value);
    public ImageFactory Load(Stream stream);
    public ImageFactory Load(string imagePath);
    public ImageFactory Load(Byte[] bytes);
    public ImageFactory Load(Image image);
    public ImageFactory Reset();
    public ImageFactory Alpha(int percentage);
    public ImageFactory AutoRotate();
    public ImageFactory BitDepth(long bitDepth);
    public ImageFactory Brightness(int percentage);
    public ImageFactory BackgroundColor(Color color);
    public ImageFactory Constrain(Size size);
    public ImageFactory Contrast(int percentage);
    public ImageFactory Crop(Rectangle rectangle);
    public ImageFactory Crop(CropLayer cropLayer);
    public ImageFactory DetectEdges(IEdgeFilter filter, bool greyscale);
    public ImageFactory Resolution(int horizontal, int vertical, PropertyTagResolutionUnit unit);
    public ImageFactory EntropyCrop(byte threshold);
    public ImageFactory Filter(IMatrixFilter matrixFilter);
    public ImageFactory Flip(bool flipVertically, bool flipBoth);
    public ImageFactory Format(ISupportedImageFormat format);
    public ImageFactory Gamma(float value);
    public ImageFactory GaussianBlur(int size);
    public ImageFactory GaussianBlur(GaussianLayer gaussianLayer);
    public ImageFactory GaussianSharpen(int size);
    public ImageFactory GaussianSharpen(GaussianLayer gaussianLayer);
    public ImageFactory Hue(int degrees, bool rotate);
    public ImageFactory Halftone(bool comicMode);
    public ImageFactory Mask(ImageLayer imageLayer);
    public ImageFactory Overlay(ImageLayer imageLayer);
    public ImageFactory Pixelate(int pixelSize, Nullable`1<Rectangle> rectangle);
    public ImageFactory Quality(int percentage);
    public ImageFactory ReplaceColor(Color target, Color replacement, int fuzziness);
    public ImageFactory Resize(Size size);
    public ImageFactory Resize(ResizeLayer resizeLayer);
    public ImageFactory Rotate(float degrees);
    public ImageFactory RotateBounded(float degrees, bool keepSize);
    public ImageFactory RoundedCorners(int radius);
    public ImageFactory RoundedCorners(RoundedCornerLayer roundedCornerLayer);
    public ImageFactory Saturation(int percentage);
    public ImageFactory Tint(Color color);
    public ImageFactory Vignette(Nullable`1<Color> color);
    public ImageFactory Watermark(TextLayer textLayer);
    public ImageFactory Save(string filePath);
    public ImageFactory Save(Stream stream);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void SetMetaData();
}
public enum ImageProcessor.Imaging.AnchorPosition : Enum {
    public int value__;
    public static AnchorPosition Center;
    public static AnchorPosition Top;
    public static AnchorPosition Bottom;
    public static AnchorPosition Left;
    public static AnchorPosition Right;
    public static AnchorPosition TopLeft;
    public static AnchorPosition TopRight;
    public static AnchorPosition BottomRight;
    public static AnchorPosition BottomLeft;
}
public enum ImageProcessor.Imaging.AnimationProcessMode : Enum {
    public int value__;
    public static AnimationProcessMode All;
    public static AnimationProcessMode First;
}
[IsReadOnlyAttribute]
public class ImageProcessor.Imaging.Colors.CmykColor : ValueType {
    public static CmykColor Empty;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <M>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <K>k__BackingField;
    public float C { get; }
    public float M { get; }
    public float Y { get; }
    public float K { get; }
    private CmykColor(float cyan, float magenta, float yellow, float keyline);
    private CmykColor(Color color);
    private static CmykColor();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_M();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_K();
    public static CmykColor FromCmykColor(float cyan, float magenta, float yellow, float keyline);
    public static CmykColor FromColor(Color color);
    public static CmykColor op_Implicit(Color color);
    public static CmykColor op_Implicit(RgbaColor rgbaColor);
    public static CmykColor op_Implicit(YCbCrColor ycbcrColor);
    public static Color op_Implicit(CmykColor cmykColor);
    public static RgbaColor op_Implicit(CmykColor cmykColor);
    public static YCbCrColor op_Implicit(CmykColor cmykColor);
    public static HslaColor op_Implicit(CmykColor cmykColor);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CmykColor other);
    public virtual int GetHashCode();
    private static float Clamp(float value);
    private bool IsEmpty();
}
public class ImageProcessor.Imaging.Colors.Color32 : ValueType {
    public byte B;
    public byte G;
    public byte R;
    public byte A;
    public int Argb;
    public Color Color { get; }
    public Color32(byte alpha, byte red, byte green, byte blue);
    public Color32(int argb);
    public Color get_Color();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Color32 other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class ImageProcessor.Imaging.Colors.ColorExtensions : object {
    [ExtensionAttribute]
public static Color Add(Color color, Color[] colors);
    [ExtensionAttribute]
public static CmykColor AddAsCmykColor(Color color, Color[] colors);
}
[IsReadOnlyAttribute]
public class ImageProcessor.Imaging.Colors.HslaColor : ValueType {
    public static HslaColor Empty;
    [CompilerGeneratedAttribute]
private float <H>k__BackingField;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <S>k__BackingField;
    [CompilerGeneratedAttribute]
private float <A>k__BackingField;
    public float H { get; }
    public float L { get; }
    public float S { get; }
    public float A { get; }
    private HslaColor(float hue, float saturation, float luminosity, float alpha);
    private HslaColor(Color color);
    private static HslaColor();
    [CompilerGeneratedAttribute]
public float get_H();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_S();
    [CompilerGeneratedAttribute]
public float get_A();
    public static HslaColor FromHslaColor(float hue, float saturation, float luminosity);
    public static HslaColor FromHslaColor(float hue, float saturation, float luminosity, float alpha);
    public static HslaColor FromColor(Color color);
    public static HslaColor op_Implicit(Color color);
    public static HslaColor op_Implicit(RgbaColor rgbaColor);
    public static HslaColor op_Implicit(YCbCrColor ycbcrColor);
    public static Color op_Implicit(HslaColor hslaColor);
    public static YCbCrColor op_Implicit(HslaColor hslaColor);
    public static CmykColor op_Implicit(HslaColor hslaColor);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HslaColor other);
    public virtual int GetHashCode();
    private static float GetColorComponent(float temp1, float temp2, float temp3);
    private static float GetTemp2(HslaColor& hslColor);
    private static float MoveIntoRange(float temp3);
    private static float Clamp(float value);
    private bool IsEmpty();
}
[IsReadOnlyAttribute]
public class ImageProcessor.Imaging.Colors.RgbaColor : ValueType {
    public static RgbaColor Empty;
    [CompilerGeneratedAttribute]
private byte <R>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <G>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <B>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <A>k__BackingField;
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public byte A { get; }
    private RgbaColor(byte red, byte green, byte blue, byte alpha);
    private RgbaColor(Color color);
    private static RgbaColor();
    [CompilerGeneratedAttribute]
public byte get_R();
    [CompilerGeneratedAttribute]
public byte get_G();
    [CompilerGeneratedAttribute]
public byte get_B();
    [CompilerGeneratedAttribute]
public byte get_A();
    public static RgbaColor FromRgba(byte red, byte green, byte blue);
    public static RgbaColor FromRgba(byte red, byte green, byte blue, byte alpha);
    public static RgbaColor FromColor(Color color);
    public static RgbaColor op_Implicit(Color color);
    public static RgbaColor op_Implicit(HslaColor hslaColor);
    public static RgbaColor op_Implicit(YCbCrColor ycbcrColor);
    public static Color op_Implicit(RgbaColor rgbaColor);
    public static YCbCrColor op_Implicit(RgbaColor rgbaColor);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RgbaColor other);
    public virtual int GetHashCode();
}
public enum ImageProcessor.Imaging.Colors.RgbaComponent : Enum {
    public int value__;
    public static RgbaComponent B;
    public static RgbaComponent G;
    public static RgbaComponent R;
    public static RgbaComponent A;
}
[IsReadOnlyAttribute]
public class ImageProcessor.Imaging.Colors.YCbCrColor : ValueType {
    public static YCbCrColor Empty;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cb>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cr>k__BackingField;
    public float Y { get; }
    public float Cb { get; }
    public float Cr { get; }
    private YCbCrColor(float y, float cb, float cr);
    private static YCbCrColor();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_Cb();
    [CompilerGeneratedAttribute]
public float get_Cr();
    public static YCbCrColor FromYCbCr(float y, float cb, float cr);
    public static YCbCrColor FromColor(Color color);
    public static YCbCrColor op_Implicit(Color color);
    public static YCbCrColor op_Implicit(RgbaColor rgbaColor);
    public static YCbCrColor op_Implicit(HslaColor hslaColor);
    public static Color op_Implicit(YCbCrColor ycbcrColor);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(YCbCrColor other);
    public virtual int GetHashCode();
    private bool IsEmpty();
}
public class ImageProcessor.Imaging.ComputerArchitectureInfo : object {
    public sealed virtual bool IsLittleEndian();
}
public class ImageProcessor.Imaging.Convolution : object {
    private double standardDeviation;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Divider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDynamicDividerForEdges>k__BackingField;
    public int Threshold { get; public set; }
    public double Divider { get; public set; }
    public bool UseDynamicDividerForEdges { get; public set; }
    public Convolution(double standardDeviation);
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(int value);
    [CompilerGeneratedAttribute]
public double get_Divider();
    [CompilerGeneratedAttribute]
public void set_Divider(double value);
    [CompilerGeneratedAttribute]
public bool get_UseDynamicDividerForEdges();
    [CompilerGeneratedAttribute]
public void set_UseDynamicDividerForEdges(bool value);
    public Double[0...,0...] CreateGaussianKernel(int kernelSize);
    public Double[0...,0...] CreateGaussianKernel2D(int kernelSize);
    public Double[0...,0...] CreateGuassianBlurFilter(int kernelSize);
    public Double[0...,0...] CreateGuassianSharpenFilter(int kernelSize);
    public Bitmap ProcessKernel(Bitmap source, Double[0...,0...] kernel, bool fixGamma);
    public Color[0...,0...] ProcessKernel(Color[0...,0...] source, Double[0...,0...] kernel, bool fixGamma);
    private double Gaussian(double x);
    private double Gaussian2D(double x, double y);
}
public class ImageProcessor.Imaging.CropLayer : object {
    [CompilerGeneratedAttribute]
private float <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Bottom>k__BackingField;
    [CompilerGeneratedAttribute]
private CropMode <CropMode>k__BackingField;
    public float Left { get; public set; }
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public CropMode CropMode { get; public set; }
    public CropLayer(float left, float top, float right, float bottom, CropMode cropMode);
    [CompilerGeneratedAttribute]
public float get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(float value);
    [CompilerGeneratedAttribute]
public float get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(float value);
    [CompilerGeneratedAttribute]
public float get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(float value);
    [CompilerGeneratedAttribute]
public float get_Bottom();
    [CompilerGeneratedAttribute]
public void set_Bottom(float value);
    [CompilerGeneratedAttribute]
public CropMode get_CropMode();
    [CompilerGeneratedAttribute]
public void set_CropMode(CropMode value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CropLayer other);
    public virtual int GetHashCode();
}
public enum ImageProcessor.Imaging.CropMode : Enum {
    public int value__;
    public static CropMode Pixels;
    public static CropMode Percentage;
}
[DefaultMemberAttribute("Item")]
public class ImageProcessor.Imaging.FastBitmap : object {
    private static int Format8bppIndexed;
    private static int Format24bppRgb;
    private static int Format32bppArgb;
    private static int Format32bppPArgb;
    private Bitmap bitmap;
    private int channel;
    private bool computeIntegrals;
    private bool computeTilted;
    private Int64[0...,0...] normalSumImage;
    private Int64[0...,0...] squaredSumImage;
    private Int64[0...,0...] tiltedSumImage;
    private int normalWidth;
    private int tiltedWidth;
    private int bytesInARow;
    private Int64* normalSum;
    private Int64* squaredSum;
    private Int64* tiltedSum;
    private GCHandle normalSumHandle;
    private GCHandle squaredSumHandle;
    private GCHandle tiltedSumHandle;
    private int pixelSize;
    private BitmapData bitmapData;
    private Byte* pixelBase;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    public Int64[0...,0...] NormalImage { get; }
    public Int64[0...,0...] SquaredImage { get; }
    public Int64[0...,0...] TiltedImage { get; }
    private Color32* Item { get; }
    public FastBitmap(Image bitmap);
    public FastBitmap(Image bitmap, bool computeIntegrals);
    public FastBitmap(Image bitmap, bool computeIntegrals, bool computeTilted);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    public Int64[0...,0...] get_NormalImage();
    public Int64[0...,0...] get_SquaredImage();
    public Int64[0...,0...] get_TiltedImage();
    private Color32* get_Item(int x, int y);
    public static Image op_Implicit(FastBitmap fastBitmap);
    public static Bitmap op_Implicit(FastBitmap fastBitmap);
    public Color GetPixel(int x, int y);
    public void SetPixel(int x, int y, Color color);
    public long GetSum(int x, int y, int rectangleWidth, int rectangleHeight);
    public long GetSum2(int x, int y, int rectangleWidth, int rectangleHeight);
    public long GetSumT(int x, int y, int rectangleWidth, int rectangleHeight);
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FastBitmap other);
    public virtual int GetHashCode();
    protected virtual void Dispose(bool disposing);
    private void LockBitmap();
    private void CalculateIntegrals();
    private void UnlockBitmap();
}
public class ImageProcessor.Imaging.Filters.Artistic.HalftoneFilter : object {
    [CompilerGeneratedAttribute]
private float <CyanAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MagentaAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <YellowAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <KeylineAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Distance>k__BackingField;
    public float CyanAngle { get; public set; }
    public float MagentaAngle { get; public set; }
    public float YellowAngle { get; public set; }
    public float KeylineAngle { get; public set; }
    public int Distance { get; public set; }
    public HalftoneFilter(int distance);
    [CompilerGeneratedAttribute]
public float get_CyanAngle();
    [CompilerGeneratedAttribute]
public void set_CyanAngle(float value);
    [CompilerGeneratedAttribute]
public float get_MagentaAngle();
    [CompilerGeneratedAttribute]
public void set_MagentaAngle(float value);
    [CompilerGeneratedAttribute]
public float get_YellowAngle();
    [CompilerGeneratedAttribute]
public void set_YellowAngle(float value);
    [CompilerGeneratedAttribute]
public float get_KeylineAngle();
    [CompilerGeneratedAttribute]
public void set_KeylineAngle(float value);
    [CompilerGeneratedAttribute]
public int get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(int value);
    public Bitmap ApplyFilter(Bitmap source);
    private Rectangle GetBoundingRectangle(int width, int height);
}
public class ImageProcessor.Imaging.Filters.Artistic.OilPaintingFilter : object {
    private int levels;
    private int brushSize;
    public int Levels { get; public set; }
    public int BrushSize { get; public set; }
    public OilPaintingFilter(int levels, int brushSize);
    public int get_Levels();
    public void set_Levels(int value);
    public int get_BrushSize();
    public void set_BrushSize(int value);
    public Bitmap ApplyFilter(Bitmap source);
}
public class ImageProcessor.Imaging.Filters.Binarization.BinaryThreshold : object {
    [CompilerGeneratedAttribute]
private byte <Threshold>k__BackingField;
    public byte Threshold { get; public set; }
    public BinaryThreshold(byte threshold);
    [CompilerGeneratedAttribute]
public byte get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(byte value);
    public Bitmap ProcessFilter(Bitmap source);
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.ConvolutionFilter : object {
    private IEdgeFilter edgeFilter;
    private bool greyscale;
    public ConvolutionFilter(IEdgeFilter edgeFilter, bool greyscale);
    public Bitmap ProcessFilter(Image source);
    public Bitmap Process2DFilter(Image source);
}
public interface ImageProcessor.Imaging.Filters.EdgeDetection.I2DEdgeFilter {
    public Double[0...,0...] VerticalGradientOperator { get; }
    public abstract virtual Double[0...,0...] get_VerticalGradientOperator();
}
public interface ImageProcessor.Imaging.Filters.EdgeDetection.IEdgeFilter {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public abstract virtual Double[0...,0...] get_HorizontalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.KayyaliEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.KirschEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.Laplacian3X3EdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.Laplacian5X5EdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.LaplacianOfGaussianEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.PrewittEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.RobertsCrossEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.ScharrEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
public class ImageProcessor.Imaging.Filters.EdgeDetection.SobelEdgeFilter : object {
    public Double[0...,0...] HorizontalGradientOperator { get; }
    public Double[0...,0...] VerticalGradientOperator { get; }
    public sealed virtual Double[0...,0...] get_HorizontalGradientOperator();
    public sealed virtual Double[0...,0...] get_VerticalGradientOperator();
}
internal class ImageProcessor.Imaging.Filters.Photo.BlackWhiteMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal static class ImageProcessor.Imaging.Filters.Photo.ColorMatrixes : object {
    private static ColorMatrix blackWhite;
    private static ColorMatrix comicHigh;
    private static ColorMatrix comicLow;
    private static ColorMatrix greyScale;
    private static ColorMatrix hiSatch;
    private static ColorMatrix invert;
    private static ColorMatrix lomograph;
    private static ColorMatrix loSatch;
    private static ColorMatrix polaroid;
    private static ColorMatrix sepia;
    internal static ColorMatrix BlackWhite { get; }
    internal static ColorMatrix ComicHigh { get; }
    internal static ColorMatrix ComicLow { get; }
    internal static ColorMatrix GreyScale { get; }
    internal static ColorMatrix HiSatch { get; }
    internal static ColorMatrix Invert { get; }
    internal static ColorMatrix Lomograph { get; }
    internal static ColorMatrix LoSatch { get; }
    internal static ColorMatrix Polaroid { get; }
    internal static ColorMatrix Sepia { get; }
    internal static ColorMatrix get_BlackWhite();
    internal static ColorMatrix get_ComicHigh();
    internal static ColorMatrix get_ComicLow();
    internal static ColorMatrix get_GreyScale();
    internal static ColorMatrix get_HiSatch();
    internal static ColorMatrix get_Invert();
    internal static ColorMatrix get_Lomograph();
    internal static ColorMatrix get_LoSatch();
    internal static ColorMatrix get_Polaroid();
    internal static ColorMatrix get_Sepia();
}
internal class ImageProcessor.Imaging.Filters.Photo.ComicMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.GothamMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.GreyScaleMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.HiSatchMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
public interface ImageProcessor.Imaging.Filters.Photo.IMatrixFilter {
    public ColorMatrix Matrix { get; }
    public abstract virtual ColorMatrix get_Matrix();
    public abstract virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.InvertMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.LomographMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.LoSatchMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
public abstract class ImageProcessor.Imaging.Filters.Photo.MatrixFilterBase : object {
    public ColorMatrix Matrix { get; }
    public abstract virtual ColorMatrix get_Matrix();
    public abstract virtual Bitmap TransformImage(Image source, Image destination);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IMatrixFilter other);
    public virtual int GetHashCode();
}
public static class ImageProcessor.Imaging.Filters.Photo.MatrixFilters : object {
    public static IMatrixFilter BlackWhite { get; }
    public static IMatrixFilter Comic { get; }
    public static IMatrixFilter Gotham { get; }
    public static IMatrixFilter GreyScale { get; }
    public static IMatrixFilter HiSatch { get; }
    public static IMatrixFilter Invert { get; }
    public static IMatrixFilter Lomograph { get; }
    public static IMatrixFilter LoSatch { get; }
    public static IMatrixFilter Polaroid { get; }
    public static IMatrixFilter Sepia { get; }
    public static IMatrixFilter get_BlackWhite();
    public static IMatrixFilter get_Comic();
    public static IMatrixFilter get_Gotham();
    public static IMatrixFilter get_GreyScale();
    public static IMatrixFilter get_HiSatch();
    public static IMatrixFilter get_Invert();
    public static IMatrixFilter get_Lomograph();
    public static IMatrixFilter get_LoSatch();
    public static IMatrixFilter get_Polaroid();
    public static IMatrixFilter get_Sepia();
}
internal class ImageProcessor.Imaging.Filters.Photo.PolaroidMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
internal class ImageProcessor.Imaging.Filters.Photo.SepiaMatrixFilter : MatrixFilterBase {
    public ColorMatrix Matrix { get; }
    public virtual ColorMatrix get_Matrix();
    public virtual Bitmap TransformImage(Image source, Image destination);
}
public class ImageProcessor.Imaging.Formats.BitmapFormat : FormatBase {
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public ImageFormat ImageFormat { get; }
    public virtual Byte[][] get_FileHeaders();
    public virtual String[] get_FileExtensions();
    public virtual string get_MimeType();
    public virtual ImageFormat get_ImageFormat();
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
}
public abstract class ImageProcessor.Imaging.Formats.FormatBase : object {
    [CompilerGeneratedAttribute]
private bool <IsIndexed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Quality>k__BackingField;
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public string DefaultExtension { get; }
    public ImageFormat ImageFormat { get; }
    public bool IsIndexed { get; public set; }
    public int Quality { get; public set; }
    public abstract virtual Byte[][] get_FileHeaders();
    public abstract virtual String[] get_FileExtensions();
    public abstract virtual string get_MimeType();
    public sealed virtual string get_DefaultExtension();
    public abstract virtual ImageFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexed();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsIndexed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Quality();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Quality(int value);
    public virtual void ApplyProcessor(Func`2<ImageFactory, Image> processor, ImageFactory factory);
    public virtual Image Load(Stream stream);
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ISupportedImageFormat other);
    public virtual int GetHashCode();
}
public static class ImageProcessor.Imaging.Formats.FormatUtilities : object {
    public static ISupportedImageFormat GetFormat(Stream stream);
    public static bool IsIndexed(Image image);
    public static bool HasAlpha(Image image);
    public static bool IsAnimated(Image image);
    public static EncoderParameters GetEncodingParameters(int quality);
    public static PropertyItem CreatePropertyItem();
}
public class ImageProcessor.Imaging.Formats.GifDecoder : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnimated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoopCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrameCount>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool IsAnimated { get; public set; }
    public int LoopCount { get; public set; }
    public int FrameCount { get; public set; }
    public GifDecoder(Image image);
    public GifDecoder(Image image, AnimationProcessMode animationProcessMode);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public bool get_IsAnimated();
    [CompilerGeneratedAttribute]
public void set_IsAnimated(bool value);
    [CompilerGeneratedAttribute]
public int get_LoopCount();
    [CompilerGeneratedAttribute]
public void set_LoopCount(int value);
    [CompilerGeneratedAttribute]
public int get_FrameCount();
    [CompilerGeneratedAttribute]
public void set_FrameCount(int value);
    public GifFrame GetFrame(Image image, int index);
}
public class ImageProcessor.Imaging.Formats.GifEncoder : object {
    private static byte ApplicationBlockSize;
    private static int ApplicationExtensionBlockIdentifier;
    private static string ApplicationIdentification;
    private static byte FileTrailer;
    private static string FileType;
    private static string FileVersion;
    private static int GraphicControlExtensionBlockIdentifier;
    private static byte GraphicControlExtensionBlockSize;
    private static long SourceColorBlockLength;
    private static long SourceColorBlockPosition;
    private static long SourceGlobalColorInfoPosition;
    private static long SourceGraphicControlExtensionLength;
    private static long SourceGraphicControlExtensionPosition;
    private static long SourceImageBlockHeaderLength;
    private static long SourceImageBlockPosition;
    private static ImageConverter Converter;
    private MemoryStream imageStream;
    private Nullable`1<int> height;
    private bool isFirstImage;
    private Nullable`1<int> repeatCount;
    private Nullable`1<int> width;
    private bool terminated;
    [CompilerGeneratedAttribute]
private Byte[] <ImageBytes>k__BackingField;
    public Byte[] ImageBytes { get; public set; }
    public GifEncoder(Nullable`1<int> width, Nullable`1<int> height, Nullable`1<int> repeatCount);
    private static GifEncoder();
    [CompilerGeneratedAttribute]
public Byte[] get_ImageBytes();
    [CompilerGeneratedAttribute]
public void set_ImageBytes(Byte[] value);
    public void AddFrame(GifFrame frame);
    public Image Save();
    public void Save(Stream stream);
    private void WriteHeaderBlock(Stream sourceGif, int w, int h);
    private void WriteByte(int value);
    private void WriteColorTable(Stream sourceGif);
    private void WriteGraphicControlBlock(Stream sourceGif, int frameDelay);
    private void WriteImageBlock(Stream sourceGif, bool includeColorTable, int x, int y, int h, int w);
    private void WriteShort(int value);
    private void WriteString(string value);
}
public class ImageProcessor.Imaging.Formats.GifFormat : FormatBase {
    [CompilerGeneratedAttribute]
private AnimationProcessMode <AnimationProcessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IQuantizer <Quantizer>k__BackingField;
    public AnimationProcessMode AnimationProcessMode { get; public set; }
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public ImageFormat ImageFormat { get; }
    public IQuantizer Quantizer { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual AnimationProcessMode get_AnimationProcessMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AnimationProcessMode(AnimationProcessMode value);
    public virtual Byte[][] get_FileHeaders();
    public virtual String[] get_FileExtensions();
    public virtual string get_MimeType();
    public virtual ImageFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public sealed virtual IQuantizer get_Quantizer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Quantizer(IQuantizer value);
    public virtual void ApplyProcessor(Func`2<ImageFactory, Image> processor, ImageFactory factory);
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
}
public class ImageProcessor.Imaging.Formats.GifFrame : object {
    [CompilerGeneratedAttribute]
private Image <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    public Image Image { get; public set; }
    public TimeSpan Delay { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    [CompilerGeneratedAttribute]
public Image get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(Image value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
}
public interface ImageProcessor.Imaging.Formats.IAnimatedImageFormat {
    public AnimationProcessMode AnimationProcessMode { get; public set; }
    public abstract virtual AnimationProcessMode get_AnimationProcessMode();
    public abstract virtual void set_AnimationProcessMode(AnimationProcessMode value);
}
public interface ImageProcessor.Imaging.Formats.IQuantizableImageFormat {
    public IQuantizer Quantizer { get; public set; }
    public abstract virtual IQuantizer get_Quantizer();
    public abstract virtual void set_Quantizer(IQuantizer value);
}
public interface ImageProcessor.Imaging.Formats.ISupportedImageFormat {
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public string DefaultExtension { get; }
    public ImageFormat ImageFormat { get; }
    public bool IsIndexed { get; public set; }
    public int Quality { get; public set; }
    public abstract virtual Byte[][] get_FileHeaders();
    public abstract virtual String[] get_FileExtensions();
    public abstract virtual string get_MimeType();
    public abstract virtual string get_DefaultExtension();
    public abstract virtual ImageFormat get_ImageFormat();
    public abstract virtual bool get_IsIndexed();
    public abstract virtual void set_IsIndexed(bool value);
    public abstract virtual int get_Quality();
    public abstract virtual void set_Quality(int value);
    public abstract virtual void ApplyProcessor(Func`2<ImageFactory, Image> processor, ImageFactory factory);
    public abstract virtual Image Load(Stream stream);
    public abstract virtual Image Save(Stream stream, Image image, long bitDepth);
    public abstract virtual Image Save(string path, Image image, long bitDepth);
}
public class ImageProcessor.Imaging.Formats.JpegFormat : FormatBase {
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public ImageFormat ImageFormat { get; }
    public virtual Byte[][] get_FileHeaders();
    public virtual String[] get_FileExtensions();
    public virtual string get_MimeType();
    public virtual ImageFormat get_ImageFormat();
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
    [CompilerGeneratedAttribute]
private bool <Save>b__8_0(ImageCodecInfo ici);
    [CompilerGeneratedAttribute]
private bool <Save>b__9_0(ImageCodecInfo ici);
}
public class ImageProcessor.Imaging.Formats.PngFormat : FormatBase {
    [CompilerGeneratedAttribute]
private IQuantizer <Quantizer>k__BackingField;
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public ImageFormat ImageFormat { get; }
    public IQuantizer Quantizer { get; public set; }
    public virtual Byte[][] get_FileHeaders();
    public virtual String[] get_FileExtensions();
    public virtual string get_MimeType();
    public virtual ImageFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public sealed virtual IQuantizer get_Quantizer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Quantizer(IQuantizer value);
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
}
public class ImageProcessor.Imaging.Formats.TiffFormat : FormatBase {
    public Byte[][] FileHeaders { get; }
    public String[] FileExtensions { get; }
    public string MimeType { get; }
    public ImageFormat ImageFormat { get; }
    public virtual Byte[][] get_FileHeaders();
    public virtual String[] get_FileExtensions();
    public virtual string get_MimeType();
    public virtual ImageFormat get_ImageFormat();
    public virtual void ApplyProcessor(Func`2<ImageFactory, Image> processor, ImageFactory factory);
    public virtual Image Save(Stream stream, Image image, long bitDepth);
    public virtual Image Save(string path, Image image, long bitDepth);
    [CompilerGeneratedAttribute]
private bool <Save>b__9_0(ImageCodecInfo ici);
    [CompilerGeneratedAttribute]
private bool <Save>b__10_0(ImageCodecInfo ici);
}
public class ImageProcessor.Imaging.GaussianLayer : object {
    private int size;
    private double sigma;
    private int threshold;
    public int Size { get; public set; }
    public double Sigma { get; public set; }
    public int Threshold { get; public set; }
    public GaussianLayer(int size, double sigma, int threshold);
    public int get_Size();
    public void set_Size(int value);
    public double get_Sigma();
    public void set_Sigma(double value);
    public int get_Threshold();
    public void set_Threshold(int value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GaussianLayer other);
    public virtual int GetHashCode();
}
public static class ImageProcessor.Imaging.Helpers.Adjustments : object {
    private static Lazy`1<Byte[]> LinearBytes;
    private static Lazy`1<Byte[]> SRGBBytes;
    private static Adjustments();
    public static Bitmap Alpha(Image source, int percentage, Nullable`1<Rectangle> rectangle);
    public static Bitmap Brightness(Image source, int threshold, Nullable`1<Rectangle> rectangle);
    public static Bitmap Contrast(Image source, int threshold, Nullable`1<Rectangle> rectangle);
    public static Bitmap Gamma(Image source, float value);
    public static Bitmap ToLinear(Image source);
    public static Bitmap ToSRGB(Image source);
    private static Byte[] GetLinearBytes();
    private static Byte[] GetSRGBBytes();
    private static double SRGBToLinear(double signal);
    private static double LinearToSRGB(double signal);
}
internal class ImageProcessor.Imaging.Helpers.BigEndianBitConverter : EndianBitConverter {
    public Endianness Endianness { get; }
    public virtual Endianness get_Endianness();
    public virtual bool IsLittleEndian();
    protected internal virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    protected internal virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
}
public static class ImageProcessor.Imaging.Helpers.Effects : object {
    public static Bitmap Vignette(Image source, Color baseColor, Nullable`1<Rectangle> rectangle, bool invert);
    public static Bitmap Glow(Image source, Color baseColor, Nullable`1<Rectangle> rectangle);
    public static Bitmap ApplyMask(Image source, Image mask);
    public static Bitmap Trace(Image source, Image destination, byte threshold);
}
internal abstract class ImageProcessor.Imaging.Helpers.EndianBitConverter : object {
    [CompilerGeneratedAttribute]
private static LittleEndianBitConverter <Little>k__BackingField;
    [CompilerGeneratedAttribute]
private static BigEndianBitConverter <Big>k__BackingField;
    public Endianness Endianness { get; }
    public static LittleEndianBitConverter Little { get; }
    public static BigEndianBitConverter Big { get; }
    private static EndianBitConverter();
    public abstract virtual bool IsLittleEndian();
    public abstract virtual Endianness get_Endianness();
    [CompilerGeneratedAttribute]
public static LittleEndianBitConverter get_Little();
    [CompilerGeneratedAttribute]
public static BigEndianBitConverter get_Big();
    public long DoubleToInt64Bits(double value);
    public double Int64BitsToDouble(long value);
    public int SingleToInt32Bits(float value);
    public float Int32BitsToSingle(int value);
    public bool ToBoolean(Byte[] value, int startIndex);
    public char ToChar(Byte[] value, int startIndex);
    public double ToDouble(Byte[] value, int startIndex);
    public float ToSingle(Byte[] value, int startIndex);
    public short ToInt16(Byte[] value, int startIndex);
    public int ToInt32(Byte[] value, int startIndex);
    public long ToInt64(Byte[] value, int startIndex);
    public ushort ToUInt16(Byte[] value, int startIndex);
    public UInt32 ToUInt32(Byte[] value, int startIndex);
    public ulong ToUInt64(Byte[] value, int startIndex);
    protected internal abstract virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
    private static void CheckByteArgument(Byte[] value, int startIndex, int bytesRequired);
    private long CheckedFromBytes(Byte[] value, int startIndex, int bytesToConvert);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    public decimal ToDecimal(Byte[] value, int startIndex);
    public Byte[] GetBytes(decimal value);
    public void CopyBytes(decimal value, Byte[] buffer, int index);
    private Byte[] GetBytes(long value, int bytes);
    public Byte[] GetBytes(bool value);
    public Byte[] GetBytes(char value);
    public Byte[] GetBytes(double value);
    public Byte[] GetBytes(short value);
    public Byte[] GetBytes(int value);
    public Byte[] GetBytes(long value);
    public Byte[] GetBytes(float value);
    public Byte[] GetBytes(ushort value);
    public Byte[] GetBytes(UInt32 value);
    public Byte[] GetBytes(ulong value);
    private void CopyBytes(long value, int bytes, Byte[] buffer, int index);
    protected internal abstract virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    public void CopyBytes(bool value, Byte[] buffer, int index);
    public void CopyBytes(char value, Byte[] buffer, int index);
    public void CopyBytes(double value, Byte[] buffer, int index);
    public void CopyBytes(short value, Byte[] buffer, int index);
    public void CopyBytes(int value, Byte[] buffer, int index);
    public void CopyBytes(long value, Byte[] buffer, int index);
    public void CopyBytes(float value, Byte[] buffer, int index);
    public void CopyBytes(ushort value, Byte[] buffer, int index);
    public void CopyBytes(UInt32 value, Byte[] buffer, int index);
    public void CopyBytes(ulong value, Byte[] buffer, int index);
}
internal enum ImageProcessor.Imaging.Helpers.Endianness : Enum {
    public int value__;
    public static Endianness LittleEndian;
    public static Endianness BigEndian;
}
internal static class ImageProcessor.Imaging.Helpers.GraphicsHelper : object {
    public static void SetGraphicsOptions(Graphics graphics, bool blending, bool smoothing);
}
public static class ImageProcessor.Imaging.Helpers.ImageMaths : object {
    public static RectangleF CenteredRectangle(Rectangle parent, Rectangle child);
    public static T Clamp(T value, T min, T max);
    public static bool InRange(T value, T min, T max, bool include);
    public static double DegreesToRadians(double angleInDegrees);
    public static Rectangle GetBoundingRectangle(Point topLeft, Point bottomRight);
    public static Rectangle GetBoundingRotatedRectangle(int width, int height, float angleInDegrees);
    public static Rectangle GetFilteredBoundingRectangle(Image bitmap, byte componentValue, RgbaComponent channel);
    public static Point RotatePoint(Point pointToRotate, double angleInDegrees, Nullable`1<Point> centerPoint);
    public static Point[] ToPoints(Rectangle rectangle);
    public static float ZoomAfterRotation(int imageWidth, int imageHeight, float angleInDegrees);
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__getMinY|6_4(FastBitmap fastBitmap, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__getMaxY|6_5(FastBitmap fastBitmap, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__getMinX|6_6(FastBitmap fastBitmap, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__getMaxX|6_7(FastBitmap fastBitmap, <>c__DisplayClass6_0& );
}
internal class ImageProcessor.Imaging.Helpers.LittleEndianBitConverter : EndianBitConverter {
    public Endianness Endianness { get; }
    public virtual Endianness get_Endianness();
    public virtual bool IsLittleEndian();
    protected internal virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    protected internal virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
}
public static class ImageProcessor.Imaging.Helpers.PixelOperations : object {
    private static Lazy`1<Byte[]> LinearBytes;
    private static Lazy`1<Byte[]> SRGBBytes;
    private static Lazy`1<Byte[]> LinearGammaBytes;
    private static Lazy`1<Byte[]> GammaLinearBytes;
    private static PixelOperations();
    public static Color Gamma(Color color, float value);
    public static Color ToLinear(Color composite);
    public static Color ToSRGB(Color linear);
    public static Color ToLinearFromGamma(Color composite);
    public static Color ToGammaFromLinear(Color composite);
    private static Byte[] GetLinearGammaBytes();
    private static Byte[] GetGammaLinearBytes();
    private static Byte[] GetLinearBytes();
    private static Byte[] GetSRGBBytes();
    private static float SRGBToLinear(float signal);
    private static float LinearToSRGB(float signal);
}
public interface ImageProcessor.Imaging.IComputerArchitectureInfo {
    public abstract virtual bool IsLittleEndian();
}
public class ImageProcessor.Imaging.ImageLayer : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private Image <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Opacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Point> <Position>k__BackingField;
    public Image Image { get; public set; }
    public Size Size { get; public set; }
    public int Opacity { get; public set; }
    public Nullable`1<Point> Position { get; public set; }
    [CompilerGeneratedAttribute]
public Image get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(Image value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public int get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<Point> get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Nullable`1<Point> value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImageLayer other);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal static class ImageProcessor.Imaging.Interpolation : object {
    public static double BiCubicKernel(double x);
    public static double BiCubicBSplineKernel(double x);
    internal static double LanczosKernel3(double x);
    private static double SinC(double x);
    private static double Clean(double x);
}
internal class ImageProcessor.Imaging.MetaData.ExifBitConverter : EndianBitConverter {
    private IComputerArchitectureInfo computerArchitectureInfo;
    public Endianness Endianness { get; }
    public ExifBitConverter(IComputerArchitectureInfo computerArchitectureInfo);
    public virtual Endianness get_Endianness();
    public virtual bool IsLittleEndian();
    public Byte[] GetBytes(string value, bool addnull);
    public Byte[] GetBytes(string value);
    public Byte[] GetBytes(Rational`1<UInt32> value);
    public Byte[] GetBytes(Rational`1<int> value);
    protected internal virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
    protected internal virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
}
public enum ImageProcessor.Imaging.MetaData.ExifPropertyTag : Enum {
    public int value__;
    public static ExifPropertyTag GpsVer;
    public static ExifPropertyTag GpsLatitudeRef;
    public static ExifPropertyTag GpsLatitude;
    public static ExifPropertyTag GpsLongitudeRef;
    public static ExifPropertyTag GpsLongitude;
    public static ExifPropertyTag GpsAltitudeRef;
    public static ExifPropertyTag GpsAltitude;
    public static ExifPropertyTag GpsGpsTime;
    public static ExifPropertyTag GpsGpsSatellites;
    public static ExifPropertyTag GpsGpsStatus;
    public static ExifPropertyTag GpsGpsMeasureMode;
    public static ExifPropertyTag GpsGpsDop;
    public static ExifPropertyTag GpsSpeedRef;
    public static ExifPropertyTag GpsSpeed;
    public static ExifPropertyTag GpsTrackRef;
    public static ExifPropertyTag GpsTrack;
    public static ExifPropertyTag GpsImgDirRef;
    public static ExifPropertyTag GpsImgDir;
    public static ExifPropertyTag GpsMapDatum;
    public static ExifPropertyTag GpsDestLatRef;
    public static ExifPropertyTag GpsDestLat;
    public static ExifPropertyTag GpsDestLongRef;
    public static ExifPropertyTag GpsDestLong;
    public static ExifPropertyTag GpsDestBearRef;
    public static ExifPropertyTag GpsDestBear;
    public static ExifPropertyTag GpsDestDistRef;
    public static ExifPropertyTag GpsDestDist;
    public static ExifPropertyTag NewSubfileType;
    public static ExifPropertyTag SubfileType;
    public static ExifPropertyTag ImageWidth;
    public static ExifPropertyTag ImageHeight;
    public static ExifPropertyTag BitsPerSample;
    public static ExifPropertyTag Compression;
    public static ExifPropertyTag PhotometricInterp;
    public static ExifPropertyTag ThreshHolding;
    public static ExifPropertyTag CellWidth;
    public static ExifPropertyTag CellHeight;
    public static ExifPropertyTag FillOrder;
    public static ExifPropertyTag DocumentName;
    public static ExifPropertyTag ImageDescription;
    public static ExifPropertyTag EquipMake;
    public static ExifPropertyTag EquipModel;
    public static ExifPropertyTag StripOffsets;
    public static ExifPropertyTag Orientation;
    public static ExifPropertyTag SamplesPerPixel;
    public static ExifPropertyTag RowsPerStrip;
    public static ExifPropertyTag StripBytesCount;
    public static ExifPropertyTag MinSampleValue;
    public static ExifPropertyTag MaxSampleValue;
    public static ExifPropertyTag XResolution;
    public static ExifPropertyTag YResolution;
    public static ExifPropertyTag PlanarConfig;
    public static ExifPropertyTag PageName;
    public static ExifPropertyTag XPosition;
    public static ExifPropertyTag YPosition;
    public static ExifPropertyTag FreeOffset;
    public static ExifPropertyTag FreeByteCounts;
    public static ExifPropertyTag GrayResponseUnit;
    public static ExifPropertyTag GrayResponseCurve;
    public static ExifPropertyTag T4Option;
    public static ExifPropertyTag T6Option;
    public static ExifPropertyTag ResolutionUnit;
    public static ExifPropertyTag PageNumber;
    public static ExifPropertyTag TransferFunction;
    public static ExifPropertyTag SoftwareUsed;
    public static ExifPropertyTag DateTime;
    public static ExifPropertyTag Artist;
    public static ExifPropertyTag HostComputer;
    public static ExifPropertyTag Predictor;
    public static ExifPropertyTag WhitePoint;
    public static ExifPropertyTag PrimaryChromaticities;
    public static ExifPropertyTag ColorMap;
    public static ExifPropertyTag HalftoneHints;
    public static ExifPropertyTag TileWidth;
    public static ExifPropertyTag TileLength;
    public static ExifPropertyTag TileOffset;
    public static ExifPropertyTag TileByteCounts;
    public static ExifPropertyTag InkSet;
    public static ExifPropertyTag InkNames;
    public static ExifPropertyTag NumberOfInks;
    public static ExifPropertyTag DotRange;
    public static ExifPropertyTag TargetPrinter;
    public static ExifPropertyTag ExtraSamples;
    public static ExifPropertyTag SampleFormat;
    public static ExifPropertyTag SMinSampleValue;
    public static ExifPropertyTag SMaxSampleValue;
    public static ExifPropertyTag TransferRange;
    public static ExifPropertyTag JPEGProc;
    public static ExifPropertyTag JPEGInterFormat;
    public static ExifPropertyTag JPEGInterLength;
    public static ExifPropertyTag JPEGRestartInterval;
    public static ExifPropertyTag JPEGLosslessPredictors;
    public static ExifPropertyTag JPEGPointTransforms;
    public static ExifPropertyTag JPEGQTables;
    public static ExifPropertyTag JPEGDCTables;
    public static ExifPropertyTag JPEGACTables;
    public static ExifPropertyTag YCbCrCoefficients;
    public static ExifPropertyTag YCbCrSubsampling;
    public static ExifPropertyTag YCbCrPositioning;
    public static ExifPropertyTag REFBlackWhite;
    public static ExifPropertyTag Gamma;
    public static ExifPropertyTag ICCProfileDescriptor;
    public static ExifPropertyTag SRGBRenderingIntent;
    public static ExifPropertyTag ImageTitle;
    public static ExifPropertyTag ResolutionXUnit;
    public static ExifPropertyTag ResolutionYUnit;
    public static ExifPropertyTag ResolutionXLengthUnit;
    public static ExifPropertyTag ResolutionYLengthUnit;
    public static ExifPropertyTag PrintFlags;
    public static ExifPropertyTag PrintFlagsVersion;
    public static ExifPropertyTag PrintFlagsCrop;
    public static ExifPropertyTag PrintFlagsBleedWidth;
    public static ExifPropertyTag PrintFlagsBleedWidthScale;
    public static ExifPropertyTag HalftoneLPI;
    public static ExifPropertyTag HalftoneLPIUnit;
    public static ExifPropertyTag HalftoneDegree;
    public static ExifPropertyTag HalftoneShape;
    public static ExifPropertyTag HalftoneMisc;
    public static ExifPropertyTag HalftoneScreen;
    public static ExifPropertyTag JPEGQuality;
    public static ExifPropertyTag GridSize;
    public static ExifPropertyTag ThumbnailFormat;
    public static ExifPropertyTag ThumbnailWidth;
    public static ExifPropertyTag ThumbnailHeight;
    public static ExifPropertyTag ThumbnailColorDepth;
    public static ExifPropertyTag ThumbnailPlanes;
    public static ExifPropertyTag ThumbnailRawBytes;
    public static ExifPropertyTag ThumbnailSize;
    public static ExifPropertyTag ThumbnailCompressedSize;
    public static ExifPropertyTag ColorTransferFunction;
    public static ExifPropertyTag ThumbnailData;
    public static ExifPropertyTag ThumbnailImageWidth;
    public static ExifPropertyTag ThumbnailImageHeight;
    public static ExifPropertyTag ThumbnailBitsPerSample;
    public static ExifPropertyTag ThumbnailCompression;
    public static ExifPropertyTag ThumbnailPhotometricInterp;
    public static ExifPropertyTag ThumbnailImageDescription;
    public static ExifPropertyTag ThumbnailEquipMake;
    public static ExifPropertyTag ThumbnailEquipModel;
    public static ExifPropertyTag ThumbnailStripOffsets;
    public static ExifPropertyTag ThumbnailOrientation;
    public static ExifPropertyTag ThumbnailSamplesPerPixel;
    public static ExifPropertyTag ThumbnailRowsPerStrip;
    public static ExifPropertyTag ThumbnailStripBytesCount;
    public static ExifPropertyTag ThumbnailResolutionX;
    public static ExifPropertyTag ThumbnailResolutionY;
    public static ExifPropertyTag ThumbnailPlanarConfig;
    public static ExifPropertyTag ThumbnailResolutionUnit;
    public static ExifPropertyTag ThumbnailTransferFunction;
    public static ExifPropertyTag ThumbnailSoftwareUsed;
    public static ExifPropertyTag ThumbnailDateTime;
    public static ExifPropertyTag ThumbnailArtist;
    public static ExifPropertyTag ThumbnailWhitePoint;
    public static ExifPropertyTag ThumbnailPrimaryChromaticities;
    public static ExifPropertyTag ThumbnailYCbCrCoefficients;
    public static ExifPropertyTag ThumbnailYCbCrSubsampling;
    public static ExifPropertyTag ThumbnailYCbCrPositioning;
    public static ExifPropertyTag ThumbnailRefBlackWhite;
    public static ExifPropertyTag ThumbnailCopyRight;
    public static ExifPropertyTag LuminanceTable;
    public static ExifPropertyTag ChrominanceTable;
    public static ExifPropertyTag FrameDelay;
    public static ExifPropertyTag LoopCount;
    public static ExifPropertyTag GlobalPalette;
    public static ExifPropertyTag IndexBackground;
    public static ExifPropertyTag IndexTransparent;
    public static ExifPropertyTag PixelUnit;
    public static ExifPropertyTag PixelPerUnitX;
    public static ExifPropertyTag PixelPerUnitY;
    public static ExifPropertyTag PaletteHistogram;
    public static ExifPropertyTag Copyright;
    public static ExifPropertyTag ExifExposureTime;
    public static ExifPropertyTag ExifFNumber;
    public static ExifPropertyTag ExifIFD;
    public static ExifPropertyTag ICCProfile;
    public static ExifPropertyTag ExifExposureProg;
    public static ExifPropertyTag ExifSpectralSense;
    public static ExifPropertyTag GpsIFD;
    public static ExifPropertyTag ExifISOSpeed;
    public static ExifPropertyTag ExifOECF;
    public static ExifPropertyTag ExifVer;
    public static ExifPropertyTag ExifDTOrig;
    public static ExifPropertyTag ExifDTDigitized;
    public static ExifPropertyTag ExifCompConfig;
    public static ExifPropertyTag ExifCompBPP;
    public static ExifPropertyTag ExifShutterSpeed;
    public static ExifPropertyTag ExifAperture;
    public static ExifPropertyTag ExifBrightness;
    public static ExifPropertyTag ExifExposureBias;
    public static ExifPropertyTag ExifMaxAperture;
    public static ExifPropertyTag ExifSubjectDist;
    public static ExifPropertyTag ExifMeteringMode;
    public static ExifPropertyTag ExifLightSource;
    public static ExifPropertyTag ExifFlash;
    public static ExifPropertyTag ExifFocalLength;
    public static ExifPropertyTag ExifMakerNote;
    public static ExifPropertyTag ExifUserComment;
    public static ExifPropertyTag ExifDTSubsec;
    public static ExifPropertyTag ExifDTOrigSS;
    public static ExifPropertyTag ExifDTDigSS;
    public static ExifPropertyTag ExifFPXVer;
    public static ExifPropertyTag ExifColorSpace;
    public static ExifPropertyTag ExifPixXDim;
    public static ExifPropertyTag ExifPixYDim;
    public static ExifPropertyTag ExifRelatedWav;
    public static ExifPropertyTag ExifInterop;
    public static ExifPropertyTag ExifFlashEnergy;
    public static ExifPropertyTag ExifSpatialFR;
    public static ExifPropertyTag ExifFocalXRes;
    public static ExifPropertyTag ExifFocalYRes;
    public static ExifPropertyTag ExifFocalResUnit;
    public static ExifPropertyTag ExifSubjectLoc;
    public static ExifPropertyTag ExifExposureIndex;
    public static ExifPropertyTag ExifSensingMethod;
    public static ExifPropertyTag ExifFileSource;
    public static ExifPropertyTag ExifSceneType;
    public static ExifPropertyTag ExifCfaPattern;
}
public static class ImageProcessor.Imaging.MetaData.ExifPropertyTagConstants : object {
    public static ExifPropertyTag[] RequiredPropertyItems;
    public static ExifPropertyTag[] GeolocationPropertyItems;
    public static ExifPropertyTag[] CopyrightPropertyItems;
    public static ExifPropertyTag[] CopyrightAndGeolocationPropertyItems;
    public static ExifPropertyTag[] All;
    private static ExifPropertyTagConstants();
}
public enum ImageProcessor.Imaging.MetaData.ExifPropertyTagType : Enum {
    public short value__;
    public static ExifPropertyTagType Byte;
    public static ExifPropertyTagType ASCII;
    public static ExifPropertyTagType UShort;
    public static ExifPropertyTagType ULong;
    public static ExifPropertyTagType Rational;
    public static ExifPropertyTagType Undefined;
    public static ExifPropertyTagType SLong;
    public static ExifPropertyTagType SRational;
}
[ExtensionAttribute]
internal static class ImageProcessor.Imaging.MetaData.ImageFactoryMetaExtensions : object {
    private static ExifBitConverter BitConverter;
    private static ImageFactoryMetaExtensions();
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, byte value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, string value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, ushort value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, UInt32 value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, Rational`1<UInt32> value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, Byte[] value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, int value);
    [ExtensionAttribute]
public static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, Rational`1<int> value);
    [ExtensionAttribute]
private static ImageFactory SetPropertyItem(ImageFactory imageFactory, ExifPropertyTag id, ExifPropertyTagType type, int length, Byte[] value);
}
[IsReadOnlyAttribute]
internal class ImageProcessor.Imaging.MetaData.Int32Converter : ValueType {
    public int Value;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public Int32Converter(int value);
    public static int op_Implicit(Int32Converter value);
    public static Int32Converter op_Implicit(int value);
}
public enum ImageProcessor.Imaging.MetaData.PropertyTagResolutionUnit : Enum {
    public ushort value__;
    public static PropertyTagResolutionUnit Inch;
    public static PropertyTagResolutionUnit Cm;
}
[IsReadOnlyAttribute]
public class ImageProcessor.Imaging.MetaData.Rational`1 : ValueType {
    public static Rational`1<T> Empty;
    private static char Delim;
    private static Char[] DelimSet;
    private static ParseDelegate<T> parser;
    private static TryParseDelegate<T> tryParser;
    private static decimal maxValue;
    private T numerator;
    private T denominator;
    public T Numerator { get; }
    public T Denominator { get; }
    public bool IsEmpty { get; }
    private static decimal MaxValue { get; }
    public Rational`1(T numerator, T denominator);
    public Rational`1(T numerator, T denominator, bool reduce);
    private static Rational`1();
    public T get_Numerator();
    public T get_Denominator();
    public bool get_IsEmpty();
    private static decimal get_MaxValue();
    public static Rational`1<T> Approximate(decimal value);
    public static Rational`1<T> Approximate(decimal value, decimal epsilon);
    public static Rational`1<T> Parse(string value);
    public static bool TryParse(string value, Rational`1& rational);
    private static ParseDelegate<T> BuildParser();
    private static TryParseDelegate<T> BuildTryParser();
    public Rational`1<T> Reduce();
    private static void Reduce(T& numerator, T& denominator);
    private static decimal Lcd(decimal a, decimal b);
    private static decimal Gcd(decimal a, decimal b);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(T other);
    public static Rational`1<T> op_UnaryNegation(Rational`1<T> rational);
    public static Rational`1<T> op_Addition(Rational`1<T> r1, Rational`1<T> r2);
    public static Rational`1<T> op_Subtraction(Rational`1<T> r1, Rational`1<T> r2);
    public static Rational`1<T> op_Multiply(Rational`1<T> r1, Rational`1<T> r2);
    public static Rational`1<T> op_Division(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_LessThan(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_LessThanOrEqual(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_GreaterThan(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_GreaterThanOrEqual(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_Equality(Rational`1<T> r1, Rational`1<T> r2);
    public static bool op_Inequality(Rational`1<T> r1, Rational`1<T> r2);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface ImageProcessor.Imaging.Quantizers.IQuantizer {
    public abstract virtual Bitmap Quantize(Image source);
}
public class ImageProcessor.Imaging.Quantizers.OctreeQuantizer : Quantizer {
    private int maxColors;
    private int maxColorBits;
    private Octree octree;
    [CompilerGeneratedAttribute]
private byte <Threshold>k__BackingField;
    public byte Threshold { get; public set; }
    public OctreeQuantizer(int maxColors, int maxColorBits);
    [CompilerGeneratedAttribute]
public byte get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(byte value);
    protected virtual void FirstPass(BitmapData sourceData, int width, int height);
    protected virtual void InitialQuantizePixel(Color32* pixel);
    protected virtual byte QuantizePixel(Color32* pixel);
    protected virtual ColorPalette GetPalette(ColorPalette original);
}
public abstract class ImageProcessor.Imaging.Quantizers.Quantizer : object {
    private bool singlePass;
    protected Quantizer(bool singlePass);
    public sealed virtual Bitmap Quantize(Image source);
    protected virtual void FirstPass(BitmapData sourceData, int width, int height);
    protected virtual void SecondPass(BitmapData sourceData, Bitmap output, int width, int height, Rectangle bounds);
    protected virtual void InitialQuantizePixel(Color32* pixel);
    protected abstract virtual byte QuantizePixel(Color32* pixel);
    protected abstract virtual ColorPalette GetPalette(ColorPalette original);
}
public class ImageProcessor.Imaging.Quantizers.WuQuantizer.Box : ValueType {
    public byte AlphaMaximum;
    public byte AlphaMinimum;
    public byte BlueMaximum;
    public byte BlueMinimum;
    public byte GreenMaximum;
    public byte GreenMinimum;
    public byte RedMaximum;
    public byte RedMinimum;
    public int Size;
}
internal class ImageProcessor.Imaging.Quantizers.WuQuantizer.ColorMoment : ValueType {
    public long Alpha;
    public long Blue;
    public long Green;
    public float Moment;
    public long Red;
    public int Weight;
    public static ColorMoment op_Addition(ColorMoment firstAddend, ColorMoment secondAddend);
    public static ColorMoment op_Subtraction(ColorMoment minuend, ColorMoment subtrahend);
    public static ColorMoment op_UnaryNegation(ColorMoment moment);
    public void Add(Color32 pixel);
    public void AddFast(ColorMoment& moment);
    public long Amplitude();
    public float Variance();
    public long WeightedDistance();
}
[IsReadOnlyAttribute]
internal class ImageProcessor.Imaging.Quantizers.WuQuantizer.CubeCut : ValueType {
    public Nullable`1<byte> Position;
    public float Value;
    public CubeCut(Nullable`1<byte> cutPoint, float result);
}
public class ImageProcessor.Imaging.Quantizers.WuQuantizer.Histogram : object {
    internal ColorMoment[0...,0...,0...,0...] Moments;
    private static int SideSize;
    internal void Clear();
}
internal class ImageProcessor.Imaging.Quantizers.WuQuantizer.ImageBuffer : object {
    [CompilerGeneratedAttribute]
private Bitmap <Image>k__BackingField;
    public Bitmap Image { get; }
    public IEnumerable`1<Color32[]> PixelLines { get; }
    public ImageBuffer(Bitmap image);
    [CompilerGeneratedAttribute]
public Bitmap get_Image();
    [IteratorStateMachineAttribute("ImageProcessor.Imaging.Quantizers.WuQuantizer.ImageBuffer/<get_PixelLines>d__5")]
public IEnumerable`1<Color32[]> get_PixelLines();
    public void UpdatePixelIndexes(IEnumerable`1<Byte[]> lineIndexes);
}
public interface ImageProcessor.Imaging.Quantizers.WuQuantizer.IWuQuantizer {
    public abstract virtual Bitmap Quantize(Image image, int alphaThreshold, int alphaFader);
}
internal class ImageProcessor.Imaging.Quantizers.WuQuantizer.PaletteColorHistory : ValueType {
    public ulong Alpha;
    public ulong Red;
    public ulong Green;
    public ulong Blue;
    public ulong Sum;
    public Color ToNormalizedColor();
    public void AddPixel(Color32 pixel);
}
internal class ImageProcessor.Imaging.Quantizers.WuQuantizer.PaletteLookup : object {
    private Dictionary`2<int, LookupNode[]> lookupNodes;
    private int paletteMask;
    [CompilerGeneratedAttribute]
private LookupNode[] <Palette>k__BackingField;
    private LookupNode[] Palette { get; }
    public PaletteLookup(Color32[] palette);
    [CompilerGeneratedAttribute]
private LookupNode[] get_Palette();
    public byte GetPaletteIndex(Color32 pixel);
    private static byte ComputeBitMask(byte max, int bits);
    private static int GetMask(Color32[] palette);
    private static byte HighestSetBitIndex(byte value);
    private void BuildLookup(Color32[] palette);
}
public class ImageProcessor.Imaging.Quantizers.WuQuantizer.WuQuantizer : WuQuantizerBase {
    internal virtual Bitmap GetQuantizedImage(ImageBuffer imageBuffer, int colorCount, Color32[] lookups, int alphaThreshold);
    private static ColorPalette BuildPalette(ColorPalette palette, PaletteColorHistory[] paletteHistory);
    [IteratorStateMachineAttribute("ImageProcessor.Imaging.Quantizers.WuQuantizer.WuQuantizer/<IndexedPixels>d__2")]
private static IEnumerable`1<Byte[]> IndexedPixels(ImageBuffer image, Color32[] lookups, int alphaThreshold, PaletteColorHistory[] paletteHistogram);
}
public abstract class ImageProcessor.Imaging.Quantizers.WuQuantizer.WuQuantizerBase : object {
    protected static byte AlphaMax;
    protected static byte AlphaMin;
    protected static int Alpha;
    protected static int Red;
    protected static int Green;
    protected static int Blue;
    private static int SideSize;
    private static int MaxSideIndex;
    [CompilerGeneratedAttribute]
private byte <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Fade>k__BackingField;
    public byte Threshold { get; public set; }
    public byte Fade { get; public set; }
    [CompilerGeneratedAttribute]
public byte get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(byte value);
    [CompilerGeneratedAttribute]
public byte get_Fade();
    [CompilerGeneratedAttribute]
public void set_Fade(byte value);
    public sealed virtual Bitmap Quantize(Image source);
    public sealed virtual Bitmap Quantize(Image image, int alphaThreshold, int alphaFader);
    public Bitmap Quantize(Image source, int alphaThreshold, int alphaFader, Histogram histogram, int maxColors);
    internal abstract virtual Bitmap GetQuantizedImage(ImageBuffer imageBuffer, int colorCount, Color32[] lookups, int alphaThreshold);
    private static void BuildHistogram(Histogram histogram, ImageBuffer imageBuffer, int alphaThreshold, int alphaFader);
    private static void CalculateMoments(ColorMoment[0...,0...,0...,0...] moments);
    private static ColorMoment Top(Box cube, int direction, int position, ColorMoment[0...,0...,0...,0...] moment);
    private static ColorMoment Bottom(Box cube, int direction, ColorMoment[0...,0...,0...,0...] moment);
    private static CubeCut Maximize(ColorMoment[0...,0...,0...,0...] moments, Box cube, int direction, byte first, byte last, ColorMoment whole);
    private static bool Cut(ColorMoment[0...,0...,0...,0...] moments, Box& first, Box& second);
    private static float CalculateVariance(ColorMoment[0...,0...,0...,0...] moments, Box cube);
    private static ColorMoment Volume(ColorMoment[0...,0...,0...,0...] moments, Box cube);
    private static Box[] SplitData(Int32& colorCount, ColorMoment[0...,0...,0...,0...] moments);
    private static Color32[] BuildLookups(Box[] cubes, ColorMoment[0...,0...,0...,0...] moments);
}
internal static class ImageProcessor.Imaging.ResizeHelper : object {
    public static ValueTuple`2<Size, Rectangle> CalculateTargetLocationAndBounds(Size sourceSize, ResizeLayer options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateBoxPadRectangle(Size source, ResizeLayer options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateCropRectangle(Size source, ResizeLayer options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateMaxRectangle(Size source, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateMinRectangle(Size source, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculatePadRectangle(Size sourceSize, ResizeLayer options, int width, int height);
    private static void ThrowInvalid(string message);
}
public class ImageProcessor.Imaging.ResizeLayer : object {
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Size> <RestrictedSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private ResizeMode <ResizeMode>k__BackingField;
    [CompilerGeneratedAttribute]
private AnchorPosition <AnchorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Upscale>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PointF> <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Point> <AnchorPoint>k__BackingField;
    public Size Size { get; public set; }
    public Nullable`1<Size> MaxSize { get; public set; }
    public List`1<Size> RestrictedSizes { get; public set; }
    public ResizeMode ResizeMode { get; public set; }
    public AnchorPosition AnchorPosition { get; public set; }
    public bool Upscale { get; public set; }
    [ObsoleteAttribute("Use the Center property instead.")]
public Single[] CenterCoordinates { get; public set; }
    public Nullable`1<PointF> Center { get; public set; }
    public Nullable`1<Point> AnchorPoint { get; public set; }
    public ResizeLayer(Size size, ResizeMode resizeMode, AnchorPosition anchorPosition, bool upscale, Single[] centerCoordinates, Nullable`1<Size> maxSize, List`1<Size> restrictedSizes, Nullable`1<Point> anchorPoint);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxSize();
    [CompilerGeneratedAttribute]
public void set_MaxSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public List`1<Size> get_RestrictedSizes();
    [CompilerGeneratedAttribute]
public void set_RestrictedSizes(List`1<Size> value);
    [CompilerGeneratedAttribute]
public ResizeMode get_ResizeMode();
    [CompilerGeneratedAttribute]
public void set_ResizeMode(ResizeMode value);
    [CompilerGeneratedAttribute]
public AnchorPosition get_AnchorPosition();
    [CompilerGeneratedAttribute]
public void set_AnchorPosition(AnchorPosition value);
    [CompilerGeneratedAttribute]
public bool get_Upscale();
    [CompilerGeneratedAttribute]
public void set_Upscale(bool value);
    public Single[] get_CenterCoordinates();
    public void set_CenterCoordinates(Single[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<PointF> get_Center();
    [CompilerGeneratedAttribute]
public void set_Center(Nullable`1<PointF> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Point> get_AnchorPoint();
    [CompilerGeneratedAttribute]
public void set_AnchorPoint(Nullable`1<Point> value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResizeLayer other);
    public virtual int GetHashCode();
}
public enum ImageProcessor.Imaging.ResizeMode : Enum {
    public int value__;
    public static ResizeMode Pad;
    public static ResizeMode Stretch;
    public static ResizeMode Crop;
    public static ResizeMode Max;
    public static ResizeMode Min;
    public static ResizeMode BoxPad;
}
public class ImageProcessor.Imaging.Resizer : object {
    [CompilerGeneratedAttribute]
private ResizeLayer <ResizeLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISupportedImageFormat <ImageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private AnimationProcessMode <AnimationProcessMode>k__BackingField;
    public ResizeLayer ResizeLayer { get; public set; }
    public ISupportedImageFormat ImageFormat { get; public set; }
    public AnimationProcessMode AnimationProcessMode { get; public set; }
    public Resizer(Size size);
    public Resizer(ResizeLayer resizeLayer);
    [CompilerGeneratedAttribute]
public ResizeLayer get_ResizeLayer();
    [CompilerGeneratedAttribute]
public void set_ResizeLayer(ResizeLayer value);
    [CompilerGeneratedAttribute]
public ISupportedImageFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public void set_ImageFormat(ISupportedImageFormat value);
    [CompilerGeneratedAttribute]
public AnimationProcessMode get_AnimationProcessMode();
    [CompilerGeneratedAttribute]
public void set_AnimationProcessMode(AnimationProcessMode value);
    public Bitmap ResizeImage(Image source, bool linear);
    protected virtual Bitmap ResizeComposite(Image source, int width, int height, Rectangle destination);
    protected virtual Bitmap ResizeLinear(Image source, int targetWidth, int targetHeight, Rectangle destination);
    protected virtual Bitmap ResizeLinear(Image source, int width, int height, Rectangle destination, AnimationProcessMode animationProcessMode);
}
public class ImageProcessor.Imaging.RoundedCornerLayer : object {
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TopLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TopRight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BottomLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BottomRight>k__BackingField;
    public int Radius { get; public set; }
    public bool TopLeft { get; public set; }
    public bool TopRight { get; public set; }
    public bool BottomLeft { get; public set; }
    public bool BottomRight { get; public set; }
    public RoundedCornerLayer(int radius, bool topLeft, bool topRight, bool bottomLeft, bool bottomRight);
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public void set_Radius(int value);
    [CompilerGeneratedAttribute]
public bool get_TopLeft();
    [CompilerGeneratedAttribute]
public void set_TopLeft(bool value);
    [CompilerGeneratedAttribute]
public bool get_TopRight();
    [CompilerGeneratedAttribute]
public void set_TopRight(bool value);
    [CompilerGeneratedAttribute]
public bool get_BottomLeft();
    [CompilerGeneratedAttribute]
public void set_BottomLeft(bool value);
    [CompilerGeneratedAttribute]
public bool get_BottomRight();
    [CompilerGeneratedAttribute]
public void set_BottomRight(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RoundedCornerLayer other);
    public virtual int GetHashCode();
}
public class ImageProcessor.Imaging.TextLayer : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <FontColor>k__BackingField;
    [CompilerGeneratedAttribute]
private FontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Opacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Point> <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DropShadow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Vertical>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RightToLeft>k__BackingField;
    public string Text { get; public set; }
    public Color FontColor { get; public set; }
    public FontFamily FontFamily { get; public set; }
    public int FontSize { get; public set; }
    public FontStyle Style { get; public set; }
    public int Opacity { get; public set; }
    public Nullable`1<Point> Position { get; public set; }
    public bool DropShadow { get; public set; }
    public bool Vertical { get; public set; }
    public bool RightToLeft { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public Color get_FontColor();
    [CompilerGeneratedAttribute]
public void set_FontColor(Color value);
    [CompilerGeneratedAttribute]
public FontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(FontFamily value);
    [CompilerGeneratedAttribute]
public int get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(int value);
    [CompilerGeneratedAttribute]
public FontStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(FontStyle value);
    [CompilerGeneratedAttribute]
public int get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<Point> get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Nullable`1<Point> value);
    [CompilerGeneratedAttribute]
public bool get_DropShadow();
    [CompilerGeneratedAttribute]
public void set_DropShadow(bool value);
    [CompilerGeneratedAttribute]
public bool get_Vertical();
    [CompilerGeneratedAttribute]
public void set_Vertical(bool value);
    [CompilerGeneratedAttribute]
public bool get_RightToLeft();
    [CompilerGeneratedAttribute]
public void set_RightToLeft(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextLayer other);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum ImageProcessor.MetaDataMode : Enum {
    public int value__;
    public static MetaDataMode None;
    public static MetaDataMode Copyright;
    public static MetaDataMode Geolocation;
    public static MetaDataMode CopyrightAndGeolocation;
    public static MetaDataMode All;
}
public class ImageProcessor.Processors.Alpha : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.AutoRotate : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Background : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.BackgroundColor : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Brightness : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Contrast : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Crop : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
    private void ForwardRotateFlip(int orientation, Image& image);
    private void ReverseRotateFlip(int orientation, Image& image);
}
public class ImageProcessor.Processors.DetectEdges : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.EntropyCrop : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Filter : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Flip : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Format : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Gamma : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.GaussianBlur : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.GaussianSharpen : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Halftone : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Hue : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public interface ImageProcessor.Processors.IGraphicsProcessor {
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public abstract virtual object get_DynamicParameter();
    public abstract virtual void set_DynamicParameter(object value);
    public abstract virtual Dictionary`2<string, string> get_Settings();
    public abstract virtual void set_Settings(Dictionary`2<string, string> value);
    public abstract virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Mask : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Meta : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Overlay : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Pixelate : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Quality : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.ReplaceColor : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Resize : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Size> <RestrictedSizes>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public List`1<Size> RestrictedSizes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public List`1<Size> get_RestrictedSizes();
    [CompilerGeneratedAttribute]
public void set_RestrictedSizes(List`1<Size> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Resolution : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Rotate : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
    private Bitmap RotateImage(Image image, float rotateAtX, float rotateAtY, float angle);
}
public class ImageProcessor.Processors.RotateBounded : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
    private Bitmap RotateImage(Image image, float angleInDegrees, bool keepSize);
}
public class ImageProcessor.Processors.RoundedCorners : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
    private Bitmap RoundCornerImage(Image image, int cornerRadius, bool topLeft, bool topRight, bool bottomLeft, bool bottomRight);
}
public class ImageProcessor.Processors.Saturation : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Tint : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Vignette : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
}
public class ImageProcessor.Processors.Watermark : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <DynamicParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [DynamicAttribute]
public object DynamicParameter { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual object get_DynamicParameter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DynamicParameter(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Settings(Dictionary`2<string, string> value);
    public sealed virtual Image ProcessImage(ImageFactory factory);
    private Font GetFont(FontFamily fontFamily, int fontSize, FontStyle fontStyle);
    private Nullable`1<StringFormatFlags> GetFlags(TextLayer textLayer);
    private Nullable`1<RotateFlipType> GetRotateFlipType(ImageFactory factory);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
