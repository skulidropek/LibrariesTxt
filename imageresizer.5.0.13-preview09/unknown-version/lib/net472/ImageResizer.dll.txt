[FlagsAttribute]
public enum ImageResizer.AnchorLocation : Enum {
    public int value__;
    public static AnchorLocation TopLeft;
    public static AnchorLocation TopCenter;
    public static AnchorLocation TopRight;
    public static AnchorLocation MiddleLeft;
    public static AnchorLocation MiddleCenter;
    public static AnchorLocation MiddleRight;
    public static AnchorLocation BottomLeft;
    public static AnchorLocation BottomCenter;
    public static AnchorLocation BottomRight;
}
public class ImageResizer.AsyncInterceptModule : object {
    private static int moduleInstancesActiveSharedCounter;
    protected IPipelineConfig conf { get; }
    public sealed virtual void Init(HttpApplication context);
    public sealed virtual void Dispose();
    protected IPipelineConfig get_conf();
    [AsyncStateMachineAttribute("ImageResizer.AsyncInterceptModule/<CheckRequest_PostAuthorizeRequest_Async>d__6")]
protected Task CheckRequest_PostAuthorizeRequest_Async(object sender, EventArgs e);
    [AsyncStateMachineAttribute("ImageResizer.AsyncInterceptModule/<HandleRequest>d__7")]
protected virtual Task HandleRequest(HttpContext context, HttpModuleRequestAssistant ra);
    protected void FileMissing(HttpContext httpContext, string virtualPath, NameValueCollection q);
}
public class ImageResizer.BoxEdges : object {
    [CompilerGeneratedAttribute]
private double <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Bottom>k__BackingField;
    public double Top { get; private set; }
    public double Left { get; private set; }
    public double Right { get; private set; }
    public double Bottom { get; private set; }
    public double All { get; private set; }
    public static BoxEdges Empty { get; }
    public bool IsEmpty { get; }
    public BoxEdges(double all);
    public BoxEdges(double left, double top, double right, double bottom);
    public BoxEdges(BoxEdges original);
    public static BoxEdges Parse(string text, BoxEdges fallbackValue);
    [CompilerGeneratedAttribute]
public double get_Top();
    [CompilerGeneratedAttribute]
private void set_Top(double value);
    [CompilerGeneratedAttribute]
public double get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(double value);
    [CompilerGeneratedAttribute]
public double get_Right();
    [CompilerGeneratedAttribute]
private void set_Right(double value);
    [CompilerGeneratedAttribute]
public double get_Bottom();
    [CompilerGeneratedAttribute]
private void set_Bottom(double value);
    public BoxEdges SetAll(double all);
    public BoxEdges SetTop(double top);
    public BoxEdges SetLeft(double left);
    public BoxEdges SetRight(double right);
    public BoxEdges SetBottom(double bottom);
    public double get_All();
    private void set_All(double value);
    public static BoxEdges get_Empty();
    public bool get_IsEmpty();
    public Single[] GetEdgeOffsets();
    public virtual string ToString();
}
public class ImageResizer.Caching.ApplyResponseHeadersDelegate : MulticastDelegate {
    public ApplyResponseHeadersDelegate(object object, IntPtr method);
    public virtual void Invoke(IResponseHeaders headers, HttpContext context);
    public virtual IAsyncResult BeginInvoke(IResponseHeaders headers, HttpContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Caching.GetSourceImageDelegate : MulticastDelegate {
    public GetSourceImageDelegate(object object, IntPtr method);
    public virtual Stream Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Use IAsyncTyrantCache")]
public interface ImageResizer.Caching.ICache {
    public abstract virtual bool CanProcess(HttpContext current, IResponseArgs e);
    public abstract virtual void Process(HttpContext current, IResponseArgs e);
}
public interface ImageResizer.Caching.IResponseArgs {
    public string RequestKey { get; }
    public NameValueCollection RewrittenQuerystring { get; }
    public string SuggestedExtension { get; }
    public IResponseHeaders ResponseHeaders { get; public set; }
    [ObsoleteAttribute("RequestKey will include the modified date if present. No longer populated")]
public ModifiedDateDelegate GetModifiedDateUTC { get; }
    [ObsoleteAttribute("RequestKey will include the modified date if present. No longer populated")]
public bool HasModifiedDate { get; }
    public ResizeImageDelegate ResizeImageToStream { get; }
    public abstract virtual string get_RequestKey();
    public abstract virtual NameValueCollection get_RewrittenQuerystring();
    public abstract virtual string get_SuggestedExtension();
    public abstract virtual IResponseHeaders get_ResponseHeaders();
    public abstract virtual void set_ResponseHeaders(IResponseHeaders value);
    public abstract virtual ModifiedDateDelegate get_GetModifiedDateUTC();
    public abstract virtual bool get_HasModifiedDate();
    public abstract virtual ResizeImageDelegate get_ResizeImageToStream();
}
public interface ImageResizer.Caching.IResponseHeaders {
    public string ContentType { get; public set; }
    public HttpCacheability CacheControl { get; public set; }
    public DateTime Expires { get; public set; }
    public DateTime LastModified { get; public set; }
    public bool ValidUntilExpires { get; public set; }
    public bool SuppressVaryHeader { get; public set; }
    public NameValueCollection DefaultHeaders { get; public set; }
    public NameValueCollection Headers { get; public set; }
    public List`1<CacheDependency> ServerCacheDependencies { get; public set; }
    public ApplyResponseHeadersDelegate ApplyToResponse { get; public set; }
    public bool ApplyDuringPreSendRequestHeaders { get; public set; }
    public abstract virtual string get_ContentType();
    public abstract virtual void set_ContentType(string value);
    public abstract virtual HttpCacheability get_CacheControl();
    public abstract virtual void set_CacheControl(HttpCacheability value);
    public abstract virtual DateTime get_Expires();
    public abstract virtual void set_Expires(DateTime value);
    public abstract virtual DateTime get_LastModified();
    public abstract virtual void set_LastModified(DateTime value);
    public abstract virtual bool get_ValidUntilExpires();
    public abstract virtual void set_ValidUntilExpires(bool value);
    public abstract virtual bool get_SuppressVaryHeader();
    public abstract virtual void set_SuppressVaryHeader(bool value);
    public abstract virtual NameValueCollection get_DefaultHeaders();
    public abstract virtual void set_DefaultHeaders(NameValueCollection value);
    public abstract virtual NameValueCollection get_Headers();
    public abstract virtual void set_Headers(NameValueCollection value);
    public abstract virtual List`1<CacheDependency> get_ServerCacheDependencies();
    public abstract virtual void set_ServerCacheDependencies(List`1<CacheDependency> value);
    public abstract virtual ApplyResponseHeadersDelegate get_ApplyToResponse();
    public abstract virtual void set_ApplyToResponse(ApplyResponseHeadersDelegate value);
    public abstract virtual bool get_ApplyDuringPreSendRequestHeaders();
    public abstract virtual void set_ApplyDuringPreSendRequestHeaders(bool value);
}
public class ImageResizer.Caching.ModifiedDateDelegate : MulticastDelegate {
    public ModifiedDateDelegate(object object, IntPtr method);
    public virtual DateTime Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
public class ImageResizer.Caching.ResizeImageDelegate : MulticastDelegate {
    public ResizeImageDelegate(object object, IntPtr method);
    public virtual void Invoke(Stream s);
    public virtual IAsyncResult BeginInvoke(Stream s, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Caching.ResponseArgs : object {
    [CompilerGeneratedAttribute]
private ModifiedDateDelegate <GetModifiedDateUTC>k__BackingField;
    [CompilerGeneratedAttribute]
private GetSourceImageDelegate <GetSourceImage>k__BackingField;
    [CompilerGeneratedAttribute]
private ResizeImageDelegate <ResizeImageToStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuggestedExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasModifiedDate>k__BackingField;
    protected IResponseHeaders responseHeaders;
    protected NameValueCollection rewrittenQuerystring;
    [ObsoleteAttribute("RequestKey will include the modified date if present. No longer populated")]
public ModifiedDateDelegate GetModifiedDateUTC { get; public set; }
    public GetSourceImageDelegate GetSourceImage { get; public set; }
    public ResizeImageDelegate ResizeImageToStream { get; public set; }
    public string RequestKey { get; public set; }
    public string SuggestedExtension { get; public set; }
    [ObsoleteAttribute("RequestKey will include the modified date if present. No longer populated")]
public bool HasModifiedDate { get; public set; }
    public IResponseHeaders ResponseHeaders { get; public set; }
    public NameValueCollection RewrittenQuerystring { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ModifiedDateDelegate get_GetModifiedDateUTC();
    [CompilerGeneratedAttribute]
public void set_GetModifiedDateUTC(ModifiedDateDelegate value);
    [CompilerGeneratedAttribute]
public GetSourceImageDelegate get_GetSourceImage();
    [CompilerGeneratedAttribute]
public void set_GetSourceImage(GetSourceImageDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual ResizeImageDelegate get_ResizeImageToStream();
    [CompilerGeneratedAttribute]
public void set_ResizeImageToStream(ResizeImageDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RequestKey();
    [CompilerGeneratedAttribute]
public void set_RequestKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SuggestedExtension();
    [CompilerGeneratedAttribute]
public void set_SuggestedExtension(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasModifiedDate();
    [CompilerGeneratedAttribute]
public void set_HasModifiedDate(bool value);
    public sealed virtual IResponseHeaders get_ResponseHeaders();
    public sealed virtual void set_ResponseHeaders(IResponseHeaders value);
    public sealed virtual NameValueCollection get_RewrittenQuerystring();
    public void set_RewrittenQuerystring(NameValueCollection value);
}
public class ImageResizer.Caching.ResponseHeaders : object {
    [CompilerGeneratedAttribute]
private bool <ApplyDuringPreSendRequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplyResponseHeadersDelegate <ApplyToResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpCacheability <CacheControl>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidUntilExpires>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressVaryHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <DefaultHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CacheDependency> <ServerCacheDependencies>k__BackingField;
    public bool ApplyDuringPreSendRequestHeaders { get; public set; }
    public string ContentType { get; public set; }
    public ApplyResponseHeadersDelegate ApplyToResponse { get; public set; }
    public HttpCacheability CacheControl { get; public set; }
    public DateTime Expires { get; public set; }
    public DateTime LastModified { get; public set; }
    public bool ValidUntilExpires { get; public set; }
    public bool SuppressVaryHeader { get; public set; }
    public NameValueCollection DefaultHeaders { get; public set; }
    public NameValueCollection Headers { get; public set; }
    public List`1<CacheDependency> ServerCacheDependencies { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ApplyDuringPreSendRequestHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplyDuringPreSendRequestHeaders(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContentType(string value);
    public static void DefaultApplyToResponseMethod(IResponseHeaders headers, HttpContext context);
    [CompilerGeneratedAttribute]
public sealed virtual ApplyResponseHeadersDelegate get_ApplyToResponse();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplyToResponse(ApplyResponseHeadersDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpCacheability get_CacheControl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheControl(HttpCacheability value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Expires();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Expires(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastModified(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ValidUntilExpires();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ValidUntilExpires(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SuppressVaryHeader();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuppressVaryHeader(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual NameValueCollection get_DefaultHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultHeaders(NameValueCollection value);
    [CompilerGeneratedAttribute]
public sealed virtual NameValueCollection get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(NameValueCollection value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<CacheDependency> get_ServerCacheDependencies();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServerCacheDependencies(List`1<CacheDependency> value);
}
public class ImageResizer.Collections.QuerystringBase`1 : NameValueCollection {
    public QuerystringBase`1(NameValueCollection q);
    public Nullable`1<T> Get(string name);
    public Nullable`1<T> Get(string name, Nullable`1<T> defaultValue);
    public T Get(string name, T defaultValue);
    public TK SetAsString(string name, T val);
    public TK Set(string name, Nullable`1<T> val);
}
public class ImageResizer.Collections.ReverseEnumerable`1 : ReverseEnumerable`1<T> {
    public ReverseEnumerable`1(ReadOnlyCollection`1<T> collection);
}
public class ImageResizer.Collections.ReverseEnumerator`1 : ReverseEnumerator`1<T> {
    public ReverseEnumerator`1(ReadOnlyCollection`1<T> collection);
}
public class ImageResizer.Collections.SafeList`1 : object {
    [CLSCompliantAttribute("False")]
protected ReadOnlyCollection`1 modreq(System.Runtime.CompilerServices.IsVolatile) items;
    protected object writeLock;
    [CompilerGeneratedAttribute]
private ChangedHandler<T> Changed;
    public T First { get; }
    public T Last { get; }
    public IEnumerable`1<T> Reversed { get; }
    public SafeList`1(IEnumerable`1<T> items);
    [CompilerGeneratedAttribute]
public void add_Changed(ChangedHandler<T> value);
    [CompilerGeneratedAttribute]
public void remove_Changed(ChangedHandler<T> value);
    protected void FireChanged();
    public ReadOnlyCollection`1<T> GetCollection();
    public IList`1<T> GetList();
    public void SetList(IEnumerable`1<T> list);
    public void Add(T item);
    public bool Remove(T item);
    public T get_First();
    public T get_Last();
    public void AddFirst(T item);
    public void ModifyList(ListEditor<T> callback);
    public bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<T> get_Reversed();
}
public class ImageResizer.Configuration.Config : object {
    private static Config modreq(System.Runtime.CompilerServices.IsVolatile) _singleton;
    private static object _singletonLock;
    protected PluginConfig plugins;
    private PipelineConfig pipeline;
    [CLSCompliantAttribute("False")]
protected ImageBuilder modreq(System.Runtime.CompilerServices.IsVolatile) _imageBuilder;
    [CLSCompliantAttribute("False")]
protected Object modreq(System.Runtime.CompilerServices.IsVolatile) _imageBuilderSync;
    private ResizerSection modreq(System.Runtime.CompilerServices.IsVolatile) configuration;
    private object configurationLock;
    public static Config Current { get; }
    public PluginConfig Plugins { get; }
    public PipelineConfig Pipeline { get; }
    public ImageBuilder CurrentImageBuilder { get; }
    protected ResizerSection cs { get; }
    public IssueSink configurationSectionIssues { get; }
    public IIssueProvider AllIssues { get; }
    public Config(ResizerSection config);
    public Config(ResizerSection config, bool addAspNetPlugins);
    private static Config();
    public static Config get_Current();
    public PluginConfig get_Plugins();
    public PipelineConfig get_Pipeline();
    public void UpgradeImageBuilder(ImageBuilder replacement);
    public ImageBuilder get_CurrentImageBuilder();
    public ImageJob Build(ImageJob job);
    public void BuildImage(object source, object dest, string settings);
    protected void InvalidateImageBuilder();
    protected ResizerSection get_cs();
    public IssueSink get_configurationSectionIssues();
    public IIssueProvider get_AllIssues();
    public string get(string selector, string defaultValue);
    public int get(string selector, int defaultValue);
    public long get(string selector, long defaultValue);
    public bool get(string selector, bool defaultValue);
    public T get(string selector, T defaultValue);
    public Node getNode(string selector);
    public Node getConfigXml();
    public void setConfigXml(Node n);
    public void setConfigXmlText(string xml);
    public void WriteDiagnosticsTo(string path);
    public string GetDiagnosticsPage();
    public string GetLicensesPage();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(SafeList`1<BuilderExtension> s);
}
public class ImageResizer.Configuration.HeartbeatHandler : MulticastDelegate {
    public HeartbeatHandler(object object, IntPtr method);
    public virtual void Invoke(IPipelineConfig sender, Config c);
    public virtual IAsyncResult BeginInvoke(IPipelineConfig sender, Config c, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.HttpModuleRequestAssistant : object {
    private HttpContext context;
    private IPipelineConfig conf;
    private IHttpModule sender;
    [CompilerGeneratedAttribute]
private string <RewrittenVirtualPath>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <RewrittenQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private Instructions <RewrittenInstructions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RewrittenMappedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RewrittenQueryHasDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessingIndicated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CachingIndicated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RewrittenVirtualPathIsAcceptedImageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EstimatedContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EstimatedFileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualFileAsync <VirtualFile>k__BackingField;
    public string RewrittenVirtualPath { get; private set; }
    public NameValueCollection RewrittenQuery { get; private set; }
    public Instructions RewrittenInstructions { get; private set; }
    public string RewrittenMappedPath { get; private set; }
    public bool RewrittenQueryHasDirective { get; private set; }
    public bool ProcessingIndicated { get; private set; }
    public bool CachingIndicated { get; private set; }
    public bool RewrittenVirtualPathIsAcceptedImageType { get; private set; }
    public string EstimatedContentType { get; private set; }
    public string EstimatedFileExtension { get; private set; }
    public IVirtualFileAsync VirtualFile { get; public set; }
    public bool IsVirtualFile { get; }
    public HttpModuleRequestAssistant(HttpContext context, IPipelineConfig config, IHttpModule sender);
    [CompilerGeneratedAttribute]
public string get_RewrittenVirtualPath();
    [CompilerGeneratedAttribute]
private void set_RewrittenVirtualPath(string value);
    [CompilerGeneratedAttribute]
public NameValueCollection get_RewrittenQuery();
    [CompilerGeneratedAttribute]
private void set_RewrittenQuery(NameValueCollection value);
    [CompilerGeneratedAttribute]
public Instructions get_RewrittenInstructions();
    [CompilerGeneratedAttribute]
private void set_RewrittenInstructions(Instructions value);
    [CompilerGeneratedAttribute]
public string get_RewrittenMappedPath();
    [CompilerGeneratedAttribute]
private void set_RewrittenMappedPath(string value);
    [CompilerGeneratedAttribute]
public bool get_RewrittenQueryHasDirective();
    [CompilerGeneratedAttribute]
private void set_RewrittenQueryHasDirective(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessingIndicated();
    [CompilerGeneratedAttribute]
private void set_ProcessingIndicated(bool value);
    [CompilerGeneratedAttribute]
public bool get_CachingIndicated();
    [CompilerGeneratedAttribute]
private void set_CachingIndicated(bool value);
    [CompilerGeneratedAttribute]
public bool get_RewrittenVirtualPathIsAcceptedImageType();
    [CompilerGeneratedAttribute]
private void set_RewrittenVirtualPathIsAcceptedImageType(bool value);
    public PostAuthorizeResult PostAuthorize();
    public string GenerateRequestCachingKey(Nullable`1<DateTime> modifiedData);
    [CompilerGeneratedAttribute]
public string get_EstimatedContentType();
    [CompilerGeneratedAttribute]
private void set_EstimatedContentType(string value);
    [CompilerGeneratedAttribute]
public string get_EstimatedFileExtension();
    [CompilerGeneratedAttribute]
private void set_EstimatedFileExtension(string value);
    [CompilerGeneratedAttribute]
public IVirtualFileAsync get_VirtualFile();
    [CompilerGeneratedAttribute]
public void set_VirtualFile(IVirtualFileAsync value);
    public bool get_IsVirtualFile();
    public void EstimateResponseInfo();
    public void FireMissing();
    private IHttpHandler CreateSFH();
    public void ApplyRewrittenPath();
    public void AssignSFH();
    internal void FireAccessDenied();
    internal void FireJobSuccess();
    internal void FirePostAuthorizeSuccess();
    internal void FirePostAuthorizeRequestException(Exception ex);
    internal void FireJobException(Exception ex);
}
public interface ImageResizer.Configuration.IPipelineConfig {
    public string ModifiedQueryStringKey { get; }
    public string ResponseArgsKey { get; }
    public string StopRoutingKey { get; }
    public string ModifiedPathKey { get; }
    public VppUsageOption VppUsage { get; }
    public string SkipFileTypeCheckKey { get; }
    public bool SkipFileTypeCheck { get; }
    public bool ModuleInstalled { get; public set; }
    public Nullable`1<bool> UsingAsyncMode { get; public set; }
    public string PreRewritePath { get; }
    public bool AuthorizeAllImages { get; public set; }
    public NameValueCollection ModifiedQueryString { get; public set; }
    public string DropQuerystringKeys { get; public set; }
    public abstract virtual bool IsAcceptedImageType(string filePath);
    public abstract virtual bool HasPipelineDirective(NameValueCollection q);
    public abstract virtual string get_ModifiedQueryStringKey();
    public abstract virtual string get_ResponseArgsKey();
    public abstract virtual string get_StopRoutingKey();
    public abstract virtual string get_ModifiedPathKey();
    public abstract virtual VppUsageOption get_VppUsage();
    public abstract virtual string get_SkipFileTypeCheckKey();
    public abstract virtual bool get_SkipFileTypeCheck();
    public abstract virtual bool get_ModuleInstalled();
    public abstract virtual void set_ModuleInstalled(bool value);
    public abstract virtual Nullable`1<bool> get_UsingAsyncMode();
    public abstract virtual void set_UsingAsyncMode(Nullable`1<bool> value);
    public abstract virtual string get_PreRewritePath();
    public abstract virtual string TrimFakeExtensions(string path);
    public abstract virtual ImageBuilder GetImageBuilder();
    public abstract virtual ImageFileType GuessOutputFileTypeIfSupported(Instructions commands, string virtualPath);
    public abstract virtual IAsyncTyrantCache GetAsyncCacheFor(HttpContext context, IAsyncResponsePlan plan);
    public abstract virtual IVirtualFile GetFile(string virtualPath, NameValueCollection queryString);
    public abstract virtual Task`1<IVirtualFileAsync> GetFileAsync(string virtualPath, NameValueCollection queryString);
    public abstract virtual bool FileExists(string virtualPath, NameValueCollection queryString);
    public abstract virtual Task`1<bool> FileExistsAsync(string virtualPath, NameValueCollection queryString);
    public abstract virtual bool get_AuthorizeAllImages();
    public abstract virtual void set_AuthorizeAllImages(bool value);
    public abstract virtual void FirePostAuthorizeRequest(IHttpModule sender, HttpContext httpContext);
    public abstract virtual void FireRewritingEvents(IHttpModule sender, HttpContext context, IUrlEventArgs ue);
    public abstract virtual void FireAuthorizeImage(IHttpModule sender, HttpContext context, IUrlAuthorizationEventArgs urlEventArgs);
    public abstract virtual void FirePreHandleImage(IHttpModule sender, HttpContext context, IResponseArgs e);
    public abstract virtual void FirePreHandleImageAsync(IHttpModule sender, HttpContext context, IAsyncResponsePlan e);
    public abstract virtual void FireImageMissing(IHttpModule sender, HttpContext context, IUrlEventArgs urlEventArgs);
    public abstract virtual void FireHeartbeat();
    public abstract virtual NameValueCollection get_ModifiedQueryString();
    public abstract virtual void set_ModifiedQueryString(NameValueCollection value);
    public abstract virtual bool IsAppDomainUnrestricted();
    public abstract virtual string get_DropQuerystringKeys();
    public abstract virtual void set_DropQuerystringKeys(string value);
}
[ObsoleteAttribute("Use ImageResizer.Issues.ConfigChecker instead")]
public class ImageResizer.Configuration.Issues.ConfigChecker : ConfigChecker {
    [ObsoleteAttribute("Use ImageResizer.Issues.ConfigChecker instead")]
public ConfigChecker(Config c);
}
[ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public interface ImageResizer.Configuration.Issues.IIssue {
}
[ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public interface ImageResizer.Configuration.Issues.IIssueProvider {
}
[ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public interface ImageResizer.Configuration.Issues.IIssueReceiver {
}
[ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public class ImageResizer.Configuration.Issues.Issue : Issue {
    [ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public Issue(string message);
    [ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public Issue(string message, string details, IssueSeverity severity);
    [ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public Issue(string message, IssueSeverity severity);
    [ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public Issue(string source, string message, string details, IssueSeverity severity);
}
[ObsoleteAttribute("Use ImageResizer.Issues.IssueGatherer instead")]
public class ImageResizer.Configuration.Issues.IssueGatherer : IssueGatherer {
    [ObsoleteAttribute("Use ImageResizer.Issues.IssueGatherer instead")]
public IssueGatherer(Config c);
}
[ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public class ImageResizer.Configuration.Issues.IssueSink : IssueSink {
    [ObsoleteAttribute("Use Imazen.Common.Issues instead of ImageResizer.Configuration.Issues")]
public IssueSink(string defaultSource);
}
public interface ImageResizer.Configuration.IUrlAuthorizationEventArgs {
    public bool AllowAccess { get; public set; }
    public NameValueCollection QueryString { get; }
    public string VirtualPath { get; }
    public abstract virtual bool get_AllowAccess();
    public abstract virtual void set_AllowAccess(bool value);
    public abstract virtual NameValueCollection get_QueryString();
    public abstract virtual string get_VirtualPath();
}
public interface ImageResizer.Configuration.IUrlEventArgs {
    public NameValueCollection QueryString { get; public set; }
    public string VirtualPath { get; public set; }
    public abstract virtual NameValueCollection get_QueryString();
    public abstract virtual void set_QueryString(NameValueCollection value);
    public abstract virtual string get_VirtualPath();
    public abstract virtual void set_VirtualPath(string value);
}
[FlagsAttribute]
public enum ImageResizer.Configuration.LicenseAccess : Enum {
    public int value__;
    public static LicenseAccess Local;
    public static LicenseAccess ProcessReadonly;
    public static LicenseAccess ProcessShareonly;
    public static LicenseAccess Process;
}
[FlagsAttribute]
public enum ImageResizer.Configuration.LicenseErrorAction : Enum {
    public int value__;
    public static LicenseErrorAction Watermark;
    public static LicenseErrorAction Exception;
}
public interface ImageResizer.Configuration.Logging.ILogger {
    public bool IsTraceEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public string LoggerName { get; public set; }
    public abstract virtual void Log(string level, string message);
    public abstract virtual void Trace(string message);
    public abstract virtual void Trace(string message, Object[] args);
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(string message, Object[] args);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(string message, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(string message, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string message, Object[] args);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Fatal(string message, Object[] args);
    public abstract virtual bool IsEnabled(string level);
    public abstract virtual bool get_IsTraceEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual string get_LoggerName();
    public abstract virtual void set_LoggerName(string value);
}
public interface ImageResizer.Configuration.Logging.ILoggerProvider {
    public ILogger Logger { get; }
    public abstract virtual ILogger get_Logger();
}
public interface ImageResizer.Configuration.Logging.ILogManager {
    public abstract virtual void LoadConfigFromFile(string fileName);
    public abstract virtual ILogger GetLogger(string loggerName);
}
[ExtensionAttribute]
internal static class ImageResizer.Configuration.Performance.AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetShortCommit(Assembly a);
    [ExtensionAttribute]
public static string GetEditionCode(Assembly a);
}
internal class ImageResizer.Configuration.Performance.CpuInfo : object {
    private static Byte[] X86CodeBytes;
    private static Byte[] X64CodeBytes;
    private static CpuInfo();
    public static Byte[] Invoke(int level);
    private static IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, AllocationType flAllocationType, MemoryProtection flProtect);
    private static bool VirtualFree(IntPtr lpAddress, UInt32 dwSize, UInt32 dwFreeType);
}
internal class ImageResizer.Configuration.Performance.DiagnosticsReport : object {
    private Config c;
    private HttpContext httpContext;
    private Dictionary`2<string, string> friendlyEditionNames;
    public DiagnosticsReport(Config c, HttpContext httpContext);
    private IEnumerable`1<T> GetProviders();
    internal string Header();
    internal string Generate();
    private static IInfoAccumulator GetReportedPairs();
    private Dictionary`2<string, List`1<string>> GetImageResizerVersions(Assembly[] assemblies);
    internal string GetEdition();
    private string LookupEdition(string editionCode);
    private string RedactedConfigXml();
    private string ServerSoftware();
    private void CheckClassicPipeline(List`1<IIssue> issues);
    private void CheckForMismatchedVersions(List`1<IIssue> issues, Assembly[] assemblies);
    [CompilerGeneratedAttribute]
private bool <GetEdition>b__9_2(string s);
}
public class ImageResizer.Configuration.Performance.GlobalPerf : object {
    private IssueSink sink;
    [CompilerGeneratedAttribute]
private static GlobalPerf <Singleton>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<ProcessInfo> <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<HardwareInfo> <Hardware>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<PluginInfo> <Plugins>k__BackingField;
    private HttpModuleCollection httpModules;
    [CompilerGeneratedAttribute]
private NamedInterval[] <Intervals>k__BackingField;
    private ConcurrentDictionary`2<string, MultiIntervalStats> rates;
    private MultiIntervalStats blobReadEvents;
    private MultiIntervalStats blobReadBytes;
    private MultiIntervalStats jobs;
    private MultiIntervalStats decodedPixels;
    private MultiIntervalStats encodedPixels;
    private ConcurrentDictionary`2<string, IPercentileProviderSink> percentiles;
    private IPercentileProviderSink job_times;
    private IPercentileProviderSink decode_times;
    private IPercentileProviderSink encode_times;
    private IPercentileProviderSink job_other_time;
    private IPercentileProviderSink blob_read_times;
    private IPercentileProviderSink collect_info_times;
    private DictionaryCounter`1<string> counters;
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> <Percentiles>k__BackingField;
    private IPercentileProviderSink sourceWidths;
    private IPercentileProviderSink sourceHeights;
    private IPercentileProviderSink outputWidths;
    private IPercentileProviderSink outputHeights;
    private IPercentileProviderSink sourceMegapixels;
    private IPercentileProviderSink outputMegapixels;
    private IPercentileProviderSink scalingRatios;
    private IPercentileProviderSink sourceAspectRatios;
    private IPercentileProviderSink outputAspectRatios;
    private ConcurrentDictionary`2<string, DictionaryCounter`1<string>> uniques;
    public static GlobalPerf Singleton { get; }
    private Lazy`1<ProcessInfo> Process { get; }
    private Lazy`1<HardwareInfo> Hardware { get; }
    private Lazy`1<PluginInfo> Plugins { get; }
    private NamedInterval[] Intervals { get; }
    private IEnumerable`1<int> Percentiles { get; }
    private static GlobalPerf();
    [CompilerGeneratedAttribute]
public static GlobalPerf get_Singleton();
    [CompilerGeneratedAttribute]
private Lazy`1<ProcessInfo> get_Process();
    [CompilerGeneratedAttribute]
private Lazy`1<HardwareInfo> get_Hardware();
    [CompilerGeneratedAttribute]
private Lazy`1<PluginInfo> get_Plugins();
    [CompilerGeneratedAttribute]
private NamedInterval[] get_Intervals();
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> get_Percentiles();
    internal void JobComplete(ImageBuilder builder, ImageJob job);
    private long CountLimitedUniqueValuesIgnoreCase(string category, string value, int limit, string otherBucketValue);
    private IEnumerable`1<string> GetPopularUniqueValues(string category, int limit);
    private void NoticeDomains(HttpRequest request);
    private void PostJobQuery(Instructions q);
    internal void PreRewriteQuery(NameValueCollection q);
    internal void QueryRewrittenWithDirective(string rewrittenVirtualPath);
    public static void BlobRead(Config c, long ticks, long bytes);
    public IInfoAccumulator GetReportPairs();
    public void TrackRate(string eventCategoryKey, long count);
    public void IncrementCounter(string key);
    [CompilerGeneratedAttribute]
private HardwareInfo <.ctor>b__43_0();
    [CompilerGeneratedAttribute]
private MultiIntervalStats <TrackRate>b__54_0(string k);
}
internal class ImageResizer.Configuration.Performance.HardwareInfo : object {
    [CompilerGeneratedAttribute]
private string <MachineDigest>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogicalCores>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OperatingSystem64Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NetworkDrives>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OtherDrives>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FixedDriveInfo> <FixedDrives>k__BackingField;
    public string MachineDigest { get; }
    public int LogicalCores { get; }
    public bool OperatingSystem64Bit { get; }
    public int NetworkDrives { get; }
    public int OtherDrives { get; }
    public IEnumerable`1<FixedDriveInfo> FixedDrives { get; }
    public HardwareInfo(IIssueReceiver sink);
    [CompilerGeneratedAttribute]
public string get_MachineDigest();
    [CompilerGeneratedAttribute]
public int get_LogicalCores();
    [CompilerGeneratedAttribute]
public bool get_OperatingSystem64Bit();
    [CompilerGeneratedAttribute]
public int get_NetworkDrives();
    [CompilerGeneratedAttribute]
public int get_OtherDrives();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FixedDriveInfo> get_FixedDrives();
    public void Add(IInfoAccumulator query);
}
internal class ImageResizer.Configuration.Performance.PluginInfo : object {
    private PluginUsage pluginUsage;
    private Lazy`1<IDictionary`2<string, string>> pluginShorthand;
    private IEnumerable`1<string> GetPluginsUsedShorthand();
    public void Add(IInfoAccumulator q);
    public void Notify(PluginConfig plugins);
    [CompilerGeneratedAttribute]
private string <GetPluginsUsedShorthand>b__3_1(string s);
}
internal class ImageResizer.Configuration.Performance.PluginUsage : object {
    private List`1<Type> pluginTypes;
    private List`1<KeyValuePair`2<string, string>> queryRelevancies;
    private int singletonPluginCount;
    public void Notify(PluginConfig plugins);
    private void CheckCurrent();
    private void Check(PluginConfig plugins);
    public IEnumerable`1<Type> GetPluginsInstalled();
    public IEnumerable`1<KeyValuePair`2<string, string>> GetRelevantQueryPairs();
}
internal class ImageResizer.Configuration.Performance.ProcessInfo : object {
    [CompilerGeneratedAttribute]
private static Guid <ProcessGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Process64Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DotNetVersionInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IisVer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IntegratedPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <HttpModules>k__BackingField;
    public static Guid ProcessGuid { get; }
    public static int ProcessId { get; }
    public bool Process64Bit { get; }
    public string DotNetVersionInstalled { get; }
    private string IisVer { get; }
    private bool IntegratedPipeline { get; }
    private IEnumerable`1<string> HttpModules { get; private set; }
    private static ProcessInfo();
    [CompilerGeneratedAttribute]
public static Guid get_ProcessGuid();
    [CompilerGeneratedAttribute]
public static int get_ProcessId();
    [CompilerGeneratedAttribute]
public bool get_Process64Bit();
    [CompilerGeneratedAttribute]
public string get_DotNetVersionInstalled();
    [CompilerGeneratedAttribute]
private string get_IisVer();
    [CompilerGeneratedAttribute]
private bool get_IntegratedPipeline();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> get_HttpModules();
    [CompilerGeneratedAttribute]
private void set_HttpModules(IEnumerable`1<string> value);
    public void SetModules(HttpModuleCollection col);
    public void Add(IInfoAccumulator query);
    private static Tuple`2<Nullable`1<int>, Nullable`1<int>> GetIisVerFromRegistry();
    private static string GetIisVerStringFromRegistry();
    private static string Get45PlusFromRegistry();
    private static string CheckFor45PlusVersion(int releaseKey);
    private static IEnumerable`1<string> GetHttpModules(HttpModuleCollection modules);
    public static AspNetHostingPermissionLevel GetCurrentTrustLevel();
    public static string MainModuleFileName();
    public static bool HasFullTrust();
}
public class ImageResizer.Configuration.PipelineConfig : object {
    protected Config c;
    private NameValueCollection pipelineDefaults;
    protected object _cachedUrlDataSync;
    [CLSCompliantAttribute("False")]
protected Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _cachedDirectives;
    [CLSCompliantAttribute("False")]
protected Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _cachedExtensions;
    [CLSCompliantAttribute("False")]
protected IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _fakeExtensions;
    [CompilerGeneratedAttribute]
private RequestEventHandler OnFirstRequest;
    [CompilerGeneratedAttribute]
private RequestEventHandler PostAuthorizeRequestStart;
    [CompilerGeneratedAttribute]
private UrlRewritingEventHandler Rewrite;
    [CompilerGeneratedAttribute]
private UrlRewritingEventHandler RewriteDefaults;
    [CompilerGeneratedAttribute]
private UrlRewritingEventHandler PostRewrite;
    [CompilerGeneratedAttribute]
private UrlAuthorizationEventHandler AuthorizeImage;
    [CompilerGeneratedAttribute]
private UrlEventHandler ImageMissing;
    [CompilerGeneratedAttribute]
private PreHandleImageEventHandler PreHandleImage;
    [CompilerGeneratedAttribute]
private PreHandleImageAsyncEventHandler PreHandleImageAsync;
    [CompilerGeneratedAttribute]
private HeartbeatHandler Heartbeat;
    [CLSCompliantAttribute("False")]
protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) firedFirstRequest;
    protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) firstRequestFinished;
    protected object firedFirstRequestSync;
    protected long processedCount;
    [CompilerGeneratedAttribute]
private bool <ModuleInstalled>k__BackingField;
    private Nullable`1<bool> _usingAsyncMode;
    private Nullable`1<bool> _authorizeAllImages;
    private string _dropQuerystringKeys;
    public ICollection`1<string> AcceptedImageExtensions { get; }
    public ICollection`1<string> SupportedQuerystringKeys { get; }
    public IList`1<string> FakeExtensions { get; }
    public string ModifiedPathKey { get; }
    public string StopRoutingKey { get; }
    public string PreRewritePath { get; public set; }
    public string ModifiedQueryStringKey { get; }
    public NameValueCollection ModifiedQueryString { get; public set; }
    public string SkipFileTypeCheckKey { get; }
    public bool SkipFileTypeCheck { get; public set; }
    public string ResponseArgsKey { get; }
    public bool IsHandlingRequest { get; }
    public VppUsageOption VppUsage { get; }
    public Nullable`1<int> MaxConcurrentJobs { get; }
    public long ProcessedCount { get; }
    public bool ModuleInstalled { get; public set; }
    public Nullable`1<bool> UsingAsyncMode { get; public set; }
    public bool AuthorizeAllImages { get; public set; }
    public string DropQuerystringKeys { get; public set; }
    public PipelineConfig(Config c);
    private void PipelineConfig_RewriteDefaults(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    protected void urlModifyingPlugins_Changed(SafeList`1<IQuerystringPlugin> sender);
    protected void _cacheUrlData();
    protected Dictionary`2<string, bool> getCachedDirectives();
    protected Dictionary`2<string, bool> getCachedExtensions();
    public ICollection`1<string> get_AcceptedImageExtensions();
    public ICollection`1<string> get_SupportedQuerystringKeys();
    protected string getExtension(string path);
    public sealed virtual bool IsAcceptedImageType(string path);
    public sealed virtual bool HasPipelineDirective(NameValueCollection q);
    private IEnumerable`1<string> PipelineDirectivesPresent(NameValueCollection q);
    public IList`1<string> get_FakeExtensions();
    public sealed virtual string TrimFakeExtensions(string path);
    public sealed virtual string get_ModifiedPathKey();
    public sealed virtual string get_StopRoutingKey();
    public sealed virtual string get_PreRewritePath();
    public void set_PreRewritePath(string value);
    public sealed virtual string get_ModifiedQueryStringKey();
    public sealed virtual NameValueCollection get_ModifiedQueryString();
    public sealed virtual void set_ModifiedQueryString(NameValueCollection value);
    public sealed virtual string get_SkipFileTypeCheckKey();
    public sealed virtual bool get_SkipFileTypeCheck();
    public void set_SkipFileTypeCheck(bool value);
    public sealed virtual string get_ResponseArgsKey();
    public bool get_IsHandlingRequest();
    public sealed virtual VppUsageOption get_VppUsage();
    public Nullable`1<int> get_MaxConcurrentJobs();
    [AsyncStateMachineAttribute("ImageResizer.Configuration.PipelineConfig/<GetFileAsync>d__48")]
public sealed virtual Task`1<IVirtualFileAsync> GetFileAsync(string virtualPath, NameValueCollection queryString);
    public sealed virtual IVirtualFile GetFile(string virtualPath, NameValueCollection queryString);
    public sealed virtual bool FileExists(string virtualPath, NameValueCollection queryString);
    [AsyncStateMachineAttribute("ImageResizer.Configuration.PipelineConfig/<FileExistsAsync>d__51")]
public sealed virtual Task`1<bool> FileExistsAsync(string virtualPath, NameValueCollection queryString);
    public sealed virtual ImageBuilder GetImageBuilder();
    public sealed virtual ImageFileType GuessOutputFileTypeIfSupported(Instructions commands, string virtualPath);
    [CompilerGeneratedAttribute]
public void add_OnFirstRequest(RequestEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnFirstRequest(RequestEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PostAuthorizeRequestStart(RequestEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PostAuthorizeRequestStart(RequestEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Rewrite(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Rewrite(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RewriteDefaults(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RewriteDefaults(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PostRewrite(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PostRewrite(UrlRewritingEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AuthorizeImage(UrlAuthorizationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AuthorizeImage(UrlAuthorizationEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ImageMissing(UrlEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ImageMissing(UrlEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreHandleImage(PreHandleImageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreHandleImage(PreHandleImageEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreHandleImageAsync(PreHandleImageAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreHandleImageAsync(PreHandleImageAsyncEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Heartbeat(HeartbeatHandler value);
    [CompilerGeneratedAttribute]
public void remove_Heartbeat(HeartbeatHandler value);
    public sealed virtual void FirePostAuthorizeRequest(IHttpModule sender, HttpContext httpContext);
    public sealed virtual void FireRewritingEvents(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public sealed virtual void FireHeartbeat();
    public void FireHeartbeatViaAspNetCache(int intervalSeconds);
    public sealed virtual void FireAuthorizeImage(IHttpModule sender, HttpContext context, IUrlAuthorizationEventArgs e);
    public sealed virtual void FirePreHandleImageAsync(IHttpModule sender, HttpContext context, IAsyncResponsePlan e);
    public sealed virtual void FireImageMissing(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public long get_ProcessedCount();
    public sealed virtual void FirePreHandleImage(IHttpModule sender, HttpContext context, IResponseArgs e);
    public sealed virtual ResizeSettings Modify(ResizeSettings settings);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ModuleInstalled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ModuleInstalled(bool value);
    public sealed virtual Nullable`1<bool> get_UsingAsyncMode();
    public sealed virtual void set_UsingAsyncMode(Nullable`1<bool> value);
    public sealed virtual bool IsAppDomainUnrestricted();
    public sealed virtual bool get_AuthorizeAllImages();
    public sealed virtual void set_AuthorizeAllImages(bool value);
    public sealed virtual IAsyncTyrantCache GetAsyncCacheFor(HttpContext context, IAsyncResponsePlan plan);
    public sealed virtual string get_DropQuerystringKeys();
    public sealed virtual void set_DropQuerystringKeys(string value);
    public sealed virtual string ModifyRequestCacheKey(string currentKey, string virtualPath, NameValueCollection queryString);
    [CompilerGeneratedAttribute]
private void <FireHeartbeatViaAspNetCache>b__90_0(string k, object v, CacheItemRemovedReason r);
}
public class ImageResizer.Configuration.PluginConfig : IssueSink {
    protected NativeDependencyManager ndeps;
    protected Config c;
    internal PluginLoadingHints hints;
    [CLSCompliantAttribute("False")]
protected Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _pluginsLoaded;
    protected object _loadPluginsSync;
    protected SafeList`1<ICurrentConfigProvider> configProviders;
    protected SafeList`1<BuilderExtension> imageBuilderExtensions;
    protected SafeList`1<IEncoder> imageEncoders;
    protected SafeList`1<IAsyncTyrantCache> cachingSystems;
    protected SafeList`1<IQuerystringPlugin> querystringPlugins;
    protected SafeList`1<IFileExtensionPlugin> fileExtensionPlugins;
    protected SafeList`1<IVirtualImageProvider> virtualProviderPlugins;
    protected SafeList`1<ISettingsModifier> settingsModifierPlugins;
    private SafeList`1<IPluginModifiesRequestCacheKey> modifiesRequestCacheKeyPlugins;
    protected SafeList`1<IPlugin> allPlugins;
    protected ILogManager _logManager;
    public LoggingAvailableEvent LoggingAvailable;
    [CompilerGeneratedAttribute]
private LicensingChangeEvent LicensePluginsChange;
    private LicenseAccess _licenseScope;
    [CompilerGeneratedAttribute]
private LicenseErrorAction <LicenseError>k__BackingField;
    private ConcurrentDictionary`2<string, string> mappedDomains;
    public bool PluginsLoaded { get; }
    public SafeList`1<ICurrentConfigProvider> ConfigProviders { get; }
    public SafeList`1<BuilderExtension> ImageBuilderExtensions { get; }
    public SafeList`1<IEncoder> ImageEncoders { get; }
    public SafeList`1<IAsyncTyrantCache> CachingSystems { get; }
    public SafeList`1<IQuerystringPlugin> QuerystringPlugins { get; }
    public SafeList`1<IFileExtensionPlugin> FileExtensionPlugins { get; }
    public SafeList`1<IVirtualImageProvider> VirtualProviderPlugins { get; }
    public SafeList`1<ISettingsModifier> SettingsModifierPlugins { get; }
    public SafeList`1<IPluginModifiesRequestCacheKey> ModifiesRequestCacheKeyPlugins { get; }
    public SafeList`1<IPlugin> AllPlugins { get; }
    public IEncoderProvider EncoderProvider { get; }
    public ILogManager LogManager { get; public set; }
    public LicenseAccess LicenseScope { get; public set; }
    public LicenseErrorAction LicenseError { get; public set; }
    public PluginConfig(Config c);
    public void LoadPlugins();
    public void ForceLoadPlugins();
    public bool get_PluginsLoaded();
    protected void loadPluginsInternal();
    public IList`1<IPlugin> GetPlugins(Type type);
    public IList`1<T> GetAll();
    public bool HasPlugin(Type type);
    public bool Has();
    public T Get();
    public T GetOrInstall();
    public T GetOrInstall(T newInstance);
    public IPlugin Install(IPlugin plugin);
    public bool Uninstall(IPlugin plugin);
    public SafeList`1<ICurrentConfigProvider> get_ConfigProviders();
    public SafeList`1<BuilderExtension> get_ImageBuilderExtensions();
    public SafeList`1<IEncoder> get_ImageEncoders();
    public SafeList`1<IAsyncTyrantCache> get_CachingSystems();
    public SafeList`1<IQuerystringPlugin> get_QuerystringPlugins();
    public SafeList`1<IFileExtensionPlugin> get_FileExtensionPlugins();
    public SafeList`1<IVirtualImageProvider> get_VirtualProviderPlugins();
    public SafeList`1<ISettingsModifier> get_SettingsModifierPlugins();
    public SafeList`1<IPluginModifiesRequestCacheKey> get_ModifiesRequestCacheKeyPlugins();
    public SafeList`1<IPlugin> get_AllPlugins();
    public IEncoderProvider get_EncoderProvider();
    public ILogManager get_LogManager();
    public void set_LogManager(ILogManager value);
    public sealed virtual IEncoder GetEncoder(ResizeSettings settings, object original);
    protected void remove_plugins_by_name(string name);
    protected void add_plugin_by_name(string name, NameValueCollection args);
    public IPlugin AddPluginByName(string name, NameValueCollection pluginConfig);
    protected void clear_plugins_by_type(string type);
    protected List`1<string> GetOptimizedAssemblyList(string assemblyName, string pluginName);
    private Tuple`2<string, string> ParseName(string typeName);
    public Type FindPluginType(string searchNameString);
    protected IPlugin CreatePluginByName(string name, NameValueCollection args);
    public void LoadNativeDependenciesForType(Type t);
    protected IPlugin CreatePluginByType(Type t, NameValueCollection args);
    public void remove_plugin(object plugin);
    public void add_plugin(IPlugin plugin);
    public void RemoveAll();
    public virtual IEnumerable`1<IIssue> GetIssues();
    [CompilerGeneratedAttribute]
public void add_LicensePluginsChange(LicensingChangeEvent value);
    [CompilerGeneratedAttribute]
public void remove_LicensePluginsChange(LicensingChangeEvent value);
    public void FireLicensePluginsChange();
    public void AddLicense(string license);
    public LicenseAccess get_LicenseScope();
    public void set_LicenseScope(LicenseAccess value);
    [CompilerGeneratedAttribute]
public LicenseErrorAction get_LicenseError();
    [CompilerGeneratedAttribute]
public void set_LicenseError(LicenseErrorAction value);
    public void AddLicensedDomainMapping(string localHostname, string licensedDomain);
    public IEnumerable`1<KeyValuePair`2<string, string>> GetLicensedDomainMappings();
}
internal class ImageResizer.Configuration.PluginLoadingHints : object {
    private Dictionary`2<string, List`1<string>> hints;
    private void AddHint(string name, string expansion);
    public IEnumerable`1<string> GetExpansions(string name);
    public IDictionary`2<string, string> GetReverseHints();
    private void LoadHints();
}
public class ImageResizer.Configuration.Plugins.NativeDependencyManager : IssueSink {
    private string TargetFolder;
    private SafeList`1<string> filesVerified;
    private SafeList`1<string> assembliesProcessed;
    public void EnsureLoaded(Assembly a);
    public void EnsureLoaded(Node manifest, string assemblyName, Stopwatch sw);
    private void DownloadFile(Dependency d, StringBuilder message);
}
public class ImageResizer.Configuration.PreHandleImageAsyncEventHandler : MulticastDelegate {
    public PreHandleImageAsyncEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context, IAsyncResponsePlan e);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, IAsyncResponsePlan e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.PreHandleImageEventHandler : MulticastDelegate {
    public PreHandleImageEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context, IResponseArgs e);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, IResponseArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.RequestEventHandler : MulticastDelegate {
    public RequestEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.UrlAuthorizationEventArgs : EventArgs {
    private bool allowAccess;
    protected string _virtualPath;
    protected NameValueCollection _queryString;
    public bool AllowAccess { get; public set; }
    public NameValueCollection QueryString { get; }
    public string VirtualPath { get; }
    public UrlAuthorizationEventArgs(string virtualPath, NameValueCollection queryString, bool allowAccess);
    public sealed virtual bool get_AllowAccess();
    public sealed virtual void set_AllowAccess(bool value);
    public sealed virtual NameValueCollection get_QueryString();
    public sealed virtual string get_VirtualPath();
}
public class ImageResizer.Configuration.UrlAuthorizationEventHandler : MulticastDelegate {
    public UrlAuthorizationEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context, IUrlAuthorizationEventArgs e);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, IUrlAuthorizationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.UrlEventArgs : EventArgs {
    protected string _virtualPath;
    protected NameValueCollection _queryString;
    public NameValueCollection QueryString { get; public set; }
    public string VirtualPath { get; public set; }
    public UrlEventArgs(string virtualPath, NameValueCollection queryString);
    public sealed virtual NameValueCollection get_QueryString();
    public sealed virtual void set_QueryString(NameValueCollection value);
    public sealed virtual string get_VirtualPath();
    public sealed virtual void set_VirtualPath(string value);
}
public class ImageResizer.Configuration.UrlEventHandler : MulticastDelegate {
    public UrlEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, IUrlEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ImageResizer.Configuration.UrlRewritingEventHandler : MulticastDelegate {
    public UrlRewritingEventHandler(object object, IntPtr method);
    public virtual void Invoke(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public virtual IAsyncResult BeginInvoke(IHttpModule sender, HttpContext context, IUrlEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum ImageResizer.Configuration.VppUsageOption : Enum {
    public int value__;
    public static VppUsageOption Fallback;
    public static VppUsageOption Never;
    public static VppUsageOption Always;
}
[DefaultMemberAttribute("Item")]
public class ImageResizer.Configuration.Xml.Node : object {
    private NameValueCollection attrs;
    [CompilerGeneratedAttribute]
private string <TextContents>k__BackingField;
    private string name;
    private List`1<Node> children;
    protected Dictionary`2<string, ICollection`1<Node>> _cachedResults;
    public NameValueCollection Attrs { get; public set; }
    public string Item { get; public set; }
    public string TextContents { get; public set; }
    public string Name { get; public set; }
    public List`1<Node> Children { get; public set; }
    public bool IsEmpty { get; }
    public Node(string localName);
    public Node(XmlElement e, IIssueReceiver ir);
    public NameValueCollection get_Attrs();
    public void set_Attrs(NameValueCollection value);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    [CompilerGeneratedAttribute]
public string get_TextContents();
    [CompilerGeneratedAttribute]
public void set_TextContents(string value);
    public string get_Name();
    public void set_Name(string value);
    public List`1<Node> get_Children();
    public void set_Children(List`1<Node> value);
    public IList`1<Node> childrenByName(string elementName);
    public string queryAttr(string selector);
    protected KeyValuePair`2<string, string> parseAttributeName(string selector);
    public string queryAttr(string nodeSelector, string attrName);
    public Node queryFirst(string selector);
    public void setAttr(string selector, string attrValue);
    public void setAttr(string nodeSelector, string attrName, string attrValue);
    public Node makeNodeTree(string selector);
    public ICollection`1<Node> query(string selector);
    public void clearQueryCache();
    public Node RedactAttributes(string elementSelector, String[] attributeNames, string replaceWith);
    public ICollection`1<Node> queryUncached(string selector);
    public Node deepCopy();
    public bool get_IsEmpty();
    public XmlElement ToXmlElement();
    public XmlElement ToXmlElement(XmlDocument doc);
    public virtual string ToString();
    public static Node FromXmlFragment(string xml, IssueSink sink);
}
public class ImageResizer.Configuration.Xml.Selector : List`1<string> {
    public string Last { get; }
    public Selector(List`1<string> items);
    public Selector(string selector);
    public string get_Last();
    public Selector GetSublist(int startAt);
    public Selector GetRemainder();
    public Selector GetAllExceptLast();
    public virtual string ToString();
}
[ObsoleteAttribute("Obsolete. Use Mode=Crop to specify automatic cropping. Set CropTopLeft and CropTopRight to specify custom coordinates. Will be removed in V3.5 or V4.")]
public enum ImageResizer.CropMode : Enum {
    public int value__;
    public static CropMode None;
    [ObsoleteAttribute("Use Mode=Crop instead.")]
public static CropMode Auto;
    public static CropMode Custom;
}
[ObsoleteAttribute("Obsolete. Specify 0 for a crop unit to indicate source pixel coordinates.  Will be removed in V3.5 or V4.")]
public enum ImageResizer.CropUnits : Enum {
    public int value__;
    public static CropUnits SourcePixels;
    public static CropUnits Custom;
}
[ExtensionAttribute]
internal static class ImageResizer.ExtensionMethods.DictionaryExtensions : object {
    [ExtensionAttribute]
internal static TK Get(IDictionary`2<string, object> d, string key, TK defaultValue);
}
[ExtensionAttribute]
public static class ImageResizer.ExtensionMethods.EnumExtensions : object {
    private static Dictionary`2<Type, Dictionary`2<string, Enum>> values;
    private static Dictionary`2<Type, Dictionary`2<Enum, string>> preferredValues;
    private static void LoadValues(Type t);
    private static Dictionary`2<string, Enum> GetValues(Type t);
    private static Dictionary`2<Enum, string> GetPreferredStrings(Type t);
    [ExtensionAttribute]
public static T Parse(T en, string value, T defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> Parse(T en, string value);
    public static Nullable`1<T> Parse(string value);
    [ExtensionAttribute]
public static string ToPreferredString(Enum en, bool lowerCase);
}
[AttributeUsageAttribute("272")]
public class ImageResizer.ExtensionMethods.EnumRemovePrefixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Default>k__BackingField;
    public string Name { get; public set; }
    public bool Default { get; public set; }
    public EnumRemovePrefixAttribute(string name, bool defaultForSerialization);
    public EnumRemovePrefixAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(bool value);
}
[AttributeUsageAttribute("272")]
public class ImageResizer.ExtensionMethods.EnumStringAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Default>k__BackingField;
    public string Name { get; public set; }
    public bool Default { get; public set; }
    public EnumStringAttribute(string name, bool defaultForSerialization);
    public EnumStringAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(bool value);
}
[ExtensionAttribute]
public static class ImageResizer.ExtensionMethods.GenericExtensions : object {
    [ExtensionAttribute]
public static string Delimited(IEnumerable`1<T> values, string separator);
    [ExtensionAttribute]
public static string Delimited(String[] values, string separator);
    [ExtensionAttribute]
public static TResult MapNonNull(T v, Func`2<T, TResult> mapNonNull);
    [ExtensionAttribute]
public static Nullable`1<TResult> MapNonNull(T v, Func`2<T, Nullable`1<TResult>> mapNonNull);
    [ExtensionAttribute]
public static Nullable`1<TResult> MapNonNull(Nullable`1<T> v, Func`2<T, Nullable`1<TResult>> mapNonNull);
    [ExtensionAttribute]
public static TResult MapNonNull(Nullable`1<T> v, Func`2<T, TResult> mapNonNull);
}
[ExtensionAttribute]
public static class ImageResizer.ExtensionMethods.NameValueCollectionExtensions : object {
    private static NumberStyles floatingPointStyle;
    private static NameValueCollectionExtensions();
    [ExtensionAttribute]
public static string GetAsString(NameValueCollection t, string name, string defaultValue);
    [ExtensionAttribute]
public static Nullable`1<T> Get(NameValueCollection t, string name);
    [ExtensionAttribute]
public static Nullable`1<T> Get(NameValueCollection q, string name, Nullable`1<T> defaultValue);
    [ExtensionAttribute]
public static T Get(NameValueCollection q, string name, T defaultValue);
    public static Nullable`1<T> ParsePrimitive(string value, Nullable`1<T> defaultValue);
    public static string SerializePrimitive(Nullable`1<T> val);
    [ExtensionAttribute]
public static NameValueCollection SetAsString(NameValueCollection q, string name, T val);
    [ExtensionAttribute]
public static NameValueCollection Set(NameValueCollection q, string name, Nullable`1<T> val);
    [ExtensionAttribute]
public static T[] GetList(NameValueCollection q, string name, Nullable`1<T> fallbackValue, Int32[] allowedSizes);
    public static T[] ParseList(string text, Nullable`1<T> fallbackValue, Int32[] allowedSizes);
    private static string JoinPrimitives(T[] array, char delimiter);
    [ExtensionAttribute]
public static NameValueCollection SetList(NameValueCollection q, string name, T[] values, bool throwExceptions, Int32[] allowedSizes);
    [ExtensionAttribute]
public static bool IsOneSpecified(NameValueCollection q, String[] keys);
    [ExtensionAttribute]
public static NameValueCollection Normalize(NameValueCollection q, string primary, string secondary);
    [ExtensionAttribute]
public static NameValueCollection Keep(NameValueCollection q, String[] keysToKeep);
    [ExtensionAttribute]
public static NameValueCollection Exclude(NameValueCollection q, String[] keysToRemove);
    [ExtensionAttribute]
public static NameValueCollection MergeDefaults(NameValueCollection q, NameValueCollection defaults);
}
[ExtensionAttribute]
public static class ImageResizer.ExtensionMethods.StreamExtensions : object {
    [ExtensionAttribute]
public static MemoryStream CopyToMemoryStream(Stream s);
    [AsyncStateMachineAttribute("ImageResizer.ExtensionMethods.StreamExtensions/<CopyToMemoryStreamAsync>d__1")]
[ExtensionAttribute]
public static Task`1<MemoryStream> CopyToMemoryStreamAsync(Stream s, int bufferSize);
    [ExtensionAttribute]
public static MemoryStream CopyToMemoryStream(Stream s, bool entireStream);
    [ExtensionAttribute]
public static MemoryStream CopyToMemoryStream(Stream s, bool entireStream, int chunkSize);
    [ExtensionAttribute]
public static Byte[] CopyToBytes(Stream s);
    [ExtensionAttribute]
public static Byte[] CopyToBytes(Stream s, bool entireStream);
    [ExtensionAttribute]
public static void CopyToStream(Stream s, Stream other);
    [ExtensionAttribute]
public static void CopyToStream(Stream s, Stream other, bool entireStream);
    [ExtensionAttribute]
public static void CopyToStream(Stream src, Stream dest, bool entireStream, int chunkSize);
    [ExtensionAttribute]
private static Byte[] CopyMemoryStreamToBytes(MemoryStream src, bool entireStream);
    [ExtensionAttribute]
public static Byte[] CopyToBytes(Stream src, bool entireStream, int chunkSize);
    [AsyncStateMachineAttribute("ImageResizer.ExtensionMethods.StreamExtensions/<CopyToBytesAsync>d__11")]
[ExtensionAttribute]
public static Task`1<Byte[]> CopyToBytesAsync(Stream src, bool entireStream, int chunkSize);
    [ExtensionAttribute]
public static Byte[] CopyOrReturnBuffer(Stream src, Int64& length, bool entireStream, int chunkSize);
}
public enum ImageResizer.FitMode : Enum {
    public int value__;
    public static FitMode None;
    public static FitMode Max;
    public static FitMode Pad;
    public static FitMode Crop;
    public static FitMode Carve;
    public static FitMode Stretch;
}
public enum ImageResizer.FlipMode : Enum {
    public int value__;
    public static FlipMode None;
    [EnumStringAttribute("h")]
public static FlipMode X;
    [EnumStringAttribute("v")]
public static FlipMode Y;
    [EnumStringAttribute("both")]
public static FlipMode XY;
}
public enum ImageResizer.GrayscaleMode : Enum {
    public int value__;
    [EnumStringAttribute("false")]
public static GrayscaleMode None;
    [EnumStringAttribute("true")]
public static GrayscaleMode Y;
    public static GrayscaleMode NTSC;
    public static GrayscaleMode RY;
    public static GrayscaleMode BT709;
    public static GrayscaleMode Flat;
}
public class ImageResizer.ImageBuilder : AbstractImageProcessor {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxConcurrentJobs>k__BackingField;
    private SemaphoreSlim semaphore;
    protected IEncoderProvider _encoderProvider;
    protected ISettingsModifier _settingsModifier;
    private IVirtualImageProvider _virtualFileProvider;
    private String[] _supportedFileExtensions;
    private String[] _supportedQuerystringKeys;
    public Nullable`1<int> MaxConcurrentJobs { get; }
    public IEncoderProvider EncoderProvider { get; }
    public ISettingsModifier SettingsModifier { get; }
    public IVirtualImageProvider VirtualFileProvider { get; }
    public static ImageBuilder Current { get; }
    public ImageBuilder(IEnumerable`1<BuilderExtension> extensions, IEncoderProvider encoderProvider, IVirtualImageProvider virtualFileProvider, ISettingsModifier settingsModifier);
    public ImageBuilder(IEnumerable`1<BuilderExtension> extensions, IEncoderProvider encoderProvider, IVirtualImageProvider virtualFileProvider, ISettingsModifier settingsModifier, Nullable`1<int> maxConcurrentJobs);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxConcurrentJobs();
    public IEncoderProvider get_EncoderProvider();
    public ISettingsModifier get_SettingsModifier();
    public IVirtualImageProvider get_VirtualFileProvider();
    public static ImageBuilder get_Current();
    public virtual ImageBuilder Create(IEnumerable`1<BuilderExtension> extensions, IEncoderProvider writer, IVirtualImageProvider virtualFileProvider, ISettingsModifier settingsModifier);
    public virtual ImageBuilder Copy();
    [ObsoleteAttribute("This method returns an unmanaged, shoot-yourself-in-the-foot Bitmap instance. Use Build(ImageJob) or LoadImageInfo(source, new string[]{"source.width","source.height"})")]
public virtual Bitmap LoadImage(object source, ResizeSettings settings);
    public virtual IDictionary`2<string, object> LoadImageInfo(object source, IEnumerable`1<string> requestedInfo);
    [ObsoleteAttribute("This method returns an unmanaged, shoot-yourself-in-the-foot Bitmap instance. Use Build(ImageJob) or LoadImageInfo(source, new string[]{"source.width","source.height"})")]
public virtual Bitmap LoadImage(object source, ResizeSettings settings, bool restoreStreamPos);
    public virtual Bitmap DecodeStream(Stream s, ResizeSettings settings, string optionalPath);
    public Stream GetStreamFromSource(object source, ResizeSettings settings, Boolean& disposeStream, String& path, Boolean& restoreStreamPosition);
    [ObsoleteAttribute("Use ImageJob with dest=typeof(Bitmap) instead - but only as a last resort. This method returns an unmanaged, non-garbage collected object that can kill your server. Use Build(source, dest, instructions) instead of handling the Bitmap instance yourself.")]
public virtual Bitmap Build(object source, ResizeSettings settings);
    [ObsoleteAttribute("Use ImageJob with dest=typeof(Bitmap) instead - but only as a last resort. This method returns an unmanaged, non-garbage collected object that can kill your server. Use Build(source, dest) instead of handling the Bitmap instance yourself.")]
public virtual Bitmap Build(object source, ResizeSettings settings, bool disposeSource);
    public virtual void Build(object source, object dest, ResizeSettings settings);
    public virtual ImageJob Build(object source, object dest, Instructions instructions);
    public virtual void Build(object source, object dest, ResizeSettings settings, bool disposeSource);
    [ObsoleteAttribute("Use .Build(new ImageJob(source, dest, settings, disposeSource, addFileExtension)).FinalPath  instead")]
public virtual string Build(object source, object dest, ResizeSettings settings, bool disposeSource, bool addFileExtension);
    [AsyncStateMachineAttribute("ImageResizer.ImageBuilder/<BuildAsync>d__31")]
internal Task`1<ImageJob> BuildAsync(ImageJob job, int maxQueuingMilliseconds, CancellationToken cancel);
    public virtual ImageJob Build(ImageJob job);
    internal ImageJob BuildInQueue(ImageJob job, bool useSemaphore, int maxQueuingMilliseconds, CancellationToken cancel);
    internal ImageJob BuildInternal(ImageJob job);
    protected virtual RequestedAction BuildJob(ImageJob job);
    protected virtual RequestedAction BuildJobBitmapToStream(ImageJob job, Bitmap source, Stream dest);
    protected Bitmap BuildJobBitmapToBitmap(ImageJob job, Bitmap source, bool transparencySupported);
    public virtual void Process(ImageState s);
    protected virtual RequestedAction Layout(ImageState s);
    protected virtual RequestedAction Render(ImageState s);
    protected virtual RequestedAction PrepareSourceBitmap(ImageState s);
    protected virtual RequestedAction PostDecodeStream(Bitmap& b, ResizeSettings settings);
    protected virtual RequestedAction LayoutPadding(ImageState s);
    protected virtual RequestedAction LayoutMargin(ImageState s);
    protected virtual RequestedAction LayoutBorder(ImageState s);
    protected virtual RequestedAction LayoutRound(ImageState s);
    protected virtual RequestedAction LayoutRotate(ImageState s);
    protected virtual RequestedAction LayoutNormalize(ImageState s);
    protected virtual RequestedAction EndLayout(ImageState s);
    protected virtual RequestedAction PrepareDestinationBitmap(ImageState s);
    protected virtual RequestedAction RenderBackground(ImageState s);
    protected virtual RequestedAction RenderPadding(ImageState s);
    protected virtual RequestedAction CreateImageAttribues(ImageState s);
    protected virtual RequestedAction RenderImage(ImageState s);
    protected virtual RequestedAction InternalGraphicsDrawImage(ImageState state, Bitmap dest, Bitmap source, PointF[] targetArea, RectangleF sourceArea, Single[][] colorMatrix);
    protected virtual RequestedAction RenderBorder(ImageState s);
    protected virtual RequestedAction FlushChanges(ImageState s);
    protected virtual RequestedAction ProcessFinalBitmap(ImageState s);
    public virtual PointF[] TranslatePoints(PointF[] sourcePoints, Size originalSize, ResizeSettings q);
    public virtual Size GetFinalSize(Size originalSize, ResizeSettings q);
    public virtual Size GetFinalSize(Size originalSize, Instructions q);
    protected virtual RequestedAction LayoutImage(ImageState s);
    protected virtual RequestedAction EndProcess(ImageState s);
    public virtual IEnumerable`1<string> GetSupportedFileExtensions();
    public virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
}
public class ImageResizer.ImageCorruptedException : ImageProcessingException {
    public ImageCorruptedException(string message, Exception innerException);
}
public class ImageResizer.ImageFileType : object {
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string Extension { get; public set; }
    public string MimeType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
public void set_MimeType(string value);
}
public class ImageResizer.ImageJob : object {
    [CompilerGeneratedAttribute]
private List`1<string> <RequestedInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <ResultInfo>k__BackingField;
    private object _source;
    private object _dest;
    private object _result;
    [CompilerGeneratedAttribute]
private long <TotalTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DecodeTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EncodeTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private IProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private Instructions <Instructions>k__BackingField;
    private bool _disposeSourceObject;
    private bool _resetSourceStream;
    private bool _disposeDestinationStream;
    private string _finalPath;
    private string _sourcePathData;
    private bool _addFileExtension;
    private bool _allowDestinationPathVariables;
    private bool _createParentDirectory;
    public List`1<string> RequestedInfo { get; public set; }
    public Dictionary`2<string, object> ResultInfo { get; public set; }
    public object Source { get; public set; }
    public object Dest { get; public set; }
    public object Result { get; public set; }
    public Nullable`1<int> SourceWidth { get; }
    public Nullable`1<int> SourceHeight { get; }
    public Nullable`1<int> FinalWidth { get; }
    public Nullable`1<int> FinalHeight { get; }
    public string ResultFileExtension { get; }
    public string ResultMimeType { get; }
    public long TotalTicks { get; public set; }
    public long DecodeTicks { get; public set; }
    public long EncodeTicks { get; public set; }
    [ObsoleteAttribute("Use Instructions instead.")]
public ResizeSettings Settings { get; public set; }
    public IProfiler Profiler { get; public set; }
    public Instructions Instructions { get; public set; }
    public string InstructionsAsString { get; public set; }
    public bool DisposeSourceObject { get; public set; }
    public bool ResetSourceStream { get; public set; }
    public bool DisposeDestinationStream { get; public set; }
    public string FinalPath { get; public set; }
    public string SourcePathData { get; public set; }
    public bool AddFileExtension { get; public set; }
    public bool AllowDestinationPathVariables { get; public set; }
    public bool CreateParentDirectory { get; public set; }
    public ImageJob(object source, object dest, Instructions instructions);
    public ImageJob(object source, object dest, Instructions instructions, bool disposeSource, bool addFileExtension);
    public ImageJob(Stream sourceStream, Stream destStream, Instructions instructions);
    public ImageJob(string sourcePath, string destPath, Instructions instructions);
    public ImageJob(object source, IEnumerable`1<string> requestedImageInfo);
    [ObsoleteAttribute("Use Instructions instead of ResizeSettings")]
public ImageJob(string sourcePath, string destPath, ResizeSettings settings);
    [ObsoleteAttribute("Use Instructions instead of ResizeSettings")]
public ImageJob(Stream sourceStream, Stream destStream, ResizeSettings settings);
    [ObsoleteAttribute("Use Instructions instead of ResizeSettings")]
public ImageJob(object source, object dest, ResizeSettings settings);
    [ObsoleteAttribute("Use Instructions instead of ResizeSettings")]
public ImageJob(object source, object dest, ResizeSettings settings, bool disposeSource, bool addFileExtension);
    public ImageJob Build();
    [CompilerGeneratedAttribute]
public List`1<string> get_RequestedInfo();
    [CompilerGeneratedAttribute]
public void set_RequestedInfo(List`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_ResultInfo();
    [CompilerGeneratedAttribute]
public void set_ResultInfo(Dictionary`2<string, object> value);
    public object get_Source();
    public void set_Source(object value);
    public object get_Dest();
    public void set_Dest(object value);
    public object get_Result();
    public void set_Result(object value);
    public Nullable`1<int> get_SourceWidth();
    public Nullable`1<int> get_SourceHeight();
    public Nullable`1<int> get_FinalWidth();
    public Nullable`1<int> get_FinalHeight();
    public string get_ResultFileExtension();
    public string get_ResultMimeType();
    [CompilerGeneratedAttribute]
public long get_TotalTicks();
    [CompilerGeneratedAttribute]
public void set_TotalTicks(long value);
    [CompilerGeneratedAttribute]
public long get_DecodeTicks();
    [CompilerGeneratedAttribute]
public void set_DecodeTicks(long value);
    [CompilerGeneratedAttribute]
public long get_EncodeTicks();
    [CompilerGeneratedAttribute]
public void set_EncodeTicks(long value);
    public ResizeSettings get_Settings();
    public void set_Settings(ResizeSettings value);
    [CompilerGeneratedAttribute]
public IProfiler get_Profiler();
    [CompilerGeneratedAttribute]
public void set_Profiler(IProfiler value);
    [CompilerGeneratedAttribute]
public Instructions get_Instructions();
    [CompilerGeneratedAttribute]
public void set_Instructions(Instructions value);
    public string get_InstructionsAsString();
    public void set_InstructionsAsString(string value);
    public bool get_DisposeSourceObject();
    public void set_DisposeSourceObject(bool value);
    public bool get_ResetSourceStream();
    public void set_ResetSourceStream(bool value);
    public bool get_DisposeDestinationStream();
    public void set_DisposeDestinationStream(bool value);
    public string get_FinalPath();
    public void set_FinalPath(string value);
    public string get_SourcePathData();
    public void set_SourcePathData(string value);
    public bool get_AddFileExtension();
    public void set_AddFileExtension(bool value);
    public bool get_AllowDestinationPathVariables();
    public void set_AllowDestinationPathVariables(bool value);
    public bool get_CreateParentDirectory();
    public void set_CreateParentDirectory(bool value);
    public ImageJob CreateDir();
    public string ResolveTemplatedPath(string path, VariableResolverCallback resolver);
}
public class ImageResizer.ImageMissingException : ImageProcessingException {
    public ImageMissingException(string message);
    public ImageMissingException(string message, string safeMessage);
    public ImageMissingException(string message, string safeMessage, Exception innerException);
}
public class ImageResizer.ImageProcessingException : HttpException {
    [CompilerGeneratedAttribute]
private string <PublicSafeMessage>k__BackingField;
    protected string PublicSafeMessage { get; protected set; }
    public ImageProcessingException(string message);
    public ImageProcessingException(int httpCode, string message);
    public ImageProcessingException(int httpCode, string message, string safeMessage);
    public ImageProcessingException(int httpCode, string message, string safeMessage, Exception innerException);
    [CompilerGeneratedAttribute]
protected string get_PublicSafeMessage();
    [CompilerGeneratedAttribute]
protected void set_PublicSafeMessage(string value);
}
public class ImageResizer.Instructions : QuerystringBase`1<Instructions> {
    public Nullable`1<int> Width { get; public set; }
    public Nullable`1<int> Height { get; public set; }
    public Nullable`1<FitMode> Mode { get; public set; }
    public Nullable`1<AnchorLocation> Anchor { get; public set; }
    public Nullable`1<FlipMode> SourceFlip { get; public set; }
    public Nullable`1<FlipMode> FinalFlip { get; public set; }
    public Nullable`1<ScaleMode> Scale { get; public set; }
    public Nullable`1<ServerCacheMode> Cache { get; public set; }
    public Nullable`1<ProcessWhen> Process { get; public set; }
    [ObsoleteAttribute("This command is not supported with Imageflow - animated gifs are supported ")]
public Nullable`1<int> Frame { get; public set; }
    [ObsoleteAttribute("TIFF support is not provided by most backends")]
public Nullable`1<int> Page { get; public set; }
    public Nullable`1<int> JpegQuality { get; public set; }
    public Nullable`1<JpegSubsamplingMode> JpegSubsampling { get; public set; }
    [ObsoleteAttribute("Ignored by all modern backends as they manage this automatically")]
public Nullable`1<byte> PaletteSize { get; public set; }
    public Nullable`1<double> Zoom { get; public set; }
    public Nullable`1<double> CropXUnits { get; public set; }
    public Nullable`1<double> CropYUnits { get; public set; }
    public Double[] CropRectangle { get; public set; }
    public Nullable`1<bool> AutoRotate { get; public set; }
    public Nullable`1<double> SourceRotate { get; public set; }
    public Nullable`1<double> Rotate { get; public set; }
    public string Format { get; public set; }
    public Nullable`1<OutputFormat> OutputFormat { get; public set; }
    public Nullable`1<bool> IgnoreICC { get; public set; }
    public string FallbackImage { get; public set; }
    public string BackgroundColor { get; public set; }
    [ObsoleteAttribute("Use CSS to add padding, margins, borders to image; these are no longer supported due to little usage")]
public string PaddingColor { get; public set; }
    [ObsoleteAttribute("Use CSS to add margins and borders to image; these are no longer supported due to little usage")]
public string BorderColor { get; public set; }
    public string Preset { get; public set; }
    public string Watermark { get; public set; }
    public Nullable`1<bool> Invert { get; public set; }
    public Nullable`1<bool> Sepia { get; public set; }
    public Nullable`1<GrayscaleMode> Grayscale { get; public set; }
    public Nullable`1<double> Alpha { get; public set; }
    public Nullable`1<double> Brightness { get; public set; }
    public Nullable`1<double> Contrast { get; public set; }
    public Nullable`1<double> Saturation { get; public set; }
    public Nullable`1<byte> TrimThreshold { get; public set; }
    public Nullable`1<double> TrimPadding { get; public set; }
    [ObsoleteAttribute("AdvancedFilters is no longer supported")]
public Nullable`1<double> Blur { get; public set; }
    [ObsoleteAttribute("AdvancedFilters is no longer supported; use f.sharpen instead of a.sharpen for a performant alternative")]
public Nullable`1<double> Sharpen { get; public set; }
    [ObsoleteAttribute("AdvancedFilters is no longer supported")]
public Nullable`1<double> RemoveNoise { get; public set; }
    [ObsoleteAttribute("Ignored by all backends; dithering is always enabled with the Imageflow backend and not implemented in GDI")]
public string Dither { get; public set; }
    [ObsoleteAttribute("Ignored")]
public string Encoder { get; public set; }
    [ObsoleteAttribute("Ignored")]
public string Decoder { get; public set; }
    public string Builder { get; public set; }
    public Double[] RoundCorners { get; public set; }
    [ObsoleteAttribute("Use CSS to add margins and borders to image; these are no longer supported due to little usage")]
public BoxEdges Padding { get; public set; }
    [ObsoleteAttribute("Use CSS to add margins and borders to image; these are no longer supported due to little usage")]
public BoxEdges Margin { get; public set; }
    [ObsoleteAttribute("Use CSS to add margins and borders to image; these are no longer supported due to little usage")]
public BoxEdges Border { get; public set; }
    public Instructions(NameValueCollection col);
    public Instructions(string queryString);
    public virtual string ToString();
    public string ToQueryString();
    public Nullable`1<int> get_Width();
    public void set_Width(Nullable`1<int> value);
    public Nullable`1<int> get_Height();
    public void set_Height(Nullable`1<int> value);
    public Nullable`1<FitMode> get_Mode();
    public void set_Mode(Nullable`1<FitMode> value);
    public Nullable`1<AnchorLocation> get_Anchor();
    public void set_Anchor(Nullable`1<AnchorLocation> value);
    public Nullable`1<FlipMode> get_SourceFlip();
    public void set_SourceFlip(Nullable`1<FlipMode> value);
    public Nullable`1<FlipMode> get_FinalFlip();
    public void set_FinalFlip(Nullable`1<FlipMode> value);
    public Nullable`1<ScaleMode> get_Scale();
    public void set_Scale(Nullable`1<ScaleMode> value);
    public Nullable`1<ServerCacheMode> get_Cache();
    public void set_Cache(Nullable`1<ServerCacheMode> value);
    public Nullable`1<ProcessWhen> get_Process();
    public void set_Process(Nullable`1<ProcessWhen> value);
    public Nullable`1<int> get_Frame();
    public void set_Frame(Nullable`1<int> value);
    public Nullable`1<int> get_Page();
    public void set_Page(Nullable`1<int> value);
    public Nullable`1<int> get_JpegQuality();
    public void set_JpegQuality(Nullable`1<int> value);
    public Nullable`1<JpegSubsamplingMode> get_JpegSubsampling();
    public void set_JpegSubsampling(Nullable`1<JpegSubsamplingMode> value);
    public Nullable`1<byte> get_PaletteSize();
    public void set_PaletteSize(Nullable`1<byte> value);
    public Nullable`1<double> get_Zoom();
    public void set_Zoom(Nullable`1<double> value);
    public Nullable`1<double> get_CropXUnits();
    public void set_CropXUnits(Nullable`1<double> value);
    public Nullable`1<double> get_CropYUnits();
    public void set_CropYUnits(Nullable`1<double> value);
    public Double[] get_CropRectangle();
    public void set_CropRectangle(Double[] value);
    public Nullable`1<bool> get_AutoRotate();
    public void set_AutoRotate(Nullable`1<bool> value);
    public Nullable`1<double> get_SourceRotate();
    public void set_SourceRotate(Nullable`1<double> value);
    public Nullable`1<double> get_Rotate();
    public void set_Rotate(Nullable`1<double> value);
    public string get_Format();
    public void set_Format(string value);
    public Nullable`1<OutputFormat> get_OutputFormat();
    public void set_OutputFormat(Nullable`1<OutputFormat> value);
    public Nullable`1<bool> get_IgnoreICC();
    public void set_IgnoreICC(Nullable`1<bool> value);
    public string get_FallbackImage();
    public void set_FallbackImage(string value);
    public string get_BackgroundColor();
    public void set_BackgroundColor(string value);
    public string get_PaddingColor();
    public void set_PaddingColor(string value);
    public string get_BorderColor();
    public void set_BorderColor(string value);
    public string get_Preset();
    public void set_Preset(string value);
    public string get_Watermark();
    public void set_Watermark(string value);
    public Nullable`1<bool> get_Invert();
    public void set_Invert(Nullable`1<bool> value);
    public Nullable`1<bool> get_Sepia();
    public void set_Sepia(Nullable`1<bool> value);
    public Nullable`1<GrayscaleMode> get_Grayscale();
    public void set_Grayscale(Nullable`1<GrayscaleMode> value);
    public Nullable`1<double> get_Alpha();
    public void set_Alpha(Nullable`1<double> value);
    public Nullable`1<double> get_Brightness();
    public void set_Brightness(Nullable`1<double> value);
    public Nullable`1<double> get_Contrast();
    public void set_Contrast(Nullable`1<double> value);
    public Nullable`1<double> get_Saturation();
    public void set_Saturation(Nullable`1<double> value);
    public Nullable`1<byte> get_TrimThreshold();
    public void set_TrimThreshold(Nullable`1<byte> value);
    public Nullable`1<double> get_TrimPadding();
    public void set_TrimPadding(Nullable`1<double> value);
    public Nullable`1<double> get_Blur();
    public void set_Blur(Nullable`1<double> value);
    public Nullable`1<double> get_Sharpen();
    public void set_Sharpen(Nullable`1<double> value);
    public Nullable`1<double> get_RemoveNoise();
    public void set_RemoveNoise(Nullable`1<double> value);
    public string get_Dither();
    public void set_Dither(string value);
    public string get_Encoder();
    public void set_Encoder(string value);
    public string get_Decoder();
    public void set_Decoder(string value);
    public string get_Builder();
    public void set_Builder(string value);
    public Double[] get_RoundCorners();
    public void set_RoundCorners(Double[] value);
    public BoxEdges get_Padding();
    public void set_Padding(BoxEdges value);
    public BoxEdges get_Margin();
    public void set_Margin(BoxEdges value);
    public BoxEdges get_Border();
    public void set_Border(BoxEdges value);
}
public class ImageResizer.InterceptModule : AsyncInterceptModule {
}
public class ImageResizer.Issues.ConfigChecker : object {
    private Config c;
    public ConfigChecker(Config c);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
}
public class ImageResizer.Issues.IssueGatherer : object {
    private Config c;
    public IssueGatherer(Config c);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
}
public enum ImageResizer.JpegSubsamplingMode : Enum {
    public int value__;
    public static JpegSubsamplingMode Default;
    [EnumStringAttribute("411", "True")]
public static JpegSubsamplingMode Y4Cb1Cr1;
    [EnumStringAttribute("420", "True")]
public static JpegSubsamplingMode Y4Cb2Cr0;
    [EnumStringAttribute("422", "True")]
public static JpegSubsamplingMode Y4Cb2Cr2;
    [EnumStringAttribute("444", "True")]
public static JpegSubsamplingMode HighestQuality;
    [EnumStringAttribute("444", "True")]
public static JpegSubsamplingMode Y4Cb4Cr4;
}
public class ImageResizer.LicenseException : ImageProcessingException {
    public LicenseException(string message);
    public LicenseException(string message, Exception innerException);
}
internal class ImageResizer.NewModuleHelpers : object {
    internal static string GetContentTypeFromBytes(Byte[] data);
    [AsyncStateMachineAttribute("ImageResizer.NewModuleHelpers/<ProxyToStream>d__1")]
internal static Task ProxyToStream(Stream sourceStream, HttpResponse response);
    private void SetCachingHeaders(HttpContext context, string etag);
    [AsyncStateMachineAttribute("ImageResizer.NewModuleHelpers/<ProcessWithStreamCache>d__3")]
public Task ProcessWithStreamCache(ILogger logger, IStreamCache streamCache, HttpContext context, IAsyncResponsePlan plan);
}
public enum ImageResizer.OutputFormat : Enum {
    public int value__;
    [EnumStringAttribute("jpg", "True")]
[EnumStringAttribute("jpe")]
[EnumStringAttribute("jif")]
[EnumStringAttribute("jfif")]
[EnumStringAttribute("jfi")]
[EnumStringAttribute("exif")]
public static OutputFormat Jpeg;
    public static OutputFormat Png;
    public static OutputFormat Gif;
}
[ObsoleteAttribute("This plugin does nothing; autorotate is now built-in.")]
public class ImageResizer.Plugins.Basic.AutoRotate : BuilderExtension {
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.ClientCache : object {
    private Config c;
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_PreHandleImage(IHttpModule sender, HttpContext context, IResponseArgs e);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.DefaultEncoder : object {
    private ImageFormat _outputFormat;
    private int quality;
    private static object _syncExts;
    private static IDictionary`2<string, ImageFormat> _imageExtensions;
    public ImageFormat OutputFormat { get; public set; }
    public int Quality { get; public set; }
    public bool SupportsTransparency { get; }
    public string MimeType { get; }
    public string Extension { get; }
    private static IDictionary`2<string, ImageFormat> imageExtensions { get; }
    public DefaultEncoder(ImageFormat outputFormat);
    public DefaultEncoder(ImageFormat outputFormat, int jpegQuality);
    public DefaultEncoder(ResizeSettings settings, object original);
    private static DefaultEncoder();
    public virtual IEncoder CreateIfSuitable(ResizeSettings settings, object original);
    public ImageFormat get_OutputFormat();
    public void set_OutputFormat(ImageFormat value);
    public bool IsValidOutputFormat(ImageFormat f);
    public int get_Quality();
    public void set_Quality(int value);
    public sealed virtual void Write(Image image, Stream s);
    public sealed virtual bool get_SupportsTransparency();
    public sealed virtual string get_MimeType();
    public sealed virtual string get_Extension();
    public static ImageFormat GetRequestedFormat(string format, ImageFormat defaultValue);
    public static ImageFormat GetOriginalFormat(object original);
    public static ImageFormat GetImageFormatFromPhysicalPath(string path);
    public static string GetExtensionFromImageFormat(ImageFormat format);
    private static IDictionary`2<string, ImageFormat> get_imageExtensions();
    public static ImageFormat GetImageFormatFromExtension(string ext);
    private static void addImageExtension(string extension, ImageFormat matchingFormat);
    public static void AddImageExtension(string extension, ImageFormat matchingFormat);
    public static string GetContentTypeFromImageFormat(ImageFormat format);
    public static ImageCodecInfo GetImageCodeInfo(string mimeType);
    public static void SaveJpeg(Image b, Stream target, int quality);
    public static void SavePng(Image img, Stream target);
    public static void SaveBmp(Image img, Stream target);
    public static void SaveGif(Image img, Stream target);
    public virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    public sealed virtual IEnumerable`1<FileSignature> GetSignatures();
}
public class ImageResizer.Plugins.Basic.DefaultSettings : object {
    private Config c;
    [CompilerGeneratedAttribute]
private ScaleMode <ExplicitSizeScaleMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ScaleMode <MaxSizeScaleMode>k__BackingField;
    public ScaleMode ExplicitSizeScaleMode { get; public set; }
    public ScaleMode MaxSizeScaleMode { get; public set; }
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    private void Pipeline_PostRewrite(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    [CompilerGeneratedAttribute]
public ScaleMode get_ExplicitSizeScaleMode();
    [CompilerGeneratedAttribute]
public void set_ExplicitSizeScaleMode(ScaleMode value);
    [CompilerGeneratedAttribute]
public ScaleMode get_MaxSizeScaleMode();
    [CompilerGeneratedAttribute]
public void set_MaxSizeScaleMode(ScaleMode value);
    public void LoadSettings();
    public sealed virtual ResizeSettings Modify(ResizeSettings settings);
}
public class ImageResizer.Plugins.Basic.DiagnoseRequest : BuilderExtension {
    private Config c;
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    protected virtual RequestedAction PostPrepareSourceBitmap(ImageState s);
    private string Normalize(PixelFormat fmt);
    private string Normalize(ImageFormat fmt);
    protected virtual RequestedAction PreFlushChanges(ImageState s);
    private void Pipeline_PreHandleImage(IHttpModule sender, HttpContext context, IResponseArgs e);
    private AlternateResponseException GetResponseException(string text);
    private static void InjectRequestMod(ResponseArgs ra);
    public sealed virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
}
public class ImageResizer.Plugins.Basic.Diagnostic : EndpointPlugin {
    public static string DisabledNotice(Config c);
    protected virtual string GenerateOutput(HttpContext context, Config c);
    public static bool AllowResponse(HttpContext context, Config c);
}
public enum ImageResizer.Plugins.Basic.DiagnosticMode : Enum {
    public int value__;
    public static DiagnosticMode None;
    public static DiagnosticMode Localhost;
    public static DiagnosticMode AllHosts;
}
public class ImageResizer.Plugins.Basic.EndpointPlugin : object {
    private Config c;
    [CompilerGeneratedAttribute]
private String[] <Endpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointMatching <EndpointMatchMethod>k__BackingField;
    protected String[] Endpoints { get; protected set; }
    protected EndpointMatching EndpointMatchMethod { get; protected set; }
    public sealed virtual IPlugin Install(Config c);
    [CompilerGeneratedAttribute]
protected String[] get_Endpoints();
    [CompilerGeneratedAttribute]
protected void set_Endpoints(String[] value);
    [CompilerGeneratedAttribute]
protected EndpointMatching get_EndpointMatchMethod();
    [CompilerGeneratedAttribute]
protected void set_EndpointMatchMethod(EndpointMatching value);
    protected virtual string GenerateOutput(HttpContext context, Config c);
    protected virtual bool HandlesRequest(HttpContext context, Config c);
    protected virtual void ProcessRequest(HttpContext context);
    private void Pipeline_PostAuthorizeRequestStart(IHttpModule sender, HttpContext context);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.FolderResizeSyntax : object {
    protected Regex resizeFolder;
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_RewriteDefaults(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public sealed virtual bool Uninstall(Config c);
    protected string parseResizeFolderSyntax(string path, NameValueCollection q);
}
public interface ImageResizer.Plugins.Basic.IDiagnosticsFooterProvider {
    public abstract virtual string ProvideDiagnosticsFooter();
}
public interface ImageResizer.Plugins.Basic.IDiagnosticsHeaderProvider {
    public abstract virtual string ProvideDiagnosticsHeader();
}
public interface ImageResizer.Plugins.Basic.IDiagnosticsProvider {
    public abstract virtual string ProvideDiagnostics();
}
public interface ImageResizer.Plugins.Basic.IDiagnosticsProviderFactory {
    public abstract virtual object GetDiagnosticsProvider();
}
public interface ImageResizer.Plugins.Basic.ILicenseDiagnosticsProvider {
    public abstract virtual string ProvidePublicText();
}
public class ImageResizer.Plugins.Basic.Image404 : object {
    private static MatcherCollection DefaultWhitelist;
    private static MatcherCollection DefaultBlacklist;
    private Config c;
    private FilterMode filterMode;
    private MatcherCollection except;
    private static Image404();
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_ImageMissing(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    private static NameAndValue CreateRemovalMatcher(FilterMode filterMode, MatcherCollection except);
    protected string resolve404Path(string path);
    public sealed virtual bool Uninstall(Config c);
    public sealed virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
}
public class ImageResizer.Plugins.Basic.ImageHandlerSyntax : object {
    private Config c;
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_PostAuthorizeRequestStart(IHttpModule sender, HttpContext context);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.ImageInfoAPI : object {
    private Config c;
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_PreHandleImage(IHttpModule sender, HttpContext context, IResponseArgs e);
    private void SimpleJson(Stream target, NameValueCollection data, string callbackName);
    public sealed virtual bool Uninstall(Config c);
    public sealed virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
}
public class ImageResizer.Plugins.Basic.LicenseDisplay : EndpointPlugin {
    protected virtual string GenerateOutput(HttpContext context, Config c);
    public static string GetPageText(Config c);
}
public class ImageResizer.Plugins.Basic.MvcRoutingShimPlugin : object {
    private StopRoutingRoute route;
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.NoCache : object {
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    public sealed virtual bool CanProcess(HttpContext current, IAsyncResponsePlan e);
    public sealed virtual Task ProcessAsync(HttpContext context, IAsyncResponsePlan e);
}
public class ImageResizer.Plugins.Basic.NoCacheAsyncHandler : AsyncHttpHandlerBase {
    private IAsyncResponsePlan e;
    public NoCacheAsyncHandler(IAsyncResponsePlan e);
    public virtual Task ProcessRequestAsync(HttpContext context);
}
public class ImageResizer.Plugins.Basic.Presets : object {
    private Config c;
    private Dictionary`2<string, ResizeSettings> defaults;
    private Dictionary`2<string, ResizeSettings> settings;
    private bool _onlyAllowPresets;
    public bool OnlyAllowPresets { get; public set; }
    public Presets(Dictionary`2<string, ResizeSettings> defaults, Dictionary`2<string, ResizeSettings> settings, bool onlyAllowPresets);
    public sealed virtual IPlugin Install(Config c);
    private void Pipeline_RewriteDefaults(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    private void Pipeline_Rewrite(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    private void Pipeline_PostRewrite(IHttpModule sender, HttpContext context, IUrlEventArgs e);
    public static NameValueCollection FilterQuerystring(NameValueCollection s, bool keepHmacAndUrl64);
    private void ApplyPreset(IUrlEventArgs e, Dictionary`2<string, ResizeSettings> dict);
    public sealed virtual ResizeSettings Modify(ResizeSettings s);
    public sealed virtual bool Uninstall(Config c);
    public bool get_OnlyAllowPresets();
    public void set_OnlyAllowPresets(bool value);
    protected void ParseXml(Node n, Config conf);
    public sealed virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
}
public class ImageResizer.Plugins.Basic.SizeLimiting : BuilderExtension {
    private SizeLimits limits;
    public SizeLimits Limits { get; public set; }
    public SizeLimits get_Limits();
    public void set_Limits(SizeLimits value);
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    protected virtual RequestedAction PostLayoutImage(ImageState s);
    protected virtual RequestedAction PrepareDestinationBitmap(ImageState s);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
}
public class ImageResizer.Plugins.Basic.SizeLimits : IssueSink {
    protected Size totalSize;
    protected TotalSizeBehavior totalBehavior;
    protected Size imageSize;
    public Size TotalSize { get; public set; }
    public TotalSizeBehavior TotalBehavior { get; public set; }
    public bool HasImageSize { get; }
    public Size ImageSize { get; public set; }
    public SizeLimits(Config c);
    public void ValidateTotalSize(Size total);
    public bool FitsInsideTotalSize(Size s);
    public Size get_TotalSize();
    public void set_TotalSize(Size value);
    public TotalSizeBehavior get_TotalBehavior();
    public void set_TotalBehavior(TotalSizeBehavior value);
    public bool get_HasImageSize();
    public Size get_ImageSize();
    public void set_ImageSize(Size value);
}
public class ImageResizer.Plugins.Basic.StaticLicenseProvider : object {
    private List`1<string> licenses;
    public StaticLicenseProvider(String[] licenses);
    public static StaticLicenseProvider One(string license);
    public void AddLicense(string license);
    public static string CleanupLicenseString(string license);
    public sealed virtual ICollection`1<string> GetLicenses();
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
}
public class ImageResizer.Plugins.Basic.VirtualFolder : VirtualPathProvider {
    private bool _failedToRegisterVpp;
    [CompilerGeneratedAttribute]
private bool <RegisterAsVpp>k__BackingField;
    private string virtualPath;
    private string physicalPath;
    private bool registeredVpp;
    private bool noIOPermission;
    public bool FailedToRegisterVpp { get; }
    public bool RegisterAsVpp { get; public set; }
    public string VirtualPath { get; public set; }
    public string PhysicalPath { get; public set; }
    public bool NoIOPermission { get; }
    public VirtualFolder(string virtualPath, string physicalPath);
    public VirtualFolder(string virtualPath, string physicalPath, bool registerAsVpp);
    public VirtualFolder(NameValueCollection args);
    public bool get_FailedToRegisterVpp();
    [CompilerGeneratedAttribute]
public bool get_RegisterAsVpp();
    [CompilerGeneratedAttribute]
public void set_RegisterAsVpp(bool value);
    public string get_VirtualPath();
    public void set_VirtualPath(string value);
    public string get_PhysicalPath();
    public void set_PhysicalPath(string value);
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    public bool get_NoIOPermission();
    protected string normalizeVirtualPath(string path);
    protected string resolvePhysicalPath(string path);
    protected string collapsePath(string path);
    protected string collapseOneLevel(string path);
    public string VirtualToPhysical(string virtualPath);
    public string LocalMapPath(string virtualPath);
    public bool IsVirtualPath(string virtualPath);
    private bool isOnlyVirtualPath(string virtualPath);
    protected internal Stream getStream(string virtualPath);
    public DateTime GetDateModifiedUtc(string virtualPath);
    public sealed virtual bool FileExists(string virtualPath, NameValueCollection queryString);
    public sealed virtual IVirtualFile GetFile(string virtualPath, NameValueCollection queryString);
    public virtual bool FileExists(string virtualPath);
    public virtual VirtualFile GetFile(string virtualPath);
    public virtual CacheDependency GetCacheDependency(string virtualPath, IEnumerable virtualPathDependencies, DateTime utcStart);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
    public sealed virtual Task`1<bool> FileExistsAsync(string virtualPath, NameValueCollection queryString);
    public sealed virtual Task`1<IVirtualFileAsync> GetFileAsync(string virtualPath, NameValueCollection queryString);
}
public class ImageResizer.Plugins.Basic.WebConfigLicenseReader : object {
    private IList`1<string> licenses;
    public sealed virtual ICollection`1<string> GetLicenses();
    public sealed virtual IPlugin Install(Config c);
    public sealed virtual bool Uninstall(Config c);
    public sealed virtual Node RedactFrom(Node resizer);
    public static string TryRedact(string license);
}
public class ImageResizer.Plugins.CommonStaticStorage : object {
    private static ConcurrentDictionary`2<string, object> dict;
    private static CommonStaticStorage();
    public static object GetOrAdd(string key, Func`2<string, object> factory);
    public static bool TryGetValue(string key, Object& value);
    public static object AddOrUpdate(string key, Func`2<string, object> factory);
}
public class ImageResizer.Plugins.FileSignature : object {
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryFileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public Byte[] Signature { get; protected set; }
    public string PrimaryFileExtension { get; protected set; }
    public string MimeType { get; protected set; }
    public FileSignature(Byte[] signature, string ext, string mime);
    [CompilerGeneratedAttribute]
public Byte[] get_Signature();
    [CompilerGeneratedAttribute]
protected void set_Signature(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_PrimaryFileExtension();
    [CompilerGeneratedAttribute]
protected void set_PrimaryFileExtension(string value);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
protected void set_MimeType(string value);
}
internal enum ImageResizer.Plugins.FolderOptions : Enum {
    public int value__;
    public static FolderOptions Default;
    public static FolderOptions CreateIfMissing;
}
public interface ImageResizer.Plugins.IAsyncResponsePlan {
    public string EstimatedContentType { get; public set; }
    public string EstimatedFileExtension { get; public set; }
    public string RequestCachingKey { get; }
    public NameValueCollection RewrittenQuerystring { get; }
    public ReadStreamAsyncDelegate OpenSourceStreamAsync { get; public set; }
    public WriteResultAsyncDelegate CreateAndWriteResultAsync { get; public set; }
    public abstract virtual string get_EstimatedContentType();
    public abstract virtual void set_EstimatedContentType(string value);
    public abstract virtual string get_EstimatedFileExtension();
    public abstract virtual void set_EstimatedFileExtension(string value);
    public abstract virtual string get_RequestCachingKey();
    public abstract virtual NameValueCollection get_RewrittenQuerystring();
    public abstract virtual ReadStreamAsyncDelegate get_OpenSourceStreamAsync();
    public abstract virtual void set_OpenSourceStreamAsync(ReadStreamAsyncDelegate value);
    public abstract virtual WriteResultAsyncDelegate get_CreateAndWriteResultAsync();
    public abstract virtual void set_CreateAndWriteResultAsync(WriteResultAsyncDelegate value);
}
public interface ImageResizer.Plugins.IAsyncTyrantCache {
    public abstract virtual bool CanProcess(HttpContext current, IAsyncResponsePlan e);
    public abstract virtual Task ProcessAsync(HttpContext current, IAsyncResponsePlan e);
}
public interface ImageResizer.Plugins.ICurrentConfigProvider {
    public abstract virtual Config GetCurrentConfig();
}
[ObsoleteAttribute("Cannot be used with Imageflow backend; relies on GDI Image object")]
public interface ImageResizer.Plugins.IEncoder {
    public bool SupportsTransparency { get; }
    public string MimeType { get; }
    public string Extension { get; }
    public abstract virtual IEncoder CreateIfSuitable(ResizeSettings settings, object original);
    public abstract virtual void Write(Image i, Stream s);
    public abstract virtual bool get_SupportsTransparency();
    public abstract virtual string get_MimeType();
    public abstract virtual string get_Extension();
}
[ObsoleteAttribute("Cannot be used with Imageflow backend; relies on GDI Image object")]
public interface ImageResizer.Plugins.IEncoderProvider {
    public abstract virtual IEncoder GetEncoder(ResizeSettings settings, object original);
}
public interface ImageResizer.Plugins.IFileExtensionPlugin {
    public abstract virtual IEnumerable`1<string> GetSupportedFileExtensions();
}
public interface ImageResizer.Plugins.IFileSignatureProvider {
    public abstract virtual IEnumerable`1<FileSignature> GetSignatures();
}
public interface ImageResizer.Plugins.ILicensedPlugin {
    public IEnumerable`1<string> LicenseFeatureCodes { get; }
    public abstract virtual IEnumerable`1<string> get_LicenseFeatureCodes();
}
public interface ImageResizer.Plugins.ILicenseProvider {
    public abstract virtual ICollection`1<string> GetLicenses();
}
public interface ImageResizer.Plugins.IMultiInstancePlugin {
}
public interface ImageResizer.Plugins.IPersistentStringCache {
    public abstract virtual StringCachePutResult TryPut(string key, string value);
    public abstract virtual string Get(string key);
    public abstract virtual Nullable`1<DateTime> GetWriteTimeUtc(string key);
}
public interface ImageResizer.Plugins.IPlugin {
    public abstract virtual IPlugin Install(Config c);
    public abstract virtual bool Uninstall(Config c);
}
public interface ImageResizer.Plugins.IPluginInfo {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetInfoPairs();
}
public interface ImageResizer.Plugins.IPluginModifiesRequestCacheKey {
    public abstract virtual string ModifyRequestCacheKey(string currentKey, string virtualPath, NameValueCollection queryString);
}
public interface ImageResizer.Plugins.IPluginRequiresShutdown {
    public abstract virtual Task StopAsync(CancellationToken cancellationToken);
}
public interface ImageResizer.Plugins.IPluginSupportsOutputFileTypes {
    public abstract virtual ImageFileType GuessOutputFileTypeIfSupported(Instructions commands, string virtualPath);
}
public interface ImageResizer.Plugins.IProfiler {
    public bool Active { get; }
    public abstract virtual bool get_Active();
    public abstract virtual void Start(string segmentName, bool allowRecursion);
    public abstract virtual bool IsRunning(string segmentName);
    public abstract virtual void Stop(string segmentName, bool assertRunning, bool stopChildren);
    public abstract virtual void LogStart(long ticks, string segmentName, bool allowRecursion);
    public abstract virtual void LogStop(long ticks, string segmentName, bool assertRunning, bool stopChildren);
}
public interface ImageResizer.Plugins.IQuerystringPlugin {
    public abstract virtual IEnumerable`1<string> GetSupportedQuerystringKeys();
}
public interface ImageResizer.Plugins.IRedactDiagnostics {
    public abstract virtual Node RedactFrom(Node resizer);
}
public interface ImageResizer.Plugins.ISettingsModifier {
    public abstract virtual ResizeSettings Modify(ResizeSettings settings);
}
public interface ImageResizer.Plugins.IVirtualBitmapFile {
    public abstract virtual Bitmap GetBitmap();
}
public interface ImageResizer.Plugins.IVirtualFile {
    public string VirtualPath { get; }
    public abstract virtual string get_VirtualPath();
    public abstract virtual Stream Open();
}
public interface ImageResizer.Plugins.IVirtualFileAsync {
    public abstract virtual Task`1<Stream> OpenAsync();
}
public interface ImageResizer.Plugins.IVirtualFileCache {
    public abstract virtual IVirtualFile GetFileIfCached(string virtualPath, NameValueCollection queryString, IVirtualFile original);
}
public interface ImageResizer.Plugins.IVirtualFileCacheAsync {
    public abstract virtual Task`1<IVirtualFileAsync> GetFileIfCachedAsync(string virtualPath, NameValueCollection queryString, IVirtualFileAsync original);
}
public interface ImageResizer.Plugins.IVirtualFileSourceCacheKey {
    public abstract virtual string GetCacheKey(bool includeModifiedDate);
}
public interface ImageResizer.Plugins.IVirtualFileWithModifiedDate {
    public DateTime ModifiedDateUTC { get; }
    public abstract virtual DateTime get_ModifiedDateUTC();
}
public interface ImageResizer.Plugins.IVirtualFileWithModifiedDateAsync {
    public abstract virtual Task`1<DateTime> GetModifiedDateUTCAsync();
}
public interface ImageResizer.Plugins.IVirtualImageProvider {
    public abstract virtual bool FileExists(string virtualPath, NameValueCollection queryString);
    public abstract virtual IVirtualFile GetFile(string virtualPath, NameValueCollection queryString);
}
public interface ImageResizer.Plugins.IVirtualImageProviderAsync {
    public abstract virtual Task`1<bool> FileExistsAsync(string virtualPath, NameValueCollection queryString);
    public abstract virtual Task`1<IVirtualFileAsync> GetFileAsync(string virtualPath, NameValueCollection queryString);
}
public interface ImageResizer.Plugins.IVirtualImageProviderVpp {
    public abstract virtual bool VppExposeFile(string virtualPath);
}
public interface ImageResizer.Plugins.IVirtualImageProviderVppCaching {
    public abstract virtual CacheDependency VppGetCacheDependency(string virtualPath, IEnumerable virtualPathDependencies, DateTime utcStart);
    public abstract virtual string VppGetFileHash(string virtualPath, IEnumerable virtualPathDependencies);
}
public interface ImageResizer.Plugins.Licensing.ILicenseBlob {
    public Byte[] Signature { get; }
    public Byte[] Data { get; }
    public string Original { get; }
    public ILicenseDetails Fields { get; }
    public abstract virtual Byte[] get_Signature();
    public abstract virtual Byte[] get_Data();
    public abstract virtual string get_Original();
    public abstract virtual ILicenseDetails get_Fields();
}
public interface ImageResizer.Plugins.Licensing.ILicenseChain {
    public string Id { get; }
    public bool Shared { get; }
    public bool IsRemote { get; }
    public abstract virtual string get_Id();
    public abstract virtual bool get_Shared();
    public abstract virtual bool get_IsRemote();
    public abstract virtual IEnumerable`1<ILicenseBlob> Licenses();
    public abstract virtual ILicenseBlob FetchedLicense();
    public abstract virtual ILicenseBlob CachedLicense();
    public abstract virtual string ToPublicString();
    public abstract virtual string LastFetchUrl();
}
public interface ImageResizer.Plugins.Licensing.ILicenseClock {
    public long TicksPerSecond { get; }
    public abstract virtual DateTimeOffset GetUtcNow();
    public abstract virtual long GetTimestampTicks();
    public abstract virtual long get_TicksPerSecond();
    public abstract virtual Nullable`1<DateTimeOffset> GetBuildDate();
    public abstract virtual Nullable`1<DateTimeOffset> GetAssemblyWriteDate();
}
public interface ImageResizer.Plugins.Licensing.ILicenseDetails {
    public string Id { get; }
    public IReadOnlyDictionary`2<string, string> Pairs { get; }
    public Nullable`1<DateTimeOffset> Issued { get; }
    public Nullable`1<DateTimeOffset> Expires { get; }
    public Nullable`1<DateTimeOffset> SubscriptionExpirationDate { get; }
    public abstract virtual string get_Id();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Pairs();
    public abstract virtual string Get(string key);
    public abstract virtual Nullable`1<DateTimeOffset> get_Issued();
    public abstract virtual Nullable`1<DateTimeOffset> get_Expires();
    public abstract virtual Nullable`1<DateTimeOffset> get_SubscriptionExpirationDate();
}
public interface ImageResizer.Plugins.Licensing.ILicenseManager {
    public IPersistentStringCache Cache { get; public set; }
    public Nullable`1<DateTimeOffset> FirstHeartbeat { get; }
    public abstract virtual IPersistentStringCache get_Cache();
    public abstract virtual void set_Cache(IPersistentStringCache value);
    public abstract virtual void Heartbeat();
    public abstract virtual Nullable`1<DateTimeOffset> get_FirstHeartbeat();
    public abstract virtual void MonitorLicenses(Config c);
    public abstract virtual void MonitorHeartbeat(Config c);
    public abstract virtual ILicenseChain GetOrAdd(string license, LicenseAccess access);
    public abstract virtual IReadOnlyCollection`1<ILicenseChain> GetSharedLicenses();
    public abstract virtual IReadOnlyCollection`1<ILicenseChain> GetAllLicenses();
    public abstract virtual LicenseManagerEvent AddLicenseChangeHandler(TTarget target, Action`2<TTarget, ILicenseManager> action);
    public abstract virtual void RemoveLicenseChangeHandler(LicenseManagerEvent handler);
}
public class ImageResizer.Plugins.Licensing.LicenseManagerEvent : MulticastDelegate {
    public LicenseManagerEvent(object object, IntPtr method);
    public virtual void Invoke(ILicenseManager mgr);
    public virtual IAsyncResult BeginInvoke(ILicenseManager mgr, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ImageResizer.Plugins.MultiFolderStorage : object {
    private IIssueReceiver sink;
    private string issueSource;
    private String[] candidateFolders;
    private FolderOptions options;
    private string dataKind;
    private ConcurrentBag`1<string> badReadLocations;
    private ConcurrentBag`1<string> badWriteLocations;
    private ReaderWriterLockSlim filesystem;
    public MultiFolderStorage(string issueSource, string dataKind, IIssueReceiver sink, String[] candidateFolders, FolderOptions options);
    private void AddBadReadLocation(string path, IIssue i);
    private void AddBadWriteLocation(string path, IIssue i);
    public bool TryDelete(string filename);
    public bool TryDiskWrite(string filename, string value);
    public string TryDiskRead(string filename);
    public Nullable`1<DateTime> TryGetLastWriteTimeUtc(string filename);
}
public class ImageResizer.Plugins.PersistentGlobalStringCache : object {
    private static WriteThroughCache processCache;
    private WriteThroughCache cache;
    private static PersistentGlobalStringCache();
    public sealed virtual string Get(string key);
    public sealed virtual StringCachePutResult TryPut(string key, string value);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
    public sealed virtual Nullable`1<DateTime> GetWriteTimeUtc(string key);
}
public class ImageResizer.Plugins.ReadStreamAsyncDelegate : MulticastDelegate {
    public ReadStreamAsyncDelegate(object object, IntPtr method);
    public virtual Task`1<Stream> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Task`1<Stream> EndInvoke(IAsyncResult result);
}
public enum ImageResizer.Plugins.StringCachePutResult : Enum {
    public int value__;
    public static StringCachePutResult Duplicate;
    public static StringCachePutResult WriteComplete;
    public static StringCachePutResult WriteFailed;
}
public class ImageResizer.Plugins.VirtualFileShim : VirtualFile {
    private IVirtualFile f;
    public VirtualFileShim(IVirtualFile f);
    public virtual Stream Open();
}
public class ImageResizer.Plugins.VirtualFileWrapper : object {
    private VirtualFile _underlyingFile;
    public VirtualFile UnderlyingFile { get; public set; }
    public string VirtualPath { get; }
    public VirtualFileWrapper(VirtualFile fileToWrap);
    public VirtualFile get_UnderlyingFile();
    public void set_UnderlyingFile(VirtualFile value);
    public sealed virtual string get_VirtualPath();
    public sealed virtual Stream Open();
}
public class ImageResizer.Plugins.VirtualPathProviderShim : VirtualPathProvider {
    private Config c;
    public VirtualPathProviderShim(Config c);
    protected virtual void Initialize();
    protected string normalizeVirtualPath(string path);
    protected IVirtualImageProviderVpp GetVIP(string virtualPath);
    public virtual bool FileExists(string virtualPath);
    public virtual VirtualFile GetFile(string virtualPath);
    public virtual string GetFileHash(string virtualPath, IEnumerable virtualPathDependencies);
    public virtual CacheDependency GetCacheDependency(string virtualPath, IEnumerable virtualPathDependencies, DateTime utcStart);
}
public class ImageResizer.Plugins.WriteResultAsyncDelegate : MulticastDelegate {
    public WriteResultAsyncDelegate(object object, IntPtr method);
    public virtual Task Invoke(Stream outputStream, IAsyncResponsePlan plan);
    public virtual IAsyncResult BeginInvoke(Stream outputStream, IAsyncResponsePlan plan, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class ImageResizer.Plugins.WriteThroughCache : object {
    private string prefix;
    private string sinkSource;
    private string dataKind;
    private IIssueReceiver sink;
    private MultiFolderStorage store;
    private ConcurrentDictionary`2<string, string> cache;
    internal WriteThroughCache(string keyPrefix);
    private string hashToBase16(string data);
    private string FilenameKeyFor(string key);
    internal StringCachePutResult TryPut(string key, string value);
    internal string TryGet(string key);
    internal Nullable`1<DateTime> GetWriteTimeUtc(string key);
    public sealed virtual IEnumerable`1<IIssue> GetIssues();
}
public enum ImageResizer.ProcessWhen : Enum {
    public int value__;
    public static ProcessWhen No;
    public static ProcessWhen Always;
    public static ProcessWhen Default;
}
internal class ImageResizer.RequestJobInfo : object {
    [CompilerGeneratedAttribute]
private string <FinalVirtualPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <FinalQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasParams>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandString>k__BackingField;
    public string FinalVirtualPath { get; private set; }
    private Dictionary`2<string, string> FinalQuery { get; private set; }
    public bool HasParams { get; }
    public string CommandString { get; }
    [CompilerGeneratedAttribute]
public string get_FinalVirtualPath();
    [CompilerGeneratedAttribute]
private void set_FinalVirtualPath(string value);
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> get_FinalQuery();
    [CompilerGeneratedAttribute]
private void set_FinalQuery(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_HasParams();
    [CompilerGeneratedAttribute]
public string get_CommandString();
}
public class ImageResizer.ResizerSection : ConfigurationSection {
    protected object nSync;
    [CLSCompliantAttribute("False")]
protected Node modreq(System.Runtime.CompilerServices.IsVolatile) n;
    [CLSCompliantAttribute("False")]
protected XmlDocument modreq(System.Runtime.CompilerServices.IsVolatile) xmlDoc;
    protected IssueSink sink;
    public IssueSink IssueSink { get; }
    public ResizerSection(Node root);
    public ResizerSection(string xml);
    public Node getCopyOfNode(string selector);
    public Node getCopyOfRootNode();
    public void replaceRootNode(Node n);
    public string getAttr(string selector, string defaultValue);
    public void setAttr(string selector, string value);
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    public IssueSink get_IssueSink();
}
public class ImageResizer.ResizeSettings : QuerystringBase`1<ResizeSettings> {
    public int Width { get; public set; }
    public int Height { get; public set; }
    public int MaxWidth { get; public set; }
    public int Quality { get; public set; }
    public int MaxHeight { get; public set; }
    public FitMode Mode { get; public set; }
    public double Rotate { get; public set; }
    public ContentAlignment Anchor { get; public set; }
    public RotateFlipType Flip { get; public set; }
    public RotateFlipType SourceFlip { get; public set; }
    public ScaleMode Scale { get; public set; }
    [ObsoleteAttribute("Replaced by Mode=Stretch")]
public StretchMode Stretch { get; public set; }
    public ServerCacheMode Cache { get; public set; }
    public ProcessWhen Process { get; public set; }
    [ObsoleteAttribute("Replaced by Mode=Crop. Use CropTopLeft and CropTopRight instead for setting a custom crop mode.")]
public CropMode CropMode { get; public set; }
    protected Double[] CropValues { get; protected set; }
    public PointF CropTopLeft { get; public set; }
    public PointF CropBottomRight { get; public set; }
    public Color BackgroundColor { get; public set; }
    public Color PaddingColor { get; public set; }
    public BoxPadding Padding { get; public set; }
    public BoxPadding Margin { get; public set; }
    public Color BorderColor { get; public set; }
    public BoxPadding Border { get; public set; }
    public string Format { get; public set; }
    public double CropXUnits { get; public set; }
    public double CropYUnits { get; public set; }
    public ResizeSettings(NameValueCollection col);
    public ResizeSettings(string queryString);
    public ResizeSettings(NameValueCollection col, NameValueCollection defaultSettings);
    public ResizeSettings(string queryString, NameValueCollection defaultSettings);
    public ResizeSettings(int width, int height, FitMode mode, string imageFormat);
    protected int get(string name, int defaultValue);
    protected void set(string name, int value);
    protected double get(string name, double defaultValue);
    protected void set(string name, double value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_MaxWidth();
    public void set_MaxWidth(int value);
    public int get_Quality();
    public void set_Quality(int value);
    public int get_MaxHeight();
    public void set_MaxHeight(int value);
    public FitMode get_Mode();
    public void set_Mode(FitMode value);
    public bool WasOneSpecified(String[] keys);
    public double get_Rotate();
    public void set_Rotate(double value);
    public ContentAlignment get_Anchor();
    public void set_Anchor(ContentAlignment value);
    public RotateFlipType get_Flip();
    public void set_Flip(RotateFlipType value);
    public RotateFlipType get_SourceFlip();
    public void set_SourceFlip(RotateFlipType value);
    public ScaleMode get_Scale();
    public void set_Scale(ScaleMode value);
    public StretchMode get_Stretch();
    public void set_Stretch(StretchMode value);
    public ServerCacheMode get_Cache();
    public void set_Cache(ServerCacheMode value);
    public ProcessWhen get_Process();
    public void set_Process(ProcessWhen value);
    public CropMode get_CropMode();
    public void set_CropMode(CropMode value);
    protected Double[] get_CropValues();
    protected void set_CropValues(Double[] value);
    public PointF get_CropTopLeft();
    public void set_CropTopLeft(PointF value);
    public PointF get_CropBottomRight();
    public void set_CropBottomRight(PointF value);
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public Color get_PaddingColor();
    public void set_PaddingColor(Color value);
    public BoxPadding get_Padding();
    public void set_Padding(BoxPadding value);
    public BoxPadding get_Margin();
    public void set_Margin(BoxPadding value);
    public Color get_BorderColor();
    public void set_BorderColor(Color value);
    public BoxPadding get_Border();
    public void set_Border(BoxPadding value);
    public string get_Format();
    public void set_Format(string value);
    public double get_CropXUnits();
    public void set_CropXUnits(double value);
    public double get_CropYUnits();
    public void set_CropYUnits(double value);
    public RectangleF getCustomCropSourceRect(SizeF imageSize);
    public void SetDefaultImageFormat(string format);
    public virtual string ToString();
    public string ToStringEncoded();
    public void Normalize();
    public ResizeSettings Normalize(string primary, string secondary);
}
public class ImageResizer.Resizing.AbstractImageProcessor : object {
    [CLSCompliantAttribute("False")]
protected IEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) exts;
    public AbstractImageProcessor(IEnumerable`1<BuilderExtension> extensions);
    protected virtual void PreLoadImage(Object& source, String& path, Boolean& disposeSource, ResizeSettings& settings);
    protected virtual Stream GetStream(object source, ResizeSettings settings, Boolean& disposeStream, String& path, Boolean& restoreStreamPosition);
    public virtual Bitmap DecodeStreamFailed(Stream s, ResizeSettings settings, string optionalPath);
    public virtual Bitmap DecodeStream(Stream s, ResizeSettings settings, string optionalPath);
    protected virtual RequestedAction PostDecodeStream(Bitmap& img, ResizeSettings settings);
    protected virtual void PreAcquireStream(Object& dest, ResizeSettings settings);
    protected virtual RequestedAction BuildJob(ImageJob job);
    protected virtual RequestedAction BeforeEncode(ImageJob job);
    protected virtual RequestedAction EndBuildJob(ImageJob job);
    protected virtual RequestedAction InternalGraphicsDrawImage(ImageState state, Bitmap dest, Bitmap source, PointF[] targetArea, RectangleF sourceArea, Single[][] colorMatrix);
    protected virtual RequestedAction BuildJobBitmapToStream(ImageJob job, Bitmap source, Stream dest);
    protected virtual RequestedAction OnProcess(ImageState s);
    protected virtual RequestedAction PrepareSourceBitmap(ImageState s);
    protected virtual RequestedAction PostPrepareSourceBitmap(ImageState s);
    protected virtual RequestedAction Layout(ImageState s);
    protected virtual RequestedAction FlipExistingPoints(ImageState s);
    protected virtual RequestedAction LayoutImage(ImageState s);
    protected virtual RequestedAction PostLayoutImage(ImageState s);
    protected virtual RequestedAction LayoutPadding(ImageState s);
    protected virtual RequestedAction PostLayoutPadding(ImageState s);
    protected virtual RequestedAction LayoutBorder(ImageState s);
    protected virtual RequestedAction PostLayoutBorder(ImageState s);
    protected virtual RequestedAction LayoutEffects(ImageState s);
    protected virtual RequestedAction PostLayoutEffects(ImageState s);
    protected virtual RequestedAction LayoutMargin(ImageState s);
    protected virtual RequestedAction PostLayoutMargin(ImageState s);
    protected virtual RequestedAction LayoutRotate(ImageState s);
    protected virtual RequestedAction PostLayoutRotate(ImageState s);
    protected virtual RequestedAction LayoutNormalize(ImageState s);
    protected virtual RequestedAction PostLayoutNormalize(ImageState s);
    protected virtual RequestedAction LayoutRound(ImageState s);
    protected virtual RequestedAction PostLayoutRound(ImageState s);
    protected virtual RequestedAction EndLayout(ImageState s);
    protected virtual RequestedAction PrepareDestinationBitmap(ImageState s);
    protected virtual RequestedAction Render(ImageState s);
    protected virtual RequestedAction RenderBackground(ImageState s);
    protected virtual RequestedAction PostRenderBackground(ImageState s);
    protected virtual RequestedAction RenderEffects(ImageState s);
    protected virtual RequestedAction PostRenderEffects(ImageState s);
    protected virtual RequestedAction RenderPadding(ImageState s);
    protected virtual RequestedAction PostRenderPadding(ImageState s);
    protected virtual RequestedAction CreateImageAttribues(ImageState s);
    protected virtual RequestedAction PostCreateImageAttributes(ImageState s);
    protected virtual RequestedAction PreRenderImage(ImageState s);
    protected virtual RequestedAction RenderImage(ImageState s);
    protected virtual RequestedAction PostRenderImage(ImageState s);
    protected virtual RequestedAction RenderBorder(ImageState s);
    protected virtual RequestedAction PostRenderBorder(ImageState s);
    protected virtual RequestedAction PreRenderOverlays(ImageState s);
    protected virtual RequestedAction RenderOverlays(ImageState s);
    protected virtual RequestedAction PreFlushChanges(ImageState s);
    protected virtual RequestedAction FlushChanges(ImageState s);
    protected virtual RequestedAction PostFlushChanges(ImageState s);
    protected virtual RequestedAction ProcessFinalBitmap(ImageState s);
    protected virtual RequestedAction EndProcess(ImageState s);
}
public class ImageResizer.Resizing.BitmapTag : object {
    private string _path;
    private Stream _source;
    public string Path { get; public set; }
    public Stream Source { get; public set; }
    public BitmapTag(object tag);
    public BitmapTag(string path, Stream source);
    public string get_Path();
    public void set_Path(string value);
    public Stream get_Source();
    public void set_Source(Stream value);
}
public class ImageResizer.Resizing.BoxPadding : object {
    protected double top;
    protected double left;
    protected double bottom;
    protected double right;
    public double Top { get; }
    public double Left { get; }
    public double Right { get; }
    public double Bottom { get; }
    public double All { get; }
    protected double all { get; protected set; }
    public static BoxPadding Empty { get; }
    public bool IsEmpty { get; }
    public BoxPadding(double all);
    public BoxPadding(double left, double top, double right, double bottom);
    public BoxPadding(BoxPadding original);
    public static BoxPadding Parse(string text, BoxPadding fallbackValue);
    public double get_Top();
    public double get_Left();
    public double get_Right();
    public double get_Bottom();
    public BoxPadding SetAll(double all);
    public BoxPadding SetTop(double top);
    public BoxPadding SetLeft(double left);
    public BoxPadding SetRight(double right);
    public BoxPadding SetBottom(double bottom);
    public double get_All();
    protected double get_all();
    protected void set_all(double value);
    public static BoxPadding get_Empty();
    public bool get_IsEmpty();
    public Single[] GetEdgeOffsets();
    public virtual string ToString();
}
[ObsoleteAttribute("ImageResizer is migrating away from GDI. Suggest new features be added to Imageflow instead.")]
public class ImageResizer.Resizing.BuilderExtension : AbstractImageProcessor {
}
public class ImageResizer.Resizing.ImageLayoutEngine : object {
    private Size originalSize;
    private RectangleF copyRect;
    private SizeF targetSize;
    private SizeF areaSize;
    public RectangleF CopyFrom { get; }
    public SizeF CopyToSize { get; }
    public SizeF CanvasSize { get; }
    public ImageLayoutEngine(Size originalSize, RectangleF cropWindow);
    public void ApplyInstructions(Instructions i);
    private RectangleF determineManualCropWindow(ResizeSettings settings);
    private FitMode determineFitMode(ResizeSettings settings);
    public void ApplySettings(ResizeSettings settings);
    public RectangleF get_CopyFrom();
    public SizeF get_CopyToSize();
    public SizeF get_CanvasSize();
}
public class ImageResizer.Resizing.ImageState : object {
    public ResizeSettings settings;
    public Size originalSize;
    public bool supportsTransparency;
    public LayoutBuilder layout;
    public Size destSize;
    public Size finalSize;
    public RectangleF copyRect;
    public Bitmap sourceBitmap;
    public Bitmap preRenderBitmap;
    [CompilerGeneratedAttribute]
private ImageJob <Job>k__BackingField;
    public Bitmap destBitmap;
    public Graphics destGraphics;
    public Single[][] colorMatrix;
    private Dictionary`2<string, object> data;
    public SizeF copySize { get; }
    public ImageJob Job { get; public set; }
    public Dictionary`2<string, object> Data { get; }
    public ImageState(ResizeSettings settings, Size originalSize, bool transparencySupported);
    public NameValueCollection settingsAsCollection();
    public SizeF get_copySize();
    public void ConvertIfCMYK();
    public void EnsurePreRenderBitmap();
    public void ApplyCropping();
    public void ValidateCropping();
    public void EnsureRGBA();
    private ImageColorFormat GetColorFormat(Bitmap bitmap);
    [CompilerGeneratedAttribute]
public ImageJob get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(ImageJob value);
    public Dictionary`2<string, object> get_Data();
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class ImageResizer.Resizing.LayoutBuilder : object {
    protected Dictionary`2<string, PointSet> ring;
    protected List`1<PointSet> ringList;
    public PointF[] Item { get; public set; }
    public PointSet LastRing { get; }
    public PointF[] get_Item(string key);
    public void set_Item(string key, PointF[] value);
    public PointSet get_LastRing();
    public PointSet AddRing(string name, PointF[] points);
    public bool ContainsRing(string name);
    public PointSet AddRing(string name, BoxPadding padding);
    public PointSet AddInvisiblePolygon(string name, PointF[] points);
    public PointSet AddIgnoredPoints(string name, PointF[] points);
    public RectangleF GetBoundingBox();
    public Nullable`1<RectangleF> GetRingAsRectF(string name);
    public void Rotate(double degrees, PointF origin);
    public void Normalize(PointF origin);
    public void Round();
    public void Scale(double factor, PointF origin);
    public void Shift(RectangleF from, RectangleF to);
}
public enum ImageResizer.Resizing.RequestedAction : Enum {
    public int value__;
    public static RequestedAction None;
    public static RequestedAction Cancel;
}
public enum ImageResizer.ScaleMode : Enum {
    public int value__;
    [EnumStringAttribute("down")]
public static ScaleMode DownscaleOnly;
    [EnumStringAttribute("up")]
public static ScaleMode UpscaleOnly;
    public static ScaleMode Both;
    [EnumStringAttribute("canvas")]
public static ScaleMode UpscaleCanvas;
}
public enum ImageResizer.ServerCacheMode : Enum {
    public int value__;
    public static ServerCacheMode No;
    public static ServerCacheMode Always;
    public static ServerCacheMode Default;
}
public class ImageResizer.StreamResponseHandler : object {
}
[ObsoleteAttribute("Use Mode=FitMode.Stretch instead. Will be removed in V3.5 or V4.")]
public enum ImageResizer.StretchMode : Enum {
    public int value__;
    public static StretchMode Proportionally;
    public static StretchMode Fill;
}
public static class ImageResizer.Util.AsyncUtils : object {
    private static TaskFactory _myTaskFactory;
    private static AsyncUtils();
    public static TResult RunSync(Func`1<Task`1<TResult>> func);
    public static void RunSync(Func`1<Task> func);
}
[ObsoleteAttribute("Use Imazen.Common.Licesning.BuildDateAttribute instead, this will not be recognized")]
[AttributeUsageAttribute("1")]
public class ImageResizer.Util.BuildDateAttribute : Attribute {
    private string str;
    public string Value { get; }
    public Nullable`1<DateTimeOffset> ValueDate { get; }
    public BuildDateAttribute(string txt);
    public string get_Value();
    public Nullable`1<DateTimeOffset> get_ValueDate();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("No longer used.")]
public class ImageResizer.Util.BuildTypeAttribute : Attribute {
    private string type;
    public string Value { get; }
    public BuildTypeAttribute(string txt);
    public string get_Value();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Use Imazen.Common.Licesning.CommitAttribute instead, this will not be recognized")]
public class ImageResizer.Util.CommitAttribute : Attribute {
    private string guid;
    public string Value { get; }
    public CommitAttribute(string txt);
    public string get_Value();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Use Imazen.Common.Licesning.EditionAttribute instead, this will not be recognized")]
public class ImageResizer.Util.EditionAttribute : Attribute {
    private string type;
    public string Value { get; }
    public EditionAttribute(string txt);
    public string get_Value();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Native dependencies are no longer supported due to misuse and startup delays")]
public class ImageResizer.Util.NativeDependenciesAttribute : Attribute {
    private string type;
    public string Value { get; }
    public NativeDependenciesAttribute(string txt);
    public string get_Value();
    public virtual string ToString();
}
public class ImageResizer.Util.ParseUtils : object {
    public static NumberStyles FloatingPointStyle;
    public static Color ParseColor(string value, Color defaultValue);
    public static Nullable`1<Color> ParseColor(string value);
    public static string SerializeColor(Color value);
    public static T ParsePrimitive(string value, T defaultValue);
    public static Nullable`1<T> ParsePrimitive(string value);
    public static string SerializePrimitive(Nullable`1<T> val);
    public static T[] ParseList(string text, Nullable`1<T> fallbackValue, Int32[] allowedSizes);
}
public class ImageResizer.Util.PathUtils : object {
    private static Char[] QueryOrFragment;
    private static Char[] SpaceOrSlash;
    public static string AppVirtualPath { get; }
    public static string AppPhysicalPath { get; }
    private static PathUtils();
    public static string get_AppVirtualPath();
    public static string get_AppPhysicalPath();
    public static string SetExtension(string path, string newExtension);
    internal static string Base64Hash(string data);
    public static string RemoveFullExtension(string path);
    public static string RemoveExtension(string path);
    public static string AddExtension(string path, string newExtension);
    public static string GetFullExtension(string path);
    public static string GetExtension(string path);
    public static string ResolveAppRelative(string virtualPath);
    public static string ResolveAppRelativeAssumeAppRelative(string virtualPath);
    public static string AddQueryString(string virtualPath, string querystring);
    public static string RemoveQueryString(string path);
    public static string MergeOverwriteQueryString(string path, NameValueCollection newQuerystring);
    public static string MergeQueryString(string path, NameValueCollection newQuerystring);
    public static string BuildQueryString(NameValueCollection QueryString);
    public static string BuildQueryString(NameValueCollection QueryString, bool urlEncode);
    public static string BuildSemicolonQueryString(NameValueCollection QueryString, bool urlEncode);
    public static string BuildQueryString(NameValueCollection QueryString, bool urlEncode, bool skipNullValues, char firstSeparator, char laterSeparators, char equals);
    public static NameValueCollection ParseQueryStringFriendly(string path);
    public static NameValueCollection ParseQueryStringFriendlyAllowSemicolons(string path);
    public static NameValueCollection ParseQueryString(string path);
    public static NameValueCollection ParseQueryString(string path, bool allowSemicolons);
    public static NameValueCollection ParseQueryString(string path, bool allowSemicolons, String& beforeQuery, String& fragment);
    public static NameValueCollection ParseQueryOnly(string query, bool allowSemicolons, bool urlDecode);
    public static string ToBase64U(Byte[] data);
    public static Byte[] FromBase64UToBytes(string data);
    public static string ToBase64U(string data);
    public static string FromBase64UToString(string data);
    public static string MapPathIfAppRelative(string path);
    public static string GenerateImageUrl(string path, NameValueCollection query);
    public static string GuessVirtualPath(string path);
    public static string ResolveVariablesInPath(string pathWithVars, VariableResolverCallback resolver);
    public static string RemoveNonMatchingChars(string text, string chars);
    public static NameValueCollection FilterQueryString(ResizeSettings query, String[] keepKeys);
    public static bool HasIOPermission(String[] paths);
}
public class ImageResizer.Util.PolygonMath : object {
    public static PointF[] RoundPoints(PointF[] a);
    [CLSCompliantAttribute("False")]
public static PointF[0...,0...] RoundPoints(PointF[0...,0...] a);
    public static void ForEach(Array a, ForEachFunction func);
    public static PointF[] RotatePoly(PointF[] poly, double degrees);
    public static PointF[] RotatePoly(PointF[] poly, double degrees, PointF origin);
    public static PointF[] ScalePoints(PointF[] poly, double xfactor, double yfactor, PointF origin);
    public static PointF ScalePoint(PointF point, double xfactor, double yfactor, PointF origin);
    public static PointF[] ToPoly(RectangleF rect);
    public static PointF[] NormalizePoly(PointF[] poly);
    public static PointF RotateVector(PointF v, double radians);
    public static PointF RotateVector(PointF v, double radians, PointF origin);
    public static PointF ChangeMagnitude(PointF v, float length);
    public static RectangleF GetBoundingBox(PointF[] points);
    public static RectangleF GetBoundingBox(Double[] flattenedPoints);
    public static PointF[] MovePoly(PointF[] points, PointF offset);
    public static bool ArraysEqual(PointF[] a1, PointF[] a2);
    public static PointF[] getParallelogram(PointF[] quad);
    public static SizeF getParallelogramSize(PointF[] p);
    public static PointF[] GetSubArray(PointF[0...,0...] array, int index);
    public static Brush GenerateRadialBrush(Color inner, Color outer, PointF pt, float width);
    public static SizeF ScaleInside(SizeF inner, SizeF bounding);
    public static SizeF ScaleOutside(SizeF innerBounds, SizeF outer);
    public static SizeF DownScaleInside(SizeF inner, SizeF bounding);
    public static bool FitsInside(SizeF inner, SizeF outer);
    public static PointF[0...,0...] GetCorners(PointF[] poly, float width);
    public static PointF[0...,0...] GetCorners(PointF[] poly, Single[] widths);
    public static PointF[0...,0...] GetSides(PointF[] poly, float width);
    public static PointF[] InflatePoly(PointF[] poly, float offset);
    public static PointF[] InflatePoly(PointF[] poly, Single[] offsets);
    public static PointF[] CenterInside(PointF[] inner, PointF[] outer);
    public static RectangleF CenterInside(SizeF size, RectangleF bounds);
    public static Rectangle ToRectangle(RectangleF r);
    public static Rectangle ToRectangleShrinkRound(RectangleF r);
    public static Size RoundPoints(SizeF sizeF);
    public static RectangleF AlignWith(RectangleF obj, RectangleF container, ContentAlignment align);
    public static RectangleF MoveInBounds(RectangleF obj, RectangleF container);
    public static RectangleF AlignWithin(RectangleF obj, RectangleF container, PointF centerAt);
    public static PointF Midpoint(RectangleF obj);
    public static PointF[] AlignWith(PointF[] obj, PointF[] container, ContentAlignment align);
    public static PointF Average(PointF a, PointF b);
    public static bool IsUnrotated(PointF[] a);
    public static double GetShortestPair(PointF[] poly);
    public static double Dist(PointF a, PointF b);
    public static double NormalizeTo90Intervals(double d);
    public static RotateFlipType CombineFlipAndRotate(RotateFlipType flip, double angle);
    public static RotateFlipType CombineFlipAndRotate(FlipMode flip, double angle);
    public static RectangleF GetCroppingRectangle(Double[] cropValues, double xunits, double yunits, SizeF imageSize);
    public static RectangleF ClipRectangle(RectangleF box, RectangleF bounds);
    public static RectangleF ExpandTo(RectangleF box, SizeF copySize);
    public static RectangleF ScaleRect(RectangleF rect, double ExpandX, double ExpandY);
}
public class ImageResizer.Util.SeekableStreamWrapper : MemoryStream {
    private Stream inner;
    private bool disposeInner;
    private bool writable;
    public bool CanWrite { get; }
    private SeekableStreamWrapper(Stream inner, bool disposeInner);
    public static Stream FromStream(Stream sourceStream);
    public static Stream FromStream(Stream sourceStream, Boolean& disposeStream);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanWrite();
}
[ObsoleteAttribute("All methods of this class have been deprecated. Use ParseUtils or ImageResizer.ExtensionMethods instead.  Will be removed in V3.5 or V4.")]
public class ImageResizer.Util.Utils : object {
    public static NumberStyles floatingPointStyle;
    public static Color parseColor(string value, Color defaultValue);
    public static string writeColor(Color value);
    public static Double[] parseList(string text, double defaultValue);
    public static int getInt(NameValueCollection q, string name, int defaultValue);
    public static float getFloat(NameValueCollection q, string name, float defaultValue);
    public static double getDouble(NameValueCollection q, string name, double defaultValue);
    public static bool getBool(NameValueCollection q, string name, bool defaultValue);
    public static T parseEnum(string value, T defaultValue);
    [ObsoleteAttribute("Use ImageResizer.ExtensionMethods instead.")]
public static void copyStream(Stream source, Stream dest);
    public static RotateFlipType parseFlip(string sFlip);
    public static double parseRotate(string s);
    public static double normalizeTo90Intervals(double d);
    public static RotateFlipType combineFlipAndRotate(RotateFlipType flip, double angle);
    public static string writeFlip(RotateFlipType flip);
    public static StretchMode parseStretch(string value);
    public static string writeStretch(StretchMode value);
    public static KeyValuePair`2<CropUnits, double> parseCropUnits(string value);
    public static string writeCropUnits(KeyValuePair`2<CropUnits, double> value);
    public static ScaleMode parseScale(string value);
    public static string writeScale(ScaleMode value);
    public static KeyValuePair`2<CropMode, Double[]> parseCrop(string value);
    public static string writeCrop(CropMode mode, Double[] coords);
    public static BoxPadding parsePadding(string value);
    public static PointF parsePointF(string value, PointF defaultValue);
    public static string writePadding(BoxPadding p);
}
