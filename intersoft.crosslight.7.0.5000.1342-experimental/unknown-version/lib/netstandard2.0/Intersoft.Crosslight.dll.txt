[AttributeUsageAttribute("111")]
internal class aa : Attribute {
}
internal class aaa : object {
    private static zy a;
    private static zy b;
    private static zy c;
    private static zy d;
    public static aab[] e;
    public static SByte[][] f;
    public static aab[] g;
    public static SByte[][] h;
    private static aaa();
    public static zy Norm(sbyte a, aab b);
    public static aab Round(zz a, zz b, sbyte c);
    public static zz ApproximateDivisionByN(zy a, zy b, zy c, sbyte d, int e, int f);
    public static aan Tau(aan a);
    public static sbyte GetMu(aag a);
    public static zy[] GetLucas(sbyte a, int b, bool c);
    public static zy GetTw(sbyte a, int b);
    public static zy[] GetSi(aag a);
    public static aab PartModReduction(zy a, int b, sbyte c, zy[] d, sbyte e, sbyte f);
    public static aan MultiplyFromTnaf(aan a, SByte[] b);
    public static SByte[] TauAdicWNaf(sbyte a, aab b, sbyte c, zy d, zy e, aab[] f);
    public static aan[] GetPreComp(aan a, sbyte b);
}
internal class aab : object {
    public zy a;
    public zy b;
    public aab(zy a, zy b);
}
internal class aac : object {
    public static aak SumOfTwoMultiplies(aak a, zy b, aak c, zy d);
    private static aak ImplShamirsTrick(aak a, zy b, aak c, zy d);
}
internal abstract class aad : object {
    internal aah c;
    internal aah d;
    public int FieldSize { get; }
    public aak Infinity { get; }
    public aah A { get; }
    public aah B { get; }
    public abstract virtual int get_FieldSize();
    public abstract virtual aah FromBigInteger(zy a);
    public abstract virtual aak CreatePoint(zy a, zy b, bool c);
    public abstract virtual aak DecodePoint(Byte[] a);
    public abstract virtual aak get_Infinity();
    public aah get_A();
    public aah get_B();
    public virtual bool Equals(object a);
    protected bool Equals(aad a);
    public virtual int GetHashCode();
}
internal abstract class aae : aad {
    protected internal abstract virtual aak DecompressPoint(int a, zy b);
    public virtual aak DecodePoint(Byte[] a);
}
internal class aaf : aae {
    private zy e;
    private aam f;
    public zy Q { get; }
    public aak Infinity { get; }
    public int FieldSize { get; }
    public aaf(zy a, zy b, zy c);
    public zy get_Q();
    public virtual aak get_Infinity();
    public virtual int get_FieldSize();
    public virtual aah FromBigInteger(zy a);
    public virtual aak CreatePoint(zy a, zy b, bool c);
    protected internal virtual aak DecompressPoint(int a, zy b);
    public virtual bool Equals(object a);
    protected bool Equals(aaf a);
    public virtual int GetHashCode();
}
internal class aag : aae {
    private int g;
    private int i;
    private int j;
    private int k;
    private zy l;
    private zy m;
    private aan f;
    private sbyte n;
    private zy[] o;
    public aak Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public zy H { get; }
    public aag(int a, int b, zy c, zy d, zy e, zy f);
    public aag(int a, int b, int c, int d, zy e, zy f);
    public aag(int a, int b, int c, int d, zy e, zy f, zy g, zy h);
    public virtual aak get_Infinity();
    public virtual int get_FieldSize();
    public virtual aah FromBigInteger(zy a);
    public bool get_IsKoblitz();
    internal sbyte GetMu();
    internal zy[] GetSi();
    public virtual aak CreatePoint(zy a, zy b, bool c);
    protected internal virtual aak DecompressPoint(int a, zy b);
    private aah solveQuadradicEquation(aah a);
    public virtual bool Equals(object a);
    protected bool Equals(aag a);
    public virtual int GetHashCode();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public zy get_H();
}
internal abstract class aah : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public abstract virtual zy ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual aah Add(aah a);
    public abstract virtual aah Subtract(aah a);
    public abstract virtual aah Multiply(aah a);
    public abstract virtual aah Divide(aah a);
    public abstract virtual aah Negate();
    public abstract virtual aah Square();
    public abstract virtual aah Invert();
    public abstract virtual aah Sqrt();
    public virtual bool Equals(object a);
    protected bool Equals(aah a);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class aai : aah {
    private zy a;
    private zy b;
    public string FieldName { get; }
    public int FieldSize { get; }
    public aai(zy a, zy b);
    public virtual zy ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual aah Add(aah a);
    public virtual aah Subtract(aah a);
    public virtual aah Multiply(aah a);
    public virtual aah Divide(aah a);
    public virtual aah Negate();
    public virtual aah Square();
    public virtual aah Invert();
    public virtual aah Sqrt();
    private static zy[] fastLucasSequence(zy a, zy b, zy c, zy d);
    public virtual bool Equals(object a);
    protected bool Equals(aai a);
    public virtual int GetHashCode();
}
internal class aaj : aah {
    private int c;
    private int d;
    private int e;
    private int f;
    private int g;
    private aao b;
    private int h;
    public string FieldName { get; }
    public int FieldSize { get; }
    public aaj(int a, int b, int c, int d, zy e);
    private aaj(int a, int b, int c, int d, aao e);
    public virtual zy ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(aah a, aah b);
    public virtual aah Add(aah a);
    public virtual aah Subtract(aah a);
    public virtual aah Multiply(aah a);
    public virtual aah Divide(aah a);
    public virtual aah Negate();
    public virtual aah Square();
    public virtual aah Invert();
    public virtual aah Sqrt();
    public virtual bool Equals(object a);
    protected bool Equals(aaj a);
    public virtual int GetHashCode();
}
internal abstract class aak : object {
    internal aad a;
    internal aah b;
    internal aah c;
    internal bool d;
    internal aap e;
    internal aar f;
    public aad Curve { get; }
    public aah X { get; }
    public aah Y { get; }
    public bool IsInfinity { get; }
    public bool IsCompressed { get; }
    protected internal aak(aad a, aah b, aah c, bool d);
    public aad get_Curve();
    public aah get_X();
    public aah get_Y();
    public bool get_IsInfinity();
    public bool get_IsCompressed();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
    internal void SetPreCompInfo(aar a);
    public abstract virtual Byte[] GetEncoded();
    public abstract virtual aak Add(aak a);
    public abstract virtual aak Subtract(aak a);
    public abstract virtual aak Negate();
    public abstract virtual aak Twice();
    public abstract virtual aak Multiply(zy a);
    internal virtual void AssertECMultiplier();
}
internal abstract class aal : aak {
    protected internal bool YTilde { get; }
    protected internal aal(aad a, aah b, aah c, bool d);
    protected internal abstract virtual bool get_YTilde();
    public virtual Byte[] GetEncoded();
    public virtual aak Multiply(zy a);
}
internal class aam : aal {
    protected internal bool YTilde { get; }
    public aam(aad a, aah b, aah c);
    public aam(aad a, aah b, aah c, bool d);
    protected internal virtual bool get_YTilde();
    public virtual aak Add(aak a);
    public virtual aak Twice();
    public virtual aak Subtract(aak a);
    public virtual aak Negate();
    internal virtual void AssertECMultiplier();
}
internal class aan : aal {
    protected internal bool YTilde { get; }
    public aan(aad a, aah b, aah c);
    public aan(aad a, aah b, aah c, bool d);
    protected internal virtual bool get_YTilde();
    private static void CheckPoints(aak a, aak b);
    public virtual aak Add(aak a);
    internal aan AddSimple(aan a);
    public virtual aak Subtract(aak a);
    internal aan SubtractSimple(aan a);
    public virtual aak Twice();
    public virtual aak Negate();
    internal virtual void AssertECMultiplier();
}
internal class aao : object {
    private Int32[] a;
    public int BitLength { get; }
    public int Length { get; }
    public aao(int a);
    private aao(Int32[] a);
    public aao(zy a, int b);
    public int GetUsedLength();
    public int get_BitLength();
    private Int32[] resizedInts(int a);
    public zy ToBigInteger();
    public void ShiftLeft();
    public aao ShiftLeft(int a);
    public void AddShifted(aao a, int b);
    public int get_Length();
    public bool TestBit(int a);
    public void FlipBit(int a);
    public void SetBit(int a);
    public aao Multiply(aao a, int b);
    public void Reduce(int a, Int32[] b);
    public aao Square(int a);
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
    internal aao Copy();
    public virtual string ToString();
}
internal interface aap {
    public abstract virtual aak Multiply(aak a, zy b, aar c);
}
internal class aaq : object {
    public sealed virtual aak Multiply(aak a, zy b, aar c);
}
internal interface aar {
}
internal class aas : object {
    public sealed virtual aak Multiply(aak a, zy b, aar c);
}
internal class aat : object {
    public SByte[] WindowNaf(sbyte a, zy b);
    public sealed virtual aak Multiply(aak a, zy b, aar c);
}
internal class aau : object {
    private aak[] a;
    private aak b;
    internal aak[] GetPreComp();
    internal void SetPreComp(aak[] a);
    internal aak GetTwiceP();
    internal void SetTwiceP(aak a);
}
internal class aav : object {
    public sealed virtual aak Multiply(aak a, zy b, aar c);
    private aan MultiplyWTnaf(aan a, aab b, aar c, sbyte d, sbyte e);
    private static aan MultiplyFromWTnaf(aan a, SByte[] b, aar c);
}
internal class aaw : object {
    private aan[] a;
    internal aaw(aan[] a);
    internal aan[] GetPreComp();
}
internal interface aax {
    public abstract virtual void Close();
}
internal class aay : object {
    private Stream a;
    private qj b;
    public sealed virtual void Close();
}
internal abstract class aaz : object {
}
[AttributeUsageAttribute("108")]
internal class ab : Attribute {
}
internal class aba : object {
    private qj a;
    private vn b;
    private rx d;
    private vo e;
    public sealed virtual void Close();
}
internal class abb : object {
    private qj a;
    public sealed virtual void Close();
}
internal class abc : bs {
    private aax d;
    public virtual void Close();
}
internal class abd : object {
    public static lx CreateEncryptedPrivateKeyInfo(string a, Char[] b, Byte[] c, int d, rw e);
    public static lx CreateEncryptedPrivateKeyInfo(string a, Char[] b, Byte[] c, int d, mj e);
}
internal class abe : object {
    public static mj CreatePrivateKeyInfo(rw a);
    public static mj CreatePrivateKeyInfo(Char[] a, lx b);
    public static mj CreatePrivateKeyInfo(Char[] a, bool b, lx c);
}
internal class abf : Exception {
    public abf(string a);
    public abf(string a, Exception b);
}
internal class abg : object {
    private static IDictionary a;
    private static IDictionary b;
    private static abg();
    public static rx GetCipher(hw a);
    public static rx GetCipher(string a);
    private static int GetDigitIndex(string a);
}
internal class abh : object {
    private static IDictionary a;
    private static IDictionary b;
    private static abh();
    public static hw GetObjectIdentifier(string a);
    public static sg GetDigest(string a);
    public static Byte[] DoFinal(sg a);
}
internal class abi : object {
    private static IDictionary a;
    private static IDictionary b;
    private static IDictionary c;
    private static abi();
    private static void AddDefaultKeySizeEntries(int a, String[] b);
    private static void AddKgAlgorithm(string a, Object[] b);
    private static void AddKpgAlgorithm(string a, Object[] b);
    private static void AddHMacKeyGenerator(string a, Object[] b);
    internal static string GetCanonicalKeyGeneratorAlgorithm(string a);
    internal static int GetDefaultKeySize(hw a);
    internal static int GetDefaultKeySize(string a);
    private static int FindDefaultKeySize(string a);
}
internal class abj : abf {
    public abj(string a);
}
internal class abk : abj {
    public abk(string a);
}
internal class abl : abj {
    public abl(string a);
}
internal class abm : object {
    private static IDictionary a;
    private static abm();
    public static vl GetMac(string a);
    public static Byte[] DoFinal(vl a);
}
internal class abn : object {
    private static IDictionary a;
    private static IDictionary b;
    private static abn();
    private static void AddAlgorithm(string a, Object[] b);
    private static void AddBasicIVSizeEntries(int a, String[] b);
    public static string GetCanonicalAlgorithmName(string a);
    public static xd CreateKeyParameter(string a, Byte[] b, int c, int d);
}
internal class abo : object {
    private static IDictionary a;
    private static IDictionary b;
    private static IDictionary c;
    private static abo();
    private static ve MakePbeGenerator(string a, sg b, Byte[] c, Byte[] d, int e);
    public static hw GetObjectIdentifier(string a);
    public static bool IsPkcs12(string a);
    public static bool IsPkcs5Scheme2(string a);
    public static bool IsPbeAlgorithm(string a);
    public static bo GenerateAlgorithmParameters(string a, Byte[] b, int c);
    public static qt GenerateCipherParameters(ly a, Char[] b, bool c);
    public static qt GenerateCipherParameters(string a, Char[] b, bo c);
    public static qt GenerateCipherParameters(string a, Char[] b, bool c, bo d);
    public static object CreateEngine(ly a);
    public static object CreateEngine(string a);
    private static qt FixDesParity(string a, qt b);
}
internal class abp : object {
    public static rw CreateKey(mj a);
    public static rw DecryptKey(Char[] a, lx b);
    public static rw DecryptKey(Char[] a, Byte[] b);
    private static rw DecryptKey(Char[] a, bu b);
    public static Byte[] EncryptKey(string a, Char[] b, Byte[] c, int d, rw e);
}
internal class abq : object {
    public static rw CreateKey(Byte[] a);
    public static rw CreateKey(pb a);
    private static bool IsPkcsDHParam(cb a);
    private static xk ReadPkcsDHParam(hw a, zy b, cb c);
}
internal class abr : Random {
    private static zc a;
    private static zc b;
    private static abr[] c;
    protected zc d;
    private static double e;
    private static abr Master { get; }
    public abr(zc a);
    private static abr();
    private static abr get_Master();
    public static abr GetInstance(string a);
    public static Byte[] GetSeed(int a);
    public virtual Byte[] GenerateSeed(int a);
    public virtual void SetSeed(Byte[] a);
    public virtual void SetSeed(long a);
    public virtual int Next();
    public virtual int Next(int a);
    public virtual int Next(int a, int b);
    public virtual void NextBytes(Byte[] a);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
}
internal class abs : Exception {
    public abs(string a);
}
internal class abt : abf {
    public abt(string a, Exception b);
}
internal class abu : object {
    internal static IDictionary a;
    internal static IDictionary b;
    private static abu();
    public static bo GetDefaultX509Parameters(string a);
    private static bo GetPssX509Parameters(string a);
    public static vp GetSigner(string a);
}
internal class abv : object {
    public static bool AreEqual(Byte[] a, Byte[] b);
    public static bool ConstantTimeAreEqual(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    public static int GetHashCode(Byte[] a);
    public static Byte[] Clone(Byte[] a);
    public static Int32[] Clone(Int32[] a);
    public static void Fill(Byte[] a, byte b);
}
internal class abw : object {
    public static zy CreateRandomInRange(zy a, zy b, abr c);
}
internal class abx : object {
    public static string ToString(IEnumerable a);
}
internal interface aby {
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public abstract virtual void Add(object a);
    public abstract virtual void AddAll(IEnumerable a);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object a);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Remove(object a);
    public abstract virtual void RemoveAll(IEnumerable a);
}
internal class abz : object {
    private IDictionary a;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual void Add(object a);
    public virtual void AddAll(IEnumerable a);
    public virtual void Clear();
    public virtual bool Contains(object a);
    public virtual void CopyTo(Array a, int b);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual void Remove(object a);
    public virtual void RemoveAll(IEnumerable a);
    public virtual object get_SyncRoot();
}
[AttributeUsageAttribute("111")]
internal class ac : Attribute {
}
internal abstract class aca : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual void Add(object a);
    public virtual void AddAll(IEnumerable a);
    public virtual void Clear();
    public abstract virtual bool Contains(object a);
    public abstract virtual void CopyTo(Array a, int b);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public virtual void Remove(object a);
    public virtual void RemoveAll(IEnumerable a);
}
internal class acb : aca {
    private aby a;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public virtual bool Contains(object a);
    public virtual void CopyTo(Array a, int b);
    public virtual int get_Count();
    public virtual IEnumerator GetEnumerator();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
}
internal class acc : object {
    public static DateTime a;
    private static acc();
    public static long DateTimeToUnixMs(DateTime a);
    public static long CurrentUnixMs();
}
internal interface acd {
    public abstract virtual int Encode(Byte[] a, int b, int c, Stream d);
    public abstract virtual int Decode(Byte[] a, int b, int c, Stream d);
    public abstract virtual int DecodeString(string a, Stream b);
}
internal class ace : object {
    protected Byte[] a;
    protected byte b;
    protected Byte[] c;
    protected void InitialiseDecodingTable();
    public sealed virtual int Encode(Byte[] a, int b, int c, Stream d);
    private bool ignore(char a);
    public sealed virtual int Decode(Byte[] a, int b, int c, Stream d);
    private int nextI(Byte[] a, int b, int c);
    public sealed virtual int DecodeString(string a, Stream b);
    private int decodeLastBlock(Stream a, char b, char c, char d, char e);
    private int nextI(string a, int b, int c);
}
internal class acf : object {
    private static acd a;
    private static acf();
    public static string ToHexString(Byte[] a);
    public static Byte[] Encode(Byte[] a, int b, int c);
    public static Byte[] Decode(string a);
}
internal class acg : object {
    private static Byte[] a;
    internal static Byte[] b;
    private static acg();
    public sealed virtual int Encode(Byte[] a, int b, int c, Stream d);
    private bool ignore(char a);
    public sealed virtual int Decode(Byte[] a, int b, int c, Stream d);
    public sealed virtual int DecodeString(string a, Stream b);
}
internal class ach : object {
    internal static Enum GetEnumValue(Type a, string b);
    internal static Array GetEnumValues(Type a);
    internal static Enum GetArbitraryValue(Type a);
}
internal class aci : bs {
    private int e;
    public virtual int ReadByte();
    public virtual int Read(Byte[] a, int b, int c);
}
internal class acj : object {
    public static Byte[] ReadAll(Stream a);
    public static int ReadFully(Stream a, Byte[] b);
    public static int ReadFully(Stream a, Byte[] b, int c, int d);
    public static void PipeAll(Stream a, Stream b);
}
internal class ack : gh {
    private Stream m;
    private Stream aj;
    public virtual void Close();
    public virtual int Read(Byte[] a, int b, int c);
    public virtual int ReadByte();
}
internal class acl : ct {
    private Stream as;
    private Stream at;
    public virtual void Close();
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
}
internal class acm : object {
    internal static string a;
    private static acm();
    private static string GetNewLine();
    internal static string GetEnvironmentVariable(string a);
    internal static Exception CreateNotImplementedException(string a);
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int a);
    internal static IDictionary CreateHashtable();
    internal static IDictionary CreateHashtable(IDictionary a);
}
internal class acn : object {
    internal static bool IsOneOf(string a, String[] b);
    public static string FromByteArray(Byte[] a);
    public static Byte[] ToByteArray(string a);
    public static string FromAsciiByteArray(Byte[] a);
    public static Byte[] ToAsciiByteArray(Char[] a);
    public static Byte[] ToAsciiByteArray(string a);
}
internal class aco : object {
    internal long adler32(long a, Byte[] b, int c, int d);
}
internal class acp : object {
    private static a[] a;
    private static String[] b;
    internal acw c;
    internal int d;
    internal Byte[] e;
    internal int f;
    internal int g;
    internal int h;
    internal int i;
    internal byte j;
    internal int k;
    internal int l;
    internal int m;
    internal int n;
    internal Byte[] o;
    internal int p;
    internal Int16[] q;
    internal Int16[] r;
    internal int s;
    internal int t;
    internal int u;
    internal int v;
    internal int w;
    internal int x;
    internal int y;
    internal int z;
    internal int aa;
    internal int ab;
    internal int ac;
    internal int ad;
    internal int ae;
    internal int af;
    internal int ag;
    internal int ah;
    internal int ai;
    internal int aj;
    internal Int16[] ak;
    internal Int16[] al;
    internal Int16[] am;
    internal acv an;
    internal acv ao;
    internal acv ap;
    internal Int16[] aq;
    internal Int32[] ar;
    internal int as;
    internal int at;
    internal Byte[] au;
    internal int av;
    internal int aw;
    internal int ax;
    internal int ay;
    internal int az;
    internal int ba;
    internal int bb;
    internal int bc;
    internal UInt32 bd;
    internal int be;
    private static acp();
    internal void init_block();
    internal void pqdownheap(Int16[] a, int b);
    internal static bool smaller(Int16[] a, int b, int c, Byte[] d);
    internal void scan_tree(Int16[] a, int b);
    internal int build_bl_tree();
    internal void send_all_trees(int a, int b, int c);
    internal void send_tree(Int16[] a, int b);
    internal void put_byte(Byte[] a, int b, int c);
    internal void put_short(int a);
    internal void putShortMSB(int a);
    internal void send_code(int a, Int16[] b);
    internal void send_bits(int a, int b);
    internal void _tr_align();
    internal bool _tr_tally(int a, int b);
    internal void compress_block(Int16[] a, Int16[] b);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int a, int b, bool c);
    internal void flush_block_only(bool a);
    internal int deflate_stored(int a);
    internal void _tr_stored_block(int a, int b, bool c);
    internal void _tr_flush_block(int a, int b, bool c);
    internal void fill_window();
    internal int deflate_fast(int a);
    internal int deflate_slow(int a);
    internal int longest_match(int a);
    internal int deflateEnd();
    internal int deflate(acw a, int b);
}
internal class acq : object {
    private static Int32[] a;
    private static Int32[] b;
    internal int c;
    internal int d;
    internal int e;
    internal int f;
    internal Int32[] g;
    internal Int32[] h;
    internal Int32[] i;
    internal acr j;
    private int k;
    internal int l;
    internal int m;
    internal Int32[] n;
    internal Byte[] o;
    internal int p;
    internal int q;
    internal int r;
    internal object s;
    internal long t;
    internal act u;
    private static acq();
    internal void reset(acw a, Int64[] b);
    internal int proc(acw a, int b);
    internal void free(acw a);
    internal int inflate_flush(acw a, int b);
}
internal class acr : object {
    private static Int32[] a;
    private int b;
    private int c;
    private Int32[] d;
    private int e;
    private int f;
    private int g;
    private int h;
    private int i;
    private byte j;
    private byte k;
    private Int32[] l;
    private int m;
    private Int32[] n;
    private int o;
    private static acr();
    internal void init(int a, int b, Int32[] c, int d, Int32[] e, int f, acw g);
    internal int proc(acq a, acw b, int c);
    internal void free(acw a);
    internal int inflate_fast(int a, int b, Int32[] c, int d, Int32[] e, int f, acq g, acw h);
}
internal class acs : object {
    internal int a;
    internal int b;
    internal Int64[] c;
    internal long d;
    internal int e;
    internal int f;
    internal int g;
    internal acq h;
    private static Byte[] i;
    private static acs();
    internal int inflateEnd(acw a);
    internal int inflate(acw a, int b);
}
internal class act : object {
    private static Int32[] a;
    private static Int32[] b;
    private static Int32[] d;
    private static Int32[] e;
    private static Int32[] f;
    private static Int32[] g;
    private Int32[] h;
    private Int32[] i;
    private Int32[] j;
    private Int32[] k;
    private Int32[] l;
    private Int32[] m;
    private static act();
    private int huft_build(Int32[] a, int b, int c, int d, Int32[] e, Int32[] f, Int32[] g, Int32[] h, Int32[] i, Int32[] j, Int32[] k);
    internal int inflate_trees_bits(Int32[] a, Int32[] b, Int32[] c, Int32[] d, acw e);
    internal int inflate_trees_dynamic(int a, int b, Int32[] c, Int32[] d, Int32[] e, Int32[] f, Int32[] g, Int32[] h, acw i);
    internal static int inflate_trees_fixed(Int32[] a, Int32[] b, Int32[][] c, Int32[][] d, acw e);
    private void initWorkArea(int a);
}
internal class acu : object {
    internal static Int16[] a;
    internal static Int16[] b;
    internal static acu c;
    internal static acu d;
    internal static acu e;
    internal Int16[] f;
    internal Int32[] g;
    internal int h;
    internal int i;
    internal int j;
    internal acu(Int16[] a, Int32[] b, int c, int d, int e);
    private static acu();
}
internal class acv : object {
    internal static Int32[] a;
    internal static Int32[] b;
    internal static Int32[] c;
    internal static Byte[] d;
    internal static Byte[] e;
    internal static Byte[] f;
    internal static Int32[] g;
    internal static Int32[] h;
    internal Int16[] i;
    internal int j;
    internal acu k;
    private static acv();
    internal static int d_code(int a);
    internal void gen_bitlen(acp a);
    internal void build_tree(acp a);
    internal static void gen_codes(Int16[] a, int b, Int16[] c);
    internal static int bi_reverse(int a, int b);
}
internal class acw : object {
    public Byte[] a;
    public int b;
    public int c;
    public long d;
    public Byte[] e;
    public int f;
    public int g;
    public long h;
    public string i;
    internal acp j;
    internal acs k;
    public long l;
    internal aco m;
    public int inflate(int a);
    public int inflateEnd();
    public int deflate(int a);
    public int deflateEnd();
    internal void flush_pending();
    internal int read_buf(Byte[] a, int b, int c);
    public void free();
}
internal class acx : object {
    public static pb CreateSubjectPublicKeyInfo(rw a);
    private static void ExtractBytes(Byte[] a, int b, zy c);
}
internal class acy : bo {
    private mw vi;
    public virtual bu ToAsn1Object();
}
internal class acz : bo {
    private int vj;
    public virtual bu ToAsn1Object();
}
[GeneratedCodeAttribute("reflection-utils", "1.0.0")]
internal class ad : object {
    private static Object[] a;
    private static ad();
    public static Attribute GetAttribute(MemberInfo a, Type b);
    public static Attribute GetAttribute(Type a, Type b);
    public static Type[] GetGenericTypeArguments(Type a);
    public static bool IsTypeGenericeCollectionInterface(Type a);
    public static bool IsAssignableFrom(Type a, Type b);
    public static bool IsTypeDictionary(Type a);
    public static bool IsNullableType(Type a);
    public static object ToNullableType(object a, Type b);
    public static bool IsValueType(Type a);
    public static IEnumerable`1<ConstructorInfo> GetConstructors(Type a);
    public static ConstructorInfo GetConstructorInfo(Type a, Type[] b);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type a);
    public static IEnumerable`1<FieldInfo> GetFields(Type a);
    public static MethodInfo GetGetterMethodInfo(PropertyInfo a);
    public static MethodInfo GetSetterMethodInfo(PropertyInfo a);
    public static c GetContructor(ConstructorInfo a);
    public static c GetContructor(Type a, Type[] b);
    public static c GetConstructorByReflection(ConstructorInfo a);
    public static c GetConstructorByReflection(Type a, Type[] b);
    public static c GetConstructorByExpression(ConstructorInfo a);
    public static c GetConstructorByExpression(Type a, Type[] b);
    public static a GetGetMethod(PropertyInfo a);
    public static a GetGetMethod(FieldInfo a);
    public static a GetGetMethodByReflection(PropertyInfo a);
    public static a GetGetMethodByReflection(FieldInfo a);
    public static a GetGetMethodByExpression(PropertyInfo a);
    public static a GetGetMethodByExpression(FieldInfo a);
    public static b GetSetMethod(PropertyInfo a);
    public static b GetSetMethod(FieldInfo a);
    public static b GetSetMethodByReflection(PropertyInfo a);
    public static b GetSetMethodByReflection(FieldInfo a);
    public static b GetSetMethodByExpression(PropertyInfo a);
    public static b GetSetMethodByExpression(FieldInfo a);
    public static BinaryExpression Assign(Expression left, Expression right);
}
[CompilerGeneratedAttribute]
internal class ada : object {
    internal static d a;
    internal static d b;
    internal static e c;
    internal static f d;
    internal static d e;
    internal static g f;
    internal static h g;
    internal static h h;
    internal static h i;
    internal static a j;
    internal static a k;
    internal static a l;
    internal static a m;
    internal static c n;
    internal static i o;
    internal static i p;
    internal static h q;
    internal static h r;
    internal static j s;
    internal static c t;
    internal static c u;
    internal static h v;
    internal static h w;
    internal static j x;
    internal static c y;
    internal static c z;
    internal static c aa;
    internal static c ab;
    internal static c ac;
    internal static c ad;
    internal static c ae;
    internal static c af;
    internal static h ag;
    internal static h ah;
    internal static j ai;
    internal static k aj;
    internal static c ak;
    internal static c al;
    internal static c am;
    internal static c an;
    internal static l ao;
    internal static c ap;
    internal static c aq;
    internal static c ar;
    internal static c as;
    internal static l at;
    internal static h au;
    internal static c av;
    internal static c aw;
    internal static c ax;
    internal static c ay;
    internal static c az;
    internal static c ba;
    internal static c bb;
    internal static c bc;
    internal static i bd;
    internal static m be;
    internal static b bf;
    internal static i bg;
    internal static l bh;
    internal static h bi;
    internal static h bj;
    internal static h bk;
    internal static h bl;
    internal static h bm;
    internal static h bn;
    internal static h bo;
    internal static h bp;
    internal static n bq;
    internal static n br;
    internal static n bs;
    internal static n bt;
    internal static n bu;
    internal static n bv;
    internal static n bw;
    internal static n bx;
    internal static o by;
    internal static h bz;
    internal static h ca;
    internal static p cb;
    internal static h cc;
    internal static h cd;
    internal static j ce;
    internal static int cf;
    internal static int cg;
    internal static int ch;
    internal static int ci;
    internal static int cj;
    internal static int ck;
    internal static int cl;
    internal static int cm;
    internal static int cn;
    internal static int co;
    internal static c cp;
    internal static c cq;
    internal static c cr;
    internal static c cs;
    internal static e ct;
    internal static f cu;
    internal static f cv;
    internal static Dictionary`2<string, int> cw;
    internal static s cx;
    internal static n cy;
    internal static n cz;
    internal static Dictionary`2<string, int> da;
    internal static h db;
    internal static d dc;
    internal static q dd;
    internal static q de;
    internal static i df;
    internal static i dg;
    internal static i dh;
    internal static i di;
    internal static i dj;
    internal static i dk;
    internal static i dl;
    internal static r dm;
    internal static r dn;
    internal static r dp;
    internal static r dq;
    internal static r dr;
    internal static r ds;
    internal static r dt;
    internal static r du;
    internal static r dv;
    internal static r dw;
    internal static r dx;
    internal static r dy;
    internal static r dz;
    internal static r ea;
    internal static r eb;
    internal static r ec;
    internal static r ed;
    internal static r ee;
    internal static r ef;
    internal static r eg;
    internal static r eh;
    internal static r ei;
    internal static r ej;
    internal static r ek;
    internal static r el;
    internal static r em;
    internal static r en;
    internal static r eo;
    internal static r ep;
    internal static r eq;
    internal static r er;
    internal static r es;
    internal static r et;
    internal static r eu;
    internal static r ev;
    internal static r ew;
    internal static r ex;
    internal static r ey;
    internal static r ez;
    internal static r fa;
    internal static r fb;
    internal static r fc;
    internal static r fd;
    internal static r fe;
    internal static r ff;
    internal static r fg;
    internal static r fh;
    internal static r fi;
    internal static r fj;
    internal static r fk;
    internal static r fl;
    internal static r fm;
    internal static r fn;
    internal static r fo;
    internal static h fp;
    internal static d fq;
    internal static e fr;
    internal static e fs;
    internal static i ft;
    internal static o fu;
    internal static t fv;
    internal static o fw;
    internal static u fx;
    internal static v fy;
    internal static w fz;
    internal static w ga;
    internal static x gb;
    internal static x gc;
    internal static y gd;
    internal static x ge;
    internal static z gf;
    internal static x gg;
    internal static t gh;
    internal static aa gi;
    internal static f gj;
    internal static h gk;
    internal static z gl;
    internal static x gm;
}
internal class ae : object {
    internal static void CallWeakReferenceHandlers(ICommand a, List`1<WeakReference> b);
    internal static void AddWeakReferenceHandler(List`1& a, EventHandler b);
    internal static void AddWeakReferenceHandler(List`1& a, EventHandler b, int c);
    internal static void RemoveWeakReferenceHandler(List`1<WeakReference> a, EventHandler b);
}
internal class af : object {
    private static string a;
    public static Func`2<IDependencyResolver, object> Create(Type a);
    private static NewExpression BuildExpression(Type a, ParameterExpression b);
    private static ConstructorInfo GetConstructorInfo(Type a);
}
internal interface ag {
    public abstract virtual Type GetInstanceType();
    public abstract virtual bool Equals(object a);
    public abstract virtual int GetHashCode();
}
internal class ah : object {
    internal Type a;
    internal string b;
    internal ah(string a, Type b);
    public sealed virtual Type GetInstanceType();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
internal class ai : object {
    internal ILifetimeManager a;
    internal Func`2<IDependencyResolver, object> b;
    private string c;
    private Type d;
    private Type e;
    public object f;
    private IDependencyResolver g;
    private object h;
    [CompilerGeneratedAttribute]
private string i;
    public string Key { get; }
    public Type ResolvesTo { get; }
    public Type ImplType { get; }
    public string Name { get; private set; }
    internal ai(IDependencyResolver a, string b, Type c, Func`2<IDependencyResolver, object> d);
    internal ai(IDependencyResolver a, string b, Type c, Type d);
    public sealed virtual string get_Key();
    public sealed virtual Type get_ResolvesTo();
    public Type get_ImplType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual IRegistration WithLifetimeManager(ILifetimeManager a);
    public object GetCachedInstance();
    public sealed virtual object CreateInstance();
    public sealed virtual object GetInstance();
    public sealed virtual void InvalidateInstanceCache();
}
internal class aj : object {
    private bool a;
    private IDictionary`2<ag, ai> b;
    internal void Add(ai a);
    internal ai Get(string a, Type b);
    internal IEnumerable`1<ai> GetDerived(string a, Type b);
    internal IEnumerable`1<ai> GetDerived(Type a);
    internal bool ContainsKey(string a, Type b);
    internal IEnumerable`1<ai> All(Type a);
    internal void Remove(IRegistration a);
    private static ag MakeKey(string a, Type b);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool a);
    protected virtual override void Finalize();
}
internal class ak : object {
    internal Type a;
    public ak(Type a);
    public sealed virtual Type GetInstanceType();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
[CompilerGeneratedAttribute]
internal class al : object {
    internal static a a;
    internal static a b;
}
[AttributeUsageAttribute("1")]
internal class am : Attribute {
    private DateTime a;
    public DateTime BuildDate { get; }
    public am(DateTime a);
    public am(string a);
    public DateTime get_BuildDate();
}
internal class an : object {
    protected XElement a;
    protected XName b;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, string> c;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, string> d;
    internal an(XElement a, XName b);
    public virtual void Add(string a, string b);
    public virtual void AddAttributeForKey(string a, string b, string c);
    public virtual void AddAll(IDictionary`2<string, string> a);
    public virtual void Remove(string a);
    public virtual void RemoveAll();
    public virtual string Get(string a);
    public virtual IDictionary`2<string, string> GetAll();
    public virtual bool Contains(string a);
    public virtual bool ContainsAll(String[] a);
    protected virtual XElement GetChild(string a);
    protected virtual string GetChildAttributeValue(string a, string b);
    protected virtual void SetTag(string a, string b);
    protected virtual void SetAttribute(string a, string b);
    protected virtual void SetChildTag(string a, string b);
    protected virtual string GetTag(string a);
    protected virtual string GetChildTag(string a);
    [CompilerGeneratedAttribute]
private static string <GetAll>b__3(XElement a);
    [CompilerGeneratedAttribute]
private static string <GetAll>b__4(XElement a);
}
internal class ao : an {
    public string Name { get; public set; }
    public string Company { get; public set; }
    public string Email { get; public set; }
    internal ao(XElement a);
    public string get_Name();
    public void set_Name(string value);
    public string get_Company();
    public void set_Company(string value);
    public string get_Email();
    public void set_Email(string value);
}
[EditorBrowsableAttribute("1")]
internal interface ap {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object a);
}
internal interface aq {
    public abstract virtual aq WithUniqueIdentifier(Guid a);
    public abstract virtual aq As(at a);
    public abstract virtual aq ExpiresAt(DateTime a);
    public abstract virtual aq WithMaximumUtilization(int a);
    public abstract virtual aq LicensedTo(string a, string b);
    public abstract virtual aq LicensedTo(string a, string b, Action`1<ao> c);
    public abstract virtual aq LicensedTo(Action`1<ao> a);
    public abstract virtual aq WithLicensedProducts(au[] a);
    public abstract virtual aq WithProductFeatures(IDictionary`2<string, string> a);
    public abstract virtual aq WithProductFeatures(Action`1<an> a);
    public abstract virtual aq WithAdditionalAttributes(IDictionary`2<string, string> a);
    public abstract virtual aq WithAdditionalAttributes(Action`1<an> a);
    public abstract virtual ar CreateAndSignWithPrivateKey(string a, string b);
}
internal class ar : object {
    private XElement a;
    private string b;
    public Guid Id { get; public set; }
    public at Type { get; public set; }
    public int Quantity { get; public set; }
    public an ProductFeatures { get; }
    public as LicensedProducts { get; }
    public ao Customer { get; }
    public an AdditionalAttributes { get; }
    public DateTime Expiration { get; public set; }
    public string Signature { get; }
    private bool IsSigned { get; }
    internal ar(XElement a);
    public Guid get_Id();
    public void set_Id(Guid value);
    public at get_Type();
    public void set_Type(at value);
    public int get_Quantity();
    public void set_Quantity(int value);
    public an get_ProductFeatures();
    public as get_LicensedProducts();
    public ao get_Customer();
    public an get_AdditionalAttributes();
    public DateTime get_Expiration();
    public void set_Expiration(DateTime value);
    public string get_Signature();
    public bool VerifySignature(string a);
    public static ar Load(string a);
    public static ar Load(Stream a);
    public static ar Load(TextReader a);
    public static ar Load(XmlReader a);
    public virtual string ToString();
    private bool get_IsSigned();
    private void SetTag(string a, string b);
    private string GetTag(string a);
}
internal class as : an {
    internal as(XElement a);
    public void AddProduct(string a, string b);
    public au GetProduct(string a);
}
internal enum at : Enum {
    public int value__;
    public static at a;
    public static at b;
    public static at c;
}
internal class au : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private double b;
    public string Name { get; private set; }
    public double Version { get; private set; }
    public au(string a, double b);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(double value);
}
internal static class av : object {
    private static string a;
    private static av();
    public static string ToEncryptedPrivateKeyString(rw a, string b);
    public static rw FromEncryptedPrivateKeyString(string a, string b);
    public static string ToPublicKeyString(rw a);
    public static rw FromPublicKeyString(string a);
}
internal class aw : object {
    private ut a;
    public aw(int a);
    public static aw Create();
    public ax GenerateKeyPair();
}
internal class ax : object {
    private rv a;
    internal ax(rv a);
    public string ToEncryptedPrivateKeyString(string a);
    public string ToPublicKeyString();
}
internal interface ay {
    public string Message { get; public set; }
    public string HowToResolve { get; public set; }
    public abstract virtual string get_Message();
    public abstract virtual void set_Message(string value);
    public abstract virtual string get_HowToResolve();
    public abstract virtual void set_HowToResolve(string value);
}
internal class az : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    public string Message { get; public set; }
    public string HowToResolve { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HowToResolve();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HowToResolve(string value);
}
internal interface ba {
    public abstract virtual bf And();
}
internal interface bb {
    public abstract virtual IEnumerable`1<ay> AssertValidLicense();
}
internal interface bc {
}
internal interface bd {
    public Predicate`1<ar> Validate { get; public set; }
    public Predicate`1<ar> ValidateWhen { get; public set; }
    public ay FailureResult { get; public set; }
    public abstract virtual Predicate`1<ar> get_Validate();
    public abstract virtual void set_Validate(Predicate`1<ar> value);
    public abstract virtual Predicate`1<ar> get_ValidateWhen();
    public abstract virtual void set_ValidateWhen(Predicate`1<ar> value);
    public abstract virtual ay get_FailureResult();
    public abstract virtual void set_FailureResult(ay value);
}
internal class be : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    public string Message { get; public set; }
    public string HowToResolve { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HowToResolve();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HowToResolve(string value);
}
internal interface bf {
}
internal interface bg {
    public abstract virtual bc When(Predicate`1<ar> a);
}
internal interface bh {
}
internal class bi : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    public string Message { get; public set; }
    public string HowToResolve { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HowToResolve();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HowToResolve(string value);
}
internal class bj : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    public string Message { get; public set; }
    public string HowToResolve { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HowToResolve();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HowToResolve(string value);
}
[ExtensionAttribute]
internal static class bk : object {
    [CompilerGeneratedAttribute]
private static Predicate`1<ar> a;
    [ExtensionAttribute]
public static bf Validate(ar a);
    [ExtensionAttribute]
public static bh ExpirationDate(bf a);
    [ExtensionAttribute]
public static bh LicensedProduct(bf a, string b, double c);
    [ExtensionAttribute]
public static bh ProductBuildDate(bf a, Assembly[] b);
    [ExtensionAttribute]
public static bh Signature(bf a, string b);
    [CompilerGeneratedAttribute]
private static bool <ExpirationDate>b__1(ar a);
}
internal class bl : object {
    [CompilerGeneratedAttribute]
private Predicate`1<ar> a;
    [CompilerGeneratedAttribute]
private Predicate`1<ar> b;
    [CompilerGeneratedAttribute]
private ay c;
    public Predicate`1<ar> Validate { get; public set; }
    public Predicate`1<ar> ValidateWhen { get; public set; }
    public ay FailureResult { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Predicate`1<ar> get_Validate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Validate(Predicate`1<ar> value);
    [CompilerGeneratedAttribute]
public sealed virtual Predicate`1<ar> get_ValidateWhen();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ValidateWhen(Predicate`1<ar> value);
    [CompilerGeneratedAttribute]
public sealed virtual ay get_FailureResult();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailureResult(ay value);
}
internal class bm : object {
    private Queue`1<bd> a;
    private bd b;
    private ar c;
    public bm(ar a);
    public bd StartValidatorChain();
    public void CompleteValidatorChain();
    public sealed virtual bc When(Predicate`1<ar> a);
    public sealed virtual bf And();
    public sealed virtual IEnumerable`1<ay> AssertValidLicense();
    private sealed virtual override Type ap.GetType();
}
internal interface bn {
    public abstract virtual bu ToAsn1Object();
}
internal abstract class bo : object {
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string a);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object a);
    public abstract virtual bu ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
internal class bp : object {
    private IList a;
    public bo Item { get; }
    public int Count { get; }
    public bp(bo[] a);
    public void Add(bo[] a);
    public void AddOptional(bo[] a);
    public bo get_Item(int index);
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class bq : IOException {
    public bq(string a);
    public bq(string a, Exception b);
}
internal abstract class br : object {
    private Stream a;
    protected Stream Out { get; }
    protected Stream get_Out();
    public abstract virtual void AddObject(bo a);
    public abstract virtual Stream GetRawOutputStream();
    public abstract virtual void Close();
}
internal class bs : Stream {
    protected Stream a;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bs(Stream a);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long a, SeekOrigin b);
    public virtual void SetLength(long a);
    public virtual int Read(Byte[] a, int b, int c);
    public virtual int ReadByte();
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
}
internal class bt : bs {
    private int b;
    private Byte[][] c;
    public bt(Stream a);
    public bt(Stream a, int b);
    public bt(Byte[] a);
    internal static int FindLimit(Stream a);
    private bu BuildObject(int a, int b, int c);
    internal bp BuildEncodableVector();
    internal virtual bp BuildDerEncodableVector(hl a);
    internal virtual cw CreateDerSequence(hl a);
    internal virtual da CreateDerSet(hl a);
    public bu ReadObject();
    internal static int ReadTagNumber(Stream a, int b);
    internal static int ReadLength(Stream a, int b);
    internal static Byte[] GetBuffer(hl a, Byte[][] b);
    internal static bu CreatePrimitiveDerObject(int a, hl b, Byte[][] c);
}
internal abstract class bu : bo {
    public static bu FromByteArray(Byte[] a);
    public sealed virtual bu ToAsn1Object();
    internal abstract virtual void Encode(by a);
    protected abstract virtual bool Asn1Equals(bu a);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(bu a);
    internal int CallAsn1GetHashCode();
}
internal abstract class bv : bu {
    public virtual string ToString();
}
internal interface bw {
    public abstract virtual Stream GetOctetStream();
}
internal abstract class bx : bu {
    internal Byte[] a;
    public bw Parser { get; }
    internal bx(Byte[] a);
    internal bx(bo a);
    public static bx GetInstance(ch a, bool b);
    public static bx GetInstance(object a);
    public sealed virtual Stream GetOctetStream();
    public bw get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public virtual string ToString();
}
internal class by : bs {
    public by(Stream a);
    private void WriteLength(int a);
    internal void WriteEncoded(int a, Byte[] b);
    internal void WriteEncoded(int a, Byte[] b, int c, int d);
    internal void WriteTag(int a, int b);
    internal void WriteEncoded(int a, int b, Byte[] c);
    protected void WriteNull();
    public virtual void WriteObject(bo a);
    public virtual void WriteObject(bu a);
}
internal class bz : by {
    public bz(Stream a);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object a);
}
internal class ca : InvalidOperationException {
    public ca(string a);
    public ca(string a, Exception b);
}
[DefaultMemberAttribute("Item")]
internal abstract class cb : bu {
    private IList b;
    public cc Parser { get; }
    public bo Item { get; }
    public int Count { get; }
    protected internal cb(int a);
    public static cb GetInstance(object a);
    public static cb GetInstance(ch a, bool b);
    public virtual IEnumerator GetEnumerator();
    public virtual cc get_Parser();
    public virtual bo get_Item(int index);
    public virtual int get_Count();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    private bo GetCurrent(IEnumerator a);
    protected internal void AddObject(bo a);
    public virtual string ToString();
}
internal interface cc {
    public abstract virtual bn ReadObject();
}
[DefaultMemberAttribute("Item")]
internal abstract class cd : bu {
    private IList c;
    public bo Item { get; }
    public int Count { get; }
    public ce Parser { get; }
    protected internal cd(int a);
    public static cd GetInstance(object a);
    public static cd GetInstance(ch a, bool b);
    public virtual IEnumerator GetEnumerator();
    public virtual bo get_Item(int index);
    public virtual int get_Count();
    public ce get_Parser();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    private bo GetCurrent(IEnumerator a);
    private bool LessThanOrEqual(Byte[] a, Byte[] b);
    protected internal void Sort();
    protected internal void AddObject(bo a);
    public virtual string ToString();
}
internal interface ce {
    public abstract virtual bn ReadObject();
}
internal class cf : object {
    private Stream a;
    private int b;
    private Byte[][] c;
    public cf(Stream a);
    public cf(Stream a, int b);
    internal bn ReadIndef(int a);
    internal bn ReadImplicit(bool a, int b);
    internal bu ReadTaggedObject(bool a, int b);
    public virtual bn ReadObject();
    private void Set00Check(bool a);
    internal bp ReadVector();
}
internal interface cg {
    public int TagNo { get; }
    public abstract virtual int get_TagNo();
    public abstract virtual bn GetObjectParser(int a, bool b);
}
internal abstract class ch : bu {
    internal int d;
    internal bool e;
    internal bo f;
    public int TagNo { get; }
    protected ch(int a, bo b);
    protected ch(bool a, int b, bo c);
    public static ch GetInstance(ch a, bool b);
    public static ch GetInstance(object a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
    public sealed virtual int get_TagNo();
    public bool IsExplicit();
    public bool IsEmpty();
    public bu GetObject();
    public sealed virtual bn GetObjectParser(int a, bool b);
    public virtual string ToString();
}
internal abstract class ci : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    private static ci();
}
internal class cj : bu {
    private bool g;
    private int h;
    private Byte[] i;
    internal cj(bool a, int b, Byte[] c);
    public cj(int a, bp b);
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal class ck : cj {
    public ck(int a, bp b);
}
internal interface cl {
    public abstract virtual bn ReadObject();
}
internal class cm : object {
    private int a;
    private cf b;
    internal cm(int a, cf b);
    public sealed virtual bn ReadObject();
    public sealed virtual bu ToAsn1Object();
}
internal class cn : br {
    private bool b;
    private bool c;
    public virtual void AddObject(bo a);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
    protected void WriteBerEnd();
}
internal class co : bv {
    public static co j;
    private Byte[] k;
    protected internal co(int a);
    private static co();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal class cp : co {
    public static cp j;
    private cp(int a);
    private static cp();
    internal virtual void Encode(by a);
}
internal class cq : bx {
    public cq(Byte[] a);
    public cq(bo a);
    internal virtual void Encode(by a);
    internal static void Encode(by a, Byte[] b, int c, int d);
}
internal class cr : cq {
    private IEnumerable l;
    public cr(Byte[] a);
    public cr(IEnumerable a);
    public static cr FromSequence(cb a);
    private static Byte[] ToBytes(IEnumerable a);
    public virtual Byte[] GetOctets();
    public sealed virtual IEnumerator GetEnumerator();
    private IList GenerateOcts();
    internal virtual void Encode(by a);
}
internal class cs : cn {
}
internal abstract class ct : Stream {
    private bool e;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] a, int b, int c);
    public sealed virtual long Seek(long a, SeekOrigin b);
    public sealed virtual void SetLength(long a);
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void Write(Byte[] a);
}
internal class cu : object {
    private cf a;
    internal cu(cf a);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual bu ToAsn1Object();
}
internal class cv : by {
    public cv(Stream a);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object a);
}
internal class cw : cb {
    public static cw m;
    public cw(bo a);
    public cw(bo[] a);
    public cw(bp a);
    private static cw();
    public static cw FromVector(bp a);
    internal virtual void Encode(by a);
}
internal class cx : cw {
    public static cx m;
    public cx(bo a);
    public cx(bo[] a);
    public cx(bp a);
    private static cx();
    public static cx FromVector(bp a);
    internal virtual void Encode(by a);
}
internal class cy : cn {
}
internal class cz : object {
    private cf a;
    internal cz(cf a);
    public sealed virtual bn ReadObject();
    public sealed virtual bu ToAsn1Object();
}
internal class da : cd {
    public static da m;
    public da(bo a);
    public da(bo[] a);
    public da(bp a);
    internal da(bp a, bool b);
    private static da();
    internal static da FromVector(bp a, bool b);
    internal virtual void Encode(by a);
}
internal class db : da {
    public static db m;
    public db(bp a);
    internal db(bp a, bool b);
    private static db();
    internal virtual void Encode(by a);
}
internal class dc : object {
    private cf a;
    internal dc(cf a);
    public sealed virtual bn ReadObject();
    public sealed virtual bu ToAsn1Object();
}
internal class dd : ch {
    public dd(int a, bo b);
    public dd(bool a, int b, bo c);
    internal virtual void Encode(by a);
}
internal class de : dd {
    public de(int a, bo b);
    public de(bool a, int b, bo c);
    internal virtual void Encode(by a);
}
internal class df : object {
    private bool a;
    private int b;
    private cf c;
    public int TagNo { get; }
    internal df(bool a, int b, cf c);
    public sealed virtual int get_TagNo();
    public sealed virtual bn GetObjectParser(int a, bool b);
    public sealed virtual bu ToAsn1Object();
}
internal class dg : bo {
    private dq n;
    private dq o;
    private dq p;
    public virtual bu ToAsn1Object();
}
internal class dh : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class di : bo {
    private dk r;
    private gs s;
    private gv t;
    public virtual bu ToAsn1Object();
}
internal interface dj {
}
internal class dk : bo {
    private dq u;
    private gs v;
    public virtual bu ToAsn1Object();
}
internal class dl : bo {
    private cb w;
    private cb x;
    public virtual bu ToAsn1Object();
}
internal class dm : bo {
    private hc y;
    private el z;
    private di aa;
    private bx ab;
    public virtual bu ToAsn1Object();
}
internal class dn : bo {
    private bx ac;
    private hc y;
    private el ad;
    public virtual bu ToAsn1Object();
}
internal class dp : bo {
    private ly ae;
    private bx af;
    private bx ag;
    public virtual bu ToAsn1Object();
}
internal class dq : bo {
    private pl ah;
    private nj ai;
    public virtual bu ToAsn1Object();
}
internal class dr : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class ds : bo {
    private el aj;
    private hc ak;
    private ef al;
    public virtual bu ToAsn1Object();
}
internal class dt : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class du : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class dv : bo {
    private hw am;
    private bo an;
    public virtual bu ToAsn1Object();
}
internal class dw : bo {
    private el z;
    private dq ao;
    private cb ap;
    private cb aq;
    public virtual bu ToAsn1Object();
    private void AddOptional(bp a, int b, bo c);
}
internal class dx : bo {
    private ly ar;
    private gk as;
    private ed at;
    public virtual bu ToAsn1Object();
    private void AddOptional(bp a, int b, bo c);
}
internal class dy : bo {
    private bx au;
    private ly ae;
    private hc av;
    private ly aw;
    public virtual bu ToAsn1Object();
}
internal class dz : bo {
    private int d;
    private bo ax;
    public virtual bu ToAsn1Object();
}
internal class ea : bo {
    public virtual bu ToAsn1Object();
}
internal interface eb {
    public abstract virtual string GetString();
}
internal abstract class ec : bu {
    public abstract virtual string GetString();
    public virtual string ToString();
    protected virtual int Asn1GetHashCode();
}
internal class ed : ec {
    private static Char[] ay;
    private Byte[] az;
    private int ba;
    public int PadBits { get; }
    public int IntValue { get; }
    public ed(Byte[] a, int b);
    public ed(Byte[] a);
    public ed(bo a);
    private static ed();
    internal static int GetPadBits(int a);
    internal static Byte[] GetBytes(int a);
    public static ed GetInstance(object a);
    public static ed GetInstance(ch a, bool b);
    public Byte[] GetBytes();
    public int get_PadBits();
    public int get_IntValue();
    internal virtual void Encode(by a);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public virtual string GetString();
    internal static ed FromAsn1Octets(Byte[] a);
}
internal class ee : ed {
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class ef : bo {
    internal cb bb;
    public virtual bu ToAsn1Object();
}
internal class eg : bo {
    public static nz bc;
    public static int bd;
    public static int be;
    private hc bf;
    private nz bg;
    private nz bh;
    private hr bi;
    private ly bj;
    private bx bk;
    private bx bl;
    private bx bm;
    private bx bn;
    private bx bo;
    private ef bp;
    private cb bq;
    private static eg();
    public virtual bu ToAsn1Object();
    private static void AddOptional(bp a, int b, bo c);
}
internal class eh : bo {
    private eg br;
    private dz ax;
    private ed bs;
    private cb bt;
    public virtual bu ToAsn1Object();
    private static void AddOptional(bp a, int b, bo c);
}
internal class ei : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal enum ej : Enum {
    public int value__;
    public static ej a;
    public static ej b;
    public static ej c;
    public static ej d;
    public static ej e;
    public static ej f;
    public static ej g;
}
internal class ek : bo {
    public static ek bu;
    public static ek bv;
    public static ek bw;
    public static ek bx;
    public static ek by;
    public static ek bz;
    public static ek ca;
    private hc z;
    private ek(ej a);
    private ek(hc a);
    private static ek();
    public virtual bu ToAsn1Object();
}
internal class el : bo {
    private hc z;
    private ef cb;
    private ed cc;
    public virtual bu ToAsn1Object();
}
internal class em : bo {
    private hc y;
    private hc cd;
    private ef ce;
    public virtual bu ToAsn1Object();
}
internal class en : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class eo : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class ep : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class eq : bo {
    private eg br;
    private dz ax;
    public virtual bu ToAsn1Object();
}
internal class er : bo {
    private ek z;
    private gk as;
    private hr cf;
    private hr cg;
    private pp ch;
    public virtual bu ToAsn1Object();
}
internal class es : bo {
    private go ci;
    private pp cj;
    public virtual bu ToAsn1Object();
}
internal class et : bo {
    private cb z;
    private cb ck;
    private cb cl;
    public virtual bu ToAsn1Object();
    private void AddOptional(bp a, int b, bo c);
}
internal class eu : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class ev : bo {
    private hw cm;
    private cd cn;
    public hw AttrType { get; }
    public ev(cb a);
    public ev(hw a, cd b);
    public static ev GetInstance(object a);
    public hw get_AttrType();
    public virtual bu ToAsn1Object();
}
internal class ew : bo {
    private cd co;
    public virtual bu ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
internal class ex : object {
    private IDictionary a;
    public ev Item { get; }
    public ex(IDictionary a);
    public ev get_Item(hw oid);
    public IDictionary ToDictionary();
    public bp ToAsn1EncodableVector();
}
internal class ey : bo {
    private hc cp;
    private fr cq;
    private cd cr;
    private ly cs;
    private ly ct;
    private fd cu;
    private cd cv;
    private bx aw;
    private cd cw;
    public virtual bu ToAsn1Object();
}
internal class ez : bo {
    private hc cp;
    private fr cq;
    private cd cr;
    private ff cx;
    private cd cv;
    private bx aw;
    private cd cw;
    public virtual bu ToAsn1Object();
}
internal abstract class fa : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    private static fa();
}
internal abstract class fb : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    private static fb();
}
internal class fc : bo {
    private hc cp;
    private ly cy;
    private fd cz;
    public virtual bu ToAsn1Object();
}
internal class fd : bo {
    private hw da;
    private bo q;
    public virtual bu ToAsn1Object();
}
internal class fe : bo {
    private fs db;
    private bx dc;
    public virtual bu ToAsn1Object();
}
internal class ff : bo {
    private hw da;
    private ly dd;
    private bx de;
    public virtual bu ToAsn1Object();
}
internal class fg : bo {
    private hc cp;
    private ff df;
    private cd dg;
    public virtual bu ToAsn1Object();
}
internal class fh : bo {
    private hc cp;
    private fr cq;
    private cd cr;
    private ff df;
    private cd dg;
    public virtual bu ToAsn1Object();
}
internal class fi : bo {
    private gg dh;
    public virtual bu ToAsn1Object();
}
internal class fj : bo {
    private pq di;
    private hc dj;
    public virtual bu ToAsn1Object();
}
internal class fk : bo {
    private bx dk;
    private hr dl;
    private ft dm;
    public virtual bu ToAsn1Object();
}
internal class fl : bo {
    private hc cp;
    private fk dn;
    private ly dp;
    private bx dq;
    public virtual bu ToAsn1Object();
}
internal class fm : bo {
    private fj dr;
    private fz ds;
    public virtual bu ToAsn1Object();
}
internal class fn : bo {
    private hc cp;
    private fq dt;
    private bx du;
    private ly dp;
    private cb dv;
    public virtual bu ToAsn1Object();
}
internal class fo : bo {
    private hc cp;
    private fx dw;
    private ly dp;
    private bx dq;
    public virtual bu ToAsn1Object();
}
internal class fp : bo {
    private hn dx;
    private ii dy;
    private hu dz;
    private ew ea;
    public virtual bu ToAsn1Object();
}
internal class fq : bo {
    private bo eb;
    public virtual bu ToAsn1Object();
}
internal class fr : bo {
    private cd ec;
    private cd cl;
    public virtual bu ToAsn1Object();
}
internal class fs : bo {
    private ly ed;
    private ed ee;
    public virtual bu ToAsn1Object();
}
internal class ft : bo {
    private hw ef;
    private bo eg;
    public virtual bu ToAsn1Object();
}
internal class fu : bo {
    private hw eh;
    private bo ei;
    public virtual bu ToAsn1Object();
}
internal class fv : bo {
    private hc cp;
    private ly ej;
    private ly dp;
    private bx dq;
    public virtual bu ToAsn1Object();
}
internal class fw : bo {
    private fm ek;
    private bx dq;
    public virtual bu ToAsn1Object();
}
internal class fx : bo {
    private bo eb;
    public virtual bu ToAsn1Object();
}
internal class fy : bo {
    internal bo el;
    public virtual bu ToAsn1Object();
}
internal class fz : bo {
    private bx em;
    private hr dl;
    private ft dm;
    public virtual bu ToAsn1Object();
}
internal class ga : bo {
    private hc cp;
    private cd en;
    private fd eo;
    private cd ep;
    private cd cl;
    private cd eq;
    private bool er;
    private bool es;
    public virtual bu ToAsn1Object();
}
internal class gb : bo {
    private bo eb;
    public bool IsTagged { get; }
    public bool get_IsTagged();
    public virtual bu ToAsn1Object();
}
internal class gc : bo {
    private hc cp;
    private gb et;
    private ly eu;
    private cd ev;
    private ly ew;
    private bx ex;
    private cd ey;
    public gc(gb a, ly b, cd c, ly d, bx e, cd f);
    public virtual bu ToAsn1Object();
}
internal class gd : bo {
    private bu ez;
    public gd(DateTime a);
    public virtual bu ToAsn1Object();
}
internal class ge : bo {
    private fd fa;
    private no fb;
    public virtual bu ToAsn1Object();
}
internal class gf : bo {
    private hc cp;
    private hu fc;
    private fp fd;
    private bx q;
    private fi fe;
    public virtual bu ToAsn1Object();
}
internal class gg : bo {
    private ge[] ff;
    public virtual bu ToAsn1Object();
}
internal abstract class gh : Stream {
    private bool a;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] a, int b, int c);
    public sealed virtual long Seek(long a, SeekOrigin b);
    public sealed virtual void SetLength(long a);
    public sealed virtual void Write(Byte[] a, int b, int c);
}
internal class gi : gh {
    private cf b;
    private bool c;
    private Stream d;
    internal gi(cf a);
    public virtual int Read(Byte[] a, int b, int c);
    public virtual int ReadByte();
}
internal class gj : bo {
    private hw fg;
    private bo fh;
    public virtual bu ToAsn1Object();
}
internal class gk : bo {
    private nz fi;
    private hc dj;
    public virtual bu ToAsn1Object();
}
internal class gl : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class gm : bo {
    private gn fj;
    private ha fk;
    private cb fl;
    public virtual bu ToAsn1Object();
}
internal class gn : bo {
    private hc y;
    private go fm;
    private gp fn;
    public virtual bu ToAsn1Object();
}
internal class go : bo {
    private cb b;
    public virtual bu ToAsn1Object();
}
internal class gp : bo {
    private cb q;
    public virtual bu ToAsn1Object();
}
internal class gq : bo {
    private mj fo;
    private bo ek;
    public virtual bu ToAsn1Object();
}
internal class gr : bo {
    private fh fp;
    private gs fq;
    public virtual bu ToAsn1Object();
}
internal class gs : bo {
    private ly fr;
    private ly fs;
    private ed ft;
    private ly fu;
    private bx fv;
    private ed fw;
    public virtual bu ToAsn1Object();
    private void AddOptional(bp a, int b, bo c);
}
internal class gt : bo {
    private pi fx;
    private pi fy;
    public virtual bu ToAsn1Object();
}
internal class gu : bo {
    private bo fh;
    public virtual bu ToAsn1Object();
}
internal class gv : bo {
    private hc fz;
    private cb ga;
    public virtual bu ToAsn1Object();
}
internal class gw : bo {
    private ly gb;
    private ed gc;
    public virtual bu ToAsn1Object();
}
internal class gx : bo {
    private int d;
    private bo f;
    public virtual bu ToAsn1Object();
}
internal class gy : bo {
    private gz gd;
    private ly ge;
    private ed gf;
    public virtual bu ToAsn1Object();
}
internal class gz : bo {
    private nz bg;
    private gw gg;
    private pb ee;
    public virtual bu ToAsn1Object();
}
internal class ha : bo {
    private int d;
    private bo f;
    public virtual bu ToAsn1Object();
}
internal class hb : bo {
    private hc gh;
    private nz gi;
    public virtual bu ToAsn1Object();
}
internal class hc : bu {
    private Byte[] gj;
    public zy Value { get; }
    public zy PositiveValue { get; }
    public hc(int a);
    public hc(zy a);
    public hc(Byte[] a);
    public static hc GetInstance(object a);
    public zy get_Value();
    public zy get_PositiveValue();
    internal virtual void Encode(by a);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public virtual string ToString();
}
internal abstract class hd : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    private static hd();
}
internal class he : object {
    internal static IDictionary a;
    internal static IDictionary b;
    internal static IDictionary c;
    private static he();
    public static xs GetByOid(hw a);
}
internal class hf : bo {
    internal hc gk;
    internal hc gl;
    internal hc gm;
    internal hc gn;
    internal hc go;
    internal hc gp;
    public virtual bu ToAsn1Object();
}
internal class hg : bo {
    private bx gq;
    private hw gr;
    public virtual bu ToAsn1Object();
}
internal class hh : object {
    private static IDictionary a;
    private static IDictionary b;
    private static hi c;
    private static hi d;
    private static hi e;
    private static hh();
    public static hi GetByOid(hw a);
}
internal class hi : bo {
    private int gs;
    private hc gk;
    private hc gl;
    private hc gm;
    public zy P { get; }
    public zy Q { get; }
    public zy A { get; }
    public hi(int a, zy b, zy c, zy d);
    public zy get_P();
    public zy get_Q();
    public zy get_A();
    public virtual bu ToAsn1Object();
}
internal class hj : bo {
    private hw gt;
    private hw gu;
    private hw gv;
    public hw PublicKeyParamSet { get; }
    public hj(hw a, hw b);
    public hj(hw a, hw b, hw c);
    public hj(cb a);
    public hw get_PublicKeyParamSet();
    public virtual bu ToAsn1Object();
}
internal abstract class hk : gh {
    protected Stream e;
    private int f;
    internal hk(Stream a, int b);
    internal virtual int GetRemaining();
    protected virtual void SetParentEofDetect(bool a);
}
internal class hl : hk {
    private static Byte[] g;
    private int h;
    private int i;
    internal hl(Stream a, int b);
    private static hl();
    public virtual int ReadByte();
    public virtual int Read(Byte[] a, int b, int c);
    internal void ReadAllIntoByteArray(Byte[] a);
    internal Byte[] ToArray();
}
internal class hm : ec {
    private string a;
    public hm(Byte[] a);
    public virtual string GetString();
    protected virtual bool Asn1Equals(bu a);
    internal virtual void Encode(by a);
}
internal class hn : bu {
    private byte fh;
    public static hn gw;
    public static hn gx;
    public bool IsTrue { get; }
    public hn(Byte[] a);
    private hn(bool a);
    private static hn();
    public bool get_IsTrue();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
internal class ho : bu {
    private Byte[] gj;
    public zy Value { get; }
    public ho(Byte[] a);
    public zy get_Value();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal class hp : bu {
    private hw gy;
    private hc gz;
    private bu ha;
    private int hb;
    private bu hc;
    unknown int Encoding {public set; }
    public hp(bp a);
    internal virtual void Encode(by a);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public void set_Encoding(int value);
    private static bu GetObjFromVector(bp a, int b);
    private static void WriteEncodable(MemoryStream a, bo b);
}
internal class hq : bo {
    private cf hd;
    public hq(cf a);
    public virtual bu ToAsn1Object();
}
internal class hr : bu {
    private string ez;
    private bool HasFractionalSeconds { get; }
    public hr(string a);
    internal hr(Byte[] a);
    public string GetTime();
    private string CalculateGmtOffset();
    private static string Convert(int a);
    public DateTime ToDateTime();
    private string FString(int a);
    private DateTime ParseDateString(string a, string b, bool c);
    private bool get_HasFractionalSeconds();
    private Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal class hs : ec {
    private string a;
    public hs(Byte[] a);
    public hs(string a);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
}
internal abstract class ht : br {
    private bool b;
    private bool c;
    private int d;
    private static void WriteLength(Stream a, int b);
    internal static void WriteDerEncoded(Stream a, int b, Byte[] c);
    internal void WriteDerEncoded(int a, Byte[] b);
}
internal class hu : ec {
    private string a;
    public hu(Byte[] a);
    public hu(string a);
    public hu(string a, bool b);
    public static hu GetInstance(object a);
    public static hu GetInstance(ch a, bool b);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public static bool IsIA5String(string a);
}
internal class hv : ec {
    private string a;
    public hv(Byte[] a);
    public hv(string a, bool b);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    public static bool IsNumericString(string a);
}
internal class hw : bu {
    private static Regex he;
    private string ek;
    private Byte[] ax;
    private static hw[] hf;
    public string Id { get; }
    public hw(string a);
    internal hw(Byte[] a);
    private static hw();
    public static hw GetInstance(object a);
    public static hw GetInstance(ch a, bool b);
    public string get_Id();
    private void WriteField(Stream a, long b);
    private void WriteField(Stream a, zy b);
    private void DoOutput(MemoryStream a);
    internal Byte[] GetBody();
    internal virtual void Encode(by a);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(bu a);
    public virtual string ToString();
    private static string MakeOidStringFromBytes(Byte[] a);
    internal static hw FromOctetString(Byte[] a);
}
internal class hx : object {
    private hl a;
    internal hx(hl a);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual bu ToAsn1Object();
}
internal class hy : ec {
    private string a;
    public hy(Byte[] a);
    public hy(string a);
    public hy(string a, bool b);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    public static bool IsPrintableString(string a);
}
internal class hz : ht {
    private MemoryStream e;
    public virtual void AddObject(bo a);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
internal class i : object {
    private string a;
    private Type b;
    private PropertyInfo c;
    public PropertyInfo PropertyInfo { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public i(string a, Type b);
    public i(PropertyInfo a);
    public PropertyInfo get_PropertyInfo();
    public string get_Name();
    public Type get_PropertyType();
}
internal class ia : object {
    private cf a;
    internal ia(cf a);
    public sealed virtual bn ReadObject();
    public sealed virtual bu ToAsn1Object();
}
internal class ib : ht {
    private MemoryStream e;
    public virtual void AddObject(bo a);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
internal class ic : object {
    private cf a;
    internal ic(cf a);
    public sealed virtual bn ReadObject();
    public sealed virtual bu ToAsn1Object();
}
internal class id : ec {
    private string a;
    public id(Byte[] a);
    public id(string a);
    public virtual string GetString();
    internal virtual void Encode(by a);
    public Byte[] GetOctets();
    protected virtual bool Asn1Equals(bu a);
}
internal class ie : ec {
    private static Char[] ay;
    private Byte[] a;
    public ie(Byte[] a);
    private static ie();
    public virtual string GetString();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
}
internal class ig : bu {
    private bool g;
    private int h;
    private Byte[] az;
    public ig(bool a, int b, Byte[] c);
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal class ih : bu {
    private string ez;
    public string TimeString { get; }
    public string AdjustedTimeString { get; }
    public ih(string a);
    internal ih(Byte[] a);
    public DateTime ToDateTime();
    private DateTime ParseDateString(string a, string b);
    public string get_TimeString();
    public string get_AdjustedTimeString();
    private Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
internal class ii : ec {
    private string a;
    public ii(Byte[] a);
    public ii(string a);
    public virtual string GetString();
    protected virtual bool Asn1Equals(bu a);
    internal virtual void Encode(by a);
}
internal class ij : ec {
    private string a;
    public ij(Byte[] a);
    public ij(string a);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(by a);
    protected virtual bool Asn1Equals(bu a);
    protected virtual int Asn1GetHashCode();
}
internal abstract class ik : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    private static ik();
}
internal class il : bo {
    private cb ep;
    public virtual bu ToAsn1Object();
}
internal class im : bo {
    private hw hg;
    private cb hh;
    public virtual bu ToAsn1Object();
}
internal class in : bo {
    private hw hi;
    private bu hj;
    public virtual bu ToAsn1Object();
}
public class Intersoft.Crosslight.Account : object {
    private IDictionary`2<string, object> a;
    public static string IsNativeAccount;
    public static string NativeAccount;
    public static string AccessToken;
    public static string PasswordHash;
    public static string Password;
    public static string Deleted;
    public static string AuthenticatorServiceIdentifier;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    public string Username { get; internal set; }
    public string ServiceId { get; internal set; }
    public string AuthenticatorServiceId { get; }
    public IDictionary`2<string, object> Properties { get; }
    public Account(string username, string serviceId);
    public Account(string username, string serviceId, IDictionary`2<string, object> properties);
    public Account(string username, string serviceId, IDictionary`2<string, string> properties);
    public virtual T GetProperty(string key);
    public virtual string GetProperty(string key);
    [CompilerGeneratedAttribute]
public virtual string get_Username();
    [CompilerGeneratedAttribute]
internal virtual void set_Username(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ServiceId();
    [CompilerGeneratedAttribute]
internal virtual void set_ServiceId(string value);
    public virtual string get_AuthenticatorServiceId();
    public virtual IDictionary`2<string, object> get_Properties();
}
public abstract class Intersoft.Crosslight.AccountStoreServiceBase : object {
    public virtual void SetOwner(object owner);
    public abstract virtual IEnumerable`1<IAccount> FindAccounts(string serviceId);
    public abstract virtual IAccount FindAccount(string serviceId);
    public abstract virtual void Save(IAccount account);
    public abstract virtual void Delete(IAccount account);
    protected virtual string SerializeCookies(object cookies);
    protected virtual object DeserializeCookies(string str);
    protected virtual string Serialize(IAccount account);
    protected virtual IAccount Deserialize(string serializedString);
}
public enum Intersoft.Crosslight.ActivityStyle : Enum {
    public int value__;
    public static ActivityStyle LargeIndicator;
    public static ActivityStyle SmallIndicatorWithText;
    public static ActivityStyle TranslucentIndicatorWithText;
}
public enum Intersoft.Crosslight.AddressType : Enum {
    public int value__;
    public static AddressType Work;
    public static AddressType Home;
    public static AddressType Other;
}
public static class Intersoft.Crosslight.ApplicationLicensing : object {
    private static IDependencyContainer a;
    private static l b;
    private static string c;
    private static ApplicationLicensing();
    [q]
internal static void ValidateLicense(IApplicationHost a, Action b);
}
[q]
internal static class Intersoft.Crosslight.ApplicationManager : object {
    [q]
internal static IApplicationInitializer GetAppInitializer(Assembly a);
    [q]
internal static void CheckRequiredServices();
    [q]
internal static Type FindViewModelType(Type a, Type b);
    [q]
internal static Type FindViewContextType(NavigationTarget a, Type b, bool c);
    [q]
internal static Type FindViewContextType(NavigationTarget a, Type[] b, bool c);
    private static bool IsIdentifierMatch(Type a, string b, Type[] c, bool d);
}
public abstract class Intersoft.Crosslight.ApplicationServiceBase : object {
    private IApplicationContext a;
    private ApplicationState b;
    public ApplicationState State { get; public set; }
    public IApplicationEventSource EventSource { get; }
    public ApplicationServiceBase(IApplicationContext context);
    public sealed virtual ApplicationState get_State();
    public void set_State(ApplicationState value);
    public sealed virtual IApplicationContext GetContext();
    public virtual IApplicationEventSource get_EventSource();
    public virtual void Navigate(NavigationTarget target);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnStart(StartParameter a);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnTerminate();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnPause();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnDeactivate();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnActivate();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnResume();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnNotificationReceived(Notification a);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnDeviceTokenReceived(DeviceToken a);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnSync(SyncContext a);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnCancelSync(SyncContext a);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnUserInteraction();
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnViewModelNavigated(IViewModel a, NavigatedParameter b);
    private sealed virtual override void Intersoft.Crosslight.IApplicationService.OnViewModelDisposed(IViewModel a);
    private void RaiseApplicationStateChanged(ApplicationState a, ApplicationState b);
    protected virtual void OnSync(SyncContext context);
    protected virtual void OnCancelSync(SyncContext context);
    protected virtual void OnNotificationReceived(Notification notification);
    protected virtual void OnDeviceTokenReceived(DeviceToken deviceToken);
    protected virtual void OnStart(StartParameter parameter);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual void OnStop();
    protected virtual void OnPause();
    protected virtual void OnResume();
    protected virtual void OnRestart();
    protected virtual void OnTerminate();
    protected virtual void OnUserInteraction();
    protected virtual void OnViewModelNavigated(IViewModel viewModel, NavigatedParameter parameter);
    protected virtual void OnViewModelDisposed(IViewModel viewModel);
    public virtual void SetRootViewModel();
    public virtual void SetRootViewModel(IViewModel viewModel);
    public sealed virtual TService GetService();
    public sealed virtual TService GetService(bool newInstance);
}
public enum Intersoft.Crosslight.ApplicationState : Enum {
    public int value__;
    public static ApplicationState NotRunning;
    public static ApplicationState Starting;
    public static ApplicationState Started;
    public static ApplicationState Active;
    public static ApplicationState Inactive;
    public static ApplicationState Background;
    public static ApplicationState Terminating;
    public static ApplicationState Terminated;
}
public class Intersoft.Crosslight.AuthenticateOptions : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private bool b;
    public bool AllowUserInteraction { get; public set; }
    public bool ForceLogin { get; public set; }
    public AuthenticateOptions(bool allowUserInteraction);
    [CompilerGeneratedAttribute]
public bool get_AllowUserInteraction();
    [CompilerGeneratedAttribute]
public void set_AllowUserInteraction(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceLogin();
    [CompilerGeneratedAttribute]
public void set_ForceLogin(bool value);
}
public class Intersoft.Crosslight.AuthenticationContext : object {
    [CompilerGeneratedAttribute]
private IAccount a;
    [CompilerGeneratedAttribute]
private CancellationToken b;
    [CompilerGeneratedAttribute]
private AuthenticateOptions c;
    public IAccount Account { get; private set; }
    public CancellationToken CancellationToken { get; private set; }
    public AuthenticateOptions Options { get; private set; }
    public AuthenticationContext(IAccount account);
    public AuthenticationContext(IAccount account, AuthenticateOptions options);
    public AuthenticationContext(IAccount account, AuthenticateOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual IAccount get_Account();
    [CompilerGeneratedAttribute]
private void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
private void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public sealed virtual AuthenticateOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(AuthenticateOptions value);
}
[AttributeUsageAttribute("1")]
public class Intersoft.Crosslight.AutoInitializeServicesAttribute : Attribute {
}
public class Intersoft.Crosslight.BackgroundEventSubscription`1 : EventSubscription`1<TPayload> {
    public BackgroundEventSubscription`1(IDelegateReference actionReference, IDelegateReference filterReference);
    public virtual void InvokeAction(Action`1<TPayload> action, TPayload argument);
}
public class Intersoft.Crosslight.BasicImageLoaderSettings : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private bool b;
    [CompilerGeneratedAttribute]
private bool c;
    [CompilerGeneratedAttribute]
private CacheExpirationPolicy d;
    public bool AnimateOnLoad { get; public set; }
    public bool CacheToMemory { get; public set; }
    public bool CacheToDisk { get; public set; }
    public CacheExpirationPolicy CacheExpirationPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AnimateOnLoad();
    [CompilerGeneratedAttribute]
public void set_AnimateOnLoad(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheToMemory();
    [CompilerGeneratedAttribute]
public void set_CacheToMemory(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheToDisk();
    [CompilerGeneratedAttribute]
public void set_CacheToDisk(bool value);
    [CompilerGeneratedAttribute]
public CacheExpirationPolicy get_CacheExpirationPolicy();
    [CompilerGeneratedAttribute]
public void set_CacheExpirationPolicy(CacheExpirationPolicy value);
}
public class Intersoft.Crosslight.BindableProperties : object {
    public static BindableProperty NameProperty;
    public static BindableProperty TextProperty;
    public static BindableProperty ValueProperty;
    public static BindableProperty MaxValueProperty;
    public static BindableProperty DataContextProperty;
    public static BindableProperty IsCheckedProperty;
    public static BindableProperty DisableCommandAutoRequeryProperty;
    public static BindableProperty IsEnabledProperty;
    public static BindableProperty IsVisibleProperty;
    public static BindableProperty IsSelectedProperty;
    public static BindableProperty IsEditingProperty;
    public static BindableProperty IsBatchUpdatingProperty;
    public static BindableProperty OpacityProperty;
    public static BindableProperty StyleAttributesProperty;
    public static BindableProperty ImageProperty;
    public static BindableProperty ImageSourceProperty;
    public static BindableProperty PlaceholderProperty;
    public static BindableProperty ImagePlaceholderProperty;
    public static BindableProperty ImageLoaderContextProperty;
    public static BindableProperty ImageLoaderSettingsProperty;
    public static BindableProperty IsComponentInitializedProperty;
    public static BindableProperty CommandProperty;
    public static BindableProperty CommandParameterProperty;
    public static BindableProperty ItemsSourceProperty;
    public static BindableProperty SectionIndexSourceProperty;
    public static BindableProperty ItemTemplateBindingProperty;
    public static BindableProperty DisplayMemberPathProperty;
    public static BindableProperty ValueMemberPathProperty;
    public static BindableProperty DetailMemberPathProperty;
    public static BindableProperty ImageMemberPathProperty;
    public static BindableProperty SelectedCommandProperty;
    public static BindableProperty SelectedIndexProperty;
    public static BindableProperty SelectedValueProperty;
    public static BindableProperty SelectedItemProperty;
    public static BindableProperty SelectedItemsProperty;
    public static BindableProperty EditActionCommandProperty;
    public static BindableProperty EditItemCommandProperty;
    public static BindableProperty AddItemCommandProperty;
    public static BindableProperty DeleteItemCommandProperty;
    public static BindableProperty ReorderItemCommandProperty;
    public static BindableProperty RefreshCommandProperty;
    public static BindableProperty DetailNavigationTargetProperty;
    public static BindableProperty HideKeyboardOnReturnProperty;
    public static BindableProperty NextInputFocusProperty;
    private static BindableProperties();
}
public class Intersoft.Crosslight.BindableProperty : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private Type b;
    [CompilerGeneratedAttribute]
private object c;
    public string Name { get; private set; }
    public Type Type { get; private set; }
    public object DefaultValue { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(object value);
    public static BindableProperty Register(string name, Type type);
    public static BindableProperty Register(string name, Type type, object defaultValue);
}
public class Intersoft.Crosslight.BindablePropertyMetadata : object {
    [CompilerGeneratedAttribute]
private BindableProperty a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private bool c;
    [CompilerGeneratedAttribute]
private UpdateSourceTrigger d;
    [CompilerGeneratedAttribute]
private bool e;
    public BindableProperty Property { get; internal set; }
    public object DefaultValue { get; internal set; }
    public bool SupportTwoWayBinding { get; internal set; }
    public UpdateSourceTrigger DefaultUpdateSourceTrigger { get; internal set; }
    public bool IsNativeProperty { get; internal set; }
    [CompilerGeneratedAttribute]
public BindableProperty get_Property();
    [CompilerGeneratedAttribute]
internal void set_Property(BindableProperty value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
internal void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public bool get_SupportTwoWayBinding();
    [CompilerGeneratedAttribute]
internal void set_SupportTwoWayBinding(bool value);
    [CompilerGeneratedAttribute]
public UpdateSourceTrigger get_DefaultUpdateSourceTrigger();
    [CompilerGeneratedAttribute]
internal void set_DefaultUpdateSourceTrigger(UpdateSourceTrigger value);
    [CompilerGeneratedAttribute]
public bool get_IsNativeProperty();
    [CompilerGeneratedAttribute]
internal void set_IsNativeProperty(bool value);
}
public abstract class Intersoft.Crosslight.BindingAdapterBase`1 : object {
    private List`1<BindablePropertyMetadata> a;
    protected void AddSupportedProperty(BindableProperty property, bool isNative, bool supportTwoWayBinding, UpdateSourceTrigger defaultUpdateSourceTrigger, object defaultValue);
    public sealed virtual bool IsPropertySupported(BindableProperty property, bool checkTwoWayBindingSupport);
    public virtual void SetValue(T obj, BindableProperty property, object value);
    public virtual object GetValue(T obj, BindableProperty property);
    public virtual object GetDefaultValue(T obj, BindableProperty property);
    public virtual void Attach(T obj, BindingContext context);
    public virtual void Detach(T obj, BindingContext context);
    protected BindablePropertyMetadata GetSupportedProperty(BindableProperty property);
    protected static void UpdateSource(object sender, BindableProperty property);
    protected static void UpdateSource(object sender, BindableProperty property, object value);
    protected void ClearValue(object obj, BindableProperty property);
    private void SetValueCore(object a, BindableProperty b, object c);
    private sealed virtual override void Intersoft.Crosslight.IBindingAdapter.SetValue(object a, BindableProperty b, object c);
    private sealed virtual override object Intersoft.Crosslight.IBindingAdapter.GetValue(object a, BindableProperty b);
    private sealed virtual override object Intersoft.Crosslight.IBindingAdapter.GetDefaultValue(object a, BindableProperty b);
    private sealed virtual override void Intersoft.Crosslight.IBindingAdapter.Attach(object a, BindingContext b);
    private sealed virtual override void Intersoft.Crosslight.IBindingAdapter.Detach(object a, BindingContext b);
}
public class Intersoft.Crosslight.BindingContext : object {
    private bool a;
    private IBindingAdapter b;
    [CompilerGeneratedAttribute]
private object c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private BindableProperty e;
    [CompilerGeneratedAttribute]
private BindingDescription f;
    [CompilerGeneratedAttribute]
private IViewContext g;
    [CompilerGeneratedAttribute]
private BindingState h;
    [CompilerGeneratedAttribute]
private o i;
    [CompilerGeneratedAttribute]
private k j;
    public object Target { get; private set; }
    public string TargetName { get; private set; }
    public BindableProperty Property { get; private set; }
    public BindingDescription Binding { get; private set; }
    public IViewContext ViewContext { get; internal set; }
    internal BindingState BindingState { get; internal set; }
    internal o UpdateState { get; internal set; }
    internal k SourcePropertyDescriptor { get; internal set; }
    private bool ListenToChanges { get; }
    internal object Source { get; }
    private IBindingAdapter BindingAdapter { get; }
    internal BindingContext(object a, BindableProperty b, BindingDescription c);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public object get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(object value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
private void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public BindableProperty get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(BindableProperty value);
    [CompilerGeneratedAttribute]
public BindingDescription get_Binding();
    [CompilerGeneratedAttribute]
private void set_Binding(BindingDescription value);
    [CompilerGeneratedAttribute]
public IViewContext get_ViewContext();
    [CompilerGeneratedAttribute]
internal void set_ViewContext(IViewContext value);
    [CompilerGeneratedAttribute]
internal BindingState get_BindingState();
    [CompilerGeneratedAttribute]
internal void set_BindingState(BindingState value);
    [CompilerGeneratedAttribute]
internal o get_UpdateState();
    [CompilerGeneratedAttribute]
internal void set_UpdateState(o value);
    [CompilerGeneratedAttribute]
internal k get_SourcePropertyDescriptor();
    [CompilerGeneratedAttribute]
internal void set_SourcePropertyDescriptor(k value);
    private bool get_ListenToChanges();
    internal object get_Source();
    private IBindingAdapter get_BindingAdapter();
    internal void AttachBindingAdapter();
    internal void DetachBindingAdapter();
    internal void Initialize();
    internal void UpdateSource(object a);
    public void UpdateSourceFromTarget();
    public object GetEffectiveValue();
    public object GetEffectiveValue(object dynamicSource);
    internal void UpdateTarget();
    internal void OnSourcePropertyChanged(PropertyChangedEventArgs a);
    internal void DetachForReuse();
    private bool EnsureTarget();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
public class Intersoft.Crosslight.BindingDefinition : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private BindableProperty c;
    [CompilerGeneratedAttribute]
private BindingDescription d;
    [CompilerGeneratedAttribute]
private object e;
    public string TargetName { get; public set; }
    public object Target { get; public set; }
    public BindableProperty Property { get; public set; }
    public BindingDescription Binding { get; public set; }
    public object Source { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public object get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(object value);
    [CompilerGeneratedAttribute]
public BindableProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(BindableProperty value);
    [CompilerGeneratedAttribute]
public BindingDescription get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(BindingDescription value);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(object value);
}
public class Intersoft.Crosslight.BindingDescription : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private BindingMode c;
    [CompilerGeneratedAttribute]
private IValueConverter d;
    [CompilerGeneratedAttribute]
private CultureInfo e;
    [CompilerGeneratedAttribute]
private object f;
    [CompilerGeneratedAttribute]
private UpdateSourceTrigger g;
    [CompilerGeneratedAttribute]
private string h;
    [CompilerGeneratedAttribute]
private bool i;
    [CompilerGeneratedAttribute]
private long j;
    [CompilerGeneratedAttribute]
private object k;
    public string Path { get; public set; }
    public object Source { get; public set; }
    public BindingMode Mode { get; public set; }
    public IValueConverter Converter { get; public set; }
    public CultureInfo ConverterCulture { get; public set; }
    public object ConverterParameter { get; public set; }
    public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    public string StringFormat { get; public set; }
    public bool AnimateChanges { get; public set; }
    public long AnimationDuration { get; public set; }
    internal object Tag { get; internal set; }
    internal string ResolvedPath { get; }
    internal object ResolvedSource { get; }
    public BindingDescription(string path);
    public BindingDescription(string path, object source);
    public BindingDescription(string path, object source, BindingMode mode);
    public BindingDescription(string path, object source, BindingMode mode, UpdateSourceTrigger updateTrigger);
    public BindingDescription(string path, BindingMode mode);
    public BindingDescription(string path, BindingMode mode, UpdateSourceTrigger updateTrigger);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(object value);
    [CompilerGeneratedAttribute]
public BindingMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(BindingMode value);
    [CompilerGeneratedAttribute]
public IValueConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(IValueConverter value);
    [CompilerGeneratedAttribute]
public CultureInfo get_ConverterCulture();
    [CompilerGeneratedAttribute]
public void set_ConverterCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public object get_ConverterParameter();
    [CompilerGeneratedAttribute]
public void set_ConverterParameter(object value);
    [CompilerGeneratedAttribute]
public UpdateSourceTrigger get_UpdateSourceTrigger();
    [CompilerGeneratedAttribute]
public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    [CompilerGeneratedAttribute]
public string get_StringFormat();
    [CompilerGeneratedAttribute]
public void set_StringFormat(string value);
    [CompilerGeneratedAttribute]
public bool get_AnimateChanges();
    [CompilerGeneratedAttribute]
public void set_AnimateChanges(bool value);
    [CompilerGeneratedAttribute]
public long get_AnimationDuration();
    [CompilerGeneratedAttribute]
public void set_AnimationDuration(long value);
    [CompilerGeneratedAttribute]
internal object get_Tag();
    [CompilerGeneratedAttribute]
internal void set_Tag(object value);
    internal string get_ResolvedPath();
    internal object get_ResolvedSource();
    public object GetValue(object source, Type targetType);
    internal object GetConvertedValue(object a, Type b);
    internal object ApplyStringFormat(string a, object b);
}
public class Intersoft.Crosslight.BindingManager : object {
    private static Dictionary`2<IViewContext, List`1<BindingContext>> a;
    private static Dictionary`2<string, IBindingAdapter> b;
    private static Dictionary`2<string, Type> c;
    private static BindingManager();
    public static void AddBindingAdapter();
    public static void AddBindingAdapter(string viewType);
    public static void AddDefaultBindingAdapter();
    public static void Register(IViewContext viewContext, BindingContext bindingContext);
    public static void Register(IViewContext viewContext);
    public static void Update(IViewContext viewContext, object source);
    public static void Unregister(IViewContext viewContext, object source);
    public static void Unregister(BindingContext bindingContext);
    public static void Unregister(IViewContext viewContext);
    internal static Type GetType(object a, string b);
    internal static bool HasPropertyAccessor(object a, string b);
    internal static object GetValue(object a, string b);
    internal static void SetValue(object a, string b, object c);
    internal static void InitializeBindingContext(BindingContext a);
    public static IBindingAdapter GetBindingAdapter(Type type);
    internal static IBindingAdapter GetDefaultBindingAdapter();
    internal static BindingContext GetBindingContext(object a, BindableProperty b);
    internal static IEnumerable`1<BindingContext> GetBindingContext(IViewContext a);
    public static IViewContext GetViewContext(IViewModel viewModel);
    internal static IViewContext GetViewContext(IViewModel a, Type b);
    internal static IViewContext GetLastViewContext(Type a);
    internal static IViewContext GetViewContext(int a);
    internal static IViewContext[] GetViewContext(NavigationTarget a);
    public sealed virtual void Dispose();
}
public enum Intersoft.Crosslight.BindingMode : Enum {
    public int value__;
    public static BindingMode TwoWay;
    public static BindingMode OneWay;
    public static BindingMode OneTime;
}
public class Intersoft.Crosslight.BindingProvider : object {
    private List`1<BindingDefinition> a;
    private sealed virtual override IEnumerable`1<BindingDefinition> Intersoft.Crosslight.IBindingProvider.GetBindings();
    protected void AddBinding(string targetViewName, BindableProperty property, BindingDescription binding);
    protected void AddBinding(string targetViewName, BindableProperty property, string path);
    protected void AddBinding(string targetViewName, BindableProperty property, string path, BindingMode mode);
    protected void AddBinding(string targetViewName, BindableProperty property, object value, bool isDirectSource);
    public virtual TService GetService();
    public virtual TService GetService(bool newInstance);
}
public enum Intersoft.Crosslight.BindingState : Enum {
    public int value__;
    public static BindingState NotInitialized;
    public static BindingState Initialized;
    public static BindingState Attached;
    public static BindingState Detaching;
    public static BindingState Detached;
}
public enum Intersoft.Crosslight.CacheExpirationPolicy : Enum {
    public int value__;
    public static CacheExpirationPolicy Never;
    public static CacheExpirationPolicy Explicit;
    public static CacheExpirationPolicy AutoDetect;
}
public enum Intersoft.Crosslight.CameraCaptureMode : Enum {
    public int value__;
    public static CameraCaptureMode Photo;
    public static CameraCaptureMode Video;
}
public enum Intersoft.Crosslight.CameraDeviceKind : Enum {
    public int value__;
    public static CameraDeviceKind Rear;
    public static CameraDeviceKind Front;
}
public enum Intersoft.Crosslight.CameraFlashMode : Enum {
    public int value__;
    public static CameraFlashMode Auto;
    public static CameraFlashMode On;
    public static CameraFlashMode Off;
}
public enum Intersoft.Crosslight.CameraMediaType : Enum {
    public int value__;
    public static CameraMediaType Auto;
    public static CameraMediaType Photo;
    public static CameraMediaType Movie;
    public static CameraMediaType All;
}
public enum Intersoft.Crosslight.CommandItemType : Enum {
    public int value__;
    public static CommandItemType Done;
    public static CommandItemType Cancel;
    public static CommandItemType Edit;
    public static CommandItemType Save;
    public static CommandItemType Add;
    public static CommandItemType Compose;
    public static CommandItemType Reply;
    public static CommandItemType Action;
    public static CommandItemType Organize;
    public static CommandItemType Bookmarks;
    public static CommandItemType Search;
    public static CommandItemType Refresh;
    public static CommandItemType Stop;
    public static CommandItemType Camera;
    public static CommandItemType Trash;
    public static CommandItemType Play;
    public static CommandItemType Pause;
    public static CommandItemType Rewind;
    public static CommandItemType FastForward;
    public static CommandItemType Undo;
    public static CommandItemType Redo;
    public static CommandItemType Favorite;
}
public class Intersoft.Crosslight.CommandManager : object {
    private static Dictionary`2<ICommand, List`1<object>> a;
    [CompilerGeneratedAttribute]
private static object b;
    [CompilerGeneratedAttribute]
private static object c;
    public static object LastCommandInitiator { get; public set; }
    private static object CapturedInitiator { get; private set; }
    private static CommandManager();
    [CompilerGeneratedAttribute]
public static object get_LastCommandInitiator();
    [CompilerGeneratedAttribute]
public static void set_LastCommandInitiator(object value);
    [CompilerGeneratedAttribute]
private static object get_CapturedInitiator();
    [CompilerGeneratedAttribute]
private static void set_CapturedInitiator(object value);
    public static void RegisterCommand(ICommand command, object obj);
    public static void UnregisterCommand(ICommand command, object obj);
    public static IEnumerable GetViews(ICommand command);
    public static void CaptureLastInitiator();
    public static void RestoreCapturedInitiator();
}
public enum Intersoft.Crosslight.CommandType : Enum {
    public int value__;
    public static CommandType Default;
    public static CommandType Cancel;
    public static CommandType Preferred;
    public static CommandType Destructive;
}
public enum Intersoft.Crosslight.ComponentType : Enum {
    public int value__;
    public static ComponentType FormContainer;
    public static ComponentType SectionContainer;
    public static ComponentType ComponentView;
}
public class Intersoft.Crosslight.Containers.AlwaysNewLifetime : object {
    public sealed virtual object GetInstance(IRegistration registration);
    public sealed virtual void InvalidateInstanceCache(IRegistration registration);
}
public class Intersoft.Crosslight.Containers.ContainerLifetime : object {
    public sealed virtual object GetInstance(IRegistration registration);
    public sealed virtual void InvalidateInstanceCache(IRegistration registration);
}
public interface Intersoft.Crosslight.Containers.IContainerFluent {
    public abstract virtual IContainerFluent UsesDefaultLifetimeManagerOf(ILifetimeManager lifetimeManager);
}
public interface Intersoft.Crosslight.Containers.IDependencyContainer {
}
public interface Intersoft.Crosslight.Containers.IDependencyRegistrar {
    public ILifetimeManager DefaultLifetimeManager { get; public set; }
    public abstract virtual ILifetimeManager get_DefaultLifetimeManager();
    public abstract virtual void set_DefaultLifetimeManager(ILifetimeManager value);
    public abstract virtual IRegistration Register(Func`2<IDependencyResolver, TType> func);
    public abstract virtual IRegistration Register(string name, Func`2<IDependencyResolver, TType> func);
    public abstract virtual IRegistration Register(Type type, Func`2<IDependencyResolver, object> func);
    public abstract virtual IRegistration Register(string name, Type type, Func`2<IDependencyResolver, object> func);
    public abstract virtual IRegistration RegisterInstance(TType instance);
    public abstract virtual IRegistration RegisterInstance(string name, TType instance);
    public abstract virtual IRegistration RegisterInstance(Type type, object instance);
    public abstract virtual IRegistration RegisterInstance(string name, Type type, object instance);
    public abstract virtual IRegistration Register();
    public abstract virtual IRegistration Register(string name);
    public abstract virtual IRegistration Register(Type tType, Type tImpl);
    public abstract virtual IRegistration Register(string name, Type tType, Type tImpl);
    public abstract virtual void Remove(IRegistration ireg);
    public abstract virtual void Remove();
    public abstract virtual IRegistration GetRegistration();
    public abstract virtual IRegistration GetRegistration(string name);
    public abstract virtual IRegistration GetRegistration(Type type);
    public abstract virtual IRegistration GetRegistration(string name, Type type);
    public abstract virtual IRegistration GetSpecificRegistration(string name);
    public abstract virtual IEnumerable`1<IRegistration> GetRegistrations();
    public abstract virtual IEnumerable`1<IRegistration> GetRegistrations(Type type);
}
public interface Intersoft.Crosslight.Containers.IDependencyResolver {
    public abstract virtual TType Resolve();
    public abstract virtual TType Resolve(string name);
    public abstract virtual object Resolve(Type type);
    public abstract virtual object Resolve(string name, Type type);
    public abstract virtual IEnumerable`1<TType> ResolveAll();
    public abstract virtual IEnumerable`1<object> ResolveAll(Type type);
    public abstract virtual Func`1<TType> LazyResolve();
    public abstract virtual Func`1<TType> LazyResolve(string name);
    public abstract virtual Func`1<object> LazyResolve(Type type);
    public abstract virtual Func`1<object> LazyResolve(string name, Type type);
    public abstract virtual bool CanResolve();
    public abstract virtual bool CanResolve(string name);
    public abstract virtual bool CanResolve(Type type);
    public abstract virtual bool CanResolve(string name, Type type);
}
public interface Intersoft.Crosslight.Containers.ILifetimeManager {
    public abstract virtual object GetInstance(IRegistration registration);
    public abstract virtual void InvalidateInstanceCache(IRegistration registration);
}
public class Intersoft.Crosslight.Containers.IocContainer : object {
    private aj a;
    private aj b;
    private static IocContainer c;
    private bool d;
    [CompilerGeneratedAttribute]
private ILifetimeManager e;
    private static string f;
    public ILifetimeManager DefaultLifetimeManager { get; public set; }
    public static IocContainer Current { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ILifetimeManager get_DefaultLifetimeManager();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DefaultLifetimeManager(ILifetimeManager value);
    public sealed virtual IContainerFluent UsesDefaultLifetimeManagerOf(ILifetimeManager lifetimeManager);
    public static IocContainer get_Current();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual IRegistration Register(Func`2<IDependencyResolver, TType> func);
    public sealed virtual IRegistration Register(string name, Func`2<IDependencyResolver, TType> func);
    public sealed virtual IRegistration Register(Type type, Func`2<IDependencyResolver, object> func);
    public sealed virtual IRegistration Register(string name, Type type, Func`2<IDependencyResolver, object> func);
    public sealed virtual IRegistration Register();
    public sealed virtual IRegistration Register(string name);
    public sealed virtual IRegistration Register(Type tType, Type tImpl);
    public sealed virtual IRegistration Register(string name, Type tType, Type tImpl);
    private IRegistration RegisterOpenType(string a, Type b, Type c);
    public sealed virtual IRegistration RegisterInstance(TType instance);
    public sealed virtual IRegistration RegisterInstance(string name, TType instance);
    public sealed virtual IRegistration RegisterInstance(Type type, object instance);
    public sealed virtual IRegistration RegisterInstance(string name, Type type, object instance);
    public sealed virtual void Remove(IRegistration ireg);
    public sealed virtual void Remove();
    public sealed virtual IRegistration GetRegistration();
    public sealed virtual IRegistration GetRegistration(string name);
    public sealed virtual IRegistration GetRegistration(Type type);
    public sealed virtual IRegistration GetRegistration(string name, Type type);
    public sealed virtual IRegistration GetSpecificRegistration(string name);
    public sealed virtual IEnumerable`1<IRegistration> GetRegistrations();
    public sealed virtual IEnumerable`1<IRegistration> GetRegistrations(Type type);
    public sealed virtual TType Resolve();
    public sealed virtual TType Resolve(string name);
    public sealed virtual object Resolve(Type type);
    public sealed virtual object Resolve(string name, Type type);
    private object HandleUnResolved(Exception a, string b, Type c);
    private object ResolveUsingOpenType(Exception a, string b, Type c);
    public sealed virtual bool CanResolve();
    public sealed virtual bool CanResolve(string name);
    public sealed virtual bool CanResolve(Type type);
    public sealed virtual bool CanResolve(string name, Type type);
    public sealed virtual IEnumerable`1<TType> ResolveAll();
    public sealed virtual IEnumerable`1<object> ResolveAll(Type type);
    public sealed virtual Func`1<TType> LazyResolve();
    public sealed virtual Func`1<TType> LazyResolve(string name);
    public sealed virtual Func`1<object> LazyResolve(Type type);
    public sealed virtual Func`1<object> LazyResolve(string name, Type type);
    private static string ResolveFailureMessage(Type a);
}
public interface Intersoft.Crosslight.Containers.IRegistration {
    public string Name { get; }
    public string Key { get; }
    public Type ResolvesTo { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Key();
    public abstract virtual Type get_ResolvesTo();
    public abstract virtual IRegistration WithLifetimeManager(ILifetimeManager manager);
    public abstract virtual void InvalidateInstanceCache();
    public abstract virtual object CreateInstance();
    public abstract virtual object GetInstance();
}
public class Intersoft.Crosslight.DataChangedEvent`1 : DelegateEvent`1<T> {
}
public class Intersoft.Crosslight.DataChangedEventArgs : EventArgs {
    private object a;
    private bool b;
    public object Item { get; }
    public bool IsRepositioned { get; }
    public DataChangedEventArgs(object item);
    public DataChangedEventArgs(object item, bool isRepositioned);
    public object get_Item();
    public bool get_IsRepositioned();
}
public class Intersoft.Crosslight.DataCollectionChangedEventArgs : EventArgs {
    private IEnumerable a;
    public IEnumerable Items { get; }
    public DataCollectionChangedEventArgs(IEnumerable items);
    public DataCollectionChangedEventArgs(object item);
    public IEnumerable get_Items();
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public class Intersoft.Crosslight.DataContractJsonSerializerStrategy : PocoJsonSerializerStrategy {
    internal virtual IDictionary`2<string, p> GetterValueFactory(Type a);
    internal virtual IDictionary`2<string, KeyValuePair`2<Type, b>> SetterValueFactory(Type a);
    private static bool CanAdd(MemberInfo a, String& b);
}
public class Intersoft.Crosslight.DataEventArgs`1 : EventArgs {
    private TData a;
    public TData Value { get; }
    public DataEventArgs`1(TData value);
    public TData get_Value();
}
public class Intersoft.Crosslight.DataInsertedEvent`1 : DelegateEvent`1<IEnumerable`1<T>> {
}
public class Intersoft.Crosslight.DataRemovedEvent`1 : DelegateEvent`1<IEnumerable`1<T>> {
}
public enum Intersoft.Crosslight.DateTimeInterval : Enum {
    public int value__;
    public static DateTimeInterval Second;
    public static DateTimeInterval Minute;
    public static DateTimeInterval Hour;
    public static DateTimeInterval Day;
    public static DateTimeInterval Week;
    public static DateTimeInterval Month;
    public static DateTimeInterval Year;
}
[AttributeUsageAttribute("128")]
public class Intersoft.Crosslight.DateTimeSerializationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DateTimeKind a;
    public DateTimeKind Mode { get; public set; }
    public DateTimeSerializationAttribute(DateTimeKind mode);
    [CompilerGeneratedAttribute]
public DateTimeKind get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(DateTimeKind value);
}
public class Intersoft.Crosslight.DelegateEvent`1 : DelegateEventBase {
    public SubscriptionToken Subscribe(Action`1<TPayload> action);
    public SubscriptionToken Subscribe(Action`1<TPayload> action, SubscribeOptions options);
    public virtual SubscriptionToken Subscribe(Action`1<TPayload> action, SubscribeOptions options, Predicate`1<TPayload> filter);
    public virtual void Publish(TPayload payload);
    public virtual void Unsubscribe(Action`1<TPayload> subscriber);
    public virtual bool Contains(Action`1<TPayload> subscriber);
}
public class Intersoft.Crosslight.DelegateEventBase : object {
    private List`1<IEventSubscription> a;
    protected ICollection`1<IEventSubscription> Subscriptions { get; }
    protected ICollection`1<IEventSubscription> get_Subscriptions();
    protected virtual SubscriptionToken InternalSubscribe(IEventSubscription eventSubscription);
    protected virtual void InternalPublish(Object[] arguments);
    public virtual void Unsubscribe(SubscriptionToken token);
    public virtual bool Contains(SubscriptionToken token);
    private List`1<Action`1<Object[]>> PruneAndReturnStrategies();
}
public class Intersoft.Crosslight.DelegateReference : object {
    private Delegate a;
    private WeakReference b;
    private MethodInfo c;
    private Type d;
    public Delegate Target { get; }
    public DelegateReference(Delegate delegate, bool keepReferenceAlive);
    public sealed virtual Delegate get_Target();
    private Delegate TryGetDelegate();
}
public class Intersoft.Crosslight.DeserializationContext : object {
    [CompilerGeneratedAttribute]
private object a;
    [CompilerGeneratedAttribute]
private object b;
    public object Instance { get; public set; }
    public object JsonObject { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public object get_JsonObject();
    [CompilerGeneratedAttribute]
public void set_JsonObject(object value);
}
public class Intersoft.Crosslight.DeviceInfo : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private DeviceKind b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    public string Name { get; internal set; }
    public DeviceKind Kind { get; internal set; }
    public string Model { get; internal set; }
    public string Manufacturer { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public DeviceKind get_Kind();
    [CompilerGeneratedAttribute]
internal void set_Kind(DeviceKind value);
    [CompilerGeneratedAttribute]
public string get_Model();
    [CompilerGeneratedAttribute]
internal void set_Model(string value);
    [CompilerGeneratedAttribute]
public string get_Manufacturer();
    [CompilerGeneratedAttribute]
internal void set_Manufacturer(string value);
}
public enum Intersoft.Crosslight.DeviceKind : Enum {
    public int value__;
    public static DeviceKind Phone;
    public static DeviceKind Tablet;
    public static DeviceKind Watch;
    public static DeviceKind TV;
    public static DeviceKind Desktop;
    public static DeviceKind Unknown;
}
public class Intersoft.Crosslight.DeviceToken : object {
    [CompilerGeneratedAttribute]
private OSKind a;
    [CompilerGeneratedAttribute]
private string b;
    public OSKind OperatingSystem { get; public set; }
    public string Token { get; public set; }
    [CompilerGeneratedAttribute]
public OSKind get_OperatingSystem();
    [CompilerGeneratedAttribute]
public void set_OperatingSystem(OSKind value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
}
[FlagsAttribute]
public enum Intersoft.Crosslight.DialogButton : Enum {
    public int value__;
    public static DialogButton Neutral;
    public static DialogButton Positive;
    public static DialogButton Negative;
}
public class Intersoft.Crosslight.DialogButtonStyle : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private Color b;
    [CompilerGeneratedAttribute]
private Color c;
    [CompilerGeneratedAttribute]
private bool d;
    public string Image { get; public set; }
    public Color ForegroundColor { get; public set; }
    public Color BackgroundColor { get; public set; }
    public bool Bold { get; public set; }
    public DialogButtonStyle(Color foregroundColor);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public Color get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(Color value);
    [CompilerGeneratedAttribute]
public Color get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Color value);
    [CompilerGeneratedAttribute]
public bool get_Bold();
    [CompilerGeneratedAttribute]
public void set_Bold(bool value);
}
public class Intersoft.Crosslight.DialogOptions : object {
    private DialogButtonStyle a;
    private DialogButtonStyle b;
    private DialogButtonStyle c;
    [CompilerGeneratedAttribute]
private DialogButton d;
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private string h;
    [CompilerGeneratedAttribute]
private string i;
    [CompilerGeneratedAttribute]
private string j;
    [CompilerGeneratedAttribute]
private object k;
    [CompilerGeneratedAttribute]
private bool l;
    public DialogButton Buttons { get; public set; }
    public bool HideButtons { get; public set; }
    public string NegativeButtonText { get; public set; }
    public string NeutralButtonText { get; public set; }
    public string PositiveButtonText { get; public set; }
    public string Title { get; public set; }
    public string Message { get; public set; }
    public object Sender { get; public set; }
    public bool ClosePreviousDialog { get; public set; }
    public DialogButtonStyle NegativeButtonStyle { get; public set; }
    public DialogButtonStyle NeutralButtonStyle { get; public set; }
    public DialogButtonStyle PositiveButtonStyle { get; public set; }
    public DialogOptions(string title);
    public DialogOptions(DialogButton buttons);
    public DialogOptions(string title, DialogButton buttons);
    [CompilerGeneratedAttribute]
public DialogButton get_Buttons();
    [CompilerGeneratedAttribute]
public void set_Buttons(DialogButton value);
    [CompilerGeneratedAttribute]
public bool get_HideButtons();
    [CompilerGeneratedAttribute]
public void set_HideButtons(bool value);
    [CompilerGeneratedAttribute]
public string get_NegativeButtonText();
    [CompilerGeneratedAttribute]
public void set_NegativeButtonText(string value);
    [CompilerGeneratedAttribute]
public string get_NeutralButtonText();
    [CompilerGeneratedAttribute]
public void set_NeutralButtonText(string value);
    [CompilerGeneratedAttribute]
public string get_PositiveButtonText();
    [CompilerGeneratedAttribute]
public void set_PositiveButtonText(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public object get_Sender();
    [CompilerGeneratedAttribute]
public void set_Sender(object value);
    [CompilerGeneratedAttribute]
public bool get_ClosePreviousDialog();
    [CompilerGeneratedAttribute]
public void set_ClosePreviousDialog(bool value);
    public DialogButtonStyle get_NegativeButtonStyle();
    public void set_NegativeButtonStyle(DialogButtonStyle value);
    public DialogButtonStyle get_NeutralButtonStyle();
    public void set_NeutralButtonStyle(DialogButtonStyle value);
    public DialogButtonStyle get_PositiveButtonStyle();
    public void set_PositiveButtonStyle(DialogButtonStyle value);
}
public class Intersoft.Crosslight.DialogResult : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private DialogButton b;
    [CompilerGeneratedAttribute]
private IViewModel c;
    [CompilerGeneratedAttribute]
private bool d;
    public bool IsDismissed { get; public set; }
    public DialogButton Button { get; public set; }
    public IViewModel ViewModel { get; public set; }
    public bool ShouldClose { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsDismissed();
    [CompilerGeneratedAttribute]
public void set_IsDismissed(bool value);
    [CompilerGeneratedAttribute]
public DialogButton get_Button();
    [CompilerGeneratedAttribute]
public void set_Button(DialogButton value);
    [CompilerGeneratedAttribute]
public IViewModel get_ViewModel();
    [CompilerGeneratedAttribute]
public void set_ViewModel(IViewModel value);
    [CompilerGeneratedAttribute]
public bool get_ShouldClose();
    [CompilerGeneratedAttribute]
public void set_ShouldClose(bool value);
}
public class Intersoft.Crosslight.DismissViewEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NavigationResult a;
    public NavigationResult Result { get; private set; }
    public DismissViewEventArgs(NavigationResult result);
    [CompilerGeneratedAttribute]
public NavigationResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(NavigationResult value);
}
public enum Intersoft.Crosslight.DrawerSide : Enum {
    public int value__;
    public static DrawerSide Left;
    public static DrawerSide Right;
}
public class Intersoft.Crosslight.Drawing.Color : ValueType {
    private a a;
    private bool b;
    public bool IsEmpty { get; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    internal static Color Create(object a);
    internal static char GetNumericListSeparator(IFormatProvider a);
    public static Color FromUInt32(UInt32 argb);
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromHex(string hex);
    public virtual string ToString();
    public bool get_IsEmpty();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string a, IFormatProvider b);
    internal string ConvertToString(string a, IFormatProvider b);
    public virtual int GetHashCode();
    internal UInt32 ToUInt32();
    public virtual bool Equals(object o);
    public bool Equals(Color color);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
}
public class Intersoft.Crosslight.Drawing.Colors : object {
    public static Color Black { get; }
    public static Color Blue { get; }
    public static Color Brown { get; }
    public static Color Cyan { get; }
    public static Color DarkGray { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color LightGray { get; }
    public static Color Magenta { get; }
    public static Color Orange { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color Transparent { get; }
    public static Color White { get; }
    public static Color Yellow { get; }
    public static Color get_Black();
    public static Color get_Blue();
    public static Color get_Brown();
    public static Color get_Cyan();
    public static Color get_DarkGray();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_LightGray();
    public static Color get_Magenta();
    public static Color get_Orange();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_Transparent();
    public static Color get_White();
    public static Color get_Yellow();
}
public enum Intersoft.Crosslight.EditAction : Enum {
    public int value__;
    public static EditAction Insert;
    public static EditAction Update;
    public static EditAction Delete;
    public static EditAction Select;
    public static EditAction Custom;
}
[r]
public class Intersoft.Crosslight.EditingParameter : object {
    [CompilerGeneratedAttribute]
private object a;
    [CompilerGeneratedAttribute]
private EditAction b;
    [CompilerGeneratedAttribute]
private int c;
    [CompilerGeneratedAttribute]
private int d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private bool f;
    public object Item { get; internal set; }
    public EditAction Action { get; internal set; }
    public int RowIndex { get; internal set; }
    public int SectionIndex { get; internal set; }
    public string CustomAction { get; internal set; }
    public bool ShouldEndEditing { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
internal void set_Item(object value);
    [CompilerGeneratedAttribute]
public EditAction get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(EditAction value);
    [CompilerGeneratedAttribute]
public int get_RowIndex();
    [CompilerGeneratedAttribute]
internal void set_RowIndex(int value);
    [CompilerGeneratedAttribute]
public int get_SectionIndex();
    [CompilerGeneratedAttribute]
internal void set_SectionIndex(int value);
    [CompilerGeneratedAttribute]
public string get_CustomAction();
    [CompilerGeneratedAttribute]
internal void set_CustomAction(string value);
    [CompilerGeneratedAttribute]
public bool get_ShouldEndEditing();
    [CompilerGeneratedAttribute]
public void set_ShouldEndEditing(bool value);
}
public enum Intersoft.Crosslight.EmailType : Enum {
    public int value__;
    public static EmailType Home;
    public static EmailType Work;
    public static EmailType Other;
}
public class Intersoft.Crosslight.EmptyLogger : object {
    private string a;
    public EmptyLogger(string name);
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, object data);
    public sealed virtual void Debug(object message, Dictionary`2<string, object> data);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] data);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] data);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, object data);
    public sealed virtual void Error(object message, Dictionary`2<string, object> data);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] data);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] data);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, object data);
    public sealed virtual void Fatal(object message, Dictionary`2<string, object> data);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] data);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] data);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, object data);
    public sealed virtual void Info(object message, Dictionary`2<string, object> data);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] data);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] data);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, object data);
    public sealed virtual void Warn(object message, Dictionary`2<string, object> data);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] data);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] data);
    public sealed virtual ITracer Trace(object message);
    public sealed virtual ITracer TraceFormat(string format, Object[] data);
    public sealed virtual ITracer TraceFormat(IFormatProvider formatProvider, string format, Object[] data);
    public TEventSource GetEventSource();
}
public class Intersoft.Crosslight.EmptyTracer : object {
    private string a;
    public EmptyTracer(string message);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ObservableCollection`1<T> ToObservable(IEnumerable`1<T> obj);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> obj, T value);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> obj, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void UpdateIndexPath(IEnumerable obj, object item);
    [ExtensionAttribute]
public static void UpdateIndexPath(IEnumerable obj);
    [ExtensionAttribute]
public static IndexPath GetIndexPath(IEnumerable obj, object item);
}
public class Intersoft.Crosslight.EventAggregator : object {
    private static EventAggregator a;
    private Dictionary`2<Type, DelegateEventBase> b;
    public static EventAggregator Default { get; }
    public static EventAggregator get_Default();
    public sealed virtual TEventType GetEvent();
    public sealed virtual SubscriptionToken Subscribe(Action`1<TPayload> action);
    public SubscriptionToken Subscribe(Action`1<TPayload> action, SubscribeOptions options);
    public SubscriptionToken Subscribe(Action`1<TPayload> action, SubscribeOptions options, Predicate`1<TPayload> filter);
    public sealed virtual void Publish(TPayload payload);
    public sealed virtual void Unsubscribe(Action`1<TPayload> action);
}
public class Intersoft.Crosslight.EventSource : object {
    [CompilerGeneratedAttribute]
private string a;
    protected string Category { get; protected set; }
    public ILog Logger { get; }
    public EventSource(Type type);
    [CompilerGeneratedAttribute]
protected virtual string get_Category();
    [CompilerGeneratedAttribute]
protected virtual void set_Category(string value);
    public virtual ILog get_Logger();
}
public class Intersoft.Crosslight.EventSource`1 : EventSource {
    public EventSource`1(Type type);
}
public class Intersoft.Crosslight.EventSubscription`1 : object {
    private IDelegateReference a;
    private IDelegateReference b;
    [CompilerGeneratedAttribute]
private SubscriptionToken c;
    public Action`1<TPayload> Action { get; }
    public Predicate`1<TPayload> Filter { get; }
    public SubscriptionToken SubscriptionID { get; public set; }
    public EventSubscription`1(IDelegateReference actionReference, IDelegateReference filterReference);
    public Action`1<TPayload> get_Action();
    public Predicate`1<TPayload> get_Filter();
    [CompilerGeneratedAttribute]
public sealed virtual SubscriptionToken get_SubscriptionID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionID(SubscriptionToken value);
    private sealed virtual override Action`1<Object[]> Intersoft.Crosslight.IEventSubscription.GetExecutionStrategy();
    public virtual void InvokeAction(Action`1<TPayload> action, TPayload argument);
}
public enum Intersoft.Crosslight.FileWriteMode : Enum {
    public int value__;
    public static FileWriteMode Overwrite;
    public static FileWriteMode Append;
}
public enum Intersoft.Crosslight.Forms.AutoCorrectionType : Enum {
    public int value__;
    public static AutoCorrectionType System;
    public static AutoCorrectionType Yes;
    public static AutoCorrectionType No;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.BindableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private BindingDirection b;
    public bool IsBindable { get; private set; }
    public BindingDirection Direction { get; private set; }
    public BindableAttribute(bool bindable);
    public BindableAttribute(bool bindable, BindingDirection bindingDirection);
    [CompilerGeneratedAttribute]
public bool get_IsBindable();
    [CompilerGeneratedAttribute]
private void set_IsBindable(bool value);
    [CompilerGeneratedAttribute]
public BindingDirection get_Direction();
    [CompilerGeneratedAttribute]
private void set_Direction(BindingDirection value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.BindingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private BindingSourceType b;
    [CompilerGeneratedAttribute]
private BindingMode c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private UpdateSourceTrigger g;
    [CompilerGeneratedAttribute]
private Type h;
    [CompilerGeneratedAttribute]
private string i;
    [CompilerGeneratedAttribute]
private object j;
    [CompilerGeneratedAttribute]
private object k;
    protected FormBindableProperty TargetProperty { get; }
    public string CustomTargetProperty { get; public set; }
    public BindingSourceType SourceType { get; public set; }
    public BindingMode Mode { get; public set; }
    public string Path { get; public set; }
    public string StringFormat { get; public set; }
    public string TargetName { get; internal set; }
    public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    public Type ConverterType { get; public set; }
    public string ConverterCulture { get; public set; }
    public object ConverterParameter { get; public set; }
    public object InitialValue { get; public set; }
    protected virtual FormBindableProperty get_TargetProperty();
    [CompilerGeneratedAttribute]
public string get_CustomTargetProperty();
    [CompilerGeneratedAttribute]
public void set_CustomTargetProperty(string value);
    [CompilerGeneratedAttribute]
public BindingSourceType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(BindingSourceType value);
    [CompilerGeneratedAttribute]
public BindingMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(BindingMode value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_StringFormat();
    [CompilerGeneratedAttribute]
public void set_StringFormat(string value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
internal void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public UpdateSourceTrigger get_UpdateSourceTrigger();
    [CompilerGeneratedAttribute]
public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public void set_ConverterType(Type value);
    [CompilerGeneratedAttribute]
public string get_ConverterCulture();
    [CompilerGeneratedAttribute]
public void set_ConverterCulture(string value);
    [CompilerGeneratedAttribute]
public object get_ConverterParameter();
    [CompilerGeneratedAttribute]
public void set_ConverterParameter(object value);
    [CompilerGeneratedAttribute]
public object get_InitialValue();
    [CompilerGeneratedAttribute]
public void set_InitialValue(object value);
    public BindingDescription ToBindingDescription(object source);
}
public enum Intersoft.Crosslight.Forms.BindingDirection : Enum {
    public int value__;
    public static BindingDirection OneWay;
    public static BindingDirection TwoWay;
}
public enum Intersoft.Crosslight.Forms.BindingSourceType : Enum {
    public int value__;
    public static BindingSourceType Model;
    public static BindingSourceType ViewModel;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.ButtonAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private ButtonStyle c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private float h;
    [CompilerGeneratedAttribute]
private float i;
    [CompilerGeneratedAttribute]
private TintColorMode j;
    [CompilerGeneratedAttribute]
private object k;
    public string Title { get; public set; }
    public string TitleKey { get; public set; }
    public ButtonStyle Style { get; public set; }
    public string BackgroundImage { get; public set; }
    public string BackgroundColor { get; public set; }
    public string TextColor { get; public set; }
    public string TextShadow { get; public set; }
    public float TopMargin { get; public set; }
    public float BottomMargin { get; public set; }
    public TintColorMode TintColorMode { get; public set; }
    public object Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_TitleKey();
    [CompilerGeneratedAttribute]
public void set_TitleKey(string value);
    [CompilerGeneratedAttribute]
public ButtonStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ButtonStyle value);
    [CompilerGeneratedAttribute]
public string get_BackgroundImage();
    [CompilerGeneratedAttribute]
public void set_BackgroundImage(string value);
    [CompilerGeneratedAttribute]
public string get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(string value);
    [CompilerGeneratedAttribute]
public string get_TextColor();
    [CompilerGeneratedAttribute]
public void set_TextColor(string value);
    [CompilerGeneratedAttribute]
public string get_TextShadow();
    [CompilerGeneratedAttribute]
public void set_TextShadow(string value);
    [CompilerGeneratedAttribute]
public float get_TopMargin();
    [CompilerGeneratedAttribute]
public void set_TopMargin(float value);
    [CompilerGeneratedAttribute]
public float get_BottomMargin();
    [CompilerGeneratedAttribute]
public void set_BottomMargin(float value);
    [CompilerGeneratedAttribute]
public TintColorMode get_TintColorMode();
    [CompilerGeneratedAttribute]
public void set_TintColorMode(TintColorMode value);
    [CompilerGeneratedAttribute]
public object get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(object value);
}
public enum Intersoft.Crosslight.Forms.ButtonStyle : Enum {
    public int value__;
    public static ButtonStyle Simple;
    public static ButtonStyle Image;
}
public enum Intersoft.Crosslight.Forms.ClearButtonVisibility : Enum {
    public int value__;
    public static ClearButtonVisibility Never;
    public static ClearButtonVisibility WhileEditing;
    public static ClearButtonVisibility UnlessEditing;
    public static ClearButtonVisibility Always;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.CommandActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private object b;
    public string Command { get; public set; }
    public object Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public object get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(object value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.CommandBindingAttribute : BindingAttribute {
    [CompilerGeneratedAttribute]
private object m;
    protected FormBindableProperty TargetProperty { get; }
    public object Parameter { get; public set; }
    protected virtual FormBindableProperty get_TargetProperty();
    [CompilerGeneratedAttribute]
public object get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(object value);
}
public abstract class Intersoft.Crosslight.Forms.ComponentDefinitionBase : object {
    [CompilerGeneratedAttribute]
private Attribute[] a;
    [CompilerGeneratedAttribute]
private Type b;
    public Attribute[] Attributes { get; internal set; }
    public Type MetadataType { get; internal set; }
    [CompilerGeneratedAttribute]
public Attribute[] get_Attributes();
    [CompilerGeneratedAttribute]
internal void set_Attributes(Attribute[] value);
    [CompilerGeneratedAttribute]
public Type get_MetadataType();
    [CompilerGeneratedAttribute]
internal void set_MetadataType(Type value);
    public T GetAttribute();
    public void AddAttributes(Attribute[] attribute);
}
public abstract class Intersoft.Crosslight.Forms.ContentControlAttribute : Attribute {
    [CompilerGeneratedAttribute]
private float a;
    [CompilerGeneratedAttribute]
private float b;
    [CompilerGeneratedAttribute]
private float c;
    [CompilerGeneratedAttribute]
private ControlHorizontalAlignment d;
    [CompilerGeneratedAttribute]
private ControlVerticalAlignment e;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public float Padding { get; public set; }
    public ControlHorizontalAlignment HorizontalAlignment { get; public set; }
    public ControlVerticalAlignment VerticalAlignment { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    [CompilerGeneratedAttribute]
public float get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(float value);
    [CompilerGeneratedAttribute]
public ControlHorizontalAlignment get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(ControlHorizontalAlignment value);
    [CompilerGeneratedAttribute]
public ControlVerticalAlignment get_VerticalAlignment();
    [CompilerGeneratedAttribute]
public void set_VerticalAlignment(ControlVerticalAlignment value);
}
public enum Intersoft.Crosslight.Forms.ControlHorizontalAlignment : Enum {
    public int value__;
    public static ControlHorizontalAlignment Auto;
    public static ControlHorizontalAlignment Left;
    public static ControlHorizontalAlignment Center;
    public static ControlHorizontalAlignment Right;
}
public enum Intersoft.Crosslight.Forms.ControlVerticalAlignment : Enum {
    public int value__;
    public static ControlVerticalAlignment Auto;
    public static ControlVerticalAlignment Top;
    public static ControlVerticalAlignment Middle;
    public static ControlVerticalAlignment Bottom;
}
public enum Intersoft.Crosslight.Forms.CustomEditorSource : Enum {
    public int value__;
    public static CustomEditorSource ViewResource;
    public static CustomEditorSource ViewBuilder;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.DataViewAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    public string ItemsMemberPath { get; public set; }
    public string DisplayMemberPath { get; public set; }
    public string DetailMemberPath { get; public set; }
    public string ImageMemberPath { get; public set; }
    public string NavigateMemberPath { get; public set; }
    public string ValueMemberPath { get; public set; }
    public string ImagePlaceholder { get; public set; }
    public DataViewAttribute(string displayMemberPath);
    [CompilerGeneratedAttribute]
public string get_ItemsMemberPath();
    [CompilerGeneratedAttribute]
public void set_ItemsMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayMemberPath();
    [CompilerGeneratedAttribute]
public void set_DisplayMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_DetailMemberPath();
    [CompilerGeneratedAttribute]
public void set_DetailMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImageMemberPath();
    [CompilerGeneratedAttribute]
public void set_ImageMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_NavigateMemberPath();
    [CompilerGeneratedAttribute]
public void set_NavigateMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ValueMemberPath();
    [CompilerGeneratedAttribute]
public void set_ValueMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImagePlaceholder();
    [CompilerGeneratedAttribute]
public void set_ImagePlaceholder(string value);
}
public enum Intersoft.Crosslight.Forms.DateInputMode : Enum {
    public int value__;
    public static DateInputMode Date;
    public static DateInputMode DateAndTime;
    public static DateInputMode Time;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.DisplayAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private int f;
    public string Caption { get; public set; }
    public string CaptionKey { get; public set; }
    public string Image { get; public set; }
    public string NullValueText { get; public set; }
    public string NullValueTextKey { get; public set; }
    public int MaxNumberOfLines { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public string get_CaptionKey();
    [CompilerGeneratedAttribute]
public void set_CaptionKey(string value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public string get_NullValueText();
    [CompilerGeneratedAttribute]
public void set_NullValueText(string value);
    [CompilerGeneratedAttribute]
public string get_NullValueTextKey();
    [CompilerGeneratedAttribute]
public void set_NullValueTextKey(string value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfLines();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfLines(int value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.EditableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool a;
    public bool AllowEdit { get; private set; }
    public EditableAttribute(bool editable);
    [CompilerGeneratedAttribute]
public bool get_AllowEdit();
    [CompilerGeneratedAttribute]
private void set_AllowEdit(bool value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.EditorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EditorType a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private CustomEditorSource c;
    [CompilerGeneratedAttribute]
private bool d;
    public EditorType EditorType { get; private set; }
    public string CustomEditorIdentifier { get; public set; }
    public CustomEditorSource CustomEditorSource { get; public set; }
    public bool IsEnabled { get; public set; }
    public EditorAttribute(EditorType editorType);
    [CompilerGeneratedAttribute]
public EditorType get_EditorType();
    [CompilerGeneratedAttribute]
private void set_EditorType(EditorType value);
    [CompilerGeneratedAttribute]
public string get_CustomEditorIdentifier();
    [CompilerGeneratedAttribute]
public void set_CustomEditorIdentifier(string value);
    [CompilerGeneratedAttribute]
public CustomEditorSource get_CustomEditorSource();
    [CompilerGeneratedAttribute]
public void set_CustomEditorSource(CustomEditorSource value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
}
public enum Intersoft.Crosslight.Forms.EditorType : Enum {
    public int value__;
    public static EditorType AutoDetect;
    public static EditorType Button;
    public static EditorType Checkbox;
    public static EditorType Radio;
    public static EditorType Label;
    public static EditorType TextField;
    public static EditorType TextView;
    public static EditorType PasswordField;
    public static EditorType NumericTextField;
    public static EditorType NumericStepper;
    public static EditorType Slider;
    public static EditorType Segmented;
    public static EditorType Switch;
    public static EditorType Date;
    public static EditorType DateTime;
    public static EditorType Time;
    public static EditorType Image;
    public static EditorType Selection;
    public static EditorType Picker;
    public static EditorType Hyperlink;
    public static EditorType Navigation;
    public static EditorType Custom;
    public static EditorType ListView;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.EnabledBindingAttribute : BindingAttribute {
    protected FormBindableProperty TargetProperty { get; }
    protected virtual FormBindableProperty get_TargetProperty();
}
public class Intersoft.Crosslight.Forms.FormAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private bool e;
    public string Title { get; public set; }
    public string TitleKey { get; public set; }
    public string SaveCommand { get; public set; }
    public string CancelCommand { get; public set; }
    public bool DisableFirstLoadAnimation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_TitleKey();
    [CompilerGeneratedAttribute]
public void set_TitleKey(string value);
    [CompilerGeneratedAttribute]
public string get_SaveCommand();
    [CompilerGeneratedAttribute]
public void set_SaveCommand(string value);
    [CompilerGeneratedAttribute]
public string get_CancelCommand();
    [CompilerGeneratedAttribute]
public void set_CancelCommand(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableFirstLoadAnimation();
    [CompilerGeneratedAttribute]
public void set_DisableFirstLoadAnimation(bool value);
}
public enum Intersoft.Crosslight.Forms.FormBindableProperty : Enum {
    public int value__;
    public static FormBindableProperty IsVisible;
    public static FormBindableProperty IsEnabled;
    public static FormBindableProperty Command;
    public static FormBindableProperty Value;
    public static FormBindableProperty SelectedItem;
    public static FormBindableProperty SelectedItems;
    public static FormBindableProperty SelectedValue;
    public static FormBindableProperty Custom;
}
public class Intersoft.Crosslight.Forms.FormDefinition : ComponentDefinitionBase {
    [CompilerGeneratedAttribute]
private List`1<SectionDefinition> c;
    public static string ViewPrefix;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private IContainerView h;
    public List`1<SectionDefinition> Sections { get; private set; }
    public string Title { get; public set; }
    public string TitleKey { get; public set; }
    public string SaveCommand { get; public set; }
    public string CancelCommand { get; public set; }
    public IContainerView View { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<SectionDefinition> get_Sections();
    [CompilerGeneratedAttribute]
private void set_Sections(List`1<SectionDefinition> value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_TitleKey();
    [CompilerGeneratedAttribute]
public void set_TitleKey(string value);
    [CompilerGeneratedAttribute]
public string get_SaveCommand();
    [CompilerGeneratedAttribute]
public void set_SaveCommand(string value);
    [CompilerGeneratedAttribute]
public string get_CancelCommand();
    [CompilerGeneratedAttribute]
public void set_CancelCommand(string value);
    [CompilerGeneratedAttribute]
public IContainerView get_View();
    [CompilerGeneratedAttribute]
public void set_View(IContainerView value);
    public static Type GetMetadataType(IViewModel viewModel);
    public static Type GetMetadataType(Type viewModelType);
    public static FormDefinition CreateFrom(Type type);
    private static PropertyDefinition[] GenerateProperties(SectionDefinition a);
    private static PropertyDefinition GenerateProperty(SectionDefinition a, MemberInfo b);
    public static bool IsNumericType(Type type);
    public BindingAttribute[] GetBindings();
    public PropertyDefinition[] GetProperties();
    public PropertyDefinition GetProperty(string propertyName);
    public IComponentView[] GetViews();
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.Forms.FormMetadataTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type a;
    public Type MetadataType { get; private set; }
    public FormMetadataTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_MetadataType();
    [CompilerGeneratedAttribute]
private void set_MetadataType(Type value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.ImageAttribute : ContentControlAttribute {
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private float h;
    [CompilerGeneratedAttribute]
private float i;
    [CompilerGeneratedAttribute]
private string j;
    [CompilerGeneratedAttribute]
private string k;
    [CompilerGeneratedAttribute]
private string l;
    [CompilerGeneratedAttribute]
private string m;
    [CompilerGeneratedAttribute]
private bool n;
    [CompilerGeneratedAttribute]
private ImageScaleMode o;
    public string Placeholder { get; public set; }
    public string Frame { get; public set; }
    public float FramePadding { get; public set; }
    public float FrameShadowHeight { get; public set; }
    public string EditCaption { get; public set; }
    public string EditCaptionKey { get; public set; }
    public string AddCaption { get; public set; }
    public string AddCaptionKey { get; public set; }
    public bool UseCircleMask { get; public set; }
    public ImageScaleMode ScaleMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Placeholder();
    [CompilerGeneratedAttribute]
public void set_Placeholder(string value);
    [CompilerGeneratedAttribute]
public string get_Frame();
    [CompilerGeneratedAttribute]
public void set_Frame(string value);
    [CompilerGeneratedAttribute]
public float get_FramePadding();
    [CompilerGeneratedAttribute]
public void set_FramePadding(float value);
    [CompilerGeneratedAttribute]
public float get_FrameShadowHeight();
    [CompilerGeneratedAttribute]
public void set_FrameShadowHeight(float value);
    [CompilerGeneratedAttribute]
public string get_EditCaption();
    [CompilerGeneratedAttribute]
public void set_EditCaption(string value);
    [CompilerGeneratedAttribute]
public string get_EditCaptionKey();
    [CompilerGeneratedAttribute]
public void set_EditCaptionKey(string value);
    [CompilerGeneratedAttribute]
public string get_AddCaption();
    [CompilerGeneratedAttribute]
public void set_AddCaption(string value);
    [CompilerGeneratedAttribute]
public string get_AddCaptionKey();
    [CompilerGeneratedAttribute]
public void set_AddCaptionKey(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCircleMask();
    [CompilerGeneratedAttribute]
public void set_UseCircleMask(bool value);
    [CompilerGeneratedAttribute]
public ImageScaleMode get_ScaleMode();
    [CompilerGeneratedAttribute]
public void set_ScaleMode(ImageScaleMode value);
}
public class Intersoft.Crosslight.Forms.ImagePickerActivateParameter : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ICommand> a;
    [CompilerGeneratedAttribute]
private bool b;
    public Dictionary`2<string, ICommand> CustomCommands { get; public set; }
    public bool UseDefaultPicker { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ICommand> get_CustomCommands();
    [CompilerGeneratedAttribute]
public void set_CustomCommands(Dictionary`2<string, ICommand> value);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultPicker();
    [CompilerGeneratedAttribute]
public void set_UseDefaultPicker(bool value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.ImagePickerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private bool d;
    [CompilerGeneratedAttribute]
private int e;
    [CompilerGeneratedAttribute]
private int f;
    [CompilerGeneratedAttribute]
private ImageResultMode g;
    public bool AllowEditing { get; public set; }
    public string ActivateCommand { get; public set; }
    public string PickerResultCommand { get; public set; }
    public bool UseThumbnailResult { get; public set; }
    public int ThumbnailWidth { get; public set; }
    public int ThumbnailHeight { get; public set; }
    public ImageResultMode ImageResultMode { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowEditing();
    [CompilerGeneratedAttribute]
public void set_AllowEditing(bool value);
    [CompilerGeneratedAttribute]
public string get_ActivateCommand();
    [CompilerGeneratedAttribute]
public void set_ActivateCommand(string value);
    [CompilerGeneratedAttribute]
public string get_PickerResultCommand();
    [CompilerGeneratedAttribute]
public void set_PickerResultCommand(string value);
    [CompilerGeneratedAttribute]
public bool get_UseThumbnailResult();
    [CompilerGeneratedAttribute]
public void set_UseThumbnailResult(bool value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailWidth();
    [CompilerGeneratedAttribute]
public void set_ThumbnailWidth(int value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailHeight();
    [CompilerGeneratedAttribute]
public void set_ThumbnailHeight(int value);
    [CompilerGeneratedAttribute]
public ImageResultMode get_ImageResultMode();
    [CompilerGeneratedAttribute]
public void set_ImageResultMode(ImageResultMode value);
}
public class Intersoft.Crosslight.Forms.ImagePickerResultParameter : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private MediaPickerResult b;
    public string SelectedCommandId { get; public set; }
    public MediaPickerResult Result { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SelectedCommandId();
    [CompilerGeneratedAttribute]
public void set_SelectedCommandId(string value);
    [CompilerGeneratedAttribute]
public MediaPickerResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(MediaPickerResult value);
}
public enum Intersoft.Crosslight.Forms.ImageScaleMode : Enum {
    public int value__;
    public static ImageScaleMode None;
    public static ImageScaleMode ScaleAspectFit;
    public static ImageScaleMode ScaleAspectFill;
}
public enum Intersoft.Crosslight.Forms.InputType : Enum {
    public int value__;
    public static InputType Auto;
    public static InputType Url;
    public static InputType EmailAddress;
    public static InputType DecimalPad;
    public static InputType NamePhonePad;
    public static InputType NumberPad;
    public static InputType NumbersAndPunctuation;
    public static InputType PhonePad;
    public static InputType Twitter;
}
public enum Intersoft.Crosslight.Forms.LayoutAlignment : Enum {
    public int value__;
    public static LayoutAlignment Auto;
    public static LayoutAlignment Left;
    public static LayoutAlignment Right;
    public static LayoutAlignment Center;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.LayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private float a;
    [CompilerGeneratedAttribute]
private float b;
    [CompilerGeneratedAttribute]
private float c;
    [CompilerGeneratedAttribute]
private float d;
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private LayoutStyle f;
    [CompilerGeneratedAttribute]
private LayoutAlignment g;
    [CompilerGeneratedAttribute]
private LayoutAlignment h;
    [CompilerGeneratedAttribute]
private float i;
    public float Width { get; public set; }
    public float MinHeight { get; public set; }
    public float MaxHeight { get; public set; }
    public float Height { get; public set; }
    public bool AutoAlignTextField { get; public set; }
    public LayoutStyle Style { get; public set; }
    public LayoutAlignment LabelAlignment { get; public set; }
    public LayoutAlignment DetailAlignment { get; public set; }
    public float RowDetailSpacing { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [CompilerGeneratedAttribute]
public float get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(float value);
    [CompilerGeneratedAttribute]
public float get_MaxHeight();
    [CompilerGeneratedAttribute]
public void set_MaxHeight(float value);
    [CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    [CompilerGeneratedAttribute]
public bool get_AutoAlignTextField();
    [CompilerGeneratedAttribute]
public void set_AutoAlignTextField(bool value);
    [CompilerGeneratedAttribute]
public LayoutStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(LayoutStyle value);
    [CompilerGeneratedAttribute]
public LayoutAlignment get_LabelAlignment();
    [CompilerGeneratedAttribute]
public void set_LabelAlignment(LayoutAlignment value);
    [CompilerGeneratedAttribute]
public LayoutAlignment get_DetailAlignment();
    [CompilerGeneratedAttribute]
public void set_DetailAlignment(LayoutAlignment value);
    [CompilerGeneratedAttribute]
public float get_RowDetailSpacing();
    [CompilerGeneratedAttribute]
public void set_RowDetailSpacing(float value);
}
public enum Intersoft.Crosslight.Forms.LayoutStyle : Enum {
    public int value__;
    public static LayoutStyle Default;
    public static LayoutStyle RightDetail;
    public static LayoutStyle LeftDetail;
    public static LayoutStyle RowDetail;
    public static LayoutStyle DetailOnly;
    public static LayoutStyle Composite;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.ListViewAttribute : DataViewAttribute {
    [CompilerGeneratedAttribute]
private ListViewInteractionMode h;
    [CompilerGeneratedAttribute]
private ListViewCellStyle i;
    [CompilerGeneratedAttribute]
private Type j;
    public ListViewInteractionMode InteractionMode { get; public set; }
    public ListViewCellStyle Style { get; public set; }
    public Type ViewModelType { get; public set; }
    public ListViewAttribute(string displayMemberPath);
    public ListViewAttribute(ListViewCellStyle style, string displayMemberPath);
    [CompilerGeneratedAttribute]
public ListViewInteractionMode get_InteractionMode();
    [CompilerGeneratedAttribute]
public void set_InteractionMode(ListViewInteractionMode value);
    [CompilerGeneratedAttribute]
public ListViewCellStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ListViewCellStyle value);
    [CompilerGeneratedAttribute]
public Type get_ViewModelType();
    [CompilerGeneratedAttribute]
public void set_ViewModelType(Type value);
}
public enum Intersoft.Crosslight.Forms.ListViewCellStyle : Enum {
    public int value__;
    public static ListViewCellStyle Default;
    public static ListViewCellStyle RightDetail;
    public static ListViewCellStyle LeftDetail;
    public static ListViewCellStyle Subtitle;
}
public enum Intersoft.Crosslight.Forms.ListViewInteractionMode : Enum {
    public int value__;
    public static ListViewInteractionMode None;
    public static ListViewInteractionMode SelectionInput;
    public static ListViewInteractionMode Navigation;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.NavigateActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private NavigationTargetKind c;
    [CompilerGeneratedAttribute]
private NavigationMode d;
    [CompilerGeneratedAttribute]
private string e;
    public Type TargetType { get; public set; }
    public string TargetNavigationIdentifier { get; public set; }
    public NavigationTargetKind NavigationTargetKind { get; public set; }
    public NavigationMode NavigationMode { get; public set; }
    public string ExtendedProperties { get; public set; }
    public NavigateActionAttribute(Type targetType);
    public NavigateActionAttribute(Type targetType, string navigationIdentifier);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetNavigationIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetNavigationIdentifier(string value);
    [CompilerGeneratedAttribute]
public NavigationTargetKind get_NavigationTargetKind();
    [CompilerGeneratedAttribute]
public void set_NavigationTargetKind(NavigationTargetKind value);
    [CompilerGeneratedAttribute]
public NavigationMode get_NavigationMode();
    [CompilerGeneratedAttribute]
public void set_NavigationMode(NavigationMode value);
    [CompilerGeneratedAttribute]
public string get_ExtendedProperties();
    [CompilerGeneratedAttribute]
public void set_ExtendedProperties(string value);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.NumericStepperMaxValueBindingAttribute : BindingAttribute {
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.PickerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PickerStyle a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    public PickerStyle Style { get; public set; }
    public string Caption { get; public set; }
    public string CaptionKey { get; public set; }
    [CompilerGeneratedAttribute]
public PickerStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(PickerStyle value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public string get_CaptionKey();
    [CompilerGeneratedAttribute]
public void set_CaptionKey(string value);
}
public enum Intersoft.Crosslight.Forms.PickerStyle : Enum {
    public int value__;
    public static PickerStyle Inline;
    public static PickerStyle Modal;
}
public class Intersoft.Crosslight.Forms.PropertyDefinition : ComponentDefinitionBase {
    [CompilerGeneratedAttribute]
private bool t;
    [CompilerGeneratedAttribute]
private string u;
    [CompilerGeneratedAttribute]
private string v;
    [CompilerGeneratedAttribute]
private Type w;
    [CompilerGeneratedAttribute]
private FormDefinition i;
    [CompilerGeneratedAttribute]
private SectionDefinition x;
    [CompilerGeneratedAttribute]
private EditorType y;
    [CompilerGeneratedAttribute]
private string z;
    [CompilerGeneratedAttribute]
private CustomEditorSource aa;
    [CompilerGeneratedAttribute]
private IComponentView h;
    [CompilerGeneratedAttribute]
private bool q;
    [CompilerGeneratedAttribute]
private bool r;
    [CompilerGeneratedAttribute]
private string ab;
    [CompilerGeneratedAttribute]
private string ac;
    [CompilerGeneratedAttribute]
private string ad;
    [CompilerGeneratedAttribute]
private object ae;
    [CompilerGeneratedAttribute]
private float af;
    [CompilerGeneratedAttribute]
private float ag;
    [CompilerGeneratedAttribute]
private float ah;
    [CompilerGeneratedAttribute]
private LayoutStyle n;
    [CompilerGeneratedAttribute]
private LayoutAlignment ai;
    [CompilerGeneratedAttribute]
private LayoutAlignment aj;
    [CompilerGeneratedAttribute]
private List`1<PropertyDefinition> s;
    public bool IsCompositeProperty { get; private set; }
    public string PropertyPath { get; public set; }
    public string PropertyName { get; public set; }
    public Type PropertyType { get; public set; }
    public FormDefinition Form { get; internal set; }
    public SectionDefinition Section { get; internal set; }
    public EditorType EditorType { get; public set; }
    public string CustomEditorIdentifier { get; public set; }
    public CustomEditorSource CustomEditorSource { get; public set; }
    public IComponentView View { get; public set; }
    public bool IsVisible { get; public set; }
    public bool IsEnabled { get; public set; }
    public string Caption { get; public set; }
    public string CaptionKey { get; public set; }
    public string Image { get; public set; }
    public object InitialValue { get; public set; }
    public float Height { get; public set; }
    public float MinHeight { get; public set; }
    public float MaxHeight { get; public set; }
    public LayoutStyle Style { get; public set; }
    public LayoutAlignment LabelAlignment { get; public set; }
    public LayoutAlignment DetailAlignment { get; public set; }
    public List`1<PropertyDefinition> Properties { get; private set; }
    public PropertyDefinition(SectionDefinition section, PropertyDefinition[] subProperties);
    [CompilerGeneratedAttribute]
public bool get_IsCompositeProperty();
    [CompilerGeneratedAttribute]
private void set_IsCompositeProperty(bool value);
    [CompilerGeneratedAttribute]
public string get_PropertyPath();
    [CompilerGeneratedAttribute]
public void set_PropertyPath(string value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public FormDefinition get_Form();
    [CompilerGeneratedAttribute]
internal void set_Form(FormDefinition value);
    [CompilerGeneratedAttribute]
public SectionDefinition get_Section();
    [CompilerGeneratedAttribute]
internal void set_Section(SectionDefinition value);
    [CompilerGeneratedAttribute]
public EditorType get_EditorType();
    [CompilerGeneratedAttribute]
public void set_EditorType(EditorType value);
    [CompilerGeneratedAttribute]
public string get_CustomEditorIdentifier();
    [CompilerGeneratedAttribute]
public void set_CustomEditorIdentifier(string value);
    [CompilerGeneratedAttribute]
public CustomEditorSource get_CustomEditorSource();
    [CompilerGeneratedAttribute]
public void set_CustomEditorSource(CustomEditorSource value);
    [CompilerGeneratedAttribute]
public IComponentView get_View();
    [CompilerGeneratedAttribute]
public void set_View(IComponentView value);
    [CompilerGeneratedAttribute]
public bool get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public string get_CaptionKey();
    [CompilerGeneratedAttribute]
public void set_CaptionKey(string value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public object get_InitialValue();
    [CompilerGeneratedAttribute]
public void set_InitialValue(object value);
    [CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    [CompilerGeneratedAttribute]
public float get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(float value);
    [CompilerGeneratedAttribute]
public float get_MaxHeight();
    [CompilerGeneratedAttribute]
public void set_MaxHeight(float value);
    [CompilerGeneratedAttribute]
public LayoutStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(LayoutStyle value);
    [CompilerGeneratedAttribute]
public LayoutAlignment get_LabelAlignment();
    [CompilerGeneratedAttribute]
public void set_LabelAlignment(LayoutAlignment value);
    [CompilerGeneratedAttribute]
public LayoutAlignment get_DetailAlignment();
    [CompilerGeneratedAttribute]
public void set_DetailAlignment(LayoutAlignment value);
    [CompilerGeneratedAttribute]
public List`1<PropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(List`1<PropertyDefinition> value);
    public PropertyDefinition GetNextProperty();
    public PropertyDefinition GetNextVisibleProperty();
    public IndexPath GetIndexPath();
    public IndexPath GetVisibleIndexPath();
    [CompilerGeneratedAttribute]
private bool <GetVisibleIndexPath>b__97_0(SectionDefinition a);
    [CompilerGeneratedAttribute]
private bool <GetVisibleIndexPath>b__97_1(PropertyDefinition a);
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.RangeInputAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object a;
    [CompilerGeneratedAttribute]
private object b;
    public object MinValue { get; public set; }
    public object MaxValue { get; public set; }
    [CompilerGeneratedAttribute]
public object get_MinValue();
    [CompilerGeneratedAttribute]
public void set_MinValue(object value);
    [CompilerGeneratedAttribute]
public object get_MaxValue();
    [CompilerGeneratedAttribute]
public void set_MaxValue(object value);
}
public enum Intersoft.Crosslight.Forms.ReturnKeyType : Enum {
    public int value__;
    public static ReturnKeyType Default;
    public static ReturnKeyType Go;
    public static ReturnKeyType Google;
    public static ReturnKeyType Join;
    public static ReturnKeyType Next;
    public static ReturnKeyType Route;
    public static ReturnKeyType Search;
    public static ReturnKeyType Send;
    public static ReturnKeyType Done;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.SectionAttribute : Attribute {
    public static int DefaultLabelWidth;
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private SectionLayoutStyle e;
    [CompilerGeneratedAttribute]
private float f;
    public string Header { get; public set; }
    public string HeaderKey { get; public set; }
    public string Footer { get; public set; }
    public string FooterKey { get; public set; }
    public SectionLayoutStyle Style { get; public set; }
    public float LabelWidth { get; public set; }
    public SectionAttribute(string header);
    public SectionAttribute(string header, string footer);
    private static SectionAttribute();
    [CompilerGeneratedAttribute]
public string get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(string value);
    [CompilerGeneratedAttribute]
public string get_HeaderKey();
    [CompilerGeneratedAttribute]
public void set_HeaderKey(string value);
    [CompilerGeneratedAttribute]
public string get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(string value);
    [CompilerGeneratedAttribute]
public string get_FooterKey();
    [CompilerGeneratedAttribute]
public void set_FooterKey(string value);
    [CompilerGeneratedAttribute]
public SectionLayoutStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SectionLayoutStyle value);
    [CompilerGeneratedAttribute]
public float get_LabelWidth();
    [CompilerGeneratedAttribute]
public void set_LabelWidth(float value);
}
public class Intersoft.Crosslight.Forms.SectionDefinition : ComponentDefinitionBase {
    [CompilerGeneratedAttribute]
private FormDefinition i;
    [CompilerGeneratedAttribute]
private string j;
    [CompilerGeneratedAttribute]
private string k;
    [CompilerGeneratedAttribute]
private string l;
    [CompilerGeneratedAttribute]
private string m;
    [CompilerGeneratedAttribute]
private SectionLayoutStyle n;
    [CompilerGeneratedAttribute]
private float o;
    [CompilerGeneratedAttribute]
private Single[] p;
    [CompilerGeneratedAttribute]
private bool q;
    [CompilerGeneratedAttribute]
private bool r;
    [CompilerGeneratedAttribute]
private IContainerView h;
    [CompilerGeneratedAttribute]
private List`1<PropertyDefinition> s;
    public FormDefinition Form { get; internal set; }
    public string Header { get; public set; }
    public string HeaderKey { get; public set; }
    public string Footer { get; public set; }
    public string FooterKey { get; public set; }
    public SectionLayoutStyle Style { get; public set; }
    public float LabelWidth { get; public set; }
    public Single[] ResolvedLabelSize { get; internal set; }
    public bool IsVisible { get; public set; }
    public bool IsEnabled { get; public set; }
    public IContainerView View { get; public set; }
    public List`1<PropertyDefinition> Properties { get; private set; }
    [CompilerGeneratedAttribute]
public FormDefinition get_Form();
    [CompilerGeneratedAttribute]
internal void set_Form(FormDefinition value);
    [CompilerGeneratedAttribute]
public string get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(string value);
    [CompilerGeneratedAttribute]
public string get_HeaderKey();
    [CompilerGeneratedAttribute]
public void set_HeaderKey(string value);
    [CompilerGeneratedAttribute]
public string get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(string value);
    [CompilerGeneratedAttribute]
public string get_FooterKey();
    [CompilerGeneratedAttribute]
public void set_FooterKey(string value);
    [CompilerGeneratedAttribute]
public SectionLayoutStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SectionLayoutStyle value);
    [CompilerGeneratedAttribute]
public float get_LabelWidth();
    [CompilerGeneratedAttribute]
public void set_LabelWidth(float value);
    [CompilerGeneratedAttribute]
public Single[] get_ResolvedLabelSize();
    [CompilerGeneratedAttribute]
internal void set_ResolvedLabelSize(Single[] value);
    [CompilerGeneratedAttribute]
public bool get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [CompilerGeneratedAttribute]
public IContainerView get_View();
    [CompilerGeneratedAttribute]
public void set_View(IContainerView value);
    [CompilerGeneratedAttribute]
public List`1<PropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(List`1<PropertyDefinition> value);
    public IndexPath GetVisibleIndexPath();
    [CompilerGeneratedAttribute]
private bool <GetVisibleIndexPath>b__49_0(SectionDefinition a);
}
public enum Intersoft.Crosslight.Forms.SectionLayoutStyle : Enum {
    public int value__;
    public static SectionLayoutStyle Default;
    public static SectionLayoutStyle RightDetail;
    public static SectionLayoutStyle LeftDetail;
    public static SectionLayoutStyle RowDetail;
    public static SectionLayoutStyle ImageWithFields;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.SelectedItemBindingAttribute : BindingAttribute {
    protected FormBindableProperty TargetProperty { get; }
    protected virtual FormBindableProperty get_TargetProperty();
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.SelectedItemsBindingAttribute : BindingAttribute {
    protected FormBindableProperty TargetProperty { get; }
    protected virtual FormBindableProperty get_TargetProperty();
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.SelectedValueBindingAttribute : BindingAttribute {
    protected FormBindableProperty TargetProperty { get; }
    protected virtual FormBindableProperty get_TargetProperty();
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.SelectionInputAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SelectionMode a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private Type h;
    public SelectionMode SelectionMode { get; public set; }
    public string ListSourceMemberPath { get; public set; }
    public string DisplayMemberPath { get; public set; }
    public string ValueMemberPath { get; public set; }
    public string ImageMemberPath { get; public set; }
    public bool ReuseExistingViewContext { get; public set; }
    public string NavigationTargetIdentifier { get; public set; }
    public Type ListSourceType { get; public set; }
    public SelectionInputAttribute(SelectionMode selectionMode);
    public SelectionInputAttribute(SelectionMode selectionMode, Type listSourceType);
    [CompilerGeneratedAttribute]
public SelectionMode get_SelectionMode();
    [CompilerGeneratedAttribute]
public void set_SelectionMode(SelectionMode value);
    [CompilerGeneratedAttribute]
public string get_ListSourceMemberPath();
    [CompilerGeneratedAttribute]
public void set_ListSourceMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayMemberPath();
    [CompilerGeneratedAttribute]
public void set_DisplayMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ValueMemberPath();
    [CompilerGeneratedAttribute]
public void set_ValueMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImageMemberPath();
    [CompilerGeneratedAttribute]
public void set_ImageMemberPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ReuseExistingViewContext();
    [CompilerGeneratedAttribute]
public void set_ReuseExistingViewContext(bool value);
    [CompilerGeneratedAttribute]
public string get_NavigationTargetIdentifier();
    [CompilerGeneratedAttribute]
public void set_NavigationTargetIdentifier(string value);
    [CompilerGeneratedAttribute]
public Type get_ListSourceType();
    [CompilerGeneratedAttribute]
public void set_ListSourceType(Type value);
}
public enum Intersoft.Crosslight.Forms.SelectionMode : Enum {
    public int value__;
    public static SelectionMode Single;
    public static SelectionMode Multiple;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.StringInputAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private bool c;
    [CompilerGeneratedAttribute]
private bool d;
    [CompilerGeneratedAttribute]
private AutoCorrectionType e;
    [CompilerGeneratedAttribute]
private ClearButtonVisibility f;
    [CompilerGeneratedAttribute]
private TextAlignment g;
    [CompilerGeneratedAttribute]
private InputType h;
    [CompilerGeneratedAttribute]
private ReturnKeyType i;
    [CompilerGeneratedAttribute]
private bool j;
    [CompilerGeneratedAttribute]
private bool k;
    [CompilerGeneratedAttribute]
private float l;
    [CompilerGeneratedAttribute]
private float m;
    [CompilerGeneratedAttribute]
private int n;
    public string Placeholder { get; public set; }
    public string PlaceHolderKey { get; public set; }
    public bool IsSecure { get; public set; }
    public bool ReadOnly { get; public set; }
    public AutoCorrectionType AutoCorrection { get; public set; }
    public ClearButtonVisibility ClearButtonVisibility { get; public set; }
    public TextAlignment Alignment { get; public set; }
    public InputType InputType { get; public set; }
    public ReturnKeyType ReturnKeyType { get; public set; }
    public bool AcceptLineBreak { get; public set; }
    public bool AutoResize { get; public set; }
    public float MinHeight { get; public set; }
    public float MaxHeight { get; public set; }
    public int MaxLength { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Placeholder();
    [CompilerGeneratedAttribute]
public void set_Placeholder(string value);
    [CompilerGeneratedAttribute]
public string get_PlaceHolderKey();
    [CompilerGeneratedAttribute]
public void set_PlaceHolderKey(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSecure();
    [CompilerGeneratedAttribute]
public void set_IsSecure(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public AutoCorrectionType get_AutoCorrection();
    [CompilerGeneratedAttribute]
public void set_AutoCorrection(AutoCorrectionType value);
    [CompilerGeneratedAttribute]
public ClearButtonVisibility get_ClearButtonVisibility();
    [CompilerGeneratedAttribute]
public void set_ClearButtonVisibility(ClearButtonVisibility value);
    [CompilerGeneratedAttribute]
public TextAlignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(TextAlignment value);
    [CompilerGeneratedAttribute]
public InputType get_InputType();
    [CompilerGeneratedAttribute]
public void set_InputType(InputType value);
    [CompilerGeneratedAttribute]
public ReturnKeyType get_ReturnKeyType();
    [CompilerGeneratedAttribute]
public void set_ReturnKeyType(ReturnKeyType value);
    [CompilerGeneratedAttribute]
public bool get_AcceptLineBreak();
    [CompilerGeneratedAttribute]
public void set_AcceptLineBreak(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoResize();
    [CompilerGeneratedAttribute]
public void set_AutoResize(bool value);
    [CompilerGeneratedAttribute]
public float get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(float value);
    [CompilerGeneratedAttribute]
public float get_MaxHeight();
    [CompilerGeneratedAttribute]
public void set_MaxHeight(float value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
public void set_MaxLength(int value);
}
public enum Intersoft.Crosslight.Forms.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Center;
    public static TextAlignment Right;
}
public enum Intersoft.Crosslight.Forms.TintColorMode : Enum {
    public int value__;
    public static TintColorMode Disabled;
    public static TintColorMode TextColor;
    public static TintColorMode BackgroundColor;
}
[AttributeUsageAttribute("384")]
public class Intersoft.Crosslight.Forms.VisibilityBindingAttribute : BindingAttribute {
    [CompilerGeneratedAttribute]
private bool l;
    protected FormBindableProperty TargetProperty { get; }
    public bool DisableAnimation { get; public set; }
    protected virtual FormBindableProperty get_TargetProperty();
    [CompilerGeneratedAttribute]
public bool get_DisableAnimation();
    [CompilerGeneratedAttribute]
public void set_DisableAnimation(bool value);
}
public enum Intersoft.Crosslight.FormState : Enum {
    public int value__;
    public static FormState New;
    public static FormState Edit;
    public static FormState View;
}
public class Intersoft.Crosslight.FrameworkModel : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler a;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string propertyName);
    public void RaisePropertyChanged(string propertyName);
}
public class Intersoft.Crosslight.GroupItem`1 : ObservableCollection`1<T> {
    [CompilerGeneratedAttribute]
private string a;
    public string Title { get; private set; }
    public bool HasItems { get; }
    private IList Intersoft.Crosslight.IGroupItem.Items { get; }
    public GroupItem`1(string title);
    public GroupItem`1(IGrouping`2<string, T> group);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    public sealed virtual bool get_HasItems();
    private sealed virtual override IList Intersoft.Crosslight.IGroupItem.get_Items();
}
public class Intersoft.Crosslight.Guard : object {
    public static void NotNull(object obj, string name);
    public static void NotEmpty(string str, string name);
}
public enum Intersoft.Crosslight.HashAlgorithmKind : Enum {
    public int value__;
    public static HashAlgorithmKind HmacSha1;
    public static HashAlgorithmKind HmacSha256;
    public static HashAlgorithmKind Sha1Managed;
    public static HashAlgorithmKind Sha256Managed;
}
public interface Intersoft.Crosslight.IAccount {
    public string Username { get; }
    public string ServiceId { get; }
    public string AuthenticatorServiceId { get; }
    public IDictionary`2<string, object> Properties { get; }
    public abstract virtual string get_Username();
    public abstract virtual string get_ServiceId();
    public abstract virtual string get_AuthenticatorServiceId();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual T GetProperty(string key);
    public abstract virtual string GetProperty(string key);
}
public interface Intersoft.Crosslight.IAccountStoreService {
    public abstract virtual void SetOwner(object owner);
    public abstract virtual IEnumerable`1<IAccount> FindAccounts(string serviceId);
    public abstract virtual IAccount FindAccount(string serviceId);
    public abstract virtual void Save(IAccount account);
    public abstract virtual void Delete(IAccount account);
}
public interface Intersoft.Crosslight.IActionPresenter {
    public abstract virtual void Show(string title, String[] buttons, Action`1<int> actionCallback);
    public abstract virtual void Show(string title, String[] buttons, int highlightButtonIndex, int cancelButtonIndex, Action`1<int> actionCallback);
    public abstract virtual void Dismiss();
}
public interface Intersoft.Crosslight.IActionToastPresenter {
    public abstract virtual void Show(string message, ToastSettings settings);
    public abstract virtual void Show(string message, ToastSettings settings, string action, object parameter, Action`1<object> actionCallback);
}
public interface Intersoft.Crosslight.IActivatorService {
    public abstract virtual void Register();
    public abstract virtual void Register(Func`2<IDependencyResolver, TType> func);
    public abstract virtual T CreateInstance();
    public abstract virtual object CreateInstance(Type type);
}
public interface Intersoft.Crosslight.IActivityPresenter {
    public abstract virtual void Show();
    public abstract virtual void Show(ActivityStyle style);
    public abstract virtual void Show(string message, ActivityStyle style);
    public abstract virtual void Show(string message, ActivityStyle style, bool useOverlay);
    public abstract virtual void Show(string message, ActivityStyle style, IViewModel owner);
    public abstract virtual void Hide();
}
public interface Intersoft.Crosslight.IAdvancedActionPresenter {
    public abstract virtual void Show(string title, NavigationItem[] items);
}
public interface Intersoft.Crosslight.IApplicationContext {
    public Assembly MainAssembly { get; }
    public Type MainType { get; }
    public IViewModel RootViewModel { get; public set; }
    public Type RootViewModelType { get; public set; }
    public Type[] ExportedTypes { get; }
    public PlatformInfo Platform { get; }
    public DeviceInfo Device { get; }
    public CultureInfo SystemLanguage { get; }
    public object Context { get; }
    public abstract virtual Assembly get_MainAssembly();
    public abstract virtual Type get_MainType();
    public abstract virtual IViewModel get_RootViewModel();
    public abstract virtual void set_RootViewModel(IViewModel value);
    public abstract virtual Type get_RootViewModelType();
    public abstract virtual void set_RootViewModelType(Type value);
    public abstract virtual Type[] get_ExportedTypes();
    public abstract virtual PlatformInfo get_Platform();
    public abstract virtual DeviceInfo get_Device();
    public abstract virtual CultureInfo get_SystemLanguage();
    public abstract virtual object get_Context();
    public abstract virtual void AddExportedType(Type type);
    public abstract virtual void AddExportedTypes(Type[] types);
}
public interface Intersoft.Crosslight.IApplicationEventSource {
    public abstract virtual void Started();
    public abstract virtual void Terminated();
    public abstract virtual void Paused();
    public abstract virtual void Activated();
    public abstract virtual void Deactivated();
    public abstract virtual void Resumed();
    public abstract virtual void NotificationReceived(Notification notification);
    public abstract virtual void DeviceTokenReceived(DeviceToken token);
    public abstract virtual void Synced(SyncContext context);
    public abstract virtual void SyncCancelled(SyncContext context);
    public abstract virtual void Navigated(IViewModel viewModel, NavigatedParameter parameter);
}
public interface Intersoft.Crosslight.IApplicationHost {
    public object ApplicationInstance { get; }
    public Type ApplicationType { get; }
    public abstract virtual object get_ApplicationInstance();
    public abstract virtual Type get_ApplicationType();
    public abstract virtual IEnumerable`1<Assembly> GetLoadedAssemblies();
}
public interface Intersoft.Crosslight.IApplicationInitializer {
    public abstract virtual void InitializeServices(IApplicationHost appHost);
    public abstract virtual void InitializeComponents(IApplicationHost appHost);
    public abstract virtual void InitializeApplication(IApplicationHost appHost);
    public abstract virtual IApplicationService GetApplicationService(IApplicationContext context);
}
public interface Intersoft.Crosslight.IApplicationService {
    public ApplicationState State { get; }
    public abstract virtual ApplicationState get_State();
    public abstract virtual IApplicationContext GetContext();
    public abstract virtual void OnStart(StartParameter parameter);
    public abstract virtual void Navigate(NavigationTarget target);
    public abstract virtual void OnTerminate();
    public abstract virtual void OnPause();
    public abstract virtual void OnActivate();
    public abstract virtual void OnDeactivate();
    public abstract virtual void OnResume();
    public abstract virtual void OnNotificationReceived(Notification notification);
    public abstract virtual void OnDeviceTokenReceived(DeviceToken token);
    public abstract virtual void OnSync(SyncContext context);
    public abstract virtual void OnCancelSync(SyncContext context);
    public abstract virtual void OnUserInteraction();
    public abstract virtual void OnViewModelNavigated(IViewModel viewModel, NavigatedParameter parameter);
    public abstract virtual void OnViewModelDisposed(IViewModel viewModel);
}
public interface Intersoft.Crosslight.IAuthenticationContext {
    public IAccount Account { get; }
    public AuthenticateOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public abstract virtual IAccount get_Account();
    public abstract virtual AuthenticateOptions get_Options();
    public abstract virtual CancellationToken get_CancellationToken();
}
public interface Intersoft.Crosslight.IAuthenticationResult {
    public bool IsAuthenticated { get; }
    public IAccount Account { get; }
    public Exception Exception { get; }
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual IAccount get_Account();
    public abstract virtual Exception get_Exception();
}
public interface Intersoft.Crosslight.IAuthenticationService {
    public abstract virtual void Register();
    public abstract virtual void Register(string accountServiceId);
    public abstract virtual TAuth GetAuthenticator();
    public abstract virtual IAuthenticator GetAuthenticator(string serviceId);
    public abstract virtual IEnumerable`1<IAuthenticator> GetAuthenticators(string serviceId);
    public abstract virtual Task`1<IAuthenticationResult> AuthenticateAsync(IAccount account, AuthenticateOptions options, CancellationToken cancellationToken);
}
public interface Intersoft.Crosslight.IAuthenticator {
    public string ServiceId { get; }
    public string AccountServiceId { get; public set; }
    public int Precedence { get; }
    public bool SaveToAccountStore { get; }
    public bool SupportsUserInteraction { get; }
    public abstract virtual string get_ServiceId();
    public abstract virtual string get_AccountServiceId();
    public abstract virtual void set_AccountServiceId(string value);
    public abstract virtual int get_Precedence();
    public abstract virtual bool get_SaveToAccountStore();
    public abstract virtual bool get_SupportsUserInteraction();
    public abstract virtual IAccount GetStoredAccount();
    public abstract virtual Task`1<IAuthenticationResult> AuthenticateAsync(IAuthenticationContext context);
}
public interface Intersoft.Crosslight.IAuthenticator`1 {
    public abstract virtual Task`1<IAuthenticationResult> AuthenticateAsync(TAuthContext context);
}
public interface Intersoft.Crosslight.IBindingAdapter {
    public abstract virtual void SetValue(object obj, BindableProperty property, object value);
    public abstract virtual object GetValue(object obj, BindableProperty property);
    public abstract virtual object GetDefaultValue(object obj, BindableProperty property);
    public abstract virtual void Attach(object obj, BindingContext context);
    public abstract virtual void Detach(object obj, BindingContext context);
    public abstract virtual bool IsPropertySupported(BindableProperty property, bool checkTwoWayBindingSupport);
}
public interface Intersoft.Crosslight.IBindingAdapter`1 {
    public abstract virtual void SetValue(T obj, BindableProperty property, object value);
    public abstract virtual object GetValue(T obj, BindableProperty property);
    public abstract virtual object GetDefaultValue(T obj, BindableProperty property);
    public abstract virtual void Attach(T obj, BindingContext property);
    public abstract virtual void Detach(T obj, BindingContext property);
}
public interface Intersoft.Crosslight.IBindingProvider {
    public abstract virtual IEnumerable`1<BindingDefinition> GetBindings();
}
public interface Intersoft.Crosslight.IChildViewModel {
    public IViewModel ParentViewModel { get; public set; }
    public abstract virtual IViewModel get_ParentViewModel();
    public abstract virtual void set_ParentViewModel(IViewModel value);
}
public interface Intersoft.Crosslight.ICommandBindingAdapter {
    public abstract virtual void OnCommandCanExecuteChanged(ICommand command);
    public abstract virtual void OnViewCanExecuteChanged(ICommand command, object view);
}
public interface Intersoft.Crosslight.IComponentView {
    public abstract virtual void Activate();
    public abstract virtual void Deactivate();
    public abstract virtual void WillDisplay();
    public abstract virtual void ValueChanged(object newValue);
}
public interface Intersoft.Crosslight.IComponentViewDelegate {
    public abstract virtual void Activate(IComponentView component, PropertyDefinition property);
}
public interface Intersoft.Crosslight.IContainerView {
    public abstract virtual int GetViewsCount();
    public abstract virtual IEnumerable`1<IComponentView> GetViews();
    public abstract virtual IComponentView GetViewAt(int index);
    public abstract virtual void AddView(IView view);
}
public interface Intersoft.Crosslight.ICustomDeserializer {
    public abstract virtual void OnDeserialized(DeserializationContext context);
}
public interface Intersoft.Crosslight.ICustomSerializer {
    public abstract virtual void OnSerialized(SerializationContext context);
}
public interface Intersoft.Crosslight.IDataChangeTracker {
    [CompilerGeneratedAttribute]
public abstract virtual void add_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    public abstract virtual void OnDataChanged(object item);
}
public interface Intersoft.Crosslight.IDataValidation {
    public bool HasErrors { get; }
    public abstract virtual bool get_HasErrors();
    public abstract virtual void Validate();
}
public interface Intersoft.Crosslight.IDataValidationErrorManager {
    public abstract virtual void ClearErrors();
}
public interface Intersoft.Crosslight.IDelegateReference {
    public Delegate Target { get; }
    public abstract virtual Delegate get_Target();
}
public interface Intersoft.Crosslight.IDetailViewModel {
    public object Item { get; public set; }
    public abstract virtual object get_Item();
    public abstract virtual void set_Item(object value);
}
public interface Intersoft.Crosslight.IDetailViewModel`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item();
    public abstract virtual void set_Item(T value);
}
public interface Intersoft.Crosslight.IDialogPresenter {
    public abstract virtual void Show(Action`1<DialogResult> callback);
    public abstract virtual void Show(DialogOptions dialogOptions, Action`1<DialogResult> callback);
    public abstract virtual void Show(NavigationParameter parameter, DialogOptions dialogOptions, Action`1<DialogResult> callback);
    public abstract virtual void Show(NavigationTarget target, DialogOptions dialogOptions, Action`1<DialogResult> callback);
    public abstract virtual void Show(string targetName, DialogOptions dialogOptions, Action`1<DialogResult> callback);
    public abstract virtual void Dismiss();
}
public interface Intersoft.Crosslight.IDrawerViewModel {
    public IViewModel LeftViewModel { get; public set; }
    public IViewModel CenterViewModel { get; public set; }
    public IViewModel RightViewModel { get; public set; }
    public bool IsOpen { get; }
    public DrawerSide OpenedDrawer { get; }
    public abstract virtual IViewModel get_LeftViewModel();
    public abstract virtual void set_LeftViewModel(IViewModel value);
    public abstract virtual IViewModel get_CenterViewModel();
    public abstract virtual void set_CenterViewModel(IViewModel value);
    public abstract virtual IViewModel get_RightViewModel();
    public abstract virtual void set_RightViewModel(IViewModel value);
    public abstract virtual bool get_IsOpen();
    public abstract virtual DrawerSide get_OpenedDrawer();
    public abstract virtual void Open(DrawerSide side);
    public abstract virtual void Close();
}
public interface Intersoft.Crosslight.IEditableListViewModel {
    public bool IsEditing { get; public set; }
    public DelegateCommand EditCommand { get; public set; }
    public DelegateCommand AddCommand { get; public set; }
    public DelegateCommand DeleteCommand { get; public set; }
    public DelegateCommand ReorderCommand { get; public set; }
    public DelegateCommand ToggleEditModeCommand { get; public set; }
    public abstract virtual bool get_IsEditing();
    public abstract virtual void set_IsEditing(bool value);
    public abstract virtual DelegateCommand get_EditCommand();
    public abstract virtual void set_EditCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_AddCommand();
    public abstract virtual void set_AddCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_DeleteCommand();
    public abstract virtual void set_DeleteCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_ReorderCommand();
    public abstract virtual void set_ReorderCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_ToggleEditModeCommand();
    public abstract virtual void set_ToggleEditModeCommand(DelegateCommand value);
}
public interface Intersoft.Crosslight.IEditableListViewModel`1 {
    public bool IsEditing { get; public set; }
    public DelegateCommand EditCommand { get; public set; }
    public DelegateCommand AddCommand { get; public set; }
    public DelegateCommand DeleteCommand { get; public set; }
    public DelegateCommand ReorderCommand { get; public set; }
    public DelegateCommand ToggleEditModeCommand { get; public set; }
    public abstract virtual bool get_IsEditing();
    public abstract virtual void set_IsEditing(bool value);
    public abstract virtual DelegateCommand get_EditCommand();
    public abstract virtual void set_EditCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_AddCommand();
    public abstract virtual void set_AddCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_DeleteCommand();
    public abstract virtual void set_DeleteCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_ReorderCommand();
    public abstract virtual void set_ReorderCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_ToggleEditModeCommand();
    public abstract virtual void set_ToggleEditModeCommand(DelegateCommand value);
}
public interface Intersoft.Crosslight.IEditorViewModel {
    public bool IsDirty { get; public set; }
    public bool IsNewItem { get; public set; }
    public bool IsCancelled { get; public set; }
    public bool IsDismissHandled { get; public set; }
    public DelegateCommand SaveCommand { get; public set; }
    public DelegateCommand CancelCommand { get; public set; }
    public Type FormMetadataType { get; }
    public abstract virtual bool get_IsDirty();
    public abstract virtual void set_IsDirty(bool value);
    public abstract virtual bool get_IsNewItem();
    public abstract virtual void set_IsNewItem(bool value);
    public abstract virtual bool get_IsCancelled();
    public abstract virtual void set_IsCancelled(bool value);
    public abstract virtual bool get_IsDismissHandled();
    public abstract virtual void set_IsDismissHandled(bool value);
    public abstract virtual DelegateCommand get_SaveCommand();
    public abstract virtual void set_SaveCommand(DelegateCommand value);
    public abstract virtual DelegateCommand get_CancelCommand();
    public abstract virtual void set_CancelCommand(DelegateCommand value);
    public abstract virtual Type get_FormMetadataType();
}
public interface Intersoft.Crosslight.IEventAggregator {
    public abstract virtual TEventType GetEvent();
    public abstract virtual SubscriptionToken Subscribe(Action`1<TPayload> action);
    public abstract virtual void Publish(TPayload payload);
    public abstract virtual void Unsubscribe(Action`1<TPayload> action);
}
public interface Intersoft.Crosslight.IEventSource {
    public ILog Logger { get; }
    public abstract virtual ILog get_Logger();
}
public interface Intersoft.Crosslight.IEventSubscription {
    public SubscriptionToken SubscriptionID { get; public set; }
    public abstract virtual SubscriptionToken get_SubscriptionID();
    public abstract virtual void set_SubscriptionID(SubscriptionToken value);
    public abstract virtual Action`1<Object[]> GetExecutionStrategy();
}
public interface Intersoft.Crosslight.IFilteredSource {
    public bool EnableAsyncFilter { get; public set; }
    public IEnumerable FilterItems { get; public set; }
    public abstract virtual bool get_EnableAsyncFilter();
    public abstract virtual void set_EnableAsyncFilter(bool value);
    public abstract virtual IEnumerable get_FilterItems();
    public abstract virtual void set_FilterItems(IEnumerable value);
    public abstract virtual void Filter(string query, string scope);
}
public interface Intersoft.Crosslight.IFormBuilderService {
    public abstract virtual object Build(object viewHost, FormDefinition form);
    public abstract virtual IViewBuilder GetViewBuilder(ComponentDefinitionBase definition);
    public abstract virtual void Register();
}
public interface Intersoft.Crosslight.IGroupedSource {
    public IEnumerable GroupItems { get; public set; }
    public abstract virtual IEnumerable get_GroupItems();
    public abstract virtual void set_GroupItems(IEnumerable value);
    public abstract virtual void RefreshGroupItems();
    public abstract virtual void RefreshGroupView();
}
public interface Intersoft.Crosslight.IGroupItem {
    public string Title { get; }
    public bool HasItems { get; }
    public IList Items { get; }
    public abstract virtual string get_Title();
    public abstract virtual bool get_HasItems();
    public abstract virtual IList get_Items();
}
public interface Intersoft.Crosslight.IImageLoaderContext {
    public string PlaceholderImage { get; }
    public ImageLoaderSettings Settings { get; }
    public ResourceCacheItem Cache { get; }
    public abstract virtual string get_PlaceholderImage();
    public abstract virtual ImageLoaderSettings get_Settings();
    public abstract virtual ResourceCacheItem get_Cache();
}
public interface Intersoft.Crosslight.IImageLoaderDelegate {
    public abstract virtual void Initializing(IImageLoaderContext context);
    public abstract virtual void Started(IImageLoaderContext context);
    public abstract virtual void Progress(IImageLoaderContext context, IResourceLoaderProgress progress);
    public abstract virtual void Completed(IImageLoaderContext context, Byte[] resultData);
    public abstract virtual void Failed(IImageLoaderContext context, Exception error);
    public abstract virtual void Canceled(IImageLoaderContext context, string reason);
}
public interface Intersoft.Crosslight.IImageLoaderService {
    public abstract virtual void Configure(ImageLoaderGlobalSettings settings);
    public abstract virtual void CancelLoad(CancellationTokenSource cancellationToken);
    public abstract virtual IResourceCacheSession GetImageLoaderCacheSession();
    public abstract virtual Task`1<Byte[]> LoadImageAsync(string url, string placeHolderImage, object userData, IImageLoaderDelegate loaderDelegate, ImageLoaderSettings loaderSettings, CancellationTokenSource cancellationToken);
}
public interface Intersoft.Crosslight.IItemBindingAdapter {
    public abstract virtual bool Attach(object view, IViewModel viewModel, object model, IEnumerable`1<BindingContext> bindingContexts);
    public abstract virtual void Detach(object view);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public interface Intersoft.Crosslight.IJsonSerializerStrategy {
    public abstract virtual bool TrySerializeNonPrimitiveObject(object input, object originalValue, JsonSerializationOptions options, Object& output);
    public abstract virtual object DeserializeObject(object value, Type type, JsonSerializationOptions options);
}
[DefaultMemberAttribute("Item")]
public interface Intersoft.Crosslight.IListAccessor {
    public object Item { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void SetItems(IEnumerable items);
    public abstract virtual object GetItemAt(IndexPath indexPath);
    public abstract virtual IndexPath GetItemIndex(object item);
}
public interface Intersoft.Crosslight.IListViewModel {
    public IEnumerable Items { get; public set; }
    public IList SelectedItems { get; public set; }
    public object SelectedItem { get; public set; }
    public ICollection SourceItems { get; public set; }
    public abstract virtual IEnumerable get_Items();
    public abstract virtual void set_Items(IEnumerable value);
    public abstract virtual IList get_SelectedItems();
    public abstract virtual void set_SelectedItems(IList value);
    public abstract virtual object get_SelectedItem();
    public abstract virtual void set_SelectedItem(object value);
    public abstract virtual ICollection get_SourceItems();
    public abstract virtual void set_SourceItems(ICollection value);
}
public interface Intersoft.Crosslight.IListViewModel`1 {
    public IEnumerable`1<T> Items { get; public set; }
    public IList`1<T> SelectedItems { get; public set; }
    public T SelectedItem { get; public set; }
    public abstract virtual IEnumerable`1<T> get_Items();
    public abstract virtual void set_Items(IEnumerable`1<T> value);
    public abstract virtual IList`1<T> get_SelectedItems();
    public abstract virtual void set_SelectedItems(IList`1<T> value);
    public abstract virtual T get_SelectedItem();
    public abstract virtual void set_SelectedItem(T value);
}
public interface Intersoft.Crosslight.ILocalizationService {
    public bool AutoUpdateBindings { get; public set; }
    public CultureInfo CurrentUICulture { get; }
    public CultureInfo CurrencyCulture { get; public set; }
    public string CurrencyFormat { get; public set; }
    public abstract virtual bool get_AutoUpdateBindings();
    public abstract virtual void set_AutoUpdateBindings(bool value);
    public abstract virtual CultureInfo get_CurrentUICulture();
    public abstract virtual CultureInfo get_CurrencyCulture();
    public abstract virtual void set_CurrencyCulture(CultureInfo value);
    public abstract virtual string get_CurrencyFormat();
    public abstract virtual void set_CurrencyFormat(string value);
    public abstract virtual IObservableResource GetResource();
    public abstract virtual string GetString(string resourceKey);
    public abstract virtual string GetString(string resourceKey);
    public abstract virtual void RegisterDefaultResource(IObservableResource resource);
    public abstract virtual void RegisterResource(IObservableResource resource);
    public abstract virtual void SetCulture(CultureInfo culture);
    public abstract virtual void SetUICulture(CultureInfo culture);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CultureChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CultureChanged(EventHandler value);
}
public interface Intersoft.Crosslight.ILog {
    public abstract virtual void Debug(object message);
    public abstract virtual void Debug(object message, object data);
    public abstract virtual void Debug(object message, Dictionary`2<string, object> data);
    public abstract virtual void Debug(object message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] data);
    public abstract virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] data);
    public abstract virtual void Error(object message);
    public abstract virtual void Error(object message, object data);
    public abstract virtual void Error(object message, Dictionary`2<string, object> data);
    public abstract virtual void Error(object message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] data);
    public abstract virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] data);
    public abstract virtual void Fatal(object message);
    public abstract virtual void Fatal(object message, object data);
    public abstract virtual void Fatal(object message, Dictionary`2<string, object> data);
    public abstract virtual void Fatal(object message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] data);
    public abstract virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] data);
    public abstract virtual void Info(object message);
    public abstract virtual void Info(object message, object data);
    public abstract virtual void Info(object message, Dictionary`2<string, object> data);
    public abstract virtual void Info(object message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] data);
    public abstract virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] data);
    public abstract virtual void Warn(object message);
    public abstract virtual void Warn(object message, object data);
    public abstract virtual void Warn(object message, Dictionary`2<string, object> data);
    public abstract virtual void Warn(object message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] data);
    public abstract virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] data);
    public abstract virtual ITracer Trace(object message);
    public abstract virtual ITracer TraceFormat(string format, Object[] data);
    public abstract virtual ITracer TraceFormat(IFormatProvider formatProvider, string format, Object[] data);
}
public interface Intersoft.Crosslight.ILogRepository {
    public abstract virtual Task Clear();
    public abstract virtual Task`1<IEnumerable> GetAllAsync();
}
public interface Intersoft.Crosslight.ILogService {
    public abstract virtual ILog GetLogger();
    public abstract virtual ILog GetLogger(string category);
    public abstract virtual ILog GetLogger(Type type);
    public abstract virtual TEventSource GetEventSource(Type type);
    public abstract virtual void RegisterEventSource();
    public abstract virtual void Register();
    public abstract virtual void RegisterByCategory(Func`2<IDependencyResolver, Func`2<string, ILog>> func);
    public abstract virtual void RegisterByType(Func`2<IDependencyResolver, Func`2<Type, ILog>> func);
}
public class Intersoft.Crosslight.ImageLoaderDelegate : object {
    private Action`1<IImageLoaderContext> a;
    private Action`1<IImageLoaderContext> b;
    private Action`2<IImageLoaderContext, IResourceLoaderProgress> c;
    private Action`2<IImageLoaderContext, Byte[]> d;
    private Action`2<IImageLoaderContext, Exception> e;
    private Action`2<IImageLoaderContext, string> f;
    public ImageLoaderDelegate(Action`1<IImageLoaderContext> initializing, Action`1<IImageLoaderContext> started, Action`2<IImageLoaderContext, IResourceLoaderProgress> progress, Action`2<IImageLoaderContext, Byte[]> completed, Action`2<IImageLoaderContext, Exception> failed, Action`2<IImageLoaderContext, string> canceled);
    public virtual void Initializing(IImageLoaderContext context);
    public virtual void Started(IImageLoaderContext context);
    public virtual void Progress(IImageLoaderContext context, IResourceLoaderProgress progress);
    public virtual void Completed(IImageLoaderContext context, Byte[] resultData);
    public virtual void Failed(IImageLoaderContext context, Exception error);
    public virtual void Canceled(IImageLoaderContext context, string reason);
}
public class Intersoft.Crosslight.ImageLoaderGlobalSettings : object {
    [CompilerGeneratedAttribute]
private int a;
    [CompilerGeneratedAttribute]
private int b;
    public int MaxDiskCacheSize { get; public set; }
    public int MaxMemoryCacheSize { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxDiskCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxDiskCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxMemoryCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxMemoryCacheSize(int value);
}
public class Intersoft.Crosslight.ImageLoaderSettings : BasicImageLoaderSettings {
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> g;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> h;
    [CompilerGeneratedAttribute]
private float i;
    [CompilerGeneratedAttribute]
private float j;
    public bool ForceLoad { get; public set; }
    public bool ForceLoadDiskCache { get; public set; }
    public Nullable`1<DateTime> CacheExpireDate { get; public set; }
    public Nullable`1<DateTime> ModifiedDate { get; public set; }
    public float ScaledImageWidth { get; public set; }
    public float ScaledImageHeight { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceLoad();
    [CompilerGeneratedAttribute]
public void set_ForceLoad(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceLoadDiskCache();
    [CompilerGeneratedAttribute]
public void set_ForceLoadDiskCache(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CacheExpireDate();
    [CompilerGeneratedAttribute]
public void set_CacheExpireDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ModifiedDate();
    [CompilerGeneratedAttribute]
public void set_ModifiedDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public float get_ScaledImageWidth();
    [CompilerGeneratedAttribute]
public void set_ScaledImageWidth(float value);
    [CompilerGeneratedAttribute]
public float get_ScaledImageHeight();
    [CompilerGeneratedAttribute]
public void set_ScaledImageHeight(float value);
}
public enum Intersoft.Crosslight.ImageResultMode : Enum {
    public int value__;
    public static ImageResultMode Thumbnail;
    public static ImageResultMode FullSize;
    public static ImageResultMode Both;
}
public interface Intersoft.Crosslight.IMessagePresenter {
    public abstract virtual void Show(string message, string title);
    public abstract virtual void Show(string message, string title, String[] buttons, Action`1<int> actionCallback);
}
public interface Intersoft.Crosslight.IMobileService {
    public ICameraService Camera { get; }
    public ITelephonyService Telephony { get; }
    public IMessagingService Messaging { get; }
    public IMailService Mail { get; }
    public IMediaLibraryService MediaLibrary { get; }
    public IBrowserService Browser { get; }
    public IMediaService Media { get; }
    public IMapService Map { get; }
    public ILocationService Location { get; }
    public ISocialService Social { get; }
    public IReachabilityService Reachability { get; }
    public INotificationService Notification { get; }
    public ILocalStorageService LocalStorage { get; }
    public IContactService Contact { get; }
    public abstract virtual IEnumerable`1<IMobileComponentService> GetAllServices();
    public abstract virtual void SetOwner(object owner);
    public abstract virtual ICameraService get_Camera();
    public abstract virtual ITelephonyService get_Telephony();
    public abstract virtual IMessagingService get_Messaging();
    public abstract virtual IMailService get_Mail();
    public abstract virtual IMediaLibraryService get_MediaLibrary();
    public abstract virtual IBrowserService get_Browser();
    public abstract virtual IMediaService get_Media();
    public abstract virtual IMapService get_Map();
    public abstract virtual ILocationService get_Location();
    public abstract virtual ISocialService get_Social();
    public abstract virtual IReachabilityService get_Reachability();
    public abstract virtual INotificationService get_Notification();
    public abstract virtual ILocalStorageService get_LocalStorage();
    public abstract virtual IContactService get_Contact();
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.ImportBindingAttribute : Attribute {
    private Type a;
    public Type BindingType { get; }
    public ImportBindingAttribute(Type type);
    public Type get_BindingType();
}
public interface Intersoft.Crosslight.IMultiPageViewModel {
    public NavigationItem[] Items { get; }
    public int SelectedIndex { get; public set; }
    public IViewModel SelectedViewModel { get; public set; }
    public abstract virtual NavigationItem[] get_Items();
    public abstract virtual int get_SelectedIndex();
    public abstract virtual void set_SelectedIndex(int value);
    public abstract virtual IViewModel get_SelectedViewModel();
    public abstract virtual void set_SelectedViewModel(IViewModel value);
}
public interface Intersoft.Crosslight.IMultipleSelectionObserver {
    public abstract virtual void OnSelectedItemsChanged(INotifyCollectionChanged selectedItems);
}
public interface Intersoft.Crosslight.INavigable {
    public INavigationService NavigationService { get; }
    public abstract virtual INavigationService get_NavigationService();
    public abstract virtual void Navigated(NavigatedParameter parameter);
    public abstract virtual bool ShouldNavigate(NavigationTarget target);
}
public interface Intersoft.Crosslight.INavigationContext {
    public abstract virtual void DetermineNavigationMode(NavigationParameter parameter);
}
public interface Intersoft.Crosslight.INavigationService {
    public abstract virtual void Initialize(IViewModel viewModel);
    public abstract virtual bool Navigate();
    public abstract virtual bool Navigate(string targetName);
    public abstract virtual bool Navigate(NavigationParameter parameter);
    public abstract virtual bool Navigate(NavigationParameter parameter, Action`1<NavigationResult> resultCallback);
    public abstract virtual bool Navigate(NavigationTarget target);
    public abstract virtual bool Navigate(NavigationTarget target, Action`1<NavigationResult> resultCallback);
    public abstract virtual void Close();
    public abstract virtual void Close(NavigationResult result);
}
[r]
public class Intersoft.Crosslight.IndexPath : object {
    [CompilerGeneratedAttribute]
private int a;
    [CompilerGeneratedAttribute]
private int b;
    [CompilerGeneratedAttribute]
private int c;
    [CompilerGeneratedAttribute]
private bool d;
    public int Row { get; public set; }
    public int Section { get; public set; }
    public int UngroupedIndex { get; public set; }
    internal bool IsLastItem { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_Row();
    [CompilerGeneratedAttribute]
public void set_Row(int value);
    [CompilerGeneratedAttribute]
public int get_Section();
    [CompilerGeneratedAttribute]
public void set_Section(int value);
    [CompilerGeneratedAttribute]
public int get_UngroupedIndex();
    [CompilerGeneratedAttribute]
public void set_UngroupedIndex(int value);
    [CompilerGeneratedAttribute]
internal bool get_IsLastItem();
    [CompilerGeneratedAttribute]
internal void set_IsLastItem(bool value);
    public static IndexPath FromIndex(int index);
    public static IndexPath FromRowSection(int row, int section);
    public static IndexPath FromRowSection(int row, int section, int ungroupedIndex);
}
public interface Intersoft.Crosslight.INotifyApplicationStateChanged {
    public abstract virtual void OnStateChanged(IApplicationService service, ApplicationState oldState, ApplicationState newState);
}
public class Intersoft.Crosslight.Input.DelegateCommand : object {
    private Action`1<object> a;
    private Func`2<object, bool> b;
    private List`1<WeakReference> c;
    public DelegateCommand(Action`1<object> executeMethod);
    public DelegateCommand(Action`1<object> executeMethod, Func`2<object, bool> canExecuteMethod);
    public bool CanExecute(object parameter);
    public void Execute(object parameter);
    public void RaiseCanExecuteChanged();
    protected virtual void OnCanExecuteChanged();
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object a);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object a);
}
public class Intersoft.Crosslight.Input.DelegateCommand`1 : object {
    private Action`1<T> a;
    private Func`2<T, bool> b;
    private List`1<WeakReference> c;
    public DelegateCommand`1(Action`1<T> executeMethod);
    public DelegateCommand`1(Action`1<T> executeMethod, Func`2<T, bool> canExecuteMethod);
    public bool CanExecute(T parameter);
    public void Execute(T parameter);
    public void RaiseCanExecuteChanged();
    protected virtual void OnCanExecuteChanged();
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object a);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object a);
}
public enum Intersoft.Crosslight.InstantMessagingService : Enum {
    public int value__;
    public static InstantMessagingService Aim;
    public static InstantMessagingService Msn;
    public static InstantMessagingService Yahoo;
    public static InstantMessagingService Icq;
    public static InstantMessagingService Jabber;
    public static InstantMessagingService Other;
}
[AttributeUsageAttribute("1")]
public class Intersoft.Crosslight.IntersoftLicenseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    public string LicenseData { get; private set; }
    public IntersoftLicenseAttribute(string licenseData);
    [CompilerGeneratedAttribute]
public string get_LicenseData();
    [CompilerGeneratedAttribute]
private void set_LicenseData(string value);
}
public interface Intersoft.Crosslight.IObservableResource {
    public bool IsDisposed { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual string GetPropertyValue(string property);
    public abstract virtual string GetString(string key);
    public abstract virtual string GetString(string key, CultureInfo culture);
}
public interface Intersoft.Crosslight.IPopupControl {
    public abstract virtual void Show(Action`1<PopupCloseAction> closeCallback);
    public abstract virtual void Close();
    public abstract virtual void Destroy();
}
public interface Intersoft.Crosslight.IPresenter {
    public abstract virtual void SetOwner(object owner);
    public abstract virtual void Show(string message);
}
public interface Intersoft.Crosslight.IPresenterService {
    public abstract virtual T GetPresenter();
    public abstract virtual void Register();
}
public interface Intersoft.Crosslight.IPropertyAccessor {
    public abstract virtual object GetValue(string propertyName);
    public abstract virtual void SetValue(string propertyName, object value);
    public abstract virtual bool HasPropertyAccessor(string propertyName);
    public abstract virtual Type GetType(string propertyName);
}
public interface Intersoft.Crosslight.IResourceCacheService {
    public abstract virtual IList`1<ResourceCacheItem> GetCachedItems(IResourceCacheSession session);
    public abstract virtual Task`1<IResourceCacheSession> OpenCacheSession(string id, IResourceCacheSettings settings);
    public abstract virtual Task`1<Byte[]> GetCachedResource(IResourceCacheSession session, string url, Nullable`1<DateTime> lastModifiedDate);
    public abstract virtual Task AddToCache(IResourceCacheSession session, string url, Byte[] data, ResourceCacheMode cacheMode, Nullable`1<DateTime> lastModifiedDate, Nullable`1<DateTime> expireDate);
    public abstract virtual ResourceCacheItem GetCachedItem(IResourceCacheSession session, string url);
    public abstract virtual Task RemoveFromCache(IResourceCacheSession session, string url);
    public abstract virtual Task ClearCache(IResourceCacheSession session);
    public abstract virtual Task SaveCacheSession(IResourceCacheSession session);
}
public interface Intersoft.Crosslight.IResourceCacheSession {
    public string PersistenceId { get; }
    public Guid SessionId { get; }
    public IResourceCacheSettings Settings { get; }
    public abstract virtual string get_PersistenceId();
    public abstract virtual Guid get_SessionId();
    public abstract virtual IResourceCacheSettings get_Settings();
}
public interface Intersoft.Crosslight.IResourceCacheSettings {
    public int MaxDiskCacheSize { get; }
    public int MaxMemoryCacheSize { get; }
    public abstract virtual int get_MaxDiskCacheSize();
    public abstract virtual int get_MaxMemoryCacheSize();
}
public interface Intersoft.Crosslight.IResourceLoaderContext {
    public string Url { get; }
    public CancellationTokenSource CancellationToken { get; }
    public IDictionary`2<string, string> Headers { get; }
    public object UserData { get; }
    public abstract virtual string get_Url();
    public abstract virtual CancellationTokenSource get_CancellationToken();
    public abstract virtual IDictionary`2<string, string> get_Headers();
    public abstract virtual object get_UserData();
}
public interface Intersoft.Crosslight.IResourceLoaderDelegate {
    public abstract virtual void Started(IResourceLoaderContext context);
    public abstract virtual void Progress(IResourceLoaderContext context, IResourceLoaderProgress progress);
    public abstract virtual void Completed(IResourceLoaderContext context, Byte[] resultData);
    public abstract virtual void Failed(IResourceLoaderContext context, Exception error);
    public abstract virtual void Canceled(IResourceLoaderContext context, string reason);
}
public interface Intersoft.Crosslight.IResourceLoaderProgress {
    public int PercentCompleted { get; }
    public long BytesReceived { get; }
    public long TotalBytes { get; }
    public abstract virtual int get_PercentCompleted();
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_TotalBytes();
}
public interface Intersoft.Crosslight.IResourceLoaderService {
    public abstract virtual void CancelLoad(CancellationTokenSource cancellationToken);
    public abstract virtual Task`1<Byte[]> LoadResourceAsync(string url, object userData, IResourceLoaderDelegate loaderDelegate, CancellationTokenSource cancellationToken);
}
public interface Intersoft.Crosslight.IService {
}
public interface Intersoft.Crosslight.IServiceAccessor {
    public abstract virtual TService GetService();
    public abstract virtual TService GetService(bool newInstance);
}
public interface Intersoft.Crosslight.IServiceInitializer {
    public abstract virtual void InitializeServices(IApplicationHost host);
}
public interface Intersoft.Crosslight.ISupportBackNavigation {
    public DelegateCommand GoBackCommand { get; }
    public abstract virtual DelegateCommand get_GoBackCommand();
}
public interface Intersoft.Crosslight.ISupportCancellation {
    public abstract virtual void Cancel();
}
public interface Intersoft.Crosslight.ISupportIncrementalLoading {
    public bool IsDataLoading { get; public set; }
    public bool EnableIncrementalLoading { get; public set; }
    public bool HasMoreItems { get; }
    public abstract virtual bool get_IsDataLoading();
    public abstract virtual void set_IsDataLoading(bool value);
    public abstract virtual bool get_EnableIncrementalLoading();
    public abstract virtual void set_EnableIncrementalLoading(bool value);
    public abstract virtual bool get_HasMoreItems();
    public abstract virtual void LoadDataIncremental();
}
public interface Intersoft.Crosslight.ISupportItemBinding {
    public Dictionary`2<Type, IItemBindingAdapter> ItemBindingAdapters { get; }
    public abstract virtual Dictionary`2<Type, IItemBindingAdapter> get_ItemBindingAdapters();
}
public interface Intersoft.Crosslight.ISupportLocalization {
    public IObservableResource Resources { get; }
    public abstract virtual IObservableResource get_Resources();
}
public interface Intersoft.Crosslight.ISupportMobileService {
    public IMobileService MobileService { get; }
    public abstract virtual IMobileService get_MobileService();
}
public interface Intersoft.Crosslight.ISupportRefresh {
    public bool IsDataLoading { get; public set; }
    public bool EnableRefresh { get; public set; }
    public bool EnableIncrementalRefresh { get; public set; }
    public abstract virtual bool get_IsDataLoading();
    public abstract virtual void set_IsDataLoading(bool value);
    public abstract virtual bool get_EnableRefresh();
    public abstract virtual void set_EnableRefresh(bool value);
    public abstract virtual bool get_EnableIncrementalRefresh();
    public abstract virtual void set_EnableIncrementalRefresh(bool value);
    public abstract virtual void RefreshData();
}
public interface Intersoft.Crosslight.ISupportViewModel {
    public IViewModel ViewModel { get; }
    public abstract virtual IViewModel get_ViewModel();
}
public interface Intersoft.Crosslight.ISyncService {
    public abstract virtual void CancelSync(IAccount account, string provider);
    public abstract virtual void DisableSync(IAccount account, string provider);
    public abstract virtual void EnableSync(IAccount account, long interval, string provider);
}
public class Intersoft.Crosslight.ItemBindingDescription : ItemBindingDescriptionBase {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private String[] g;
    public string DetailMemberPath { get; public set; }
    public string ImageMemberPath { get; public set; }
    public string ImageModifiedDateMemberPath { get; public set; }
    public string NavigateMemberPath { get; public set; }
    public string ValueMemberPath { get; public set; }
    public string ImagePlaceholder { get; public set; }
    public String[] AdditionalImageViewTarget { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DetailMemberPath();
    [CompilerGeneratedAttribute]
public void set_DetailMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImageMemberPath();
    [CompilerGeneratedAttribute]
public void set_ImageMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImageModifiedDateMemberPath();
    [CompilerGeneratedAttribute]
public void set_ImageModifiedDateMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_NavigateMemberPath();
    [CompilerGeneratedAttribute]
public void set_NavigateMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ValueMemberPath();
    [CompilerGeneratedAttribute]
public void set_ValueMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_ImagePlaceholder();
    [CompilerGeneratedAttribute]
public void set_ImagePlaceholder(string value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalImageViewTarget();
    [CompilerGeneratedAttribute]
public void set_AdditionalImageViewTarget(String[] value);
    public ItemBindingDescription Clone();
}
public abstract class Intersoft.Crosslight.ItemBindingDescriptionBase : object {
    private List`1<BindingContext> h;
    private List`1<BindingContext> i;
    [CompilerGeneratedAttribute]
private string j;
    [CompilerGeneratedAttribute]
private string k;
    public string ItemsMemberPath { get; public set; }
    public string DisplayMemberPath { get; public set; }
    public List`1<BindingContext> ItemBindings { get; }
    public List`1<BindingContext> GroupBindings { get; }
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public string get_ItemsMemberPath();
    [CompilerGeneratedAttribute]
public void set_ItemsMemberPath(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayMemberPath();
    [CompilerGeneratedAttribute]
public void set_DisplayMemberPath(string value);
    public List`1<BindingContext> get_ItemBindings();
    public virtual List`1<BindingContext> get_GroupBindings();
    public void AddBinding(string targetViewId, BindableProperty property, BindingDescription bindingDescription);
    public void AddBinding(string targetViewId, BindableProperty property, string path);
    public void AddViewModelBinding(string targetViewId, BindableProperty property, string path);
    public void AddBinding(string targetViewId, BindableProperty property, BindingDescription bindingDescription, TargetBindingType targetBindingType);
    public void AddViewModelBinding(string targetViewId, BindableProperty property, BindingDescription bindingDescription, TargetBindingType targetBindingType);
    public void AddBinding(string targetViewId, BindableProperty property, string path, TargetBindingType targetBindingType);
    public void AddViewModelBinding(string targetViewId, BindableProperty property, string path, TargetBindingType targetBindingType);
    public void CopyBindingsFrom(ItemBindingDescriptionBase sourceBinding);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
public interface Intersoft.Crosslight.IToastPresenter {
    public abstract virtual void Show(string message, double duration);
    public abstract virtual void Show(string message, string title);
    public abstract virtual void Show(string message, string title, string image);
    public abstract virtual void Show(string message, string title, double duration);
    public abstract virtual void Show(string message, string title, string image, double duration);
    public abstract virtual void Show(string message, string title, string image, double duration, ToastGravity gravity);
    public abstract virtual void Show(string message, string title, string image, ToastSettings settings);
}
public interface Intersoft.Crosslight.ITracer {
}
public interface Intersoft.Crosslight.ITrackChanges {
    public bool SuspendTrackChanges { get; public set; }
    public abstract virtual bool get_SuspendTrackChanges();
    public abstract virtual void set_SuspendTrackChanges(bool value);
}
public interface Intersoft.Crosslight.IValueConverter {
    public abstract virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public interface Intersoft.Crosslight.IView {
    public abstract virtual IViewContext GetViewContext();
    public abstract virtual float GetHeight();
    public abstract virtual void InvalidateSize(bool isInitializing);
    public abstract virtual void VisibilityChanged(bool isVisible);
    public abstract virtual void EnabledChanged(bool isEnabled);
}
public interface Intersoft.Crosslight.IViewBuilder {
    public string EditorIdentifier { get; }
    public ComponentType ComponentType { get; }
    public abstract virtual string get_EditorIdentifier();
    public abstract virtual ComponentType get_ComponentType();
    public abstract virtual T Build(object viewHost, ComponentDefinitionBase definition);
}
public interface Intersoft.Crosslight.IViewContext {
    public abstract virtual object FindName(string name);
    public abstract virtual T FindName(string name);
    public abstract virtual void OnViewDismissed(NavigationResult result);
}
public interface Intersoft.Crosslight.IViewModel {
    public IApplicationContext Context { get; }
    public string Title { get; public set; }
    public abstract virtual IApplicationContext get_Context();
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual void DisposeServices();
}
public interface Intersoft.Crosslight.IViewModelBinder {
    public abstract virtual void PerformBinding(IViewModel viewModel, object model);
}
public interface Intersoft.Crosslight.IViewModelBinder`2 {
    public abstract virtual void PerformBinding(TViewModel viewModel, TModel model);
}
public interface Intersoft.Crosslight.IViewModelInitializer {
    public abstract virtual void SetViewModel(IViewModel viewModel);
}
public interface Intersoft.Crosslight.IViewNotification {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ViewDismissed(EventHandler`1<DismissViewEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ViewDismissed(EventHandler`1<DismissViewEventArgs> value);
}
public interface Intersoft.Crosslight.IViewService {
    public abstract virtual object FindName(object view, string name);
    public abstract virtual T FindName(object view, string name);
    public abstract virtual bool IsRunningOnUIThread();
    public abstract virtual void RunOnUIThread(Action action);
    public abstract virtual void RunOnUIThreadIfNeeded(Action action);
    public abstract virtual IAsyncResult RunOnBackgroundThread(Action action, int delay);
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.IViewServiceExtensions : object {
    [ExtensionAttribute]
public static void RunOnUIThread(IViewService viewService, Action action, int delay);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
public class Intersoft.Crosslight.JsonArray : List`1<object> {
    public JsonArray(int capacity);
    public virtual string ToString();
    internal static int RggyKZUybHji(int a);
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
public class Intersoft.Crosslight.JsonObject : object {
    private Dictionary`2<string, object> a;
    public object Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JsonObject(IEqualityComparer`1<string> comparer);
    public object get_Item(int index);
    internal static object GetAtIndex(IDictionary`2<string, object> a, int b);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
public class Intersoft.Crosslight.JsonSerializationOptions : object {
    public static JsonSerializationOptions Default;
    [CompilerGeneratedAttribute]
private DateTimeKind a;
    [CompilerGeneratedAttribute]
private bool b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, Type> d;
    public DateTimeKind DateTimeSerializationMode { get; public set; }
    public bool SerializeEmptyValue { get; public set; }
    internal string PropertyName { get; internal set; }
    internal IDictionary`2<object, Type> SubClassObjects { get; internal set; }
    private static JsonSerializationOptions();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeSerializationMode();
    [CompilerGeneratedAttribute]
public void set_DateTimeSerializationMode(DateTimeKind value);
    [CompilerGeneratedAttribute]
public bool get_SerializeEmptyValue();
    [CompilerGeneratedAttribute]
public void set_SerializeEmptyValue(bool value);
    [CompilerGeneratedAttribute]
internal string get_PropertyName();
    [CompilerGeneratedAttribute]
internal void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<object, Type> get_SubClassObjects();
    [CompilerGeneratedAttribute]
internal void set_SubClassObjects(IDictionary`2<object, Type> value);
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.KeepAliveAttribute : Attribute {
}
public enum Intersoft.Crosslight.LocalFolderKind : Enum {
    public int value__;
    public static LocalFolderKind Data;
    public static LocalFolderKind Documents;
    public static LocalFolderKind Downloads;
    public static LocalFolderKind Cache;
    public static LocalFolderKind Temporary;
    public static LocalFolderKind Custom;
}
public class Intersoft.Crosslight.LocalizableNavigationItem : NavigationItem {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private IObservableResource d;
    public string TitleKey { get; public set; }
    public string DetailKey { get; public set; }
    public string GroupKey { get; public set; }
    public IObservableResource Resources { get; public set; }
    private IObservableResource ResolvedResources { get; }
    public string Title { get; public set; }
    public string Group { get; public set; }
    public LocalizableNavigationItem(string titleKey, NavigationTarget target);
    public LocalizableNavigationItem(string titleKey, string groupKey, NavigationTarget target);
    public LocalizableNavigationItem(string titleKey, string groupKey, Type targetType);
    public LocalizableNavigationItem(string titleKey, string groupKey, ICommand command);
    public LocalizableNavigationItem(string titleKey, Type targetType);
    [CompilerGeneratedAttribute]
public string get_TitleKey();
    [CompilerGeneratedAttribute]
public void set_TitleKey(string value);
    [CompilerGeneratedAttribute]
public string get_DetailKey();
    [CompilerGeneratedAttribute]
public void set_DetailKey(string value);
    [CompilerGeneratedAttribute]
public string get_GroupKey();
    [CompilerGeneratedAttribute]
public void set_GroupKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IObservableResource get_Resources();
    [CompilerGeneratedAttribute]
public void set_Resources(IObservableResource value);
    private IObservableResource get_ResolvedResources();
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual string get_Group();
    public virtual void set_Group(string value);
}
public class Intersoft.Crosslight.LocalizationService : object {
    private CultureInfo a;
    private List`1<WeakReference> b;
    private Dictionary`2<Type, IObservableResource> c;
    [CompilerGeneratedAttribute]
private IObservableResource d;
    [CompilerGeneratedAttribute]
private CultureInfo e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private bool g;
    private IObservableResource DefaultResource { get; private set; }
    private Dictionary`2<Type, IObservableResource> ObservableResources { get; }
    public CultureInfo CurrentUICulture { get; }
    public CultureInfo CurrencyCulture { get; public set; }
    public string CurrencyFormat { get; public set; }
    public bool AutoUpdateBindings { get; public set; }
    [CompilerGeneratedAttribute]
private IObservableResource get_DefaultResource();
    [CompilerGeneratedAttribute]
private void set_DefaultResource(IObservableResource value);
    private Dictionary`2<Type, IObservableResource> get_ObservableResources();
    public sealed virtual CultureInfo get_CurrentUICulture();
    [CompilerGeneratedAttribute]
public sealed virtual CultureInfo get_CurrencyCulture();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CurrencyCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CurrencyFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CurrencyFormat(string value);
    private void AddWeakReferenceHandler(List`1& a, EventHandler b, int c);
    private void CallWeakReferenceHandlers(List`1<WeakReference> a);
    private void RemoveWeakReferenceHandler(List`1<WeakReference> a, EventHandler b);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AutoUpdateBindings();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AutoUpdateBindings(bool value);
    public sealed virtual void add_CultureChanged(EventHandler value);
    public sealed virtual void remove_CultureChanged(EventHandler value);
    public sealed virtual IObservableResource GetResource();
    public sealed virtual string GetString(string resourceKey);
    public sealed virtual string GetString(string resourceKey);
    public sealed virtual void RegisterDefaultResource(IObservableResource resource);
    public sealed virtual void RegisterResource(IObservableResource resource);
    public sealed virtual void SetCulture(CultureInfo culture);
    public sealed virtual void SetUICulture(CultureInfo culture);
}
public class Intersoft.Crosslight.LocalNotification : Notification {
    [CompilerGeneratedAttribute]
private DateTime i;
    [CompilerGeneratedAttribute]
private bool j;
    [CompilerGeneratedAttribute]
private DateTimeInterval k;
    public DateTime ScheduledDate { get; public set; }
    public bool AutoRepeat { get; public set; }
    public DateTimeInterval RepeatInterval { get; public set; }
    public LocalNotification(Guid guid);
    public LocalNotification(string message, string title);
    public LocalNotification(string message, string title, DateTime scheduledDate);
    [CompilerGeneratedAttribute]
public DateTime get_ScheduledDate();
    [CompilerGeneratedAttribute]
public void set_ScheduledDate(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_AutoRepeat();
    [CompilerGeneratedAttribute]
public void set_AutoRepeat(bool value);
    [CompilerGeneratedAttribute]
public DateTimeInterval get_RepeatInterval();
    [CompilerGeneratedAttribute]
public void set_RepeatInterval(DateTimeInterval value);
}
public class Intersoft.Crosslight.Logger : object {
    public static bool EnablePerfLog;
    private static Nullable`1<DateTime> _capturedTime;
    public static void CaptureTime();
    public static void LogPerf(object obj, string message);
    private static ILog GetLogger(object a);
    internal static void Debug(object a, string b, Object[] c);
    internal static void Error(object a, string b, Exception c);
}
public class Intersoft.Crosslight.LogService : object {
    private Dictionary`2<Type, Type> a;
    public sealed virtual ILog GetLogger();
    public sealed virtual ILog GetLogger(string category);
    public sealed virtual ILog GetLogger(Type type);
    public sealed virtual void Register();
    public sealed virtual void RegisterByCategory(Func`2<IDependencyResolver, Func`2<string, ILog>> func);
    public sealed virtual void RegisterByType(Func`2<IDependencyResolver, Func`2<Type, ILog>> func);
    public sealed virtual void RegisterEventSource();
    public sealed virtual TEventSource GetEventSource(Type type);
}
public enum Intersoft.Crosslight.MailComposeStatus : Enum {
    public int value__;
    public static MailComposeStatus Cancelled;
    public static MailComposeStatus Saved;
    public static MailComposeStatus Sent;
    public static MailComposeStatus Failed;
}
internal class Intersoft.Crosslight.ManagedPropertyBag : object {
    private static Dictionary`2<string, object> _properties;
    private static ManagedPropertyBag();
    internal static object GetValue(object a, string b);
    internal static void ClearValue(object a);
    internal static void ClearValue(int a, string b);
    internal static object GetValue(int a, string b);
    internal static void SetValue(object a, string b, object c);
    internal static void SetValueStrong(object a, string b, object c);
    internal static void SetValue(int a, string b, object c);
    private static void SetValue(int a, string b, object c, bool d);
    internal static bool IsPrimitive(object a);
}
public enum Intersoft.Crosslight.MapDirectionMode : Enum {
    public int value__;
    public static MapDirectionMode Driving;
    public static MapDirectionMode Walking;
}
public enum Intersoft.Crosslight.MediaLibraryType : Enum {
    public int value__;
    public static MediaLibraryType Auto;
    public static MediaLibraryType SystemPhotoAlbum;
    public static MediaLibraryType PhotoLibrary;
}
public class Intersoft.Crosslight.Mobile.Address : FrameworkModel {
    private AddressType b;
    private string c;
    private string d;
    private string e;
    private string f;
    private string g;
    private string h;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public AddressType Type { get; public set; }
    public string Label { get; public set; }
    public string StreetAddress { get; public set; }
    public string City { get; public set; }
    public string Region { get; public set; }
    public string Country { get; public set; }
    public string PostalCode { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public AddressType get_Type();
    public void set_Type(AddressType value);
    public string get_Label();
    public void set_Label(string value);
    public string get_StreetAddress();
    public void set_StreetAddress(string value);
    public string get_City();
    public void set_City(string value);
    public string get_Region();
    public void set_Region(string value);
    public string get_Country();
    public void set_Country(string value);
    public string get_PostalCode();
    public void set_PostalCode(string value);
}
public class Intersoft.Crosslight.Mobile.CameraCaptureSettings : object {
    [CompilerGeneratedAttribute]
private CameraCaptureMode a;
    [CompilerGeneratedAttribute]
private CameraMediaType b;
    [CompilerGeneratedAttribute]
private CameraDeviceKind c;
    [CompilerGeneratedAttribute]
private CameraFlashMode d;
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private ImageResultMode f;
    [CompilerGeneratedAttribute]
private int g;
    [CompilerGeneratedAttribute]
private int h;
    public CameraCaptureMode CaptureMode { get; public set; }
    public CameraMediaType MediaType { get; public set; }
    public CameraDeviceKind DeviceKind { get; public set; }
    public CameraFlashMode FlashMode { get; public set; }
    public bool AllowEditing { get; public set; }
    public ImageResultMode ImageResultMode { get; public set; }
    public int ThumbnailWidth { get; public set; }
    public int ThumbnailHeight { get; public set; }
    [CompilerGeneratedAttribute]
public CameraCaptureMode get_CaptureMode();
    [CompilerGeneratedAttribute]
public void set_CaptureMode(CameraCaptureMode value);
    [CompilerGeneratedAttribute]
public CameraMediaType get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(CameraMediaType value);
    [CompilerGeneratedAttribute]
public CameraDeviceKind get_DeviceKind();
    [CompilerGeneratedAttribute]
public void set_DeviceKind(CameraDeviceKind value);
    [CompilerGeneratedAttribute]
public CameraFlashMode get_FlashMode();
    [CompilerGeneratedAttribute]
public void set_FlashMode(CameraFlashMode value);
    [CompilerGeneratedAttribute]
public bool get_AllowEditing();
    [CompilerGeneratedAttribute]
public void set_AllowEditing(bool value);
    [CompilerGeneratedAttribute]
public ImageResultMode get_ImageResultMode();
    [CompilerGeneratedAttribute]
public void set_ImageResultMode(ImageResultMode value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailWidth();
    [CompilerGeneratedAttribute]
public void set_ThumbnailWidth(int value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailHeight();
    [CompilerGeneratedAttribute]
public void set_ThumbnailHeight(int value);
    public ImagePickerSettings GetImageSettings();
}
public class Intersoft.Crosslight.Mobile.ComposeMailResult : object {
    [CompilerGeneratedAttribute]
private MailComposeStatus a;
    [CompilerGeneratedAttribute]
private Exception b;
    public MailComposeStatus Status { get; private set; }
    public Exception Error { get; private set; }
    public ComposeMailResult(MailComposeStatus status);
    public ComposeMailResult(Exception error);
    [CompilerGeneratedAttribute]
public MailComposeStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(MailComposeStatus value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
}
public class Intersoft.Crosslight.Mobile.Contact : FrameworkModel {
    private string j;
    private string k;
    private string l;
    private string m;
    private string n;
    private string o;
    private string p;
    public Byte[] _photo;
    private List`1<Relationship> q;
    private List`1<Address> r;
    private List`1<InstantMessagingAccount> s;
    private List`1<Website> t;
    private List`1<Organization> u;
    private List`1<Note> v;
    private List`1<Email> w;
    private List`1<Phone> x;
    [CompilerGeneratedAttribute]
private string i;
    public string Id { get; public set; }
    public string DisplayName { get; public set; }
    public string Prefix { get; public set; }
    public string FirstName { get; public set; }
    public string MiddleName { get; public set; }
    public string LastName { get; public set; }
    public string Nickname { get; public set; }
    public string Suffix { get; public set; }
    public Byte[] Photo { get; public set; }
    public List`1<Relationship> Relationships { get; }
    public List`1<Address> Addresses { get; }
    public List`1<InstantMessagingAccount> InstantMessagingAccounts { get; }
    public List`1<Website> Websites { get; }
    public List`1<Organization> Organizations { get; }
    public List`1<Note> Notes { get; }
    public List`1<Email> Emails { get; }
    public List`1<Phone> Phones { get; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_FirstName();
    public void set_FirstName(string value);
    public string get_MiddleName();
    public void set_MiddleName(string value);
    public string get_LastName();
    public void set_LastName(string value);
    public string get_Nickname();
    public void set_Nickname(string value);
    public string get_Suffix();
    public void set_Suffix(string value);
    public Byte[] get_Photo();
    public void set_Photo(Byte[] value);
    public List`1<Relationship> get_Relationships();
    public List`1<Address> get_Addresses();
    public List`1<InstantMessagingAccount> get_InstantMessagingAccounts();
    public List`1<Website> get_Websites();
    public List`1<Organization> get_Organizations();
    public List`1<Note> get_Notes();
    public List`1<Email> get_Emails();
    public List`1<Phone> get_Phones();
}
public class Intersoft.Crosslight.Mobile.ContactPickerResult : object {
    [CompilerGeneratedAttribute]
private Contact a;
    [CompilerGeneratedAttribute]
private bool b;
    public Contact Contact { get; private set; }
    public bool IsCancelled { get; private set; }
    public ContactPickerResult(Contact contact);
    public ContactPickerResult(bool isCancelled);
    [CompilerGeneratedAttribute]
public Contact get_Contact();
    [CompilerGeneratedAttribute]
private void set_Contact(Contact value);
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
}
public class Intersoft.Crosslight.Mobile.Email : FrameworkModel {
    private EmailType b;
    private string c;
    private string y;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public EmailType Type { get; public set; }
    public string Label { get; public set; }
    public string Address { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public EmailType get_Type();
    public void set_Type(EmailType value);
    public string get_Label();
    public void set_Label(string value);
    public string get_Address();
    public void set_Address(string value);
}
public interface Intersoft.Crosslight.Mobile.IBrowserService {
    public abstract virtual void Navigate(string url);
}
public interface Intersoft.Crosslight.Mobile.ICameraService {
    public abstract virtual void Capture(CameraCaptureMode mode, Action`1<MediaPickerResult> resultCallback);
    public abstract virtual void Capture(CameraCaptureSettings settings, Action`1<MediaPickerResult> resultCallback);
}
public interface Intersoft.Crosslight.Mobile.IContactService {
    public abstract virtual IEnumerable`1<Contact> LoadContacts();
    public abstract virtual bool SaveContact(Contact contact);
    public abstract virtual bool DeleteContact(Contact contact);
    public abstract virtual void PickContact(Action`1<ContactPickerResult> callback);
}
public interface Intersoft.Crosslight.Mobile.ILocalStorageService {
    public abstract virtual Task`1<Byte[]> ReadFileAsync(string fileName, LocalFolderKind folderKind);
    public abstract virtual Task`1<string> ReadTextFileAsync(string fileName, LocalFolderKind folderKind);
    public abstract virtual Task`1<bool> WriteFileAsync(Byte[] data, string fileName, LocalFolderKind folderKind, FileWriteMode writeMode);
    public abstract virtual Task`1<bool> WriteTextFileAsync(string data, string fileName, LocalFolderKind folderKind, FileWriteMode writeMode);
    public abstract virtual Task`1<bool> DeleteFileAsync(string fileName, LocalFolderKind folderKind);
    public abstract virtual bool IsFileExisted(string fileName, LocalFolderKind folderKind);
    public abstract virtual string GetFolderPath(LocalFolderKind folderKind);
    public abstract virtual string GetFilePath(string fileName, LocalFolderKind folderKind);
    public abstract virtual Task`1<LocalFileInfo> GetFileInfoAsync(string fileName, LocalFolderKind folderKind);
    public abstract virtual Task`1<List`1<LocalFileInfo>> GetFilesAsync(string searchPattern, LocalFolderKind folderKind);
    public abstract virtual Task`1<bool> RenameFileAsync(string sourceName, string targetName, LocalFolderKind folderKind);
}
public interface Intersoft.Crosslight.Mobile.ILocationService {
    public abstract virtual void GetCurrentLocation(double desiredAccuracy, Action`1<LocationResult> resultCallback);
    public abstract virtual void GetPlacemark(PlacemarkAddress address, Action`1<PlacemarkResult> resultCallback);
    public abstract virtual void GetPlacemarks(Location location, Action`1<IList`1<PlacemarkResult>> resultCallback);
    public abstract virtual bool IsLocationInRange(LocationCoordinate sourcelocation, LocationCoordinate targetLocation, double radius);
}
public class Intersoft.Crosslight.Mobile.ImagePickerSettings : object {
    [CompilerGeneratedAttribute]
private ImageResultMode a;
    [CompilerGeneratedAttribute]
private int b;
    [CompilerGeneratedAttribute]
private int c;
    [CompilerGeneratedAttribute]
private bool d;
    public ImageResultMode ImageResultMode { get; public set; }
    public int ThumbnailWidth { get; public set; }
    public int ThumbnailHeight { get; public set; }
    public bool UseEditedImage { get; public set; }
    [CompilerGeneratedAttribute]
public ImageResultMode get_ImageResultMode();
    [CompilerGeneratedAttribute]
public void set_ImageResultMode(ImageResultMode value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailWidth();
    [CompilerGeneratedAttribute]
public void set_ThumbnailWidth(int value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailHeight();
    [CompilerGeneratedAttribute]
public void set_ThumbnailHeight(int value);
    [CompilerGeneratedAttribute]
public bool get_UseEditedImage();
    [CompilerGeneratedAttribute]
public void set_UseEditedImage(bool value);
}
public interface Intersoft.Crosslight.Mobile.IMailService {
    public abstract virtual void ComposeMail(string to, string subject, string body, Action`1<ComposeMailResult> resultCallback);
    public abstract virtual void ComposeMail(MailMessage mailMessage, Action`1<ComposeMailResult> resultCallback);
}
public interface Intersoft.Crosslight.Mobile.IMapService {
    public abstract virtual void Navigate(Placemark placemark, int zoomScale);
    public abstract virtual void NavigateToCurrentLocation();
    public abstract virtual void ShowDirections(Placemark from, Placemark destination, MapDirectionMode directionMode);
}
public interface Intersoft.Crosslight.Mobile.IMediaLibraryService {
    public abstract virtual void ShowPicker(MediaLibrarySettings settings, Action`1<MediaPickerResult> resultCallback);
}
public interface Intersoft.Crosslight.Mobile.IMediaService {
    public abstract virtual void PlaySound(string soundFile);
    public abstract virtual void OpenMusicApp();
    public abstract virtual void OpenVideoApp();
    public abstract virtual void OpenYouTube(string videoId);
}
public interface Intersoft.Crosslight.Mobile.IMessagingService {
    public abstract virtual void SendMessage(string phoneNumber);
}
public interface Intersoft.Crosslight.Mobile.IMobileComponent {
    public abstract virtual bool IsSupported();
    public abstract virtual void Initialize();
}
public interface Intersoft.Crosslight.Mobile.IMobileComponentService {
    public abstract virtual void SetOwner(object owner);
}
public interface Intersoft.Crosslight.Mobile.INotificationService {
    public abstract virtual void ScheduleLocalNotification(string message, string title);
    public abstract virtual void ScheduleLocalNotification(LocalNotification notification);
    public abstract virtual void CancelLocalNotification(Guid notificationIdentifier);
    public abstract virtual void CancelAllLocalNotifications();
}
public class Intersoft.Crosslight.Mobile.InstantMessagingAccount : FrameworkModel {
    private InstantMessagingService z;
    private string aa;
    private string ab;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public InstantMessagingService Service { get; public set; }
    public string ServiceLabel { get; public set; }
    public string Account { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public InstantMessagingService get_Service();
    public void set_Service(InstantMessagingService value);
    public string get_ServiceLabel();
    public void set_ServiceLabel(string value);
    public string get_Account();
    public void set_Account(string value);
}
public interface Intersoft.Crosslight.Mobile.IReachabilityService {
    public abstract virtual NetworkConnectionStatus GetConnectionStatus();
    public abstract virtual void GetHostReachability(string host, Action`1<ReachabilityResult> resultCallback);
    public abstract virtual void StartMonitoringReachabilityChanges(ReachabilityChangesDelegate reachabilityChangesDelegate);
    public abstract virtual void StopMonitoringReachabilityChanges(ReachabilityChangesDelegate reachabilityChangesDelegate);
    public abstract virtual void ShowNetworkActivityIndicator();
    public abstract virtual void HideNetworkActivityIndicator();
}
public interface Intersoft.Crosslight.Mobile.ISocialService {
    public abstract virtual void ShowShareOptions(string text, Object[] additionalData, ShareActivityType activityType);
    public abstract virtual void PostToFacebook(string text, Byte[] image, IEnumerable`1<Byte[]> additionalImages);
    public abstract virtual void PostToTwitter(string text, Byte[] image, IEnumerable`1<Byte[]> additionalImages);
}
public interface Intersoft.Crosslight.Mobile.ITelephonyService {
    public abstract virtual void Call(string phoneNumber);
}
public class Intersoft.Crosslight.Mobile.LocalFileInfo : object {
    [CompilerGeneratedAttribute]
private LocalFolderKind a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private DateTime c;
    [CompilerGeneratedAttribute]
private DateTime d;
    [CompilerGeneratedAttribute]
private DateTime e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private long h;
    public LocalFolderKind FolderKind { get; internal set; }
    public string FullName { get; internal set; }
    public DateTime CreationTime { get; internal set; }
    public DateTime LastAccessTime { get; internal set; }
    public DateTime LastWriteTime { get; internal set; }
    public string Name { get; internal set; }
    public string Extension { get; internal set; }
    public long Length { get; internal set; }
    [CompilerGeneratedAttribute]
public LocalFolderKind get_FolderKind();
    [CompilerGeneratedAttribute]
internal void set_FolderKind(LocalFolderKind value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
internal void set_FullName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreationTime();
    [CompilerGeneratedAttribute]
internal void set_CreationTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastAccessTime();
    [CompilerGeneratedAttribute]
internal void set_LastAccessTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastWriteTime();
    [CompilerGeneratedAttribute]
internal void set_LastWriteTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
internal void set_Extension(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(long value);
}
public class Intersoft.Crosslight.Mobile.Location : FrameworkModel {
    private double ac;
    private LocationCoordinate ad;
    private double ae;
    private double af;
    private double ag;
    private DateTime ah;
    private double ai;
    public double Altitude { get; public set; }
    public LocationCoordinate Coordinate { get; public set; }
    public double Course { get; public set; }
    public double HorizontalAccuracy { get; public set; }
    public double Speed { get; public set; }
    public DateTime Timestamp { get; public set; }
    public double VerticalAccuracy { get; public set; }
    public Location(LocationCoordinate coordinate);
    public double get_Altitude();
    public void set_Altitude(double value);
    public LocationCoordinate get_Coordinate();
    public void set_Coordinate(LocationCoordinate value);
    public double get_Course();
    public void set_Course(double value);
    public double get_HorizontalAccuracy();
    public void set_HorizontalAccuracy(double value);
    public double get_Speed();
    public void set_Speed(double value);
    public DateTime get_Timestamp();
    public void set_Timestamp(DateTime value);
    public double get_VerticalAccuracy();
    public void set_VerticalAccuracy(double value);
}
public static class Intersoft.Crosslight.Mobile.LocationAccuracy : object {
    public static double Best;
    public static double NearestTenMeters;
    public static double HundredMeters;
    public static double Kilometer;
    public static double ThreeKilometers;
}
public class Intersoft.Crosslight.Mobile.LocationCoordinate : FrameworkModel {
    [CompilerGeneratedAttribute]
private double am;
    [CompilerGeneratedAttribute]
private double an;
    public double Latitude { get; private set; }
    public double Longitude { get; private set; }
    public LocationCoordinate(double latitude, double longitude);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
private void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
private void set_Longitude(double value);
}
public class Intersoft.Crosslight.Mobile.LocationRegion : FrameworkModel {
    private LocationCoordinate aj;
    private double ak;
    private string al;
    public LocationCoordinate Center { get; public set; }
    public double Radius { get; public set; }
    public string Name { get; public set; }
    public LocationCoordinate get_Center();
    public void set_Center(LocationCoordinate value);
    public double get_Radius();
    public void set_Radius(double value);
    public string get_Name();
    public void set_Name(string value);
}
public class Intersoft.Crosslight.Mobile.LocationResult : object {
    [CompilerGeneratedAttribute]
private Location a;
    [CompilerGeneratedAttribute]
private Exception b;
    public Location Location { get; private set; }
    public Exception Error { get; private set; }
    public LocationResult(Location location);
    public LocationResult(Exception error);
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Location value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
}
public class Intersoft.Crosslight.Mobile.MailAttachment : object {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private Byte[] c;
    public string FileName { get; public set; }
    public string MimeType { get; public set; }
    public Byte[] Data { get; public set; }
    public MailAttachment(string fileName, string mimeType, Byte[] data);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
public void set_MimeType(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
}
public class Intersoft.Crosslight.Mobile.MailMessage : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> a;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> b;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MailAttachment> g;
    public IEnumerable`1<string> ToRecipients { get; private set; }
    public IEnumerable`1<string> CcRecipients { get; private set; }
    public IEnumerable`1<string> BccRecipients { get; private set; }
    public string Subject { get; public set; }
    public string Body { get; public set; }
    public bool IsHTML { get; public set; }
    public IEnumerable`1<MailAttachment> Attachments { get; private set; }
    public MailMessage(string to, string subject, string body);
    public MailMessage(string to, string subject, string body, bool isHTML);
    public MailMessage(string to, string subject, string body, bool isHTML, IEnumerable`1<MailAttachment> attachments);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ToRecipients();
    [CompilerGeneratedAttribute]
private void set_ToRecipients(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CcRecipients();
    [CompilerGeneratedAttribute]
private void set_CcRecipients(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_BccRecipients();
    [CompilerGeneratedAttribute]
private void set_BccRecipients(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public bool get_IsHTML();
    [CompilerGeneratedAttribute]
public void set_IsHTML(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<MailAttachment> get_Attachments();
    [CompilerGeneratedAttribute]
private void set_Attachments(IEnumerable`1<MailAttachment> value);
    public void AddToRecipient(string recipient);
    public void AddCcRecipient(string recipient);
    public void AddBccRecipient(string recipient);
    public void AddAttachment(MailAttachment attachment);
}
public class Intersoft.Crosslight.Mobile.MediaLibrarySettings : object {
    [CompilerGeneratedAttribute]
private MediaLibraryType a;
    [CompilerGeneratedAttribute]
private CameraMediaType b;
    [CompilerGeneratedAttribute]
private ImageResultMode c;
    [CompilerGeneratedAttribute]
private int d;
    [CompilerGeneratedAttribute]
private int e;
    [CompilerGeneratedAttribute]
private bool f;
    public MediaLibraryType Source { get; public set; }
    public CameraMediaType MediaType { get; public set; }
    public ImageResultMode ImageResultMode { get; public set; }
    public int ThumbnailWidth { get; public set; }
    public int ThumbnailHeight { get; public set; }
    public bool AllowEditing { get; public set; }
    [CompilerGeneratedAttribute]
public MediaLibraryType get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(MediaLibraryType value);
    [CompilerGeneratedAttribute]
public CameraMediaType get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(CameraMediaType value);
    [CompilerGeneratedAttribute]
public ImageResultMode get_ImageResultMode();
    [CompilerGeneratedAttribute]
public void set_ImageResultMode(ImageResultMode value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailWidth();
    [CompilerGeneratedAttribute]
public void set_ThumbnailWidth(int value);
    [CompilerGeneratedAttribute]
public int get_ThumbnailHeight();
    [CompilerGeneratedAttribute]
public void set_ThumbnailHeight(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowEditing();
    [CompilerGeneratedAttribute]
public void set_AllowEditing(bool value);
    public ImagePickerSettings GetImageSettings();
}
public class Intersoft.Crosslight.Mobile.MediaPickerResult : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private CameraMediaType b;
    [CompilerGeneratedAttribute]
private Byte[] c;
    [CompilerGeneratedAttribute]
private Byte[] d;
    [CompilerGeneratedAttribute]
private string e;
    public bool IsCancelled { get; private set; }
    public CameraMediaType ResultType { get; private set; }
    public Byte[] ImageData { get; private set; }
    public Byte[] ThumbnailImageData { get; private set; }
    public string MediaUrl { get; private set; }
    public MediaPickerResult(bool isCancelled);
    public MediaPickerResult(Byte[] imageData);
    public MediaPickerResult(Byte[] imageData, Byte[] thumbnailImageData);
    public MediaPickerResult(string mediaUrl);
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
    [CompilerGeneratedAttribute]
public CameraMediaType get_ResultType();
    [CompilerGeneratedAttribute]
private void set_ResultType(CameraMediaType value);
    [CompilerGeneratedAttribute]
public Byte[] get_ImageData();
    [CompilerGeneratedAttribute]
private void set_ImageData(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ThumbnailImageData();
    [CompilerGeneratedAttribute]
private void set_ThumbnailImageData(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_MediaUrl();
    [CompilerGeneratedAttribute]
private void set_MediaUrl(string value);
}
public class Intersoft.Crosslight.Mobile.Note : FrameworkModel {
    private string ao;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public string Contents { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public string get_Contents();
    public void set_Contents(string value);
}
public class Intersoft.Crosslight.Mobile.Organization : FrameworkModel {
    private OrganizationType b;
    private string c;
    private string al;
    private string ap;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public OrganizationType Type { get; public set; }
    public string Label { get; public set; }
    public string Name { get; public set; }
    public string ContactTitle { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public OrganizationType get_Type();
    public void set_Type(OrganizationType value);
    public string get_Label();
    public void set_Label(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ContactTitle();
    public void set_ContactTitle(string value);
}
public class Intersoft.Crosslight.Mobile.Phone : FrameworkModel {
    private PhoneType b;
    private string c;
    private string aq;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public PhoneType Type { get; public set; }
    public string Label { get; public set; }
    public string Number { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public PhoneType get_Type();
    public void set_Type(PhoneType value);
    public string get_Label();
    public void set_Label(string value);
    public string get_Number();
    public void set_Number(string value);
}
public class Intersoft.Crosslight.Mobile.Placemark : FrameworkModel {
    private Location au;
    private PlacemarkAddress y;
    private string al;
    private string av;
    private string aw;
    private string ax;
    private string ay;
    private string az;
    private string ba;
    private string bb;
    private LocationRegion f;
    public Location Location { get; public set; }
    public PlacemarkAddress Address { get; private set; }
    public string Name { get; public set; }
    public string AdministrativeArea { get; public set; }
    public string SubAdministrativeArea { get; public set; }
    public string Locality { get; public set; }
    public string SubLocality { get; public set; }
    public string Thoroughfare { get; public set; }
    public string SubThoroughfare { get; public set; }
    public string CountryCode { get; public set; }
    public LocationRegion Region { get; public set; }
    public Placemark(Location location);
    public Placemark(Location location, PlacemarkAddress address, string placemarkName);
    public Location get_Location();
    public void set_Location(Location value);
    public PlacemarkAddress get_Address();
    private void set_Address(PlacemarkAddress value);
    public string get_Name();
    public void set_Name(string value);
    public string get_AdministrativeArea();
    public void set_AdministrativeArea(string value);
    public string get_SubAdministrativeArea();
    public void set_SubAdministrativeArea(string value);
    public string get_Locality();
    public void set_Locality(string value);
    public string get_SubLocality();
    public void set_SubLocality(string value);
    public string get_Thoroughfare();
    public void set_Thoroughfare(string value);
    public string get_SubThoroughfare();
    public void set_SubThoroughfare(string value);
    public string get_CountryCode();
    public void set_CountryCode(string value);
    public LocationRegion get_Region();
    public void set_Region(LocationRegion value);
}
public class Intersoft.Crosslight.Mobile.PlacemarkAddress : FrameworkModel {
    private string ar;
    private string as;
    private string at;
    private string e;
    private string g;
    public string Street { get; public set; }
    public string State { get; public set; }
    public string Zip { get; public set; }
    public string City { get; public set; }
    public string Country { get; public set; }
    public PlacemarkAddress(string street, string zip, string city, string country);
    public PlacemarkAddress(string street, string state, string zip, string city, string country);
    public string get_Street();
    public void set_Street(string value);
    public string get_State();
    public void set_State(string value);
    public string get_Zip();
    public void set_Zip(string value);
    public string get_City();
    public void set_City(string value);
    public string get_Country();
    public void set_Country(string value);
    public virtual string ToString();
}
public class Intersoft.Crosslight.Mobile.PlacemarkResult : object {
    [CompilerGeneratedAttribute]
private Placemark a;
    [CompilerGeneratedAttribute]
private Exception b;
    public Placemark Placemark { get; private set; }
    public Exception Error { get; private set; }
    public PlacemarkResult(Placemark placemark);
    public PlacemarkResult(Exception error);
    [CompilerGeneratedAttribute]
public Placemark get_Placemark();
    [CompilerGeneratedAttribute]
private void set_Placemark(Placemark value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
}
public class Intersoft.Crosslight.Mobile.ReachabilityChangesDelegate : MulticastDelegate {
    public ReachabilityChangesDelegate(object object, IntPtr method);
    public virtual void Invoke(object sender, ReachabilityEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ReachabilityEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Intersoft.Crosslight.Mobile.ReachabilityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private bool b;
    [CompilerGeneratedAttribute]
private bool c;
    public bool IsReachableViaWWAN { get; private set; }
    public bool IsReachableViaWiFi { get; private set; }
    public bool IsReachable { get; private set; }
    public ReachabilityEventArgs(bool isReachable, bool isReachableViaWiFi, bool isReachableViaWWAN);
    [CompilerGeneratedAttribute]
public bool get_IsReachableViaWWAN();
    [CompilerGeneratedAttribute]
private void set_IsReachableViaWWAN(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReachableViaWiFi();
    [CompilerGeneratedAttribute]
private void set_IsReachableViaWiFi(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
    [CompilerGeneratedAttribute]
private void set_IsReachable(bool value);
}
public class Intersoft.Crosslight.Mobile.ReachabilityResult : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private bool b;
    [CompilerGeneratedAttribute]
private bool c;
    public bool IsReachableViaWWAN { get; private set; }
    public bool IsReachableViaWiFi { get; private set; }
    public bool IsReachable { get; private set; }
    public ReachabilityResult(bool isReachable, bool isReachableViaWiFi, bool isReachableViaWWAN);
    [CompilerGeneratedAttribute]
public bool get_IsReachableViaWWAN();
    [CompilerGeneratedAttribute]
private void set_IsReachableViaWWAN(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReachableViaWiFi();
    [CompilerGeneratedAttribute]
private void set_IsReachableViaWiFi(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
    [CompilerGeneratedAttribute]
private void set_IsReachable(bool value);
}
public class Intersoft.Crosslight.Mobile.Relationship : FrameworkModel {
    private string al;
    private RelationshipType b;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public string Name { get; public set; }
    public RelationshipType Type { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public string get_Name();
    public void set_Name(string value);
    public RelationshipType get_Type();
    public void set_Type(RelationshipType value);
}
public class Intersoft.Crosslight.Mobile.Website : FrameworkModel {
    private string y;
    [CompilerGeneratedAttribute]
private string i;
    internal string Id { get; internal set; }
    public string Address { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
    public string get_Address();
    public void set_Address(string value);
}
public enum Intersoft.Crosslight.ModalPresentationStyle : Enum {
    public int value__;
    public static ModalPresentationStyle Default;
    public static ModalPresentationStyle FormSheet;
    public static ModalPresentationStyle PageSheet;
    public static ModalPresentationStyle FullScreen;
}
public enum Intersoft.Crosslight.ModalTransitionStyle : Enum {
    public int value__;
    public static ModalTransitionStyle Default;
    public static ModalTransitionStyle Slide;
    public static ModalTransitionStyle Flip;
    public static ModalTransitionStyle Fade;
    public static ModalTransitionStyle Curl;
}
[SerializableAttribute]
public class Intersoft.Crosslight.NavigatedParameter : object {
    [CompilerGeneratedAttribute]
private NavigationMode a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private IViewModel c;
    [DataMemberAttribute]
public NavigationMode NavigationMode { get; internal set; }
    [DataMemberAttribute]
public object Data { get; internal set; }
    [IgnoreDataMemberAttribute]
public IViewModel Sender { get; internal set; }
    public NavigatedParameter(object data, IViewModel sender);
    public NavigatedParameter(object data, IViewModel sender, NavigationMode navigationMode);
    [CompilerGeneratedAttribute]
public NavigationMode get_NavigationMode();
    [CompilerGeneratedAttribute]
internal void set_NavigationMode(NavigationMode value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
internal void set_Data(object value);
    [CompilerGeneratedAttribute]
public IViewModel get_Sender();
    [CompilerGeneratedAttribute]
internal void set_Sender(IViewModel value);
}
public class Intersoft.Crosslight.NavigationItem : object {
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private string f;
    [CompilerGeneratedAttribute]
private string g;
    [CompilerGeneratedAttribute]
private string h;
    [CompilerGeneratedAttribute]
private ICommand i;
    [CompilerGeneratedAttribute]
private NavigationTarget j;
    [CompilerGeneratedAttribute]
private CommandType k;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler l;
    public string Group { get; public set; }
    public string Title { get; public set; }
    public string Detail { get; public set; }
    public string Image { get; public set; }
    public ICommand Command { get; public set; }
    public NavigationTarget Target { get; public set; }
    public CommandType CommandType { get; public set; }
    public NavigationItem(string title, NavigationTarget target);
    public NavigationItem(string title, string group, NavigationTarget target);
    public NavigationItem(string title, string group, Type targetType);
    public NavigationItem(string title, string group, ICommand command);
    public NavigationItem(string title, Type targetType);
    [CompilerGeneratedAttribute]
public virtual string get_Group();
    [CompilerGeneratedAttribute]
public virtual void set_Group(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
public virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Detail();
    [CompilerGeneratedAttribute]
public virtual void set_Detail(string value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public ICommand get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(ICommand value);
    [CompilerGeneratedAttribute]
public NavigationTarget get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(NavigationTarget value);
    [CompilerGeneratedAttribute]
public CommandType get_CommandType();
    [CompilerGeneratedAttribute]
public void set_CommandType(CommandType value);
    public void RaisePropertyChanged(string propertyName);
    protected virtual void OnPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public enum Intersoft.Crosslight.NavigationMode : Enum {
    public int value__;
    public static NavigationMode Push;
    public static NavigationMode Modal;
}
public class Intersoft.Crosslight.NavigationParameter : object {
    [CompilerGeneratedAttribute]
private object a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private NavigationMode c;
    [CompilerGeneratedAttribute]
private NavigationTargetKind d;
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private bool g;
    [CompilerGeneratedAttribute]
private bool h;
    [CompilerGeneratedAttribute]
private IViewModel i;
    [CompilerGeneratedAttribute]
private ModalTransitionStyle j;
    [CompilerGeneratedAttribute]
private ModalPresentationStyle k;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> l;
    [CompilerGeneratedAttribute]
private Action`1<IViewContext> m;
    [CompilerGeneratedAttribute]
private Action`1<Type> n;
    public object CommandId { get; public set; }
    public object Data { get; public set; }
    public NavigationMode NavigationMode { get; public set; }
    public NavigationTargetKind NavigationTargetKind { get; public set; }
    public bool Animated { get; public set; }
    public bool ReuseExistingTarget { get; public set; }
    public bool PreferPopover { get; public set; }
    public bool EnsureNavigationContext { get; public set; }
    public IViewModel Sender { get; internal set; }
    public ModalTransitionStyle ModalTransitionStyle { get; public set; }
    public ModalPresentationStyle ModalPresentationStyle { get; public set; }
    public Dictionary`2<string, object> Flags { get; private set; }
    internal Action`1<IViewContext> ConfigureTargetAction { get; internal set; }
    public Action`1<Type> ConfigurePrenavigateAction { get; public set; }
    public NavigationParameter(NavigationMode mode);
    public NavigationParameter(NavigationMode mode, object data);
    public NavigationParameter(object data);
    [CompilerGeneratedAttribute]
public object get_CommandId();
    [CompilerGeneratedAttribute]
public void set_CommandId(object value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    [CompilerGeneratedAttribute]
public NavigationMode get_NavigationMode();
    [CompilerGeneratedAttribute]
public void set_NavigationMode(NavigationMode value);
    [CompilerGeneratedAttribute]
public NavigationTargetKind get_NavigationTargetKind();
    [CompilerGeneratedAttribute]
public void set_NavigationTargetKind(NavigationTargetKind value);
    [CompilerGeneratedAttribute]
public bool get_Animated();
    [CompilerGeneratedAttribute]
public void set_Animated(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReuseExistingTarget();
    [CompilerGeneratedAttribute]
public void set_ReuseExistingTarget(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferPopover();
    [CompilerGeneratedAttribute]
public void set_PreferPopover(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnsureNavigationContext();
    [CompilerGeneratedAttribute]
public void set_EnsureNavigationContext(bool value);
    [CompilerGeneratedAttribute]
public IViewModel get_Sender();
    [CompilerGeneratedAttribute]
internal void set_Sender(IViewModel value);
    [CompilerGeneratedAttribute]
public ModalTransitionStyle get_ModalTransitionStyle();
    [CompilerGeneratedAttribute]
public void set_ModalTransitionStyle(ModalTransitionStyle value);
    [CompilerGeneratedAttribute]
public ModalPresentationStyle get_ModalPresentationStyle();
    [CompilerGeneratedAttribute]
public void set_ModalPresentationStyle(ModalPresentationStyle value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(Dictionary`2<string, object> value);
    public void AddPlatformFlag(string key, object value);
    internal object GetFlag(string a);
    [CompilerGeneratedAttribute]
internal Action`1<IViewContext> get_ConfigureTargetAction();
    [CompilerGeneratedAttribute]
internal void set_ConfigureTargetAction(Action`1<IViewContext> value);
    [CompilerGeneratedAttribute]
public Action`1<Type> get_ConfigurePrenavigateAction();
    [CompilerGeneratedAttribute]
public void set_ConfigurePrenavigateAction(Action`1<Type> value);
}
public class Intersoft.Crosslight.NavigationResult : object {
    [CompilerGeneratedAttribute]
private NavigationResultAction a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private IViewModel c;
    [CompilerGeneratedAttribute]
private bool d;
    [CompilerGeneratedAttribute]
private bool e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private bool g;
    public NavigationResultAction Action { get; public set; }
    public object Data { get; public set; }
    public IViewModel Sender { get; internal set; }
    public bool StaysModal { get; public set; }
    public bool ClosedByTopStack { get; public set; }
    internal bool IsProgrammaticDismissed { get; internal set; }
    internal bool IsResultCallbackEvaluated { get; internal set; }
    public NavigationResult(NavigationResultAction action);
    public NavigationResult(object data);
    public NavigationResult(NavigationResultAction action, object data);
    [CompilerGeneratedAttribute]
public NavigationResultAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(NavigationResultAction value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    [CompilerGeneratedAttribute]
public IViewModel get_Sender();
    [CompilerGeneratedAttribute]
internal void set_Sender(IViewModel value);
    [CompilerGeneratedAttribute]
public bool get_StaysModal();
    [CompilerGeneratedAttribute]
public void set_StaysModal(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClosedByTopStack();
    [CompilerGeneratedAttribute]
public void set_ClosedByTopStack(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsProgrammaticDismissed();
    [CompilerGeneratedAttribute]
internal void set_IsProgrammaticDismissed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsResultCallbackEvaluated();
    [CompilerGeneratedAttribute]
internal void set_IsResultCallbackEvaluated(bool value);
}
public enum Intersoft.Crosslight.NavigationResultAction : Enum {
    public int value__;
    public static NavigationResultAction Close;
    public static NavigationResultAction Cancel;
    public static NavigationResultAction Done;
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.NavigationSettingsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private NavigationMode a;
    [CompilerGeneratedAttribute]
private ModalTransitionStyle b;
    [CompilerGeneratedAttribute]
private ModalPresentationStyle c;
    [CompilerGeneratedAttribute]
private bool d;
    public NavigationMode Mode { get; public set; }
    public ModalTransitionStyle ModalTransitionStyle { get; public set; }
    public ModalPresentationStyle ModalPresentationStyle { get; public set; }
    public bool EnsureNavigationContext { get; public set; }
    [CompilerGeneratedAttribute]
public NavigationMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(NavigationMode value);
    [CompilerGeneratedAttribute]
public ModalTransitionStyle get_ModalTransitionStyle();
    [CompilerGeneratedAttribute]
public void set_ModalTransitionStyle(ModalTransitionStyle value);
    [CompilerGeneratedAttribute]
public ModalPresentationStyle get_ModalPresentationStyle();
    [CompilerGeneratedAttribute]
public void set_ModalPresentationStyle(ModalPresentationStyle value);
    [CompilerGeneratedAttribute]
public bool get_EnsureNavigationContext();
    [CompilerGeneratedAttribute]
public void set_EnsureNavigationContext(bool value);
}
public class Intersoft.Crosslight.NavigationTarget : object {
    [CompilerGeneratedAttribute]
private Type a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private NavigationParameter c;
    [CompilerGeneratedAttribute]
private string d;
    public Type Type { get; internal set; }
    public string Name { get; public set; }
    public NavigationParameter Parameter { get; internal set; }
    public string NavigationIdentifier { get; internal set; }
    public NavigationTarget(Type targetType);
    public NavigationTarget(Type targetType, NavigationTargetKind targetKind);
    public NavigationTarget(Type targetType, NavigationParameter parameter);
    public NavigationTarget(Type targetType, NavigationMode navigationMode);
    public NavigationTarget(Type targetType, string targetName);
    public NavigationTarget(Type targetType, string targetName, NavigationMode navigationMode, bool ensureNavigationContext);
    public NavigationTarget(Type targetType, string targetName, NavigationParameter parameter);
    public NavigationTarget(Type targetType, string targetName, NavigationTargetKind targetKind);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    [CompilerGeneratedAttribute]
internal virtual void set_Type(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NavigationParameter get_Parameter();
    [CompilerGeneratedAttribute]
internal void set_Parameter(NavigationParameter value);
    [CompilerGeneratedAttribute]
public string get_NavigationIdentifier();
    [CompilerGeneratedAttribute]
internal void set_NavigationIdentifier(string value);
    public NavigationTarget Clone();
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.NavigationTargetExtensions : object {
    [ExtensionAttribute]
public static Type FindViewContextType(NavigationTarget target, Type excludedType, bool ignoreDeviceKind);
    [ExtensionAttribute]
public static Type FindViewContextType(NavigationTarget target, Type[] excludedTypes, bool ignoreDeviceKind);
}
public enum Intersoft.Crosslight.NavigationTargetKind : Enum {
    public int value__;
    public static NavigationTargetKind Auto;
    public static NavigationTargetKind Self;
    public static NavigationTargetKind Detail;
}
public enum Intersoft.Crosslight.NetworkConnectionStatus : Enum {
    public int value__;
    public static NetworkConnectionStatus NoConnection;
    public static NetworkConnectionStatus WiFi;
    public static NetworkConnectionStatus WWAN;
    public static NetworkConnectionStatus WiFiAndWWAN;
}
public enum Intersoft.Crosslight.NetworkConnectionType : Enum {
    public int value__;
    public static NetworkConnectionType Any;
    public static NetworkConnectionType WiFi;
    public static NetworkConnectionType WWAN;
}
[AttributeUsageAttribute("4252")]
public class Intersoft.Crosslight.NonSerializableAttribute : Attribute {
}
public class Intersoft.Crosslight.Notification : object {
    [CompilerGeneratedAttribute]
private Guid a;
    [CompilerGeneratedAttribute]
private NotificationType b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private string d;
    [CompilerGeneratedAttribute]
private string e;
    [CompilerGeneratedAttribute]
private bool f;
    [CompilerGeneratedAttribute]
private int g;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> h;
    public Guid Identifier { get; private set; }
    public NotificationType Type { get; protected set; }
    public string Title { get; public set; }
    public string Message { get; public set; }
    public string SoundName { get; public set; }
    public bool HasAction { get; public set; }
    public int BadgeNumber { get; public set; }
    public Dictionary`2<string, object> UserInfo { get; public set; }
    public Notification(Guid guid);
    [CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(Guid value);
    [CompilerGeneratedAttribute]
public NotificationType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(NotificationType value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_SoundName();
    [CompilerGeneratedAttribute]
public void set_SoundName(string value);
    [CompilerGeneratedAttribute]
public bool get_HasAction();
    [CompilerGeneratedAttribute]
public void set_HasAction(bool value);
    [CompilerGeneratedAttribute]
public int get_BadgeNumber();
    [CompilerGeneratedAttribute]
public void set_BadgeNumber(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_UserInfo();
    [CompilerGeneratedAttribute]
public void set_UserInfo(Dictionary`2<string, object> value);
}
public enum Intersoft.Crosslight.NotificationType : Enum {
    public int value__;
    public static NotificationType Local;
    public static NotificationType Remote;
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.ObjectExtensions : object {
    private static Dictionary`2<string, PropertyInfo> a;
    private static ObjectExtensions();
    [ExtensionAttribute]
public static BindingContext SetBinding(object obj, BindableProperty property, BindingDescription bindingDescription);
    [ExtensionAttribute]
public static BindingContext GetBindingContext(object obj, BindableProperty property);
    [ExtensionAttribute]
public static void SetPropertyValue(object obj, BindableProperty property, object value);
    [ExtensionAttribute]
public static void SetPropertyValue(object obj, string property, object value);
    [ExtensionAttribute]
internal static object GetPropertyValue(object a, string b);
    [ExtensionAttribute]
internal static void SetPropertyValue(object a, BindableProperty b, object c, bool d);
    [ExtensionAttribute]
public static object GetPropertyValue(object obj, BindableProperty property);
    [ExtensionAttribute]
public static T GetPropertyValue(object obj, BindableProperty property);
    [ExtensionAttribute]
internal static PropertyInfo GetProperty(object a, string b);
    [ExtensionAttribute]
internal static object GetPropertyPathValue(object a, string b, bool c);
    [ExtensionAttribute]
public static void SetPropertyPathValue(object obj, string propertyPath, object value);
    [ExtensionAttribute]
public static void SetPropertyPathValue(object obj, BindingDescription binding, T value);
    [ExtensionAttribute]
public static object GetPropertyPathValue(object obj, string propertyPath);
    [ExtensionAttribute]
public static T GetPropertyPathValue(object obj, BindingDescription binding);
    [ExtensionAttribute]
public static object GetPropertyPathValue(object obj, Type propertyType, BindingDescription binding);
    [ExtensionAttribute]
public static T GetPropertyPathValue(object obj, string propertyPath);
    [ExtensionAttribute]
public static object FindName(object obj, string name);
    [ExtensionAttribute]
public static T FindName(object obj, string name);
    [ExtensionAttribute]
public static bool IsDeleted(IAccount account);
    [ExtensionAttribute]
internal static T GetAttribute(Attribute[] a);
}
public class Intersoft.Crosslight.ObservableResource`1 : object {
    private ResourceManager a;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler b;
    [CompilerGeneratedAttribute]
private bool c;
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string propertyName);
    public sealed virtual void Dispose();
    public virtual string GetPropertyValue(string property);
    public virtual string GetString(string key, CultureInfo culture);
    public virtual string GetString(string key);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
}
public enum Intersoft.Crosslight.OrganizationType : Enum {
    public int value__;
    public static OrganizationType Work;
    public static OrganizationType Other;
}
public enum Intersoft.Crosslight.OSKind : Enum {
    public int value__;
    public static OSKind iOS;
    public static OSKind Android;
    public static OSKind WinPhone;
    public static OSKind WinRT;
    public static OSKind Blazor;
}
public enum Intersoft.Crosslight.PhoneType : Enum {
    public int value__;
    public static PhoneType Home;
    public static PhoneType HomeFax;
    public static PhoneType Work;
    public static PhoneType WorkFax;
    public static PhoneType Pager;
    public static PhoneType Mobile;
    public static PhoneType Other;
}
public class Intersoft.Crosslight.PlatformInfo : object {
    [CompilerGeneratedAttribute]
private OSKind a;
    [CompilerGeneratedAttribute]
private int b;
    [CompilerGeneratedAttribute]
private int c;
    [CompilerGeneratedAttribute]
private bool d;
    public OSKind OperatingSystem { get; internal set; }
    public int MajorVersion { get; internal set; }
    public int MinorVersion { get; internal set; }
    public bool IsDebug { get; internal set; }
    public PlatformInfo(OSKind os);
    [CompilerGeneratedAttribute]
public OSKind get_OperatingSystem();
    [CompilerGeneratedAttribute]
internal void set_OperatingSystem(OSKind value);
    [CompilerGeneratedAttribute]
public int get_MajorVersion();
    [CompilerGeneratedAttribute]
internal void set_MajorVersion(int value);
    [CompilerGeneratedAttribute]
public int get_MinorVersion();
    [CompilerGeneratedAttribute]
internal void set_MinorVersion(int value);
    [CompilerGeneratedAttribute]
public bool get_IsDebug();
    [CompilerGeneratedAttribute]
internal void set_IsDebug(bool value);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public class Intersoft.Crosslight.PocoJsonSerializerStrategy : object {
    private IEnumerable`1<Assembly> a;
    private IDictionary`2<string, Type> b;
    internal IDictionary`2<Type, c> c;
    internal IDictionary`2<Type, IDictionary`2<string, p>> d;
    internal IDictionary`2<Type, IDictionary`2<string, KeyValuePair`2<Type, b>>> e;
    internal static Type[] f;
    internal static Type[] g;
    private static String[] h;
    internal IEnumerable`1<Assembly> LoadedAssemblies { get; }
    internal IDictionary`2<string, Type> LoadedType { get; }
    private static PocoJsonSerializerStrategy();
    internal IEnumerable`1<Assembly> get_LoadedAssemblies();
    internal IDictionary`2<string, Type> get_LoadedType();
    protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName);
    internal virtual c ContructorDelegateFactory(Type a);
    internal virtual IDictionary`2<string, p> GetterValueFactory(Type a);
    internal virtual IDictionary`2<string, KeyValuePair`2<Type, b>> SetterValueFactory(Type a);
    public virtual bool TrySerializeNonPrimitiveObject(object input, object originalValue, JsonSerializationOptions options, Object& output);
    public virtual object DeserializeObject(object value, Type type, JsonSerializationOptions options);
    private object DeserializeObject(object a, Type b, JsonSerializationOptions c, PropertyInfo d);
    protected virtual object SerializeEnum(Enum p);
    private DateTimeKind GetDateTimeSerializationMode(object a, JsonSerializationOptions b);
    private DateTimeKind GetDateTimeSerializationMode(Type a, JsonSerializationOptions b);
    private DateTimeKind GetDateTimeSerializationMode(PropertyInfo a, JsonSerializationOptions b);
    protected virtual bool TrySerializeKnownTypes(object input, object originalValue, JsonSerializationOptions options, Object& output);
    protected virtual bool TrySerializeUnknownTypes(object input, object originalValue, JsonSerializationOptions options, Object& output);
}
public enum Intersoft.Crosslight.PopupCloseAction : Enum {
    public int value__;
    public static PopupCloseAction Dismissed;
    public static PopupCloseAction UserInitiate;
}
public class Intersoft.Crosslight.ProductInfo : object {
    public string ProductName;
    public string VersionNumber;
    public double CommercialVersion;
    public string BuildNumber;
    public string SubProductName;
    public bool IsCollection;
    public string Namespace;
    public string ProductDesc;
    public bool HasEdition;
    public string EditionName;
    public string ReleaseType;
    public string PublicKeyToken;
    public DateTime BetaExpired;
    public bool IsTrialExpired;
    public string Identity;
    public Type ProductType;
    public string SimpleProductName;
    internal object a;
    internal object b;
    public string GetProductName();
}
public enum Intersoft.Crosslight.ReachabilityStatus : Enum {
    public int value__;
    public static ReachabilityStatus NotReachable;
    public static ReachabilityStatus ViaWiFi;
    public static ReachabilityStatus ViaWWAN;
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.RegisterNavigationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string a;
    [CompilerGeneratedAttribute]
private bool b;
    [CompilerGeneratedAttribute]
private Nullable`1<DeviceKind> c;
    public string Identifier { get; public set; }
    public bool IsRootView { get; public set; }
    public Nullable`1<DeviceKind> DeviceKind { get; public set; }
    public RegisterNavigationAttribute(DeviceKind targetDeviceKind);
    public RegisterNavigationAttribute(string navigationIdentifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRootView();
    [CompilerGeneratedAttribute]
public void set_IsRootView(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DeviceKind> get_DeviceKind();
    [CompilerGeneratedAttribute]
public void set_DeviceKind(Nullable`1<DeviceKind> value);
}
public enum Intersoft.Crosslight.RelationshipType : Enum {
    public int value__;
    public static RelationshipType SignificantOther;
    public static RelationshipType Child;
    public static RelationshipType Other;
}
public enum Intersoft.Crosslight.ReorderAction : Enum {
    public int value__;
    public static ReorderAction QueryState;
    public static ReorderAction CustomizeTarget;
    public static ReorderAction ProcessReorder;
}
[r]
public class Intersoft.Crosslight.ReorderParameter : object {
    [CompilerGeneratedAttribute]
private object a;
    [CompilerGeneratedAttribute]
private int b;
    [CompilerGeneratedAttribute]
private ReorderAction c;
    [CompilerGeneratedAttribute]
private int d;
    public object Item { get; internal set; }
    public int RowIndex { get; internal set; }
    public ReorderAction Action { get; internal set; }
    public int ProposedRowIndex { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
internal void set_Item(object value);
    [CompilerGeneratedAttribute]
public int get_RowIndex();
    [CompilerGeneratedAttribute]
internal void set_RowIndex(int value);
    [CompilerGeneratedAttribute]
public ReorderAction get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(ReorderAction value);
    [CompilerGeneratedAttribute]
public int get_ProposedRowIndex();
    [CompilerGeneratedAttribute]
public void set_ProposedRowIndex(int value);
}
public class Intersoft.Crosslight.ResourceCacheItem : object {
    private Byte[] a;
    [CompilerGeneratedAttribute]
private string b;
    [CompilerGeneratedAttribute]
private string c;
    [CompilerGeneratedAttribute]
private int d;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> e;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> f;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> g;
    [CompilerGeneratedAttribute]
private bool h;
    [CompilerGeneratedAttribute]
private object i;
    public string CacheId { get; public set; }
    public string Url { get; public set; }
    public int Size { get; public set; }
    public Nullable`1<DateTime> LastAccessedDate { get; public set; }
    public Nullable`1<DateTime> LastModifiedDate { get; public set; }
    public Nullable`1<DateTime> ExpireDate { get; public set; }
    public bool IsPurged { get; public set; }
    [IgnoreDataMemberAttribute]
public bool IsExpired { get; }
    [IgnoreDataMemberAttribute]
public object NativeObject { get; public set; }
    [IgnoreDataMemberAttribute]
public Byte[] RawData { get; public set; }
    public ResourceCacheItem(string url);
    [CompilerGeneratedAttribute]
public string get_CacheId();
    [CompilerGeneratedAttribute]
public void set_CacheId(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastAccessedDate();
    [CompilerGeneratedAttribute]
public void set_LastAccessedDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastModifiedDate();
    [CompilerGeneratedAttribute]
public void set_LastModifiedDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpireDate();
    [CompilerGeneratedAttribute]
public void set_ExpireDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsPurged();
    [CompilerGeneratedAttribute]
public void set_IsPurged(bool value);
    public bool get_IsExpired();
    [CompilerGeneratedAttribute]
public object get_NativeObject();
    [CompilerGeneratedAttribute]
public void set_NativeObject(object value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    private string GetExtension(string a);
}
public enum Intersoft.Crosslight.ResourceCacheMode : Enum {
    public int value__;
    public static ResourceCacheMode Disk;
    public static ResourceCacheMode Memory;
    public static ResourceCacheMode DiskAndMemory;
}
public class Intersoft.Crosslight.RuntimeStyles : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> a;
    [CompilerGeneratedAttribute]
private StyleAttributes b;
    public Dictionary`2<string, object> DefaultAttributes { get; public set; }
    public StyleAttributes AppliedStyle { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_DefaultAttributes();
    [CompilerGeneratedAttribute]
public void set_DefaultAttributes(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public StyleAttributes get_AppliedStyle();
    [CompilerGeneratedAttribute]
public void set_AppliedStyle(StyleAttributes value);
    public void AddDefaultAttribute(string key, object value);
}
[AttributeUsageAttribute("4252")]
public class Intersoft.Crosslight.SerializableAttribute : Attribute {
}
public class Intersoft.Crosslight.SerializationContext : object {
    private Dictionary`2<string, object> a;
    [CompilerGeneratedAttribute]
private object b;
    [CompilerGeneratedAttribute]
private object c;
    public Dictionary`2<string, object> CustomData { get; }
    public object Instance { get; public set; }
    public object JsonObject { get; public set; }
    public Dictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public object get_JsonObject();
    [CompilerGeneratedAttribute]
public void set_JsonObject(object value);
}
public class Intersoft.Crosslight.ServiceProvider : object {
    private static IDependencyContainer a;
    [CompilerGeneratedAttribute]
private static IServiceProvider b;
    public static IServiceProvider NativeServiceProvider { get; private set; }
    private static ServiceProvider();
    [CompilerGeneratedAttribute]
public static IServiceProvider get_NativeServiceProvider();
    [CompilerGeneratedAttribute]
private static void set_NativeServiceProvider(IServiceProvider value);
    public static void Initialize(IServiceProvider provider);
    public static void AddService();
    public static void AddService(TType instance);
    public static void AddService(Func`2<IDependencyResolver, TType> func);
    public static TType GetService();
    public static TType GetService(bool newInstance);
    public static IEnumerable`1<TType> GetServices();
    public static object GetService(Type serviceType);
    public sealed virtual void Dispose();
}
public class Intersoft.Crosslight.Services.ActivatorService : object {
    public IDependencyContainer Container { get; }
    public IDependencyContainer get_Container();
    public sealed virtual void Register();
    public sealed virtual void Register(Func`2<IDependencyResolver, TType> func);
    public sealed virtual T CreateInstance();
    public sealed virtual object CreateInstance(Type type);
}
public class Intersoft.Crosslight.Services.DefaultTypeResolverService : object {
    private List`1<a> a;
    public sealed virtual void Register(Assembly assembly, string category);
    public sealed virtual Type Resolve(string name, string category);
    public sealed virtual Type Resolve(string category);
}
public abstract class Intersoft.Crosslight.Services.FormBuilderServiceBase`1 : object {
    private static List`1<IViewBuilder> a;
    private static FormBuilderServiceBase`1();
    public abstract virtual T Build(object viewHost, FormDefinition form);
    public virtual void Register();
    public virtual IViewBuilder GetViewBuilder(ComponentDefinitionBase definition);
    private sealed virtual override object Intersoft.Crosslight.IFormBuilderService.Build(object a, FormDefinition b);
}
public interface Intersoft.Crosslight.Services.IHashCryptographicService {
    public abstract virtual bool IsAlgorithmSupported(HashAlgorithmKind algorithmKind);
    public abstract virtual string CreateSignature(HashAlgorithmKind algorithmKind, string input, Byte[] key);
}
public interface Intersoft.Crosslight.Services.ITypeResolverService {
    public abstract virtual void Register(Assembly assembly, string category);
    public abstract virtual Type Resolve(string name, string category);
    public abstract virtual Type Resolve(string category);
}
public abstract class Intersoft.Crosslight.Services.MobileComponentServiceBase : object {
    [CompilerGeneratedAttribute]
private bool a;
    [CompilerGeneratedAttribute]
private object b;
    public bool IsInitialized { get; protected set; }
    public object Owner { get; private set; }
    public IApplicationContext ApplicationContext { get; }
    public IMessagePresenter MessagePresenter { get; }
    protected virtual override void Finalize();
    public abstract virtual bool IsSupported();
    [CompilerGeneratedAttribute]
public virtual bool get_IsInitialized();
    [CompilerGeneratedAttribute]
protected virtual void set_IsInitialized(bool value);
    [CompilerGeneratedAttribute]
public virtual object get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(object value);
    public virtual void SetOwner(object owner);
    public IApplicationContext get_ApplicationContext();
    public IMessagePresenter get_MessagePresenter();
    public virtual void Initialize();
    public sealed virtual void Dispose();
    protected virtual void OnInitialize();
    protected virtual void Dispose(bool disposing);
    public sealed virtual TService GetService();
    public sealed virtual TService GetService(bool newInstance);
}
public class Intersoft.Crosslight.Services.MobileService : object {
    [CompilerGeneratedAttribute]
private object a;
    protected object Owner { get; private set; }
    public ICameraService Camera { get; }
    public ITelephonyService Telephony { get; }
    public IMailService Mail { get; }
    public IMediaLibraryService MediaLibrary { get; }
    public IBrowserService Browser { get; }
    public IMessagingService Messaging { get; }
    public IMediaService Media { get; }
    public IMapService Map { get; }
    public ILocationService Location { get; }
    public ISocialService Social { get; }
    public IReachabilityService Reachability { get; }
    public INotificationService Notification { get; }
    public ILocalStorageService LocalStorage { get; }
    public IContactService Contact { get; }
    [CompilerGeneratedAttribute]
protected object get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(object value);
    public sealed virtual IEnumerable`1<IMobileComponentService> GetAllServices();
    public sealed virtual void SetOwner(object owner);
    public sealed virtual ICameraService get_Camera();
    public sealed virtual ITelephonyService get_Telephony();
    public sealed virtual IMailService get_Mail();
    public sealed virtual IMediaLibraryService get_MediaLibrary();
    public sealed virtual IBrowserService get_Browser();
    public sealed virtual IMessagingService get_Messaging();
    public sealed virtual IMediaService get_Media();
    public sealed virtual IMapService get_Map();
    public sealed virtual ILocationService get_Location();
    public sealed virtual ISocialService get_Social();
    public sealed virtual IReachabilityService get_Reachability();
    public sealed virtual INotificationService get_Notification();
    public sealed virtual ILocalStorageService get_LocalStorage();
    public sealed virtual IContactService get_Contact();
    public T GetService();
}
public class Intersoft.Crosslight.Services.PresenterService : object {
    public IDependencyContainer Container { get; }
    public IDependencyContainer get_Container();
    public sealed virtual T GetPresenter();
    public sealed virtual void Register();
}
[FlagsAttribute]
public enum Intersoft.Crosslight.ShareActivityType : Enum {
    public int value__;
    public static ShareActivityType SocialDefaults;
    public static ShareActivityType PostToTwitter;
    public static ShareActivityType PostToFacebook;
    public static ShareActivityType PostToWeibo;
    public static ShareActivityType AssignToContact;
    public static ShareActivityType CopyToPasteboard;
    public static ShareActivityType Mail;
    public static ShareActivityType Message;
    public static ShareActivityType Print;
    public static ShareActivityType SaveToCamera;
    public static ShareActivityType All;
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public static class Intersoft.Crosslight.SimpleJson : object {
    private static int a;
    private static int b;
    private static int c;
    private static int d;
    private static int e;
    private static int f;
    private static int g;
    private static int h;
    private static int i;
    private static int j;
    private static int k;
    private static int l;
    private static int m;
    private static IJsonSerializerStrategy n;
    private static PocoJsonSerializerStrategy o;
    private static DataContractJsonSerializerStrategy p;
    public static IJsonSerializerStrategy CurrentJsonSerializerStrategy { get; public set; }
    [EditorBrowsableAttribute("2")]
public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy { get; }
    [EditorBrowsableAttribute("2")]
public static DataContractJsonSerializerStrategy DataContractJsonSerializerStrategy { get; }
    public static object DeserializeObject(string json);
    public static bool TryDeserializeObject(string json, Object& obj);
    public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy, JsonSerializationOptions options);
    public static object DeserializeObject(string json, Type type);
    public static object DeserializeObject(string json, Type type, JsonSerializationOptions options);
    public static T DeserializeObject(string json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static T DeserializeObject(string json, IJsonSerializerStrategy jsonSerializerStrategy, JsonSerializationOptions options);
    public static T DeserializeObject(string json);
    public static T DeserializeObject(string json, JsonSerializationOptions options);
    public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy, JsonSerializationOptions options);
    public static string SerializeObject(object json);
    public static string SerializeObject(object json, JsonSerializationOptions options);
    public static string EscapeToJavascriptString(string jsonString);
    private static IDictionary`2<string, object> ParseObject(Char[] a, Int32& b, Boolean& c);
    private static JsonArray ParseArray(Char[] a, Int32& b, Boolean& c);
    private static object ParseValue(Char[] a, Int32& b, Boolean& c);
    private static string ParseString(Char[] a, Int32& b, Boolean& c);
    private static string ConvertFromUtf32(int a);
    private static object ParseNumber(Char[] a, Int32& b, Boolean& c);
    private static int GetLastIndexOfNumber(Char[] a, int b);
    private static void EatWhitespace(Char[] a, Int32& b);
    private static int LookAhead(Char[] a, int b);
    private static int NextToken(Char[] a, Int32& b);
    private static bool SerializeValue(IJsonSerializerStrategy a, object b, StringBuilder c, JsonSerializationOptions d, object e);
    private static bool SerializeObject(IJsonSerializerStrategy a, IEnumerable b, IEnumerable c, StringBuilder d, JsonSerializationOptions e, object f);
    private static bool SerializeArray(IJsonSerializerStrategy a, IEnumerable b, StringBuilder c, JsonSerializationOptions d, object e);
    private static bool SerializeString(string a, StringBuilder b);
    private static bool SerializeNumber(object a, StringBuilder b);
    private static bool IsNumeric(object a);
    public static IJsonSerializerStrategy get_CurrentJsonSerializerStrategy();
    public static void set_CurrentJsonSerializerStrategy(IJsonSerializerStrategy value);
    public static PocoJsonSerializerStrategy get_PocoJsonSerializerStrategy();
    public static DataContractJsonSerializerStrategy get_DataContractJsonSerializerStrategy();
}
public class Intersoft.Crosslight.StartParameter : object {
}
[AttributeUsageAttribute("128")]
public class Intersoft.Crosslight.StateAwareAttribute : Attribute {
    private StateRestorationOrder a;
    public StateRestorationOrder RestorationOrder { get; }
    public StateAwareAttribute(StateRestorationOrder restorationOrder);
    public StateRestorationOrder get_RestorationOrder();
}
public enum Intersoft.Crosslight.StateRestorationOrder : Enum {
    public int value__;
    public static StateRestorationOrder BeforeNavigated;
    public static StateRestorationOrder AfterNavigated;
}
public class Intersoft.Crosslight.StyleAttributes : object {
    [CompilerGeneratedAttribute]
private Color a;
    [CompilerGeneratedAttribute]
private Color b;
    [CompilerGeneratedAttribute]
private Color c;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> d;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> e;
    public Color BackgroundColor { get; public set; }
    public Color ForegroundColor { get; public set; }
    public Color BorderColor { get; public set; }
    public Nullable`1<bool> Strikethrough { get; public set; }
    public Dictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public Color get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Color value);
    [CompilerGeneratedAttribute]
public Color get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(Color value);
    [CompilerGeneratedAttribute]
public Color get_BorderColor();
    [CompilerGeneratedAttribute]
public void set_BorderColor(Color value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Strikethrough();
    [CompilerGeneratedAttribute]
public void set_Strikethrough(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, object> value);
}
[FlagsAttribute]
public enum Intersoft.Crosslight.SubscribeOptions : Enum {
    public int value__;
    public static SubscribeOptions Default;
    public static SubscribeOptions UseBackgroundThread;
    public static SubscribeOptions UseStrongReference;
    public static SubscribeOptions SupportsCancellation;
}
public class Intersoft.Crosslight.SubscriptionToken : object {
    private Guid a;
    public sealed virtual bool Equals(SubscriptionToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Intersoft.Crosslight.SyncContext : object {
    [CompilerGeneratedAttribute]
private IAccount a;
    [CompilerGeneratedAttribute]
private string b;
    public IAccount Account { get; private set; }
    public string Provider { get; private set; }
    public SyncContext(IAccount account, string provider);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
private void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public string get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(string value);
}
public static class Intersoft.Crosslight.SyncInterval : object {
    public static long Quarterly;
    public static long HalfHourly;
    public static long Hourly;
    public static long HalfDaily;
    public static long Daily;
}
public enum Intersoft.Crosslight.TargetBindingType : Enum {
    public int value__;
    public static TargetBindingType Item;
    public static TargetBindingType Group;
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.TaskExtensions : object {
    [ExtensionAttribute]
public static T WaitForResult(Task`1<T> task);
}
public enum Intersoft.Crosslight.ToastAppearance : Enum {
    public int value__;
    public static ToastAppearance Dark;
    public static ToastAppearance Light;
}
public class Intersoft.Crosslight.ToastDisplayDuration : ValueType {
    public static double Immediate;
    public static double Short;
    public static double Long;
    public static double LongAction;
}
public enum Intersoft.Crosslight.ToastGravity : Enum {
    public int value__;
    public static ToastGravity Top;
    public static ToastGravity Center;
    public static ToastGravity Bottom;
}
public class Intersoft.Crosslight.ToastSettings : object {
    [CompilerGeneratedAttribute]
private float a;
    [CompilerGeneratedAttribute]
private float b;
    [CompilerGeneratedAttribute]
private float c;
    [CompilerGeneratedAttribute]
private float d;
    [CompilerGeneratedAttribute]
private float e;
    [CompilerGeneratedAttribute]
private float f;
    [CompilerGeneratedAttribute]
private float g;
    [CompilerGeneratedAttribute]
private float h;
    [CompilerGeneratedAttribute]
private float i;
    [CompilerGeneratedAttribute]
private int j;
    [CompilerGeneratedAttribute]
private int k;
    [CompilerGeneratedAttribute]
private double l;
    [CompilerGeneratedAttribute]
private ToastAppearance m;
    [CompilerGeneratedAttribute]
private bool n;
    [CompilerGeneratedAttribute]
private Color o;
    [CompilerGeneratedAttribute]
private float p;
    [CompilerGeneratedAttribute]
private float q;
    [CompilerGeneratedAttribute]
private float r;
    [CompilerGeneratedAttribute]
private float s;
    [CompilerGeneratedAttribute]
private float t;
    [CompilerGeneratedAttribute]
private bool u;
    [CompilerGeneratedAttribute]
private double v;
    [CompilerGeneratedAttribute]
private ToastGravity w;
    [CompilerGeneratedAttribute]
private float x;
    [CompilerGeneratedAttribute]
private float y;
    [CompilerGeneratedAttribute]
private object z;
    public float MaxWidth { get; public set; }
    public float MaxHeight { get; public set; }
    public float HorizontalPadding { get; public set; }
    public float VerticalPadding { get; public set; }
    public float HorizontalMargin { get; public set; }
    public float VerticalMargin { get; public set; }
    public float CornerRadius { get; public set; }
    public float Opacity { get; public set; }
    public float FontSize { get; public set; }
    public int MaxTitleLines { get; public set; }
    public int MaxMessageLines { get; public set; }
    public double AnimationDuration { get; public set; }
    public ToastAppearance Appearance { get; public set; }
    public bool OverlayEnabled { get; public set; }
    public Color OverlayBackground { get; public set; }
    public float OverlayOpacity { get; public set; }
    public float ShadowOpacity { get; public set; }
    public float ShadowRadius { get; public set; }
    public float ShadowOffsetX { get; public set; }
    public float ShadowOffsetY { get; public set; }
    public bool ShadowEnabled { get; public set; }
    public double DisplayDuration { get; public set; }
    public ToastGravity Gravity { get; public set; }
    public float ImageWidth { get; public set; }
    public float ImageHeight { get; public set; }
    public object Owner { get; public set; }
    public ToastSettings(object view);
    [CompilerGeneratedAttribute]
public float get_MaxWidth();
    [CompilerGeneratedAttribute]
public void set_MaxWidth(float value);
    [CompilerGeneratedAttribute]
public float get_MaxHeight();
    [CompilerGeneratedAttribute]
public void set_MaxHeight(float value);
    [CompilerGeneratedAttribute]
public float get_HorizontalPadding();
    [CompilerGeneratedAttribute]
public void set_HorizontalPadding(float value);
    [CompilerGeneratedAttribute]
public float get_VerticalPadding();
    [CompilerGeneratedAttribute]
public void set_VerticalPadding(float value);
    [CompilerGeneratedAttribute]
public float get_HorizontalMargin();
    [CompilerGeneratedAttribute]
public void set_HorizontalMargin(float value);
    [CompilerGeneratedAttribute]
public float get_VerticalMargin();
    [CompilerGeneratedAttribute]
public void set_VerticalMargin(float value);
    [CompilerGeneratedAttribute]
public float get_CornerRadius();
    [CompilerGeneratedAttribute]
public void set_CornerRadius(float value);
    [CompilerGeneratedAttribute]
public float get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(float value);
    [CompilerGeneratedAttribute]
public float get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(float value);
    [CompilerGeneratedAttribute]
public int get_MaxTitleLines();
    [CompilerGeneratedAttribute]
public void set_MaxTitleLines(int value);
    [CompilerGeneratedAttribute]
public int get_MaxMessageLines();
    [CompilerGeneratedAttribute]
public void set_MaxMessageLines(int value);
    [CompilerGeneratedAttribute]
public double get_AnimationDuration();
    [CompilerGeneratedAttribute]
public void set_AnimationDuration(double value);
    [CompilerGeneratedAttribute]
public ToastAppearance get_Appearance();
    [CompilerGeneratedAttribute]
public void set_Appearance(ToastAppearance value);
    [CompilerGeneratedAttribute]
public bool get_OverlayEnabled();
    [CompilerGeneratedAttribute]
public void set_OverlayEnabled(bool value);
    [CompilerGeneratedAttribute]
public Color get_OverlayBackground();
    [CompilerGeneratedAttribute]
public void set_OverlayBackground(Color value);
    [CompilerGeneratedAttribute]
public float get_OverlayOpacity();
    [CompilerGeneratedAttribute]
public void set_OverlayOpacity(float value);
    [CompilerGeneratedAttribute]
public float get_ShadowOpacity();
    [CompilerGeneratedAttribute]
public void set_ShadowOpacity(float value);
    [CompilerGeneratedAttribute]
public float get_ShadowRadius();
    [CompilerGeneratedAttribute]
public void set_ShadowRadius(float value);
    [CompilerGeneratedAttribute]
public float get_ShadowOffsetX();
    [CompilerGeneratedAttribute]
public void set_ShadowOffsetX(float value);
    [CompilerGeneratedAttribute]
public float get_ShadowOffsetY();
    [CompilerGeneratedAttribute]
public void set_ShadowOffsetY(float value);
    [CompilerGeneratedAttribute]
public bool get_ShadowEnabled();
    [CompilerGeneratedAttribute]
public void set_ShadowEnabled(bool value);
    [CompilerGeneratedAttribute]
public double get_DisplayDuration();
    [CompilerGeneratedAttribute]
public void set_DisplayDuration(double value);
    [CompilerGeneratedAttribute]
public ToastGravity get_Gravity();
    [CompilerGeneratedAttribute]
public void set_Gravity(ToastGravity value);
    [CompilerGeneratedAttribute]
public float get_ImageWidth();
    [CompilerGeneratedAttribute]
public void set_ImageWidth(float value);
    [CompilerGeneratedAttribute]
public float get_ImageHeight();
    [CompilerGeneratedAttribute]
public void set_ImageHeight(float value);
    [CompilerGeneratedAttribute]
public object get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(object value);
}
[q]
public class Intersoft.Crosslight.Tracer : object {
    [q]
public static void Log(string category, string text);
}
[ExtensionAttribute]
public static class Intersoft.Crosslight.TypeExtensions : object {
    [ExtensionAttribute]
public static T GetAttribute(MemberInfo info);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAttributes(MemberInfo info);
    [ExtensionAttribute]
public static Type GetItemType(Type source);
    [ExtensionAttribute]
public static PropertyInfo GetNestedProperty(Type source, string propertyName);
    [ExtensionAttribute]
public static Type GetNestedPropertyType(Type source, string propertyName);
}
public enum Intersoft.Crosslight.UpdateSourceTrigger : Enum {
    public int value__;
    public static UpdateSourceTrigger Default;
    public static UpdateSourceTrigger PropertyChanged;
    public static UpdateSourceTrigger LostFocus;
    public static UpdateSourceTrigger Explicit;
}
public class Intersoft.Crosslight.Utilities.Converter : object {
    public static T Convert(object value);
    public static object Convert(Type type, object value);
}
public class Intersoft.Crosslight.ValidationResult : object {
    private string a;
    private List`1<string> b;
    public bool IsSuccess { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public string ErrorMessage { get; }
    public static ValidationResult Success { get; }
    public ValidationResult(string errorMessage);
    public ValidationResult(string errorMessage, string propertyName);
    public bool get_IsSuccess();
    public IEnumerable`1<string> get_MemberNames();
    public string get_ErrorMessage();
    public static ValidationResult get_Success();
}
public class Intersoft.Crosslight.ViewModelBindingContext : BindingContext {
    internal ViewModelBindingContext(object a, BindableProperty b, BindingDescription c);
}
public class Intersoft.Crosslight.ViewModels.DetailViewModelBase`1 : ViewModelBase`1<T> {
    private T a;
    public T Item { get; public set; }
    private object Intersoft.Crosslight.IDetailViewModel.Item { get; private set; }
    public virtual T get_Item();
    public virtual void set_Item(T value);
    protected virtual void OnItemChanged(T newItem);
    protected virtual void OnItemChanging(T oldItem, T newItem);
    protected virtual object GetValue(string propertyName);
    protected virtual Type GetType(string propertyName);
    protected virtual bool HasPropertyAccessor(string propertyName);
    protected virtual void SetValue(string propertyName, object value);
    private sealed virtual override object Intersoft.Crosslight.IDetailViewModel.get_Item();
    private sealed virtual override void Intersoft.Crosslight.IDetailViewModel.set_Item(object value);
}
public abstract class Intersoft.Crosslight.ViewModels.DrawerViewModelBase : ViewModelBase {
    private IViewModel a;
    private IViewModel b;
    private IViewModel c;
    private Nullable`1<DrawerSide> d;
    private bool e;
    public IViewModel RightViewModel { get; public set; }
    public IViewModel CenterViewModel { get; public set; }
    public IViewModel LeftViewModel { get; public set; }
    public bool IsOpen { get; }
    public DrawerSide OpenedDrawer { get; }
    protected bool IsNavigated { get; private set; }
    public DrawerViewModelBase(IViewModel leftViewModel, IViewModel centerViewModel);
    public DrawerViewModelBase(IViewModel leftViewModel, IViewModel centerViewModel, IViewModel rightViewModel);
    public virtual IViewModel get_RightViewModel();
    public virtual void set_RightViewModel(IViewModel value);
    public virtual IViewModel get_CenterViewModel();
    public virtual void set_CenterViewModel(IViewModel value);
    public virtual IViewModel get_LeftViewModel();
    public virtual void set_LeftViewModel(IViewModel value);
    public virtual bool get_IsOpen();
    public virtual DrawerSide get_OpenedDrawer();
    protected virtual bool get_IsNavigated();
    private void set_IsNavigated(bool value);
    public virtual void Navigated(NavigatedParameter parameter);
    public virtual void Open(DrawerSide side);
    public virtual void Close();
}
public class Intersoft.Crosslight.ViewModels.EditableDetailViewModelBase`1 : DetailViewModelBase`1<T> {
    [CompilerGeneratedAttribute]
private DelegateCommand a;
    [CompilerGeneratedAttribute]
private DelegateCommand b;
    [CompilerGeneratedAttribute]
private DelegateCommand c;
    public DelegateCommand AddCommand { get; public set; }
    public DelegateCommand DeleteCommand { get; public set; }
    public DelegateCommand EditCommand { get; public set; }
    [CompilerGeneratedAttribute]
public DelegateCommand get_AddCommand();
    [CompilerGeneratedAttribute]
public void set_AddCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public DelegateCommand get_DeleteCommand();
    [CompilerGeneratedAttribute]
public void set_DeleteCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public DelegateCommand get_EditCommand();
    [CompilerGeneratedAttribute]
public void set_EditCommand(DelegateCommand value);
    protected virtual bool CanExecuteAdd(object sender);
    protected virtual bool CanExecuteDelete(object sender);
    protected virtual bool CanExecuteEdit(object sender);
    protected virtual void ExecuteAdd(object parameter);
    protected virtual void ExecuteDelete(object parameter);
    protected virtual void ExecuteEdit(object parameter);
}
public class Intersoft.Crosslight.ViewModels.EditableListViewModelBase`1 : ListViewModelBase`1<T> {
    private bool a;
    private bool b;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataChangedEventArgs> c;
    [CompilerGeneratedAttribute]
private DelegateCommand d;
    [CompilerGeneratedAttribute]
private DelegateCommand e;
    [CompilerGeneratedAttribute]
private DelegateCommand f;
    [CompilerGeneratedAttribute]
private DelegateCommand g;
    [CompilerGeneratedAttribute]
private DelegateCommand h;
    [CompilerGeneratedAttribute]
private DelegateCommand i;
    public DelegateCommand AddCommand { get; public set; }
    public DelegateCommand DeleteCommand { get; public set; }
    public DelegateCommand EditActionCommand { get; public set; }
    public DelegateCommand EditCommand { get; public set; }
    public bool IsBatchUpdating { get; public set; }
    public bool IsEditing { get; public set; }
    public DelegateCommand ReorderCommand { get; public set; }
    public DelegateCommand ToggleEditModeCommand { get; public set; }
    public EditableListViewModelBase`1(IViewModel owner);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_AddCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AddCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_DeleteCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeleteCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public DelegateCommand get_EditActionCommand();
    [CompilerGeneratedAttribute]
public void set_EditActionCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_EditCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EditCommand(DelegateCommand value);
    public bool get_IsBatchUpdating();
    public void set_IsBatchUpdating(bool value);
    public sealed virtual bool get_IsEditing();
    public sealed virtual void set_IsEditing(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_ReorderCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReorderCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_ToggleEditModeCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ToggleEditModeCommand(DelegateCommand value);
    public virtual T GetNextValidItem(T item);
    private sealed virtual override void Intersoft.Crosslight.IDataChangeTracker.OnDataChanged(object a);
    protected virtual bool CanExecuteAdd(object parameter);
    protected virtual bool CanExecuteDelete(object parameter);
    protected virtual bool CanExecuteEdit(object parameter);
    protected virtual bool CanExecuteEditAction(object parameter);
    protected virtual bool CanExecuteReorder(object parameter);
    protected virtual bool CanExecuteToggleEditMode(object parameter);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void ExecuteAdd(object parameter);
    protected virtual void ExecuteDelete(object parameter);
    protected virtual void ExecuteEdit(object parameter);
    protected virtual void ExecuteEditAction(object parameter);
    protected virtual void ExecuteReorder(object parameter);
    protected virtual void ExecuteToggleEditMode(object parameter);
    protected virtual Type GetType(string propertyName);
    protected virtual object GetValue(string propertyName);
    protected virtual bool HasPropertyAccessor(string propertyName);
    protected virtual void OnDataChanged(T item);
    protected virtual void OnDataInserted(T item);
    protected virtual void OnDataInserted(IEnumerable`1<T> items);
    protected virtual void OnDataRemoved(T item);
    protected virtual void OnDataRemoved(IEnumerable`1<T> items);
    protected virtual void SetValue(string propertyName, object value);
    private void _OnDataChanged(T a);
    private void _OnDataInserted(IEnumerable`1<T> a);
    private void _OnDataRemoved(IEnumerable`1<T> a);
    private void Initialize();
}
public class Intersoft.Crosslight.ViewModels.EditorViewModelBase`1 : DetailViewModelBase`1<T> {
    private string a;
    private bool b;
    private bool c;
    private bool d;
    private bool e;
    private bool f;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataChangedEventArgs> g;
    [CompilerGeneratedAttribute]
private DelegateCommand h;
    [CompilerGeneratedAttribute]
private Type i;
    [CompilerGeneratedAttribute]
private DelegateCommand j;
    public DelegateCommand CancelCommand { get; public set; }
    public string ErrorMessage { get; public set; }
    public Type FormMetadataType { get; private set; }
    public bool HasErrors { get; }
    public bool IsCancelled { get; public set; }
    public bool IsDismissHandled { get; public set; }
    public bool IsDirty { get; public set; }
    public bool IsInitializing { get; public set; }
    public bool IsNewItem { get; public set; }
    public DelegateCommand SaveCommand { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DataChanged(EventHandler`1<DataChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_CancelCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CancelCommand(DelegateCommand value);
    public string get_ErrorMessage();
    public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public virtual Type get_FormMetadataType();
    [CompilerGeneratedAttribute]
private void set_FormMetadataType(Type value);
    public virtual bool get_HasErrors();
    public sealed virtual bool get_IsCancelled();
    public sealed virtual void set_IsCancelled(bool value);
    public sealed virtual bool get_IsDismissHandled();
    public sealed virtual void set_IsDismissHandled(bool value);
    public sealed virtual bool get_IsDirty();
    public sealed virtual void set_IsDirty(bool value);
    public bool get_IsInitializing();
    public void set_IsInitializing(bool value);
    public sealed virtual bool get_IsNewItem();
    public sealed virtual void set_IsNewItem(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual DelegateCommand get_SaveCommand();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SaveCommand(DelegateCommand value);
    private sealed virtual override void Intersoft.Crosslight.IDataChangeTracker.OnDataChanged(object a);
    private sealed virtual override void Intersoft.Crosslight.IDataValidationErrorManager.ClearErrors();
    public virtual void Validate();
    protected virtual bool CanExecuteCancel(object parameter);
    protected virtual bool CanExecuteSave(object parameter);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void ExecuteCancel(object parameter);
    protected virtual void ExecuteSave(object parameter);
    public virtual void Dismiss(NavigationResultAction action);
    protected virtual void OnDataChanged(T item);
    protected virtual void OnDataInserted(T item);
    protected virtual void OnDataInserted(IEnumerable`1<T> items);
    protected virtual void OnDataRemoved(T item);
    protected virtual void OnDataRemoved(IEnumerable`1<T> items);
    protected virtual void OnErrorsChanged(DataErrorsChangedEventArgs e);
    protected virtual void OnItemChanging(T oldItem, T newItem);
    protected virtual void OnItemPropertyChanged(PropertyChangedEventArgs e);
    private void Item_ErrorsChanged(object a, DataErrorsChangedEventArgs b);
    private void Item_PropertyChanged(object a, PropertyChangedEventArgs b);
}
public class Intersoft.Crosslight.ViewModels.EmptyViewModel : ViewModelBase {
    [CompilerGeneratedAttribute]
private object f;
    public object MyProperty { get; public set; }
    [CompilerGeneratedAttribute]
public object get_MyProperty();
    [CompilerGeneratedAttribute]
public void set_MyProperty(object value);
}
public class Intersoft.Crosslight.ViewModels.GroupListViewModelBase`2 : ListViewModelBase`1<TItem> {
    private TGroup a;
    public TGroup Group { get; public set; }
    public GroupListViewModelBase`2(IViewModel owner);
    public TGroup get_Group();
    public void set_Group(TGroup value);
    protected virtual void OnGroupChanged(TGroup group);
}
public abstract class Intersoft.Crosslight.ViewModels.ListViewModelBase`1 : ViewModelBase`1<T> {
    private IEnumerable a;
    private IEnumerable b;
    private bool c;
    private IEnumerable`1<T> d;
    private IList`1<T> e;
    private T f;
    private IList`1<T> g;
    private ICollection`1<T> h;
    [CompilerGeneratedAttribute]
private DelegateCommand i;
    [CompilerGeneratedAttribute]
private DelegateCommand j;
    [CompilerGeneratedAttribute]
private bool k;
    public IEnumerable`1<T> Items { get; public set; }
    public DelegateCommand RefreshCommand { get; public set; }
    public DelegateCommand SelectedCommand { get; public set; }
    public T SelectedItem { get; public set; }
    public IList`1<T> SelectedItems { get; public set; }
    public ICollection`1<T> SourceItems { get; public set; }
    protected IEnumerable`1<T> OriginalItems { get; }
    public IEnumerable GroupItems { get; public set; }
    public bool EnableAsyncFilter { get; public set; }
    public IEnumerable FilterItems { get; public set; }
    private IEnumerable Intersoft.Crosslight.IListViewModel.Items { get; private set; }
    private object Intersoft.Crosslight.IListViewModel.SelectedItem { get; private set; }
    private IList Intersoft.Crosslight.IListViewModel.SelectedItems { get; private set; }
    private ICollection Intersoft.Crosslight.IListViewModel.SourceItems { get; private set; }
    public ListViewModelBase`1(IViewModel owner);
    public virtual IEnumerable`1<T> get_Items();
    public virtual void set_Items(IEnumerable`1<T> value);
    [CompilerGeneratedAttribute]
public DelegateCommand get_RefreshCommand();
    [CompilerGeneratedAttribute]
public void set_RefreshCommand(DelegateCommand value);
    [CompilerGeneratedAttribute]
public DelegateCommand get_SelectedCommand();
    [CompilerGeneratedAttribute]
public void set_SelectedCommand(DelegateCommand value);
    public virtual T get_SelectedItem();
    public virtual void set_SelectedItem(T value);
    public virtual IList`1<T> get_SelectedItems();
    public virtual void set_SelectedItems(IList`1<T> value);
    public virtual ICollection`1<T> get_SourceItems();
    public virtual void set_SourceItems(ICollection`1<T> value);
    protected IEnumerable`1<T> get_OriginalItems();
    protected virtual bool CanExecuteRefresh(object sender);
    protected virtual bool CanExecuteSelect(object sender);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void ExecuteRefresh(object parameter);
    protected virtual void ExecuteSelect(object parameter);
    protected virtual Type GetType(string propertyName);
    protected virtual object GetValue(string propertyName);
    protected virtual bool HasPropertyAccessor(string propertyName);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnItemsChanged(IEnumerable`1<T> items);
    protected virtual void OnSelectedItemChanged(T newItem);
    protected virtual void OnSelectedItemChanging(T oldItem, T newItem);
    protected virtual void OnSelectedItemsCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnSourceItemsChanged(ICollection`1<T> items);
    protected virtual void SetValue(string propertyName, object value);
    protected virtual void UpdateResources();
    private void Initialize();
    private void Items_CollectionChanged(object a, NotifyCollectionChangedEventArgs b);
    private void SelectedItems_CollectionChanged(object a, NotifyCollectionChangedEventArgs b);
    private void SourceItems_CollectionChanged(object a, NotifyCollectionChangedEventArgs b);
    public virtual IEnumerable get_GroupItems();
    public virtual void set_GroupItems(IEnumerable value);
    public virtual void RefreshGroupItems();
    public virtual void RefreshGroupView();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableAsyncFilter();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableAsyncFilter(bool value);
    public virtual IEnumerable get_FilterItems();
    public virtual void set_FilterItems(IEnumerable value);
    public virtual void Filter(string query, string scope);
    private sealed virtual override IEnumerable Intersoft.Crosslight.IListViewModel.get_Items();
    private sealed virtual override void Intersoft.Crosslight.IListViewModel.set_Items(IEnumerable value);
    private sealed virtual override object Intersoft.Crosslight.IListViewModel.get_SelectedItem();
    private sealed virtual override void Intersoft.Crosslight.IListViewModel.set_SelectedItem(object value);
    private sealed virtual override IList Intersoft.Crosslight.IListViewModel.get_SelectedItems();
    private sealed virtual override void Intersoft.Crosslight.IListViewModel.set_SelectedItems(IList value);
    private sealed virtual override ICollection Intersoft.Crosslight.IListViewModel.get_SourceItems();
    private sealed virtual override void Intersoft.Crosslight.IListViewModel.set_SourceItems(ICollection value);
}
public class Intersoft.Crosslight.ViewModels.MultiPageViewModelBase : ViewModelBase {
    private NavigationItem[] g;
    private int h;
    private IViewModel i;
    public IViewModel SelectedViewModel { get; public set; }
    public int SelectedIndex { get; public set; }
    public NavigationItem[] Items { get; public set; }
    public sealed virtual IViewModel get_SelectedViewModel();
    public sealed virtual void set_SelectedViewModel(IViewModel value);
    public sealed virtual int get_SelectedIndex();
    public sealed virtual void set_SelectedIndex(int value);
    public virtual NavigationItem[] get_Items();
    public virtual void set_Items(NavigationItem[] value);
    protected virtual void OnSelectedIndexChanging(int oldIndex, int newIndex);
    protected virtual void OnSelectedIndexChanged(int newIndex);
}
public abstract class Intersoft.Crosslight.ViewModels.ViewModelBase : object {
    private Dictionary`2<string, object> j;
    private INavigationService k;
    private IActionPresenter l;
    private IMessagePresenter m;
    private IToastPresenter n;
    private IActionToastPresenter o;
    private IActivityPresenter p;
    private IDialogPresenter q;
    private IObservableResource r;
    private EventHandler s;
    private a t;
    private ILog u;
    private IViewModel v;
    private Object[] w;
    private string x;
    private bool y;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler z;
    public IApplicationContext Context { get; }
    public string Title { get; public set; }
    public bool IsAsyncNavigationCompleted { get; public set; }
    internal Object[] ViewMethodArgs { get; internal set; }
    internal a Tag { get; }
    public IObservableResource Resources { get; }
    public ILocalizationService LocalizationService { get; }
    private EventHandler WeakResourceEventHandler { get; }
    public INavigationService NavigationService { get; }
    public ILog Logger { get; }
    public IPresenterService PresenterService { get; }
    public IMessagePresenter MessagePresenter { get; }
    public IToastPresenter ToastPresenter { get; }
    public IActionPresenter ActionPresenter { get; }
    public IActionToastPresenter ActionToastPresenter { get; }
    public IActivityPresenter ActivityPresenter { get; }
    public IDialogPresenter DialogPresenter { get; }
    public IMobileService MobileService { get; }
    public ViewModelBase(IViewModel owner);
    protected virtual override void Finalize();
    public virtual IApplicationContext get_Context();
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public bool get_IsAsyncNavigationCompleted();
    public void set_IsAsyncNavigationCompleted(bool value);
    internal Object[] get_ViewMethodArgs();
    internal void set_ViewMethodArgs(Object[] value);
    internal a get_Tag();
    public virtual void Navigated(NavigatedParameter parameter);
    public virtual bool ShouldNavigate(NavigationTarget target);
    public virtual TService GetService();
    public virtual TService GetService(bool newInstance);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(string propertyName);
    public virtual IObservableResource get_Resources();
    public virtual ILocalizationService get_LocalizationService();
    protected virtual void UpdateResources();
    private void InitializeResources();
    private EventHandler get_WeakResourceEventHandler();
    public void InvokeViewMethod(string methodName, Object[] args);
    protected virtual object GetValue(string propertyName);
    protected virtual void SetValue(string propertyName, object value);
    protected virtual Type GetType(string propertyName);
    protected virtual bool HasPropertyAccessor(string propertyName);
    public object GetProperty(string propertyName, object defaultValue);
    public T GetProperty(string propertyName, object defaultValue);
    public bool SetProperty(string propertyName, object value);
    public bool SetProperty(T& source, T target, Expression`1<Func`1<object>> property);
    public bool IsPropertyEqual(Expression`1<Func`1<object>> sourceProperty, Expression`1<Func`1<object>> targetProperty);
    protected virtual void OnPropertyChanged(Expression`1<Func`1<object>> property);
    private string GetMemberName(Expression a);
    public virtual INavigationService get_NavigationService();
    public virtual ILog get_Logger();
    public virtual IPresenterService get_PresenterService();
    public virtual IMessagePresenter get_MessagePresenter();
    public virtual IToastPresenter get_ToastPresenter();
    public virtual IActionPresenter get_ActionPresenter();
    public virtual IActionToastPresenter get_ActionToastPresenter();
    public virtual IActivityPresenter get_ActivityPresenter();
    public virtual IDialogPresenter get_DialogPresenter();
    public virtual IMobileService get_MobileService();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    public sealed virtual void DisposeServices();
    private sealed virtual override object Intersoft.Crosslight.IPropertyAccessor.GetValue(string a);
    private sealed virtual override void Intersoft.Crosslight.IPropertyAccessor.SetValue(string a, object b);
    private sealed virtual override bool Intersoft.Crosslight.IPropertyAccessor.HasPropertyAccessor(string a);
    private sealed virtual override Type Intersoft.Crosslight.IPropertyAccessor.GetType(string a);
    [CompilerGeneratedAttribute]
private void <get_WeakResourceEventHandler>b__47_0(object a, EventArgs b);
    [CompilerGeneratedAttribute]
private void <Dispose>b__81_0();
}
public abstract class Intersoft.Crosslight.ViewModels.ViewModelBase`1 : ViewModelBase {
    public ViewModelBase`1(IViewModel owner);
}
[AttributeUsageAttribute("4")]
public class Intersoft.Crosslight.ViewModelTypeAttribute : Attribute {
    private Type a;
    public Type ViewModelType { get; }
    public ViewModelTypeAttribute(Type viewModelType);
    public Type get_ViewModelType();
}
public class Intersoft.Crosslight.WeakAction : object {
    private Action a;
    private WeakReference b;
    public Action Action { get; }
    public bool IsAlive { get; }
    public object Target { get; }
    public WeakAction(Action action);
    public Action get_Action();
    public bool get_IsAlive();
    public object get_Target();
    public void Invoke();
    public void Dispose();
}
public class Intersoft.Crosslight.WeakAction`1 : WeakAction {
    private Action`1<T> a;
    public Action`1<T> Action { get; }
    public WeakAction`1(Action`1<T> action);
    public Action`1<T> get_Action();
    public void Invoke();
    public void Execute(T parameter);
}
internal class io : bo {
    private cb hk;
    public virtual bu ToAsn1Object();
}
internal class ip : bo {
    private cb hl;
    public virtual bu ToAsn1Object();
}
internal class iq : bo {
    private pq hm;
    private ih hn;
    private hc ho;
    public virtual bu ToAsn1Object();
}
internal class ir : bo {
    private cb cl;
    public virtual bu ToAsn1Object();
}
internal class is : bo {
    private ir hp;
    private iv hq;
    private ja hr;
    public virtual bu ToAsn1Object();
}
internal class it : bo {
    private iy hs;
    private iq ht;
    public virtual bu ToAsn1Object();
}
internal class iu : bo {
    private le hu;
    private hr hv;
    public virtual bu ToAsn1Object();
}
internal class iv : bo {
    private cb hw;
    public virtual bu ToAsn1Object();
}
internal class iw : bo {
    private iu hx;
    private iy hy;
    public virtual bu ToAsn1Object();
}
internal class ix : bo {
    private iy hz;
    private oe dr;
    public virtual bu ToAsn1Object();
}
internal class iy : bo {
    private bx ia;
    private iz ib;
    public virtual bu ToAsn1Object();
}
internal class iz : bo {
    private ly ic;
    private bx id;
    public virtual bu ToAsn1Object();
}
internal class j : object {
    private Dictionary`2<a, Func`2<object, object>> a;
    private Func`2<object, object> GetIndexerAccessor(Type a, PropertyInfo b, string c);
    private Func`2<object, object> GetPropAccessor(Type a, string b);
    public object GetValue(object a, string b);
}
internal class ja : bo {
    private hw ie;
    private bu ig;
    public virtual bu ToAsn1Object();
}
internal class jb : bo {
    private hw ih;
    private bu ii;
    public virtual bu ToAsn1Object();
}
internal class jc : bo {
    private cb ec;
    private cb ij;
    public virtual bu ToAsn1Object();
}
internal class jd : bo {
    private cb ik;
    private cb il;
    private jb ii;
    public virtual bu ToAsn1Object();
}
internal class je : bo {
    private hw im;
    private iz in;
    private cb io;
    public virtual bu ToAsn1Object();
}
internal class jf : bo {
    private je ip;
    public virtual bu ToAsn1Object();
}
internal class jg : bo {
    private cb iq;
    private nj ir;
    public virtual bu ToAsn1Object();
}
internal class jh : bo {
    private ii is;
    private ii it;
    private cb iu;
    public virtual bu ToAsn1Object();
}
internal class ji : bo {
    private hw iv;
    private bu iw;
    public virtual bu ToAsn1Object();
}
internal class jj : bo {
    private ii ix;
    private hw da;
    public virtual bu ToAsn1Object();
}
internal class jk : bo {
    private bx fh;
    public virtual bu ToAsn1Object();
}
internal class jl : bo {
    private bx ac;
    private oe dr;
    public virtual bu ToAsn1Object();
}
internal class jm : bo {
    private ly ic;
    private Byte[] ac;
    private oe dr;
    private static ly iy;
    private static jm();
    public virtual bu ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
internal class jn : bo {
    private bo hz;
    private oe dr;
    public virtual bu ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
internal class jo : bo {
    private cb ec;
    private cb ij;
    public virtual bu ToAsn1Object();
}
internal class jp : bo {
    private cb ec;
    private cb ij;
    public virtual bu ToAsn1Object();
}
internal class jq : bo {
    private cb ec;
    private cb ij;
    public virtual bu ToAsn1Object();
}
internal abstract class jr : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    private static jr();
}
internal class js : bo {
    private hc cp;
    private pl[] iz;
    public virtual bu ToAsn1Object();
}
internal class jt : bo {
    private hc ja;
    private bx jb;
    public virtual bu ToAsn1Object();
}
internal class ju : bo {
    private hc cp;
    private ly jc;
    private jt[] jd;
    private jv je;
    public virtual bu ToAsn1Object();
}
internal class jv : bo {
    private hy jf;
    private hy jg;
    public virtual bu ToAsn1Object();
}
internal class jw : hk {
    private int j;
    private bool k;
    internal jw(Stream a, int b);
    internal void SetEofOn00(bool a);
    private bool CheckForEof();
    public virtual int Read(Byte[] a, int b, int c);
    public virtual int ReadByte();
    private int RequireByte();
}
internal abstract class jx : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    private static jx();
}
internal class jy : bo {
    private ly ic;
    private Byte[] jh;
    public virtual bu ToAsn1Object();
}
internal class jz : bo {
    private pl ji;
    private Byte[] jj;
    private Byte[] jk;
    public virtual bu ToAsn1Object();
}
internal class k : object {
    private BindingContext a;
    [CompilerGeneratedAttribute]
private List`1<a> b;
    [CompilerGeneratedAttribute]
private object c;
    [CompilerGeneratedAttribute]
private bool d;
    internal bool IsDirectSource { get; }
    internal List`1<a> PropertyPathSteps { get; internal set; }
    private object EffectiveValue { get; private set; }
    private bool IsAttached { get; private set; }
    internal bool ListenToChanges { get; }
    internal i PropertyInfo { get; }
    internal object EffectiveSource { get; }
    internal string Property { get; }
    internal k(BindingContext a);
    internal bool get_IsDirectSource();
    [CompilerGeneratedAttribute]
internal List`1<a> get_PropertyPathSteps();
    [CompilerGeneratedAttribute]
internal void set_PropertyPathSteps(List`1<a> value);
    [CompilerGeneratedAttribute]
private object get_EffectiveValue();
    [CompilerGeneratedAttribute]
private void set_EffectiveValue(object value);
    [CompilerGeneratedAttribute]
private bool get_IsAttached();
    [CompilerGeneratedAttribute]
private void set_IsAttached(bool value);
    internal bool get_ListenToChanges();
    internal i get_PropertyInfo();
    internal object get_EffectiveSource();
    internal string get_Property();
    internal object GetRawValue();
    internal object GetEffectiveValue(Type a);
    internal void InvalidateEffectiveValue();
    internal void SetValue(object a);
    internal object GetConvertedValue(object a, Type b);
    internal void Detach();
    internal void OnSourceObjectAvailable();
    private void RefreshPropertyPath();
    private void SourcePropertyChanged(object a, PropertyChangedEventArgs b);
    private void ParentPropertyChanged(object a, PropertyChangedEventArgs b);
}
internal class ka : bo {
    private nf jl;
    public virtual bu ToAsn1Object();
}
internal class kb : bo {
    private nz jm;
    private kf jn;
    private cb jo;
    public virtual bu ToAsn1Object();
}
internal class kc : bo {
    private nz jm;
    private cb jp;
    public virtual bu ToAsn1Object();
}
internal class kd : bo {
    private ch jq;
    public virtual bu ToAsn1Object();
}
internal class ke : bo {
    private hy jr;
    private hc js;
    private hc jt;
    public virtual bu ToAsn1Object();
}
internal class kf : bo {
    public static hw ju;
    private hw jv;
    private string jw;
    private nf jx;
    private static kf();
    public virtual bu ToAsn1Object();
}
internal class kg : bo {
    private string jy;
    private nf jz;
    private nz ka;
    private oe kb;
    public virtual bu ToAsn1Object();
}
internal class kh : bo {
    public static hw kc;
    public static hw kd;
    public static hw ke;
    public static hw kf;
    public static hw kg;
    public static hw kh;
    public static hw ki;
    public static hw kj;
    public static hw kk;
    public static hw kl;
    public static hw km;
    public static hw kn;
    public static hw ko;
    public static hw kp;
    public static hw kq;
    public static hw kr;
    public static hw ks;
    public static hw kt;
    public static hw ku;
    private kf jn;
    private cb kv;
    private cb kw;
    private string kx;
    private bx ky;
    private static kh();
    public virtual bu ToAsn1Object();
}
internal class ki : bo {
    private nf kz;
    public virtual bu ToAsn1Object();
}
internal abstract class kj : object {
    public static hw a;
    public static hw b;
    private static kj();
}
internal class kk : bt {
    public kk(Byte[] a);
    internal virtual cw CreateDerSequence(hl a);
    internal virtual da CreateDerSet(hl a);
}
[DefaultMemberAttribute("Item")]
internal class kl : cw {
    private Byte[] la;
    public bo Item { get; }
    public int Count { get; }
    internal kl(Byte[] a);
    private void Parse();
    public virtual bo get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(by a);
}
[DefaultMemberAttribute("Item")]
internal class km : da {
    private Byte[] la;
    public bo Item { get; }
    public int Count { get; }
    internal km(Byte[] a);
    private void Parse();
    public virtual bo get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(by a);
}
internal class kn : bo {
    private hc lb;
    private bx gq;
    public virtual bu ToAsn1Object();
}
internal class ko : bo {
    internal bx gq;
    public virtual bu ToAsn1Object();
}
internal class kp : ed {
    public virtual string ToString();
}
internal class kq : hu {
    public virtual string ToString();
}
internal class kr : hu {
    public virtual string ToString();
}
internal class ks : bo {
    private cb lc;
    public virtual bu ToAsn1Object();
}
internal class kt : object {
    private static IDictionary a;
    private static IDictionary b;
    private static kt();
    private static void DefineCurve(string a, hw b);
    public static qa GetByOid(hw a);
}
internal class ku : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    public static hw v;
    public static hw w;
    public static hw x;
    public static hw y;
    public static hw z;
    public static hw aa;
    public static hw ab;
    public static hw ac;
    public static hw ad;
    public static hw ae;
    public static hw af;
    private static ku();
}
internal abstract class kv : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    private static kv();
}
internal class kw : bo {
    private lg ld;
    private ly le;
    private ed gf;
    private cb ec;
    public virtual bu ToAsn1Object();
}
internal class kx : bo {
    private ly ic;
    private bx lf;
    private bx lg;
    private hc dj;
    public virtual bu ToAsn1Object();
}
internal class ky : bo {
    private int d;
    private bo fh;
    public virtual bu ToAsn1Object();
}
internal class kz : bo {
    private hu lh;
    private hc li;
    private hr lj;
    public virtual bu ToAsn1Object();
}
internal class l : ProductInfo {
}
internal class la : bo {
    private ll lk;
    private lj ll;
    public virtual bu ToAsn1Object();
}
internal class lb : bo {
    private lc lm;
    private lf ln;
    public virtual bu ToAsn1Object();
}
internal class lc : ho {
}
internal class ld : bo {
    private kx lo;
    private pp lp;
    public virtual bu ToAsn1Object();
}
internal class le : bo {
    private bo eb;
    public virtual bu ToAsn1Object();
}
internal class lf : bo {
    private hw lq;
    private bx x;
    public virtual bu ToAsn1Object();
}
internal class lg : bo {
    private static hc lr;
    private bool ls;
    private hc cp;
    private le lt;
    private hr hv;
    private cb lu;
    private pp lv;
    private static lg();
    public virtual bu ToAsn1Object();
}
internal class lh : bo {
    private hr lw;
    private ns lx;
    public virtual bu ToAsn1Object();
}
internal class li : bo {
    private pq fi;
    private bu ly;
    public virtual bu ToAsn1Object();
}
internal class lj : bo {
    internal ly le;
    internal ed lz;
    internal cb ec;
    public virtual bu ToAsn1Object();
}
internal class lk : bo {
    private kx ma;
    private ky mb;
    private hr mc;
    private hr md;
    private pp me;
    public virtual bu ToAsn1Object();
}
internal class ll : bo {
    private static hc lr;
    private hc cp;
    private nz mf;
    private cb mg;
    private pp mh;
    private bool mi;
    private static ll();
    public virtual bu ToAsn1Object();
}
internal class lm : object {
    private string a;
    private int b;
    public bool HasMoreTokens { get; }
    public lm(string a);
    public bool get_HasMoreTokens();
    public string NextToken();
}
internal class ln : bo {
    internal hc gk;
    internal hc mj;
    public zy P { get; }
    public zy G { get; }
    public ln(zy a, zy b);
    public ln(cb a);
    public zy get_P();
    public zy get_G();
    public virtual bu ToAsn1Object();
}
internal abstract class lo : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    private static lo();
}
internal class lp : bo {
    private hw cm;
    private cd cn;
    public virtual bu ToAsn1Object();
}
internal class lq : bo {
    private lu[] el;
    public virtual bu ToAsn1Object();
}
internal class lr : bo {
    private hw ma;
    private bu mk;
    public virtual bu ToAsn1Object();
}
internal class ls : bo {
    protected lt ml;
    protected ly mm;
    protected ed mn;
    public virtual bu ToAsn1Object();
}
internal class lt : bo {
    internal hc cp;
    internal pq mo;
    internal pb mp;
    internal cd co;
    public virtual bu ToAsn1Object();
    internal static int WSasZdnWJJCQ(int a);
}
internal class lu : bo {
    private hw da;
    private bo q;
    public virtual bu ToAsn1Object();
}
internal class lv : bo {
    internal hc gk;
    internal hc mj;
    internal hc mq;
    public zy P { get; }
    public zy G { get; }
    public zy L { get; }
    public lv(zy a, zy b, int c);
    public lv(cb a);
    public zy get_P();
    public zy get_G();
    public zy get_L();
    public virtual bu ToAsn1Object();
}
internal class lw : bo {
    private cb az;
    public virtual bu ToAsn1Object();
}
internal class lx : bo {
    private ly mr;
    private bx az;
    public ly EncryptionAlgorithm { get; }
    private lx(cb a);
    public lx(ly a, Byte[] b);
    public static lx GetInstance(object a);
    public ly get_EncryptionAlgorithm();
    public Byte[] GetEncryptedData();
    public virtual bu ToAsn1Object();
}
internal class ly : bo {
    private hw ms;
    private bo mt;
    private bool mu;
    public hw ObjectID { get; }
    public bo Parameters { get; }
    public ly(hw a);
    public ly(string a);
    public ly(hw a, bo b);
    internal ly(cb a);
    public static ly GetInstance(object a);
    public virtual hw get_ObjectID();
    public bo get_Parameters();
    public virtual bu ToAsn1Object();
}
internal class lz : ly {
    public lz(hw a, bo b);
    internal lz(cb a);
    public static lz GetInstance(object a);
    public virtual bu ToAsn1Object();
}
internal interface m {
    public string Value1 { get; public set; }
    public Nullable`1<bool> Value2 { get; public set; }
    public abstract virtual string get_Value1();
    public abstract virtual void set_Value1(string value);
    public abstract virtual Nullable`1<bool> get_Value2();
    public abstract virtual void set_Value2(Nullable`1<bool> value);
}
internal class ma : bo {
    private pq di;
    private hc mv;
    public virtual bu ToAsn1Object();
}
internal class mb : ly {
    internal mb(cb a);
    public mb(hw a, bo b);
}
internal class mc : bo {
    internal nt mw;
    internal Byte[] au;
    internal zy av;
    public virtual bu ToAsn1Object();
}
internal class md : bo {
    private bx au;
    private hc av;
    public zy IterationCount { get; }
    private md(cb a);
    public md(Byte[] a, int b);
    public static md GetInstance(object a);
    public Byte[] GetSalt();
    public zy get_IterationCount();
    public virtual bu ToAsn1Object();
}
internal class me : bo {
    private mb mx;
    private lz my;
    public mb KeyDerivationFunc { get; }
    public lz EncryptionScheme { get; }
    public me(cb a);
    public static me GetInstance(object a);
    public mb get_KeyDerivationFunc();
    public lz get_EncryptionScheme();
    public virtual bu ToAsn1Object();
}
internal class mf : bo {
    private bx mz;
    private hc av;
    private hc lb;
    public zy IterationCount { get; }
    public zy KeyLength { get; }
    public mf(cb a);
    public mf(Byte[] a, int b);
    public static mf GetInstance(object a);
    public Byte[] GetSalt();
    public zy get_IterationCount();
    public zy get_KeyLength();
    public virtual bu ToAsn1Object();
    internal static int sFKZnSURtKWO(int a);
}
internal class mg : bo {
    private lu eo;
    private mc na;
    public virtual bu ToAsn1Object();
}
internal class mh : bo {
    private hc nb;
    private bx gq;
    public zy Iterations { get; }
    public mh(Byte[] a, int b);
    private mh(cb a);
    public static mh GetInstance(object a);
    public zy get_Iterations();
    public Byte[] GetIV();
    public virtual bu ToAsn1Object();
}
internal abstract class mi : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    public static hw v;
    public static hw w;
    public static hw x;
    public static hw y;
    public static hw z;
    public static hw aa;
    public static hw ab;
    public static hw ac;
    public static hw ad;
    public static hw ae;
    public static hw af;
    public static hw ag;
    public static hw ah;
    public static hw ai;
    public static hw aj;
    public static hw ak;
    public static hw al;
    public static hw am;
    public static hw an;
    public static hw ao;
    public static hw ap;
    public static hw aq;
    public static hw ar;
    public static hw as;
    public static hw at;
    public static hw au;
    public static hw av;
    public static hw aw;
    public static hw ax;
    public static hw ay;
    public static hw az;
    public static hw ba;
    [ObsoleteAttribute("Use X509Certificate instead")]
public static hw bb;
    public static hw bc;
    public static hw bd;
    public static hw be;
    public static hw bf;
    public static hw bg;
    public static hw bh;
    public static hw bi;
    public static hw bj;
    public static hw bk;
    public static hw bl;
    public static hw bm;
    public static hw bn;
    public static hw bo;
    public static hw bp;
    public static hw bq;
    public static hw br;
    public static hw bs;
    public static hw bt;
    public static hw bu;
    public static hw bv;
    public static hw bw;
    public static hw bx;
    public static hw by;
    public static hw bz;
    public static hw ca;
    public static hw cb;
    public static hw cc;
    public static hw cd;
    public static hw ce;
    public static hw cf;
    public static hw cg;
    public static hw ch;
    public static hw ci;
    public static hw cj;
    public static hw ck;
    public static hw cl;
    public static hw cm;
    public static hw cn;
    public static hw co;
    public static hw cp;
    [ObsoleteAttribute("Use 'IdAAEtsSigPolicyID' instead")]
public static hw cq;
    [ObsoleteAttribute("Use 'IdAAEtsCommitmentType' instead")]
public static hw cr;
    [ObsoleteAttribute("Use 'IdAAEtsSignerLocation' instead")]
public static hw cs;
    [ObsoleteAttribute("Use 'IdAAEtsOtherSigCert' instead")]
public static hw ct;
    public static hw cu;
    public static hw cv;
    public static hw cw;
    public static hw cx;
    public static hw cy;
    public static hw cz;
    public static hw da;
    public static hw db;
    public static hw dc;
    public static hw dd;
    public static hw de;
    public static hw df;
    public static hw dg;
    public static hw dh;
    public static hw di;
    public static hw dj;
    private static mi();
}
internal class mj : bo {
    private bu nc;
    private ly gb;
    private cd co;
    public ly AlgorithmID { get; }
    public bu PrivateKey { get; }
    public mj(ly a, bu b);
    public mj(ly a, bu b, cd c);
    private mj(cb a);
    public static mj GetInstance(object a);
    public ly get_AlgorithmID();
    public bu get_PrivateKey();
    public virtual bu ToAsn1Object();
}
internal class mk : bo {
    internal hc cp;
    internal bx gq;
    private mk(cb a);
    public static mk GetInstance(object a);
    public Byte[] GetIV();
    public virtual bu ToAsn1Object();
}
internal class ml : bo {
    private ly ic;
    private ly nd;
    private ly ne;
    public static ly nf;
    public static ly ng;
    public static ly nh;
    private static ml();
    public virtual bu ToAsn1Object();
}
internal class mm : bo {
    private zy ni;
    private zy nj;
    private zy nk;
    private zy nl;
    private zy nm;
    private zy nn;
    private zy no;
    private zy np;
    public zy Modulus { get; }
    public zy PublicExponent { get; }
    public zy PrivateExponent { get; }
    public zy Prime1 { get; }
    public zy Prime2 { get; }
    public zy Exponent1 { get; }
    public zy Exponent2 { get; }
    public zy Coefficient { get; }
    public mm(zy a, zy b, zy c, zy d, zy e, zy f, zy g, zy h);
    public mm(cb a);
    public zy get_Modulus();
    public zy get_PublicExponent();
    public zy get_PrivateExponent();
    public zy get_Prime1();
    public zy get_Prime2();
    public zy get_Exponent1();
    public zy get_Exponent2();
    public zy get_Coefficient();
    public virtual bu ToAsn1Object();
}
internal class mn : bo {
    private ly ic;
    private ly nd;
    private hc nq;
    private hc nr;
    public static ly nf;
    public static ly ng;
    public static hc ns;
    public static hc nt;
    public mn(ly a, ly b, hc c, hc d);
    private static mn();
    public virtual bu ToAsn1Object();
}
internal class mo : bo {
    private hw nu;
    private bu nv;
    private cd nw;
    public virtual bu ToAsn1Object();
}
internal class mp : bo {
    private hc cp;
    private cd en;
    private lu eo;
    private cd ep;
    private cd cl;
    private cd eq;
    public virtual bu ToAsn1Object();
}
internal class mq : bo {
    private hc cp;
    private ma nx;
    private ly eu;
    private cd ev;
    private ly ew;
    private bx ex;
    private cd ey;
    public virtual bu ToAsn1Object();
}
internal class mr : bo {
    private cb b;
    public mr(cb a);
    public mr(zy a);
    public mr(zy a, bo b);
    public mr(zy a, ed b, bo c);
    public zy GetKey();
    public virtual bu ToAsn1Object();
}
internal class ms : object {
    private static IDictionary a;
    private static IDictionary b;
    private static IDictionary c;
    private static ms();
    private static zy FromHex(string a);
    private static void DefineCurve(string a, hw b, mt c);
    public static qa GetByOid(hw a);
}
internal abstract class mt : object {
    private qa b;
    public qa Parameters { get; }
    public qa get_Parameters();
    protected abstract virtual qa CreateParameters();
}
internal abstract class mu : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    public static hw v;
    public static hw w;
    public static hw x;
    public static hw y;
    public static hw z;
    public static hw aa;
    public static hw ab;
    public static hw ac;
    public static hw ad;
    public static hw ae;
    public static hw af;
    public static hw ag;
    public static hw ah;
    private static mu();
}
internal class mv : bo {
    public static hw ny;
    public static hw nz;
    public static hw oa;
    public static hw ob;
    public static hw oc;
    public static hw od;
    private cb oe;
    private static mv();
    public virtual bu ToAsn1Object();
}
internal class mw : bo {
    private hw cm;
    private cd cn;
    public virtual bu ToAsn1Object();
}
internal class mx : bo {
    public static hw ny;
    public static hw nz;
    public static hw of;
    public static hw ob;
    public static hw oc;
    public static hw od;
    private hw og;
    private bu mt;
    private static mx();
    public virtual bu ToAsn1Object();
}
internal class my : object {
    private static IDictionary a;
    private static IDictionary b;
    private static IDictionary c;
    private static my();
    private static void DefineCurve(string a, hw b, mt c);
    public static qa GetByOid(hw a);
}
internal class mz : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    public static hw v;
    public static hw w;
    public static hw x;
    public static hw y;
    public static hw z;
    public static hw aa;
    public static hw ab;
    private static mz();
}
internal class n : object {
    private string a;
    private Nullable`1<bool> b;
    private string m.Value1 { get; private set; }
    private Nullable`1<bool> m.Value2 { get; private set; }
    private sealed virtual override string m.get_Value1();
    private sealed virtual override void m.set_Value1(string a);
    private sealed virtual override Nullable`1<bool> m.get_Value2();
    private sealed virtual override void m.set_Value2(Nullable`1<bool> a);
}
internal class na : bo {
    private hc oh;
    private hc oi;
    private hc oj;
    public virtual bu ToAsn1Object();
}
internal class nb : bo {
    private ly ic;
    private Byte[] ok;
    public virtual bu ToAsn1Object();
}
internal class nc : bo {
    private hc cp;
    private nb ol;
    private hw om;
    private hc on;
    private hn fj;
    private pp oo;
    public virtual bu ToAsn1Object();
}
internal class nd : bo {
    private el aj;
    private fd op;
    public virtual bu ToAsn1Object();
}
internal class ne : bo {
    private hc cp;
    private hw oq;
    private nb ol;
    private hc dj;
    private hr or;
    private na os;
    private hn ot;
    private hc on;
    private nz ou;
    private pp oo;
    public virtual bu ToAsn1Object();
}
internal class nf : bo {
    private ec a;
    public sealed virtual string GetString();
    public virtual bu ToAsn1Object();
}
internal class ng : bo {
    public static hw ov;
    public static hw ow;
    private hw ox;
    private nz oy;
    private static ng();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class nh : bo {
    internal bu oz;
    public virtual bu ToAsn1Object();
}
internal class ni : bo {
    private hr pa;
    private hr pb;
    public virtual bu ToAsn1Object();
}
internal class nj : bo {
    private nk pc;
    private ly le;
    private ed lz;
    public virtual bu ToAsn1Object();
}
internal class nk : bo {
    internal hc cp;
    internal oc pd;
    internal nh fi;
    internal ly gf;
    internal hc dj;
    internal ni pe;
    internal cb co;
    internal ed pf;
    internal pp oo;
    public virtual bu ToAsn1Object();
}
internal class nl : bo {
    private ng[] pg;
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class nm : bo {
    internal bx ph;
    internal oa pi;
    internal hc pj;
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class nn : bo {
    private hn pk;
    private hc pl;
    public bool IsCA();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class no : bo {
    private ph pm;
    private ly pn;
    private ed po;
    public virtual bu ToAsn1Object();
}
internal class np : bo {
    private pl pp;
    private pl pq;
    public virtual bu ToAsn1Object();
}
internal class nq : bo {
    internal cb b;
    public nv[] GetDistributionPoints();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class nr : hc {
    public zy Number { get; }
    public zy get_Number();
    public virtual string ToString();
}
internal class ns : ho {
    private static String[] pr;
    private static ns();
    public virtual string ToString();
}
internal class nt : bo {
    private Byte[] ps;
    private ly gb;
    public nt(ly a, Byte[] b);
    public virtual bu ToAsn1Object();
}
internal class nu : bo {
    internal eb pt;
    public virtual bu ToAsn1Object();
}
internal class nv : bo {
    internal nw pu;
    internal ou pv;
    internal oa pw;
    private nv(cb a);
    public static nv GetInstance(object a);
    public virtual bu ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder a, string b, string c, string d);
}
internal class nw : bo {
    internal bo di;
    internal int fg;
    public nw(ch a);
    public static nw GetInstance(ch a, bool b);
    public static nw GetInstance(object a);
    public virtual bu ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder a, string b, string c, string d);
}
internal class nx : bo {
    internal hc gk;
    internal hc gl;
    internal hc mj;
    public zy P { get; }
    public zy Q { get; }
    public zy G { get; }
    public nx(zy a, zy b, zy c);
    private nx(cb a);
    public static nx GetInstance(object a);
    public zy get_P();
    public zy get_Q();
    public zy get_G();
    public virtual bu ToAsn1Object();
}
internal class ny : bo {
    internal cb b;
    public virtual bu ToAsn1Object();
}
internal class nz : bo {
    internal bo f;
    internal int h;
    public bo Name { get; }
    public nz(pq a);
    public nz(int a, bo b);
    public static nz GetInstance(object a);
    public bo get_Name();
    public virtual string ToString();
    public virtual bu ToAsn1Object();
}
internal enum o : Enum {
    public int value__;
    public static o a;
    public static o b;
    public static o c;
}
internal class oa : bo {
    private nz[] px;
    private oa(cb a);
    public static oa GetInstance(object a);
    public static oa GetInstance(ch a, bool b);
    public nz[] GetNames();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class ob : bo {
    private nz py;
    private hc pz;
    private hc qa;
    public virtual bu ToAsn1Object();
}
internal class oc : bo {
    internal oe qb;
    internal oa qc;
    internal oj qd;
    private int cp;
    public virtual bu ToAsn1Object();
}
internal class od : bo {
    internal oa qe;
    internal bp qf;
    public virtual bu ToAsn1Object();
}
internal class oe : bo {
    internal oa fi;
    internal hc qg;
    internal ed qh;
    public virtual bu ToAsn1Object();
}
internal class of : bo {
    private nw qi;
    private bool qj;
    private bool qk;
    private ou ql;
    private bool qm;
    private bool qn;
    private cb b;
    public virtual bu ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder a, string b, string c, string d);
}
internal class og : ed {
    public og(int a);
    public virtual string ToString();
}
internal class oh : bo {
    private cb qo;
    private cb qp;
    public virtual bu ToAsn1Object();
}
internal class oi : bo {
    internal nu qq;
    internal cb qr;
    public virtual bu ToAsn1Object();
}
internal class oj : bo {
    internal ho qs;
    internal hw qt;
    internal ly ct;
    internal ed qu;
    public virtual bu ToAsn1Object();
}
internal class ok : bo {
    private hw qv;
    private cb qw;
    public virtual bu ToAsn1Object();
}
internal class ol : bo {
    private cb b;
    public virtual bu ToAsn1Object();
}
internal class om : bo {
    internal hw qx;
    internal bo hj;
    public virtual bu ToAsn1Object();
}
internal class on : bo {
    private hr qy;
    private hr qz;
    public virtual bu ToAsn1Object();
}
internal class oo : bo {
    private ot ra;
    private ly ic;
    private bx rb;
    private hu rc;
    public virtual bu ToAsn1Object();
}
internal class op : bo {
    internal bo f;
    public virtual bu ToAsn1Object();
}
internal class oq : bo {
    internal op jr;
    internal hc js;
    internal hc jt;
    public virtual bu ToAsn1Object();
}
internal class or : bo {
    private hw rd;
    private bo re;
    public virtual bu ToAsn1Object();
}
internal class os : bo {
    private hw rf;
    private nz[] rg;
    public virtual bu ToAsn1Object();
}
internal class ot : bo {
    internal bo f;
    public virtual bu ToAsn1Object();
}
internal class ou : ed {
    public ou(ed a);
}
internal class ov : bo {
    private oa rh;
    private nz ri;
    public string GetRoleNameAsString();
    public String[] GetRoleAuthorityAsString();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class ow : bo {
    private zy ni;
    private zy nj;
    public zy Modulus { get; }
    public zy PublicExponent { get; }
    public ow(zy a, zy b);
    private ow(cb a);
    public static ow GetInstance(object a);
    public zy get_Modulus();
    public zy get_PublicExponent();
    public virtual bu ToAsn1Object();
}
internal class ox : bo {
    private nf rj;
    private nf rk;
    private cb rl;
    public virtual bu ToAsn1Object();
}
internal class oy : bo {
    private ox rm;
    private zy rn;
    private hr ro;
    private nf rp;
    private string rq;
    private nf iu;
    public virtual bu ToAsn1Object();
}
internal class oz : bo {
    private IList co;
    public virtual bu ToAsn1Object();
}
internal class p : object {
    [CompilerGeneratedAttribute]
private MemberInfo a;
    [CompilerGeneratedAttribute]
private a b;
    internal MemberInfo Info { get; internal set; }
    internal a Delegate { get; internal set; }
    internal PropertyInfo PropertyInfo { get; }
    internal FieldInfo FieldInfo { get; }
    [CompilerGeneratedAttribute]
internal MemberInfo get_Info();
    [CompilerGeneratedAttribute]
internal void set_Info(MemberInfo value);
    [CompilerGeneratedAttribute]
internal a get_Delegate();
    [CompilerGeneratedAttribute]
internal void set_Delegate(a value);
    internal PropertyInfo get_PropertyInfo();
    internal FieldInfo get_FieldInfo();
    internal Type GetMemberInfoType();
}
internal class pa : bo {
    private Byte[] dk;
    public virtual bu ToAsn1Object();
}
internal class pb : bo {
    private ly gb;
    private ed rr;
    public ly AlgorithmID { get; }
    public ed PublicKeyData { get; }
    public pb(ly a, bo b);
    public pb(ly a, Byte[] b);
    private pb(cb a);
    public static pb GetInstance(object a);
    public ly get_AlgorithmID();
    public bu GetPublicKey();
    public ed get_PublicKeyData();
    public virtual bu ToAsn1Object();
}
internal class pc : bo {
    private nz rs;
    private nz rt;
    public virtual bu ToAsn1Object();
}
internal class pd : bo {
    private cb ru;
    public virtual bu ToAsn1Object();
}
internal class pe : bo {
    private cb ru;
    public virtual bu ToAsn1Object();
}
internal class pf : bo {
    internal cb b;
    public virtual bu ToAsn1Object();
}
internal class pg : bo {
    internal cb b;
    public virtual bu ToAsn1Object();
}
internal class ph : bo {
    internal cb b;
    public virtual bu ToAsn1Object();
}
internal class pi : bo {
    internal bu ez;
    public string GetTime();
    public virtual bu ToAsn1Object();
    public virtual string ToString();
}
internal class pj : bo {
    internal oi rv;
    internal nu rw;
    public virtual bu ToAsn1Object();
}
internal class pk : bo {
    internal oa rx;
    internal oe qb;
    internal oj qd;
    public virtual bu ToAsn1Object();
}
internal class pl : bo {
    private pf ry;
    private ly pn;
    private ed po;
    public virtual bu ToAsn1Object();
}
internal abstract class pm : object {
    protected bu ConvertHexEncoded(string a, int b);
    public abstract virtual bu GetConvertedValue(hw a, string b);
}
internal class pn : pm {
    public virtual bu GetConvertedValue(hw a, string b);
}
internal class po : object {
    internal bool a;
    internal bx b;
    public bool IsCritical { get; }
    public bx Value { get; }
    public bool get_IsCritical();
    public bx get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object a);
}
internal class pp : bo {
    public static hw rz;
    public static hw sa;
    public static hw sb;
    public static hw sc;
    public static hw sd;
    public static hw se;
    public static hw sf;
    public static hw sg;
    public static hw sh;
    public static hw si;
    public static hw sj;
    public static hw sk;
    public static hw sl;
    public static hw sm;
    public static hw sn;
    public static hw so;
    public static hw sp;
    public static hw sq;
    public static hw sr;
    public static hw ss;
    public static hw st;
    public static hw su;
    public static hw sv;
    public static hw sw;
    public static hw sx;
    public static hw sy;
    public static hw sz;
    public static hw ta;
    public static hw tb;
    public static hw tc;
    public static hw td;
    private IDictionary oo;
    private IList ot;
    private static pp();
    public virtual bu ToAsn1Object();
}
internal class pq : bo {
    public static hw te;
    public static hw tf;
    public static hw tg;
    public static hw th;
    public static hw ti;
    public static hw tj;
    public static hw tk;
    public static hw tl;
    public static hw tm;
    public static hw tn;
    public static hw to;
    public static hw tp;
    public static hw tq;
    public static hw tr;
    public static hw ts;
    public static hw tt;
    public static hw tu;
    public static hw tv;
    public static hw tw;
    public static hw tx;
    public static hw ty;
    public static hw tz;
    public static hw ua;
    public static hw ub;
    public static hw uc;
    public static hw ud;
    public static hw ue;
    public static hw uf;
    public static hw ug;
    public static hw uh;
    public static hw ui;
    public static hw uj;
    public static hw uk;
    public static hw ul;
    private static Boolean[] um;
    public static IDictionary un;
    public static IDictionary uo;
    public static IDictionary up;
    public static IDictionary uq;
    private IList ot;
    private pm ur;
    private IList qf;
    private IList us;
    private cb b;
    public static bool DefaultReverse { get; }
    private static pq();
    protected pq(cb a);
    public static bool get_DefaultReverse();
    public static pq GetInstance(ch a, bool b);
    public static pq GetInstance(object a);
    public virtual bu ToAsn1Object();
    private void AppendValue(StringBuilder a, IDictionary b, hw c, string d);
    public string ToString(bool a, IDictionary b);
    public virtual string ToString();
}
internal abstract class pr : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    private static pr();
}
internal class ps : bo {
    private hc gk;
    private hc mj;
    private hc gl;
    private hc ut;
    private pu uu;
    public hc P { get; }
    public hc G { get; }
    public hc Q { get; }
    public hc J { get; }
    public pu ValidationParms { get; }
    private ps(cb a);
    public static ps GetInstance(object a);
    private static bo GetNext(IEnumerator a);
    public hc get_P();
    public hc get_G();
    public hc get_Q();
    public hc get_J();
    public pu get_ValidationParms();
    public virtual bu ToAsn1Object();
}
internal class pt : bo {
    private hc gp;
    public hc Y { get; }
    public pt(hc a);
    public static pt GetInstance(object a);
    public hc get_Y();
    public virtual bu ToAsn1Object();
}
internal class pu : bo {
    private ed uv;
    private hc uw;
    public ed Seed { get; }
    public hc PgenCounter { get; }
    private pu(cb a);
    public static pu GetInstance(object a);
    public ed get_Seed();
    public hc get_PgenCounter();
    public virtual bu ToAsn1Object();
}
internal class pv : bo {
    private hw ed;
    private bx ux;
    public virtual bu ToAsn1Object();
}
internal class pw : bo {
    private pv uy;
    private bx uz;
    private bx va;
    public virtual bu ToAsn1Object();
}
internal class px : object {
    private static IDictionary a;
    private static IDictionary b;
    private static IDictionary c;
    private static px();
    private static void DefineCurve(string a, hw b, mt c);
    public static qa GetByOid(hw a);
}
internal class py : bo {
    private bu vb;
    public bool IsNamedCurve { get; }
    public bu Parameters { get; }
    public py(qa a);
    public py(hw a);
    public py(bu a);
    public bool get_IsNamedCurve();
    public bu get_Parameters();
    public virtual bu ToAsn1Object();
}
internal class pz : bo {
    private aad vc;
    private Byte[] uv;
    private hw vd;
    public aad Curve { get; }
    public pz(aad a, Byte[] b);
    public pz(qd a, cb b);
    public aad get_Curve();
    public Byte[] GetSeed();
    public virtual bu ToAsn1Object();
}
[AttributeUsageAttribute("5471")]
internal class q : Attribute {
}
internal class qa : bo {
    private qd ve;
    private aad vc;
    private aak mj;
    private zy vf;
    private zy vg;
    private Byte[] uv;
    public aad Curve { get; }
    public aak G { get; }
    public zy N { get; }
    public zy H { get; }
    public qa(cb a);
    public qa(aad a, aak b, zy c, zy d);
    public qa(aad a, aak b, zy c, zy d, Byte[] e);
    public aad get_Curve();
    public aak get_G();
    public zy get_N();
    public zy get_H();
    public Byte[] GetSeed();
    public virtual bu ToAsn1Object();
}
internal class qb : bo {
    private aak gk;
    public aak Point { get; }
    public qb(aak a);
    public qb(aad a, bx b);
    public aak get_Point();
    public virtual bu ToAsn1Object();
}
internal class qc : bo {
    private aah vh;
    public aah Value { get; }
    public qc(aah a);
    public qc(zy a, bx b);
    public qc(int a, int b, int c, int d, bx e);
    public aah get_Value();
    public virtual bu ToAsn1Object();
}
internal class qd : bo {
    private hw eb;
    private bu mt;
    public hw Identifier { get; }
    public bu Parameters { get; }
    public qd(zy a);
    public qd(int a, int b, int c, int d);
    internal qd(cb a);
    public hw get_Identifier();
    public bu get_Parameters();
    public virtual bu ToAsn1Object();
}
internal class qe : object {
    public static int GetByteLength(aah a);
    public static Byte[] IntegerToBytes(zy a, int b);
}
internal abstract class qf : object {
    public static hw a;
    public static hw b;
    public static hw c;
    public static hw d;
    public static hw e;
    public static hw f;
    public static hw g;
    public static hw h;
    public static hw i;
    public static hw j;
    public static hw k;
    public static hw l;
    public static hw m;
    public static hw n;
    public static hw o;
    public static hw p;
    public static hw q;
    public static hw r;
    public static hw s;
    public static hw t;
    public static hw u;
    public static hw v;
    public static hw w;
    public static hw x;
    public static hw y;
    public static hw z;
    public static hw aa;
    public static hw ab;
    public static hw ac;
    public static hw ad;
    public static hw ae;
    public static hw af;
    public static hw ag;
    public static hw ah;
    public static hw ai;
    public static hw aj;
    public static hw ak;
    public static hw al;
    public static hw am;
    public static hw an;
    public static hw ao;
    public static hw ap;
    public static hw aq;
    public static hw ar;
    public static hw as;
    public static hw at;
    public static hw au;
    public static hw av;
    public static hw aw;
    public static hw ax;
    public static hw ay;
    public static hw az;
    public static hw ba;
    public static hw bb;
    public static hw bc;
    public static hw bd;
    public static hw be;
    public static hw bf;
    private static qf();
}
internal class qg : gh {
    private static Byte[] l;
    private Stream m;
    private bool n;
    private Int32[] o;
    private int p;
    private qk q;
    private bool r;
    private bool s;
    private string t;
    private bool u;
    private bool v;
    private bool w;
    private IList x;
    private int y;
    private bool z;
    private static qg();
    private int Decode(int a, int b, int c, int d, Int32[] e);
    private bool ParseHeaders();
    private int ReadIgnoreSpace();
    private int ReadIgnoreWhitespace();
    private int ReadByteClearText();
    private int ReadClearText(Byte[] a, int b, int c);
    private int DoReadByte();
    public virtual int ReadByte();
    public virtual int Read(Byte[] a, int b, int c);
    public virtual void Close();
}
internal class qh : ct {
    private static Byte[] f;
    private Stream g;
    private Int32[] h;
    private int i;
    private qk j;
    private int k;
    private int l;
    private bool m;
    private bool n;
    private bool o;
    private string p;
    private static string q;
    private static string r;
    private static string s;
    private static string t;
    private static string u;
    private static string v;
    private IDictionary w;
    private static qh();
    private static void Encode(Stream a, Int32[] b, int c);
    public virtual void WriteByte(byte a);
    public virtual void Close();
    private void WriteHeaderEntry(string a, string b);
    private void DoWrite(string a);
}
internal class qi : gh {
    private Stream aa;
    private bool ab;
    private int ac;
    public virtual int ReadByte();
    public virtual int Read(Byte[] a, int b, int c);
    public virtual void Close();
}
internal class qj : ct {
    private Stream x;
    private Byte[] y;
    private int z;
    private int aa;
    private int ab;
    public qj(Stream a, ql b, long c);
    private void WriteNewPacketLength(long a);
    private void WriteHeader(ql a, bool b, bool c, long d);
    private void PartialFlush(bool a);
    private void WritePartial(byte a);
    private void WritePartial(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void Flush();
    public void Finish();
    public virtual void Close();
}
internal class qk : object {
    private int a;
    public int Value { get; }
    public void Update(int a);
    public int get_Value();
    public void Reset();
}
internal enum ql : Enum {
    public int value__;
    public static ql a;
    public static ql b;
    public static ql c;
    public static ql d;
    public static ql e;
    public static ql f;
    public static ql g;
    public static ql h;
    public static ql i;
    public static ql j;
    public static ql k;
    public static ql l;
    public static ql m;
    public static ql n;
    public static ql o;
    public static ql p;
    public static ql q;
    public static ql r;
    public static ql s;
    public static ql t;
    public static ql u;
    public static ql v;
}
internal enum qm : Enum {
    public int value__;
    public static qm a;
    public static qm b;
    public static qm c;
    public static qm d;
}
internal interface qn {
    public abstract virtual ex GetAttributes(IDictionary a);
}
internal class qo : object {
    internal static Int16[] a;
    public static string b;
    public static string c;
    public static string d;
    public static string e;
    public static string f;
    public static string g;
    public static string h;
    public static string i;
    public static string j;
    public static string k;
    public static string l;
    public static string m;
    public static string n;
    public static string o;
    public static string p;
    public static string q;
    public static string r;
    public static string s;
    public static string t;
    internal IList u;
    internal abr v;
    internal qn w;
    public qo(abr a);
    private static qo();
}
internal class qp : qo {
}
internal class qq : qp {
}
internal class qr : object {
}
internal class qs : qo {
}
internal interface qt {
}
internal class qu : object {
    public static string a;
    public static string b;
    public static string c;
    public static string d;
    public static string e;
    public static string f;
    public static string g;
    public static string h;
    public static string i;
    public static string j;
    public static string k;
    public static string l;
    public static string m;
    public static string n;
    public static string o;
    public static string p;
    public static string q;
    private static string r;
    private static string s;
    private static string t;
    private static string u;
    private static string v;
    private static aby w;
    private static IDictionary x;
    internal IList y;
    internal IList z;
    internal IList aa;
    internal IDictionary ab;
    protected abr ac;
    private static qu();
    protected qu(abr a);
    internal static ly GetEncAlgorithmIdentifier(hw a, bo b);
    protected internal virtual IDictionary GetBaseParameters(hw a, ly b, Byte[] c);
    protected internal virtual cd GetAttributeSet(ex a);
}
internal class qv : qu {
    private static qx ad;
    private IList ae;
    private aby af;
    private IDictionary ag;
    private IDictionary ah;
    private bool ai;
    private static qv();
    internal virtual void AddSignerCallback(rg a);
    private void RegisterDigestOid(string a);
}
internal interface qw {
    public abstract virtual gc Generate(hw a, ly b, Byte[] c);
}
internal class qx : object {
    internal static qx a;
    private static IDictionary b;
    private static IDictionary c;
    private static IDictionary d;
    private static qx();
    private static void AddEntries(hw a, string b, string c);
    internal string GetDigestAlgName(string a);
}
internal class qy : IOException {
    public qy(string a);
    public qy(string a, Exception b);
}
internal class qz : object {
}
[AttributeUsageAttribute("1052")]
internal class r : Attribute {
}
internal class ra : object {
    public static cd CreateBerSetFromList(IList a);
}
internal class rb : object {
    private IDictionary a;
    protected virtual IDictionary CreateStandardAttributeTable(IDictionary a);
    public virtual ex GetAttributes(IDictionary a);
}
internal class rc : object {
    private IDictionary a;
    protected virtual IDictionary createStandardAttributeTable(IDictionary a);
    private void DoCreateStandardAttributeTable(IDictionary a, IDictionary b);
    public virtual ex GetAttributes(IDictionary a);
}
internal class rd : ct {
    private sg aq;
    public virtual void WriteByte(byte a);
    public virtual void Write(Byte[] a, int b, int c);
}
internal class re : ct {
    private vl ad;
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
}
internal class rf : ct {
    public virtual void WriteByte(byte a);
    public virtual void Write(Byte[] a, int b, int c);
}
internal class rg : object {
    private static qx a;
    private gc b;
    private ly c;
    public ly DigestAlgorithmID { get; }
    private static rg();
    public ly get_DigestAlgorithmID();
    public gc ToSignerInfo();
}
internal class rh : ct {
    private vp ar;
    public virtual void WriteByte(byte a);
    public virtual void Write(Byte[] a, int b, int c);
}
internal class ri : object {
    private ex a;
    public virtual ex GetAttributes(IDictionary a);
}
internal interface rj {
    public abstract virtual void Init(qt a);
    public abstract virtual zy CalculateAgreement(qt a);
}
internal class rk : object {
    private xj a;
    private xi b;
    public sealed virtual void Init(qt a);
    public sealed virtual zy CalculateAgreement(qt a);
}
internal class rl : object {
    protected internal xv a;
    public sealed virtual void Init(qt a);
    public virtual zy CalculateAgreement(qt a);
}
internal class rm : object {
    private xv a;
    public sealed virtual void Init(qt a);
    public sealed virtual zy CalculateAgreement(qt a);
}
internal class rn : rl {
    private string b;
    private rs c;
    public virtual zy CalculateAgreement(qt a);
    private Byte[] bigIntToBytes(zy a);
}
internal class ro : object {
    protected internal yn a;
    public sealed virtual void Init(qt a);
    public virtual zy CalculateAgreement(qt a);
    private static aak calculateMqvAgreement(xs a, xv b, xv c, xw d, xw e, xw f);
}
internal class rp : ro {
    private string b;
    private rs c;
    public virtual zy CalculateAgreement(qt a);
    private Byte[] bigIntToBytes(zy a);
}
internal interface rq {
}
internal class rr : object {
    private hw a;
    private int b;
    private Byte[] c;
    private Byte[] d;
    public hw Algorithm { get; }
    public int KeySize { get; }
    public rr(hw a, int b, Byte[] c);
    public rr(hw a, int b, Byte[] c, Byte[] d);
    public hw get_Algorithm();
    public int get_KeySize();
    public Byte[] GetZ();
    public Byte[] GetExtraInfo();
}
internal interface rs {
    public sg Digest { get; }
    public abstract virtual void Init(rq a);
    public abstract virtual sg get_Digest();
    public abstract virtual int GenerateBytes(Byte[] a, int b, int c);
}
internal class rt : object {
    private sg a;
    private hw b;
    private int c;
    private Byte[] d;
    private Byte[] e;
    public sg Digest { get; }
    public sealed virtual void Init(rq a);
    public sealed virtual sg get_Digest();
    public sealed virtual int GenerateBytes(Byte[] a, int b, int c);
    private Byte[] integerToBytes(int a);
}
internal class ru : object {
    private rs a;
    private hw b;
    private int c;
    private Byte[] d;
    public sg Digest { get; }
    public sealed virtual void Init(rq a);
    public sealed virtual sg get_Digest();
    public sealed virtual int GenerateBytes(Byte[] a, int b, int c);
    private Byte[] integerToBytes(int a);
}
internal class rv : object {
    private rw a;
    private rw b;
    public rw Public { get; }
    public rw Private { get; }
    public rv(rw a, rw b);
    public rw get_Public();
    public rw get_Private();
}
internal abstract class rw : object {
    private bool a;
    public bool IsPrivate { get; }
    protected rw(bool a);
    public bool get_IsPrivate();
    public virtual bool Equals(object a);
    protected bool Equals(rw a);
    public virtual int GetHashCode();
}
internal interface rx {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int a);
    public abstract virtual int GetUpdateOutputSize(int a);
    public abstract virtual Byte[] ProcessByte(byte a);
    public abstract virtual int ProcessByte(byte a, Byte[] b, int c);
    public abstract virtual Byte[] ProcessBytes(Byte[] a);
    public abstract virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public abstract virtual int ProcessBytes(Byte[] a, Byte[] b, int c);
    public abstract virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] a);
    public abstract virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public abstract virtual int DoFinal(Byte[] a, int b);
    public abstract virtual int DoFinal(Byte[] a, Byte[] b, int c);
    public abstract virtual int DoFinal(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual void Reset();
}
internal abstract class ry : object {
    protected static Byte[] a;
    public string AlgorithmName { get; }
    private static ry();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int a);
    public abstract virtual int GetUpdateOutputSize(int a);
    public abstract virtual Byte[] ProcessByte(byte a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual Byte[] ProcessBytes(Byte[] a);
    public abstract virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual int ProcessBytes(Byte[] a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a);
    public abstract virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual int DoFinal(Byte[] a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual void Reset();
}
internal class rz : ry {
    private wc b;
    public string AlgorithmName { get; }
    public rz(wc a);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int a);
    public virtual int GetOutputSize(int a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual Byte[] ProcessByte(byte a);
    public virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
}
[AttributeUsageAttribute("8191")]
internal class s : Attribute {
}
internal class sa : ry {
    private ta b;
    private Byte[] c;
    private int d;
    public string AlgorithmName { get; }
    public sa(ta a);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual void Init(bool a, qt b);
    public virtual Byte[] ProcessByte(byte a);
    public virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual void Reset();
}
internal class sb : ry {
    internal Byte[] e;
    internal int d;
    internal bool f;
    internal te b;
    public string AlgorithmName { get; }
    public sb(te a);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int a);
    public virtual int GetOutputSize(int a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual Byte[] ProcessByte(byte a);
    public virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
}
internal class sc : ry {
    private tu g;
    private bool f;
    private MemoryStream c;
    public string AlgorithmName { get; }
    public sc(tu a);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual Byte[] ProcessByte(byte a);
    public virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual void Reset();
}
internal class sd : ry {
    private tr b;
    public string AlgorithmName { get; }
    public sd(tr a);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual Byte[] ProcessByte(byte a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual Byte[] ProcessBytes(Byte[] a, int b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] a, int b, int c);
    public virtual void Reset();
}
internal class se : Exception {
    public se(string a);
}
internal class sf : se {
    public sf(string a);
}
internal interface sg {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte a);
    public abstract virtual void BlockUpdate(Byte[] a, int b, int c);
    public abstract virtual int DoFinal(Byte[] a, int b);
    public abstract virtual void Reset();
}
internal abstract class sh : object {
    private Byte[] a;
    private int b;
    private long c;
    public string AlgorithmName { get; }
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] a, int b);
    internal abstract virtual void ProcessLength(long a);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] a, int b);
}
internal class si : object {
    private Byte[] b;
    private Byte[] c;
    private Byte[] d;
    private Byte[] e;
    private Byte[][] f;
    private Byte[] g;
    private int h;
    private ulong i;
    private te j;
    private Byte[] k;
    private Byte[] l;
    private Byte[] m;
    internal Int16[] n;
    internal Int16[] o;
    internal Byte[] p;
    internal Byte[] q;
    internal Byte[] r;
    internal Byte[] s;
    private static Byte[] t;
    public string AlgorithmName { get; }
    private static si();
    private static Byte[][] MakeC();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    private Byte[] P(Byte[] a);
    private Byte[] A(Byte[] a);
    private void E(Byte[] a, Byte[] b, int c, Byte[] d, int e);
    private void fw(Byte[] a);
    private void processBlock(Byte[] a, int b);
    private void finish();
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
    private void sumByteArray(Byte[] a);
    private static void cpyBytesToShort(Byte[] a, Int16[] b);
    private static void cpyShortToBytes(Int16[] a, Byte[] b);
    public sealed virtual int GetByteLength();
}
internal abstract class sj : object {
    private int a;
    private Byte[] b;
    private int c;
    private long d;
    private long e;
    internal ulong f;
    internal ulong g;
    internal ulong h;
    internal ulong i;
    internal ulong j;
    internal ulong k;
    internal ulong l;
    internal ulong m;
    private UInt64[] n;
    private int o;
    internal static UInt64[] p;
    public string AlgorithmName { get; }
    private static sj();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] a, int b);
    private void AdjustByteCounts();
    internal void ProcessLength(long a, long b);
    internal void ProcessBlock();
    private static ulong Ch(ulong a, ulong b, ulong c);
    private static ulong Maj(ulong a, ulong b, ulong c);
    private static ulong Sum0(ulong a);
    private static ulong Sum1(ulong a);
    private static ulong Sigma0(ulong a);
    private static ulong Sigma1(ulong a);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] a, int b);
}
internal class sk : object {
    private Byte[] a;
    private int b;
    private Byte[] c;
    private int d;
    private Byte[] e;
    private int f;
    private static Byte[] g;
    public string AlgorithmName { get; }
    private static sk();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    internal void ProcessChecksum(Byte[] a);
    internal void ProcessBlock(Byte[] a);
}
internal class sl : sh {
    private int d;
    private int e;
    private int f;
    private int g;
    private Int32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    private void UnpackWord(int a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private int RotateLeft(int a, int b);
    private int F(int a, int b, int c);
    private int G(int a, int b, int c);
    private int H(int a, int b, int c);
    internal virtual void ProcessBlock();
}
internal class sm : sh {
    private UInt32 d;
    private UInt32 e;
    private UInt32 f;
    private UInt32 g;
    private UInt32[] h;
    private int i;
    private static int j;
    private static int k;
    private static int l;
    private static int m;
    private static int n;
    private static int o;
    private static int p;
    private static int q;
    private static int r;
    private static int s;
    private static int t;
    private static int u;
    private static int v;
    private static int w;
    private static int x;
    private static int y;
    public string AlgorithmName { get; }
    private static sm();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private static UInt32 RotateLeft(UInt32 a, int b);
    private static UInt32 F(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 G(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 H(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 K(UInt32 a, UInt32 b, UInt32 c);
    internal virtual void ProcessBlock();
}
internal class sn : object {
    private MemoryStream a;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class so : sh {
    private int z;
    private int d;
    private int e;
    private int f;
    private Int32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    private void UnpackWord(int a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private int RL(int a, int b);
    private int F1(int a, int b, int c);
    private int F2(int a, int b, int c);
    private int F3(int a, int b, int c);
    private int F4(int a, int b, int c);
    private int F1(int a, int b, int c, int d, int e, int f);
    private int F2(int a, int b, int c, int d, int e, int f);
    private int F3(int a, int b, int c, int d, int e, int f);
    private int F4(int a, int b, int c, int d, int e, int f);
    private int FF1(int a, int b, int c, int d, int e, int f);
    private int FF2(int a, int b, int c, int d, int e, int f);
    private int FF3(int a, int b, int c, int d, int e, int f);
    private int FF4(int a, int b, int c, int d, int e, int f);
    internal virtual void ProcessBlock();
}
internal class sp : sh {
    private int z;
    private int d;
    private int e;
    private int f;
    private int g;
    private Int32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    private void UnpackWord(int a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private int RL(int a, int b);
    private int F1(int a, int b, int c);
    private int F2(int a, int b, int c);
    private int F3(int a, int b, int c);
    private int F4(int a, int b, int c);
    private int F5(int a, int b, int c);
    internal virtual void ProcessBlock();
}
internal class sq : sh {
    private int z;
    private int d;
    private int e;
    private int f;
    private int g;
    private int aa;
    private int ab;
    private int ac;
    private Int32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    private void UnpackWord(int a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private int RL(int a, int b);
    private int F1(int a, int b, int c);
    private int F2(int a, int b, int c);
    private int F3(int a, int b, int c);
    private int F4(int a, int b, int c);
    private int F1(int a, int b, int c, int d, int e, int f);
    private int F2(int a, int b, int c, int d, int e, int f);
    private int F3(int a, int b, int c, int d, int e, int f);
    private int F4(int a, int b, int c, int d, int e, int f);
    private int FF1(int a, int b, int c, int d, int e, int f);
    private int FF2(int a, int b, int c, int d, int e, int f);
    private int FF3(int a, int b, int c, int d, int e, int f);
    private int FF4(int a, int b, int c, int d, int e, int f);
    internal virtual void ProcessBlock();
}
internal class sr : sh {
    private int z;
    private int d;
    private int e;
    private int f;
    private int g;
    private int aa;
    private int ab;
    private int ac;
    private int ad;
    private int ae;
    private Int32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    private void UnpackWord(int a, Byte[] b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private int RL(int a, int b);
    private int F1(int a, int b, int c);
    private int F2(int a, int b, int c);
    private int F3(int a, int b, int c);
    private int F4(int a, int b, int c);
    private int F5(int a, int b, int c);
    internal virtual void ProcessBlock();
}
internal class ss : sh {
    private UInt32 d;
    private UInt32 e;
    private UInt32 f;
    private UInt32 g;
    private UInt32 aa;
    private UInt32[] h;
    private int i;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private static UInt32 F(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 H(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 G(UInt32 a, UInt32 b, UInt32 c);
    internal virtual void ProcessBlock();
}
internal class st : sh {
    private UInt32 d;
    private UInt32 e;
    private UInt32 f;
    private UInt32 g;
    private UInt32 aa;
    private UInt32 ab;
    private UInt32 ac;
    private UInt32 ad;
    private UInt32[] h;
    private int i;
    internal static UInt32[] af;
    public string AlgorithmName { get; }
    private static st();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static UInt32 Ch(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 Maj(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 Sum0(UInt32 a);
    private static UInt32 Sum1(UInt32 a);
    private static UInt32 Theta0(UInt32 a);
    private static UInt32 Theta1(UInt32 a);
}
internal class su : sh {
    private UInt32 d;
    private UInt32 e;
    private UInt32 f;
    private UInt32 g;
    private UInt32 aa;
    private UInt32 ab;
    private UInt32 ac;
    private UInt32 ad;
    private UInt32[] h;
    private int i;
    private static UInt32[] af;
    public string AlgorithmName { get; }
    private static su();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] a, int b);
    internal virtual void ProcessLength(long a);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 Sum0Maj(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 Theta0(UInt32 a);
    private static UInt32 Theta1(UInt32 a);
}
internal class sv : sj {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
}
internal class sw : sj {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
}
internal class sx : object {
    private sg a;
    private int b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
    public sealed virtual int GetByteLength();
}
internal class sy : object {
    private static Int64[] d;
    private static Int64[] e;
    private static Int64[] f;
    private static Int64[] g;
    private long h;
    private long i;
    private long j;
    private long k;
    private Byte[] l;
    private int m;
    private Int64[] n;
    private int o;
    public string AlgorithmName { get; }
    private static sy();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    private void ProcessWord(Byte[] a, int b);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    private void RoundABC(long a, long b);
    private void RoundBCA(long a, long b);
    private void RoundCAB(long a, long b);
    private void KeySchedule();
    private void ProcessBlock();
    private void UnpackWord(long a, Byte[] b, int c);
    private void ProcessLength(long a);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class sz : object {
    private static Int32[] a;
    private static Int64[] b;
    private static Int64[] c;
    private static Int64[] d;
    private static Int64[] e;
    private static Int64[] f;
    private static Int64[] g;
    private static Int64[] h;
    private static Int64[] i;
    private Int64[] j;
    private static Int16[] k;
    private Byte[] l;
    private int m;
    private Int16[] n;
    private Int64[] o;
    private Int64[] p;
    private Int64[] q;
    private Int64[] r;
    private Int64[] s;
    public string AlgorithmName { get; }
    private static sz();
    private static long packIntoLong(int a, int b, int c, int d, int e, int f, int g, int h);
    private static int maskWithReductionPolynomial(int a);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
    private void processFilledBuffer();
    private static long bytesToLongFromBuffer(Byte[] a, int b);
    private static void convertLongToByteArray(long a, Byte[] b, int c);
    private void processBlock();
    public sealed virtual void Update(byte a);
    private void increment();
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    private void finish();
    private Byte[] copyBitLength();
    public sealed virtual int GetByteLength();
}
[AttributeUsageAttribute("1052")]
internal class t : Attribute {
}
internal interface ta {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
}
internal class tb : object {
    private static zy a;
    private static zy b;
    private static Byte[] c;
    private static Byte[] d;
    private ta e;
    private bool f;
    private int g;
    private int h;
    private zy i;
    public string AlgorithmName { get; }
    public tb(ta a);
    private static tb();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
    private Byte[] EncodeBlock(Byte[] a, int b, int c);
    private Byte[] DecodeBlock(Byte[] a, int b, int c);
}
internal class tc : object {
    private Byte[] a;
    private sg b;
    private sg c;
    private ta d;
    private abr e;
    private bool f;
    public string AlgorithmName { get; }
    public tc(ta a);
    public tc(ta a, sg b);
    public tc(ta a, sg b, Byte[] c);
    public tc(ta a, sg b, sg c, Byte[] d);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
    private Byte[] encodeBlock(Byte[] a, int b, int c);
    private Byte[] decodeBlock(Byte[] a, int b, int c);
    private void ItoOSP(int a, Byte[] b);
    private Byte[] maskGeneratorFunction1(Byte[] a, int b, int c, int d);
}
internal class td : object {
    private static Boolean[] a;
    private abr b;
    private ta c;
    private bool d;
    private bool e;
    private bool f;
    public static bool StrictLengthEnabled { get; }
    public string AlgorithmName { get; }
    private static td();
    public td(ta a);
    public static bool get_StrictLengthEnabled();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
    private Byte[] EncodeBlock(Byte[] a, int b, int c);
    private Byte[] DecodeBlock(Byte[] a, int b, int c);
}
internal interface te {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public abstract virtual void Reset();
}
internal class tf : object {
    private static Byte[] a;
    private static Byte[] b;
    private static Byte[] c;
    private static UInt32[] d;
    private static UInt32[] e;
    private int f;
    private UInt32[0...,0...] g;
    private UInt32 h;
    private UInt32 i;
    private UInt32 j;
    private UInt32 k;
    private bool l;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tf();
    private UInt32 Shift(UInt32 a, int b);
    private UInt32 FFmulX(UInt32 a);
    private UInt32 Inv_Mcol(UInt32 a);
    private UInt32 SubWord(UInt32 a);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] a, bool b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] a, int b);
    private void PackBlock(Byte[] a, int b);
    private void EncryptBlock(UInt32[0...,0...] a);
    private void DecryptBlock(UInt32[0...,0...] a);
}
internal class tg : object {
    private static Byte[] a;
    private static Byte[] b;
    private static Byte[] c;
    private static UInt32[] d;
    private static UInt32[] e;
    private static UInt32[] f;
    private static UInt32[] g;
    private static UInt32[] h;
    private static UInt32[] i;
    private static UInt32[] j;
    private static UInt32[] k;
    private int l;
    private UInt32[0...,0...] m;
    private UInt32 n;
    private UInt32 o;
    private UInt32 p;
    private UInt32 q;
    private bool r;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tg();
    private UInt32 Shift(UInt32 a, int b);
    private UInt32 FFmulX(UInt32 a);
    private UInt32 Inv_Mcol(UInt32 a);
    private UInt32 SubWord(UInt32 a);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] a, bool b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] a, int b);
    private void PackBlock(Byte[] a, int b);
    private void EncryptBlock(UInt32[0...,0...] a);
    private void DecryptBlock(UInt32[0...,0...] a);
}
internal class th : object {
    private static Byte[] a;
    private static Byte[] b;
    private static Byte[] c;
    private int d;
    private UInt32[0...,0...] e;
    private UInt32 f;
    private UInt32 g;
    private UInt32 h;
    private UInt32 i;
    private bool j;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static th();
    private UInt32 Shift(UInt32 a, int b);
    private UInt32 FFmulX(UInt32 a);
    private UInt32 Mcol(UInt32 a);
    private UInt32 Inv_Mcol(UInt32 a);
    private UInt32 SubWord(UInt32 a);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] a, bool b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] a, int b);
    private void PackBlock(Byte[] a, int b);
    private void EncryptBlock(UInt32[0...,0...] a);
    private void DecryptBlock(UInt32[0...,0...] a);
}
internal class ti : object {
    private static UInt32[] a;
    private static UInt32[] b;
    private static UInt32[] c;
    private static UInt32[] d;
    private static UInt32[] e;
    private static int f;
    private static int g;
    private static int h;
    private UInt32[] i;
    private UInt32[] j;
    private UInt32[] k;
    private UInt32[] l;
    private UInt32[] m;
    private bool n;
    private Byte[] o;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static ti();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private UInt32 F(UInt32 a);
    private void ProcessTable(UInt32 a, UInt32 b, UInt32[] c);
    private void SetKey(Byte[] a);
    private void EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void DecryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal class tj : object {
    private bool a;
    private bool b;
    private UInt32[] c;
    private UInt32[] d;
    private UInt32[] e;
    private UInt32[] f;
    private static UInt32[] g;
    private static UInt32[] h;
    private static UInt32[] i;
    private static UInt32[] j;
    private static UInt32[] k;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tj();
    private static UInt32 rightRotate(UInt32 a, int b);
    private static UInt32 leftRotate(UInt32 a, int b);
    private static void roldq(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void decroldq(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void roldqo32(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void decroldqo32(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static UInt32 bytes2uint(Byte[] a, int b);
    private static void uint2bytes(UInt32 a, Byte[] b, int c);
    private static void camelliaF2(UInt32[] a, UInt32[] b, int c);
    private static void camelliaFLs(UInt32[] a, UInt32[] b, int c);
    private void setKey(bool a, Byte[] b);
    private int processBlock128(Byte[] a, int b, Byte[] c, int d);
    private int processBlock192or256(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal class tk : object {
    private bool a;
    private bool b;
    private UInt32[] c;
    private UInt32[] d;
    private UInt32[] e;
    private UInt32[] f;
    private static UInt32[] g;
    private static Byte[] h;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tk();
    private static UInt32 rightRotate(UInt32 a, int b);
    private static UInt32 leftRotate(UInt32 a, int b);
    private static void roldq(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void decroldq(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void roldqo32(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static void decroldqo32(int a, UInt32[] b, int c, UInt32[] d, int e);
    private static UInt32 bytes2uint(Byte[] a, int b);
    private static void uint2bytes(UInt32 a, Byte[] b, int c);
    private byte lRot8(byte a, int b);
    private UInt32 sbox2(int a);
    private UInt32 sbox3(int a);
    private UInt32 sbox4(int a);
    private void camelliaF2(UInt32[] a, UInt32[] b, int c);
    private void camelliaFLs(UInt32[] a, UInt32[] b, int c);
    private void setKey(bool a, Byte[] b);
    private int processBlock128(Byte[] a, int b, Byte[] c, int d);
    private int processBlock192or256(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal class tl : object {
    internal static UInt32[] a;
    internal static UInt32[] b;
    internal static UInt32[] c;
    internal static UInt32[] d;
    internal static UInt32[] e;
    internal static UInt32[] f;
    internal static UInt32[] g;
    internal static UInt32[] h;
    internal static int i;
    internal static int j;
    private Int32[] k;
    private UInt32[] l;
    private bool m;
    private Byte[] n;
    private int o;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tl();
    public sealed virtual void Init(bool a, qt b);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] a);
    internal virtual int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    internal virtual int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    internal static UInt32 F1(UInt32 a, UInt32 b, int c);
    internal static UInt32 F2(UInt32 a, UInt32 b, int c);
    internal static UInt32 F3(UInt32 a, UInt32 b, int c);
    internal void CAST_Encipher(UInt32 a, UInt32 b, UInt32[] c);
    internal void CAST_Decipher(UInt32 a, UInt32 b, UInt32[] c);
    internal static void Bits32ToInts(UInt32 a, Int32[] b, int c);
    internal static UInt32 IntsTo32bits(Int32[] a, int b);
}
internal class tm : tl {
    private Int32[] k;
    private UInt32[] l;
    private Int32[] p;
    private UInt32[] q;
    private UInt32[] n;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] a);
    internal virtual int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    internal virtual int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void CAST_Encipher(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32[] e);
    private void CAST_Decipher(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32[] e);
}
internal class tn : object {
    private Int32[] a;
    private static Int16[] b;
    private static Int32[] c;
    private static Byte[] d;
    private static Byte[] e;
    private static Byte[] f;
    private static UInt32[] g;
    private static UInt32[] h;
    private static UInt32[] i;
    private static UInt32[] j;
    private static UInt32[] k;
    private static UInt32[] l;
    private static UInt32[] m;
    private static UInt32[] n;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tn();
    public virtual void Init(bool a, qt b);
    public virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public virtual void Reset();
    protected static Int32[] GenerateWorkingKey(bool a, Byte[] b);
    internal static void DesFunc(Int32[] a, Byte[] b, int c, Byte[] d, int e);
}
internal class to : tn {
    private Int32[] o;
    private Int32[] p;
    private Int32[] q;
    private bool r;
    public string AlgorithmName { get; }
    public virtual void Init(bool a, qt b);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public virtual void Reset();
}
internal class tp : object {
    private xy a;
    private abr b;
    private bool c;
    private int d;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
}
internal class tq : object {
    private Int32[] a;
    private bool b;
    private Byte[] c;
    private static Byte[] d;
    private static Byte[] e;
    private static Byte[] f;
    private static Byte[] g;
    private static Byte[] h;
    private static Byte[] i;
    private static Byte[] j;
    private static Byte[] k;
    private static IDictionary l;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tq();
    private static void AddSBox(string a, Byte[] b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private Int32[] generateWorkingKey(bool a, Byte[] b);
    private int Gost28147_mainStep(int a, int b);
    private void Gost28147Func(Int32[] a, Byte[] b, int c, Byte[] d, int e);
    private static int bytesToint(Byte[] a, int b);
    private static void intTobytes(int a, Byte[] b, int c);
    public static Byte[] GetSBox(string a);
}
internal interface tr {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual byte ReturnByte(byte a);
    public abstract virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual void Reset();
}
internal class ts : object {
    private UInt32[] a;
    private UInt32[] b;
    private UInt32 c;
    private Byte[] d;
    private Byte[] e;
    private bool f;
    private Byte[] g;
    private int h;
    public string AlgorithmName { get; }
    private static UInt32 F1(UInt32 a);
    private static UInt32 F2(UInt32 a);
    private UInt32 G1(UInt32 a, UInt32 b, UInt32 c);
    private UInt32 G2(UInt32 a, UInt32 b, UInt32 c);
    private static UInt32 RotateLeft(UInt32 a, int b);
    private static UInt32 RotateRight(UInt32 a, int b);
    private UInt32 H1(UInt32 a);
    private UInt32 H2(UInt32 a);
    private static UInt32 Mod1024(UInt32 a);
    private static UInt32 Mod512(UInt32 a);
    private static UInt32 Dim(UInt32 a, UInt32 b);
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte a);
}
internal class tt : object {
    private UInt32[] a;
    private UInt32[] b;
    private UInt32 c;
    private Byte[] d;
    private Byte[] e;
    private bool f;
    private Byte[] g;
    private int h;
    public string AlgorithmName { get; }
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte a);
    private static UInt32 RotateRight(UInt32 a, int b);
}
internal class tu : object {
    private rj a;
    private rs b;
    private vl c;
    private sb d;
    private Byte[] e;
    private bool f;
    private qt g;
    private qt h;
    private yi i;
    public tu(rj a, rs b, vl c);
    private Byte[] DecryptBlock(Byte[] a, int b, int c, Byte[] d);
    private Byte[] EncryptBlock(Byte[] a, int b, int c, Byte[] d);
    private Byte[] GenerateKdfBytes(yl a, int b);
    public Byte[] ProcessBlock(Byte[] a, int b, int c);
}
internal class tv : object {
    private static int d;
    private static int e;
    private UInt32[] f;
    private UInt32[] g;
    private UInt32 h;
    private UInt32 i;
    private UInt32 j;
    private int k;
    private Byte[] l;
    private Byte[] m;
    private bool n;
    public string AlgorithmName { get; }
    private static tv();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual byte ReturnByte(byte a);
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Reset();
    private void setKey(Byte[] a);
    private void isaac();
    private void mix(UInt32[] a);
    private UInt32 byteToIntLittle(Byte[] a, int b);
    private Byte[] intToByteLittle(UInt32 a);
    private Byte[] intToByteLittle(UInt32[] a);
}
internal class tw : object {
    private bool a;
    private yq b;
    private IList[] c;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
    public Byte[] Encrypt(zy a);
    private static zy chineseRemainder(IList a, IList b);
}
internal class tx : object {
    private static UInt32[] a;
    private static UInt32[] b;
    private UInt32[] c;
    private UInt32[] d;
    private UInt32[] e;
    private bool f;
    private bool g;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tx();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void setKey(Byte[] a);
    private int encryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int decryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void gamma(UInt32[] a);
    private void theta(UInt32[] a, UInt32[] b);
    private void pi1(UInt32[] a);
    private void pi2(UInt32[] a);
    private UInt32 rotl(UInt32 a, int b);
}
internal class ty : object {
    private bool a;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal class tz : object {
    private static Byte[] a;
    private Int32[] b;
    private bool c;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static tz();
    private Int32[] GenerateWorkingKey(Byte[] a, int b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual void Reset();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    private int RotateWordLeft(int a, int b);
    private void EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void DecryptBlock(Byte[] a, int b, Byte[] c, int d);
}
[AttributeUsageAttribute("1052")]
internal class u : Attribute {
}
internal class ua : object {
    private static int a;
    private Byte[] b;
    private int c;
    private int d;
    private Byte[] e;
    public string AlgorithmName { get; }
    private static ua();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte a);
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual void Reset();
    private void SetKey(Byte[] a);
}
internal class ub : object {
    private int a;
    private Int32[] b;
    private static int c;
    private static int d;
    private bool e;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static ub();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void SetKey(Byte[] a);
    private int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int RotateLeft(int a, int b);
    private int RotateRight(int a, int b);
    private int BytesToWord(Byte[] a, int b);
    private void WordToBytes(int a, Byte[] b, int c);
}
internal class uc : object {
    private static int a;
    private static int b;
    private int c;
    private Int64[] d;
    private static long e;
    private static long f;
    private bool g;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static uc();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void SetKey(Byte[] a);
    private int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private long RotateLeft(long a, long b);
    private long RotateRight(long a, long b);
    private long BytesToWord(Byte[] a, int b);
    private void WordToBytes(long a, Byte[] b, int c);
}
internal class ud : object {
    private static int a;
    private static int b;
    private static int c;
    private Int32[] d;
    private static int e;
    private static int f;
    private static int g;
    private bool h;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static ud();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void SetKey(Byte[] a);
    private int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int RotateLeft(int a, int b);
    private int RotateRight(int a, int b);
    private int BytesToWord(Byte[] a, int b);
    private void WordToBytes(int a, Byte[] b, int c);
}
internal class ue : object {
    private static int a;
    private static int b;
    private static Byte[] c;
    private static Byte[] d;
    private static Byte[] e;
    private static Byte[] f;
    private static Byte[] g;
    private static Byte[][] h;
    private static Byte[][] i;
    private int j;
    private long k;
    private int l;
    private int m;
    private Int64[][] n;
    private long o;
    private long p;
    private long q;
    private long r;
    private bool s;
    private Byte[] t;
    private Byte[] u;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public ue(int a);
    private static ue();
    private byte Mul0x2(int a);
    private byte Mul0x3(int a);
    private byte Mul0x9(int a);
    private byte Mul0xb(int a);
    private byte Mul0xd(int a);
    private byte Mul0xe(int a);
    private void KeyAddition(Int64[] a);
    private long Shift(long a, int b);
    private void ShiftRow(Byte[] a);
    private long ApplyS(long a, Byte[] b);
    private void Substitution(Byte[] a);
    private void MixColumn();
    private void InvMixColumn();
    private Int64[][] GenerateWorkingKey(Byte[] a);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] a, int b);
    private void PackBlock(Byte[] a, int b);
    private void EncryptBlock(Int64[][] a);
    private void DecryptBlock(Int64[][] a);
}
internal class uf : object {
    private uh a;
    private za b;
    private abr c;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
}
internal class ug : object {
    private uh a;
    private za b;
    private zy c;
    private bool d;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
    private zy BlindMessage(zy a);
    private zy UnblindMessage(zy a);
}
internal class uh : object {
    private za a;
    private bool b;
    private int c;
    public void Init(bool a, qt b);
    public int GetInputBlockSize();
    public int GetOutputBlockSize();
    public zy ConvertInput(Byte[] a, int b, int c);
    public Byte[] ConvertOutput(zy a);
    public zy ProcessBlock(zy a);
}
internal class ui : object {
    private uh a;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] a, int b, int c);
}
internal class uj : object {
    private static Byte[] a;
    private static Byte[] b;
    private int c;
    private UInt32[] d;
    private UInt32[] e;
    private Byte[] f;
    private Byte[] g;
    private Byte[] h;
    private bool i;
    private UInt32 j;
    private UInt32 k;
    private UInt32 l;
    public string AlgorithmName { get; }
    private static uj();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte a);
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual void Reset();
    private void SetKey(Byte[] a, Byte[] b);
    private void GenerateKeyStream(Byte[] a);
    internal static void SalsaCore(int a, UInt32[] b, UInt32[] c);
    private static UInt32 R(UInt32 a, int b);
    private void ResetCounter();
    private bool LimitExceeded();
    private bool LimitExceeded(UInt32 a);
}
internal class uk : object {
    private static UInt32[] a;
    private static UInt32[] b;
    private static UInt32[] c;
    private static UInt32[] d;
    private static UInt32[] e;
    private Int32[] f;
    private bool g;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static uk();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private Int32[] createWorkingKey(Byte[] a);
    private int extractW1(long a);
    private int extractW0(long a);
    private long rotateLeft8(long a);
    private long rotateRight8(long a);
    private long bytesToLong(Byte[] a, int b);
    private void longToBytes(Byte[] a, int b, long c);
    private int G(int a);
    private long F(int a, int b, long c);
    private int phaseCalc1(int a, int b, int c, int d);
    private int phaseCalc2(int a, int b, int c, int d);
}
internal class ul : object {
    private static int a;
    private static int b;
    private bool c;
    private Int32[] d;
    private int e;
    private int f;
    private int g;
    private int h;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static ul();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private Int32[] MakeWorkingKey(Byte[] a);
    private int RotateLeft(int a, int b);
    private int RotateRight(int a, int b);
    private int BytesToWord(Byte[] a, int b);
    private void WordToBytes(int a, Byte[] b, int c);
    private void EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void Sb0(int a, int b, int c, int d);
    private void Ib0(int a, int b, int c, int d);
    private void Sb1(int a, int b, int c, int d);
    private void Ib1(int a, int b, int c, int d);
    private void Sb2(int a, int b, int c, int d);
    private void Ib2(int a, int b, int c, int d);
    private void Sb3(int a, int b, int c, int d);
    private void Ib3(int a, int b, int c, int d);
    private void Sb4(int a, int b, int c, int d);
    private void Ib4(int a, int b, int c, int d);
    private void Sb5(int a, int b, int c, int d);
    private void Ib5(int a, int b, int c, int d);
    private void Sb6(int a, int b, int c, int d);
    private void Ib6(int a, int b, int c, int d);
    private void Sb7(int a, int b, int c, int d);
    private void Ib7(int a, int b, int c, int d);
    private void LT();
    private void InverseLT();
}
internal class um : object {
    private static Int16[] a;
    private Int32[] b;
    private Int32[] c;
    private Int32[] d;
    private Int32[] e;
    private bool f;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static um();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private int G(int a, int b);
    public int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int H(int a, int b);
    public int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal class un : object {
    private UInt32 a;
    private UInt32 b;
    private UInt32 c;
    private UInt32 d;
    private bool e;
    private bool f;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void setKey(Byte[] a);
    private int encryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int decryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal class uo : object {
    private static Byte[0...,0...] a;
    private bool b;
    private Int32[] c;
    private Int32[] d;
    private Int32[] e;
    private Int32[] f;
    private Int32[] g;
    private Int32[] h;
    private int i;
    private Byte[] j;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static uo();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private void SetKey(Byte[] a);
    private void EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private void DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int F32(int a, Int32[] b);
    private int RS_MDS_Encode(int a, int b);
    private int RS_rem(int a);
    private int LFSR1(int a);
    private int LFSR2(int a);
    private int Mx_X(int a);
    private int Mx_Y(int a);
    private int M_b0(int a);
    private int M_b1(int a);
    private int M_b2(int a);
    private int M_b3(int a);
    private int Fe32_0(int a);
    private int Fe32_3(int a);
    private int BytesTo32Bits(Byte[] a, int b);
    private void Bits32ToBytes(int a, Byte[] b, int c);
}
internal class up : object {
    protected byte a;
    protected Byte[] b;
    protected byte c;
    protected Byte[] d;
    protected Byte[] e;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    protected virtual void InitKey(Byte[] a, Byte[] b);
    public virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual void Reset();
    public virtual byte ReturnByte(byte a);
}
internal class uq : up {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual void InitKey(Byte[] a, Byte[] b);
}
internal class ur : object {
    private UInt32[] a;
    private UInt32[] b;
    private UInt32[] c;
    private bool d;
    private bool e;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private void setKey(Byte[] a);
    private int encryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int decryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal class us : object {
    private int a;
    private sg b;
    private Byte[] c;
    private Byte[] d;
    public sg Digest { get; }
    protected us(int a, sg b);
    public sealed virtual void Init(rq a);
    public sealed virtual sg get_Digest();
    public sealed virtual int GenerateBytes(Byte[] a, int b, int c);
}
internal interface ut {
    public abstract virtual void Init(vr a);
    public abstract virtual rv GenerateKeyPair();
}
internal class uu : object {
    private xg a;
    public virtual void Init(vr a);
    public virtual rv GenerateKeyPair();
}
internal class uv : object {
    internal static uv a;
    private static uv();
    internal zy CalculatePrivate(xi a, abr b);
    internal zy CalculatePublic(xi a, zy b);
}
internal class uw : object {
    private xg a;
    public virtual void Init(vr a);
    public virtual rv GenerateKeyPair();
}
internal class ux : object {
    private xm a;
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
    private static zy GeneratePrivateKey(zy a, abr b);
    private static zy CalculatePublicKey(zy a, zy b, zy c);
}
internal class uy : object {
    private string a;
    private xs b;
    private hw c;
    private abr d;
    public uy(string a);
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
    private string VerifyAlgorithmName(string a);
    internal static qa FindECCurveByOid(hw a);
}
internal class uz : object {
    private xx a;
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
}
[AttributeUsageAttribute("64")]
internal class v : Attribute {
}
internal class va : object {
    private yc a;
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
}
internal class vb : us {
    public vb(sg a);
}
internal class vc : object {
    private sg a;
    private Byte[] b;
    private int c;
    public sg Digest { get; }
    public sealed virtual void Init(rq a);
    public sealed virtual sg get_Digest();
    private void ItoOSP(int a, Byte[] b);
    public sealed virtual int GenerateBytes(Byte[] a, int b, int c);
}
internal class vd : object {
    private static Int32[] a;
    private yp b;
    private static vd();
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
    private static zy generatePrime(int a, int b, abr c);
    private static IList permuteList(IList a, abr b);
    private static IList findFirstPrimes(int a);
}
internal abstract class ve : object {
    protected Byte[] a;
    protected Byte[] b;
    protected int c;
    public virtual void Init(Byte[] a, Byte[] b, int c);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual qt GenerateDerivedParameters(int a);
    public abstract virtual qt GenerateDerivedParameters(string a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual qt GenerateDerivedParameters(int a, int b);
    public abstract virtual qt GenerateDerivedParameters(string a, int b, int c);
    public abstract virtual qt GenerateDerivedMacParameters(int a);
    public static Byte[] Pkcs5PasswordToBytes(Char[] a);
    public static Byte[] Pkcs12PasswordToBytes(Char[] a, bool b);
}
internal class vf : ve {
    private sg d;
    public virtual void Init(Byte[] a, Byte[] b, int c);
    private Byte[] GenerateDerivedKey(int a);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a);
    public virtual qt GenerateDerivedParameters(string a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a, int b);
    public virtual qt GenerateDerivedParameters(string a, int b, int c);
    public virtual qt GenerateDerivedMacParameters(int a);
}
internal class vg : ve {
    private sg d;
    private int e;
    private int f;
    public vg(sg a);
    private void Adjust(Byte[] a, int b, Byte[] c);
    private Byte[] GenerateDerivedKey(int a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a);
    public virtual qt GenerateDerivedParameters(string a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a, int b);
    public virtual qt GenerateDerivedParameters(string a, int b, int c);
    public virtual qt GenerateDerivedMacParameters(int a);
}
internal class vh : ve {
    private sg d;
    public vh(sg a);
    private Byte[] GenerateDerivedKey();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a);
    public virtual qt GenerateDerivedParameters(string a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a, int b);
    public virtual qt GenerateDerivedParameters(string a, int b, int c);
    public virtual qt GenerateDerivedMacParameters(int a);
}
internal class vi : ve {
    private vl g;
    public vi(sg a);
    private void F(Byte[] a, Byte[] b, int c, Byte[] d, Byte[] e, int f);
    private Byte[] GenerateDerivedKey(int a);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a);
    public virtual qt GenerateDerivedParameters(string a, int b);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual qt GenerateDerivedParameters(int a, int b);
    public virtual qt GenerateDerivedParameters(string a, int b, int c);
    public virtual qt GenerateDerivedMacParameters(int a);
}
internal class vj : object {
    private static zy a;
    private yz b;
    private static vj();
    public sealed virtual void Init(vr a);
    public sealed virtual rv GenerateKeyPair();
}
internal interface vk {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual zy[] GenerateSignature(Byte[] a);
    public abstract virtual bool VerifySignature(Byte[] a, zy b, zy c);
}
internal interface vl {
    public string AlgorithmName { get; }
    public abstract virtual void Init(qt a);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte a);
    public abstract virtual void BlockUpdate(Byte[] a, int b, int c);
    public abstract virtual int DoFinal(Byte[] a, int b);
    public abstract virtual void Reset();
}
internal class vm : se {
    public vm(string a);
}
internal class vn : Stream {
    internal Stream a;
    internal rx b;
    internal rx c;
    private Byte[] d;
    private int e;
    private bool f;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual int ReadByte();
    public virtual int Read(Byte[] a, int b, int c);
    private bool FillInBuf();
    private Byte[] ReadAndProcessBlock();
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long Seek(long a, SeekOrigin b);
    public sealed virtual void SetLength(long a);
}
internal class vo : Stream {
    protected Stream a;
    protected sg b;
    protected sg c;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual sg WriteDigest();
    public virtual int Read(Byte[] a, int b, int c);
    public virtual int ReadByte();
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long a, SeekOrigin b);
    public virtual void SetLength(long a);
}
internal interface vp {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual void Update(byte a);
    public abstract virtual void BlockUpdate(Byte[] a, int b, int c);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] a);
    public abstract virtual void Reset();
}
internal interface vq {
    public abstract virtual bool HasFullMessage();
    public abstract virtual Byte[] GetRecoveredMessage();
    public abstract virtual void UpdateWithRecoveredMessage(Byte[] a);
}
internal class vr : object {
    private abr a;
    private int b;
    public abr Random { get; }
    public int Strength { get; }
    public vr(abr a, int b);
    public abr get_Random();
    public int get_Strength();
}
internal class vs : object {
    private Byte[] a;
    private int b;
    private te c;
    private wu d;
    private int e;
    public string AlgorithmName { get; }
    public vs(te a);
    public vs(te a, int b);
    public vs(te a, int b, wu c);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(qt a);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class vt : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private int d;
    private te e;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public vt(te a, int b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    public void GetMacBlock(Byte[] a);
}
internal class vu : object {
    private Byte[] a;
    private Byte[] b;
    private int c;
    private vt d;
    private wu e;
    private int f;
    public string AlgorithmName { get; }
    public vu(te a);
    public vu(te a, int b, int c, wu d);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(qt a);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class vv : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private int d;
    private te e;
    private int f;
    private Byte[] g;
    private Byte[] h;
    private Byte[] i;
    public string AlgorithmName { get; }
    public vv(te a);
    public vv(te a, int b);
    public sealed virtual string get_AlgorithmName();
    private static Byte[] doubleLu(Byte[] a);
    public sealed virtual void Init(qt a);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class vw : object {
    private int a;
    private Byte[] b;
    private Byte[] c;
    private bool d;
    private Int32[] e;
    private Byte[] f;
    public string AlgorithmName { get; }
    private static Int32[] generateWorkingKey(Byte[] a);
    public sealed virtual void Init(qt a);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    private int gost28147_mainStep(int a, int b);
    private void gost28147MacFunc(Int32[] a, Byte[] b, int c, Byte[] d, int e);
    private static int bytesToint(Byte[] a, int b);
    private static void intTobytes(int a, Byte[] b, int c);
    private static Byte[] CM5func(Byte[] a, int b, Byte[] c);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class vx : object {
    private sg a;
    private int b;
    private int c;
    private Byte[] d;
    private Byte[] e;
    public string AlgorithmName { get; }
    public vx(sg a);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(qt a);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
    private static void xor(Byte[] a, byte b);
}
internal class vy : object {
    private Byte[] a;
    private Byte[] b;
    private int c;
    private te d;
    private wu e;
    private int f;
    private xd g;
    private xd h;
    public string AlgorithmName { get; }
    public vy(te a);
    public vy(te a, wu b);
    public vy(te a, int b, wu c);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(qt a);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class vz : object {
    private byte a;
    private byte b;
    private Byte[] c;
    private byte d;
    private Byte[] e;
    private Byte[] f;
    private Byte[] g;
    private byte h;
    private byte i;
    private byte j;
    private byte k;
    public string AlgorithmName { get; }
    public virtual int DoFinal(Byte[] a, int b);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(qt a);
    private void initKey(Byte[] a, Byte[] b);
    public virtual void Reset();
    public virtual void Update(byte a);
    public virtual void BlockUpdate(Byte[] a, int b, int c);
}
[AttributeUsageAttribute("108")]
internal class w : Attribute {
}
internal class wa : se {
    public wa(string a);
}
internal class wb : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private int d;
    private te e;
    private bool f;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public wb(te a);
    public te GetUnderlyingCipher();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal interface wc {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool a, qt b);
    public abstract virtual int GetBlockSize();
    public abstract virtual void ProcessAadByte(byte a);
    public abstract virtual void ProcessAadBytes(Byte[] a, int b, int c);
    public abstract virtual int ProcessByte(byte a, Byte[] b, int c);
    public abstract virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public abstract virtual int DoFinal(Byte[] a, int b);
    public abstract virtual Byte[] GetMac();
    public abstract virtual int GetUpdateOutputSize(int a);
    public abstract virtual int GetOutputSize(int a);
    public abstract virtual void Reset();
}
internal class wd : object {
    private static int a;
    private te b;
    private Byte[] c;
    private bool d;
    private Byte[] e;
    private Byte[] f;
    private int g;
    private qt h;
    private MemoryStream i;
    private MemoryStream j;
    public string AlgorithmName { get; }
    public wd(te a);
    private static wd();
    public virtual void Init(bool a, qt b);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void ProcessAadByte(byte a);
    public virtual void ProcessAadBytes(Byte[] a, int b, int c);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int a);
    public sealed virtual int GetOutputSize(int a);
    public Byte[] ProcessPacket(Byte[] a, int b, int c);
    private int calculateMac(Byte[] a, int b, int c, Byte[] d);
    private int GetAssociatedTextLength();
    private bool HasAssociatedText();
}
internal class we : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private bool d;
    private int e;
    private te f;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public we(te a, int b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    public int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal class wf : sb {
    private int h;
    public wf(te a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual int GetOutputSize(int a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual int DoFinal(Byte[] a, int b);
}
internal class wg : object {
    private wt a;
    private bool b;
    private int c;
    private vl d;
    private Byte[] e;
    private Byte[] f;
    private Byte[] g;
    private int h;
    private Byte[] i;
    private int j;
    private bool k;
    private Byte[] l;
    public string AlgorithmName { get; }
    public wg(te a);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool a, qt b);
    private void InitCipher();
    private void CalculateMac();
    public virtual void Reset();
    private void Reset(bool a);
    public virtual void ProcessAadByte(byte a);
    public sealed virtual void ProcessAadBytes(Byte[] a, int b, int c);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int a);
    public virtual int GetOutputSize(int a);
    private int Process(byte a, Byte[] b, int c);
    private bool VerifyMac(Byte[] a, int b);
}
internal class wh : object {
    private te a;
    private wk b;
    private wi c;
    private bool d;
    private int e;
    private Byte[] f;
    private Byte[] g;
    private Byte[] h;
    private Byte[] i;
    private Byte[] j;
    private Byte[] k;
    private Byte[] l;
    private Byte[] m;
    private Byte[] n;
    private Byte[] o;
    private int p;
    private ulong q;
    private Byte[] r;
    private int s;
    private ulong t;
    private ulong u;
    public string AlgorithmName { get; }
    public wh(te a);
    public wh(te a, wk b);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool a, qt b);
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual void ProcessAadByte(byte a);
    public virtual void ProcessAadBytes(Byte[] a, int b, int c);
    private void InitCipher();
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    private void OutputBlock(Byte[] a, int b);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private void Reset(bool a);
    private void gCTRBlock(Byte[] a, Byte[] b, int c);
    private void gCTRPartial(Byte[] a, int b, int c, Byte[] d, int e);
    private void gHASH(Byte[] a, Byte[] b, int c);
    private void gHASHBlock(Byte[] a, Byte[] b);
    private void gHASHPartial(Byte[] a, Byte[] b, int c, int d);
    private Byte[] GetNextCounterBlock();
}
internal interface wi {
    public abstract virtual void Init(Byte[] a);
    public abstract virtual void ExponentiateX(long a, Byte[] b);
}
internal class wj : object {
    private Byte[] a;
    public sealed virtual void Init(Byte[] a);
    public sealed virtual void ExponentiateX(long a, Byte[] b);
}
internal interface wk {
    public abstract virtual void Init(Byte[] a);
    public abstract virtual void MultiplyH(Byte[] a);
}
internal class wl : object {
    private Byte[] a;
    public sealed virtual void Init(Byte[] a);
    public sealed virtual void MultiplyH(Byte[] a);
}
internal abstract class wm : object {
    internal static Byte[] OneAsBytes();
    internal static UInt32[] AsUints(Byte[] a);
    internal static void Multiply(Byte[] a, Byte[] b);
    internal static void MultiplyP(UInt32[] a);
    internal static void MultiplyP8(UInt32[] a);
    internal static void ShiftRight(Byte[] a);
    internal static void ShiftRight(UInt32[] a);
    internal static void ShiftRightN(UInt32[] a, int b);
    internal static void Xor(Byte[] a, Byte[] b);
    internal static void Xor(Byte[] a, Byte[] b, int c, int d);
    internal static void Xor(UInt32[] a, UInt32[] b);
}
internal class wn : object {
    private IList`1<Byte[]> a;
    public sealed virtual void Init(Byte[] a);
    public sealed virtual void ExponentiateX(long a, Byte[] b);
    private void EnsureAvailable(int a);
}
internal class wo : object {
    private Byte[] a;
    private UInt32[][][] b;
    public sealed virtual void Init(Byte[] a);
    public sealed virtual void MultiplyH(Byte[] a);
}
internal class wp : object {
    private Byte[] a;
    private UInt32[][][] b;
    public sealed virtual void Init(Byte[] a);
    public sealed virtual void MultiplyH(Byte[] a);
}
internal class wq : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private int d;
    private te e;
    private bool f;
    private int g;
    private int h;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public wq(te a);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    private int bytesToint(Byte[] a, int b);
    private void intTobytes(int a, Byte[] b, int c);
}
internal class wr : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private int d;
    private te e;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public wr(te a, int b);
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal class ws : object {
    private Byte[] a;
    private Byte[] b;
    private Byte[] c;
    private te d;
    private int e;
    private int f;
    private bool g;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public ws(te a);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
    public sealed virtual void Init(bool a, qt b);
    private byte EncryptByte(byte a, int b);
    private int EncryptBlock(Byte[] a, int b, Byte[] c, int d);
    private int DecryptBlock(Byte[] a, int b, Byte[] c, int d);
}
internal class wt : object {
    private te a;
    private int b;
    private Byte[] c;
    private Byte[] d;
    private Byte[] e;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public wt(te a);
    public te GetUnderlyingCipher();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] a, int b, Byte[] c, int d);
    public sealed virtual void Reset();
}
internal interface wu {
    public string PaddingName { get; }
    public abstract virtual void Init(abr a);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] a, int b);
    public abstract virtual int PadCount(Byte[] a);
}
internal class wv : object {
    private abr a;
    public string PaddingName { get; }
    public sealed virtual void Init(abr a);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] a, int b);
    public sealed virtual int PadCount(Byte[] a);
}
internal class ww : object {
    public string PaddingName { get; }
    public sealed virtual void Init(abr a);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] a, int b);
    public sealed virtual int PadCount(Byte[] a);
}
internal class wx : sb {
    private wu i;
    public wx(te a, wu b);
    public wx(te a);
    public virtual void Init(bool a, qt b);
    public virtual int GetOutputSize(int a);
    public virtual int GetUpdateOutputSize(int a);
    public virtual int ProcessByte(byte a, Byte[] b, int c);
    public virtual int ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public virtual int DoFinal(Byte[] a, int b);
}
internal class wy : object {
    public string PaddingName { get; }
    public sealed virtual void Init(abr a);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] a, int b);
    public sealed virtual int PadCount(Byte[] a);
}
internal class wz : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public virtual void Init(abr a);
    public virtual int AddPadding(Byte[] a, int b);
    public virtual int PadCount(Byte[] a);
}
[AttributeUsageAttribute("108")]
internal class x : Attribute {
}
internal class xa : object {
    private abr a;
    public string PaddingName { get; }
    public sealed virtual void Init(abr a);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] a, int b);
    public sealed virtual int PadCount(Byte[] a);
}
internal class xb : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public sealed virtual void Init(abr a);
    public sealed virtual int AddPadding(Byte[] a, int b);
    public sealed virtual int PadCount(Byte[] a);
}
internal class xc : object {
    private Byte[] a;
    private Byte[] b;
    private xd c;
    private int d;
    public xd Key { get; }
    public int MacSize { get; }
    public virtual xd get_Key();
    public virtual int get_MacSize();
    public virtual Byte[] GetAssociatedText();
    public virtual Byte[] GetNonce();
}
internal class xd : object {
    private Byte[] a;
    public xd(Byte[] a);
    public xd(Byte[] a, int b, int c);
    public Byte[] GetKey();
}
internal class xe : xd {
    private static Byte[] b;
    public xe(Byte[] a);
    public xe(Byte[] a, int b, int c);
    private static xe();
    public static bool IsWeakKey(Byte[] a, int b);
    public static bool IsWeakKey(Byte[] a);
    public static void SetOddParity(Byte[] a);
}
internal class xf : xe {
    public xf(Byte[] a, int b, int c);
    private static Byte[] FixKey(Byte[] a, int b, int c);
    public static bool IsWeakKey(Byte[] a, int b, int c);
    public static bool IsWeakKey(Byte[] a);
}
internal class xg : vr {
    private xi c;
    public xi Parameters { get; }
    public xi get_Parameters();
}
internal class xh : rw {
    private xi b;
    private hw c;
    public xi Parameters { get; }
    public hw AlgorithmOid { get; }
    protected xh(bool a, xi b);
    protected xh(bool a, xi b, hw c);
    public xi get_Parameters();
    public hw get_AlgorithmOid();
    public virtual bool Equals(object a);
    protected bool Equals(xh a);
    public virtual int GetHashCode();
}
internal class xi : object {
    private zy a;
    private zy b;
    private zy c;
    private zy d;
    private int e;
    private int f;
    private xl g;
    public zy P { get; }
    public zy G { get; }
    public zy Q { get; }
    public int M { get; }
    public int L { get; }
    public xi(zy a, zy b, zy c, int d);
    public xi(zy a, zy b, zy c, int d, int e);
    public xi(zy a, zy b, zy c, zy d, xl e);
    public xi(zy a, zy b, zy c, int d, int e, zy f, xl g);
    private static int GetDefaultMParam(int a);
    public zy get_P();
    public zy get_G();
    public zy get_Q();
    public int get_M();
    public int get_L();
    public virtual bool Equals(object a);
    protected bool Equals(xi a);
    public virtual int GetHashCode();
}
internal class xj : xh {
    private zy d;
    public zy X { get; }
    public xj(zy a, xi b);
    public xj(zy a, xi b, hw c);
    public zy get_X();
    public virtual bool Equals(object a);
    protected bool Equals(xj a);
    public virtual int GetHashCode();
}
internal class xk : xh {
    private zy e;
    public zy Y { get; }
    public xk(zy a, xi b);
    public xk(zy a, xi b, hw c);
    public zy get_Y();
    public virtual bool Equals(object a);
    protected bool Equals(xk a);
    public virtual int GetHashCode();
}
internal class xl : object {
    private Byte[] a;
    private int b;
    public xl(Byte[] a, int b);
    public virtual bool Equals(object a);
    protected bool Equals(xl a);
    public virtual int GetHashCode();
}
internal class xm : vr {
    private xo c;
    public xo Parameters { get; }
    public xo get_Parameters();
}
internal abstract class xn : rw {
    private xo b;
    public xo Parameters { get; }
    protected xn(bool a, xo b);
    public xo get_Parameters();
    public virtual bool Equals(object a);
    protected bool Equals(xn a);
    public virtual int GetHashCode();
}
internal class xo : object {
    private zy a;
    private zy b;
    private zy c;
    private xr d;
    public zy P { get; }
    public zy Q { get; }
    public zy G { get; }
    public xo(zy a, zy b, zy c);
    public xo(zy a, zy b, zy c, xr d);
    public zy get_P();
    public zy get_Q();
    public zy get_G();
    public virtual bool Equals(object a);
    protected bool Equals(xo a);
    public virtual int GetHashCode();
}
internal class xp : xn {
    private zy d;
    public zy X { get; }
    public xp(zy a, xo b);
    public zy get_X();
    public virtual bool Equals(object a);
    protected bool Equals(xp a);
    public virtual int GetHashCode();
}
internal class xq : xn {
    private zy e;
    public zy Y { get; }
    public xq(zy a, xo b);
    public zy get_Y();
    public virtual bool Equals(object a);
    protected bool Equals(xq a);
    public virtual int GetHashCode();
}
internal class xr : object {
    private Byte[] a;
    private int b;
    public virtual bool Equals(object a);
    protected bool Equals(xr a);
    public virtual int GetHashCode();
}
internal class xs : object {
    internal aad a;
    internal Byte[] b;
    internal aak c;
    internal zy d;
    internal zy e;
    public aad Curve { get; }
    public aak G { get; }
    public zy N { get; }
    public zy H { get; }
    public xs(aad a, aak b, zy c);
    public xs(aad a, aak b, zy c, zy d);
    public xs(aad a, aak b, zy c, zy d, Byte[] e);
    public aad get_Curve();
    public aak get_G();
    public zy get_N();
    public zy get_H();
    public Byte[] GetSeed();
    public virtual bool Equals(object a);
    protected bool Equals(xs a);
    public virtual int GetHashCode();
}
internal class xt : vr {
    private xs d;
    private hw e;
    public xs DomainParameters { get; }
    public hw PublicKeyParamSet { get; }
    public xt(xs a, abr b);
    public xs get_DomainParameters();
    public hw get_PublicKeyParamSet();
}
internal abstract class xu : rw {
    private string f;
    private xs b;
    private hw g;
    public string AlgorithmName { get; }
    public xs Parameters { get; }
    public hw PublicKeyParamSet { get; }
    protected xu(string a, bool b, xs c);
    protected xu(string a, bool b, hw c);
    public string get_AlgorithmName();
    public xs get_Parameters();
    public hw get_PublicKeyParamSet();
    public virtual bool Equals(object a);
    protected bool Equals(xu a);
    public virtual int GetHashCode();
    private string VerifyAlgorithmName(string a);
    internal static xs LookupParameters(hw a);
}
internal class xv : xu {
    private zy h;
    public zy D { get; }
    public xv(zy a, xs b);
    public xv(string a, zy b, xs c);
    public xv(string a, zy b, hw c);
    public zy get_D();
    public virtual bool Equals(object a);
    protected bool Equals(xv a);
    public virtual int GetHashCode();
}
internal class xw : xu {
    private aak i;
    public aak Q { get; }
    public xw(aak a, xs b);
    public xw(string a, aak b, xs c);
    public xw(string a, aak b, hw c);
    public aak get_Q();
    public virtual bool Equals(object a);
    protected bool Equals(xw a);
    public virtual int GetHashCode();
}
internal class xx : vr {
    private xz c;
    public xz Parameters { get; }
    public xz get_Parameters();
}
internal class xy : rw {
    private xz b;
    public xz Parameters { get; }
    protected xy(bool a, xz b);
    public xz get_Parameters();
    public virtual bool Equals(object a);
    protected bool Equals(xy a);
    public virtual int GetHashCode();
}
internal class xz : object {
    private zy a;
    private zy b;
    private int c;
    public zy P { get; }
    public zy G { get; }
    public int L { get; }
    public xz(zy a, zy b);
    public xz(zy a, zy b, int c);
    public zy get_P();
    public zy get_G();
    public int get_L();
    public virtual bool Equals(object a);
    protected bool Equals(xz a);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1372")]
internal class y : Attribute {
    internal y(string a);
}
internal class ya : xy {
    private zy d;
    public zy X { get; }
    public ya(zy a, xz b);
    public zy get_X();
    public virtual bool Equals(object a);
    protected bool Equals(ya a);
    public virtual int GetHashCode();
}
internal class yb : xy {
    private zy e;
    public zy Y { get; }
    public yb(zy a, xz b);
    public zy get_Y();
    public virtual bool Equals(object a);
    protected bool Equals(yb a);
    public virtual int GetHashCode();
}
internal class yc : vr {
    private ye c;
    private hw e;
    public ye Parameters { get; }
    public hw PublicKeyParamSet { get; }
    public yc(abr a, ye b);
    public yc(abr a, hw b);
    public ye get_Parameters();
    public hw get_PublicKeyParamSet();
    private static ye LookupParameters(hw a);
}
internal abstract class yd : rw {
    private ye b;
    private hw g;
    public ye Parameters { get; }
    public hw PublicKeyParamSet { get; }
    protected yd(bool a, ye b);
    protected yd(bool a, hw b);
    public ye get_Parameters();
    public hw get_PublicKeyParamSet();
    private static ye LookupParameters(hw a);
}
internal class ye : object {
    private zy b;
    private zy c;
    private zy d;
    private yh e;
    public zy P { get; }
    public zy Q { get; }
    public zy A { get; }
    public ye(zy a, zy b, zy c);
    public ye(zy a, zy b, zy c, yh d);
    public zy get_P();
    public zy get_Q();
    public zy get_A();
    public virtual bool Equals(object a);
    protected bool Equals(ye a);
    public virtual int GetHashCode();
}
internal class yf : yd {
    private zy d;
    public zy X { get; }
    public yf(zy a, ye b);
    public yf(zy a, hw b);
    public zy get_X();
}
internal class yg : yd {
    private zy e;
    public zy Y { get; }
    public yg(zy a, ye b);
    public yg(zy a, hw b);
    public zy get_Y();
}
internal class yh : object {
    private int a;
    private int b;
    private long c;
    private long d;
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
internal class yi : object {
    private Byte[] a;
    private Byte[] b;
    private int c;
    public int MacKeySize { get; }
    public Byte[] GetDerivationV();
    public Byte[] GetEncodingV();
    public int get_MacKeySize();
}
internal class yj : yi {
    private int d;
    public int CipherKeySize { get; }
    public int get_CipherKeySize();
}
internal class yk : object {
    private Byte[] a;
    public Byte[] GetSeed();
}
internal class yl : object {
    private Byte[] a;
    private Byte[] b;
    public yl(Byte[] a, Byte[] b);
    public Byte[] GetSharedSecret();
    public Byte[] GetIV();
}
internal class ym : object {
    private Byte[] a;
    public Byte[] GetSeed();
}
internal class yn : object {
    private xv a;
    private xv b;
    private xw c;
    public xv StaticPrivateKey { get; }
    public xv EphemeralPrivateKey { get; }
    public xw EphemeralPublicKey { get; }
    public xv get_StaticPrivateKey();
    public xv get_EphemeralPrivateKey();
    public xw get_EphemeralPublicKey();
}
internal class yo : object {
    private xw a;
    private xw b;
    public xw StaticPublicKey { get; }
    public xw EphemeralPublicKey { get; }
    public xw get_StaticPublicKey();
    public xw get_EphemeralPublicKey();
}
internal class yp : vr {
    private int f;
    private int g;
    private bool h;
    public int Certainty { get; }
    public int CountSmallPrimes { get; }
    public bool IsDebug { get; }
    public int get_Certainty();
    public int get_CountSmallPrimes();
    public bool get_IsDebug();
}
internal class yq : rw {
    private zy j;
    private zy k;
    private int l;
    public zy G { get; }
    public int LowerSigmaBound { get; }
    public zy Modulus { get; }
    public yq(bool a, zy b, zy c, int d);
    public zy get_G();
    public int get_LowerSigmaBound();
    public zy get_Modulus();
}
internal class yr : yq {
    private zy m;
    private IList n;
    public zy PhiN { get; }
    public IList SmallPrimesList { get; }
    public yr(zy a, zy b, int c, IList d, zy e);
    public zy get_PhiN();
    public IList get_SmallPrimesList();
}
internal class ys : object {
    private qt a;
    private Byte[] b;
    public qt Parameters { get; }
    public ys(qt a, Byte[] b);
    public ys(qt a, Byte[] b, int c, int d);
    public Byte[] GetIV();
    public qt get_Parameters();
}
internal class yt : object {
    private qt a;
    private abr b;
    public abr Random { get; }
    public qt Parameters { get; }
    public abr get_Random();
    public qt get_Parameters();
}
internal class yu : object {
    private Byte[] a;
    private qt b;
    public qt Parameters { get; }
    public Byte[] GetSalt();
    public qt get_Parameters();
}
internal class yv : object {
    private qt a;
    private Byte[] b;
    public qt Parameters { get; }
    public yv(qt a, Byte[] b);
    public Byte[] GetSBox();
    public qt get_Parameters();
}
internal class yw : xd {
    private int c;
    public int EffectiveKeyBits { get; }
    public yw(Byte[] a, int b, int c);
    public yw(Byte[] a, int b, int c, int d);
    public int get_EffectiveKeyBits();
}
internal class yx : xd {
    private int d;
    public int Rounds { get; }
    public int get_Rounds();
}
internal class yy : object {
    private za a;
    private zy b;
    public za PublicKey { get; }
    public zy BlindingFactor { get; }
    public za get_PublicKey();
    public zy get_BlindingFactor();
}
internal class yz : vr {
    private zy i;
    private int f;
    public zy PublicExponent { get; }
    public int Certainty { get; }
    public yz(zy a, abr b, int c, int d);
    public zy get_PublicExponent();
    public int get_Certainty();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1052")]
internal class z : Attribute {
    internal z(string a);
}
internal class za : rw {
    private zy o;
    private zy p;
    public zy Modulus { get; }
    public zy Exponent { get; }
    public za(bool a, zy b, zy c);
    public zy get_Modulus();
    public zy get_Exponent();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
internal class zb : za {
    private zy r;
    private zy s;
    private zy i;
    private zy t;
    private zy u;
    private zy v;
    public zy PublicExponent { get; }
    public zy P { get; }
    public zy Q { get; }
    public zy DP { get; }
    public zy DQ { get; }
    public zy QInv { get; }
    public zb(zy a, zy b, zy c, zy d, zy e, zy f, zy g, zy h);
    public zy get_PublicExponent();
    public zy get_P();
    public zy get_Q();
    public zy get_DP();
    public zy get_DQ();
    public zy get_QInv();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
    private static void ValidateValue(zy a, string b, string c);
}
internal interface zc {
    public abstract virtual void AddSeedMaterial(Byte[] a);
    public abstract virtual void AddSeedMaterial(long a);
    public abstract virtual void NextBytes(Byte[] a);
    public abstract virtual void NextBytes(Byte[] a, int b, int c);
}
internal class zd : object {
    private long a;
    private long b;
    private sg c;
    private Byte[] d;
    private Byte[] e;
    public zd(sg a);
    public sealed virtual void AddSeedMaterial(Byte[] a);
    public sealed virtual void AddSeedMaterial(long a);
    public sealed virtual void NextBytes(Byte[] a);
    public sealed virtual void NextBytes(Byte[] a, int b, int c);
    private void CycleSeed();
    private void GenerateState();
    private void DigestAddCounter(long a);
    private void DigestUpdate(Byte[] a);
    private void DigestDoFinal(Byte[] a);
}
internal class ze : object {
    private zc a;
    private Byte[] b;
    private int c;
    public ze(zc a, int b);
    public virtual void AddSeedMaterial(Byte[] a);
    public virtual void AddSeedMaterial(long a);
    public virtual void NextBytes(Byte[] a);
    public virtual void NextBytes(Byte[] a, int b, int c);
    private void doNextBytes(Byte[] a, int b, int c);
}
internal class zf : object {
    public Byte[] GenerateSeed(int a, bool b);
}
internal class zg : object {
    private byte a;
    private Byte[] b;
    private byte c;
    public virtual void AddSeedMaterial(Byte[] a);
    public virtual void AddSeedMaterial(long a);
    public virtual void NextBytes(Byte[] a);
    public virtual void NextBytes(Byte[] a, int b, int c);
}
internal class zh : object {
    private sg a;
    private vk b;
    private bool c;
    public string AlgorithmName { get; }
    public zh(vk a, sg b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] a);
    public sealed virtual void Reset();
    private Byte[] DerEncode(zy a, zy b);
    private zy[] DerDecode(Byte[] a);
}
internal class zi : object {
    private xn a;
    private abr b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual zy[] GenerateSignature(Byte[] a);
    public sealed virtual bool VerifySignature(Byte[] a, zy b, zy c);
    private zy calculateE(zy a, Byte[] b);
}
internal class zj : object {
    private xu a;
    private abr b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual zy[] GenerateSignature(Byte[] a);
    public sealed virtual bool VerifySignature(Byte[] a, zy b, zy c);
    private zy calculateE(zy a, Byte[] b);
}
internal class zk : object {
    private xu a;
    private abr b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual zy[] GenerateSignature(Byte[] a);
    public sealed virtual bool VerifySignature(Byte[] a, zy b, zy c);
}
internal class zl : object {
    private bool a;
    private xu b;
    private abr c;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual zy[] GenerateSignature(Byte[] a);
    public sealed virtual bool VerifySignature(Byte[] a, zy b, zy c);
}
internal class zm : object {
    private ta a;
    private sg b;
    private bool c;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] a);
    public sealed virtual void Reset();
}
internal class zn : object {
    private sg a;
    private vk b;
    private bool c;
    public string AlgorithmName { get; }
    public zn(vk a, sg b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] a);
    public sealed virtual void Reset();
}
internal class zo : object {
    private yd a;
    private abr b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual zy[] GenerateSignature(Byte[] a);
    public sealed virtual bool VerifySignature(Byte[] a, zy b, zy c);
}
internal class zp : object {
    private sg a;
    private ta b;
    private abr c;
    private Byte[] d;
    private int e;
    private int f;
    private int g;
    private Byte[] h;
    private Byte[] i;
    private int j;
    private int k;
    private bool l;
    private Byte[] m;
    public string AlgorithmName { get; }
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] a);
    public virtual void UpdateWithRecoveredMessage(Byte[] a);
    public virtual void Update(byte a);
    public virtual void BlockUpdate(Byte[] a, int b, int c);
    public virtual void Reset();
    public sealed virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] a);
    public virtual bool HasFullMessage();
    private void ItoOSP(int a, Byte[] b);
    private void LtoOSP(long a, Byte[] b);
    private Byte[] MaskGeneratorFunction1(Byte[] a, int b, int c, int d);
}
internal class zq : object {
    private static IDictionary a;
    private sg b;
    private ta c;
    private int d;
    private int e;
    private Byte[] f;
    private Byte[] g;
    private int h;
    private bool i;
    private Byte[] j;
    private Byte[] k;
    private Byte[] l;
    public string AlgorithmName { get; }
    private static zq();
    public zq(ta a, sg b, bool c);
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] a);
    public virtual void UpdateWithRecoveredMessage(Byte[] a);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] a);
    private bool ReturnFalse(Byte[] a);
    public virtual bool HasFullMessage();
}
internal class zr : object {
    private sg a;
    private sg b;
    private sg c;
    private ta d;
    private abr e;
    private int f;
    private int g;
    private int h;
    private int i;
    private Byte[] j;
    private Byte[] k;
    private Byte[] l;
    private byte m;
    public string AlgorithmName { get; }
    public zr(ta a, sg b);
    public zr(ta a, sg b, int c);
    public zr(ta a, sg b, int c, byte d);
    public zr(ta a, sg b, sg c, int d, byte e);
    private zr(ta a, sg b, sg c, sg d, int e, byte f);
    public static zr CreateRawSigner(ta a, sg b);
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool a, qt b);
    private void ClearBlock(Byte[] a);
    public virtual void Update(byte a);
    public virtual void BlockUpdate(Byte[] a, int b, int c);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] a);
    private void ItoOSP(int a, Byte[] b);
    private Byte[] MaskGeneratorFunction1(Byte[] a, int b, int c, int d);
}
internal class zs : object {
    private ta a;
    private ly b;
    private sg c;
    private bool d;
    private static IDictionary e;
    public string AlgorithmName { get; }
    private static zs();
    public zs(sg a);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] a);
    public sealed virtual void Reset();
    private Byte[] DerEncode(Byte[] a);
}
internal class zt : object {
    private te a;
    private Byte[] b;
    public string AlgorithmName { get; }
    public sealed virtual void Init(bool a, qt b);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte a);
    public sealed virtual void ProcessBytes(Byte[] a, int b, int c, Byte[] d, int e);
    public sealed virtual void Reset();
}
internal class zu : object {
    private sm a;
    private ss b;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte a);
    public sealed virtual void BlockUpdate(Byte[] a, int b, int c);
    public sealed virtual int DoFinal(Byte[] a, int b);
    public sealed virtual void Reset();
}
internal class zv : object {
    internal static Byte[] a;
    internal static Byte[] b;
    internal static Byte[] c;
    internal static Byte[] d;
    private sg e;
    private Byte[] f;
    private Byte[] g;
    private Byte[] h;
    public string AlgorithmName { get; }
    private static zv();
    public virtual string get_AlgorithmName();
    public virtual void Init(qt a);
    public virtual int GetMacSize();
    public virtual void Update(byte a);
    public virtual void BlockUpdate(Byte[] a, int b, int c);
    public virtual int DoFinal(Byte[] a, int b);
    public virtual void Reset();
    private static Byte[] GenPad(byte a, int b);
}
internal class zw : Stream {
    protected acw a;
    protected int b;
    protected Byte[] c;
    protected Byte[] d;
    protected bool e;
    protected Stream f;
    protected bool g;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] a, int b, int c);
    public sealed virtual long Seek(long a, SeekOrigin b);
    public sealed virtual void SetLength(long a);
    public virtual void Write(Byte[] a, int b, int c);
    public virtual void WriteByte(byte a);
}
internal class zx : object {
    internal static void UInt32_To_BE(UInt32 a, Byte[] b);
    internal static void UInt32_To_BE(UInt32 a, Byte[] b, int c);
    internal static void UInt32_To_BE(UInt32[] a, Byte[] b, int c);
    internal static UInt32 BE_To_UInt32(Byte[] a, int b);
    internal static void BE_To_UInt32(Byte[] a, int b, UInt32[] c);
    internal static ulong BE_To_UInt64(Byte[] a, int b);
    internal static void UInt64_To_BE(ulong a, Byte[] b, int c);
    internal static void UInt32_To_LE(UInt32 a, Byte[] b);
    internal static void UInt32_To_LE(UInt32 a, Byte[] b, int c);
    internal static void UInt32_To_LE(UInt32[] a, Byte[] b, int c);
    internal static UInt32 LE_To_UInt32(Byte[] a, int b);
    internal static void UInt64_To_LE(ulong a, Byte[] b);
}
internal class zy : object {
    internal static Int32[][] a;
    internal static Int32[] b;
    private static Int32[] c;
    private static Byte[] d;
    private static zy[] e;
    public static zy f;
    public static zy g;
    public static zy h;
    public static zy i;
    public static zy j;
    private static Byte[] k;
    private static zy l;
    private static zy m;
    private static zy n;
    private static zy o;
    private static zy p;
    private static zy q;
    private static zy r;
    private static zy s;
    private static Random t;
    private static Int32[] u;
    private Int32[] v;
    private int w;
    private int x;
    private int y;
    private int z;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public long LongValue { get; }
    public int SignValue { get; }
    private static zy();
    private zy(int a, Int32[] b, bool c);
    public zy(string a);
    public zy(string a, int b);
    public zy(Byte[] a);
    public zy(Byte[] a, int b, int c);
    public zy(int a, Byte[] b);
    public zy(int a, Byte[] b, int c, int d);
    public zy(int a, Random b);
    public zy(int a, int b, Random c);
    private static int GetByteLength(int a);
    private static Int32[] MakeMagnitude(Byte[] a, int b, int c);
    public zy Abs();
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    public zy Add(zy a);
    private zy AddToMagnitude(Int32[] a);
    public int get_BitCount();
    public static int BitCnt(int a);
    private static int CalcBitLength(int a, int b, Int32[] c);
    public int get_BitLength();
    private static int BitLen(int a);
    private bool QuickPow2Check();
    private static int CompareTo(int a, Int32[] b, int c, Int32[] d);
    private static int CompareNoLeadingZeroes(int a, Int32[] b, int c, Int32[] d);
    public int CompareTo(zy a);
    private Int32[] Divide(Int32[] a, Int32[] b);
    public zy Divide(zy a);
    public zy[] DivideAndRemainder(zy a);
    public virtual bool Equals(object a);
    private bool IsEqualMagnitude(zy a);
    public zy Gcd(zy a);
    public virtual int GetHashCode();
    private zy Inc();
    public int get_IntValue();
    public bool IsProbablePrime(int a);
    private bool CheckProbablePrime(int a, Random b);
    public bool RabinMillerTest(int a, Random b);
    public long get_LongValue();
    public zy Max(zy a);
    public zy Mod(zy a);
    public zy ModInverse(zy a);
    private zy ModInversePow2(zy a);
    private static int ModInverse32(int a);
    private static long ModInverse64(long a);
    private static zy ExtEuclid(zy a, zy b, zy& c);
    public zy ModPow(zy a, zy b);
    private static zy ModPowBarrett(zy a, zy b, zy c);
    private static zy ReduceBarrett(zy a, zy b, zy c, zy d);
    private static zy ModPowMonty(zy a, zy b, zy c, bool d);
    private static Int32[] GetWindowList(Int32[] a, int b);
    private static int CreateWindowEntry(int a, int b);
    private static Int32[] Square(Int32[] a, Int32[] b);
    private static Int32[] Multiply(Int32[] a, Int32[] b, Int32[] c);
    private int GetMQuote();
    private static void MontgomeryReduce(Int32[] a, Int32[] b, UInt32 c);
    private static void MultiplyMonty(Int32[] a, Int32[] b, Int32[] c, Int32[] d, UInt32 e, bool f);
    private static void SquareMonty(Int32[] a, Int32[] b, Int32[] c, UInt32 d, bool e);
    private static UInt32 MultiplyMontyNIsOne(UInt32 a, UInt32 b, UInt32 c, UInt32 d);
    public zy Multiply(zy a);
    public zy Square();
    public zy Negate();
    public zy Not();
    public zy Pow(int a);
    private int Remainder(int a);
    private static Int32[] Remainder(Int32[] a, Int32[] b);
    public zy Remainder(zy a);
    private Int32[] LastNBits(int a);
    private zy DivideWords(int a);
    private zy RemainderWords(int a);
    private static Int32[] ShiftLeft(Int32[] a, int b);
    public zy ShiftLeft(int a);
    private static void ShiftRightInPlace(int a, Int32[] b, int c);
    private static void ShiftRightOneInPlace(int a, Int32[] b);
    public zy ShiftRight(int a);
    public int get_SignValue();
    private static Int32[] Subtract(int a, Int32[] b, int c, Int32[] d);
    public zy Subtract(zy a);
    private static Int32[] doSubBigLil(Int32[] a, Int32[] b);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool a);
    public virtual string ToString();
    public string ToString(int a);
    private static void AppendZeroExtendedString(StringBuilder a, string b, int c);
    private static zy CreateUValueOf(ulong a);
    private static zy CreateValueOf(long a);
    public static zy ValueOf(long a);
    public int GetLowestSetBit();
    private int GetLowestSetBitMaskFirst(int a);
    public bool TestBit(int a);
    public zy Or(zy a);
    public zy SetBit(int a);
    private zy FlipExistingBit(int a);
}
internal class zz : object {
    private zy a;
    private int b;
    public int Scale { get; }
    public zz(zy a, int b);
    private void CheckScale(zz a);
    public zz AdjustScale(int a);
    public zz Add(zz a);
    public zz Negate();
    public zz Subtract(zz a);
    public zz Subtract(zy a);
    public int CompareTo(zy a);
    public zy Floor();
    public zy Round();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object a);
    public virtual int GetHashCode();
}
