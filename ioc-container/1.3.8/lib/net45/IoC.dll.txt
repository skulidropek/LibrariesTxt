[AttributeUsageAttribute("4")]
public class IoC.AspChildControlTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ControlType>k__BackingField;
    [NotNullAttribute]
public string TagName { get; private set; }
    [NotNullAttribute]
public Type ControlType { get; private set; }
    public AspChildControlTypeAttribute(string tagName, Type controlType);
    [CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
public Type get_ControlType();
    [CompilerGeneratedAttribute]
private void set_ControlType(Type value);
}
[AttributeUsageAttribute("192")]
public class IoC.AspDataFieldAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
public class IoC.AspDataFieldsAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class IoC.AspMethodPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class IoC.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2176")]
public class IoC.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcAreaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcAreaViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2112")]
public class IoC.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class IoC.AspMvcPartialViewAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("68")]
public class IoC.AspMvcSuppressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class IoC.AspMvcViewAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.AspMvcViewComponentAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class IoC.AspMvcViewComponentViewAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class IoC.AspMvcViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("4")]
public class IoC.AspRequiredAttributeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Attribute>k__BackingField;
    [NotNullAttribute]
public string Attribute { get; private set; }
    public AspRequiredAttributeAttribute(string attribute);
    [CompilerGeneratedAttribute]
public string get_Attribute();
    [CompilerGeneratedAttribute]
private void set_Attribute(string value);
}
[AttributeUsageAttribute("128")]
public class IoC.AspTypePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CreateConstructorReferences>k__BackingField;
    public bool CreateConstructorReferences { get; private set; }
    public AspTypePropertyAttribute(bool createConstructorReferences);
    [CompilerGeneratedAttribute]
public bool get_CreateConstructorReferences();
    [CompilerGeneratedAttribute]
private void set_CreateConstructorReferences(bool value);
}
[AttributeUsageAttribute("2048")]
public class IoC.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; private set; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
    [CompilerGeneratedAttribute]
private void set_ConditionType(AssertionConditionType value);
}
public enum IoC.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
public class IoC.AssertionMethodAttribute : Attribute {
}
[ExtensionAttribute]
public static class IoC.AutowiringStrategies : object {
    public static IAutowiringStrategy AspectOriented();
    [ExtensionAttribute]
public static IAutowiringStrategy Type(IAutowiringStrategy strategy, Func`2<TTypeAttribute, Type> typeSelector);
    [ExtensionAttribute]
public static IAutowiringStrategy Order(IAutowiringStrategy strategy, Func`2<TOrderAttribute, IComparable> orderSelector);
    [ExtensionAttribute]
public static IAutowiringStrategy Tag(IAutowiringStrategy strategy, Func`2<TTagAttribute, object> tagSelector);
    private static AspectOrientedMetadata GuardAspectOrientedMetadata(IAutowiringStrategy strategy);
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
public class IoC.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("24516")]
public class IoC.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class IoC.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
public class IoC.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
public enum IoC.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[PublicAPIAttribute]
[DebuggerDisplayAttribute("Name = {ToString()}")]
[DebuggerTypeProxyAttribute("IoC.Container/ContainerDebugView")]
public class IoC.Container : object {
    private static long _containerId;
    [NotNullAttribute]
internal Table`2<Key, Delegate> Resolvers;
    [NotNullAttribute]
internal Table`2<Type, Delegate> ResolversByType;
    [NotNullAttribute]
private Table`2<Key, Registration> _registrations;
    [NotNullAttribute]
private Table`2<Type, Registration> _registrationsTagAny;
    private bool _isDisposed;
    [NotNullAttribute]
private IContainer _parent;
    [NotNullAttribute]
private string _name;
    [NotNullAttribute]
private ILockObject _lockObject;
    [NotNullAttribute]
private Subject`1<ContainerEvent> _eventSubject;
    [NotNullAttribute]
private List`1<IDisposable> _resources;
    [NotNullAttribute]
private RegistrationTracker _registrationTracker;
    public IContainer Parent { get; }
    internal Container(string name, IContainer parent, ILockObject lockObject);
    [PublicAPIAttribute]
[NotNullAttribute]
public static Container Create(IConfiguration[] configurations);
    [PublicAPIAttribute]
[NotNullAttribute]
public static Container Create(string name, IConfiguration[] configurations);
    public sealed virtual IContainer get_Parent();
    public virtual string ToString();
    public sealed virtual bool TryRegisterDependency(IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime, IToken& dependencyToken);
    public sealed virtual bool TryGetResolver(Type type, object tag, Resolver`1& resolver, Exception& error, IContainer resolvingContainer);
    internal bool TryGetResolver(Key key, Resolver`1& resolver, Exception& error, IContainer resolvingContainer);
    public sealed virtual bool TryGetDependency(Key key, IDependency& dependency, ILifetime& lifetime);
    public sealed virtual void Dispose();
    public sealed virtual void RegisterResource(IDisposable resource);
    public sealed virtual bool UnregisterResource(IDisposable resource);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IEnumerable`1<Key>> GetEnumerator();
    public sealed virtual IDisposable Subscribe(IObserver`1<ContainerEvent> observer);
    internal void Reset();
    private void CheckIsNotDisposed();
    private void UnregisterKeys(List`1<Key> registeredKeys, IDependency dependency, ILifetime lifetime);
    private IEnumerable`1<IEnumerable`1<Key>> GetAllKeys();
    private bool TryUnregister(TKey key, Table`2& entries);
    [NotNullAttribute]
internal static string CreateContainerName(string name);
    private void ApplyConfigurations(IConfiguration[] configurations);
    private bool TryGetRegistration(Key key, Registration& registration);
}
[PublicAPIAttribute]
public class IoC.ContainerEvent : ValueType {
    [NotNullAttribute]
public IContainer Container;
    public EventType EventType;
    public bool IsSuccess;
    [CanBeNullAttribute]
public Exception Error;
    [CanBeNullAttribute]
public IEnumerable`1<Key> Keys;
    [CanBeNullAttribute]
public IDependency Dependency;
    [CanBeNullAttribute]
public ILifetime Lifetime;
    [CanBeNullAttribute]
public LambdaExpression ResolverExpression;
    internal ContainerEvent(IContainer container, EventType eventType, bool isSuccess, Exception error, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime, LambdaExpression resolverExpression);
    internal static ContainerEvent NewContainer(IContainer newContainer);
    internal static ContainerEvent DisposeContainer(IContainer disposingContainer);
    internal static ContainerEvent RegisterDependency(IContainer registeringContainer, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime);
    internal static ContainerEvent RegisterDependencyFailed(IContainer registeringContainer, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime, Exception error);
    internal static ContainerEvent UnregisterDependency(IContainer registeringContainer, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime);
    internal static ContainerEvent Compilation(IContainer registeringContainer, IEnumerable`1<Key> keys, LambdaExpression resolverExpression);
    internal static ContainerEvent CompilationFailed(IContainer registeringContainer, IEnumerable`1<Key> keys, LambdaExpression resolverExpression, Exception error);
}
[PublicAPIAttribute]
public class IoC.Context : object {
    public Key Key;
    [NotNullAttribute]
public IContainer Container;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public Object[] Args;
    internal Context(Key key, IContainer container, Object[] args);
}
[PublicAPIAttribute]
public class IoC.Context`1 : Context {
    [NotNullAttribute]
public T It;
    internal Context`1(T it, Key key, IContainer container, Object[] args);
}
[AttributeUsageAttribute("64")]
public class IoC.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
internal class IoC.Core.ArgsResolver`1 : ValueType {
    public T Value;
    public bool HasValue;
    public ArgsResolver`1(Object[] args);
}
internal class IoC.Core.AspectOrientedAutowiringStrategy : object {
    [NotNullAttribute]
private IAspectOrientedMetadata _metadata;
    public AspectOrientedAutowiringStrategy(IAspectOrientedMetadata metadata);
    public sealed virtual bool TryResolveType(IContainer container, Type registeredType, Type resolvingType, Type& instanceType);
    public sealed virtual bool TryResolveConstructor(IContainer container, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors, IMethod`1& constructor);
    public sealed virtual bool TryResolveInitializers(IContainer container, IEnumerable`1<IMethod`1<MethodInfo>> methods, IEnumerable`1& initializers);
    private IEnumerable`1<IMethod`1<TMethodInfo>> PrepareMethods(IEnumerable`1<IMethod`1<TMethodInfo>> methods, bool enforceSelection);
    private Metadata[] GetParametersMetadata(IMethod`1<TMethodInfo> method);
    private IMethod`1<TMethodInfo> SetDependencies(IMethod`1<TMethodInfo> method, Metadata[] parametersMetadata, Metadata methodMetadata);
}
internal class IoC.Core.AspectOrientedMetadata : ValueType {
    internal static AspectOrientedMetadata Empty;
    private IDictionary`2<Type, Func`2<Attribute, Type>> _typeSelectors;
    private IDictionary`2<Type, Func`2<Attribute, IComparable>> _orderSelectors;
    private IDictionary`2<Type, Func`2<Attribute, object>> _tagSelectors;
    private ILockObject _lockObject;
    private IAutowiringStrategy modreq(System.Runtime.CompilerServices.IsVolatile) _autowiringStrategy;
    private AspectOrientedMetadata(IDictionary`2<Type, Func`2<Attribute, Type>> typeSelectors, IDictionary`2<Type, Func`2<Attribute, IComparable>> orderSelectors, IDictionary`2<Type, Func`2<Attribute, object>> tagSelectors);
    private static AspectOrientedMetadata();
    public static AspectOrientedMetadata Type(AspectOrientedMetadata metadata, Func`2<TTypeAttribute, Type> typeSelector);
    public static AspectOrientedMetadata Order(AspectOrientedMetadata metadata, Func`2<TOrderAttribute, IComparable> orderSelector);
    public static AspectOrientedMetadata Tag(AspectOrientedMetadata metadata, Func`2<TTagAttribute, object> tagSelector);
    private sealed virtual override bool IoC.Core.IAspectOrientedMetadata.TryGetType(Attribute attribute, Type& type);
    private sealed virtual override bool IoC.Core.IAspectOrientedMetadata.TryGetOrder(Attribute attribute, IComparable& comparable);
    private sealed virtual override bool IoC.Core.IAspectOrientedMetadata.TryGetTag(Attribute attribute, Object& tag);
    public sealed virtual bool TryResolveType(IContainer container, Type registeredType, Type resolvingType, Type& instanceType);
    public sealed virtual bool TryResolveConstructor(IContainer container, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors, IMethod`1& constructor);
    public sealed virtual bool TryResolveInitializers(IContainer container, IEnumerable`1<IMethod`1<MethodInfo>> methods, IEnumerable`1& initializers);
    private IAutowiringStrategy GetAutowiringStrategy();
}
internal class IoC.Core.Binding`1 : ValueType {
    [CompilerGeneratedAttribute]
private IMutableContainer <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<object> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private ILifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private IAutowiringStrategy <AutowiringStrategy>k__BackingField;
    public IMutableContainer Container { get; }
    public IEnumerable`1<IToken> Tokens { get; }
    public IEnumerable`1<Type> Types { get; }
    public IEnumerable`1<object> Tags { get; }
    public ILifetime Lifetime { get; }
    public IAutowiringStrategy AutowiringStrategy { get; }
    public Binding`1(IMutableContainer container, Type[] types);
    public Binding`1(IToken token, Type[] types);
    public Binding`1(IBinding binding, Type[] types);
    public Binding`1(IBinding`1<T> binding, Lifetime lifetime);
    public Binding`1(IBinding`1<T> binding, ILifetime lifetime);
    public Binding`1(IBinding`1<T> binding, object tagValue);
    public Binding`1(IBinding`1<T> binding, IAutowiringStrategy autowiringStrategy);
    [CompilerGeneratedAttribute]
public sealed virtual IMutableContainer get_Container();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IToken> get_Tokens();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_Types();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<object> get_Tags();
    [CompilerGeneratedAttribute]
public sealed virtual ILifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual IAutowiringStrategy get_AutowiringStrategy();
}
[PublicAPIAttribute]
internal class IoC.Core.BuildContext : object {
    [NotNullAttribute]
private IEnumerable`1<IBuilder> _builders;
    [NotNullAttribute]
private IObserver`1<ContainerEvent> _eventObserver;
    private IList`1<ParameterExpression> _parameters;
    [NotNullAttribute]
private IDictionary`2<Type, Type> _typesMap;
    private IDictionary`2<Key, Expression> _cache;
    [CompilerGeneratedAttribute]
private IBuildContext <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private IContainer <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICompiler> <Compilers>k__BackingField;
    [CompilerGeneratedAttribute]
private IAutowiringStrategy <AutowiringStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <ArgsParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <ContainerParameter>k__BackingField;
    public IBuildContext Parent { get; private set; }
    public Key Key { get; }
    public IContainer Container { get; }
    public IEnumerable`1<ICompiler> Compilers { get; private set; }
    public IAutowiringStrategy AutowiringStrategy { get; }
    public int Depth { get; }
    public ParameterExpression ArgsParameter { get; private set; }
    public ParameterExpression ContainerParameter { get; private set; }
    internal BuildContext(BuildContext parent, Key key, IContainer resolvingContainer, IEnumerable`1<ICompiler> compilers, IEnumerable`1<IBuilder> builders, IAutowiringStrategy defaultAutowiringStrategy, ParameterExpression argsParameter, ParameterExpression containerParameter, IObserver`1<ContainerEvent> eventObserver, int depth);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildContext get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IBuildContext value);
    [CompilerGeneratedAttribute]
public sealed virtual Key get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual IContainer get_Container();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ICompiler> get_Compilers();
    [CompilerGeneratedAttribute]
private void set_Compilers(IEnumerable`1<ICompiler> value);
    [CompilerGeneratedAttribute]
public sealed virtual IAutowiringStrategy get_AutowiringStrategy();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Depth();
    [CompilerGeneratedAttribute]
public sealed virtual ParameterExpression get_ArgsParameter();
    [CompilerGeneratedAttribute]
private void set_ArgsParameter(ParameterExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual ParameterExpression get_ContainerParameter();
    [CompilerGeneratedAttribute]
private void set_ContainerParameter(ParameterExpression value);
    public sealed virtual IBuildContext CreateChild(Key key, IContainer container);
    public sealed virtual Expression CreateExpression(Expression defaultExpression);
    public sealed virtual void AddParameter(ParameterExpression parameterExpression);
    public sealed virtual void MapType(Type fromType, Type toType);
    public sealed virtual Expression FinalizeExpression(Expression baseExpression, ILifetime lifetime);
    public sealed virtual bool TryCompile(LambdaExpression lambdaExpression, Delegate& lambdaCompiled, Exception& error);
    private IBuildContext CreateInternal(Key key, IContainer container);
    public virtual string ToString();
}
internal class IoC.Core.BuildExpressionException : InvalidOperationException {
    public BuildExpressionException(string message, Exception innerException);
}
internal class IoC.Core.CannotBuildExpression : object {
    public static ICannotBuildExpression Shared;
    private static CannotBuildExpression();
    public sealed virtual Expression Resolve(IBuildContext buildContext, IDependency dependency, ILifetime lifetime, Exception error);
}
internal class IoC.Core.CannotGetResolver : object {
    public static ICannotGetResolver Shared;
    private static CannotGetResolver();
    public sealed virtual Resolver`1<T> Resolve(IContainer container, Key key, Exception error);
}
internal class IoC.Core.CannotRegister : object {
    public static ICannotRegister Shared;
    private static CannotRegister();
    public sealed virtual IToken Resolve(IContainer container, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime);
}
internal class IoC.Core.CannotResolveConstructor : object {
    public static ICannotResolveConstructor Shared;
    private static CannotResolveConstructor();
    public sealed virtual IMethod`1<ConstructorInfo> Resolve(IBuildContext buildContext, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors);
}
internal class IoC.Core.CannotResolveDependency : object {
    public static ICannotResolveDependency Shared;
    private static CannotResolveDependency();
    public sealed virtual DependencyDescription Resolve(IBuildContext buildContext);
}
internal class IoC.Core.CannotResolveGenericTypeArgument : object {
    public static ICannotResolveGenericTypeArgument Shared;
    private static CannotResolveGenericTypeArgument();
    public sealed virtual Type Resolve(IBuildContext buildContext, Type type, int genericTypeArgPosition, Type genericTypeArg);
}
internal class IoC.Core.CannotResolveType : object {
    public static ICannotResolveType Shared;
    private static CannotResolveType();
    public sealed virtual Type Resolve(IBuildContext buildContext, Type registeredType, Type resolvingType);
}
internal class IoC.Core.ConfigurationFromDelegate : object {
    [NotNullAttribute]
private Func`2<IContainer, IToken> _configurationFactory;
    public ConfigurationFromDelegate(Func`2<IContainer, IToken> configurationFactory);
    [IteratorStateMachineAttribute("IoC.Core.ConfigurationFromDelegate/<Apply>d__2")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
internal class IoC.Core.ContainerEventToStringConverter : object {
    private static PropertyInfo PropertyInfo;
    public static IConverter`3<ContainerEvent, IContainer, string> Shared;
    private static ContainerEventToStringConverter();
    public sealed virtual bool TryConvert(IContainer context, ContainerEvent src, String& dst);
    [CanBeNullAttribute]
private static string GetDebugView(Expression expression);
    [NotNullAttribute]
private static string FormatDependency(ContainerEvent containerEvent);
    [NotNullAttribute]
private static string FormatKeys(ContainerEvent containerEvent);
    [NotNullAttribute]
private static string FormatKey(Key key);
    [NotNullAttribute]
private static string FormatPrefix(IContainer container);
    [NotNullAttribute]
private static string GetString(T value, string defaultString);
    [NotNullAttribute]
private static string Quoted(string text);
}
[ExtensionAttribute]
internal static class IoC.Core.CoreExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(T[] array1, T[] array2);
    [ExtensionAttribute]
public static int GetHash(T[] items);
    public static T[] EmptyArray();
    public static T[] CreateArray(int size, T value);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static T[] Add(T[] source, T value);
    [ExtensionAttribute]
[PureAttribute]
public static T[] Copy(T[] previous);
}
internal class IoC.Core.DefaultAutowiringStrategy : object {
    public static IAutowiringStrategy Shared;
    private static DefaultAutowiringStrategy();
    public sealed virtual bool TryResolveType(IContainer container, Type registeredType, Type resolvingType, Type& instanceType);
    public sealed virtual bool TryResolveConstructor(IContainer container, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors, IMethod`1& constructor);
    public sealed virtual bool TryResolveInitializers(IContainer container, IEnumerable`1<IMethod`1<MethodInfo>> methods, IEnumerable`1& initializers);
}
internal class IoC.Core.DefaultCompiler : object {
    public static ICompiler Shared;
    private static DefaultCompiler();
    public sealed virtual bool TryCompile(IBuildContext context, LambdaExpression lambdaExpression, Delegate& lambdaCompiled, Exception& error);
}
internal class IoC.Core.DependencyInjectionExpressionVisitor : ExpressionVisitor {
    private static Exception InvalidExpressionError;
    private static Key ContextKey;
    private static TypeDescriptor ContextTypeDescriptor;
    private static TypeDescriptor GenericContextTypeDescriptor;
    [NotNullAttribute]
private static ConstructorInfo ContextConstructor;
    [NotNullAttribute]
private IContainer _container;
    [NotNullAttribute]
private IBuildContext _buildContext;
    [CanBeNullAttribute]
private Expression _thisExpression;
    public DependencyInjectionExpressionVisitor(IBuildContext buildContext, Expression thisExpression);
    private static DependencyInjectionExpressionVisitor();
    protected virtual Expression VisitMethodCall(MethodCallExpression methodCall);
    private Expression OverrideArgsAndCreateDependencyExpression(Expression argsExpression, Key key, Expression containerExpression, DefaultExpression defaultExpression);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    private Expression CreateNewContextExpression();
    [CanBeNullAttribute]
private object GetTag(Expression tagExpression);
    private IEnumerable`1<Expression> InjectAll(IEnumerable`1<Expression> expressions);
    private IContainer SelectedContainer(Expression containerExpression);
    private Expression CreateDependencyExpression(Key key, Expression containerExpression, DefaultExpression defaultExpression);
    private bool TryReplaceContextFields(Type type, string name, Expression& expression);
}
[ExtensionAttribute]
internal static class IoC.Core.Disposable : object {
    private static TypeDescriptor DisposableTypeDescriptor;
    [NotNullAttribute]
public static IDisposable Empty;
    private static Disposable();
    [NotNullAttribute]
public static IDisposable Create(Action action);
    [ExtensionAttribute]
public static bool IsDisposable(TypeDescriptor typeDescriptor);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDisposable AsDisposable(T instance);
    [ExtensionAttribute]
public static void Register(IResourceRegistry registry, IDisposable disposable);
    [ExtensionAttribute]
public static void UnregisterAndDispose(IResourceRegistry registry, IDisposable disposable);
    [NotNullAttribute]
public static IDisposable Create(IEnumerable`1<IDisposable> disposables);
}
[ExtensionAttribute]
internal static class IoC.Core.ExpressionBuilderExtensions : object {
    private static TypeDescriptor ResolverGenericTypeDescriptor;
    internal static Expression NullConst;
    internal static Expression ContainerExpression;
    internal static MethodInfo EqualsMethodInfo;
    private static MethodInfo EnterMethodInfo;
    private static MethodInfo ExitMethodInfo;
    private static ExpressionBuilderExtensions();
    [ExtensionAttribute]
public static Expression Convert(Expression expression, Type type);
    [ExtensionAttribute]
public static Type ToResolverType(Type type);
    [ExtensionAttribute]
public static Expression Lock(Expression body, Expression lockObject);
    public static Expression BuildGetOrCreateInstance(T owner, IBuildContext context, Expression bodyExpression, string methodName);
}
[ExtensionAttribute]
[PublicAPIAttribute]
internal static class IoC.Core.FluentRegister : object {
    internal static Object[] AnyTag;
    private static IEnumerable`1<object> DefaultTags;
    private static FluentRegister();
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, ILifetime lifetime, Object[] tags);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, Expression`1<Func`2<Context, T>> factory, ILifetime lifetime, Object[] tags, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, IEnumerable`1<Type> types, IDependency dependency, ILifetime lifetime, Object[] tags);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, ILifetime lifetime, Object[] tags);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, Expression`1<Func`2<Context, T>> factory, ILifetime lifetime, Object[] tags, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, ILifetime lifetime, Object[] tags);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, Expression`1<Func`2<Context, T>> factory, ILifetime lifetime, Object[] tags, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, ILifetime lifetime, Object[] tags);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Register(IMutableContainer container, Expression`1<Func`2<Context, T>> factory, ILifetime lifetime, Object[] tags, Expression`1[] statements);
}
internal class IoC.Core.FoundCyclicDependency : object {
    public static IFoundCyclicDependency Shared;
    private static FoundCyclicDependency();
    public sealed virtual void Resolve(IBuildContext buildContext);
}
internal interface IoC.Core.IArray {
}
internal interface IoC.Core.IAspectOrientedMetadata {
    public abstract virtual bool TryGetType(Attribute attribute, Type& type);
    public abstract virtual bool TryGetOrder(Attribute attribute, IComparable& comparable);
    public abstract virtual bool TryGetTag(Attribute attribute, Object& tag);
}
internal interface IoC.Core.IConverter`3 {
    public abstract virtual bool TryConvert(TContext context, TSrc src, TDst& dst);
}
internal interface IoC.Core.ILockObject {
}
internal interface IoC.Core.IRegistrationTracker {
    [NotNullAttribute]
public IEnumerable`1<IBuilder> Builders { get; }
    [NotNullAttribute]
public IAutowiringStrategy AutowiringStrategy { get; }
    [NotNullAttribute]
public IEnumerable`1<ICompiler> Compilers { get; }
    public abstract virtual IEnumerable`1<IBuilder> get_Builders();
    public abstract virtual IAutowiringStrategy get_AutowiringStrategy();
    public abstract virtual IEnumerable`1<ICompiler> get_Compilers();
}
internal interface IoC.Core.IScopeManager {
    [NotNullAttribute]
public IScope Current { get; }
    public abstract virtual IScope get_Current();
    [NotNullAttribute]
public abstract virtual IDisposable Activate(IScope scope);
}
internal interface IoC.Core.ISubject`1 {
}
internal class IoC.Core.LockObject : object {
}
internal class IoC.Core.Method`1 : object {
    private Expression[] _parametersExpressions;
    private ParameterInfo[] _parameters;
    [CompilerGeneratedAttribute]
private TMethodInfo <Info>k__BackingField;
    public TMethodInfo Info { get; }
    public Method`1(TMethodInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual TMethodInfo get_Info();
    [IteratorStateMachineAttribute("IoC.Core.Method`1/<GetParametersExpressions>d__6")]
public sealed virtual IEnumerable`1<Expression> GetParametersExpressions(IBuildContext buildContext);
    public sealed virtual void SetExpression(int parameterPosition, Expression parameterExpression);
    public sealed virtual void SetDependency(int parameterPosition, Type dependencyType, object dependencyTag, bool isOptional, Object[] args);
}
[ExtensionAttribute]
internal static class IoC.Core.Observable : object {
    [NotNullAttribute]
public static IObservable`1<T> Create(Func`2<IObserver`1<T>, IDisposable> factory);
    [ExtensionAttribute]
public static IDisposable Subscribe(IObservable`1<T> source, Action`1<T> onNext, Action`1<Exception> onError, Action oncComplete);
    [ExtensionAttribute]
public static IObservable`1<TResult> Select(IObservable`1<T> source, Func`2<T, TResult> selector);
    [ExtensionAttribute]
public static IObservable`1<T> Where(IObservable`1<T> source, Predicate`1<T> filter);
}
internal class IoC.Core.Registration : object {
    [NotNullAttribute]
internal static ParameterExpression ContainerParameter;
    [NotNullAttribute]
internal static ParameterExpression ArgsParameter;
    [NotNullAttribute]
[ItemNotNullAttribute]
internal static IEnumerable`1<ParameterExpression> ResolverParameters;
    [CanBeNullAttribute]
internal ILifetime Lifetime;
    [NotNullAttribute]
private IDisposable _resource;
    [NotNullAttribute]
internal ICollection`1<Key> Keys;
    [NotNullAttribute]
private IObserver`1<ContainerEvent> _eventObserver;
    [NotNullAttribute]
internal IDependency Dependency;
    private Table`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lifetimes;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private IMutableContainer <Container>k__BackingField;
    public IMutableContainer Container { get; }
    public Registration(IMutableContainer container, IObserver`1<ContainerEvent> eventObserver, IDependency dependency, ILifetime lifetime, IDisposable resource, ICollection`1<Key> keys);
    private static Registration();
    [CompilerGeneratedAttribute]
public sealed virtual IMutableContainer get_Container();
    public bool TryCreateResolver(Key key, IContainer resolvingContainer, IRegistrationTracker registrationTracker, Resolver`1& resolver, Exception& error);
    [CanBeNullAttribute]
public ILifetime GetLifetime(Type type);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
internal class IoC.Core.RegistrationTracker : object {
    private Container _container;
    private ITracker[] _trackers;
    private Tracker`1<IBuilder> _builderTracker;
    private Tracker`1<IAutowiringStrategy> _autowiringStrategyTracker;
    private Tracker`1<ICompiler> _compilerTracker;
    public IEnumerable`1<IBuilder> Builders { get; }
    public IAutowiringStrategy AutowiringStrategy { get; }
    public IEnumerable`1<ICompiler> Compilers { get; }
    public RegistrationTracker(Container container);
    public sealed virtual IEnumerable`1<IBuilder> get_Builders();
    public sealed virtual IAutowiringStrategy get_AutowiringStrategy();
    public sealed virtual IEnumerable`1<ICompiler> get_Compilers();
    public sealed virtual void OnNext(ContainerEvent value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
}
internal class IoC.Core.RootContainer : object {
    public static IContainer Shared;
    private static NotSupportedException NotSupportedException;
    public IContainer Parent { get; }
    private static RootContainer();
    public sealed virtual IContainer get_Parent();
    public sealed virtual bool TryGetDependency(Key key, IDependency& dependency, ILifetime& lifetime);
    public sealed virtual bool TryGetResolver(Type type, object tag, Resolver`1& resolver, Exception& error, IContainer resolvingContainer);
    public sealed virtual void RegisterResource(IDisposable resource);
    public sealed virtual bool UnregisterResource(IDisposable resource);
    public void Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IEnumerable`1<Key>> GetEnumerator();
    public sealed virtual IDisposable Subscribe(IObserver`1<ContainerEvent> observer);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{ToString()}")]
internal class IoC.Core.Scope : object {
    private static long _currentScopeKey;
    internal long ScopeKey;
    private int _scopeHashCode;
    [NotNullAttribute]
private IScopeManager _scopeManager;
    [NotNullAttribute]
private ILockObject _lockObject;
    private IContainer _container;
    private IList`1<IDisposable> _resources;
    private bool _isDefault;
    public IContainer Container { get; }
    public IContainer Parent { get; }
    public Scope(IScopeManager scopeManager, ILockObject lockObject, IContainer container, bool isDefault);
    public sealed virtual IContainer get_Container();
    public sealed virtual IDisposable Activate();
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IEnumerable`1<Key>> GetEnumerator();
    public sealed virtual IDisposable Subscribe(IObserver`1<ContainerEvent> observer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void RegisterResource(IDisposable resource);
    public sealed virtual bool UnregisterResource(IDisposable resource);
    public sealed virtual IContainer get_Parent();
    public sealed virtual bool TryGetDependency(Key key, IDependency& dependency, ILifetime& lifetime);
    public sealed virtual bool TryGetResolver(Type type, object tag, Resolver`1& resolver, Exception& error, IContainer resolvingContainer);
}
internal class IoC.Core.ScopeManager : object {
    [NotNullAttribute]
private IScope _current;
    [CanBeNullAttribute]
private IScope _prev;
    public IScope Current { get; }
    public ScopeManager(ILockObject lockObject, IContainer container);
    public sealed virtual IScope get_Current();
    public sealed virtual IDisposable Activate(IScope scope);
    [CompilerGeneratedAttribute]
private void <Activate>b__5_0();
}
internal class IoC.Core.Subject`1 : object {
    private ILockObject _lockObject;
    private List`1<IObserver`1<T>> _observers;
    public Subject`1(ILockObject lockObject);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
}
internal class IoC.Core.Table`2 : object {
    private static Bucket<TKey, TValue> EmptyBucket;
    public static Table`2<TKey, TValue> Empty;
    public int Count;
    public int Divisor;
    public Bucket[] Buckets;
    private Table`2(int size);
    private Table`2(Bucket[] buckets, int divisor, int count);
    private Table`2(Table`2<TKey, TValue> origin, TKey key, TValue value);
    private static Table`2();
    [PureAttribute]
public TValue Get(TKey key);
    [IteratorStateMachineAttribute("IoC.Core.Table`2/<GetEnumerator>d__9")]
[PureAttribute]
public sealed virtual IEnumerator`1<KeyValue<TKey, TValue>> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Table`2<TKey, TValue> Set(TKey key, TValue value);
    [PureAttribute]
public Table`2<TKey, TValue> Remove(TKey key, Boolean& removed);
}
[ExtensionAttribute]
internal static class IoC.Core.TableExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool TryGetByType(Table`2<Type, TValue> table, Type key, TValue& value);
    [ExtensionAttribute]
[PureAttribute]
public static bool TryGetByKey(Table`2<Key, TValue> table, Key key, TValue& value);
}
internal class IoC.Core.Token : ValueType {
    [NotNullAttribute]
private IDisposable _dependencyToken;
    [CompilerGeneratedAttribute]
private IMutableContainer <Container>k__BackingField;
    public IMutableContainer Container { get; }
    public Token(IMutableContainer container, IDisposable dependencyToken);
    [CompilerGeneratedAttribute]
public sealed virtual IMutableContainer get_Container();
    public sealed virtual void Dispose();
}
internal class IoC.Core.TypeDescriptor : ValueType {
    private static BindingFlags DefaultBindingFlags;
    internal Type Type;
    public TypeDescriptor(Type type);
    [NotNullAttribute]
[PureAttribute]
public Type AsType();
    [PureAttribute]
public Guid GetId();
    [NotNullAttribute]
[PureAttribute]
public Assembly GetAssembly();
    [PureAttribute]
public bool IsValueType();
    [PureAttribute]
public bool IsArray();
    [PureAttribute]
public bool IsPublic();
    [CanBeNullAttribute]
[PureAttribute]
public Type GetElementType();
    [PureAttribute]
public bool IsInterface();
    [PureAttribute]
public bool IsAbstract();
    [PureAttribute]
public bool IsGenericParameter();
    [PureAttribute]
public bool IsConstructedGenericType();
    [PureAttribute]
public bool IsGenericTypeDefinition();
    public bool IsGenericTypeArgument();
    [NotNullAttribute]
[PureAttribute]
public Type[] GetGenericTypeArguments();
    [NotNullAttribute]
[PureAttribute]
public Type[] GetGenericParameterConstraints();
    [PureAttribute]
public GenericParameterAttributes GetGenericParameterAttributes();
    [NotNullAttribute]
[PureAttribute]
public Type[] GetGenericTypeParameters();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<ConstructorInfo> GetDeclaredConstructors();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<MethodInfo> GetDeclaredMethods();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<MemberInfo> GetDeclaredMembers();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<FieldInfo> GetDeclaredFields();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<PropertyInfo> GetDeclaredProperties();
    [CanBeNullAttribute]
[PureAttribute]
public Type GetBaseType();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<Type> GetImplementedInterfaces();
    [PureAttribute]
public bool IsAssignableFrom(TypeDescriptor typeDescriptor);
    [NotNullAttribute]
[PureAttribute]
public Type MakeGenericType(Type[] typeArguments);
    [NotNullAttribute]
[PureAttribute]
public Type GetGenericTypeDefinition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string Trace();
}
internal static class IoC.Core.TypeDescriptor`1 : object {
    public static TypeDescriptor Descriptor;
    public static int HashCode;
    private static TypeDescriptor`1();
}
[ExtensionAttribute]
internal static class IoC.Core.TypeDescriptorExtensions : object {
    [ExtensionAttribute]
public static TypeDescriptor Descriptor(Type type);
    public static TypeDescriptor Descriptor();
    public static Assembly LoadAssembly(string assemblyName);
    [ExtensionAttribute]
[NotNullAttribute]
public static Type ToGenericType(Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetShortName(Type type);
}
internal class IoC.Core.TypeMapper : object {
    public static TypeMapper Shared;
    private static TypeMapper();
    public void Map(Type type, Type targetType, IDictionary`2<Type, Type> typesMap);
}
internal class IoC.Core.TypeReplacerExpressionVisitor : ExpressionVisitor {
    [NotNullAttribute]
private IDictionary`2<Type, Type> _typesMap;
    [NotNullAttribute]
private Dictionary`2<ParameterExpression, ParameterExpression> _parameters;
    public TypeReplacerExpressionVisitor(IDictionary`2<Type, Type> typesMap);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    protected virtual Expression VisitListInit(ListInitExpression node);
    private ElementInit VisitInitializer(ElementInit node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    private bool Match(IList`1<ParameterInfo> baseParams, IList`1<ParameterInfo> newParams);
    private Type[] ReplaceTypes(Type[] types);
    private Type ReplaceType(Type type);
    private IEnumerable`1<Expression> ReplaceAll(IEnumerable`1<Expression> expressions);
}
internal class IoC.Core.TypeToStringConverter : object {
    public static IConverter`3<Type, Type, string> Shared;
    private static IDictionary`2<Type, string> PrimitiveTypes;
    private static TypeToStringConverter();
    public sealed virtual bool TryConvert(Type context, Type type, String& typeName);
    public static string Convert(Type type);
    private static string GetTypeName(Type type);
}
public class IoC.Dependencies.AutowiringDependency : object {
    [NotNullAttribute]
private Type _implementationType;
    [CanBeNullAttribute]
private IAutowiringStrategy _autowiringStrategy;
    private bool _hasGenericParamsWithConstraints;
    private List`1<GenericParamsWithConstraints> _genericParamsWithConstraints;
    private Type[] _genericTypeParameters;
    private TypeDescriptor _typeDescriptor;
    [NotNullAttribute]
[ItemNotNullAttribute]
private LambdaExpression[] _initializeInstanceExpressions;
    private IDictionary`2<Type, Type> _typesMap;
    public AutowiringDependency(Type implementationType, LambdaExpression[] initializeInstanceLambdaStatements);
    public AutowiringDependency(Type implementationType, IAutowiringStrategy autowiringStrategy, LambdaExpression[] initializeInstanceLambdaStatements);
    public sealed virtual bool TryBuildExpression(IBuildContext buildContext, ILifetime lifetime, Expression& expression, Exception& error);
    private Type ResolveInstanceType(IBuildContext buildContext, IAutowiringStrategy autoWiringStrategy);
    private static IMethod`1<ConstructorInfo> SelectConstructor(IBuildContext buildContext, TypeDescriptor typeDescriptor, IAutowiringStrategy autoWiringStrategy);
    private TypeDescriptor CreateTypeDescriptor(IBuildContext buildContext, Type type, Dictionary`2<Type, Type> typesMap);
    [CanBeNullAttribute]
internal Type GetInstanceTypeBasedOnTargetGenericConstrains(Type type);
    public virtual string ToString();
}
internal class IoC.Dependencies.BaseDependency : object {
    [NotNullAttribute]
private IDictionary`2<Type, Type> _typesMap;
    private Expression _createInstanceExpression;
    [CanBeNullAttribute]
private IAutowiringStrategy _autowiringStrategy;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<Expression> _initializeInstanceExpressions;
    public BaseDependency(Expression instanceExpression, IEnumerable`1<Expression> initializeInstanceExpressions, IDictionary`2<Type, Type> typesMap, IAutowiringStrategy autowiringStrategy);
    public sealed virtual bool TryBuildExpression(IBuildContext buildContext, ILifetime lifetime, Expression& expression, Exception& error);
    public virtual string ToString();
    private static Expression ReplaceTypes(IBuildContext buildContext, Expression expression, IDictionary`2<Type, Type> typesMap);
    private static IEnumerable`1<IMethod`1<MethodInfo>> GetInitializers(IContainer container, IAutowiringStrategy autoWiringStrategy, TypeDescriptor typeDescriptor);
}
public class IoC.Dependencies.ExpressionDependency : object {
    private LambdaExpression _instanceExpression;
    [CanBeNullAttribute]
private IAutowiringStrategy _autowiringStrategy;
    [NotNullAttribute]
[ItemNotNullAttribute]
private LambdaExpression[] _initializeInstanceExpressions;
    public ExpressionDependency(LambdaExpression instanceExpression, LambdaExpression[] initializeInstanceExpressions);
    public ExpressionDependency(LambdaExpression instanceExpression, IAutowiringStrategy autowiringStrategy, LambdaExpression[] initializeInstanceExpressions);
    public sealed virtual bool TryBuildExpression(IBuildContext buildContext, ILifetime lifetime, Expression& expression, Exception& error);
    public virtual string ToString();
}
public enum IoC.EventType : Enum {
    public int value__;
    public static EventType CreateContainer;
    public static EventType DisposeContainer;
    public static EventType RegisterDependency;
    public static EventType ContainerStateSingletonLifetime;
    public static EventType ResolverCompilation;
}
[PublicAPIAttribute]
public class IoC.Features.CollectionFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    private static CollectionFeature();
    [IteratorStateMachineAttribute("IoC.Features.CollectionFeature/<Apply>d__2")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
    [IteratorStateMachineAttribute("IoC.Features.CollectionFeature/<GetKeys>d__3")]
private static IEnumerable`1<Key> GetKeys(IContainer container, Type type);
}
public class IoC.Features.CommonTypesFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    private static CommonTypesFeature();
    [IteratorStateMachineAttribute("IoC.Features.CommonTypesFeature/<Apply>d__2")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
[PublicAPIAttribute]
public class IoC.Features.CoreFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    private static CoreFeature();
    [IteratorStateMachineAttribute("IoC.Features.CoreFeature/<Apply>d__2")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
[PublicAPIAttribute]
public class IoC.Features.DefaultFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    [NotNullAttribute]
private static IEnumerable`1<IConfiguration> Features;
    private static DefaultFeature();
    [IteratorStateMachineAttribute("IoC.Features.DefaultFeature/<Apply>d__3")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
[PublicAPIAttribute]
public class IoC.Features.FuncFeature : object {
    [NotNullAttribute]
private static MethodInfo ResolveWithTagGenericMethodInfo;
    [NotNullAttribute]
public static IConfiguration Set;
    [NotNullAttribute]
public static IConfiguration LightSet;
    private bool _light;
    private FuncFeature(bool light);
    private static FuncFeature();
    [IteratorStateMachineAttribute("IoC.Features.FuncFeature/<Apply>d__5")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
    private static T Resolve(IContainer container, object tag, Object[] args);
}
[FlagsAttribute]
public enum IoC.Features.Options : Enum {
    public int value__;
    public static Options ResolveArgs;
    public static Options ResolveDefaults;
}
public class IoC.Features.ResolveUnboundFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    private static TypeDescriptor ArgsResolverDescriptor;
    [NotNullAttribute]
private Func`2<Key, Key> _keyResolver;
    private Options _options;
    public ResolveUnboundFeature(Func`2<Key, Key> keyResolver);
    public ResolveUnboundFeature(Options options, Func`2<Key, Key> keyResolver);
    private static ResolveUnboundFeature();
    [IteratorStateMachineAttribute("IoC.Features.ResolveUnboundFeature/<Apply>d__7")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
    private sealed virtual override Resolver`1<T> IoC.Issues.ICannotGetResolver.Resolve(IContainer container, Key key, Exception error);
    private sealed virtual override DependencyDescription IoC.Issues.ICannotResolveDependency.Resolve(IBuildContext buildContext);
    public sealed virtual bool TryBuildExpression(IBuildContext buildContext, ILifetime lifetime, Expression& expression, Exception& error);
    private static bool IsValidType(Type type);
    private bool KeyResolver(Key key, Key& newKey);
    private static Key DefaultKeyResolver(Key key);
}
[PublicAPIAttribute]
public class IoC.Features.TaskFeature : object {
    [CanBeNullAttribute]
private TaskScheduler _taskScheduler;
    [NotNullAttribute]
public static IConfiguration Set;
    public TaskFeature(TaskScheduler taskScheduler);
    private static TaskFeature();
    [IteratorStateMachineAttribute("IoC.Features.TaskFeature/<Apply>d__3")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
    private static Task`1<T> CreateTask(Func`1<T> factory, TaskScheduler taskScheduler);
}
[PublicAPIAttribute]
public class IoC.Features.TupleFeature : object {
    [NotNullAttribute]
public static IConfiguration Set;
    private static TupleFeature();
    [IteratorStateMachineAttribute("IoC.Features.TupleFeature/<Apply>d__1")]
public sealed virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentBind : object {
    [ExtensionAttribute]
public static bool IsBound(IContainer container, Type type, object tag);
    [ExtensionAttribute]
public static bool IsBound(IContainer container, object tag);
    [ExtensionAttribute]
public static bool CanResolve(IContainer container, Type type, object tag);
    [ExtensionAttribute]
public static bool CanResolve(IContainer container, object tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<object> Bind(IMutableContainer container, Type[] types);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<object> Bind(IToken token, Type[] types);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> As(IBinding`1<T> binding, Lifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Lifetime(IBinding`1<T> binding, ILifetime lifetime);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Autowiring(IBinding`1<T> binding, IAutowiringStrategy autowiringStrategy);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Tag(IBinding`1<T> binding, object tagValue);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> AnyTag(IBinding`1<T> binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken To(IBinding`1<object> binding, Type type, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken To(IBinding`1<T> binding, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken To(IBinding`1<T> binding, Expression`1<Func`2<Context, T>> factory, Expression`1[] statements);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken To(IBinding`1<T> binding, IDependency dependency);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IBinding binding);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBinding`1<T> Bind(IToken token);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentConfiguration : object {
    [NotNullAttribute]
public static IConfiguration Create(Func`2<IContainer, IToken> configurationFactory);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken AsTokenOf(IDisposable disposableToken, IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container, String[] configurationText);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token, String[] configurationText);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container, Stream[] configurationStreams);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token, Stream[] configurationStreams);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container, TextReader[] configurationReaders);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token, TextReader[] configurationReaders);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container, IEnumerable`1<IConfiguration> configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token, IEnumerable`1<IConfiguration> configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container, IConfiguration[] configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token, IConfiguration[] configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IToken Apply(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Using(IMutableContainer container, IConfiguration[] configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Using(IToken token, IConfiguration[] configurations);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Using(IMutableContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Using(IToken token);
    [ExtensionAttribute]
[NotNullAttribute]
private static IToken ApplyConfigurationFromData(IMutableContainer container, T[] configurationData);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentContainer : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Create(IContainer parentContainer, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMutableContainer Create(IToken token, string name);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentGetResolver : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(IContainer container, Type type, Tag tag);
    [ExtensionAttribute]
public static bool TryGetResolver(IContainer container, Type type, Tag tag, Resolver`1& resolver);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(IContainer container, Tag tag);
    [ExtensionAttribute]
public static bool TryGetResolver(IContainer container, Tag tag, Resolver`1& resolver);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(IContainer container, Type type);
    [ExtensionAttribute]
public static bool TryGetResolver(IContainer container, Type type, Resolver`1& resolver);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(IContainer container);
    [ExtensionAttribute]
public static bool TryGetResolver(IContainer container, Resolver`1& resolver);
    [ExtensionAttribute]
public static Tag AsTag(object tagValue);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentNativeGetResolver : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(Container container);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(Container container, Tag tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(Container container, Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static Resolver`1<T> GetResolver(Container container, Type type, Tag tag);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentNativeResolve : object {
    internal static Object[] EmptyArgs;
    private static FluentNativeResolve();
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Tag tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Tag tag, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Type type, Tag tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Type type, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(Container container, Type type, Tag tag, Object[] args);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentResolve : object {
    private static Object[] EmptyArgs;
    private static FluentResolve();
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Tag tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Tag tag, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Type type);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Type type, Object[] args);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Type type, Tag tag);
    [ExtensionAttribute]
[NotNullAttribute]
public static T Resolve(IContainer container, Type type, Tag tag, Object[] args);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.FluentTrace : object {
    [ExtensionAttribute]
public static IObservable`1<TraceEvent> ToTraceSource(IContainer container);
    [ExtensionAttribute]
public static IToken Trace(IMutableContainer container, Action`1<TraceEvent> onTraceEvent);
    [ExtensionAttribute]
public static IToken Trace(IToken token, Action`1<TraceEvent> onTraceEvent);
    [ExtensionAttribute]
public static IToken Trace(IMutableContainer container);
    [ExtensionAttribute]
public static IToken Trace(IToken token);
    private static void Subscribe(IContainer container, IDictionary`2<IContainer, IDisposable> subscriptions, IObserver`1<TraceEvent> observer, IConverter`3<ContainerEvent, IContainer, string> converter);
}
[PublicAPIAttribute]
[AttributeUsageAttribute("1036")]
public class IoC.GenericTypeArgumentAttribute : Attribute {
}
internal static class IoC.GenericTypeArguments : object {
    internal static Type[] Arguments;
    private static GenericTypeArguments();
}
[AttributeUsageAttribute("2432")]
public class IoC.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("2432")]
public class IoC.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[PublicAPIAttribute]
public interface IoC.IAutowiringStrategy {
    public abstract virtual bool TryResolveType(IContainer container, Type registeredType, Type resolvingType, Type& instanceType);
    public abstract virtual bool TryResolveConstructor(IContainer container, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors, IMethod`1& constructor);
    public abstract virtual bool TryResolveInitializers(IContainer container, IEnumerable`1<IMethod`1<MethodInfo>> methods, IEnumerable`1& initializers);
}
[PublicAPIAttribute]
public interface IoC.IBinding {
    [NotNullAttribute]
public IMutableContainer Container { get; }
    [NotNullAttribute]
public IEnumerable`1<IToken> Tokens { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<Type> Types { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IEnumerable`1<object> Tags { get; }
    [CanBeNullAttribute]
public ILifetime Lifetime { get; }
    [CanBeNullAttribute]
public IAutowiringStrategy AutowiringStrategy { get; }
    public abstract virtual IMutableContainer get_Container();
    public abstract virtual IEnumerable`1<IToken> get_Tokens();
    public abstract virtual IEnumerable`1<Type> get_Types();
    public abstract virtual IEnumerable`1<object> get_Tags();
    public abstract virtual ILifetime get_Lifetime();
    public abstract virtual IAutowiringStrategy get_AutowiringStrategy();
}
[PublicAPIAttribute]
public interface IoC.IBinding`1 {
}
[PublicAPIAttribute]
public interface IoC.IBuildContext {
    [CanBeNullAttribute]
public IBuildContext Parent { get; }
    public Key Key { get; }
    [NotNullAttribute]
public IContainer Container { get; }
    public int Depth { get; }
    [NotNullAttribute]
public IEnumerable`1<ICompiler> Compilers { get; }
    [NotNullAttribute]
public IAutowiringStrategy AutowiringStrategy { get; }
    [NotNullAttribute]
public ParameterExpression ArgsParameter { get; }
    [NotNullAttribute]
public ParameterExpression ContainerParameter { get; }
    public abstract virtual IBuildContext get_Parent();
    public abstract virtual Key get_Key();
    public abstract virtual IContainer get_Container();
    public abstract virtual int get_Depth();
    public abstract virtual IEnumerable`1<ICompiler> get_Compilers();
    public abstract virtual IAutowiringStrategy get_AutowiringStrategy();
    public abstract virtual ParameterExpression get_ArgsParameter();
    public abstract virtual ParameterExpression get_ContainerParameter();
    [NotNullAttribute]
public abstract virtual IBuildContext CreateChild(Key key, IContainer container);
    [NotNullAttribute]
public abstract virtual Expression CreateExpression(Expression defaultExpression);
    [NotNullAttribute]
public abstract virtual Expression FinalizeExpression(Expression baseExpression, ILifetime lifetime);
    public abstract virtual void MapType(Type fromType, Type toType);
    public abstract virtual void AddParameter(ParameterExpression parameterExpression);
    public abstract virtual bool TryCompile(LambdaExpression lambdaExpression, Delegate& lambdaCompiled, Exception& error);
}
public interface IoC.IBuilder {
    [NotNullAttribute]
public abstract virtual Expression Build(IBuildContext context, Expression bodyExpression);
}
[PublicAPIAttribute]
public interface IoC.ICompiler {
    public abstract virtual bool TryCompile(IBuildContext context, LambdaExpression lambdaExpression, Delegate& lambdaCompiled, Exception& error);
}
[PublicAPIAttribute]
public interface IoC.IConfiguration {
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IToken> Apply(IMutableContainer container);
}
[PublicAPIAttribute]
public interface IoC.IContainer {
    [CanBeNullAttribute]
public IContainer Parent { get; }
    public abstract virtual IContainer get_Parent();
    public abstract virtual bool TryGetDependency(Key key, IDependency& dependency, ILifetime& lifetime);
    public abstract virtual bool TryGetResolver(Type type, object tag, Resolver`1& resolver, Exception& error, IContainer resolvingContainer);
}
[PublicAPIAttribute]
public interface IoC.IDependency {
    public abstract virtual bool TryBuildExpression(IBuildContext buildContext, ILifetime lifetime, Expression& expression, Exception& error);
}
[PublicAPIAttribute]
public interface IoC.ILifetime {
    public abstract virtual ILifetime CreateLifetime();
    [NotNullAttribute]
public abstract virtual IContainer SelectContainer(IContainer registrationContainer, IContainer resolvingContainer);
}
[PublicAPIAttribute]
public interface IoC.IMethod`1 {
    [NotNullAttribute]
public TMethodInfo Info { get; }
    public abstract virtual TMethodInfo get_Info();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<Expression> GetParametersExpressions(IBuildContext buildContext);
    public abstract virtual void SetExpression(int parameterPosition, Expression parameterExpression);
    public abstract virtual void SetDependency(int parameterPosition, Type dependencyType, object dependencyTag, bool isOptional, Object[] args);
}
[AttributeUsageAttribute("1037")]
public class IoC.ImplicitNotNullAttribute : Attribute {
}
[FlagsAttribute]
public enum IoC.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
public enum IoC.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[PublicAPIAttribute]
public interface IoC.IMutableContainer {
    public abstract virtual bool TryRegisterDependency(IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime, IToken& dependencyToken);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class IoC.Injections : object {
    private static string JustAMarkerError;
    [NotNullAttribute]
internal static MethodInfo InjectGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectValueGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo InjectWithTagGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectWithTagGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectValueWithTagGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo AssignGenericMethodInfo;
    [NotNullAttribute]
internal static MethodInfo InjectMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectMethodInfo;
    [NotNullAttribute]
internal static MethodInfo InjectWithTagMethodInfo;
    [NotNullAttribute]
internal static MethodInfo TryInjectWithTagMethodInfo;
    private static Injections();
    [ExtensionAttribute]
public static T Inject(IContainer container);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T TryInject(IContainer container);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Nullable`1<T> TryInjectValue(IContainer container);
    [ExtensionAttribute]
public static T Inject(IContainer container, object tag, Object[] args);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T TryInject(IContainer container, object tag, Object[] args);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Nullable`1<T> TryInjectValue(IContainer container, object tag, Object[] args);
    [ExtensionAttribute]
public static IContainer Assign(IContainer container, T destination, T source);
    [ExtensionAttribute]
public static object Inject(IContainer container, Type type);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static object TryInject(IContainer container, Type type);
    [ExtensionAttribute]
public static object Inject(IContainer container, Type type, object tag, Object[] args);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static object TryInject(IContainer container, Type type, object tag, Object[] args);
}
[AttributeUsageAttribute("2048")]
public class IoC.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.InvokerParameterNameAttribute : Attribute {
}
[PublicAPIAttribute]
public interface IoC.IResourceRegistry {
    public abstract virtual void RegisterResource(IDisposable resource);
    public abstract virtual bool UnregisterResource(IDisposable resource);
}
[PublicAPIAttribute]
public interface IoC.IScope {
    public IContainer Container { get; }
    public abstract virtual IContainer get_Container();
    public abstract virtual IDisposable Activate();
}
[PublicAPIAttribute]
public interface IoC.IScopeToken {
}
[PublicAPIAttribute]
public class IoC.Issues.DependencyDescription : ValueType {
    [NotNullAttribute]
public IDependency Dependency;
    [CanBeNullAttribute]
public ILifetime Lifetime;
    public DependencyDescription(IDependency dependency, ILifetime lifetime);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotBuildExpression {
    [NotNullAttribute]
public abstract virtual Expression Resolve(IBuildContext buildContext, IDependency dependency, ILifetime lifetime, Exception error);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotGetResolver {
    [NotNullAttribute]
public abstract virtual Resolver`1<T> Resolve(IContainer container, Key key, Exception error);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotParseLifetime {
    public abstract virtual Lifetime Resolve(string statementText, int statementLineNumber, int statementPosition, string lifetimeName);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotParseTag {
    [CanBeNullAttribute]
public abstract virtual object Resolve(string statementText, int statementLineNumber, int statementPosition, string tag);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotParseType {
    [NotNullAttribute]
public abstract virtual Type Resolve(string statementText, int statementLineNumber, int statementPosition, string typeName);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotRegister {
    [NotNullAttribute]
public abstract virtual IToken Resolve(IContainer container, IEnumerable`1<Key> keys, IDependency dependency, ILifetime lifetime);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotResolveConstructor {
    [NotNullAttribute]
public abstract virtual IMethod`1<ConstructorInfo> Resolve(IBuildContext buildContext, IEnumerable`1<IMethod`1<ConstructorInfo>> constructors);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotResolveDependency {
    public abstract virtual DependencyDescription Resolve(IBuildContext buildContext);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotResolveGenericTypeArgument {
    [NotNullAttribute]
public abstract virtual Type Resolve(IBuildContext buildContext, Type type, int genericTypeArgPosition, Type genericTypeArg);
}
[PublicAPIAttribute]
public interface IoC.Issues.ICannotResolveType {
    public abstract virtual Type Resolve(IBuildContext buildContext, Type registeredType, Type resolvingType);
}
[PublicAPIAttribute]
public interface IoC.Issues.IFoundCyclicDependency {
    public abstract virtual void Resolve(IBuildContext buildContext);
}
[AttributeUsageAttribute("6592")]
public class IoC.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
public class IoC.ItemNotNullAttribute : Attribute {
}
public interface IoC.IToken {
    public IMutableContainer Container { get; }
    public abstract virtual IMutableContainer get_Container();
}
[PublicAPIAttribute]
[DebuggerDisplayAttribute("{ToString()}")]
public class IoC.Key : ValueType {
    [NotNullAttribute]
public static object AnyTag;
    [NotNullAttribute]
public Type Type;
    [CanBeNullAttribute]
public object Tag;
    public Key(Type type, object tag);
    private static Key();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public bool Equals(Key other);
    [PureAttribute]
public virtual int GetHashCode();
}
[PublicAPIAttribute]
public enum IoC.Lifetime : Enum {
    public int value__;
    public static Lifetime Transient;
    public static Lifetime Singleton;
    public static Lifetime ContainerSingleton;
    public static Lifetime ScopeRoot;
    public static Lifetime Disposing;
}
[PublicAPIAttribute]
public class IoC.Lifetimes.ContainerSingletonLifetime : KeyBasedLifetime`1<IContainer> {
    protected virtual IContainer CreateKey(IContainer container, Object[] args);
    public virtual string ToString();
    public virtual ILifetime CreateLifetime();
    protected virtual object AfterCreation(object newInstance, IContainer targetContainer, IContainer container, Object[] args);
    protected virtual void OnRelease(object releasedInstance, IContainer targetContainer);
}
internal class IoC.Lifetimes.ContainerStateSingletonLifetime : KeyBasedLifetime`1<IContainer> {
    private bool _isDisposable;
    private IDisposable _containerSubscription;
    public ContainerStateSingletonLifetime(bool isDisposable);
    protected virtual IContainer CreateKey(IContainer container, Object[] args);
    public virtual string ToString();
    public virtual ILifetime CreateLifetime();
    protected virtual object AfterCreation(object newInstance, IContainer targetContainer, IContainer container, Object[] args);
    protected virtual void OnRelease(object releasedInstance, IContainer targetContainer);
    public virtual void Dispose();
}
[PublicAPIAttribute]
public class IoC.Lifetimes.DisposingLifetime : object {
    public sealed virtual ILifetime CreateLifetime();
    public sealed virtual IContainer SelectContainer(IContainer registrationContainer, IContainer resolvingContainer);
    public sealed virtual Expression Build(IBuildContext context, Expression bodyExpression);
    public sealed virtual void Dispose();
    internal T GetOrCreateInstance(Resolver`1<T> resolver, IContainer container, Object[] args);
}
[PublicAPIAttribute]
public abstract class IoC.Lifetimes.KeyBasedLifetime`1 : object {
    private Dictionary`2<TKey, object> _instances;
    public abstract virtual ILifetime CreateLifetime();
    public virtual IContainer SelectContainer(IContainer registrationContainer, IContainer resolvingContainer);
    public sealed virtual Expression Build(IBuildContext context, Expression bodyExpression);
    protected T GetOrCreateInstance(Resolver`1<T> resolver, IContainer container, Object[] args);
    public virtual void Dispose();
    protected abstract virtual TKey CreateKey(IContainer container, Object[] args);
    protected virtual object AfterCreation(object newInstance, TKey key, IContainer container, Object[] args);
    protected virtual void OnRelease(object releasedInstance, TKey key);
    protected internal bool Remove(TKey key);
}
[PublicAPIAttribute]
internal class IoC.Lifetimes.ScopeRootLifetime : object {
    private Func`1<IScope> _scopeFactory;
    public ScopeRootLifetime(Func`1<IScope> scopeFactory);
    public sealed virtual ILifetime CreateLifetime();
    public sealed virtual IContainer SelectContainer(IContainer registrationContainer, IContainer resolvingContainer);
    public sealed virtual Expression Build(IBuildContext context, Expression bodyExpression);
    internal T GetOrCreateInstance(Resolver`1<T> resolver, IContainer container, Object[] args);
    public sealed virtual void Dispose();
}
[PublicAPIAttribute]
public class IoC.Lifetimes.SingletonLifetime : object {
    private static FieldInfo InstanceFieldInfo;
    [CanBeNullAttribute]
private object _lockObject;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public SingletonLifetime(bool threadSafe);
    private static SingletonLifetime();
    public sealed virtual Expression Build(IBuildContext context, Expression expression);
    public sealed virtual IContainer SelectContainer(IContainer registrationContainer, IContainer resolvingContainer);
    public sealed virtual void Dispose();
    public sealed virtual ILifetime CreateLifetime();
    public virtual string ToString();
}
internal class IoC.Lifetimes.ThreadSingletonLifetime : KeyBasedLifetime`1<int> {
    [ThreadStaticAttribute]
private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadId;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _latsThreadId;
    public virtual ILifetime CreateLifetime();
    protected virtual int CreateKey(IContainer container, Object[] args);
}
[AttributeUsageAttribute("64")]
public class IoC.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class IoC.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("2112")]
public class IoC.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    public string Expression { get; public set; }
    public int Editable { get; public set; }
    public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("16388")]
public class IoC.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("64")]
public class IoC.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; private set; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
private void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
public class IoC.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class IoC.NoReorder : Attribute {
}
[AttributeUsageAttribute("64")]
public class IoC.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("24516")]
public class IoC.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[AttributeUsageAttribute("19916")]
public class IoC.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
public class IoC.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
public class IoC.PureAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class IoC.RazorDirectiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Directive>k__BackingField;
    [NotNullAttribute]
public string Directive { get; private set; }
    public RazorDirectiveAttribute(string directive);
    [CompilerGeneratedAttribute]
public string get_Directive();
    [CompilerGeneratedAttribute]
private void set_Directive(string value);
}
[AttributeUsageAttribute("64")]
public class IoC.RazorHelperCommonAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class IoC.RazorImportNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public RazorImportNamespaceAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("1")]
public class IoC.RazorInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [NotNullAttribute]
public string Type { get; private set; }
    [NotNullAttribute]
public string FieldName { get; private set; }
    public RazorInjectionAttribute(string type, string fieldName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
}
[AttributeUsageAttribute("128")]
public class IoC.RazorLayoutAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
public class IoC.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class IoC.RazorWriteLiteralMethodAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class IoC.RazorWriteMethodAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.RazorWriteMethodParameterAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class IoC.RegexPatternAttribute : Attribute {
}
[PublicAPIAttribute]
[NotNullAttribute]
public class IoC.Resolver`1 : MulticastDelegate {
    public Resolver`1(object object, IntPtr method);
    public virtual T Invoke(IContainer container, Object[] args);
    public virtual IAsyncResult BeginInvoke(IContainer container, Object[] args, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class IoC.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
public class IoC.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[PublicAPIAttribute]
public class IoC.Tag : ValueType {
    internal object Value;
    internal Tag(object value);
    public virtual string ToString();
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
public class IoC.TerminatesProgramAttribute : Attribute {
}
[PublicAPIAttribute]
public class IoC.TraceEvent : ValueType {
    public ContainerEvent ContainerEvent;
    [NotNullAttribute]
public string Message;
    internal TraceEvent(ContainerEvent containerEvent, string message);
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT1 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT10 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT11 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT12 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT13 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT14 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT15 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT16 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT17 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT18 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT19 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT2 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT20 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT21 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT22 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT23 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT24 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT25 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT26 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT27 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT28 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT29 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT3 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT30 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT31 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT32 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT4 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT5 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT6 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT7 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT8 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public abstract class IoC.TT9 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC1 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC10 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC11 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC12 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC13 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC14 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC15 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC16 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC17 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC18 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC19 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC2 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC20 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC21 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC22 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC23 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC24 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC25 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC26 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC27 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC28 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC29 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC3 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC30 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC31 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC32 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC4 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC5 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC6 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC7 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC8 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTC9 : object {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTCollection8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable3 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable4 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable5 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable6 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable7 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable8 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparable8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTComparer8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary1`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary2`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary3`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary4`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary5`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary6`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary7`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDictionary8`2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable3 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable4 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable5 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable6 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable7 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTDisposable8 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerable8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEnumerator8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEqualityComparer8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTEquatable8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI10 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI11 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI12 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI13 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI14 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI15 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI16 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI17 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI18 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI19 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI2 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI20 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI21 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI22 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI23 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI24 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI25 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI26 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI27 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI28 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI29 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI3 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI30 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI31 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI32 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI4 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI5 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI6 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI7 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI8 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTI9 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTList8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObservable8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTObserver8`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS1 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS10 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS11 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS12 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS13 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS14 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS15 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS16 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS17 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS18 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS19 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS2 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS20 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS21 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS22 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS23 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS24 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS25 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS26 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS27 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS28 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS29 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS3 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS30 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS31 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS32 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS4 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS5 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS6 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS7 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS8 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public class IoC.TTS9 : ValueType {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet1`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet2`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet3`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet4`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet5`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet6`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet7`1 {
}
[PublicAPIAttribute]
[GenericTypeArgumentAttribute]
public interface IoC.TTSet8`1 {
}
[AttributeUsageAttribute("32767")]
public class IoC.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2432")]
public class IoC.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("128")]
public class IoC.XamlItemBindingOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class IoC.XamlItemsControlAttribute : Attribute {
}
