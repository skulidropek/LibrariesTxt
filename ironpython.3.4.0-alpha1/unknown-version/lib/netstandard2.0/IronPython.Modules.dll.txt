public static class ComponentAce.Compression.Libs.ZLib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    public static long GetAdler32Checksum(long adler, Byte[] buf, int index, int len);
}
public enum ComponentAce.Compression.Libs.ZLib.BlockType : Enum {
    public int value__;
    public static BlockType Z_BINARY;
    public static BlockType Z_ASCII;
    public static BlockType Z_UNKNOWN;
}
public enum ComponentAce.Compression.Libs.ZLib.CompressionStrategy : Enum {
    public int value__;
    public static CompressionStrategy Z_FILTERED;
    public static CompressionStrategy Z_HUFFMAN_ONLY;
    public static CompressionStrategy Z_DEFAULT_STRATEGY;
}
public class ComponentAce.Compression.Libs.ZLib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    public static int Z_DEFAULT_COMPRESSION;
    public static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    [CompilerGeneratedAttribute]
private int <level>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pending>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Pending_buf>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pending_out>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NoHeader>k__BackingField;
    private ZStream strm;
    private DeflateState status;
    private int pending_buf_size;
    private BlockType data_type;
    private byte method;
    private int last_flush;
    private int w_size;
    private int w_bits;
    private int w_mask;
    private Byte[] window;
    private int window_size;
    private Int16[] prev;
    private Int16[] head;
    private int ins_h;
    private int hash_size;
    private int hash_bits;
    private int hash_mask;
    private int hash_shift;
    private int block_start;
    private int match_length;
    private int prev_match;
    private int match_available;
    private int strstart;
    private int match_start;
    private int lookahead;
    private int prev_length;
    private int max_chain_length;
    private int max_lazy_match;
    private CompressionStrategy strategy;
    private int good_match;
    private int nice_match;
    private Int16[] dyn_ltree;
    private Int16[] dyn_dtree;
    private Int16[] bl_tree;
    private Tree l_desc;
    private Tree d_desc;
    private Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    private int lit_bufsize;
    private int last_lit;
    private int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    private short bi_buf;
    private int bi_valid;
    public int level { get; public set; }
    public int Pending { get; public set; }
    public Byte[] Pending_buf { get; public set; }
    public int Pending_out { get; public set; }
    public int NoHeader { get; public set; }
    private static Deflate();
    [CompilerGeneratedAttribute]
public int get_level();
    [CompilerGeneratedAttribute]
public void set_level(int value);
    [CompilerGeneratedAttribute]
public int get_Pending();
    [CompilerGeneratedAttribute]
public void set_Pending(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Pending_buf();
    [CompilerGeneratedAttribute]
public void set_Pending_buf(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Pending_out();
    [CompilerGeneratedAttribute]
public void set_Pending_out(int value);
    [CompilerGeneratedAttribute]
public int get_NoHeader();
    [CompilerGeneratedAttribute]
public void set_NoHeader(int value);
    private void lm_init();
    private void tr_init();
    private void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    private void scan_tree(Int16[] tree, int max_code);
    private int build_bl_tree();
    private void send_all_trees(int lcodes, int dcodes, int blcodes);
    private void send_tree(Int16[] tree, int max_code);
    private void put_byte(Byte[] p, int start, int len);
    private void put_byte(byte c);
    private void put_short(int w);
    private void putShortMSB(int b);
    private void send_code(int c, Int16[] tree);
    private void send_bits(int value_Renamed, int length);
    private void _tr_align();
    private bool _tr_tally(int dist, int lc);
    private void compress_block(Int16[] ltree, Int16[] dtree);
    private void set_data_type();
    private void bi_flush();
    private void bi_windup();
    private void copy_block(int buf, int len, bool header);
    private void flush_block_only(bool eof);
    private int deflate_stored(int flush);
    private void _tr_stored_block(int buf, int stored_len, bool eof);
    private void _tr_flush_block(int buf, int stored_len, bool eof);
    private void fill_window();
    private int deflate_fast(int flush);
    private int deflate_slow(int flush);
    private int longest_match(int cur_match);
    internal int DeflateInit(ZStream strm, int level, int bits);
    internal int DeflateInit(ZStream strm, int level);
    internal int DeflateInit2(ZStream strm, int level, int windowBits, int memLevel, CompressionStrategy strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int level, CompressionStrategy strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, FlushStrategy f);
}
internal enum ComponentAce.Compression.Libs.ZLib.DeflateState : Enum {
    public int value__;
    public static DeflateState INIT_STATE;
    public static DeflateState BUSY_STATE;
    public static DeflateState FINISH_STATE;
}
public enum ComponentAce.Compression.Libs.ZLib.FlushStrategy : Enum {
    public int value__;
    public static FlushStrategy Z_NO_FLUSH;
    public static FlushStrategy Z_PARTIAL_FLUSH;
    public static FlushStrategy Z_SYNC_FLUSH;
    public static FlushStrategy Z_FULL_FLUSH;
    public static FlushStrategy Z_FINISH;
}
internal class ComponentAce.Compression.Libs.ZLib.GzipHeader : object {
    private static int FIXED_HEADER_SIZE;
    public static IEnumerator`1<object> CreateRemover(ZStream z);
    private byte GetNext(ZStream z);
    [IteratorStateMachineAttribute("ComponentAce.Compression.Libs.ZLib.GzipHeader/<StartHeaderSkipping>d__4")]
private IEnumerable`1<object> StartHeaderSkipping(ZStream z);
}
internal class ComponentAce.Compression.Libs.ZLib.InfBlocks : object {
    private static int MANY;
    private InflateBlockMode mode;
    private int left;
    private int table;
    private int index;
    private Int32[] blens;
    private Int32[] bb;
    private Int32[] tb;
    private InfCodes codes;
    private int last;
    private Int32[] hufts;
    internal bool needCheck;
    private long check;
    [CompilerGeneratedAttribute]
private Byte[] <Window>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadPos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WritePos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitK>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitB>k__BackingField;
    public Byte[] Window { get; public set; }
    public int End { get; public set; }
    public int ReadPos { get; public set; }
    public int WritePos { get; public set; }
    public int BitK { get; public set; }
    public int BitB { get; public set; }
    internal InfBlocks(ZStream z, bool needCheck, int w);
    [CompilerGeneratedAttribute]
public Byte[] get_Window();
    [CompilerGeneratedAttribute]
public void set_Window(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    [CompilerGeneratedAttribute]
public int get_ReadPos();
    [CompilerGeneratedAttribute]
public void set_ReadPos(int value);
    [CompilerGeneratedAttribute]
public int get_WritePos();
    [CompilerGeneratedAttribute]
public void set_WritePos(int value);
    [CompilerGeneratedAttribute]
public int get_BitK();
    [CompilerGeneratedAttribute]
public void set_BitK(int value);
    [CompilerGeneratedAttribute]
public int get_BitB();
    [CompilerGeneratedAttribute]
public void set_BitB(int value);
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class ComponentAce.Compression.Libs.ZLib.InfCodes : object {
    private InflateCodesMode mode;
    private int count;
    private Int32[] tree;
    internal int tree_index;
    internal int need;
    internal int lit;
    internal int get_Renamed;
    internal int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    internal InfCodes(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal InfCodes(int bl, int bd, Int32[] tl, Int32[] td, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class ComponentAce.Compression.Libs.ZLib.Inflate : object {
    public InflateMode mode;
    private int method;
    private Int64[] was;
    private long need;
    private int marker;
    private int nowrap;
    private int wbits;
    private IEnumerator`1<object> gzipHeaderRemover;
    private bool detectHeader;
    private InfBlocks blocks;
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int windowBits);
    internal int inflate(ZStream z, FlushStrategy flush);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal enum ComponentAce.Compression.Libs.ZLib.InflateBlockMode : Enum {
    public int value__;
    public static InflateBlockMode TYPE;
    public static InflateBlockMode LENS;
    public static InflateBlockMode STORED;
    public static InflateBlockMode TABLE;
    public static InflateBlockMode BTREE;
    public static InflateBlockMode DTREE;
    public static InflateBlockMode CODES;
    public static InflateBlockMode DRY;
    public static InflateBlockMode DONE;
    public static InflateBlockMode BAD;
}
internal enum ComponentAce.Compression.Libs.ZLib.InflateCodesMode : Enum {
    public int value__;
    public static InflateCodesMode START;
    public static InflateCodesMode LEN;
    public static InflateCodesMode LENEXT;
    public static InflateCodesMode DIST;
    public static InflateCodesMode DISTEXT;
    public static InflateCodesMode COPY;
    public static InflateCodesMode LIT;
    public static InflateCodesMode WASH;
    public static InflateCodesMode END;
    public static InflateCodesMode BADCODE;
}
internal enum ComponentAce.Compression.Libs.ZLib.InflateMode : Enum {
    public int value__;
    public static InflateMode METHOD;
    public static InflateMode FLAG;
    public static InflateMode DICT4;
    public static InflateMode DICT3;
    public static InflateMode DICT2;
    public static InflateMode DICT1;
    public static InflateMode DICT0;
    public static InflateMode BLOCKS;
    public static InflateMode CHECK4;
    public static InflateMode CHECK3;
    public static InflateMode CHECK2;
    public static InflateMode CHECK1;
    public static InflateMode DONE;
    public static InflateMode BAD;
}
internal class ComponentAce.Compression.Libs.ZLib.InfTree : object {
    private static int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal static int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal static int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
}
internal class ComponentAce.Compression.Libs.ZLib.InfTreeUtil : object {
    internal static int MANY;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal static int BMAX;
    private static InfTreeUtil();
}
internal class ComponentAce.Compression.Libs.ZLib.StaticTree : object {
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class ComponentAce.Compression.Libs.ZLib.Tree : object {
    private Int16[] dyn_tree;
    private int max_code;
    private StaticTree stat_desc;
    public Int16[] DynTree { get; public set; }
    public int MaxCode { get; public set; }
    internal StaticTree StatDesc { get; internal set; }
    public Int16[] get_DynTree();
    public void set_DynTree(Int16[] value);
    public int get_MaxCode();
    public void set_MaxCode(int value);
    internal StaticTree get_StatDesc();
    internal void set_StatDesc(StaticTree value);
    internal static int d_code(int dist);
    private void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    private static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    private static int bi_reverse(int code, int len);
}
public static class ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel : object {
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
}
public enum ComponentAce.Compression.Libs.ZLib.ZLibResultCode : Enum {
    public int value__;
    public static ZLibResultCode Z_OK;
    public static ZLibResultCode Z_STREAM_END;
    public static ZLibResultCode Z_NEED_DICT;
    public static ZLibResultCode Z_ERRNO;
    public static ZLibResultCode Z_STREAM_ERROR;
    public static ZLibResultCode Z_DATA_ERROR;
    public static ZLibResultCode Z_MEM_ERROR;
    public static ZLibResultCode Z_BUF_ERROR;
    public static ZLibResultCode Z_VERSION_ERROR;
}
public static class ComponentAce.Compression.Libs.ZLib.ZLibUtil : object {
    public static int MAX_WBITS;
    internal static Byte[] mark;
    internal static int PRESET_DICT;
    internal static int zLibBufSize;
    internal static String[] z_errmsg;
    internal static Int32[] inflate_mask;
    internal static Int32[] border;
    internal static int Z_DEFLATED;
    internal static int BL_CODES;
    internal static int D_CODES;
    internal static int LITERALS;
    internal static int LENGTH_CODES;
    internal static int L_CODES;
    internal static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    private static ZLibUtil();
    internal static long Identity(long literal);
    internal static ulong Identity(ulong literal);
    internal static float Identity(float literal);
    internal static double Identity(double literal);
    internal static int URShift(int number, int bits);
    internal static int URShift(int number, long bits);
    internal static long URShift(long number, int bits);
    internal static long URShift(long number, long bits);
    internal static int ReadInput(Stream sourceStream, Byte[] target, int start, int count);
    internal static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
    internal static Byte[] ToByteArray(string sourceString);
    internal static Char[] ToCharArray(Byte[] byteArray);
}
public class ComponentAce.Compression.Libs.ZLib.ZStream : object {
    private static int DEF_WBITS;
    private Byte[] _next_in;
    private int _next_in_index;
    private int _avail_in;
    private long _total_in;
    private Byte[] _next_out;
    private int _next_out_index;
    private int _avail_out;
    private long _total_out;
    private string _msg;
    private Deflate _dstate;
    private Inflate _istate;
    [CompilerGeneratedAttribute]
private long <adler>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockType <Data_type>k__BackingField;
    public long adler { get; public set; }
    public BlockType Data_type { get; public set; }
    public Byte[] next_in { get; public set; }
    public int next_in_index { get; public set; }
    public int avail_in { get; public set; }
    public long total_in { get; public set; }
    public Byte[] next_out { get; public set; }
    public int next_out_index { get; public set; }
    public int avail_out { get; public set; }
    public long total_out { get; public set; }
    public string msg { get; public set; }
    internal Deflate dstate { get; internal set; }
    internal Inflate istate { get; internal set; }
    public bool IsInitialized { get; }
    [CompilerGeneratedAttribute]
public long get_adler();
    [CompilerGeneratedAttribute]
public void set_adler(long value);
    [CompilerGeneratedAttribute]
public BlockType get_Data_type();
    [CompilerGeneratedAttribute]
public void set_Data_type(BlockType value);
    public Byte[] get_next_in();
    public void set_next_in(Byte[] value);
    public int get_next_in_index();
    public void set_next_in_index(int value);
    public int get_avail_in();
    public void set_avail_in(int value);
    public long get_total_in();
    public void set_total_in(long value);
    public Byte[] get_next_out();
    public void set_next_out(Byte[] value);
    public int get_next_out_index();
    public void set_next_out_index(int value);
    public int get_avail_out();
    public void set_avail_out(int value);
    public long get_total_out();
    public void set_total_out(long value);
    public string get_msg();
    public void set_msg(string value);
    internal Deflate get_dstate();
    internal void set_dstate(Deflate value);
    internal Inflate get_istate();
    internal void set_istate(Inflate value);
    public bool get_IsInitialized();
    public int inflateInit();
    public int inflateInit(int windowBits);
    public int inflate(FlushStrategy flush);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int DeflateInit(int level);
    public int DeflateInit(int level, int bits);
    public int DeflateInit(int level, int windowBits, int memLevel, CompressionStrategy strategy);
    public int reset();
    public int deflate(FlushStrategy flush);
    public int deflateEnd();
    public int deflateParams(int level, CompressionStrategy strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    public void FlushPending();
    public int ReadBuf(Byte[] buf, int start, int size);
    public void free();
}
public class ComponentAce.Compression.Libs.ZLib.ZStreamException : IOException {
    public ZStreamException(string s);
}
internal class Ionic.BZip2.BitWriter : object {
    private UInt32 accumulator;
    private int nAccumulatedBits;
    private Stream output;
    private int totalBytesWrittenOut;
    public byte RemainingBits { get; }
    public int NumRemainingBits { get; }
    public int TotalBytesWrittenOut { get; }
    public BitWriter(Stream s);
    public byte get_RemainingBits();
    public int get_NumRemainingBits();
    public int get_TotalBytesWrittenOut();
    public void Reset();
    public void WriteBits(int nbits, UInt32 value);
    public void WriteByte(byte b);
    public void WriteInt(UInt32 u);
    public void Flush();
    public void FinishAndPad();
}
internal static class Ionic.BZip2.BZip2 : object {
    public static int BlockSizeMultiple;
    public static int MinBlockSize;
    public static int MaxBlockSize;
    public static int MaxAlphaSize;
    public static int MaxCodeLength;
    public static char RUNA;
    public static char RUNB;
    public static int NGroups;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MaxSelectors;
    public static int NUM_OVERSHOOT_BYTES;
    internal static int QSORT_STACK_SIZE;
    private static BZip2();
    internal static T[][] InitRectangularArray(int d1, int d2);
}
internal class Ionic.BZip2.BZip2Compressor : object {
    private int blockSize100k;
    private int currentByte;
    private int runLength;
    private int last;
    private int outBlockFillThreshold;
    private CompressionState cstate;
    private CRC32 crc;
    private BitWriter bw;
    private int runs;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private bool blockRandomised;
    private int origPtr;
    private int nInUse;
    private int nMTF;
    private static int SETMASK;
    private static int CLEARMASK;
    private static byte GREATER_ICOST;
    private static byte LESSER_ICOST;
    private static int SMALL_THRESH;
    private static int DEPTH_THRESH;
    private static int WORK_FACTOR;
    private static Int32[] increments;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AvailableBytesOut>k__BackingField;
    public int BlockSize { get; }
    public UInt32 Crc32 { get; private set; }
    public int AvailableBytesOut { get; private set; }
    public int UncompressedBytes { get; }
    public BZip2Compressor(BitWriter writer);
    public BZip2Compressor(BitWriter writer, int blockSize);
    private static BZip2Compressor();
    private void Reset();
    public int get_BlockSize();
    [CompilerGeneratedAttribute]
public UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_AvailableBytesOut();
    [CompilerGeneratedAttribute]
private void set_AvailableBytesOut(int value);
    public int get_UncompressedBytes();
    public int Fill(Byte[] buffer, int offset, int count);
    private int write0(byte b);
    private bool AddRunToOutputBlock(bool final);
    public void CompressAndWrite();
    private void randomiseBlock();
    private void mainSort();
    private void blockSort();
    private bool mainSimpleSort(CompressionState dataShadow, int lo, int hi, int d);
    private static void vswap(Int32[] fmap, int p1, int p2, int n);
    private static byte med3(byte a, byte b, byte c);
    private void mainQSort3(CompressionState dataShadow, int loSt, int hiSt, int dSt);
    private void generateMTFValues();
    private static void hbAssignCodes(Int32[] code, Byte[] length, int minLen, int maxLen, int alphaSize);
    private void sendMTFValues();
    private void sendMTFValues0(int nGroups, int alphaSize);
    private static void hbMakeCodeLengths(Byte[] len, Int32[] freq, CompressionState state1, int alphaSize, int maxLen);
    private int sendMTFValues1(int nGroups, int alphaSize);
    private void sendMTFValues2(int nGroups, int nSelectors);
    private void sendMTFValues3(int nGroups, int alphaSize);
    private void sendMTFValues4();
    private void sendMTFValues5(int nGroups, int nSelectors);
    private void sendMTFValues6(int nGroups, int alphaSize);
    private void sendMTFValues7(int nSelectors);
    private void moveToFrontCodeAndSend();
}
public class Ionic.BZip2.BZip2InputStream : Stream {
    private bool _disposed;
    private bool _leaveOpen;
    private long totalBytesRead;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC32 crc;
    private int nInUse;
    private Stream input;
    private int currentChar;
    private CState currentState;
    private UInt32 storedBlockCRC;
    private UInt32 storedCombinedCRC;
    private UInt32 computedBlockCRC;
    private UInt32 computedCombinedCRC;
    private int su_count;
    private int su_ch2;
    private int su_chPrev;
    private int su_i2;
    private int su_j2;
    private int su_rNToGo;
    private int su_rTPos;
    private int su_tPos;
    private char su_z;
    private DecompressionState data;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2InputStream(Stream input);
    public BZip2InputStream(Stream input, bool leaveOpen);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void MakeMaps();
    public virtual int ReadByte();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void init();
    private void CheckMagicChar(char expected, int position);
    private void InitBlock();
    private void EndBlock();
    private void complete();
    public virtual void Close();
    private int GetBits(int n);
    private bool bsGetBit();
    private char bsGetUByte();
    private UInt32 bsGetInt();
    private static void hbCreateDecodeTables(Int32[] limit, Int32[] bbase, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
    private void recvDecodingTables();
    private void createHuffmanDecodingTables(int alphaSize, int nGroups);
    private void getAndMoveToFrontDecode();
    private int getAndMoveToFrontDecode0(int groupNo);
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    internal object DumpState();
    internal void RestoreState(object o);
}
public class Ionic.BZip2.BZip2OutputStream : Stream {
    private int totalBytesWrittenIn;
    private bool leaveOpen;
    private BZip2Compressor compressor;
    private UInt32 combinedCRC;
    private Stream output;
    private BitWriter bw;
    private int blockSize100k;
    private TraceBits desiredTrace;
    public int BlockSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2OutputStream(Stream output);
    public BZip2OutputStream(Stream output, int blockSize);
    public BZip2OutputStream(Stream output, bool leaveOpen);
    public BZip2OutputStream(Stream output, int blockSize, bool leaveOpen);
    public virtual void Close();
    public virtual void Flush();
    private void EmitHeader();
    private void EmitTrailer();
    private void Finish();
    public int get_BlockSize();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
}
public class Ionic.BZip2.ParallelBZip2OutputStream : Stream {
    private static int BufferPairsPerCore;
    private int _maxWorkers;
    private bool firstWriteDone;
    private int lastFilled;
    private int lastWritten;
    private int latestCompressed;
    private int currentlyFilling;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) pendingException;
    private bool handlingException;
    private bool emitting;
    private Queue`1<int> toWrite;
    private Queue`1<int> toFill;
    private List`1<WorkItem> pool;
    private object latestLock;
    private object eLock;
    private object outputLock;
    private AutoResetEvent newlyCompressedBlob;
    private long totalBytesWrittenIn;
    private long totalBytesWrittenOut;
    private bool leaveOpen;
    private UInt32 combinedCRC;
    private Stream output;
    private BitWriter bw;
    private int blockSize100k;
    private TraceBits desiredTrace;
    public int MaxWorkers { get; public set; }
    public int BlockSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long BytesWrittenOut { get; }
    public ParallelBZip2OutputStream(Stream output);
    public ParallelBZip2OutputStream(Stream output, int blockSize);
    public ParallelBZip2OutputStream(Stream output, bool leaveOpen);
    public ParallelBZip2OutputStream(Stream output, int blockSize, bool leaveOpen);
    private static ParallelBZip2OutputStream();
    private void InitializePoolOfWorkItems();
    public int get_MaxWorkers();
    public void set_MaxWorkers(int value);
    public virtual void Close();
    private void FlushOutput(bool lastInput);
    public virtual void Flush();
    private void EmitHeader();
    private void EmitTrailer();
    public int get_BlockSize();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void EmitPendingBuffers(bool doAll, bool mustWait);
    private void CompressOne(object wi);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_BytesWrittenOut();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
}
internal static class Ionic.BZip2.Rand : object {
    private static Int32[] RNUMS;
    private static Rand();
    internal static int Rnums(int i);
}
internal class Ionic.BZip2.WorkItem : object {
    public int index;
    [CompilerGeneratedAttribute]
private BZip2Compressor <Compressor>k__BackingField;
    public MemoryStream ms;
    public int ordinal;
    public BitWriter bw;
    public BZip2Compressor Compressor { get; private set; }
    public WorkItem(int ix, int blockSize);
    [CompilerGeneratedAttribute]
public BZip2Compressor get_Compressor();
    [CompilerGeneratedAttribute]
private void set_Compressor(BZip2Compressor value);
}
public class Ionic.Crc.CRC32 : object {
    private UInt32 dwPolynomial;
    private long _TotalBytesRead;
    private bool reverseBits;
    private UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _register;
    public long TotalBytesRead { get; }
    public int Crc32Result { get; }
    public CRC32(bool reverseBits);
    public CRC32(int polynomial, bool reverseBits);
    public long get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
    public void UpdateCRC(byte b);
    public void UpdateCRC(byte b, int n);
    private static UInt32 ReverseBits(UInt32 data);
    private static byte ReverseBits(byte data);
    private void GenerateLookupTable();
    private UInt32 gf2_matrix_times(UInt32[] matrix, UInt32 vec);
    private void gf2_matrix_square(UInt32[] square, UInt32[] mat);
    public void Combine(int crc, int length);
    public void Reset();
}
public class Ionic.Crc.CrcCalculatorStream : Stream {
    private static long UnsetLengthLimit;
    internal Stream _innerStream;
    private CRC32 _Crc32;
    private long _lengthLimit;
    private bool _leaveOpen;
    public long TotalBytesSlurped { get; }
    public int Crc { get; }
    public bool LeaveOpen { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32);
    private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32);
    private static CrcCalculatorStream();
    public long get_TotalBytesSlurped();
    public int get_Crc();
    public bool get_LeaveOpen();
    public void set_LeaveOpen(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
}
public static class IronPython.Modules._sysconfigdata : object {
    public static PythonDictionary build_time_vars;
    private static _sysconfigdata();
}
internal class IronPython.Modules.Arg : LocalOrArg {
    private int _index;
    private Type _type;
    public Type Type { get; }
    public Arg(int index, Type type);
    public virtual void Emit(ILGenerator ilgen);
    public virtual Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class IronPython.Modules.ArrayModule : object {
    public static string __doc__;
    public static PythonType ArrayType;
    public static string typecodes;
    public static BuiltinFunction _array_reconstructor;
    private static ArrayModule();
    private static array ArrayReconstructor(CodeContext context, PythonType cls, string typecode, int mformat_code, Bytes items);
    [CompilerGeneratedAttribute]
internal static string <ArrayReconstructor>g__MachineFormatToTypeCode|3_0(int machineFormat, Boolean& isBigEndian, String& encoding);
}
internal class IronPython.Modules.Asn1Object : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NID>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <OID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OIDString>k__BackingField;
    public string ShortName { get; public set; }
    public string LongName { get; public set; }
    public int NID { get; public set; }
    public Byte[] OID { get; public set; }
    public string OIDString { get; }
    public Asn1Object(string shortName, string longName, int nid, Byte[] oid);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
public void set_LongName(string value);
    [CompilerGeneratedAttribute]
public int get_NID();
    [CompilerGeneratedAttribute]
public void set_NID(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_OID();
    [CompilerGeneratedAttribute]
public void set_OID(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_OIDString();
    public PythonTuple ToTuple();
}
public static class IronPython.Modules.Bz2.Bz2Module : object {
    internal static int DEFAULT_COMPRESSLEVEL;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class IronPython.Modules.CharmapEncoding : Encoding {
    private IDictionary`2<object, object> _map;
    private int _maxEncodingReplacementLength;
    private int _maxDecodingReplacementLength;
    public string EncodingName { get; }
    public CharmapEncoding(IDictionary`2<object, object> map);
    public virtual string get_EncodingName();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    private static int ProcessEncodingReplacementValue(object replacement, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class IronPython.Modules.ComplexMath : object {
    public static double pi;
    public static double e;
    public static string __doc__;
    public static Complex cos(object x);
    public static Complex sin(object x);
    public static Complex tan(object x);
    public static Complex cosh(object x);
    public static Complex sinh(object x);
    public static Complex tanh(object x);
    public static Complex acos(object x);
    public static Complex asin(object x);
    public static Complex atan(object x);
    public static Complex acosh(object x);
    public static Complex asinh(object x);
    public static Complex atanh(object x);
    public static Complex log(object x);
    public static Complex log(object x, object logBase);
    public static Complex log10(object x);
    public static Complex exp(object x);
    public static Complex sqrt(object x);
    public static double phase(object x);
    public static PythonTuple polar(object x);
    public static Complex rect(double r, double theta);
    public static bool isinf(object x);
    public static bool isnan(object x);
    public static bool isfinite(object x);
    private static bool IsInfinity(Complex num);
    private static bool IsNaN(Complex num);
    private static bool IsFinite(Complex num);
    private static double GetAngle(Complex num);
    private static Complex GetComplexNum(object num);
}
public static class IronPython.Modules.CTypes : object {
    private static WeakDictionary`2<PythonType, Dictionary`2<int, ArrayType>> _arrayTypes;
    public static PythonType _SimpleCData;
    public static PythonType CFuncPtr;
    public static PythonType Structure;
    public static PythonType Union;
    public static PythonType _Pointer;
    public static PythonType Array;
    private static object _lock;
    private static object _pointerTypeCacheKey;
    private static object _conversion_mode;
    private static Dictionary`2<object, RefCountInfo> _refCountTable;
    private static ModuleBuilder _dynamicModule;
    private static Dictionary`2<int, Type> _nativeTypes;
    private static StringAtDelegate _stringAt;
    private static StringAtDelegate _wstringAt;
    private static CastDelegate _cast;
    public static string __version__;
    public static int FUNCFLAG_STDCALL;
    public static int FUNCFLAG_CDECL;
    public static int FUNCFLAG_HRESULT;
    public static int FUNCFLAG_PYTHONAPI;
    public static int FUNCFLAG_USE_ERRNO;
    public static int FUNCFLAG_USE_LASTERROR;
    public static int RTLD_GLOBAL;
    public static int RTLD_LOCAL;
    public static object _cast_addr { get; }
    public static object _memmove_addr { get; }
    public static object _memset_addr { get; }
    public static object _string_at_addr { get; }
    public static object _wstring_at_addr { get; }
    private static ModuleBuilder DynamicModule { get; }
    private static CTypes();
    private static ArrayType MakeArrayType(PythonType type, int count);
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static object get__cast_addr();
    private static IntPtr Cast(IntPtr data, IntPtr obj, IntPtr type);
    private static bool IsPointer(PythonType pt);
    public static object get__memmove_addr();
    public static object get__memset_addr();
    public static object get__string_at_addr();
    public static object get__wstring_at_addr();
    public static int CopyComPointer(object src, object dest);
    public static string FormatError();
    public static string FormatError(int errorCode);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void FreeLibrary(int handle);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void FreeLibrary(BigInteger handle);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void FreeLibrary(IntPtr handle);
    [NullableContextAttribute("1")]
private static object LoadDLL(string library, int mode);
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static object LoadLibrary(string library, int mode);
    [NullableContextAttribute("1")]
[PythonHiddenAttribute("0")]
public static object dlopen(string library, int mode);
    public static PythonType POINTER(CodeContext context, PythonType type);
    private static PointerType MakePointer(CodeContext context, string name, PythonDictionary dict);
    public static PythonType POINTER(CodeContext context, string name);
    public static object PyObj_FromPtr(IntPtr address);
    public static IntPtr PyObj_ToPtr(object obj);
    public static void Py_DECREF(object key);
    public static void Py_INCREF(object key);
    public static PythonTuple _buffer_info(CData data);
    public static void _check_HRESULT(int hresult);
    public static void _unpickle();
    public static object addressof(CData data);
    public static int alignment(PythonType type);
    public static int alignment(object o);
    public static object byref(CData instance, int offset);
    public static object call_cdeclfunction(CodeContext context, int address, PythonTuple args);
    public static object call_cdeclfunction(CodeContext context, BigInteger address, PythonTuple args);
    public static object call_cdeclfunction(CodeContext context, IntPtr address, PythonTuple args);
    public static void call_commethod();
    public static object call_function(CodeContext context, int address, PythonTuple args);
    public static object call_function(CodeContext context, BigInteger address, PythonTuple args);
    public static object call_function(CodeContext context, IntPtr address, PythonTuple args);
    private static CFuncPtrType GetFunctionType(CodeContext context, int flags);
    public static int get_errno();
    public static int get_last_error();
    public static Pointer pointer(CodeContext context, CData data);
    public static void resize(CData obj, int newSize);
    public static PythonTuple set_conversion_mode(CodeContext context, string encoding, string errors);
    public static void set_errno();
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int set_last_error(int errorCode);
    public static int sizeof(PythonType type);
    public static int sizeof(object instance);
    private static ModuleBuilder get_DynamicModule();
    private static Type GetMarshalTypeFromSize(int size);
    private static void GetFieldInfo(INativeType type, object o, String& fieldName, INativeType& cdata, Nullable`1& bitCount);
    private static int CheckBits(INativeType cdata, PythonTuple pt);
    private static IList`1<object> GetFieldsList(object fields);
    private static Exception StructureCannotContainSelf();
    private static IntPtr StringAt(IntPtr src, int len);
    private static IntPtr WStringAt(IntPtr src, int len);
    private static IntPtr GetHandleFromObject(object dll, string errorMsg);
    private static void ValidateArraySizes(array array, int offset, int size);
    private static void ValidateArraySizes(Bytes bytes, int offset, int size);
    private static void ValidateArraySizes(string data, int offset, int size);
    private static void ValidateArraySizes(int arraySize, int offset, int size);
    private static void ValidateArraySizes(BigInteger arraySize, int offset, int size);
    public static object GetCharArrayValue(_Array arr);
    public static void SetCharArrayValue(_Array arr, object value);
    public static void DeleteCharArrayValue(_Array arr, object value);
    public static object GetWCharArrayValue(_Array arr);
    public static void SetWCharArrayValue(_Array arr, object value);
    public static object DeleteWCharArrayValue(_Array arr);
    public static object GetWCharArrayRaw(_Array arr);
    public static void SetWCharArrayRaw(_Array arr, object value);
    public static object DeleteWCharArrayRaw(_Array arr);
    private static void EmitCDataCreation(INativeType type, ILGenerator method, List`1<object> constantPool, int constantPoolArgument);
    private static void EnsureRefCountTable();
}
[ExtensionAttribute]
internal static class IronPython.Modules.CTypesExtensionMethods : object {
    [ExtensionAttribute]
public static IntPtr Add(IntPtr self, int offset);
}
public static class IronPython.Modules.CTypesTest : object {
    public static string __file__;
    private static CTypesTest();
    private static string FindRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class IronPython.Modules.EncodingMap : object {
    private string _smap;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private Dictionary`2<byte, int> _dmap;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private Dictionary`2<int, byte> _emap;
    internal EncodingMap(string stringMap, bool compileForDecoding, bool compileForEncoding);
    private void CompileEncodingMap();
    private void CompileDecodingMap();
    public bool TryGetCharValue(byte b, Int32& val);
    public bool TryGetByteValue(int c, Byte& val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class IronPython.Modules.EncodingMapEncoding : Encoding {
    private EncodingMap _map;
    public string EncodingName { get; }
    public EncodingMapEncoding(EncodingMap map);
    public virtual string get_EncodingName();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class IronPython.Modules.FunctionTools : object {
    public static string __doc__;
    [NullableContextAttribute("2")]
public static object reduce(CodeContext context, SiteLocalStorage`1<CallSite`1<Func`6<CallSite, CodeContext, object, object, object, object>>> siteData, object func, object seq);
    [NullableContextAttribute("2")]
public static object reduce(CodeContext context, SiteLocalStorage`1<CallSite`1<Func`6<CallSite, CodeContext, object, object, object, object>>> siteData, object func, object seq, object initializer);
    private static void EnsureReduceData(CodeContext context, SiteLocalStorage`1<CallSite`1<Func`6<CallSite, CodeContext, object, object, object, object>>> siteData);
}
[PythonTypeAttribute("method-wrapper")]
public class IronPython.Modules.GenericMethodWrapper : object {
    private string name;
    private IProxyObject target;
    public GenericMethodWrapper(string methodName, IProxyObject proxyTarget);
    public object Call(CodeContext context, Object[] args);
    public object Call(CodeContext context, IDictionary`2<object, object> dict, Object[] args);
}
[PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class IronPython.Modules.HashBase`1 : object {
    protected T _hasher;
    private static MethodInfo _memberwiseClone;
    private static Byte[] _empty;
    public string name;
    public int block_size;
    public int digest_size;
    internal HashBase`1(string name, int blocksize, int digestsize);
    private static HashBase`1();
    protected abstract virtual void CreateHasher();
    [DocumentationAttribute("update(string) -> None (update digest with string data)")]
public void update(IBufferProtocol data);
    public void update(string data);
    [DocumentationAttribute("digest() -> int (current digest value)")]
public Bytes digest();
    [DocumentationAttribute("hexdigest() -> string (current digest as hex digits)")]
public string hexdigest();
    public abstract virtual HashBase`1<T> copy();
    private sealed virtual override object System.ICloneable.Clone();
    protected T CloneHasher();
}
internal class IronPython.Modules.Local : LocalOrArg {
    private LocalBuilder _local;
    public Type Type { get; }
    public Local(LocalBuilder local);
    public virtual void Emit(ILGenerator ilgen);
    public virtual Type get_Type();
}
internal abstract class IronPython.Modules.LocalOrArg : object {
    public Type Type { get; }
    public abstract virtual void Emit(ILGenerator ilgen);
    public abstract virtual Type get_Type();
}
internal abstract class IronPython.Modules.MarshalCleanup : object {
    public abstract virtual void Cleanup(ILGenerator generator);
}
internal class IronPython.Modules.MemoryHolder : CriticalFinalizerObject {
    private IntPtr _data;
    private bool _ownsData;
    private int _size;
    private PythonDictionary _objects;
    private MemoryHolder _parent;
    public IntPtr UnsafeAddress { get; }
    public int Size { get; }
    public PythonDictionary Objects { get; public set; }
    [ReliabilityContractAttribute("3", "1")]
public MemoryHolder(int size);
    public MemoryHolder(IntPtr data, int size);
    public MemoryHolder(IntPtr data, int size, MemoryHolder parent);
    public IntPtr get_UnsafeAddress();
    public int get_Size();
    public PythonDictionary get_Objects();
    public void set_Objects(PythonDictionary value);
    internal PythonDictionary EnsureObjects();
    internal void AddObject(object key, object value);
    private short Swap(short val);
    private int Swap(int val);
    private long Swap(long val);
    public byte ReadByte(int offset);
    public short ReadInt16(int offset, bool swap);
    public int ReadInt32(int offset, bool swap);
    public long ReadInt64(int offset, bool swap);
    public IntPtr ReadIntPtr(int offset);
    public MemoryHolder ReadMemoryHolder(int offset);
    internal Bytes ReadBytes(int offset);
    internal string ReadUnicodeString(int offset);
    internal Bytes ReadBytes(int offset, int length);
    internal static Bytes ReadBytes(IntPtr addr, int offset, int length);
    internal static Bytes ReadBytes(IntPtr addr, int offset);
    internal string ReadUnicodeString(int offset, int length);
    public void WriteByte(int offset, byte value);
    public void WriteInt16(int offset, short value, bool swap);
    public void WriteInt32(int offset, int value, bool swap);
    public void WriteInt64(int offset, long value, bool swap);
    public void WriteIntPtr(int offset, IntPtr value);
    public void WriteIntPtr(int offset, MemoryHolder address);
    public void CopyFrom(IntPtr source, IntPtr size);
    internal void WriteUnicodeString(int offset, string value);
    internal void WriteAnsiString(int offset, string value);
    public MemoryHolder GetSubBlock(int offset);
    public void CopyTo(MemoryHolder destAddress, int writeOffset, int size);
    [ReliabilityContractAttribute("3", "2")]
protected virtual override void Finalize();
}
public static class IronPython.Modules.MmapModule : object {
    public static int ACCESS_READ;
    public static int ACCESS_WRITE;
    public static int ACCESS_COPY;
    private static int SEEK_SET;
    private static int SEEK_CUR;
    private static int SEEK_END;
    [PythonHiddenAttribute("0")]
public static int MAP_SHARED;
    [PythonHiddenAttribute("0")]
public static int MAP_PRIVATE;
    [PythonHiddenAttribute("0")]
public static int PROT_NONE;
    [PythonHiddenAttribute("0")]
public static int PROT_READ;
    [PythonHiddenAttribute("0")]
public static int PROT_WRITE;
    [PythonHiddenAttribute("0")]
public static int PROT_EXEC;
    public static int ALLOCATIONGRANULARITY;
    public static int PAGESIZE;
    public static string __doc__;
    public static PythonType error { get; }
    public static PythonType mmap { get; }
    private static MmapModule();
    private static string FormatError(int errorCode);
    private static Exception WindowsError(int code);
    public static PythonType get_error();
    public static PythonType get_mmap();
    private static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    private static int GetAllocationGranularity();
    private static int GetAllocationGranularityWorker();
    private static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen);
}
public static class IronPython.Modules.ModuleOps : object {
    private static Byte[] FakeZeroLength;
    private static ModuleOps();
    public static IntPtr StringToHGlobalAnsi(string str);
    public static IntPtr StringToHGlobalUni(string str);
    public static object DoErrorCheck(object errCheckFunc, object result, object func, Object[] arguments);
    public static object CreateMemoryHolder(IntPtr data, int size);
    public static object CreateNativeWrapper(PythonType type, object holder);
    public static object CreateCData(IntPtr dataAddress, PythonType type);
    public static object CreateCFunction(IntPtr address, PythonType type);
    public static CData CheckSimpleCDataType(object o, object type);
    public static CData CheckCDataType(object o, object type);
    public static IntPtr GetFunctionPointerValue(object o, object type);
    public static CData TryCheckCDataPointerType(object o, object type);
    public static _Array TryCheckCharArray(object o);
    public static Byte[] TryCheckBytes(object o);
    public static Byte[] GetBytes(Bytes bytes);
    public static _Array TryCheckWCharArray(object o);
    public static object CreateSubclassInstance(object type, object instance);
    public static void CallbackException(Exception e, CodeContext context);
    private static Exception ArgumentError(object type, string expected, object got);
    public static CData CheckNativeArgument(object o, object type);
    public static string CharToString(byte c);
    public static string WCharToString(char c);
    public static char StringToChar(string s);
    public static string EnsureString(object o);
    public static bool CheckFunctionId(_CFuncPtr func, int id);
    public static IntPtr GetWCharPointer(object value);
    public static IntPtr GetBSTR(object value);
    public static IntPtr GetCharPointer(object value);
    public static IntPtr GetPointer(object value);
    public static IntPtr GetInterfacePointer(IntPtr self, int offset);
    public static IntPtr GetObject(object value);
    public static long GetSignedLongLong(object value, object type);
    public static long GetUnsignedLongLong(object value, object type);
    public static double GetDouble(object value, object type);
    public static float GetSingle(object value, object type);
    public static long GetDoubleBits(object value);
    public static int GetSingleBits(object value);
    public static int GetSignedLong(object value, object type);
    public static int GetUnsignedLong(object value, object type);
    public static int GetUnsignedInt(object value, object type);
    public static int GetSignedInt(object value, object type);
    public static short GetUnsignedShort(object value, object type);
    public static short GetSignedShort(object value, object type);
    public static int GetVariantBool(object value, object type);
    public static byte GetUnsignedByte(object value, object type);
    public static byte GetSignedByte(object value, object type);
    public static byte GetBoolean(object value, object type);
    public static byte GetChar(object value, object type);
    public static char GetWChar(object value, object type);
    public static object IntPtrToObject(IntPtr address);
}
public static class IronPython.Modules.MultiProcessing : object {
    [CompilerGeneratedAttribute]
private static object <flags>k__BackingField;
    public static object flags { get; public set; }
    private static MultiProcessing();
    [CompilerGeneratedAttribute]
public static object get_flags();
    [CompilerGeneratedAttribute]
public static void set_flags(object value);
    private static SocketError closesocket(IntPtr socketHandle);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static object closesocket(int handle);
    private static int recv(IntPtr socketHandle, Byte[] pinnedBuffer, int len, SocketFlags socketFlags);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static Bytes recv(int handle, int size);
    private static int send(IntPtr socketHandle, IntPtr pinnedBuffer, int len, SocketFlags socketFlags);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int send(int handle, IBufferProtocol data);
}
internal static class IronPython.Modules.NativeFunctions : object {
    private static SetMemoryDelegate _setMem;
    private static MoveMemoryDelegate _moveMem;
    private static int RTLD_NOW;
    private static int LMEM_ZEROINIT;
    private static NativeFunctions();
    public static bool FreeLibrary(IntPtr hModule);
    private static IntPtr LoadLibrary(string lpFileName);
    public static void SetLastError(int errorCode);
    public static int GetLastError();
    private static IntPtr GetProcAddress(IntPtr module, string lpFileName);
    private static IntPtr GetProcAddress(IntPtr module, IntPtr ordinal);
    private static void memcpy(IntPtr dst, IntPtr src, IntPtr length);
    private static void CopyMemory(IntPtr destination, IntPtr source, IntPtr length);
    public static void MemCopy(IntPtr destination, IntPtr source, IntPtr length);
    private static IntPtr dlopen(string filename, int flags);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    public static IntPtr LoadDLL(string filename, int flags);
    public static IntPtr LoadFunction(IntPtr module, string functionName);
    public static IntPtr LoadFunction(IntPtr module, IntPtr ordinal);
    [ReliabilityContractAttribute("3", "1")]
public static IntPtr Calloc(IntPtr size);
    public static IntPtr GetMemMoveAddress();
    public static IntPtr GetMemSetAddress();
    [ReliabilityContractAttribute("3", "1")]
private static IntPtr LocalAlloc(UInt32 flags, IntPtr size);
    private static IntPtr calloc(IntPtr num, IntPtr size);
    private static void RtlMoveMemory(IntPtr Destination, IntPtr src, IntPtr length);
    private static IntPtr memmove(IntPtr dst, IntPtr src, IntPtr length);
    private static IntPtr MemSet(IntPtr dest, byte value, IntPtr length);
    private static IntPtr MoveMemory(IntPtr dest, IntPtr src, IntPtr length);
}
public class IronPython.Modules.PosixSubprocess : object {
    public static string __doc__;
    [DocumentationAttribute("fork_exec(args, executable_list, close_fds, cwd, env,
          p2cread, p2cwrite, c2pread, c2pwrite,
          errread, errwrite, errpipe_read, errpipe_write,
          restore_signals, call_setsid, preexec_fn)

Forks a child process, closes parent file descriptors as appropriate in the
child and dups the few that are needed before calling exec() in the child
process.

The preexec_fn, if supplied, will be called immediately before exec.
WARNING: preexec_fn is NOT SAFE if your application uses threads.
         It may trigger infrequent, difficult to debug deadlocks.

If an error occurs in the child process before the exec, it is
serialized and written to the errpipe_write fd per subprocess.py.

Returns: the child process's PID.

Raises: Only on an error in the parent process.
")]
public static object fork_exec(CodeContext context, Object[] args);
}
public static class IronPython.Modules.PythonAtExit : object {
    public static string __doc__;
    private static object _registry_key;
    private static PythonAtExit();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    [DocumentationAttribute("register(func, *args, **kwargs) -> func

Register a function to be executed upon normal program termination\n\

    func - function to be called at exit
    args - optional arguments to pass to func
    kwargs - optional keyword arguments to pass to func

    func is returned to facilitate usage as a decorator.")]
public static object register(CodeContext context, object func, IDictionary`2<object, object> kwargs, Object[] args);
    [DocumentationAttribute("unregister(func) -> None

Unregister an exit function which was previously registered using
atexit.register

    func - function to be unregistered")]
public static void unregister(CodeContext context, object func);
    [DocumentationAttribute("_clear() -> None

Clear the list of previously registered exit functions.")]
public static void _clear(CodeContext context);
    [DocumentationAttribute("_run_exitfuncs() -> None

Run all registered exit functions.")]
public static void _run_exitfuncs(CodeContext context);
    [DocumentationAttribute("_ncallbacks() -> int

Return the number of registered exit functions.")]
public static int _ncallbacks(CodeContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class IronPython.Modules.PythonAudioOp : object {
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    private static PythonType error(CodeContext context);
    public static Bytes byteswap(CodeContext context, IBufferProtocol fragment, int width);
    [ExtensionAttribute]
private static void ByteSwap(Byte[] array, int i, int j);
}
[ExtensionAttribute]
public static class IronPython.Modules.PythonBinaryAscii : object {
    public static string __doc__;
    private static object _ErrorKey;
    private static object _IncompleteKey;
    private static int MAXLINESIZE;
    private static UInt16[] crctab_hqx;
    private static int IgnoreByte;
    private static int EmptyByte;
    private static int PadByte;
    private static int InvalidByte;
    private static int NoMoreBytes;
    private static PythonBinaryAscii();
    private static Exception Error(CodeContext context, Object[] args);
    private static Exception Incomplete(CodeContext context, Object[] args);
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static Bytes a2b_uu(CodeContext context, IBufferProtocol data);
    public static Bytes a2b_uu(CodeContext context, string data);
    private static Bytes a2b_uu_impl(CodeContext context, IList`1<byte> data);
    public static Bytes b2a_uu(CodeContext context, IBufferProtocol data);
    private static Bytes b2a_uu_impl(CodeContext context, IList`1<byte> data);
    public static Bytes a2b_base64(CodeContext context, IBufferProtocol data);
    public static Bytes a2b_base64(CodeContext context, string data);
    private static Bytes a2b_base64_impl(CodeContext context, IList`1<byte> data);
    public static Bytes b2a_base64(IBufferProtocol data);
    private static Bytes b2a_base64_impl(IList`1<byte> data);
    [DocumentationAttribute("a2b_qp(data, header=False)
    Decode a string of qp-encoded data.")]
public static Bytes a2b_qp(IBufferProtocol data, bool header);
    public static Bytes a2b_qp(string data, bool header);
    private static Bytes a2b_qp_impl(ReadOnlySpan`1<byte> ascii_data, bool header);
    [DocumentationAttribute("b2a_qp(data, quotetabs=False, istext=True, header=False) -> s;
 Encode a string using quoted-printable encoding.

On encoding, when istext is set, newlines are not encoded, and white
space at end of lines is.  When istext is not set, \\r and \\n (CR/LF) are
both encoded.  When quotetabs is set, space and tabs are encoded.")]
public static Bytes b2a_qp(IBufferProtocol data, bool quotetabs, bool istext, bool header);
    private static Bytes b2a_qp_impl(string data, bool quotetabs, bool istext, bool header);
    public static object a2b_hqx(object data);
    public static object rledecode_hqx(object data);
    public static object rlecode_hqx(object data);
    public static object b2a_hqx(object data);
    public static int crc_hqx(IBufferProtocol data, int crc);
    private static int crc_hqx_impl(IList`1<byte> data, int crc);
    [DocumentationAttribute("crc32(data[, crc]) -> string

Computes a CRC (Cyclic Redundancy Check) checksum of data.")]
public static object crc32(IBufferProtocol data, UInt32 crc);
    private static UInt32 crc32(ReadOnlySpan`1<byte> buffer, UInt32 baseValue);
    public static Bytes b2a_hex(IBufferProtocol data);
    private static Bytes b2a_hex_impl(IList`1<byte> data);
    public static Bytes hexlify(IBufferProtocol data);
    public static Bytes a2b_hex(CodeContext context, IBufferProtocol data);
    public static Bytes a2b_hex(CodeContext context, string data);
    private static Bytes a2b_hex_impl(CodeContext context, IList`1<byte> data);
    public static Bytes unhexlify(CodeContext context, IBufferProtocol hexstr);
    public static Bytes unhexlify(CodeContext context, string hexstr);
    [ExtensionAttribute]
private static void EncodeData(MemoryStream res, IList`1<byte> data, byte empty, Func`2<int, byte> encFunc);
    private static int NextVal(CodeContext context, IList`1<byte> data, Int32& index, DecodeByte decFunc);
    private static int CountPadBytes(CodeContext context, IList`1<byte> data, int bound, Int32& index, DecodeByte decFunc);
    private static int GetVal(CodeContext context, IList`1<byte> data, int align, bool bounded, Int32& index, DecodeByte decFunc);
    private static MemoryStream DecodeWorker(CodeContext context, IList`1<byte> data, bool bounded, DecodeByte decFunc);
    private static IList`1<byte> RemovePrefix(CodeContext context, IList`1<byte> data, DecodeByte decFunc);
    private static void ProcessSuffix(CodeContext context, IList`1<byte> data, DecodeByte decFunc);
    [ExtensionAttribute]
private static Bytes ToBytes(string s);
    [ExtensionAttribute]
private static IList`1<byte> ToBytes(IBufferProtocol buffer);
    private static bool TryParseHex(byte b, Byte& x);
    [CompilerGeneratedAttribute]
internal static int <a2b_uu_impl>g__UuDecFunc|8_0(byte val);
    [CompilerGeneratedAttribute]
internal static int <a2b_base64_impl>g__Base64DecFunc|13_0(byte val);
    [CompilerGeneratedAttribute]
internal static byte <b2a_base64_impl>g__EncodeValue|15_0(int val);
    [CompilerGeneratedAttribute]
internal static void <b2a_qp_impl>g__to_hex|21_0(char ch, StringBuilder s, int index);
    [CompilerGeneratedAttribute]
internal static byte <b2a_hex_impl>g__ToAscii|32_0(int b);
    [CompilerGeneratedAttribute]
internal static byte <a2b_hex_impl>g__ParseHex|36_0(CodeContext context, byte b);
}
public class IronPython.Modules.PythonBisectModule : object {
    public static string __doc__;
    public static object bisect_right;
    public static object bisect;
    public static object insort_right;
    public static object insort;
    private static PythonBisectModule();
    private static int InternalBisectLeft(CodeContext context, PythonList list, object item, int lo, int hi);
    private static int InternalBisectLeft(CodeContext context, object list, object item, int lo, int hi);
    private static int InternalBisectRight(CodeContext context, PythonList list, object item, int lo, int hi);
    private static int InternalBisectRight(CodeContext context, object list, object item, int lo, int hi);
    private static Type GetComparisonType(CodeContext context, object a);
    private static Type GetComparisonType(PythonList a);
    [PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DocumentationAttribute("bisect_right(a, x[, lo[, hi]]) -> index

Return the index where to insert item x in list a, assuming a is sorted.

The return value i is such that all e in a[:i] have e <= x, and all e in
a[i:] have e > x.  So if x already appears in the list, i points just
beyond the rightmost x already there

Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
")]
public static object BisectRight(CodeContext context, object a, object x, int lo, int hi);
    [DocumentationAttribute("bisect_left(a, x[, lo[, hi]]) -> index

Return the index where to insert item x in list a, assuming a is sorted.

The return value i is such that all e in a[:i] have e < x, and all e in
a[i:] have e >= x.  So if x already appears in the list, i points just
before the leftmost x already there.

Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
")]
public static object bisect_left(CodeContext context, object a, object x, int lo, int hi);
    [PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DocumentationAttribute("insort_right(a, x[, lo[, hi]])

Insert item x in list a, and keep it sorted assuming a is sorted.

If x is already in a, insert it to the right of the rightmost x.

Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
")]
public static void InsortRight(CodeContext context, object a, object x, int lo, int hi);
    [DocumentationAttribute("insort_left(a, x[, lo[, hi]])

Insert item x in list a, and keep it sorted assuming a is sorted.

If x is already in a, insert it to the left of the leftmost x.

Optional args lo (default 0) and hi (default len(a)) bound the
slice of a to be searched.
")]
public static void insort_left(CodeContext context, object a, object x, int lo, int hi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class IronPython.Modules.PythonCodecs : object {
    public static string __doc__;
    internal static int EncoderIndex;
    internal static int DecoderIndex;
    internal static int StreamReaderIndex;
    internal static int StreamWriterIndex;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Byte[] _replacementMarker;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf16LeEncoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Byte[] _bom_utf16_le;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf16BeEncoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Byte[] _bom_utf16_be;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf8Encoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf32LeEncoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Byte[] _bom_utf32_le;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf32BeEncoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Encoding _utf32BeBomEncoding;
    [NullableAttribute("2")]
[DisallowNullAttribute]
private static Byte[] _bom_utf32_be;
    private static Encoding Utf16LeEncoding { get; }
    private static Encoding Utf16LeBomEncoding { get; }
    private static Byte[] BOM_UTF16_LE { get; }
    private static Encoding Utf16BeEncoding { get; }
    private static Encoding Utf16BeBomEncoding { get; }
    private static Byte[] BOM_UTF16_BE { get; }
    private static Encoding Utf8Encoding { get; }
    private static Encoding Utf32LeEncoding { get; }
    private static Encoding Utf32LeBomEncoding { get; }
    private static Byte[] BOM_UTF32_LE { get; }
    private static Encoding Utf32BeEncoding { get; }
    private static Encoding Utf32BeBomEncoding { get; }
    private static Byte[] BOM_UTF32_BE { get; }
    public static PythonTuple lookup(CodeContext context, string encoding);
    [LightThrowingAttribute]
public static object lookup_error(CodeContext context, string name);
    public static void register(CodeContext context, object search_function);
    public static void register_error(CodeContext context, string name, object handler);
    public static PythonTuple ascii_decode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple ascii_encode(CodeContext context, string input, string errors);
    public static EncodingMap charmap_build(string decoding_table);
    public static PythonTuple charmap_encode(CodeContext context, string input, string errors, EncodingMap map);
    public static PythonTuple charmap_encode(CodeContext context, string input, string errors, IDictionary`2<object, object> map);
    public static PythonTuple charmap_decode(CodeContext context, IBufferProtocol input, string errors, string map);
    public static PythonTuple charmap_decode(CodeContext context, IBufferProtocol input, string errors, IDictionary`2<object, object> map);
    public static object decode(CodeContext context, object obj, string encoding, string errors);
    public static object encode(CodeContext context, object obj, string encoding, string errors);
    public static PythonTuple escape_decode(CodeContext context, string data, string errors);
    public static PythonTuple escape_decode(IBufferProtocol data, string errors);
    public static PythonTuple escape_encode(Bytes data, string errors);
    public static PythonTuple latin_1_decode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple latin_1_encode(CodeContext context, string input, string errors);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static PythonTuple mbcs_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static PythonTuple mbcs_encode(CodeContext context, string input, string errors);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static PythonTuple code_page_decode(CodeContext context, int codepage, IBufferProtocol input, string errors, bool final);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static PythonTuple code_page_encode(CodeContext context, int codepage, string input, string errors);
    public static PythonTuple raw_unicode_escape_decode(CodeContext context, string input, string errors);
    public static PythonTuple raw_unicode_escape_decode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple raw_unicode_escape_encode(CodeContext context, string input, string errors);
    public static PythonTuple unicode_escape_decode(CodeContext context, string input, string errors);
    public static PythonTuple unicode_escape_decode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple unicode_escape_encode(CodeContext context, string input, string errors);
    public static PythonTuple readbuffer_encode(CodeContext context, string input, string errors);
    public static PythonTuple readbuffer_encode(IBufferProtocol input, string errors);
    public static PythonTuple unicode_internal_decode(CodeContext context, string input, string errors);
    public static PythonTuple unicode_internal_decode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple unicode_internal_encode(CodeContext context, string input, string errors);
    public static PythonTuple unicode_internal_encode(CodeContext context, IBufferProtocol input, string errors);
    public static PythonTuple utf_16_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_16_encode(CodeContext context, string input, string errors);
    public static PythonTuple utf_16_ex_decode(CodeContext context, IBufferProtocol input, string errors, int byteorder, bool final);
    [NullableContextAttribute("0")]
private static int Utf16DetectByteorder(ReadOnlySpan`1<byte> input);
    [NullableContextAttribute("0")]
private static int NumEligibleUtf16Bytes(ReadOnlySpan`1<byte> input, bool final, bool isLE);
    private static Encoding get_Utf16LeEncoding();
    private static Encoding get_Utf16LeBomEncoding();
    private static Byte[] get_BOM_UTF16_LE();
    public static PythonTuple utf_16_le_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_16_le_encode(CodeContext context, string input, string errors);
    private static Encoding get_Utf16BeEncoding();
    private static Encoding get_Utf16BeBomEncoding();
    private static Byte[] get_BOM_UTF16_BE();
    public static PythonTuple utf_16_be_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_16_be_encode(CodeContext context, string input, string errors);
    public static PythonTuple utf_7_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_7_encode(CodeContext context, string input, string errors);
    [NullableContextAttribute("0")]
private static int NumEligibleUtf7Bytes(ReadOnlySpan`1<byte> input, bool final);
    private static Encoding get_Utf8Encoding();
    public static PythonTuple utf_8_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_8_encode(CodeContext context, string input, string errors);
    [NullableContextAttribute("0")]
private static int NumEligibleUtf8Bytes(ReadOnlySpan`1<byte> input, bool final);
    public static PythonTuple utf_32_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_32_encode(CodeContext context, string input, string errors);
    public static PythonTuple utf_32_ex_decode(CodeContext context, IBufferProtocol input, string errors, int byteorder, bool final);
    [NullableContextAttribute("0")]
private static int Utf32DetectByteorder(ReadOnlySpan`1<byte> input);
    [NullableContextAttribute("0")]
private static int NumEligibleUtf32Bytes(ReadOnlySpan`1<byte> input, bool final);
    private static Encoding get_Utf32LeEncoding();
    private static Encoding get_Utf32LeBomEncoding();
    private static Byte[] get_BOM_UTF32_LE();
    public static PythonTuple utf_32_le_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_32_le_encode(CodeContext context, string input, string errors);
    private static Encoding get_Utf32BeEncoding();
    private static Encoding get_Utf32BeBomEncoding();
    private static Byte[] get_BOM_UTF32_BE();
    public static PythonTuple utf_32_be_decode(CodeContext context, IBufferProtocol input, string errors, bool final);
    public static PythonTuple utf_32_be_encode(CodeContext context, string input, string errors);
    private static Tuple`2<string, int> DoDecode(CodeContext context, string encodingName, Encoding encoding, IPythonBuffer input, string errors, int numBytes);
    private static Tuple`2<Bytes, int> DoEncode(CodeContext context, string encodingName, Encoding encoding, string input, string errors, bool includePreamble);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ParseBytesErrorHandler`1<byte> <escape_decode>g__getErrorHandler|19_0(string errors);
}
public class IronPython.Modules.PythonCollections : object {
    public static string __doc__;
    public static PythonType _deque_iterator { get; }
    public static PythonType _deque_reversed_iterator { get; }
    public static PythonType get__deque_iterator();
    public static PythonType get__deque_reversed_iterator();
}
public static class IronPython.Modules.PythonCsvModule : object {
    public static string __doc__;
    public static string __version__;
    public static int QUOTE_MINIMAL;
    public static int QUOTE_ALL;
    public static int QUOTE_NONNUMERIC;
    public static int QUOTE_NONE;
    private static object _fieldSizeLimitKey;
    private static object _dialectRegistryKey;
    private static int FieldSizeLimit;
    public static PythonType Error;
    private static PythonCsvModule();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static int field_size_limit(CodeContext context, int new_limit);
    public static int field_size_limit(CodeContext context);
    [DocumentationAttribute("Create a mapping from a string name to a dialect class.
dialect = csv.register_dialect(name, dialect)")]
public static void register_dialect(CodeContext context, IDictionary`2<object, object> kwArgs, Object[] args);
    private static Dictionary`2<string, Dialect> GetDialects(CodeContext context);
    private static int GetFieldSizeLimit(CodeContext context);
    [DocumentationAttribute("Delete the name/dialect mapping associated with a string name.\n
    csv.unregister_dialect(name)")]
public static void unregister_dialect(CodeContext context, string name);
    [DocumentationAttribute("Return the dialect instance associated with name.
    dialect = csv.get_dialect(name)")]
public static object get_dialect(CodeContext context, string name);
    [DocumentationAttribute("Return a list of all know dialect names
    names = csv.list_dialects()")]
public static PythonList list_dialects(CodeContext context);
    [DocumentationAttribute("csv_reader = reader(iterable [, dialect='excel']
                       [optional keyword args])
    for row in csv_reader:
        process(row)

    The "iterable" argument can be any object that returns a line
    of input for each iteration, such as a file object or a list.  The
    optional "dialect" parameter is discussed below.  The function
    also accepts optional keyword arguments which override settings
    provided by the dialect.

    The returned object is an iterator.  Each iteration returns a row
    of the CSV file (which can span multiple input lines)")]
public static object reader(CodeContext context, IDictionary`2<object, object> kwArgs, Object[] args);
    public static object writer(CodeContext context, IDictionary`2<object, object> kwArgs, Object[] args);
    internal static Exception MakeError(Object[] args);
    private static void InitModuleExceptions(PythonContext context, PythonDictionary dict);
}
public class IronPython.Modules.PythonDateTime : object {
    public static int MAXYEAR;
    public static int MINYEAR;
    public static string __doc__;
    private static PythonDateTime();
    internal static void ThrowIfInvalid(timedelta delta, string funcname);
    internal static void ValidateInput(InputKind kind, int value);
    internal static bool IsNaiveTimeZone(tzinfo tz);
    internal static int CastToInt(object o);
}
public static class IronPython.Modules.PythonErrorNumber : object {
    public static string __doc__;
    public static int E2BIG;
    public static int EACCES;
    public static int EADDRINUSE;
    public static int EADDRNOTAVAIL;
    public static int EAFNOSUPPORT;
    public static int EAGAIN;
    public static int EALREADY;
    public static int EBADF;
    public static int EBUSY;
    public static int ECHILD;
    public static int ECONNABORTED;
    public static int ECONNREFUSED;
    public static int ECONNRESET;
    public static int EDEADLK;
    public static int EDEADLOCK;
    public static int EDESTADDRREQ;
    public static int EDOM;
    public static int EDQUOT;
    public static int EEXIST;
    public static int EFAULT;
    public static int EFBIG;
    public static int EHOSTDOWN;
    public static int EHOSTUNREACH;
    public static int EILSEQ;
    public static int EINPROGRESS;
    public static int EINTR;
    public static int EINVAL;
    public static int EIO;
    public static int EISCONN;
    public static int EISDIR;
    public static int ELOOP;
    public static int EMFILE;
    public static int EMLINK;
    public static int EMSGSIZE;
    public static int ENAMETOOLONG;
    public static int ENETDOWN;
    public static int ENETRESET;
    public static int ENETUNREACH;
    public static int ENFILE;
    public static int ENOBUFS;
    public static int ENODEV;
    public static int ENOENT;
    public static int ENOEXEC;
    public static int ENOLCK;
    public static int ENOMEM;
    public static int ENOPROTOOPT;
    public static int ENOSPC;
    public static int ENOSYS;
    public static int ENOTCONN;
    public static int ENOTDIR;
    public static int ENOTEMPTY;
    public static int ENOTSOCK;
    public static int ENOTTY;
    public static int ENXIO;
    public static int EOPNOTSUPP;
    public static int EPERM;
    public static int EPFNOSUPPORT;
    public static int EPIPE;
    public static int EPROTONOSUPPORT;
    public static int EPROTOTYPE;
    public static int ERANGE;
    public static int EREMOTE;
    public static int EROFS;
    public static int ESHUTDOWN;
    public static int ESOCKTNOSUPPORT;
    public static int ESPIPE;
    public static int ESRCH;
    public static int ESTALE;
    public static int ETIMEDOUT;
    public static int ETOOMANYREFS;
    public static int EUSERS;
    public static int EWOULDBLOCK;
    public static int EXDEV;
    public static int WSABASEERR;
    public static int WSAEACCES;
    public static int WSAEADDRINUSE;
    public static int WSAEADDRNOTAVAIL;
    public static int WSAEAFNOSUPPORT;
    public static int WSAEALREADY;
    public static int WSAEBADF;
    public static int WSAECONNABORTED;
    public static int WSAECONNREFUSED;
    public static int WSAECONNRESET;
    public static int WSAEDESTADDRREQ;
    public static int WSAEDISCON;
    public static int WSAEDQUOT;
    public static int WSAEFAULT;
    public static int WSAEHOSTDOWN;
    public static int WSAEHOSTUNREACH;
    public static int WSAEINPROGRESS;
    public static int WSAEINTR;
    public static int WSAEINVAL;
    public static int WSAEISCONN;
    public static int WSAELOOP;
    public static int WSAEMFILE;
    public static int WSAEMSGSIZE;
    public static int WSAENAMETOOLONG;
    public static int WSAENETDOWN;
    public static int WSAENETRESET;
    public static int WSAENETUNREACH;
    public static int WSAENOBUFS;
    public static int WSAENOPROTOOPT;
    public static int WSAENOTCONN;
    public static int WSAENOTEMPTY;
    public static int WSAENOTSOCK;
    public static int WSAEOPNOTSUPP;
    public static int WSAEPFNOSUPPORT;
    public static int WSAEPROCLIM;
    public static int WSAEPROTONOSUPPORT;
    public static int WSAEPROTOTYPE;
    public static int WSAEREMOTE;
    public static int WSAESHUTDOWN;
    public static int WSAESOCKTNOSUPPORT;
    public static int WSAESTALE;
    public static int WSAETIMEDOUT;
    public static int WSAETOOMANYREFS;
    public static int WSAEUSERS;
    public static int WSAEWOULDBLOCK;
    public static int WSANOTINITIALISED;
    public static int WSASYSNOTREADY;
    public static int WSAVERNOTSUPPORTED;
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
}
public static class IronPython.Modules.PythonExpat : object {
    public static int XML_PARAM_ENTITY_PARSING_NEVER;
    public static int XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE;
    public static int XML_PARAM_ENTITY_PARSING_ALWAYS;
    private static object _errorsKey;
    [CompilerGeneratedAttribute]
private static object <XMLParserType>k__BackingField;
    public static object XMLParserType { get; }
    private static PythonExpat();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static string ErrorString(int errno);
    public static object ParserCreate(CodeContext context, IDictionary`2<object, object> kwArgsø, Object[] argsø);
    public static object ParserCreate(object encoding, object namespace_separator, object intern);
    private static object ParserCreateImpl(string encoding, string namespace_separator, object intern);
    [CompilerGeneratedAttribute]
public static object get_XMLParserType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class IronPython.Modules.PythonFaultHandler : object {
    private static int STDERR;
    public static void dump_traceback(CodeContext context, object file, bool all_threads);
    public static void enable(CodeContext context, object file, bool all_threads);
}
public static class IronPython.Modules.PythonFcntl : object {
}
public static class IronPython.Modules.PythonGC : object {
    public static string __doc__;
    public static int DEBUG_STATS;
    public static int DEBUG_COLLECTABLE;
    public static int DEBUG_UNCOLLECTABLE;
    public static int DEBUG_SAVEALL;
    public static int DEBUG_LEAK;
    private static object _threadholdKey;
    public static PythonList garbage { get; }
    private static PythonGC();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static void enable();
    public static void disable(CodeContext context);
    public static object isenabled();
    public static int collect(CodeContext context, int generation);
    public static int collect(CodeContext context);
    public static void set_debug(object o);
    public static object get_debug();
    public static Object[] get_objects();
    public static void set_threshold(CodeContext context, Object[] args);
    public static PythonTuple get_threshold(CodeContext context);
    public static Object[] get_referrers(Object[] objs);
    public static Object[] get_referents(Object[] objs);
    public static PythonList get_garbage();
    private static PythonTuple GetThresholds(CodeContext context);
    private static void SetThresholds(CodeContext context, PythonTuple thresholds);
}
public static class IronPython.Modules.PythonGrp : object {
    public static string __doc__;
    private static struct_group Make(IntPtr pwd);
    [IteratorStateMachineAttribute("IronPython.Modules.PythonGrp/<MarshalStringArray>d__4")]
private static IEnumerable`1<string> MarshalStringArray(IntPtr arrayPtr);
    public static struct_group getgrgid(int gid);
    public static struct_group getgrnam(string name);
    public static PythonList getgrall();
    private static IntPtr _getgrgid(int uid);
    private static IntPtr _getgrnam(string name);
    private static void setgrent();
    private static IntPtr getgrent();
}
public static class IronPython.Modules.PythonHeapq : object {
    public static string __doc__;
    public static string __about__;
    [DocumentationAttribute("Transform list into a heap, in-place, in O(len(heap)) time.")]
public static void heapify(CodeContext context, PythonList list);
    [DocumentationAttribute("Pop the smallest item off the heap, maintaining the heap invariant.")]
public static object heappop(CodeContext context, PythonList list);
    [DocumentationAttribute("Push item onto heap, maintaining the heap invariant.")]
public static void heappush(CodeContext context, PythonList list, object item);
    [DocumentationAttribute("Push item on the heap, then pop and return the smallest item
from the heap. The combined action runs more efficiently than
heappush() followed by a separate call to heappop().")]
public static object heappushpop(CodeContext context, PythonList list, object item);
    [DocumentationAttribute("Pop and return the current smallest value, and add the new item.

This is more efficient than heappop() followed by heappush(), and can be
more appropriate when using a fixed-size heap. Note that the value
returned may be larger than item!  That constrains reasonable uses of
this routine unless written as part of a conditional replacement:

        if item > heap[0]:
            item = heapreplace(heap, item)
")]
public static object heapreplace(CodeContext context, PythonList list, object item);
    [DocumentationAttribute("Find the n largest elements in a dataset.

Equivalent to:  sorted(iterable, reverse=True)[:n]
")]
public static PythonList nlargest(CodeContext context, int n, object iterable);
    [DocumentationAttribute("Find the n smallest elements in a dataset.

Equivalent to:  sorted(iterable)[:n]
")]
public static PythonList nsmallest(CodeContext context, int n, object iterable);
    private static bool IsLessThan(CodeContext context, object x, object y);
    private static void HeapSort(CodeContext context, PythonList list);
    private static void HeapSort(CodeContext context, PythonList list, bool reverse);
    private static void DoHeapify(CodeContext context, PythonList list);
    private static void DoHeapifyMax(CodeContext context, PythonList list);
    private static object DoPushPop(CodeContext context, PythonList heap, object item);
    private static object DoPushPopMax(CodeContext context, PythonList heap, object item);
    private static void SiftDown(CodeContext context, PythonList heap, int start, int stop);
    private static void SiftDownMax(CodeContext context, PythonList heap, int start, int stop);
    private static void SiftUp(CodeContext context, PythonList heap, int index);
    private static void SiftUpMax(CodeContext context, PythonList heap, int index);
}
public static class IronPython.Modules.PythonIterTools : object {
    public static string __doc__;
    public static object tee(object iterable);
    public static object tee(object iterable, int n);
    private static Exception UnexpectedKeywordArgument(IDictionary`2<object, object> paramDict);
    private static int GetR(object r, PythonList data);
    private static bool MoveNextHelper(IEnumerator move);
}
public static class IronPython.Modules.PythonMarshal : object {
    public static string __doc__;
    public static int version;
    public static void dump(CodeContext context, object value, _IOBase file, int version);
    public static object load(CodeContext context, _IOBase file);
    public static Bytes dumps(object value, int version);
    public static object loads(IList`1<byte> bytes);
    [IteratorStateMachineAttribute("IronPython.Modules.PythonMarshal/<FileEnumerator>d__6")]
private static IEnumerator`1<byte> FileEnumerator(CodeContext context, _IOBase file);
}
public static class IronPython.Modules.PythonMath : object {
    public static string __doc__;
    public static double pi;
    public static double e;
    private static double degreesToRadians;
    private static int Bias;
    public static double nan;
    public static double inf;
    private static PythonMath();
    public static double degrees(double radians);
    public static double radians(double degrees);
    public static double fmod(double v, double w);
    private static double sum(List`1<double> partials);
    public static double fsum(IEnumerable e);
    public static PythonTuple frexp(double v);
    public static PythonTuple modf(double v);
    public static double ldexp(double v, BigInteger w);
    public static double hypot(double v, double w);
    public static double pow(double v, double exp);
    public static double log(double v0);
    public static double log(double v0, double v1);
    public static double log(BigInteger value);
    public static double log(object value);
    public static double log(BigInteger value, double newBase);
    public static double log(object value, double newBase);
    public static double log2(double x);
    public static double log2(BigInteger x);
    public static double log10(double v0);
    public static double log10(BigInteger value);
    public static double log10(object value);
    public static double log1p(double v0);
    public static double log1p(BigInteger value);
    public static double log1p(object value);
    public static double expm1(double v0);
    public static double asinh(double v0);
    public static double asinh(object value);
    public static double acosh(double v0);
    public static double acosh(object value);
    public static double atanh(double v0);
    public static double atanh(BigInteger value);
    public static double atanh(object value);
    public static double atan2(double v0, double v1);
    public static object ceil(CodeContext context, object x);
    public static object ceil(double v0);
    public static double erf(double v0);
    public static double erfc(double v0);
    public static object factorial(double v0);
    public static object factorial(BigInteger value);
    public static object factorial(object value);
    public static object floor(CodeContext context, object x);
    public static object floor(double v0);
    public static double gamma(double v0);
    public static double lgamma(double v0);
    public static object trunc(CodeContext context, object value);
    public static bool isfinite(double x);
    public static bool isinf(double v0);
    public static bool isinf(BigInteger value);
    public static bool isinf(object value);
    public static bool isnan(double v0);
    public static bool isnan(BigInteger value);
    public static bool isnan(object value);
    public static double copysign(double x, double y);
    public static double copysign(object x, object y);
    public static object gcd(BigInteger x, BigInteger y);
    public static object gcd(object x, object y);
    public static bool isclose(double a, double b, double rel_tol, double abs_tol);
    private static void SetExponentLe(Byte[] v, int exp);
    private static int IntExponentLe(Byte[] v);
    private static ushort LdExponentLe(Byte[] v);
    private static long LdMantissaLe(Byte[] v);
    private static void StExponentLe(Byte[] v, ushort e);
    private static bool IsDenormalizedLe(Byte[] v);
    private static void DecomposeLe(Byte[] v, Double& m, Int32& e);
    private static double Check(double v);
    private static double Check(double input, double output);
    private static double Check(double in0, double in1, double output);
    public static double cos(double v0);
    public static double sin(double v0);
    public static double tan(double v0);
    public static double cosh(double v0);
    public static double sinh(double v0);
    public static double tanh(double v0);
    public static double acos(double v0);
    public static double asin(double v0);
    public static double atan(double v0);
    public static double fabs(double v0);
    public static double sqrt(double v0);
    public static double exp(double v0);
    [CompilerGeneratedAttribute]
internal static BigInteger <gcd>g__ObjectToBigInteger|60_0(object x);
}
public static class IronPython.Modules.PythonMD5 : object {
    public static string __doc__;
    private static int DIGEST_SIZE;
    private static int BLOCK_SIZE;
    [DocumentationAttribute("md5([data]) -> object (new md5 object)")]
public static MD5Type md5(IBufferProtocol data);
    public static MD5Type md5(string data);
    [DocumentationAttribute("md5([data]) -> object (new md5 object)")]
public static MD5Type md5();
}
[PythonTypeAttribute("msvcrt")]
public class IronPython.Modules.PythonMsvcrt : object {
    public static string __doc__;
    public static int SEM_FAILCRITICALERRORS;
    public static int SEM_NOGPFAULTERRORBOX;
    public static int SEM_NOALIGNMENTFAULTEXCEPT;
    public static int SEM_NOOPENFILEERRORBOX;
    private static int O_TEXT;
    private static int O_BINARY;
    private static int EOF;
    private static ushort WEOF;
    private static PythonMsvcrt();
    public static void SetErrorMode(int mode);
    [DocumentationAttribute("heapmin() -> None

Force the malloc() heap to clean itself up and return unused blocks
to the operating system. On failure, this raises IOError.")]
public static void heapmin();
    [DocumentationAttribute("open_osfhandle(handle, flags) -> file descriptor

Create a C runtime file descriptor from the file handle handle. The
flags parameter should be a bitwise OR of os.O_APPEND, os.O_RDONLY,
and os.O_TEXT. The returned file descriptor may be used as a parameter
to os.fdopen() to create a file object.
")]
public static int open_osfhandle(CodeContext context, BigInteger os_handle, int flags);
    private static bool TryGetFileHandle(Stream stream, Object& handle);
    [DocumentationAttribute("get_osfhandle(fd) -> file handle

Return the file handle for the file descriptor fd. Raises IOError
if fd is not recognized.")]
public static object get_osfhandle(CodeContext context, int fd);
    [DocumentationAttribute("setmode(fd, mode) -> Previous mode

Set the line-end translation mode for the file descriptor fd. To set
it to text mode, flags should be os.O_TEXT; for binary, it should be
os.O_BINARY.")]
public static int setmode(CodeContext context, int fd, int flags);
    [DocumentationAttribute("kbhit() -> bool

Return true if a keypress is waiting to be read.")]
public static bool kbhit();
    [DocumentationAttribute("getch() -> key character

Read a keypress and return the resulting character. Nothing is echoed to
the console. This call will block if a keypress is not already
available, but will not wait for Enter to be pressed. If the pressed key
was a special function key, this will return '\\000' or '\\xe0'; the next
call will return the keycode. The Control-C keypress cannot be read with
this function.")]
public static string getch();
    [DocumentationAttribute("getwch() -> Unicode key character

Wide char variant of getch(), returning a Unicode value.")]
public static string getwch();
    [DocumentationAttribute("getche() -> key character

Similar to getch(), but the keypress will be echoed if it represents
a printable character.")]
public static string getche();
    [DocumentationAttribute("getwche() -> Unicode key character

Wide char variant of getche(), returning a Unicode value.")]
public static string getwche();
    [DocumentationAttribute("putch(char) -> None

Print the character char to the console without buffering.")]
public static void putch(char char);
    [DocumentationAttribute("putwch(unicode_char) -> None

Wide char variant of putch(), accepting a Unicode value.")]
public static void putwch(char char);
    [DocumentationAttribute("ungetch(char) -> None

Cause the character char to be "pushed back" into the console buffer;
it will be the next character read by getch() or getche().")]
public static void ungetch(char char);
    [DocumentationAttribute("ungetwch(unicode_char) -> None

Wide char variant of ungetch(), accepting a Unicode value.")]
public static void ungetwch(char char);
    private static int _heapmin();
    private static int _kbhit();
    private static int _getch();
    private static int _getche();
    private static int _putch(int c);
    private static int _ungetch(int c);
    private static ushort _getwch();
    private static ushort _getwche();
    private static ushort _putwch(char c);
    private static ushort _ungetwch(ushort c);
    [CompilerGeneratedAttribute]
internal static object <TryGetFileHandle>g__GetFileHandleUnix|10_0(<>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class IronPython.Modules.PythonNT : object {
    public static string __doc__;
    private static Dictionary`2<int, Process> _processToIdMapping;
    private static List`1<int> _freeProcessIds;
    private static int _processCount;
    private static object _keyFields;
    private static string _keyHaveFunctions;
    private static Encoding _filesystemEncoding;
    public static object environ;
    public static PythonType error;
    private static Char[] invalidPathChars;
    private static int DefaultBufferSize;
    private static UInt32 MOVEFILE_REPLACE_EXISTING;
    private static int OPEN_EXISTING;
    private static int FILE_ATTRIBUTE_NORMAL;
    private static int FILE_READ_ATTRIBUTES;
    private static int FILE_FLAG_BACKUP_SEMANTICS;
    private static int FILE_FLAG_OPEN_REPARSE_POINT;
    private static object _umaskKey;
    public static int O_APPEND;
    public static int O_CREAT;
    public static int O_TRUNC;
    public static int O_EXCL;
    public static int O_NOINHERIT;
    public static int O_RANDOM;
    public static int O_SEQUENTIAL;
    public static int O_SHORT_LIVED;
    public static int O_TEMPORARY;
    public static int O_WRONLY;
    public static int O_RDONLY;
    public static int O_RDWR;
    public static int O_BINARY;
    public static int O_TEXT;
    public static int P_WAIT;
    public static int P_NOWAIT;
    public static int P_NOWAITO;
    public static int P_OVERLAY;
    public static int P_DETACH;
    public static int TMP_MAX;
    [PythonHiddenAttribute("0")]
public static int WNOHANG;
    [PythonHiddenAttribute("0")]
public static int WUNTRACED;
    [PythonHiddenAttribute("0")]
public static int WCONTINUED;
    [PythonHiddenAttribute("0")]
public static int WSTOPPED;
    [PythonHiddenAttribute("0")]
public static int WEXITED;
    [PythonHiddenAttribute("0")]
public static int WNOWAIT;
    [PythonHiddenAttribute("0")]
public static int P_ALL;
    [PythonHiddenAttribute("0")]
public static int P_PID;
    [PythonHiddenAttribute("0")]
public static int P_PGID;
    private static int S_IWRITE;
    private static int S_IREAD;
    private static int S_IEXEC;
    public static int F_OK;
    public static int X_OK;
    public static int W_OK;
    public static int R_OK;
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int ERROR_INSUFFICIENT_BUFFER;
    private static PythonNT();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    [PythonHiddenAttribute("1")]
public static PythonTuple _getdiskusage(string path);
    private static int GetFinalPathNameByHandle(SafeFileHandle hFile, StringBuilder lpszFilePath, int cchFilePath, int dwFlags);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static string _getfinalpathname(string path);
    public static string _getfullpathname(CodeContext context, string path);
    public static Bytes _getfullpathname(CodeContext context, Bytes path);
    public static void abort();
    [DocumentationAttribute("access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)")]
public static bool access(CodeContext context, string path, int mode, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static bool access(CodeContext context, Bytes path, int mode, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static bool access(CodeContext context, IBufferProtocol path, int mode, IDictionary`2<string, object> kwargs);
    public static void chdir(string path);
    public static void chdir(Bytes path);
    public static void chdir(CodeContext context, IBufferProtocol path);
    private static void chmodUnix(string path, int mode);
    [DocumentationAttribute("chmod(path, mode, *, dir_fd=None, follow_symlinks=True)")]
public static void chmod(string path, int mode, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void chmod(Bytes path, int mode, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void chmod(CodeContext context, IBufferProtocol path, int mode, IDictionary`2<string, object> kwargs);
    public static void close(CodeContext context, int fd);
    public static void closerange(CodeContext context, int fd_low, int fd_high);
    private static bool IsValidFd(CodeContext context, int fd);
    public static int dup(CodeContext context, int fd);
    public static int dup2(CodeContext context, int fd, int fd2);
    public static void _exit(CodeContext context, int status);
    [LightThrowingAttribute]
public static object fstat(CodeContext context, int fd);
    public static void fsync(CodeContext context, int fd);
    public static string getcwd(CodeContext context);
    public static Bytes getcwdb(CodeContext context);
    public static int getpid();
    [DocumentationAttribute("link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)")]
public static void link(string src, string dst, IDictionary`2<string, object> kwargs);
    public static bool isatty(CodeContext context, int fd);
    [DocumentationAttribute("")]
public static void link(Bytes src, Bytes dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void link(CodeContext context, object src, object dst, IDictionary`2<string, object> kwargs);
    private static bool CreateHardLink(string lpFileName, string lpExistingFileName, IntPtr lpSecurityAttributes);
    public static PythonList listdir(CodeContext context, string path);
    public static PythonList listdir(CodeContext context, Bytes path);
    public static PythonList listdir(CodeContext context, IBufferProtocol path);
    public static BigInteger lseek(CodeContext context, int filedes, long offset, int whence);
    [DocumentationAttribute("lstat(path, *, dir_fd=None) -> stat_result

Like stat(), but do not follow symbolic links.
Equivalent to calling stat(...) with follow_symlinks=False.")]
[LightThrowingAttribute]
public static object lstat(string path, IDictionary`2<string, object> kwargs);
    [LightThrowingAttribute]
[DocumentationAttribute("")]
public static object lstat(Bytes path, IDictionary`2<string, object> kwargs);
    [LightThrowingAttribute]
[DocumentationAttribute("")]
public static object lstat(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs);
    public static ScandirIterator scandir(CodeContext context, string path);
    [DocumentationAttribute("symlink(src, dst, target_is_directory=False, *, dir_fd=None)")]
public static void symlink(string src, string dst, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void symlink(Bytes src, Bytes dst, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void symlink(CodeContext context, object src, object dst, IDictionary`2<string, object> kwargs, Object[] args);
    [PythonHiddenAttribute("0")]
public static uname_result uname();
    [PythonHiddenAttribute("0")]
public static BigInteger getuid();
    [PythonHiddenAttribute("0")]
public static BigInteger geteuid();
    [DocumentationAttribute("mkdir(path, mode=511, *, dir_fd=None)")]
public static void mkdir(string path, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void mkdir(Bytes path, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void mkdir(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("open(path, flags, mode=511, *, dir_fd=None)")]
public static object open(CodeContext context, string filename, int flags, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static object open(CodeContext context, Bytes filename, int flags, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static object open(CodeContext context, IBufferProtocol filename, int flags, IDictionary`2<string, object> kwargs, Object[] args);
    private static FileOptions FileOptionsFromFlags(int flag);
    private static Tuple`2<Stream, Stream> CreatePipeStreams();
    public static PythonTuple pipe(CodeContext context);
    public static void putenv(string name, string value);
    public static Bytes read(CodeContext context, int fd, int buffersize);
    [DocumentationAttribute("rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)")]
public static void rename(string src, string dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void rename(Bytes src, Bytes dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void rename(CodeContext context, object src, object dst, IDictionary`2<string, object> kwargs);
    private static bool MoveFileEx(string src, string dst, UInt32 flags);
    private static void renameUnix(string src, string dst);
    [DocumentationAttribute("replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)")]
public static void replace(string src, string dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void replace(Bytes src, Bytes dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void replace(CodeContext context, object src, object dst, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("rmdir(path, *, dir_fd=None)")]
public static void rmdir(string path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void rmdir(Bytes path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void rmdir(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs);
    public static object spawnv(CodeContext context, int mode, string path, object args);
    public static object spawnv(CodeContext context, int mode, Bytes path, object args);
    public static object spawnv(CodeContext context, int mode, IBufferProtocol path, object args);
    public static object spawnve(CodeContext context, int mode, string path, object args, object env);
    public static object spawnve(CodeContext context, int mode, Bytes path, object args, object env);
    public static object spawnve(CodeContext context, int mode, IBufferProtocol path, object args, object env);
    private static Process MakeProcess();
    private static object SpawnProcessImpl(CodeContext context, Process process, int mode, string path, object args, string methodname);
    private static void SetEnvironment(CodeContext context, StringDictionary currentEnvironment, object newEnvironment);
    private static string ArgumentsToString(CodeContext context, object args, string methodname);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void startfile(string filename, string operation);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void startfile(Bytes filename, string operation);
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static void startfile(CodeContext context, IBufferProtocol filename, string operation);
    private static bool HasExecutableExtension(string path);
    private static object statUnix(string path);
    private static SafeFileHandle CreateFile(string lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr securityAttrs, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    private static bool GetFileInformationByHandle(SafeFileHandle hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [DocumentationAttribute("stat(path, *, dir_fd=None, follow_symlinks=True) -> stat_result

Gathers statistics about the specified file or directory")]
[LightThrowingAttribute]
public static object stat(string path, IDictionary`2<string, object> kwargs);
    [LightThrowingAttribute]
[DocumentationAttribute("")]
public static object stat(Bytes path, IDictionary`2<string, object> dict);
    [LightThrowingAttribute]
[DocumentationAttribute("")]
public static object stat(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> dict);
    [LightThrowingAttribute]
[DocumentationAttribute("")]
public static object stat(CodeContext context, int fd);
    public static string strerror(int code);
    [DocumentationAttribute("system(command) -> int
Execute the command (a string) in a subshell.")]
public static int system(string command);
    public static terminal_size get_terminal_size(CodeContext context);
    public static terminal_size get_terminal_size(int fd);
    public static void truncate(CodeContext context, string path, BigInteger length);
    [DocumentationAttribute("")]
public static void truncate(CodeContext context, Bytes path, BigInteger length);
    [DocumentationAttribute("")]
public static void truncate(CodeContext context, IBufferProtocol path, BigInteger length);
    public static void truncate(CodeContext context, int fd, BigInteger length);
    public static void ftruncate(CodeContext context, int fd, BigInteger length);
    public static object times();
    [DocumentationAttribute("remove(path, *, dir_fd=None)")]
public static void remove(string path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void remove(Bytes path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void remove(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("unlink(path, *, dir_fd=None)")]
public static void unlink(string path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void unlink(Bytes path, IDictionary`2<string, object> kwargs);
    [DocumentationAttribute("")]
public static void unlink(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs);
    private static void UnlinkWorker(string path);
    public static void unsetenv(string varname);
    public static object urandom(int n);
    public static object urandom(object n);
    public static int umask(CodeContext context, int mask);
    public static int umask(CodeContext context, object mask);
    private static void utimeUnix(string path, long atime_ns, long utime_ns);
    [DocumentationAttribute("utime(path, times=None, *[, ns], dir_fd=None, follow_symlinks=True)")]
public static void utime(string path, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void utime(Bytes path, IDictionary`2<string, object> kwargs, Object[] args);
    [DocumentationAttribute("")]
public static void utime(CodeContext context, IBufferProtocol path, IDictionary`2<string, object> kwargs, Object[] args);
    public static PythonTuple waitpid(int pid, int options);
    public static int write(CodeContext context, int fd, IBufferProtocol data);
    [DocumentationAttribute("Send signal sig to the process pid. Constants for the specific signals available on the host platform
are defined in the signal module.")]
public static void kill(CodeContext context, int pid, int sig);
    [DocumentationAttribute("WCOREDUMP(status) -> bool

Return True if the process returning 'status' was dumped to a core file.")]
[PythonHiddenAttribute("0")]
public static bool WCOREDUMP(int status);
    [DocumentationAttribute("WIFCONTINUED(status) -> bool

Return True if the process returning 'status' was continued from a
job control stop.")]
[PythonHiddenAttribute("0")]
public static bool WIFCONTINUED(int status);
    [DocumentationAttribute("WIFSTOPPED(status) -> bool

Return True if the process returning 'status' was stopped.")]
[PythonHiddenAttribute("0")]
public static bool WIFSTOPPED(int status);
    [DocumentationAttribute("WIFSIGNALED(status) -> bool

Return True if the process returning 'status' was terminated by a signal.")]
[PythonHiddenAttribute("0")]
public static bool WIFSIGNALED(int status);
    [DocumentationAttribute("WIFEXITED(status) -> bool

Return true if the process returning 'status' exited using the exit()
system call.")]
[PythonHiddenAttribute("0")]
public static bool WIFEXITED(int status);
    [DocumentationAttribute("WEXITSTATUS(status) -> integer

Return the process return code from 'status'.")]
[PythonHiddenAttribute("0")]
public static int WEXITSTATUS(int status);
    [DocumentationAttribute("WTERMSIG(status) -> integer

Return the signal that terminated the process that provided the 'status'
value.")]
[PythonHiddenAttribute("0")]
public static int WTERMSIG(int status);
    [DocumentationAttribute("WSTOPSIG(status) -> integer

Return the signal that stopped the process that provided
the 'status' value.")]
[PythonHiddenAttribute("0")]
public static int WSTOPSIG(int status);
    private static Exception ToPythonException(Exception e, string filename);
    [NullableContextAttribute("2")]
private static Exception IOExceptionToPythonException(IOException ioe, int error, string filename);
    private static void addBase(IEnumerable`1<string> files, PythonList ret);
    private static FileMode FileModeFromFlags(int flags);
    private static FileAccess FileAccessFromFlags(int flags);
    private static ProcessStartInfo GetProcessInfo(string command, bool throwException);
    private static bool TryGetExecutableCommand(string command, String& baseCommand, String& args);
    private static bool TryGetShellCommand(string command, String& baseCommand, String& args);
    private static Exception DirectoryExists();
    [NullableContextAttribute("2")]
private static Exception GetLastUnixError(string filename, string filename2);
    [NullableContextAttribute("2")]
private static Exception GetUnixError(int error, string filename, string filename2);
    private static int FormatMessage(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr arguments);
    internal static string GetMessage(int errorCode);
    [NullableContextAttribute("2")]
private static Exception GetLastWin32Error(string filename, string filename2);
    [NullableContextAttribute("2")]
private static Exception GetWin32Error(int error, string filename, string filename2);
    [ExtensionAttribute]
private static string ToFsString(Bytes b);
    [ExtensionAttribute]
private static Bytes ToFsBytes(string s);
    [ExtensionAttribute]
private static Bytes ToFsBytes(IBufferProtocol bp, CodeContext context);
    private static string ConvertToFsString(CodeContext context, object o, string argname, string methodname);
    [NullableContextAttribute("2")]
private static void CheckOptionalArgsCount(int numRegParms, int numOptPosParms, int numKwParms, int numOptPosArgs, int numKwArgs, string methodname);
    private static void VerifyPath(string path, string functionName, string argName);
    [CompilerGeneratedAttribute]
internal static bool <_getfullpathname>g__IsWindows|12_0();
    [CompilerGeneratedAttribute]
internal static bool <fstat>g__IsUnixStream|33_0(Stream stream);
    [CompilerGeneratedAttribute]
internal static void <link>g__linkWindows|39_0(string src, string dst);
    [CompilerGeneratedAttribute]
internal static void <link>g__linkUnix|39_1(string src, string dst);
    [CompilerGeneratedAttribute]
internal static void <symlink>g__symlinkUnix|54_0(string src, string dst);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Stream, Stream> <CreatePipeStreams>g__CreatePipeStreamsUnix|69_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static PythonTuple <utime>g__convertTimesToTuple|138_0(object val);
}
public static class IronPython.Modules.PythonOpcode : object {
    private static int POP_TOP;
    private static int ROT_TWO;
    private static int ROT_THREE;
    private static int DUP_TOP;
    private static int DUP_TOP_TWO;
    private static int ROT_FOUR;
    private static int NOP;
    private static int UNARY_POSITIVE;
    private static int UNARY_NEGATIVE;
    private static int UNARY_NOT;
    private static int UNARY_INVERT;
    private static int BINARY_MATRIX_MULTIPLY;
    private static int INPLACE_MATRIX_MULTIPLY;
    private static int BINARY_POWER;
    private static int BINARY_MULTIPLY;
    private static int BINARY_MODULO;
    private static int BINARY_ADD;
    private static int BINARY_SUBTRACT;
    private static int BINARY_SUBSCR;
    private static int BINARY_FLOOR_DIVIDE;
    private static int BINARY_TRUE_DIVIDE;
    private static int INPLACE_FLOOR_DIVIDE;
    private static int INPLACE_TRUE_DIVIDE;
    private static int GET_AITER;
    private static int GET_ANEXT;
    private static int BEFORE_ASYNC_WITH;
    private static int BEGIN_FINALLY;
    private static int END_ASYNC_FOR;
    private static int INPLACE_ADD;
    private static int INPLACE_SUBTRACT;
    private static int INPLACE_MULTIPLY;
    private static int INPLACE_MODULO;
    private static int STORE_SUBSCR;
    private static int DELETE_SUBSCR;
    private static int BINARY_LSHIFT;
    private static int BINARY_RSHIFT;
    private static int BINARY_AND;
    private static int BINARY_XOR;
    private static int BINARY_OR;
    private static int INPLACE_POWER;
    private static int GET_ITER;
    private static int GET_YIELD_FROM_ITER;
    private static int PRINT_EXPR;
    private static int LOAD_BUILD_CLASS;
    private static int YIELD_FROM;
    private static int GET_AWAITABLE;
    private static int INPLACE_LSHIFT;
    private static int INPLACE_RSHIFT;
    private static int INPLACE_AND;
    private static int INPLACE_XOR;
    private static int INPLACE_OR;
    private static int WITH_CLEANUP_START;
    private static int WITH_CLEANUP_FINISH;
    private static int RETURN_VALUE;
    private static int IMPORT_STAR;
    private static int SETUP_ANNOTATIONS;
    private static int YIELD_VALUE;
    private static int POP_BLOCK;
    private static int END_FINALLY;
    private static int POP_EXCEPT;
    private static int HAVE_ARGUMENT;
    private static int STORE_NAME;
    private static int DELETE_NAME;
    private static int UNPACK_SEQUENCE;
    private static int FOR_ITER;
    private static int UNPACK_EX;
    private static int STORE_ATTR;
    private static int DELETE_ATTR;
    private static int STORE_GLOBAL;
    private static int DELETE_GLOBAL;
    private static int LOAD_CONST;
    private static int LOAD_NAME;
    private static int BUILD_TUPLE;
    private static int BUILD_LIST;
    private static int BUILD_SET;
    private static int BUILD_MAP;
    private static int LOAD_ATTR;
    private static int COMPARE_OP;
    private static int IMPORT_NAME;
    private static int IMPORT_FROM;
    private static int JUMP_FORWARD;
    private static int JUMP_IF_FALSE_OR_POP;
    private static int JUMP_IF_TRUE_OR_POP;
    private static int JUMP_ABSOLUTE;
    private static int POP_JUMP_IF_FALSE;
    private static int POP_JUMP_IF_TRUE;
    private static int LOAD_GLOBAL;
    private static int SETUP_FINALLY;
    private static int LOAD_FAST;
    private static int STORE_FAST;
    private static int DELETE_FAST;
    private static int RAISE_VARARGS;
    private static int CALL_FUNCTION;
    private static int MAKE_FUNCTION;
    private static int BUILD_SLICE;
    private static int LOAD_CLOSURE;
    private static int LOAD_DEREF;
    private static int STORE_DEREF;
    private static int DELETE_DEREF;
    private static int CALL_FUNCTION_KW;
    private static int CALL_FUNCTION_EX;
    private static int SETUP_WITH;
    private static int EXTENDED_ARG;
    private static int LIST_APPEND;
    private static int SET_ADD;
    private static int MAP_ADD;
    private static int LOAD_CLASSDEREF;
    private static int BUILD_LIST_UNPACK;
    private static int BUILD_MAP_UNPACK;
    private static int BUILD_MAP_UNPACK_WITH_CALL;
    private static int BUILD_TUPLE_UNPACK;
    private static int BUILD_SET_UNPACK;
    private static int SETUP_ASYNC_WITH;
    private static int FORMAT_VALUE;
    private static int BUILD_CONST_KEY_MAP;
    private static int BUILD_STRING;
    private static int BUILD_TUPLE_UNPACK_WITH_CALL;
    private static int LOAD_METHOD;
    private static int CALL_METHOD;
    private static int CALL_FINALLY;
    private static int POP_FINALLY;
    private static int PY_INVALID_STACK_EFFECT;
    private static int FVC_MASK;
    private static int FVC_NONE;
    private static int FVC_STR;
    private static int FVC_REPR;
    private static int FVC_ASCII;
    private static int FVS_MASK;
    private static int FVS_HAVE_SPEC;
    private static PythonOpcode();
    public static int stack_effect(CodeContext context, int opcode, object oparg);
    private static int stack_effect(int opcode, int oparg, int jump);
}
public static class IronPython.Modules.PythonOperator : object {
    public static string __doc__;
    public static object lt(CodeContext context, object a, object b);
    public static object le(CodeContext context, object a, object b);
    public static object eq(CodeContext context, object a, object b);
    public static object ne(CodeContext context, object a, object b);
    public static object ge(CodeContext context, object a, object b);
    public static object gt(CodeContext context, object a, object b);
    public static bool not_(object o);
    public static bool truth(object o);
    public static object is_(object a, object b);
    public static object is_not(object a, object b);
    public static object abs(CodeContext context, object o);
    public static object add(CodeContext context, object a, object b);
    public static object and_(CodeContext context, object a, object b);
    public static object floordiv(CodeContext context, object a, object b);
    public static object inv(CodeContext context, object o);
    public static object invert(CodeContext context, object o);
    public static object lshift(CodeContext context, object a, object b);
    public static object mod(CodeContext context, object a, object b);
    public static object mul(CodeContext context, object a, object b);
    public static object neg(object o);
    public static object or_(CodeContext context, object a, object b);
    public static object pos(object o);
    public static object pow(CodeContext context, object a, object b);
    public static object rshift(CodeContext context, object a, object b);
    public static object sub(CodeContext context, object a, object b);
    public static object truediv(CodeContext context, object a, object b);
    public static object xor(CodeContext context, object a, object b);
    public static object concat(CodeContext context, object a, object b);
    public static bool contains(CodeContext context, object a, object b);
    public static int countOf(CodeContext context, object a, object b);
    public static void delitem(CodeContext context, object a, object b);
    public static object getitem(CodeContext context, object a, object b);
    public static int indexOf(CodeContext context, object a, object b);
    public static void setitem(CodeContext context, object a, object b, object c);
    private static bool isSequenceType(object o);
    public static object iadd(CodeContext context, object a, object b);
    public static object iand(CodeContext context, object a, object b);
    public static object ifloordiv(CodeContext context, object a, object b);
    public static object ilshift(CodeContext context, object a, object b);
    public static object imod(CodeContext context, object a, object b);
    public static object imul(CodeContext context, object a, object b);
    public static object ior(CodeContext context, object a, object b);
    public static object ipow(CodeContext context, object a, object b);
    public static object irshift(CodeContext context, object a, object b);
    public static object isub(CodeContext context, object a, object b);
    public static object itruediv(CodeContext context, object a, object b);
    public static object ixor(CodeContext context, object a, object b);
    public static object iconcat(CodeContext context, object a, object b);
    public static object index(object a);
    [DocumentationAttribute("compare_digest(a, b)-> bool

Return 'a == b'.  This function uses an approach designed to prevent
timing analysis, making it appropriate for cryptography.
a and b must both be of the same type: either str (ASCII only),
or any type that supports the buffer protocol (e.g. bytes).

Note: If a and b are of different lengths, or if an error occurs,
a timing attack could theoretically reveal information about the
types and lengths of a and b--but not their values.")]
public static bool _compare_digest(object a, object b);
    private static bool CompareBytes(IEnumerable`1<byte> a, IEnumerable`1<byte> b);
    private static void TestBothSequence(object a, object b);
}
public static class IronPython.Modules.PythonPwd : object {
    public static string __doc__;
    private static struct_passwd Make(IntPtr pwd);
    [DocumentationAttribute("Return the password database entry for the given numeric user ID.")]
public static struct_passwd getpwuid(object uid);
    [DocumentationAttribute("Return the password database entry for the given user name.")]
public static struct_passwd getpwnam(string name);
    [DocumentationAttribute("Return a list of all available password database entries, in arbitrary order.")]
public static PythonList getpwall();
    private static IntPtr _getpwuid(int uid);
    private static IntPtr _getpwnam(string name);
    private static void setpwent();
    private static IntPtr getpwent();
}
public static class IronPython.Modules.PythonRandom : object {
    public static string __doc__;
}
public static class IronPython.Modules.PythonRegex : object {
    private static CacheDict`2<PatternKey, Pattern> _cachedPatterns;
    private static Random r;
    public static int I;
    public static int L;
    public static int M;
    public static int S;
    public static int U;
    public static int X;
    public static int A;
    public static int IGNORECASE;
    public static int LOCALE;
    public static int MULTILINE;
    public static int DOTALL;
    public static int UNICODE;
    public static int VERBOSE;
    public static int ASCII;
    public static string engine;
    private static Char[] _endOfLineChars;
    private static Char[] _preParsedChars;
    private static string _mangledNamedGroup;
    private static PythonRegex();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static Pattern compile(CodeContext context, object pattern, int flags);
    public static string escape(string text);
    public static PythonList findall(CodeContext context, object pattern, object string, int flags);
    public static object finditer(CodeContext context, object pattern, object string, int flags);
    public static Match match(CodeContext context, object pattern, object string, int flags);
    public static Match fullmatch(CodeContext context, object pattern, object string, int flags);
    public static Match search(CodeContext context, object pattern, object string, int flags);
    public static PythonList split(CodeContext context, object pattern, object string, int maxsplit, int flags);
    public static object sub(CodeContext context, object pattern, object repl, object string, int count, int flags);
    public static object subn(CodeContext context, object pattern, object repl, object string, int count, int flags);
    public static void purge();
    public static PythonTuple _pickle(CodeContext context, Pattern pattern);
    private static Pattern GetPattern(CodeContext context, object pattern, int flags, bool compiled);
    [IteratorStateMachineAttribute("IronPython.Modules.PythonRegex/<MatchIterator>d__34")]
private static IEnumerator MatchIterator(MatchCollection matches, Pattern pattern, string input);
    private static RegexOptions FlagsToOption(ReFlags flags);
    private static ParsedRegex PreParseRegex(CodeContext context, string pattern, bool verbose);
    private static void RemoveOption(String& pattern, Int32& nameIndex);
    private static string GetRandomString();
    private static string UnescapeGroups(Match m, string text);
    private static PythonType error(CodeContext context);
    [CompilerGeneratedAttribute]
internal static string <PreParseRegex>g__ApplyVerbose|40_0(string pattern);
}
public static class IronPython.Modules.PythonSelect : object {
    public static string __doc__;
    public static PythonType error { get; }
    public static PythonType get_error();
    [DocumentationAttribute("select(iwtd, owtd, ewtd[, timeout]) -> readlist, writelist, errlist

Block until sockets are available for reading or writing, until an error
occurs, or until a the timeout expires. The first three parameters are
sequences of socket objects (opened using the socket module). The last is a
timeout value, given in seconds as a float. If timeout is omitted, select()
blocks until at least one socket is ready. A timeout of zero never blocks, but
can be used for polling.

The return value is a tuple of lists of sockets that are ready (subsets of
iwtd, owtd, and ewtd). If the timeout occurs before any sockets are ready, a
tuple of three empty lists is returned.

Note that select() on IronPython works only with sockets; it will not work with
files or other objects.")]
public static PythonTuple select(CodeContext context, object iwtd, object owtd, object ewtd, object timeout);
    private static PythonTuple SocketExceptionToTuple(SocketException e);
    private static Exception MakeException(CodeContext context, object value);
    private static void ProcessSocketSequence(CodeContext context, object sequence, PythonList& socketList, Dictionary`2& socketToOriginal);
    private static Socket ObjectToSocket(CodeContext context, object obj);
}
public static class IronPython.Modules.PythonSha : object {
    public static string __doc__;
    private static int DIGEST_SIZE;
    private static int BLOCK_SIZE;
    [DocumentationAttribute("sha1([data]) -> object (object used to calculate hash)")]
public static SHA1Type sha1(IBufferProtocol data);
    public static SHA1Type sha1(string data);
    [DocumentationAttribute("sha1([data]) -> object (object used to calculate hash)")]
public static SHA1Type sha1();
}
[DocumentationAttribute("SHA256 hash algorithm")]
public static class IronPython.Modules.PythonSha256 : object {
    private static int BLOCK_SIZE;
    public static string __doc__;
    public static SHA256Type sha256(IBufferProtocol data);
    public static SHA256Type sha256(string data);
    public static SHA256Type sha256();
    public static SHA224Type sha224(IBufferProtocol data);
    public static SHA256Type sha224(string data);
    public static SHA224Type sha224();
}
[DocumentationAttribute("SHA512 hash algorithm")]
public static class IronPython.Modules.PythonSha512 : object {
    private static int BLOCK_SIZE;
    public static string __doc__;
    public static SHA384Type sha384(IBufferProtocol data);
    public static SHA384Type sha384(string data);
    public static SHA384Type sha384();
    public static SHA512Type sha512(IBufferProtocol data);
    public static SHA512Type sha512(string data);
    public static SHA512Type sha512();
}
public static class IronPython.Modules.PythonSignal : object {
    public static string __doc__;
    public static int NSIG;
    public static int SIGABRT;
    public static int SIGBREAK;
    public static int SIGFPE;
    public static int SIGILL;
    public static int SIGINT;
    public static int SIGSEGV;
    public static int SIGTERM;
    public static int SIG_DFL;
    public static int SIG_IGN;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int CTRL_C_EVENT;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int CTRL_BREAK_EVENT;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int CTRL_CLOSE_EVENT;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int CTRL_LOGOFF_EVENT;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static int CTRL_SHUTDOWN_EVENT;
    public static BuiltinFunction default_int_handler;
    private static object _PythonSignalStateKey;
    private static Int32[] _PySupportedSignals;
    private static PythonSignal();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    private static PythonSignalState MakeSignalState(PythonContext context);
    private static PythonSignalState MakeNtSignalState(PythonContext context);
    private static PythonSignalState MakePosixSignalState(PythonContext context);
    [PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DocumentationAttribute("default_int_handler(...)

The default handler for SIGINT installed by Python.
It raises KeyboardInterrupt.")]
public static object default_int_handlerImpl(int signalnum, TraceBackFrame frame);
    [DocumentationAttribute("getsignal(sig) -> action

Return the current action for the given signal.  The return value can be:
SIG_IGN -- if the signal is being ignored
SIG_DFL -- if the default action for the signal is in effect
None -- if an unknown handler is in effect
anything else -- the callable Python object used as a handler")]
public static object getsignal(CodeContext context, int signalnum);
    [DocumentationAttribute("signal(sig, action) -> action

Set the action for the given signal.  The action can be SIG_DFL,
SIG_IGN, or a callable Python object.  The previous action is
returned.  See getsignal() for possible return values.

*** IMPORTANT NOTICE ***
A signal handler function is called with two arguments:
the first is the signal number, the second is the interrupted stack frame.")]
public static object signal(CodeContext context, int sig, object action);
    [DocumentationAttribute("NOT YET IMPLEMENTED

set_wakeup_fd(fd) -> fd

Sets the fd to be written to (with '\0') when a signal
comes in.  A library can use this to wakeup select or poll.
The previous fd is returned.

The fd must be non-blocking.")]
public static void set_wakeup_fd(CodeContext context, UInt32 fd);
    private static PythonSignalState GetPythonSignalState(CodeContext context);
    private static void SetPythonSignalState(CodeContext context, PythonSignalState pss);
}
public static class IronPython.Modules.PythonSocket : object {
    private static object _defaultTimeoutKey;
    private static object _defaultBufsizeKey;
    private static int DefaultBufferSize;
    public static PythonTuple _delegate_methods;
    public static string __doc__;
    public static PythonType SocketType;
    private static string AnyAddrToken;
    private static string BroadcastAddrToken;
    private static string LocalhostAddrToken;
    private static int IPv4AddrBytes;
    private static int IPv6AddrBytes;
    private static double MillisecondsPerSecond;
    public static object _GLOBAL_DEFAULT_TIMEOUT;
    public static int AF_APPLETALK;
    public static int AF_DECnet;
    public static int AF_INET;
    public static int AF_INET6;
    public static int AF_IPX;
    public static int AF_IRDA;
    public static int AF_SNA;
    public static int AF_UNSPEC;
    public static int AI_CANONNAME;
    public static int AI_NUMERICHOST;
    public static int AI_PASSIVE;
    public static int EAI_AGAIN;
    public static int EAI_BADFLAGS;
    public static int EAI_FAIL;
    public static int EAI_FAMILY;
    public static int EAI_MEMORY;
    public static int EAI_NODATA;
    public static int EAI_NONAME;
    public static int EAI_SERVICE;
    public static int EAI_SOCKTYPE;
    public static int EAI_SYSTEM;
    public static int EBADF;
    public static int INADDR_ALLHOSTS_GROUP;
    public static int INADDR_ANY;
    public static int INADDR_BROADCAST;
    public static int INADDR_LOOPBACK;
    public static int INADDR_MAX_LOCAL_GROUP;
    public static int INADDR_NONE;
    public static int INADDR_UNSPEC_GROUP;
    public static int IPPORT_RESERVED;
    public static int IPPORT_USERRESERVED;
    public static int IPPROTO_AH;
    public static int IPPROTO_DSTOPTS;
    public static int IPPROTO_ESP;
    public static int IPPROTO_FRAGMENT;
    public static int IPPROTO_GGP;
    public static int IPPROTO_HOPOPTS;
    public static int IPPROTO_ICMP;
    public static int IPPROTO_ICMPV6;
    public static int IPPROTO_IDP;
    public static int IPPROTO_IGMP;
    public static int IPPROTO_IP;
    public static int IPPROTO_IPV4;
    public static int IPPROTO_IPV6;
    public static int IPPROTO_MAX;
    public static int IPPROTO_ND;
    public static int IPPROTO_NONE;
    public static int IPPROTO_PUP;
    public static int IPPROTO_RAW;
    public static int IPPROTO_ROUTING;
    public static int IPPROTO_TCP;
    public static int IPPROTO_UDP;
    public static int IPV6_HOPLIMIT;
    public static int IPV6_JOIN_GROUP;
    public static int IPV6_LEAVE_GROUP;
    public static int IPV6_MULTICAST_HOPS;
    public static int IPV6_MULTICAST_IF;
    public static int IPV6_MULTICAST_LOOP;
    public static int IPV6_PKTINFO;
    public static int IPV6_UNICAST_HOPS;
    public static int IP_ADD_MEMBERSHIP;
    public static int IP_DROP_MEMBERSHIP;
    public static int IP_HDRINCL;
    public static int IP_MULTICAST_IF;
    public static int IP_MULTICAST_LOOP;
    public static int IP_MULTICAST_TTL;
    public static int IP_OPTIONS;
    public static int IP_TOS;
    public static int IP_TTL;
    public static int MSG_DONTROUTE;
    public static int MSG_OOB;
    public static int MSG_PEEK;
    public static int NI_DGRAM;
    public static int NI_MAXHOST;
    public static int NI_MAXSERV;
    public static int NI_NAMEREQD;
    public static int NI_NOFQDN;
    public static int NI_NUMERICHOST;
    public static int NI_NUMERICSERV;
    public static int SHUT_RD;
    public static int SHUT_RDWR;
    public static int SHUT_WR;
    public static int SOCK_DGRAM;
    public static int SOCK_RAW;
    public static int SOCK_RDM;
    public static int SOCK_SEQPACKET;
    public static int SOCK_STREAM;
    public static int SOL_IP;
    public static int SOL_IPV6;
    public static int SOL_SOCKET;
    public static int SOL_TCP;
    public static int SOL_UDP;
    public static int SOMAXCONN;
    public static int SO_ACCEPTCONN;
    public static int SO_BROADCAST;
    public static int SO_DEBUG;
    public static int SO_DONTROUTE;
    public static int SO_ERROR;
    public static int SO_EXCLUSIVEADDRUSE;
    public static int SO_KEEPALIVE;
    public static int SO_LINGER;
    public static int SO_OOBINLINE;
    public static int SO_RCVBUF;
    public static int SO_RCVLOWAT;
    public static int SO_RCVTIMEO;
    public static int SO_REUSEADDR;
    public static int SO_SNDBUF;
    public static int SO_SNDLOWAT;
    public static int SO_SNDTIMEO;
    public static int SO_TYPE;
    public static int SO_USELOOPBACK;
    public static int TCP_NODELAY;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static BigInteger SIO_RCVALL;
    [SupportedOSPlatformAttribute("windows")]
[PythonHiddenAttribute("1")]
public static BigInteger SIO_KEEPALIVE_VALS;
    public static int RCVALL_ON;
    public static int RCVALL_OFF;
    public static int RCVALL_SOCKETLEVELONLY;
    public static int RCVALL_MAX;
    public static int has_ipv6;
    public static PythonType error { get; }
    private static PythonSocket();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static PythonType get_error();
    [DocumentationAttribute("Connect to *address* and return the socket object.

Convenience function.  Connect to *address* (a 2-tuple ``(host,
port)``) and return the socket object.  Passing the optional
*timeout* parameter will set the timeout on the socket instance
before attempting to connect.  If no *timeout* is supplied, the
global default timeout setting returned by :func:`getdefaulttimeout`
is used.
")]
public static socket create_connection(CodeContext context, PythonTuple address);
    [DocumentationAttribute("Connect to *address* and return the socket object.

Convenience function.  Connect to *address* (a 2-tuple ``(host,
port)``) and return the socket object.  Passing the optional
*timeout* parameter will set the timeout on the socket instance
before attempting to connect.  If no *timeout* is supplied, the
global default timeout setting returned by :func:`getdefaulttimeout`
is used.
")]
public static socket create_connection(CodeContext context, PythonTuple address, object timeout);
    public static socket create_connection(CodeContext context, PythonTuple address, object timeout, PythonTuple source_address);
    [DocumentationAttribute("")]
public static PythonList getaddrinfo(CodeContext context, string host, object port, int family, int socktype, int proto, int flags);
    [DocumentationAttribute("")]
public static PythonList getaddrinfo(CodeContext context, Bytes host, object port, int family, int socktype, int proto, int flags);
    private static PythonType gaierror(CodeContext context);
    [DocumentationAttribute("getfqdn([hostname_or_ip]) -> hostname

Return the fully-qualified domain name for the specified hostname or IP
address. An unspecified or empty name is interpreted as the local host. If the
name lookup fails, the passed-in name is returned as-is.")]
public static string getfqdn(string host);
    [DocumentationAttribute("")]
public static string getfqdn();
    [DocumentationAttribute("gethostbyname(hostname) -> ip address

Return the string IPv4 address associated with the given hostname (e.g.
'10.10.0.1'). The hostname is returned as-is if it an IPv4 address. The empty
string is treated as the local host.

gethostbyname() doesn't support IPv6; for IPv4/IPv6 support, use getaddrinfo().")]
public static string gethostbyname(CodeContext context, string host);
    [DocumentationAttribute("gethostbyname_ex(hostname) -> (hostname, aliases, ip_addresses)

Return the real host name, a list of aliases, and a list of IP addresses
associated with the given hostname. If the hostname is an IPv4 address, the
tuple ([hostname, [], [hostname]) is returned without doing a DNS lookup.

gethostbyname_ex() doesn't support IPv6; for IPv4/IPv6 support, use
getaddrinfo().")]
public static PythonTuple gethostbyname_ex(CodeContext context, string host);
    [DocumentationAttribute("gethostname() -> hostname
Return this machine's hostname")]
public static string gethostname();
    [DocumentationAttribute("gethostbyaddr(host) -> (hostname, aliases, ipaddrs)

Return a tuple of (primary hostname, alias hostnames, ip addresses). host may
be either a hostname or an IP address.")]
public static object gethostbyaddr(CodeContext context, string host);
    [DocumentationAttribute("getnameinfo(socketaddr, flags) -> (host, port)
Given a socket address, the return a tuple of the corresponding hostname and
port. Available flags:
 - NI_NOFQDN: Return only the hostname part of the domain name for hosts on the
   same domain as the executing machine.
 - NI_NUMERICHOST: return the numeric form of the host (e.g. '127.0.0.1' or
   '::1' rather than 'localhost').
 - NI_NAMEREQD: Raise an error if the hostname cannot be looked up.
 - NI_NUMERICSERV: Return string containing the numeric form of the port (e.g.
   '80' rather than 'http'). This flag is required (see below).
 - NI_DGRAM: Silently ignored (see below).

")]
public static object getnameinfo(CodeContext context, PythonTuple socketAddr, int flags);
    [DocumentationAttribute("getprotobyname(protoname) -> integer proto

Given a string protocol name (e.g. "udp"), return the associated integer
protocol number, suitable for passing to socket(). The name is case
insensitive.

Raises socket.error if no protocol number can be found.")]
public static object getprotobyname(CodeContext context, string protocolName);
    [DocumentationAttribute("getservbyname(service_name[, protocol_name]) -> port

Return a port number from a service name and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.")]
public static int getservbyname(CodeContext context, string serviceName, string protocolName);
    [DocumentationAttribute("getservbyport(port[, protocol_name]) -> service_name

Return a service name from a port number and protocol name.
The optional protocol name, if given, should be 'tcp' or 'udp',
otherwise any protocol will match.")]
public static string getservbyport(CodeContext context, int port, string protocolName);
    [DocumentationAttribute("ntohl(x) -> integer

Convert a 32-bit integer from network byte order to host byte order.")]
public static object ntohl(object x);
    [DocumentationAttribute("ntohs(x) -> integer

Convert a 16-bit integer from network byte order to host byte order.")]
public static int ntohs(object x);
    [DocumentationAttribute("htonl(x) -> integer

Convert a 32bit integer from host byte order to network byte order.")]
public static object htonl(object x);
    [DocumentationAttribute("htons(x) -> integer

Convert a 16-bit integer from host byte order to network byte order.")]
public static int htons(object x);
    private static int SignInsensitiveToInt32(object x);
    private static short SignInsensitiveToInt16(object x);
    [DocumentationAttribute("inet_pton(addr_family, ip_string) -> packed_ip

Convert an IP address (in string format, e.g. '127.0.0.1' or '::1') to a 32-bit
packed binary format, as 4-byte (IPv4) or 16-byte (IPv6) string. The return
format matches the format of the standard C library's in_addr or in6_addr
struct.

If the address format is invalid, socket.error will be raised. Validity is
determined by the .NET System.Net.IPAddress.Parse() method.

inet_pton() supports IPv4 and IPv6.")]
public static string inet_pton(CodeContext context, int addressFamily, string ipString);
    [DocumentationAttribute("inet_ntop(address_family, packed_ip) -> ip_string

Convert a packed IP address (a 4-byte [IPv4] or 16-byte [IPv6] string) to a
string IP address (e.g. '127.0.0.1' or '::1').

The input format matches the format of the standard C library's in_addr or
in6_addr struct. If the input string is not exactly 4 bytes or 16 bytes,
socket.error will be raised.

inet_ntop() supports IPv4 and IPv6.")]
public static string inet_ntop(CodeContext context, int addressFamily, Bytes packedIP);
    [DocumentationAttribute("inet_aton(ip_string) -> packed_ip
Convert an IP address (in string dotted quad format, e.g. '127.0.0.1') to a
32-bit packed binary format, as four-character string. The return format
matches the format of the standard C library's in_addr struct.

If the address format is invalid, socket.error will be raised. Validity is
determined by the .NET System.Net.IPAddress.Parse() method.

inet_aton() supports only IPv4.")]
public static string inet_aton(CodeContext context, string ipString);
    [DocumentationAttribute("inet_ntoa(packed_ip) -> ip_string

Convert a packed IP address (a 4-byte string) to a string IP address (in dotted
quad format, e.g. '127.0.0.1'). The input format matches the format of the
standard C library's in_addr struct.

If the input string is not exactly 4 bytes, socket.error will be raised.

inet_ntoa() supports only IPv4.")]
public static string inet_ntoa(CodeContext context, Bytes packedIP);
    [DocumentationAttribute("getdefaulttimeout() -> timeout

Return the default timeout for new socket objects in seconds as a float. A
value of None means that sockets have no timeout and begin in blocking mode.
The default value when the module is imported is None.")]
public static object getdefaulttimeout(CodeContext context);
    [DocumentationAttribute("setdefaulttimeout(timeout) -> None

Set the default timeout for new socket objects. timeout must be either None,
meaning that sockets have no timeout and start in blocking mode, or a
non-negative float that specifies the default timeout in seconds.")]
public static void setdefaulttimeout(CodeContext context, object timeout);
    internal static Exception MakeException(CodeContext context, Exception exception);
    private static string IPv6BytesToColonHex(Byte[] ipBytes);
    private static string ConvertSpecialAddresses(string host);
    private static IPAddress HostToAddress(CodeContext context, string host, AddressFamily family);
    private static IPAddress[] HostToAddresses(CodeContext context, string host, AddressFamily family);
    private static string RemoveLocalDomain(string fqdn);
    private static IPEndPoint TupleToEndPoint(CodeContext context, PythonTuple address, AddressFamily family, String& host);
    private static PythonTuple EndPointToTuple(IPEndPoint endPoint);
    private static Nullable`1<int> GetDefaultTimeout(CodeContext context);
    private static void SetDefaultTimeout(CodeContext context, Nullable`1<int> timeout);
    private static PythonType herror(CodeContext context);
    private static PythonType timeout(CodeContext context);
    [CompilerGeneratedAttribute]
internal static int <getaddrinfo>g__ParsePort|20_0(CodeContext context, string port);
}
public static class IronPython.Modules.PythonSpwd : object {
    public static string __doc__;
    private static struct_spwd Make(IntPtr pwd);
    [DocumentationAttribute("Return the shadow password database entry for the given user name.")]
public static struct_spwd getspnam(string name);
    [DocumentationAttribute("Return a list of all available shadow password database entries, in arbitrary order.")]
public static PythonList getspall();
    private static IntPtr _getspnam(string name);
    private static void setspent();
    private static IntPtr getspent();
}
public static class IronPython.Modules.PythonSRegEx : object {
    public static string __doc__;
    public static int MAGIC;
    public static int CODESIZE;
    public static int MAXREPEAT;
    public static object getlower(CodeContext context, object val, object encoding);
    public static object compile(object a, object b, object c);
}
public static class IronPython.Modules.PythonSsl : object {
    public static string __doc__;
    public static int OPENSSL_VERSION_NUMBER;
    public static PythonTuple OPENSSL_VERSION_INFO;
    public static object _OPENSSL_API_VERSION;
    public static string OPENSSL_VERSION;
    private static List`1<Asn1Object> _asn1Objects;
    private static int ClassOffset;
    private static int ClassMask;
    private static int ClassUniversal;
    private static int ClassApplication;
    private static int ClassContextSpecific;
    private static int ClassPrivate;
    private static int NumberMask;
    private static int UnivesalSequence;
    private static int UniversalInteger;
    private static int UniversalOctetString;
    public static int CERT_NONE;
    public static int CERT_OPTIONAL;
    public static int CERT_REQUIRED;
    public static int PROTOCOL_SSLv2;
    public static int PROTOCOL_SSLv3;
    public static int PROTOCOL_SSLv23;
    public static int PROTOCOL_TLSv1;
    public static int PROTOCOL_TLSv1_1;
    public static int PROTOCOL_TLSv1_2;
    public static UInt32 OP_ALL;
    public static UInt32 OP_DONT_INSERT_EMPTY_FRAGMENTS;
    public static int OP_NO_SSLv2;
    public static int OP_NO_SSLv3;
    public static int OP_NO_TLSv1;
    public static int OP_NO_TLSv1_1;
    public static int OP_NO_TLSv1_2;
    internal static int OP_NO_COMPRESSION;
    internal static int OP_NO_ALL;
    public static int SSL_ERROR_SSL;
    public static int SSL_ERROR_WANT_READ;
    public static int SSL_ERROR_WANT_WRITE;
    public static int SSL_ERROR_WANT_X509_LOOKUP;
    public static int SSL_ERROR_SYSCALL;
    public static int SSL_ERROR_ZERO_RETURN;
    public static int SSL_ERROR_WANT_CONNECT;
    public static int SSL_ERROR_EOF;
    public static int SSL_ERROR_INVALID_ERROR_CODE;
    public static int VERIFY_DEFAULT;
    public static int VERIFY_CRL_CHECK_LEAF;
    public static int VERIFY_CRL_CHECK_CHAIN;
    public static int VERIFY_X509_STRICT;
    public static int VERIFY_X509_TRUSTED_FIRST;
    public static bool HAS_SNI;
    public static bool HAS_ECDH;
    public static bool HAS_NPN;
    public static bool HAS_ALPN;
    public static bool HAS_TLS_UNIQUE;
    private static int SSL_VERIFY_NONE;
    private static int SSL_VERIFY_PEER;
    private static int SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    private static int SSL_VERIFY_CLIENT_ONCE;
    private static PythonSsl();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static void RAND_add(object buf, double entropy);
    public static int RAND_status();
    public static object RAND_bytes(int num);
    public static object RAND_pseudo_bytes(int num);
    public static object txt2obj(CodeContext context, string txt, bool name);
    public static object nid2obj(CodeContext context, int nid);
    public static PythonList enum_certificates(string store_name);
    public static PythonList enum_crls(string store_name);
    internal static PythonType SSLError(CodeContext context);
    public static PythonDictionary _test_decode_cert(CodeContext context, string path);
    private static PythonDictionary CertificateToPython(CodeContext context, X509Certificate cert);
    private static PythonDictionary CertificateToPython(CodeContext context, X509Certificate2 cert);
    private static void AddSubjectAltNames(CommonDictionaryStorage dict, X509Certificate2 cert2);
    private static string SerialNumberToPython(X509Certificate2 cert);
    [IteratorStateMachineAttribute("IronPython.Modules.PythonSsl/<IssuerParts>d__24")]
private static IEnumerable`1<string> IssuerParts(string issuer);
    private static PythonTuple IssuerToPython(CodeContext context, string issuer);
    private static PythonTuple IssuerFieldToPython(CodeContext context, string p);
    private static X509Certificate2 ReadCertificate(CodeContext context, string filename);
    private static RSACryptoServiceProvider ParsePkcs1DerEncodedPrivateKey(CodeContext context, string filename, Byte[] x);
    private static Byte[] ReadUnivesalIntAsBytes(Byte[] x, Int32& offset);
    private static void ReadIntType(Byte[] x, Int32& offset);
    private static int ReadUnivesalInt(Byte[] x, Int32& offset);
    private static int ReadLength(Byte[] x, Int32& offset);
    private static int ReadInt(Byte[] x, Int32& offset, int bytes);
    private static int ReadInt(Byte[] x, Int32& offset);
    private static string ReadToEnd(String[] lines, Int32& start, string end);
    private static Exception ErrorDecoding(CodeContext context, Object[] args);
    [CompilerGeneratedAttribute]
internal static string <CertificateToPython>g__ToPythonDateFormat|21_0(DateTime date);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class IronPython.Modules.PythonString : object {
    public static IEnumerable`1<PythonTuple> formatter_parser(string self);
    public static PythonTuple formatter_field_name_split(string self);
}
[ExtensionAttribute]
public static class IronPython.Modules.PythonStruct : object {
    public static string __doc__;
    private static int MAX_CACHE_SIZE;
    private static CacheDict`2<string, Struct> _cache;
    private static PythonStruct();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    private static int GetNativeSize(FormatType c);
    private static string FormatObjectToString(object fmt);
    private static Struct GetStructFromCache(CodeContext context, object fmt);
    [DocumentationAttribute("Clear the internal cache.")]
public static void _clearcache();
    [DocumentationAttribute("int(x[, base]) -> integer

Convert a string or number to an integer, if possible.  A floating point
argument will be truncated towards zero (this does not include a string
representation of a floating point number!)  When converting a string, use
the optional base.  It is an error to supply a base when converting a
non-string.  If base is zero, the proper base is guessed based on the
string content.  If the argument is outside the integer range a
long object will be returned instead.")]
public static int calcsize(CodeContext context, object fmt);
    [DocumentationAttribute("Return string containing values v1, v2, ... packed according to fmt.")]
public static Bytes pack(CodeContext context, object fmt, Object[] values);
    [DocumentationAttribute("Pack the values v1, v2, ... according to fmt.
Write the packed bytes into the writable buffer buf starting at offset.")]
public static void pack_into(CodeContext context, object fmt, array buffer, int offset, Object[] args);
    public static void pack_into(CodeContext context, object fmt, ByteArray buffer, int offset, Object[] args);
    [DocumentationAttribute("Unpack the string containing packed C structure data, according to fmt.
Requires len(string) == calcsize(fmt).")]
public static PythonTuple unpack(CodeContext context, object fmt, IList`1<byte> buffer);
    [DocumentationAttribute("Unpack the string containing packed C structure data, according to fmt.
Requires len(string) == calcsize(fmt).")]
public static PythonTuple unpack(CodeContext context, object fmt, array buffer);
    [DocumentationAttribute("Unpack the buffer, containing packed C structure data, according to
fmt, starting at offset. Requires len(buffer[offset:]) >= calcsize(fmt).")]
public static PythonTuple unpack_from(CodeContext context, object fmt, IList`1<byte> buffer, int offset);
    [DocumentationAttribute("Unpack the buffer, containing packed C structure data, according to
fmt, starting at offset. Requires len(buffer[offset:]) >= calcsize(fmt).")]
public static PythonTuple unpack_from(CodeContext context, object fmt, array buffer, int offset);
    [DocumentationAttribute("Iteratively unpack the buffer, containing packed C structure data, according to
fmt, starting at offset. Requires len(buffer[offset:]) >= calcsize(fmt).")]
public static PythonUnpackIterator iter_unpack(CodeContext context, object fmt, IList`1<byte> buffer, int offset);
    [DocumentationAttribute("Iteratively unpack the buffer, containing packed C structure data, according to
fmt, starting at offset. Requires len(buffer[offset:]) >= calcsize(fmt).")]
public static PythonUnpackIterator iter_unpack(CodeContext context, object fmt, array buffer, int offset);
    [ExtensionAttribute]
private static void WriteByteCount(MemoryStream stream, byte value, int repeatCount);
    [ExtensionAttribute]
private static void WriteShort(MemoryStream res, bool fLittleEndian, short val);
    [ExtensionAttribute]
private static void WriteUShort(MemoryStream res, bool fLittleEndian, ushort val);
    [ExtensionAttribute]
private static void WriteInt(MemoryStream res, bool fLittleEndian, int val);
    [ExtensionAttribute]
private static void WriteUInt(MemoryStream res, bool fLittleEndian, UInt32 val);
    [ExtensionAttribute]
private static void WritePointer(MemoryStream res, bool fLittleEndian, ulong val);
    [ExtensionAttribute]
private static void WriteUnsignedNetPointer(MemoryStream res, bool fLittleEndian, UIntPtr val);
    [ExtensionAttribute]
private static void WriteSignedNetPointer(MemoryStream res, bool fLittleEndian, IntPtr val);
    [ExtensionAttribute]
private static void WriteFloat(MemoryStream res, bool fLittleEndian, float val);
    [ExtensionAttribute]
private static void WriteLong(MemoryStream res, bool fLittleEndian, long val);
    [ExtensionAttribute]
private static void WriteULong(MemoryStream res, bool fLittleEndian, ulong val);
    [ExtensionAttribute]
private static void WriteDouble(MemoryStream res, bool fLittleEndian, double val);
    [ExtensionAttribute]
private static void WriteString(MemoryStream res, int len, IList`1<byte> val);
    [ExtensionAttribute]
private static void WritePascalString(MemoryStream res, int len, IList`1<byte> val);
    internal static bool GetBoolValue(CodeContext context, int index, Object[] args);
    internal static char GetCharValue(CodeContext context, int index, Object[] args);
    internal static sbyte GetSByteValue(CodeContext context, int index, Object[] args);
    internal static byte GetByteValue(CodeContext context, int index, Object[] args);
    internal static short GetShortValue(CodeContext context, int index, Object[] args);
    internal static ushort GetUShortValue(CodeContext context, int index, Object[] args);
    internal static int GetIntValue(CodeContext context, int index, Object[] args);
    internal static UInt32 GetULongValue(CodeContext context, int index, Object[] args, string type);
    private static void CheckRange(CodeContext context, int val, string type);
    private static void CheckRange(CodeContext context, BigInteger bi, string type);
    private static void OutOfRange(CodeContext context, string type);
    internal static int GetSignedSizeT(CodeContext context, int index, Object[] args);
    internal static UInt32 GetSizeT(CodeContext context, int index, Object[] args);
    internal static ulong GetPointer(CodeContext context, int index, Object[] args);
    internal static IntPtr GetSignedNetPointer(CodeContext context, int index, Object[] args);
    internal static UIntPtr GetUnsignedNetPointer(CodeContext context, int index, Object[] args);
    internal static long GetLongValue(CodeContext context, int index, Object[] args);
    internal static ulong GetULongLongValue(CodeContext context, int index, Object[] args);
    internal static double GetDoubleValue(CodeContext context, int index, Object[] args);
    internal static IList`1<byte> GetStringValue(CodeContext context, int index, Object[] args);
    internal static object GetValue(CodeContext context, int index, Object[] args);
    internal static bool CreateBoolValue(CodeContext context, Int32& index, IList`1<byte> data);
    internal static byte CreateCharValue(CodeContext context, Int32& index, IList`1<byte> data);
    internal static short CreateShortValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static ushort CreateUShortValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static float CreateFloatValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static int CreateIntValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static UInt32 CreateUIntValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static long CreateLongValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static ulong CreateULongValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static double CreateDoubleValue(CodeContext context, Int32& index, bool fLittleEndian, IList`1<byte> data);
    internal static Bytes CreateString(CodeContext context, Int32& index, int count, IList`1<byte> data);
    internal static Bytes CreatePascalString(CodeContext context, Int32& index, int count, IList`1<byte> data);
    private static byte ReadData(CodeContext context, Int32& index, IList`1<byte> data);
    internal static int Align(int length, int size);
    private static Exception Error(CodeContext context, string msg);
}
public static class IronPython.Modules.PythonThread : object {
    public static string __doc__;
    private static object _stackSizeKey;
    private static object _threadCountKey;
    [ThreadStaticAttribute]
private static List`1<lock> _sentinelLocks;
    public static double TIMEOUT_MAX;
    public static PythonType LockType;
    private static PythonThread();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    [DocumentationAttribute("start_new_thread(function, [args, [kwDict]]) -> thread id
Creates a new thread running the given function")]
public static object start_new_thread(CodeContext context, object function, object args, object kwDict);
    [DocumentationAttribute("start_new_thread(function, args, [kwDict]) -> thread id
Creates a new thread running the given function")]
public static object start_new_thread(CodeContext context, object function, object args);
    public static void interrupt_main(CodeContext context);
    public static void exit();
    [DocumentationAttribute("allocate_lock() -> lock object
Allocates a new lock object that can be used for synchronization")]
public static object allocate_lock();
    public static object get_ident();
    public static int stack_size(CodeContext context);
    public static int stack_size(CodeContext context, int size);
    [DocumentationAttribute("start_new(function, [args, [kwDict]]) -> thread id
Creates a new thread running the given function")]
public static object start_new(CodeContext context, object function, object args);
    public static void exit_thread();
    public static object allocate();
    public static int _count(CodeContext context);
    [DocumentationAttribute("_set_sentinel() -> lock

Set a sentinel lock that will be released when the current thread
state is finalized (after it is untied from the interpreter).

This is a private API for the threading module.")]
public static object _set_sentinel(CodeContext context);
    private static Thread CreateThread(CodeContext context, ThreadStart start);
    private static int GetStackSize(CodeContext context);
    private static void SetStackSize(CodeContext context, int stackSize);
}
public static class IronPython.Modules.PythonTime : object {
    private static int YearIndex;
    private static int MonthIndex;
    private static int DayIndex;
    private static int HourIndex;
    private static int MinuteIndex;
    private static int SecondIndex;
    private static int WeekdayIndex;
    private static int DayOfYearIndex;
    private static int IsDaylightSavingsIndex;
    private static int MaxIndex;
    private static int minYear;
    private static double epochDifferenceDouble;
    private static long epochDifferenceLong;
    private static double ticksPerSecond;
    public static int altzone;
    public static int daylight;
    public static int timezone;
    public static PythonTuple tzname;
    public static int _STRUCT_TM_ITEMS;
    private static Stopwatch sw;
    public static string __doc__;
    private static PythonTime();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    internal static long TimestampToTicks(double seconds);
    internal static double TicksToTimestamp(long ticks);
    public static string asctime(CodeContext context);
    public static string asctime(CodeContext context, object time);
    public static double clock();
    public static double perf_counter();
    public static string ctime(CodeContext context);
    public static string ctime(CodeContext context, object seconds);
    public static void sleep(double tm);
    public static double monotonic();
    public static BigInteger monotonic_ns();
    public static double time();
    public static PythonTuple localtime();
    public static PythonTuple localtime(object seconds);
    public static PythonTuple gmtime();
    public static PythonTuple gmtime(object seconds);
    public static double mktime(CodeContext context, PythonTuple localTime);
    public static string strftime(CodeContext context, string format);
    public static string strftime(CodeContext context, string format, PythonTuple dateTime);
    public static object strptime(CodeContext context, string string);
    public static object strptime(CodeContext context, string string, string format);
    internal static Tuple`2<DateTime, Nullable`1<DayOfWeek>> _strptime(CodeContext context, string string, string format);
    private static String[] ExpandMicrosecondFormat(int fIdx, String[] formatParts);
    internal static string strftime(CodeContext context, string format, DateTime dt, Nullable`1<int> microseconds);
    internal static double DateTimeToTimestamp(DateTime dateTime);
    internal static DateTime TimestampToDateTime(double timeStamp);
    private static DateTime RemoveDst(DateTime dt);
    private static DateTime RemoveDst(DateTime dt, bool always);
    private static DateTime AddDst(DateTime dt);
    private static double GetTimestampFromObject(object seconds);
    private static void AddTime(List`1<FormatInfo> newFormat);
    private static void AddDate(List`1<FormatInfo> newFormat);
    private static List`1<FormatInfo> PythonFormatToCLIFormat(string format, bool forParse, Boolean& postProcess, FoundDateComponents& found);
    internal static int Weekday(DateTime dt);
    internal static int Weekday(DayOfWeek dayOfWeek);
    internal static int IsoWeekday(DateTime dt);
    internal static PythonTuple GetDateTimeTuple(DateTime dt);
    internal static PythonTuple GetDateTimeTuple(DateTime dt, Nullable`1<DayOfWeek> dayOfWeek);
    internal static PythonTuple GetDateTimeTuple(DateTime dt, Nullable`1<DayOfWeek> dayOfWeek, tzinfo tz);
    internal static struct_time GetDateTimeTuple(DateTime dt, bool dstMode);
    private static DateTime GetDateTimeFromTuple(CodeContext context, PythonTuple t);
    private static DateTime GetDateTimeFromTupleNoDst(CodeContext context, PythonTuple t);
    private static DateTime GetDateTimeFromTupleNoDst(CodeContext context, PythonTuple t, Int32[]& ints);
    private static Int32[] ValidateDateTimeTuple(CodeContext context, PythonTuple t);
    private static int FindFormat(List`1<FormatInfo> formatInfo, string format);
    private static void InitStopWatch();
}
public static class IronPython.Modules.PythonWarnings : object {
    public static string __doc__;
    private static object _keyFields;
    private static string _keyDefaultAction;
    private static string _keyFilters;
    private static string _keyOnceRegistry;
    private static PythonWarnings();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static void _filters_mutated();
    public static void warn(CodeContext context, object message, PythonType category, int stacklevel);
    public static void warn_explicit(CodeContext context, object message, PythonType category, string filename, int lineno, string module, PythonDictionary registry, object module_globals);
    internal static string formatwarning(object message, PythonType category, string filename, int lineno, string line);
    internal static void showwarning(CodeContext context, object message, PythonType category, string filename, int lineno, object file, string line);
}
public static class IronPython.Modules.PythonWeakRef : object {
    public static string __doc__;
    public static PythonType CallableProxyType;
    public static PythonType ProxyType;
    public static PythonType ReferenceType;
    private static PythonWeakRef();
    internal static IWeakReferenceable ConvertToWeakReferenceable(PythonContext context, object obj);
    public static int getweakrefcount(CodeContext context, object object);
    public static PythonList getweakrefs(CodeContext context, object object);
    public static object proxy(CodeContext context, object object);
    public static object proxy(CodeContext context, object object, object callback);
    public static void _remove_dead_weakref(CodeContext context, PythonDictionary dict, object key);
}
public static class IronPython.Modules.PythonWinApi : object {
    public static string __doc__;
    public static int CREATE_NEW_CONSOLE;
    public static int CREATE_NEW_PROCESS_GROUP;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_BROKEN_PIPE;
    public static int ERROR_IO_PENDING;
    public static int ERROR_MORE_DATA;
    public static int ERROR_NETNAME_DELETED;
    public static int ERROR_NO_DATA;
    public static int ERROR_NO_SYSTEM_RESOURCES;
    public static int ERROR_OPERATION_ABORTED;
    public static int ERROR_PIPE_BUSY;
    public static int ERROR_PIPE_CONNECTED;
    public static int ERROR_SEM_TIMEOUT;
    public static int FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static int FILE_FLAG_OVERLAPPED;
    public static int FILE_GENERIC_READ;
    public static int FILE_GENERIC_WRITE;
    public static int GENERIC_READ;
    public static int GENERIC_WRITE;
    public static int INFINITE;
    public static int NMPWAIT_WAIT_FOREVER;
    public static int NULL;
    public static int OPEN_EXISTING;
    public static int PIPE_ACCESS_DUPLEX;
    public static int PIPE_ACCESS_INBOUND;
    public static int PIPE_READMODE_MESSAGE;
    public static int PIPE_TYPE_MESSAGE;
    public static int PIPE_UNLIMITED_INSTANCES;
    public static int PIPE_WAIT;
    public static int PROCESS_ALL_ACCESS;
    public static int PROCESS_DUP_HANDLE;
    public static int STARTF_USESHOWWINDOW;
    public static int STARTF_USESTDHANDLES;
    public static int STD_ERROR_HANDLE;
    public static int STD_INPUT_HANDLE;
    public static int STD_OUTPUT_HANDLE;
    public static int STILL_ACTIVE;
    public static int SW_HIDE;
    public static int WAIT_ABANDONED_0;
    public static int WAIT_OBJECT_0;
    public static int WAIT_TIMEOUT;
    public static PythonTuple CreatePipe(CodeContext context, object pSec, int bufferSize);
    private static string FormatError(int errorCode);
    public static PythonTuple CreateProcess(CodeContext context, string applicationName, string commandLineArgs, object pSec, object tSec, Nullable`1<int> bInheritHandles, Nullable`1<UInt32> dwCreationFlags, object lpEnvironment, string lpCurrentDirectory, object lpStartupInfo);
    private static string EnvironmentToNative(CodeContext context, object environment);
    public static void CloseHandle(BigInteger handle);
    public static BigInteger DuplicateHandle(CodeContext context, BigInteger sourceProcess, BigInteger handle, BigInteger targetProcess, int desiredAccess, bool inherit_handle, object DUPLICATE_SAME_ACCESS);
    public static BigInteger GetCurrentProcess();
    public static int GetExitCodeProcess(BigInteger hProcess);
    public static string GetModuleFileName(object ignored);
    public static object GetStdHandle(int STD_OUTPUT_HANDLE);
    public static int GetVersion();
    public static bool TerminateProcess(BigInteger handle, object uExitCode);
    public static int WaitForSingleObject(BigInteger handle, int dwMilliseconds);
    private static bool CreateProcessPI(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES& lpProcessAttributes, SECURITY_ATTRIBUTES& lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, string lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    private static bool CreatePipePI(IntPtr& hReadPipe, IntPtr& hWritePipe, SECURITY_ATTRIBUTES& lpPipeAttributes, UInt32 nSize);
    private static bool DuplicateHandlePI(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, IntPtr& lpTargetHandle, UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwOptions);
    private static IntPtr GetCurrentProcessPI();
    internal static bool GetExitCodeProcessPI(IntPtr hProcess, Int32& lpExitCode);
    private static IntPtr GetStdHandlePI(int nStdHandle);
    private static int GetVersionPI();
    internal static bool CloseHandle(IntPtr hObject);
    private static bool TerminateProcessPI(IntPtr hProcess, UInt32 uExitCode);
    internal static int WaitForSingleObjectPI(IntPtr hHandle, int dwMilliseconds);
}
[SupportedOSPlatformAttribute("windows")]
public static class IronPython.Modules.PythonWinReg : object {
    public static string __doc__;
    public static PythonType error;
    public static BigInteger HKEY_CLASSES_ROOT;
    public static BigInteger HKEY_CURRENT_USER;
    public static BigInteger HKEY_LOCAL_MACHINE;
    public static BigInteger HKEY_USERS;
    public static BigInteger HKEY_PERFORMANCE_DATA;
    public static BigInteger HKEY_CURRENT_CONFIG;
    public static BigInteger HKEY_DYN_DATA;
    public static int KEY_QUERY_VALUE;
    public static int KEY_SET_VALUE;
    public static int KEY_CREATE_SUB_KEY;
    public static int KEY_ENUMERATE_SUB_KEYS;
    public static int KEY_NOTIFY;
    public static int KEY_CREATE_LINK;
    public static int KEY_ALL_ACCESS;
    public static int KEY_EXECUTE;
    public static int KEY_READ;
    public static int KEY_WRITE;
    public static int KEY_WOW64_64KEY;
    public static int KEY_WOW64_32KEY;
    public static int REG_CREATED_NEW_KEY;
    public static int REG_OPENED_EXISTING_KEY;
    public static int REG_NONE;
    public static int REG_SZ;
    public static int REG_EXPAND_SZ;
    public static int REG_BINARY;
    public static int REG_DWORD;
    public static int REG_DWORD_LITTLE_ENDIAN;
    public static int REG_DWORD_BIG_ENDIAN;
    public static int REG_LINK;
    public static int REG_MULTI_SZ;
    public static int REG_RESOURCE_LIST;
    public static int REG_FULL_RESOURCE_DESCRIPTOR;
    public static int REG_RESOURCE_REQUIREMENTS_LIST;
    public static int REG_NOTIFY_CHANGE_NAME;
    public static int REG_NOTIFY_CHANGE_ATTRIBUTES;
    public static int REG_NOTIFY_CHANGE_LAST_SET;
    public static int REG_NOTIFY_CHANGE_SECURITY;
    public static int REG_OPTION_RESERVED;
    public static int REG_OPTION_NON_VOLATILE;
    public static int REG_OPTION_VOLATILE;
    public static int REG_OPTION_CREATE_LINK;
    public static int REG_OPTION_BACKUP_RESTORE;
    public static int REG_OPTION_OPEN_LINK;
    public static int REG_NO_LAZY_FLUSH;
    public static int REG_REFRESH_HIVE;
    public static int REG_LEGAL_CHANGE_FILTER;
    public static int REG_LEGAL_OPTION;
    public static int REG_WHOLE_HIVE_VOLATILE;
    private static int ERROR_NO_MORE_ITEMS;
    private static int ERROR_MORE_DATA;
    private static int ERROR_SUCCESS;
    private static PythonWinReg();
    public static void CloseKey(HKEYType key);
    public static HKEYType CreateKey(object key, string sub_key);
    private static string FormatError(int errorCode);
    public static HKEYType CreateKeyEx(object key, string sub_key, int reserved, int access);
    private static int RegCreateKeyEx(SafeRegistryHandle hKey, string lpSubKey, int Reserved, string lpClass, RegistryOptions dwOptions, RegistryRights samDesired, IntPtr lpSecurityAttributes, SafeRegistryHandle& phkResult, Int32& lpdwDisposition);
    private static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, IntPtr lpReserved, Int32& lpType, Byte[] lpData, UInt32& lpcbData);
    private static int RegEnumKeyEx(SafeRegistryHandle hKey, int dwIndex, StringBuilder lpName, Int32& lpcbName, IntPtr lpReserved, IntPtr lpClass, IntPtr lpcbClass, IntPtr lpftLastWriteTime);
    private static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, int dwType, Byte[] lpData, int cbData);
    internal static int RegDeleteKey(SafeRegistryHandle hKey, string lpSubKey);
    internal static int RegDeleteKeyEx(SafeRegistryHandle hKey, string lpSubKey, int samDesired, int Reserved);
    internal static int RegDisableReflectionKey(SafeRegistryHandle hKey);
    internal static int RegEnableReflectionKey(SafeRegistryHandle hKey);
    internal static int RegQueryReflectionKey(SafeRegistryHandle hBase, Boolean& bIsReflectionDisabled);
    public static void DeleteKey(object key, string sub_key);
    public static void DeleteKeyEx(object key, string sub_key, int access, int reserved);
    public static void DeleteValue(object key, string value);
    public static string EnumKey(object key, int index);
    public static PythonTuple EnumValue(object key, int index);
    private static void QueryValueExImpl(SafeRegistryHandle handle, string valueName, Int32& valueKind, Object& value);
    public static string ExpandEnvironmentStrings(string value);
    private static string ExtractString(Byte[] data, int start, int end);
    public static void FlushKey(object key);
    public static HKEYType OpenKey(object key, string sub_key);
    public static HKEYType OpenKey(object key, string sub_key, int reserved, int access);
    public static HKEYType OpenKeyEx(object key, string sub_key, int reserved, int access);
    public static PythonTuple QueryInfoKey(object key);
    public static object QueryValue(object key, string sub_key);
    public static PythonTuple QueryValueEx(object key, string value_name);
    public static void SetValue(object key, string sub_key, int type, string value);
    public static void SetValueEx(object key, string value_name, object reserved, int type, object value);
    public static HKEYType ConnectRegistry(string computer_name, BigInteger key);
    public static void DisableReflectionKey(object key);
    public static void EnableReflectionKey(object key);
    public static bool QueryReflectionKey(object key);
    private static HKEYType GetRootKey(object key);
    private static RegistryHive MapSystemKey(BigInteger hKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public static class IronPython.Modules.PythonWinsoundModule : object {
    public static string __doc__;
    public static int SND_SYNC;
    public static int SND_ASYNC;
    public static int SND_NODEFAULT;
    public static int SND_MEMORY;
    public static int SND_LOOP;
    public static int SND_NOSTOP;
    public static int SND_NOWAIT;
    public static int SND_ALIAS;
    public static int SND_ALIAS_ID;
    public static int SND_FILENAME;
    public static int SND_RESOURCE;
    public static int SND_PURGE;
    public static int SND_APPLICATION;
    public static int MB_OK;
    public static int MB_ICONASTERISK;
    public static int MB_ICONEXCLAMATION;
    public static int MB_ICONHAND;
    public static int MB_ICONQUESTION;
    private static PythonWinsoundModule();
    private static bool PlaySound(string fileName, IntPtr hMod, int flags);
    private static bool PlaySound(Byte[] bytes, IntPtr hMod, int flags);
    private static bool PlaySound(IntPtr input, IntPtr hMod, int flags);
    private static bool Beep(int dwFreq, int dwDuration);
    private static bool MessageBeep(int uType);
    [DocumentationAttribute("PlaySound(sound, flags) - a wrapper around the Windows PlaySound API

The sound argument can be a filename, data, or None.
For flag values, ored together, see module documentation.")]
public static void PlaySound(CodeContext context, string sound, int flags);
    [DocumentationAttribute("PlaySound(sound, flags) - a wrapper around the Windows PlaySound API

The sound argument can be a filename, data, or None.
For flag values, ored together, see module documentation.")]
public static void PlaySound(CodeContext context, IBufferProtocol sound, int flags);
    [DocumentationAttribute("Beep(frequency, duration) - a wrapper around the Windows Beep API

The frequency argument specifies frequency, in hertz, of the sound.
This parameter must be in the range 37 through 32,767.
The duration argument specifies the number of milliseconds.
")]
public static void Beep(CodeContext context, int freq, int dur);
    [DocumentationAttribute("MessageBeep(x) - call Windows MessageBeep(x). x defaults to MB_OK.")]
public static void MessageBeep(CodeContext context, int x);
}
[PythonTypeAttribute]
public class IronPython.Modules.ResourceMetaPathImporter : object {
    private PackedResourceLoader _loader;
    private IDictionary`2<string, PackedResourceInfo> _unpackedLibrary;
    private IDictionary`2<string, PackedResourceInfo[]> _unpackedModules;
    private string _unpackingError;
    private static Dictionary`2<string, ModuleCodeType> SearchOrder;
    private static ResourceMetaPathImporter();
    public ResourceMetaPathImporter(Assembly fromAssembly, string resourceName);
    [DocumentationAttribute("find_module(fullname, path=None) -> self or None.

Search for a module specified by 'fullname'. 'fullname' must be the
fully qualified (dotted) module name. It returns the importer
instance itself if the module was found, or None if it wasn't.
The optional 'path' argument is ignored -- it's there for compatibility
with the importer protocol.")]
public object find_module(CodeContext context, string fullname, Object[] args);
    [DocumentationAttribute("load_module(fullname) -> module.

Load the module specified by 'fullname'. 'fullname' must be the
fully qualified (dotted) module name. It returns the imported
module, or raises ResourceImportError if it wasn't found.")]
public object load_module(CodeContext context, string fullname);
    private Byte[] GetModuleCode(CodeContext context, string fullname, Boolean& ispackage, String& modpath);
    private Byte[] GetCodeFromData(CodeContext context, bool isbytecode, PackedResourceInfo tocEntry);
    private Byte[] GetData(PackedResourceInfo tocEntry);
    private static Exception MakeError(Object[] args);
    private static string MakeFilename(string name);
}
[PythonTypeAttribute("wrapper_descriptor")]
internal class IronPython.Modules.SlotWrapper : PythonTypeSlot {
    private string _name;
    private PythonType _type;
    public SlotWrapper(string slotName, PythonType targetType);
    public virtual string __repr__(CodeContext context);
    internal virtual bool TryGetValue(CodeContext context, object instance, PythonType owner, Object& value);
}
internal static class IronPython.Modules.SocketUtil : object {
    private static IntPtr getservbyname_linux(string name, string proto);
    private static IntPtr getservbyport_linux(ushort port, string proto);
    private static int WSAStartup(short wVersionRequested, WSAData& wsaData);
    private static IntPtr getservbyname(string name, string proto);
    private static IntPtr getservbyport(ushort port, string proto);
    private static int WSAGetLastError();
    private static int WSACleanup();
    private static T PtrToStructure(IntPtr result);
    public static string GetServiceByPortWindows(ushort port, string protocol);
    public static string GetServiceByPortNonWindows(ushort port, string protocol);
    public static string GetServiceByPort(ushort port, string protocol);
    public static ushort GetServiceByNameWindows(string service, string protocol);
    public static ushort GetServiceByNameNonWindows(string service, string protocol);
    public static ushort GetServiceByName(string service, string protocol);
}
internal class IronPython.Modules.SocketUtilException : Exception {
    public SocketUtilException(string message);
    public SocketUtilException(string message, Exception inner);
}
internal class IronPython.Modules.StringCleanup : MarshalCleanup {
    private LocalBuilder _local;
    public StringCleanup(LocalBuilder local);
    public virtual void Cleanup(ILGenerator generator);
}
public static class IronPython.Modules.xxsubtype : object {
    public static string __doc__;
    public static double bench(CodeContext context, object x, string name);
}
public static class IronPython.Runtime.ZipImportModule : object {
    public static string __doc__;
    private static object _zip_directory_cache_key;
    private static ZipImportModule();
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    public static PythonType get_ZipImportError(CodeContext context);
    internal static Exception MakeError(CodeContext context, Object[] args);
    private static void InitModuleExceptions(PythonContext context, PythonDictionary dict);
}
[PythonTypeAttribute]
public class IronPython.Zlib.Compress : object {
    private static int Z_OK;
    private static int Z_BUF_ERROR;
    private static int Z_STREAM_END;
    private static int Z_NO_FLUSH;
    private static int Z_FINISH;
    private ZStream zst;
    internal Compress(int level, int method, int wbits, int memlevel, int strategy);
    [DocumentationAttribute("compress(data) -- Return a bytes object containing compressed data.

After calling this function, some of the input data may still
be stored in internal buffers for later processing.
Call the flush() method to clear these buffers.")]
public Bytes compress(IBufferProtocol data);
    [DocumentationAttribute("flush( [mode] ) -- Return a bytes object containing any remaining compressed data.

mode can be one of the constants Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH; the
default value used when mode is not specified is Z_FINISH.
If mode == Z_FINISH, the compressor object can no longer be used after
calling the flush() method.  Otherwise, more data can still be compressed.")]
public Bytes flush(int mode);
    private static Bytes GetBytes(Byte[] bytes, int index, int count);
}
[PythonTypeAttribute]
public class IronPython.Zlib.Decompress : object {
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_BUF_ERROR;
    private static int Z_SYNC_FLUSH;
    private static int Z_FINISH;
    [CompilerGeneratedAttribute]
private Bytes <unused_data>k__BackingField;
    [CompilerGeneratedAttribute]
private Bytes <unconsumed_tail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <eof>k__BackingField;
    private ZStream zst;
    public Bytes unused_data { get; private set; }
    public Bytes unconsumed_tail { get; private set; }
    public bool eof { get; public set; }
    internal Decompress(int wbits);
    [CompilerGeneratedAttribute]
public Bytes get_unused_data();
    [CompilerGeneratedAttribute]
private void set_unused_data(Bytes value);
    [CompilerGeneratedAttribute]
public Bytes get_unconsumed_tail();
    [CompilerGeneratedAttribute]
private void set_unconsumed_tail(Bytes value);
    [DocumentationAttribute("decompress(data, max_length) -- Return a bytes object containing the decompressed
version of the data.

After calling this function, some of the input data may still be stored in
internal buffers for later processing.
Call the flush() method to clear these buffers.
If the max_length parameter is specified then the return value will be
no longer than max_length.  Unconsumed input data will be stored in
the unconsumed_tail attribute.")]
public Bytes decompress(IBufferProtocol data, int max_length);
    [CompilerGeneratedAttribute]
public bool get_eof();
    [CompilerGeneratedAttribute]
public void set_eof(bool value);
    [DocumentationAttribute("flush( [length] ) -- Return a bytes object  containing any remaining
decompressed data. length, if given, is the initial size of the
output buffer.

The decompressor object can no longer be used after this call.")]
public Bytes flush(int length);
    private static Bytes GetBytes(Byte[] bytes, int index, int count);
}
public static class IronPython.Zlib.ZlibModule : object {
    public static string __doc__;
    public static string ZLIB_VERSION;
    internal static int Z_OK;
    internal static int Z_STREAM_END;
    internal static int Z_NEED_DICT;
    internal static int Z_ERRNO;
    internal static int Z_STREAM_ERROR;
    internal static int Z_DATA_ERROR;
    internal static int Z_MEM_ERROR;
    internal static int Z_BUF_ERROR;
    internal static int Z_VERSION_ERROR;
    public static int Z_NO_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int DEFLATED;
    public static int DEF_MEM_LEVEL;
    public static int MAX_WBITS;
    internal static int DEFAULTALLOC;
    public static PythonType error;
    [DocumentationAttribute("adler32(data[, value]) -- Compute an Adler-32 checksum of data.

An optional starting value can be specified.  The returned checksum is
a signed integer.")]
public static int adler32(IBufferProtocol data, long value);
    [DocumentationAttribute("crc32(data[, value]) -- Compute a CRC-32 checksum of data.

An optional starting value can be specified.  The returned checksum is
a signed integer.")]
public static object crc32(IBufferProtocol data, UInt32 value);
    [DocumentationAttribute("compress(data[, level]) -- Returns a bytes object containing compressed data.

Optional arg level is the compression level, in 1-9.")]
public static Bytes compress(IBufferProtocol data, int level);
    [DocumentationAttribute("compressobj([level]) -- Return a compressor object.

Optional arg level is the compression level, in 1-9.")]
public static Compress compressobj(int level, int method, int wbits, int memlevel, int strategy);
    [DocumentationAttribute("decompress(data[, wbits[, bufsize]]) -- Returns a bytes object containing the uncompressed data.

Optional arg wbits is the window buffer size.  Optional arg bufsize is
the initial output buffer size.")]
public static Bytes decompress(IBufferProtocol data, int wbits, int bufsize);
    [DocumentationAttribute("decompressobj([wbits]) -- Return a decompressor object.

Optional arg wbits is the window buffer size.")]
public static Decompress decompressobj(int wbits);
    public static void PerformModuleReload(PythonContext context, PythonDictionary dict);
    internal static Exception MakeError(Object[] args);
    internal static Exception zlib_error(ZStream zst, int err, string msg);
    [PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] Decompress(Byte[] input, int wbits, int bufsize);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Mono.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private UInt32[] buff;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private static UInt32[] K;
    private static MD5CryptoServiceProvider();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, int inputOffset);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
[ComVisibleAttribute("True")]
internal class Mono.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    private SHA1Internal sha;
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private sealed virtual override object System.ICloneable.Clone();
}
internal class Mono.Security.Cryptography.SHA1Internal : object {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private UInt32[] buff;
    public void HashCore(Byte[] rgb, int ibStart, int cbSize);
    public Byte[] HashFinal();
    public void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, UInt32 inputOffset);
    private static void InitialiseBuff(UInt32[] buff, Byte[] input, UInt32 inputOffset);
    private static void FillBuff(UInt32[] buff);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
    public SHA1Internal Clone();
}
[PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Mono.Security.Cryptography.SHA224 : HashAlgorithm {
    public static SHA224 Create();
    public static SHA224 Create(string hashName);
}
[PythonHiddenAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Mono.Security.Cryptography.SHA224Managed : SHA224 {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private UInt32[] buff;
    private UInt32 Ch(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 Maj(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 Ro0(UInt32 x);
    private UInt32 Ro1(UInt32 x);
    private UInt32 Sig0(UInt32 x);
    private UInt32 Sig1(UInt32 x);
    protected virtual void HashCore(Byte[] rgb, int start, int size);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, int inputOffset);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
[ComVisibleAttribute("True")]
internal class Mono.Security.Cryptography.SHA256Managed : SHA256 {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private UInt32[] buff;
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, int inputOffset);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
[ComVisibleAttribute("True")]
internal class Mono.Security.Cryptography.SHA384Managed : SHA384 {
    private Byte[] xBuf;
    private int xBufOff;
    private ulong byteCount1;
    private ulong byteCount2;
    private ulong H1;
    private ulong H2;
    private ulong H3;
    private ulong H4;
    private ulong H5;
    private ulong H6;
    private ulong H7;
    private ulong H8;
    private UInt64[] W;
    private int wOff;
    private void Initialize(bool reuse);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void update(byte input);
    private void processWord(Byte[] input, int inOff);
    private void unpackWord(ulong word, Byte[] output, int outOff);
    private void adjustByteCounts();
    private void processLength(ulong lowW, ulong hiW);
    private void processBlock();
}
[ComVisibleAttribute("True")]
internal class Mono.Security.Cryptography.SHA512Managed : SHA512 {
    private Byte[] xBuf;
    private int xBufOff;
    private ulong byteCount1;
    private ulong byteCount2;
    private ulong H1;
    private ulong H2;
    private ulong H3;
    private ulong H4;
    private ulong H5;
    private ulong H6;
    private ulong H7;
    private ulong H8;
    private UInt64[] W;
    private int wOff;
    private void Initialize(bool reuse);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void update(byte input);
    private void processWord(Byte[] input, int inOff);
    private void unpackWord(ulong word, Byte[] output, int outOff);
    private void adjustByteCounts();
    private void processLength(ulong lowW, ulong hiW);
    private void processBlock();
    private ulong rotateRight(ulong x, int n);
    private ulong Ch(ulong x, ulong y, ulong z);
    private ulong Maj(ulong x, ulong y, ulong z);
    private ulong Sum0(ulong x);
    private ulong Sum1(ulong x);
    private ulong Sigma0(ulong x);
    private ulong Sigma1(ulong x);
}
internal static class Mono.Security.Cryptography.SHAConstants : object {
    public static UInt32[] K1;
    public static UInt64[] K2;
    private static SHAConstants();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
