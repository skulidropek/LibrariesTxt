public class com.itextpdf.text.pdf.languages.DevanagariLigaturizer : IndicLigaturizer {
    public static char DEVA_MATRA_AA;
    public static char DEVA_MATRA_I;
    public static char DEVA_MATRA_E;
    public static char DEVA_MATRA_AI;
    public static char DEVA_MATRA_HLR;
    public static char DEVA_MATRA_HLRR;
    public static char DEVA_LETTER_A;
    public static char DEVA_LETTER_AU;
    public static char DEVA_LETTER_KA;
    public static char DEVA_LETTER_HA;
    public static char DEVA_HALANTA;
}
public class com.itextpdf.text.pdf.ListBody : object {
    protected PdfName role;
    protected AccessibleElementId id;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected internal ListItem parentItem;
    protected internal float indentation;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    protected internal ListBody(ListItem parentItem);
    public ListBody(ListItem parentItem, float indentation);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class com.itextpdf.text.pdf.ListLabel : ListBody {
    public PdfName Role { get; public set; }
    public float Indentation { get; public set; }
    [ObsoleteAttribute]
public bool TagLabelContent { get; public set; }
    public bool IsInline { get; }
    protected internal ListLabel(ListItem parentItem);
    public virtual PdfObject GetAccessibleProperty(PdfName key);
    public virtual void SetAccessibleProperty(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleProperties();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual float get_Indentation();
    public virtual void set_Indentation(float value);
    public virtual bool get_TagLabelContent();
    public virtual void set_TagLabelContent(bool value);
    public virtual bool get_IsInline();
}
public class com.itextpdf.text.pdf.security.ExternalBlankSignatureContainer : object {
    private PdfDictionary sigDic;
    public ExternalBlankSignatureContainer(PdfDictionary sigDic);
    public ExternalBlankSignatureContainer(PdfName filter, PdfName subFilter);
    public virtual Byte[] Sign(Stream data);
    public virtual void ModifySigningDictionary(PdfDictionary signDic);
}
public class iTextSharp.awt.geom.AffineTransform : object {
    public static int TYPE_IDENTITY;
    public static int TYPE_TRANSLATION;
    public static int TYPE_UNIFORM_SCALE;
    public static int TYPE_GENERAL_SCALE;
    public static int TYPE_QUADRANT_ROTATION;
    public static int TYPE_GENERAL_ROTATION;
    public static int TYPE_GENERAL_TRANSFORM;
    public static int TYPE_FLIP;
    public static int TYPE_MASK_SCALE;
    public static int TYPE_MASK_ROTATION;
    private static int TYPE_UNKNOWN;
    private static double ZERO;
    private double m00;
    private double m10;
    private double m01;
    private double m11;
    private double m02;
    private double m12;
    private int type;
    public int Type { get; }
    public AffineTransform(AffineTransform t);
    public AffineTransform(float m00, float m10, float m01, float m11, float m02, float m12);
    public AffineTransform(double m00, double m10, double m01, double m11, double m02, double m12);
    public AffineTransform(Single[] matrix);
    public AffineTransform(Double[] matrix);
    public virtual int get_Type();
    public virtual double GetScaleX();
    public virtual double GetScaleY();
    public virtual double GetShearX();
    public virtual double GetShearY();
    public virtual double GetTranslateX();
    public virtual double GetTranslateY();
    public virtual bool IsIdentity();
    public virtual void GetMatrix(Double[] matrix);
    public virtual double GetDeterminant();
    public virtual void SetTransform(double m00, double m10, double m01, double m11, double m02, double m12);
    public virtual void SetTransform(AffineTransform t);
    public virtual void SetToIdentity();
    public virtual void SetToTranslation(double mx, double my);
    public virtual void SetToScale(double scx, double scy);
    public virtual void SetToShear(double shx, double shy);
    public virtual void SetToRotation(double angle);
    public virtual void SetToRotation(double angle, double px, double py);
    public static AffineTransform GetTranslateInstance(double mx, double my);
    public static AffineTransform GetScaleInstance(double scx, double scY);
    public static AffineTransform GetShearInstance(double shx, double shy);
    public static AffineTransform GetRotateInstance(double angle);
    public static AffineTransform GetRotateInstance(double angle, double x, double y);
    public virtual void Translate(double mx, double my);
    public virtual void Scale(double scx, double scy);
    public virtual void Shear(double shx, double shy);
    public virtual void Rotate(double angle);
    public virtual void Rotate(double angle, double px, double py);
    private AffineTransform Multiply(AffineTransform t1, AffineTransform t2);
    public virtual void Concatenate(AffineTransform t);
    public virtual void preConcatenate(AffineTransform t);
    public virtual AffineTransform CreateInverse();
    public virtual Point2D Transform(Point2D src, Point2D dst);
    public virtual void Transform(Point2D[] src, int srcOff, Point2D[] dst, int dstOff, int length);
    public virtual void Transform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void Transform(Single[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual void Transform(Single[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void Transform(Double[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual Point2D DeltaTransform(Point2D src, Point2D dst);
    public virtual void DeltaTransform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual Point2D InverseTransform(Point2D src, Point2D dst);
    public virtual void InverseTransform(Double[] src, int srcOff, Double[] dst, int dstOff, int length);
    public virtual void InverseTransform(Single[] src, int srcOff, Single[] dst, int dstOff, int length);
    public virtual object Clone();
    public virtual string ToString();
}
public class iTextSharp.awt.geom.Point : Point2D {
    public double x;
    public double y;
    public Point(int x, int y);
    public Point(double x, double y);
    public Point(Point p);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual double GetX();
    public virtual double GetY();
    public virtual Point GetLocation();
    public virtual void SetLocation(Point p);
    public virtual void SetLocation(int x, int y);
    public virtual void SetLocation(double x, double y);
    public virtual void Move(int x, int y);
    public virtual void Move(double x, double y);
    public virtual void Translate(int dx, int dy);
    public virtual void Translate(double dx, double dy);
}
public abstract class iTextSharp.awt.geom.Point2D : object {
    public abstract virtual double GetX();
    public abstract virtual double GetY();
    public abstract virtual void SetLocation(double x, double y);
    public virtual void SetLocation(Point2D p);
    public static double DistanceSq(double x1, double y1, double x2, double y2);
    public virtual double DistanceSq(double px, double py);
    public virtual double DistanceSq(Point2D p);
    public static double Distance(double x1, double y1, double x2, double y2);
    public virtual double Distance(double px, double py);
    public virtual double Distance(Point2D p);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.testutils.CompareTool : object {
    private string gsExec;
    private string compareExec;
    private static string renderedImageExtension;
    private static string pageNumberPattern;
    private Regex pageListRegexp;
    private static string tempFilePrefix;
    private static string gsParams;
    private static string compareParams;
    private static string cannotOpenTarGetDirectory;
    private static string gsFailed;
    private static string unexpectedNumberOfPages;
    private static string differentPages;
    private static string undefinedGsPath;
    private static string ignoredAreasPrefix;
    private string cmpPdf;
    private string cmpPdfName;
    private string cmpImage;
    private string outPdf;
    private string outPdfName;
    private string outImage;
    private IList`1<PdfDictionary> outPages;
    private IList`1<RefKey> outPagesRef;
    private IList`1<PdfDictionary> cmpPages;
    private IList`1<RefKey> cmpPagesRef;
    private int compareByContentErrorsLimit;
    private bool generateCompareByContentXmlReport;
    private string xmlReportName;
    private double floatComparisonError;
    private bool absoluteError;
    private string Compare(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    private string Compare(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas, IList`1<int> equalPages);
    private int RunGhostscriptAndGetExitCode(string replacementPdf, string replacementImagesDirectory);
    public virtual string Compare(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string Compare(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix);
    public virtual CompareTool SetCompareByContentErrorsLimit(int compareByContentMaxErrorCount);
    public virtual void SetGenerateCompareByContentXmlReport(bool generateCompareByContentXmlReport);
    public CompareTool SetFloatAbsoluteError(float error);
    public CompareTool SetFloatRelativeError(float error);
    public void SetXmlReportName(string reportName);
    public string GetXmlReportName();
    private string CompareByContent(string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string CompareByContent(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix, IDictionary`2<int, IList`1<Rectangle>> ignoredAreas);
    public virtual string CompareByContent(string outPdf, string cmpPdf, string outPath, string differenceImagePrefix);
    private void LoadPagesFromReader(PdfReader reader, IList`1<PdfDictionary> pages, IList`1<RefKey> pagesRef);
    private void AddPagesFromDict(PdfObject dictRef, IList`1<PdfDictionary> pages, IList`1<RefKey> pagesRef);
    private bool CompareObjects(PdfObject outObj, PdfObject cmpObj, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareDictionaries(PdfDictionary outDict, PdfDictionary cmpDict);
    private bool CompareDictionariesExtended(PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareContentStreamsByParsing(PdfObject outObj, PdfObject cmpObj);
    public bool CompareContentStreamsByParsing(PdfObject outObj, PdfObject cmpObj, PdfDictionary outResources, PdfDictionary cmpResources);
    private bool CompareContentStreamsByParsingExtended(PdfObject outObj, PdfObject cmpObj, PdfDictionary outResources, PdfDictionary cmpResources, ObjectPath currentPath, CompareResult compareResult);
    private bool CompareInlineImagesExtended(PdfContentParser outPs, PdfContentParser cmpPs, PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareStreams(PRStream outStream, PRStream cmpStream);
    private bool CompareStreamsExtended(PRStream outStream, PRStream cmpStream, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareArrays(PdfArray outArray, PdfArray cmpArray);
    private bool CompareArraysExtended(PdfArray outArray, PdfArray cmpArray, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareNames(PdfName outName, PdfName cmpName);
    private bool CompareNamesExtended(PdfName outName, PdfName cmpName, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareNumbers(PdfNumber outNumber, PdfNumber cmpNumber);
    private bool CompareNumbersExtended(PdfNumber outNumber, PdfNumber cmpNumber, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareStrings(PdfString outString, PdfString cmpString);
    private bool CompareStringsExtended(PdfString outString, PdfString cmpString, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareLiterals(PdfLiteral outLiteral, PdfLiteral cmpLiteral);
    private bool CompareLiteralsExtended(PdfLiteral outLiteral, PdfLiteral cmpLiteral, ObjectPath currentPath, CompareResult compareResult);
    public bool CompareBooleans(PdfBoolean outBoolean, PdfBoolean cmpBoolean);
    private bool CompareBooleansExtended(PdfBoolean outBoolean, PdfBoolean cmpBoolean, ObjectPath currentPath, CompareResult compareResult);
    public string CompareXmp(Byte[] xmp1, Byte[] xmp2);
    public string CompareXmp(Byte[] xmp1, Byte[] xmp2, bool ignoreDateAndProducerProperties);
    public string CompareXmp(string outPdf, string cmpPdf);
    public string CompareXmp(string outPdf, string cmpPdf, bool ignoreDateAndProducerProperties);
    public bool CompareXmls(Byte[] xml1, Byte[] xml2);
    private void Init(string outPdf, string cmpPdf);
    private bool CompareStreams(FileStream is1, FileStream is2);
    public virtual string CompareDocumentInfo(string outPdf, string cmpPdf);
    private bool LinksAreSame(PdfImportedLink cmpLink, PdfImportedLink outLink);
    public virtual string CompareLinks(string outPdf, string cmpPdf);
    private String[] ConvertInfo(IDictionary`2<string, string> info);
    private bool PngPredicate(FileSystemInfo pathname);
    private bool CmpPngPredicate(FileSystemInfo pathname);
}
public class iTextSharp.testutils.CompareToolUtil : object {
    private static int tempFileCounter;
    private static int stdOutputIndex;
    private static int ErrOutputIndex;
    private static string splitRegex;
    private static CompareToolUtil();
    public static string CreateTempCopy(string file, string tempFilePrefix, string tempFilePostfix);
    public static void Copy(string fileToCopy, string copiedFile);
    public static string CreateTempDirectory(string tempFilePrefix);
    public static bool RemoveFiles(Object[] paths);
    internal static void SetProcessStartInfo(Process proc, string exec, string params, string workingDir);
    internal static String[] PrepareProcessArguments(string exec, string params);
    internal static String[] SplitIntoProcessArguments(string command, string params);
    internal static string GetProcessOutput(Process p);
    internal static StringBuilder[] GetProcessOutputBuilders(Process p);
}
public abstract class iTextSharp.testutils.ITextTest : object {
    public virtual void RunTest();
    protected abstract virtual void MakePdf(string outPdf);
    protected abstract virtual string GetOutPdf();
    protected virtual void AssertPdf(string outPdf);
    protected virtual void ComparePdf(string outPdf, string cmpPdf);
    protected virtual string GetCmpPdf();
    protected virtual void DeleteDirectory(string path);
    protected virtual void DeleteFiles(string path);
}
public class iTextSharp.text.AccessibleElementId : object {
    private static int id_counter;
    private int id;
    private static AccessibleElementId();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual int CompareTo(AccessibleElementId elementId);
}
public class iTextSharp.text.Anchor : Phrase {
    protected string name;
    protected string reference;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public string Name { get; public set; }
    public string Reference { get; public set; }
    public Uri Url { get; }
    public Anchor(float leading);
    public Anchor(Chunk chunk);
    public Anchor(string str);
    public Anchor(string str, Font font);
    public Anchor(float leading, Chunk chunk);
    public Anchor(float leading, string str);
    public Anchor(float leading, string str, Font font);
    public Anchor(Phrase phrase);
    public virtual bool Process(IElementListener listener);
    public virtual IList`1<Chunk> get_Chunks();
    protected virtual bool ApplyAnchor(Chunk chunk, bool notGotoOK, bool localDestination);
    public virtual int get_Type();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Reference();
    public virtual void set_Reference(string value);
    public virtual Uri get_Url();
}
public class iTextSharp.text.Annotation : object {
    public static int TEXT;
    public static int URL_NET;
    public static int URL_AS_STRING;
    public static int FILE_DEST;
    public static int FILE_PAGE;
    public static int NAMED_DEST;
    public static int LAUNCH;
    public static int SCREEN;
    public static string TITLE;
    public static string CONTENT;
    public static string URL;
    public static string FILE;
    public static string DESTINATION;
    public static string PAGE;
    public static string NAMED;
    public static string APPLICATION;
    public static string PARAMETERS;
    public static string OPERATION;
    public static string DEFAULTDIR;
    public static string LLX;
    public static string LLY;
    public static string URX;
    public static string URY;
    public static string MIMETYPE;
    protected int annotationtype;
    protected Dictionary`2<string, object> annotationAttributes;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public int AnnotationType { get; }
    public string Title { get; }
    public string Content { get; }
    public Dictionary`2<string, object> Attributes { get; }
    private Annotation(float llx, float lly, float urx, float ury);
    public Annotation(Annotation an);
    public Annotation(string title, string text);
    public Annotation(string title, string text, float llx, float lly, float urx, float ury);
    public Annotation(float llx, float lly, float urx, float ury, Uri url);
    public Annotation(float llx, float lly, float urx, float ury, string url);
    public Annotation(float llx, float lly, float urx, float ury, string file, string dest);
    public Annotation(float llx, float lly, float urx, float ury, string moviePath, string mimeType, bool showOnDisplay);
    public Annotation(float llx, float lly, float urx, float ury, string file, int page);
    public Annotation(float llx, float lly, float urx, float ury, int named);
    public Annotation(float llx, float lly, float urx, float ury, string application, string parameters, string operation, string defaultdir);
    public virtual int get_Type();
    public virtual bool Process(IElementListener listener);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual void SetDimensions(float llx, float lly, float urx, float ury);
    public virtual float GetLlx();
    public virtual float GetLly();
    public virtual float GetUrx();
    public virtual float GetUry();
    public virtual float GetLlx(float def);
    public virtual float GetLly(float def);
    public virtual float GetUrx(float def);
    public virtual float GetUry(float def);
    public virtual int get_AnnotationType();
    public virtual string get_Title();
    public virtual string get_Content();
    public virtual Dictionary`2<string, object> get_Attributes();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual string ToString();
}
public interface iTextSharp.text.api.IIndentable {
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public abstract virtual float get_IndentationLeft();
    public abstract virtual void set_IndentationLeft(float value);
    public abstract virtual float get_IndentationRight();
    public abstract virtual void set_IndentationRight(float value);
}
public interface iTextSharp.text.api.ISpaceable {
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public abstract virtual float get_SpacingBefore();
    public abstract virtual void set_SpacingBefore(float value);
    public abstract virtual float get_SpacingAfter();
    public abstract virtual void set_SpacingAfter(float value);
    public abstract virtual float get_PaddingTop();
    public abstract virtual void set_PaddingTop(float value);
}
public interface iTextSharp.text.api.IWriterOperation {
    public abstract virtual void Write(PdfWriter writer, Document doc);
}
public class iTextSharp.text.BadElementException : DocumentException {
    public BadElementException(string message);
    protected BadElementException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.BaseColor : object {
    public static BaseColor WHITE;
    public static BaseColor LIGHT_GRAY;
    public static BaseColor GRAY;
    public static BaseColor DARK_GRAY;
    public static BaseColor BLACK;
    public static BaseColor RED;
    public static BaseColor PINK;
    public static BaseColor ORANGE;
    public static BaseColor YELLOW;
    public static BaseColor GREEN;
    public static BaseColor MAGENTA;
    public static BaseColor CYAN;
    public static BaseColor BLUE;
    private static double FACTOR;
    private int value;
    public int RGB { get; }
    public int R { get; }
    public int G { get; }
    public int B { get; }
    public int A { get; }
    public BaseColor(int red, int green, int blue, int alpha);
    public BaseColor(int red, int green, int blue);
    public BaseColor(float red, float green, float blue, float alpha);
    public BaseColor(float red, float green, float blue);
    public BaseColor(int argb);
    public BaseColor(Color color);
    private static BaseColor();
    public virtual int get_RGB();
    public virtual int get_R();
    public virtual int get_G();
    public virtual int get_B();
    public virtual int get_A();
    public virtual BaseColor Brighter();
    public virtual BaseColor Darker();
    [ObsoleteAttribute("Use RGB instead")]
public virtual int ToArgb();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected internal virtual void SetValue(int red, int green, int blue, int alpha);
    private static void Validate(int value);
    public virtual string ToString();
}
public class iTextSharp.text.Chapter : Section {
    public int Type { get; }
    public Chapter(int number);
    public Chapter(Paragraph title, int number);
    public Chapter(string title, int number);
    public virtual int get_Type();
    public virtual bool IsNestable();
}
public class iTextSharp.text.ChapterAutoNumber : Chapter {
    protected bool numberSet;
    public ChapterAutoNumber(Paragraph para);
    public ChapterAutoNumber(string title);
    public virtual Section AddSection(string title);
    public virtual Section AddSection(Paragraph title);
    public virtual int SetAutomaticNumber(int number);
}
public class iTextSharp.text.Chunk : object {
    public static string OBJECT_REPLACEMENT_CHARACTER;
    public static Chunk NEWLINE;
    public static Chunk NEXTPAGE;
    public static Chunk TABBING;
    public static Chunk SPACETABBING;
    protected StringBuilder content;
    protected Font font;
    protected Dictionary`2<string, object> attributes;
    protected internal PdfName role;
    protected internal Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    public static string SEPARATOR;
    public static string TAB;
    public static string TABSETTINGS;
    private string contentWithNoTabs;
    public static string HSCALE;
    public static string UNDERLINE;
    public static string SUBSUPSCRIPT;
    public static string SKEW;
    public static string BACKGROUND;
    public static string TEXTRENDERMODE;
    public static string SPLITCHARACTER;
    public static string HYPHENATION;
    public static string REMOTEGOTO;
    public static string LOCALGOTO;
    public static string LOCALDESTINATION;
    public static string GENERICTAG;
    public static string LINEHEIGHT;
    public static string IMAGE;
    public static string ACTION;
    public static string NEWPAGE;
    public static string PDFANNOTATION;
    public static string COLOR;
    public static string ENCODING;
    public static string CHAR_SPACING;
    public static string WORD_SPACING;
    public static string WHITESPACE;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public Font Font { get; public set; }
    public string Content { get; }
    public Dictionary`2<string, object> Attributes { get; public set; }
    public float HorizontalScaling { get; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    private static Chunk();
    public Chunk(Chunk ck);
    public Chunk(string content, Font font);
    public Chunk(string content);
    public Chunk(char c, Font font);
    public Chunk(char c);
    public Chunk(Image image, float offsetX, float offsetY);
    public Chunk(IDrawInterface separator);
    public Chunk(IDrawInterface separator, bool vertical);
    [ObsoleteAttribute]
public Chunk(IDrawInterface separator, float tabPosition);
    [ObsoleteAttribute]
public Chunk(IDrawInterface separator, float tabPosition, bool newline);
    private Chunk(float tabInterval, bool isWhitespace);
    public Chunk(Image image, float offsetX, float offsetY, bool changeLeading);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual StringBuilder Append(string str);
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public virtual string get_Content();
    public virtual string ToString();
    public virtual bool IsEmpty();
    public virtual float GetWidthPoint();
    public virtual bool HasAttributes();
    public bool HasAccessibleAttributes();
    public virtual Dictionary`2<string, object> get_Attributes();
    public virtual void set_Attributes(Dictionary`2<string, object> value);
    private Chunk SetAttribute(string name, object obj);
    public virtual Chunk SetHorizontalScaling(float scale);
    public virtual float get_HorizontalScaling();
    public virtual Chunk SetUnderline(float thickness, float yPosition);
    public virtual Chunk SetUnderline(BaseColor color, float thickness, float thicknessMul, float yPosition, float yPositionMul, int cap);
    public virtual Chunk SetTextRise(float rise);
    public virtual float GetTextRise();
    public virtual Chunk SetSkew(float alpha, float beta);
    public virtual Chunk SetBackground(BaseColor color);
    public virtual Chunk SetBackground(BaseColor color, float extraLeft, float extraBottom, float extraRight, float extraTop);
    public virtual Chunk SetTextRenderMode(int mode, float strokeWidth, BaseColor strokeColor);
    public virtual Chunk SetSplitCharacter(ISplitCharacter splitCharacter);
    public virtual Chunk SetHyphenation(IHyphenationEvent hyphenation);
    public virtual Chunk SetRemoteGoto(string filename, string name);
    public virtual Chunk SetRemoteGoto(string filename, int page);
    public virtual Chunk SetLocalGoto(string name);
    public virtual Chunk SetLocalDestination(string name);
    public virtual Chunk SetGenericTag(string text);
    public virtual Chunk setLineHeight(float lineheight);
    public virtual Image GetImage();
    public virtual Chunk SetAction(PdfAction action);
    public virtual Chunk SetAnchor(Uri url);
    public virtual Chunk SetAnchor(string url);
    public virtual Chunk SetNewPage();
    public virtual Chunk SetAnnotation(PdfAnnotation annotation);
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IHyphenationEvent GetHyphenation();
    public virtual Chunk SetCharacterSpacing(float charSpace);
    public virtual float GetCharacterSpacing();
    public virtual Chunk SetWordSpacing(float wordSpace);
    public virtual float GetWordSpacing();
    public static Chunk CreateWhitespace(string content);
    public static Chunk CreateWhitespace(string content, bool preserve);
    public virtual bool IsWhitespace();
    [ObsoleteAttribute]
public static Chunk CreateTabspace();
    [ObsoleteAttribute]
public static Chunk CreateTabspace(float spacing);
    [ObsoleteAttribute]
public virtual bool IsTabspace();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual string GetTextExpansion();
    public virtual void SetTextExpansion(string value);
}
public class iTextSharp.text.Document : object {
    public static bool Compress;
    public static float WmfFontCorrection;
    protected List`1<IDocListener> listeners;
    protected bool open;
    protected bool close;
    protected Rectangle pageSize;
    protected float marginLeft;
    protected float marginRight;
    protected float marginTop;
    protected float marginBottom;
    protected bool marginMirroring;
    protected bool marginMirroringTopBottom;
    protected string javaScript_onLoad;
    protected string javaScript_onUnLoad;
    protected string htmlStyleClass;
    protected int pageN;
    protected int chapternumber;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    unknown int PageCount {public set; }
    public int PageNumber { get; }
    public float LeftMargin { get; }
    public float RightMargin { get; }
    public float TopMargin { get; }
    public float BottomMargin { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public Rectangle PageSize { get; }
    public string JavaScript_onLoad { get; public set; }
    public string JavaScript_onUnLoad { get; public set; }
    public string HtmlStyleClass { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public Document(Rectangle pageSize);
    public Document(Rectangle pageSize, float marginLeft, float marginRight, float marginTop, float marginBottom);
    private static Document();
    public virtual void AddDocListener(IDocListener listener);
    public virtual void RemoveIDocListener(IDocListener listener);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void OpenDocument();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public virtual int get_PageNumber();
    public virtual void Close();
    public virtual void CloseDocument();
    public virtual bool AddHeader(string name, string content);
    public virtual bool AddTitle(string title);
    public virtual bool AddSubject(string subject);
    public virtual bool AddKeywords(string keywords);
    public virtual bool AddAuthor(string author);
    public virtual bool AddCreator(string creator);
    public virtual bool AddProducer();
    public virtual bool AddLanguage(string language);
    public virtual bool AddCreationDate();
    public virtual float get_LeftMargin();
    public virtual float get_RightMargin();
    public virtual float get_TopMargin();
    public virtual float get_BottomMargin();
    public virtual float get_Left();
    public virtual float get_Right();
    public virtual float get_Top();
    public virtual float get_Bottom();
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public virtual float GetBottom(float margin);
    public virtual Rectangle get_PageSize();
    public virtual bool IsOpen();
    public virtual string get_JavaScript_onLoad();
    public virtual void set_JavaScript_onLoad(string value);
    public virtual string get_JavaScript_onUnLoad();
    public virtual void set_JavaScript_onUnLoad(string value);
    public virtual string get_HtmlStyleClass();
    public virtual void set_HtmlStyleClass(string value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public virtual bool IsMarginMirroring();
    public virtual void Dispose();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.DocumentException : Exception {
    public DocumentException(string message);
    protected DocumentException(SerializationInfo info, StreamingContext context);
    public DocumentException(string message, Exception ex);
}
public abstract class iTextSharp.text.DocWriter : object {
    public static byte NEWLINE;
    public static byte TAB;
    public static byte LT;
    public static byte SPACE;
    public static byte EQUALS;
    public static byte QUOTE;
    public static byte GT;
    public static byte FORWARD;
    protected Rectangle pageSize;
    protected Document document;
    protected OutputStreamCounter os;
    protected bool open;
    protected bool pause;
    protected bool closeStream;
    unknown int PageCount {public set; }
    public bool CloseStream { get; public set; }
    protected DocWriter(Document document, Stream os);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public virtual void Close();
    public static Byte[] GetISOBytes(string text);
    public virtual void Pause();
    public virtual bool IsPaused();
    public virtual void Resume();
    public virtual void Flush();
    protected virtual void Write(string str);
    protected virtual void AddTabs(int indent);
    protected virtual void Write(string key, string value);
    protected virtual void WriteStart(string tag);
    protected virtual void WriteEnd(string tag);
    protected virtual void WriteEnd();
    protected virtual bool WriteMarkupAttributes(Properties markup);
    public virtual bool get_CloseStream();
    public virtual void set_CloseStream(bool value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroring);
    public virtual void Dispose();
}
public class iTextSharp.text.Element : object {
    public static int HEADER;
    public static int TITLE;
    public static int SUBJECT;
    public static int KEYWORDS;
    public static int AUTHOR;
    public static int PRODUCER;
    public static int CREATIONDATE;
    public static int CREATOR;
    public static int LANGUAGE;
    public static int CHUNK;
    public static int PHRASE;
    public static int PARAGRAPH;
    public static int SECTION;
    public static int LIST;
    public static int LISTITEM;
    public static int CHAPTER;
    public static int ANCHOR;
    public static int PTABLE;
    public static int ANNOTATION;
    public static int RECTANGLE;
    public static int JPEG;
    public static int JPEG2000;
    public static int IMGRAW;
    public static int IMGTEMPLATE;
    public static int JBIG2;
    public static int DIV;
    public static int BODY;
    public static int MARKED;
    public static int YMARK;
    public static int WRITABLE_DIRECT;
    public static int ALIGN_UNDEFINED;
    public static int ALIGN_LEFT;
    public static int ALIGN_CENTER;
    public static int ALIGN_RIGHT;
    public static int ALIGN_JUSTIFIED;
    public static int ALIGN_TOP;
    public static int ALIGN_MIDDLE;
    public static int ALIGN_BOTTOM;
    public static int ALIGN_BASELINE;
    public static int ALIGN_JUSTIFIED_ALL;
    public static int CCITTG4;
    public static int CCITTG3_1D;
    public static int CCITTG3_2D;
    public static int CCITT_BLACKIS1;
    public static int CCITT_ENCODEDBYTEALIGN;
    public static int CCITT_ENDOFLINE;
    public static int CCITT_ENDOFBLOCK;
}
public class iTextSharp.text.error_messages.LocalizedResource : object {
    private static Char[] splt;
    private Properties msgs;
    public LocalizedResource(string resourceRoot, CultureInfo culture, Assembly assembly);
    private static LocalizedResource();
    public virtual string GetMessage(string key);
}
public class iTextSharp.text.error_messages.MessageLocalization : object {
    private static Dictionary`2<string, string> defaultLanguage;
    private static Dictionary`2<string, string> currentLanguage;
    private static string BASE_PATH;
    private static MessageLocalization();
    public static string GetMessage(string key);
    public static string GetMessage(string key, bool useDefaultLanguageIfMessageNotFound);
    public static string GetComposedMessage(string key, Object[] p);
    public static bool SetLanguage(string language, string country);
    public static void SetMessages(TextReader r);
    private static Dictionary`2<string, string> GetLanguageMessages(string language, string country);
    private static Dictionary`2<string, string> ReadLanguageStream(Stream isp);
    private static Dictionary`2<string, string> ReadLanguageStream(TextReader br);
}
public class iTextSharp.text.exceptions.BadPasswordException : IOException {
    public BadPasswordException(string message);
    protected BadPasswordException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.IllegalPdfSyntaxException : ArgumentException {
    public IllegalPdfSyntaxException(string message);
    protected IllegalPdfSyntaxException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.InvalidImageException : Exception {
    public InvalidImageException(string message);
    public InvalidImageException(string message, Exception innerException);
    protected InvalidImageException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.InvalidPdfException : IOException {
    private Exception cause;
    public InvalidPdfException(string message);
    public InvalidPdfException(string message, Exception cause);
    protected InvalidPdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.exceptions.UnsupportedPdfException : InvalidPdfException {
    public UnsupportedPdfException(string message);
    protected UnsupportedPdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.factories.GreekAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanNumberFactory : object {
    private static RomanDigit[] roman;
    private static RomanNumberFactory();
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.Font : object {
    public static int NORMAL;
    public static int BOLD;
    public static int ITALIC;
    public static int UNDERLINE;
    public static int STRIKETHRU;
    public static int BOLDITALIC;
    public static int UNDEFINED;
    public static int DEFAULTSIZE;
    private FontFamily family;
    private float size;
    private int style;
    private BaseColor color;
    private BaseFont baseFont;
    public FontFamily Family { get; }
    public string Familyname { get; }
    public float Size { get; public set; }
    public float CalculatedSize { get; }
    public int Style { get; }
    public int CalculatedStyle { get; }
    public BaseColor Color { get; public set; }
    public BaseFont BaseFont { get; }
    public Font(Font other);
    public Font(FontFamily family, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style, BaseColor color);
    public Font(BaseFont bf, float size, int style);
    public Font(BaseFont bf, float size);
    public Font(BaseFont bf);
    public Font(FontFamily family, float size, int style);
    public Font(FontFamily family, float size);
    public Font(FontFamily family);
    public virtual int CompareTo(Font font);
    public virtual FontFamily get_Family();
    public virtual string get_Familyname();
    public virtual void SetFamily(string family);
    public static FontFamily GetFamilyIndex(string family);
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public virtual float get_CalculatedSize();
    public virtual float GetCalculatedLeading(float multipliedLeading);
    public virtual int get_Style();
    public virtual int get_CalculatedStyle();
    public virtual bool IsBold();
    public virtual bool IsItalic();
    public virtual bool IsUnderlined();
    public virtual bool IsStrikethru();
    public virtual void SetStyle(string style);
    public virtual void SetStyle(int style);
    public static int GetStyleValue(string style);
    public virtual BaseColor get_Color();
    public virtual void set_Color(BaseColor value);
    public virtual void SetColor(int red, int green, int blue);
    public virtual BaseFont get_BaseFont();
    public virtual BaseFont GetCalculatedBaseFont(bool specialEncoding);
    public virtual bool IsStandardFont();
    public virtual Font Difference(Font font);
}
public class iTextSharp.text.FontFactory : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    private static FontFactoryImp fontImp;
    private static string defaultEncoding;
    private static bool defaultEmbedding;
    public static ICollection`1<string> RegisteredFonts { get; }
    public static ICollection`1<string> RegisteredFamilies { get; }
    public static string DefaultEncoding { get; }
    public static bool DefaultEmbedding { get; }
    public static FontFactoryImp FontImp { get; public set; }
    private static FontFactory();
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size);
    public static Font GetFont(string fontname, string encoding, bool embedded);
    public static Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, string encoding, float size, int style);
    public static Font GetFont(string fontname, string encoding, float size);
    public static Font GetFont(string fontname, string encoding);
    public static Font GetFont(string fontname, float size, int style, BaseColor color);
    public static Font GetFont(string fontname, float size, BaseColor color);
    public static Font GetFont(string fontname, float size, int style);
    public static Font GetFont(string fontname, float size);
    public static Font GetFont(string fontname);
    public static void RegisterFamily(string familyName, string fullName, string path);
    public static void Register(Properties attributes);
    public static void Register(string path);
    public static void Register(string path, string alias);
    public static int RegisterDirectory(string dir);
    public static int RegisterDirectory(string dir, bool scanSubdirectories);
    public static int RegisterDirectories();
    public static ICollection`1<string> get_RegisteredFonts();
    public static ICollection`1<string> get_RegisteredFamilies();
    public static bool Contains(string fontname);
    public static bool IsRegistered(string fontname);
    public static string get_DefaultEncoding();
    public static bool get_DefaultEmbedding();
    public static FontFactoryImp get_FontImp();
    public static void set_FontImp(FontFactoryImp value);
}
public class iTextSharp.text.FontFactoryImp : object {
    protected static string SystemPath;
    private static ILogger LOGGER;
    private Dictionary`2<string, string> trueTypeFonts;
    private static String[] TTFamilyOrder;
    private Dictionary`2<string, List`1<string>> fontFamilies;
    private string defaultEncoding;
    private bool defaultEmbedding;
    public ICollection`1<string> RegisteredFonts { get; }
    public ICollection`1<string> RegisteredFamilies { get; }
    public string DefaultEncoding { get; public set; }
    public bool DefaultEmbedding { get; public set; }
    private static FontFactoryImp();
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color, bool cached);
    protected virtual BaseFont GetBaseFont(string fontname, string encoding, bool embedded, bool cached);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size);
    public virtual Font GetFont(string fontname, string encoding, bool embedded);
    public virtual Font GetFont(string fontname, string encoding, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, string encoding, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, float size);
    public virtual Font GetFont(string fontname, string encoding);
    public virtual Font GetFont(string fontname, float size, int style, BaseColor color);
    public virtual Font GetFont(string fontname, float size, BaseColor color);
    public virtual Font GetFont(string fontname, float size, int style);
    public virtual Font GetFont(string fontname, float size);
    public virtual Font GetFont(string fontname);
    public virtual void RegisterFamily(string familyName, string fullName, string path);
    public virtual void Register(string path);
    public virtual void Register(string path, string alias);
    protected bool SaveCopyOfRegularFont(string regularFontName, string path);
    public virtual int RegisterDirectory(string dir);
    public virtual int RegisterDirectory(string dir, bool scanSubdirectories);
    public virtual int RegisterDirectories();
    public virtual ICollection`1<string> get_RegisteredFonts();
    public virtual ICollection`1<string> get_RegisteredFamilies();
    public virtual bool IsRegistered(string fontname);
    public virtual string get_DefaultEncoding();
    public virtual void set_DefaultEncoding(string value);
    public virtual bool get_DefaultEmbedding();
    public virtual void set_DefaultEmbedding(bool value);
}
public class iTextSharp.text.GreekList : List {
    public GreekList(int symbolIndent);
    public GreekList(bool greeklower, int symbolIndent);
    protected virtual void SetGreekFont();
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.Header : Meta {
    private StringBuilder name;
    public string Name { get; }
    public Header(string name, string content);
    public virtual string get_Name();
}
[ObsoleteAttribute]
public static class iTextSharp.text.html.HtmlEncoder : object {
    private static String[] HTML_CODE;
    private static Dictionary`2<string, object> NEWLINETAGS;
    private static HtmlEncoder();
    public static string Encode(string str);
    public static string Encode(BaseColor color);
    public static string GetAlignment(int alignment);
    public static bool IsNewLineTag(string tag);
}
[ObsoleteAttribute]
public static class iTextSharp.text.html.HtmlTags : object {
    public static string A;
    public static string B;
    public static string BODY;
    public static string BLOCKQUOTE;
    public static string BR;
    public static string DIV;
    public static string EM;
    public static string FONT;
    public static string H1;
    public static string H2;
    public static string H3;
    public static string H4;
    public static string H5;
    public static string H6;
    public static string HR;
    public static string I;
    public static string IMG;
    public static string LI;
    public static string OL;
    public static string P;
    public static string PRE;
    public static string S;
    public static string SPAN;
    public static string STRIKE;
    public static string STRONG;
    public static string SUB;
    public static string SUP;
    public static string TABLE;
    public static string TD;
    public static string TH;
    public static string TR;
    public static string U;
    public static string UL;
    public static string ALIGN;
    public static string BGCOLOR;
    public static string BORDER;
    public static string CELLPADDING;
    public static string COLSPAN;
    public static string EXTRAPARASPACE;
    public static string ENCODING;
    public static string FACE;
    public static string HEIGHT;
    public static string HREF;
    public static string HYPHENATION;
    public static string IMAGEPATH;
    public static string INDENT;
    public static string LEADING;
    public static string ROWSPAN;
    public static string SIZE;
    public static string SRC;
    public static string VALIGN;
    public static string WIDTH;
    public static string ALIGN_LEFT;
    public static string ALIGN_CENTER;
    public static string ALIGN_RIGHT;
    public static string ALIGN_JUSTIFY;
    public static string ALIGN_JUSTIFIED_ALL;
    public static string ALIGN_TOP;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_BASELINE;
    public static string STYLE;
    public static string CLASS;
    public static string COLOR;
    public static string FONTFAMILY;
    public static string FONTSIZE;
    public static string FONTSTYLE;
    public static string FONTWEIGHT;
    public static string LINEHEIGHT;
    public static string PADDINGLEFT;
    public static string TEXTALIGN;
    public static string TEXTDECORATION;
    public static string VERTICALALIGN;
    public static string BOLD;
    public static string ITALIC;
    public static string LINETHROUGH;
    public static string NORMAL;
    public static string OBLIQUE;
    public static string UNDERLINE;
    public static string AFTER;
    public static string BEFORE;
}
[ObsoleteAttribute]
public class iTextSharp.text.html.HtmlUtilities : object {
    public static float DEFAULT_FONT_SIZE;
    private static Dictionary`2<string, float> sizes;
    public static Int32[] FONTSIZES;
    private static HtmlUtilities();
    public static float ParseLength(string str);
    public static float ParseLength(string str, float actualFontSize);
    public static BaseColor DecodeColor(string s);
    public static Properties ParseAttributes(string str);
    public static string RemoveComment(string str, string startComment, string endComment);
    public static string EliminateWhiteSpace(string content);
    public static int GetIndexedFontSize(string value, string previous);
    public static int AlignmentValue(string alignment);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.CellWrapper : object {
    private PdfPCell cell;
    private float width;
    private bool percentage;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public PdfPCell Cell { get; }
    public float Width { get; }
    public bool IsPercentage { get; }
    public CellWrapper(string tag, ChainedProperties chain);
    public virtual PdfPCell CreatePdfPCell(string tag, ChainedProperties chain);
    public virtual bool Add(IElement o);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual PdfPCell get_Cell();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual float get_Width();
    public virtual bool get_IsPercentage();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ChainedProperties : object {
    public IList`1<TagAttributes> chain;
    public string Item { get; }
    public string get_Item(string key);
    public virtual bool HasProperty(string key);
    public virtual void AddToChain(string tag, IDictionary`2<string, string> props);
    public virtual void RemoveChain(string tag);
    protected internal virtual void AdjustFontSize(IDictionary`2<string, string> attrs);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ElementFactory : object {
    private IFontProvider provider;
    public IFontProvider FontProvider { get; public set; }
    public virtual void set_FontProvider(IFontProvider value);
    public virtual IFontProvider get_FontProvider();
    public virtual Font GetFont(ChainedProperties chain);
    public virtual Chunk CreateChunk(string content, ChainedProperties chain);
    public virtual Paragraph CreateParagraph(ChainedProperties chain);
    public virtual ListItem CreateListItem(ChainedProperties chain);
    protected virtual void UpdateElement(Paragraph paragraph, ChainedProperties chain);
    protected static void SetParagraphLeading(Paragraph paragraph, string leading);
    public virtual IHyphenationEvent GetHyphenation(ChainedProperties chain);
    public virtual LineSeparator CreateLineSeparator(IDictionary`2<string, string> attrs, float offset);
    public virtual Image CreateImage(string src, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener document, IImageProvider img_provider, Dictionary`2<string, Image> img_store, string img_baseurl);
    public virtual List CreateList(string tag, ChainedProperties chain);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.HTMLTagProcessors : Dictionary`2<string, IHTMLTagProcessor> {
    public static IHTMLTagProcessor EM_STRONG_STRIKE_SUP_SUP;
    public static IHTMLTagProcessor A;
    public static IHTMLTagProcessor BR;
    public static IHTMLTagProcessor UL_OL;
    public static IHTMLTagProcessor HR;
    public static IHTMLTagProcessor SPAN;
    public static IHTMLTagProcessor H;
    public static IHTMLTagProcessor LI;
    public static IHTMLTagProcessor PRE;
    public static IHTMLTagProcessor DIV;
    public static IHTMLTagProcessor TABLE;
    public static IHTMLTagProcessor TR;
    public static IHTMLTagProcessor TD;
    public static IHTMLTagProcessor IMG;
    private static HTMLTagProcessors();
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.HTMLWorker : object {
    private static ILogger LOGGER;
    protected IDocListener document;
    protected internal IDictionary`2<string, IHTMLTagProcessor> tags;
    private StyleSheet style;
    protected Stack`1<IElement> stack;
    protected Paragraph currentParagraph;
    private ChainedProperties chain;
    public static string IMG_PROVIDER;
    public static string IMG_PROCESSOR;
    public static string IMG_STORE;
    public static string IMG_BASEURL;
    public static string FONT_PROVIDER;
    public static string LINK_PROVIDER;
    private IDictionary`2<string, object> providers;
    private ElementFactory factory;
    private Stack`1<Boolean[]> tableState;
    private bool pendingTR;
    private bool pendingTD;
    private bool pendingLI;
    private bool insidePRE;
    protected internal bool skipText;
    protected List`1<IElement> objectList;
    unknown int PageCount {public set; }
    public HTMLWorker(IDocListener document);
    public HTMLWorker(IDocListener document, IDictionary`2<string, IHTMLTagProcessor> tags, StyleSheet style);
    private static HTMLWorker();
    public virtual void SetSupportedTags(IDictionary`2<string, IHTMLTagProcessor> tags);
    public virtual void SetStyleSheet(StyleSheet style);
    public virtual void Parse(TextReader reader);
    public virtual void StartDocument();
    public virtual void StartElement(string tag, IDictionary`2<string, string> attrs);
    public virtual void Text(string content);
    public virtual void EndElement(string tag);
    public virtual void EndDocument();
    public virtual void NewLine();
    public virtual void CarriageReturn();
    public virtual void FlushContent();
    public virtual void PushToStack(IElement element);
    public virtual void UpdateChain(string tag, IDictionary`2<string, string> attrs);
    public virtual void UpdateChain(string tag);
    public virtual void SetProviders(IDictionary`2<string, object> providers);
    public virtual Chunk CreateChunk(string content);
    public virtual Paragraph CreateParagraph();
    public virtual List CreateList(string tag);
    public virtual ListItem CreateListItem();
    public virtual LineSeparator CreateLineSeparator(IDictionary`2<string, string> attrs);
    public virtual Image CreateImage(IDictionary`2<string, string> attrs);
    public virtual CellWrapper CreateCell(string tag);
    public virtual void ProcessLink();
    public virtual void ProcessList();
    public virtual void ProcessListItem();
    public virtual void ProcessImage(Image img, IDictionary`2<string, string> attrs);
    public virtual void ProcessTable();
    public virtual void ProcessRow();
    public virtual void PushTableState();
    public virtual void PopTableState();
    public virtual bool IsPendingTR();
    public virtual void SetPendingTR(bool pendingTR);
    public virtual bool IsPendingTD();
    public virtual void SetPendingTD(bool pendingTD);
    public virtual bool IsPendingLI();
    public virtual void SetPendingLI(bool pendingLI);
    public virtual bool IsInsidePRE();
    public virtual void SetInsidePRE(bool insidePRE);
    public virtual bool IsSkipText();
    public virtual void SetSkipText(bool skipText);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style, Dictionary`2<string, object> providers);
    public static List`1<IElement> ParseToList(TextReader reader, StyleSheet style, IDictionary`2<string, IHTMLTagProcessor> tags, Dictionary`2<string, object> providers);
    public virtual bool Add(IElement element);
    public virtual void Close();
    public virtual bool NewPage();
    public virtual void Open();
    public virtual void ResetPageCount();
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroring);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual void set_PageCount(int value);
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual void SetInterfaceProps(Dictionary`2<string, object> providers);
    public virtual IDictionary`2<string, object> GetInterfaceProps();
    public virtual void Dispose();
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IHTMLTagProcessor {
    public abstract virtual void StartElement(HTMLWorker worker, string tag, IDictionary`2<string, string> attrs);
    public abstract virtual void EndElement(HTMLWorker worker, string tag);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IImageProcessor {
    public abstract virtual bool Process(Image img, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener doc);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.IImageProvider {
    public abstract virtual Image GetImage(string src, IDictionary`2<string, string> attrs, ChainedProperties chain, IDocListener doc);
}
[ObsoleteAttribute]
public interface iTextSharp.text.html.simpleparser.ILinkProcessor {
    public abstract virtual bool Process(Paragraph current, ChainedProperties attrs);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.ImageStore : Dictionary`2<string, Image> {
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.StyleSheet : object {
    protected internal IDictionary`2<string, IDictionary`2<string, string>> tagMap;
    protected internal IDictionary`2<string, IDictionary`2<string, string>> classMap;
    public virtual void LoadTagStyle(string tag, IDictionary`2<string, string> attrs);
    public virtual void LoadTagStyle(string tag, string key, string value);
    public virtual void LoadStyle(string className, Dictionary`2<string, string> attrs);
    public virtual void LoadStyle(string className, string key, string value);
    public virtual void ApplyStyle(string tag, IDictionary`2<string, string> attrs);
    public static void ResolveStyleAttribute(IDictionary`2<string, string> h, ChainedProperties chain);
}
[ObsoleteAttribute]
public class iTextSharp.text.html.simpleparser.TableWrapper : object {
    private IDictionary`2<string, string> styles;
    private IList`1<IList`1<PdfPCell>> rows;
    private Single[] colWidths;
    unknown Single[] ColWidths {public set; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public TableWrapper(IDictionary`2<string, string> attrs);
    public virtual void AddRow(IList`1<PdfPCell> row);
    public virtual void set_ColWidths(Single[] value);
    public virtual PdfPTable CreateTable();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
}
[ObsoleteAttribute]
public class iTextSharp.text.html.WebColors : Dictionary`2<string, Int32[]> {
    public static WebColors NAMES;
    private static WebColors();
    private static bool MissingHashColorFormat(string colStr);
    public static BaseColor GetRGBColor(string name);
    private static int GetRGBChannelValue(string rgbChannel);
}
public interface iTextSharp.text.IDocListener {
    unknown int PageCount {public set; }
    public abstract virtual void Open();
    public abstract virtual void Close();
    public abstract virtual bool NewPage();
    public abstract virtual bool SetPageSize(Rectangle pageSize);
    public abstract virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public abstract virtual bool SetMarginMirroring(bool marginMirroring);
    public abstract virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public abstract virtual void set_PageCount(int value);
    public abstract virtual void ResetPageCount();
}
public interface iTextSharp.text.IElement {
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public abstract virtual bool Process(IElementListener listener);
    public abstract virtual int get_Type();
    public abstract virtual bool IsContent();
    public abstract virtual bool IsNestable();
    public abstract virtual IList`1<Chunk> get_Chunks();
    public abstract virtual string ToString();
}
public interface iTextSharp.text.IElementListener {
    public abstract virtual bool Add(IElement element);
}
public interface iTextSharp.text.IFontProvider {
    public abstract virtual bool IsRegistered(string fontname);
    public abstract virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color);
}
public interface iTextSharp.text.ILargeElement {
    public bool ElementComplete { get; public set; }
    public abstract virtual bool get_ElementComplete();
    public abstract virtual void set_ElementComplete(bool value);
    public abstract virtual void FlushContent();
}
public abstract class iTextSharp.text.Image : Rectangle {
    public static int DEFAULT;
    public static int RIGHT_ALIGN;
    public static int LEFT_ALIGN;
    public static int MIDDLE_ALIGN;
    public static int TEXTWRAP;
    public static int UNDERLYING;
    public static int AX;
    public static int AY;
    public static int BX;
    public static int BY;
    public static int CX;
    public static int CY;
    public static int DX;
    public static int DY;
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_JPEG;
    public static int ORIGINAL_PNG;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_BMP;
    public static int ORIGINAL_TIFF;
    public static int ORIGINAL_WMF;
    public static int ORIGINAL_JPEG2000;
    public static int ORIGINAL_JBIG2;
    protected bool invert;
    protected int type;
    protected Uri url;
    protected Byte[] rawData;
    protected PdfTemplate[] template;
    protected int alignment;
    protected string alt;
    protected float absoluteX;
    protected float absoluteY;
    protected float plainWidth;
    protected float plainHeight;
    protected float scaledWidth;
    protected float scaledHeight;
    protected int compressionLevel;
    protected float rotationRadians;
    protected int colorspace;
    protected int colortransform;
    protected int bpc;
    protected Int32[] transparency;
    protected float indentationLeft;
    protected float indentationRight;
    protected long mySerialId;
    private static object serialId;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    protected int dpiX;
    protected int dpiY;
    protected bool mask;
    protected Image imageMask;
    protected bool interpolation;
    protected Annotation annotation;
    protected ICC_Profile profile;
    protected bool deflated;
    private PdfDictionary additional;
    private bool smask;
    private float xyRatio;
    protected int originalType;
    protected Byte[] originalData;
    protected float spacingBefore;
    protected float spacingAfter;
    protected float paddingTop;
    private float widthPercentage;
    protected IPdfOCG layer;
    private float initialRotation;
    private PdfIndirectReference directReference;
    protected internal bool scaleToFitLineWhenOverflow;
    protected bool scaleToFitHeight;
    unknown float Rotation {public set; }
    unknown float RotationDegrees {public set; }
    public Annotation Annotation { get; public set; }
    public int Bpc { get; }
    public Byte[] RawData { get; }
    public PdfTemplate TemplateData { get; public set; }
    public float AbsoluteX { get; }
    public float AbsoluteY { get; }
    public int Type { get; }
    public Uri Url { get; public set; }
    public int Alignment { get; public set; }
    public string Alt { get; public set; }
    public float ScaledWidth { get; }
    public float ScaledHeight { get; }
    public int Colorspace { get; }
    public int ColorTransform { get; public set; }
    public Int32[] Transparency { get; public set; }
    public float PlainWidth { get; }
    public float PlainHeight { get; }
    public long MySerialId { get; }
    public int DpiX { get; }
    public int DpiY { get; }
    public Image ImageMask { get; public set; }
    public bool Inverted { get; public set; }
    public bool Interpolation { get; public set; }
    public ICC_Profile TagICC { get; public set; }
    public bool Deflated { get; public set; }
    public PdfDictionary Additional { get; public set; }
    public bool Smask { get; public set; }
    public float XYRatio { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public int OriginalType { get; public set; }
    public Byte[] OriginalData { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public float WidthPercentage { get; public set; }
    public bool ScaleToFitLineWhenOverflow { get; public set; }
    public bool ScaleToFitHeight { get; public set; }
    public IPdfOCG Layer { get; public set; }
    public float InitialRotation { get; public set; }
    public PdfIndirectReference DirectReference { get; public set; }
    public int CompressionLevel { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public Image(Uri url);
    public Image(Image image);
    private static Image();
    public static Image GetInstance(Image image);
    public static Image GetInstance(Uri url);
    public static Image GetInstance(Uri url, bool recoverFromImageError);
    public static Image GetInstance(Stream s);
    public static Image GetInstance(string filename, bool recoverFromImageError);
    public static Image GetInstance(Byte[] imgb);
    public static Image GetInstance(Byte[] imgb, bool recoverFromImageError);
    public static Image GetInstance(Image image, BaseColor color, bool forceBW);
    public static Image GetInstance(Image image, ImageFormat format);
    public static Image GetInstance(Image image, BaseColor color);
    public static Image GetInstance(string filename);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data);
    public static Image GetInstance(int width, int height, Byte[] data, Byte[] globals);
    public static Image GetInstance(PRIndirectReference iref);
    public static Image GetInstance(PdfTemplate template);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data, Int32[] transparency);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data, Int32[] transparency);
    public virtual void SetAbsolutePosition(float absoluteX, float absoluteY);
    public virtual void ScaleAbsolute(Rectangle rectangle);
    public virtual void ScaleAbsolute(float newWidth, float newHeight);
    public virtual void ScaleAbsoluteWidth(float newWidth);
    public virtual void ScaleAbsoluteHeight(float newHeight);
    public virtual void ScalePercent(float percent);
    public virtual void ScalePercent(float percentX, float percentY);
    public virtual void ScaleToFit(Rectangle rectangle);
    public virtual void ScaleToFit(float fitWidth, float fitHeight);
    public virtual float GetImageRotation();
    public void set_Rotation(float value);
    public virtual void set_RotationDegrees(float value);
    public virtual Annotation get_Annotation();
    public virtual void set_Annotation(Annotation value);
    public virtual int get_Bpc();
    public virtual Byte[] get_RawData();
    public virtual PdfTemplate get_TemplateData();
    public virtual void set_TemplateData(PdfTemplate value);
    public virtual bool HasAbsolutePosition();
    public virtual bool HasAbsoluteX();
    public virtual float get_AbsoluteX();
    public virtual float get_AbsoluteY();
    public virtual int get_Type();
    public virtual bool IsNestable();
    public virtual bool IsJpeg();
    public virtual bool IsImgRaw();
    public virtual bool IsImgTemplate();
    public virtual Uri get_Url();
    public virtual void set_Url(Uri value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual string get_Alt();
    public virtual void set_Alt(string value);
    public virtual float get_ScaledWidth();
    public virtual float get_ScaledHeight();
    public virtual int get_Colorspace();
    public virtual int get_ColorTransform();
    public virtual void set_ColorTransform(int value);
    public virtual Single[] GetMatrix();
    public virtual Single[] GetMatrix(float scalePercentage);
    public virtual Int32[] get_Transparency();
    public virtual void set_Transparency(Int32[] value);
    public virtual float get_PlainWidth();
    public virtual float get_PlainHeight();
    protected static long GetSerialId();
    public virtual long get_MySerialId();
    public virtual int get_DpiX();
    public virtual int get_DpiY();
    public virtual void SetDpi(int dpiX, int dpiY);
    public virtual bool IsMaskCandidate();
    public virtual void MakeMask();
    public virtual Image get_ImageMask();
    public virtual void set_ImageMask(Image value);
    public virtual bool IsMask();
    public virtual void set_Inverted(bool value);
    public virtual bool get_Inverted();
    public virtual void set_Interpolation(bool value);
    public virtual bool get_Interpolation();
    public virtual ICC_Profile get_TagICC();
    public virtual void set_TagICC(ICC_Profile value);
    public virtual bool HasICCProfile();
    public virtual bool get_Deflated();
    public virtual void set_Deflated(bool value);
    public virtual PdfDictionary get_Additional();
    public virtual void set_Additional(PdfDictionary value);
    public virtual bool get_Smask();
    public virtual void set_Smask(bool value);
    public virtual float get_XYRatio();
    public virtual void set_XYRatio(float value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual int get_OriginalType();
    public virtual void set_OriginalType(int value);
    public virtual Byte[] get_OriginalData();
    public virtual void set_OriginalData(Byte[] value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_WidthPercentage();
    public virtual void set_WidthPercentage(float value);
    public virtual bool get_ScaleToFitLineWhenOverflow();
    public virtual void set_ScaleToFitLineWhenOverflow(bool value);
    public virtual bool get_ScaleToFitHeight();
    public virtual void set_ScaleToFitHeight(bool value);
    public virtual IPdfOCG get_Layer();
    public virtual void set_Layer(IPdfOCG value);
    private PdfObject SimplifyColorspace(PdfArray obj);
    public virtual void SimplifyColorspace();
    public virtual float get_InitialRotation();
    public virtual void set_InitialRotation(float value);
    public virtual void set_DirectReference(PdfIndirectReference value);
    public virtual PdfIndirectReference get_DirectReference();
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.ImgCCITT : Image {
    public ImgCCITT(Image image);
    public ImgCCITT(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
}
public class iTextSharp.text.ImgJBIG2 : Image {
    private Byte[] global;
    private Byte[] globalHash;
    public Byte[] GlobalBytes { get; }
    public Byte[] GlobalHash { get; }
    private ImgJBIG2(Image image);
    public ImgJBIG2(int width, int height, Byte[] data, Byte[] globals);
    public virtual Byte[] get_GlobalBytes();
    public virtual Byte[] get_GlobalHash();
}
public class iTextSharp.text.ImgRaw : Image {
    public ImgRaw(Image image);
    public ImgRaw(int width, int height, int components, int bpc, Byte[] data);
}
public class iTextSharp.text.ImgTemplate : Image {
    public ImgTemplate(Image image);
    public ImgTemplate(PdfTemplate template);
}
public class iTextSharp.text.ImgWMF : Image {
    public ImgWMF(Image image);
    public ImgWMF(Uri url);
    public ImgWMF(string filename);
    public ImgWMF(Byte[] img);
    private void ProcessParameters();
    public virtual void ReadWMF(PdfTemplate template);
}
internal class iTextSharp.text.io.ArrayRandomAccessSource : object {
    private Byte[] array;
    public long Length { get; }
    public ArrayRandomAccessSource(Byte[] array);
    public virtual int Get(long offset);
    public virtual int Get(long offset, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.GetBufferedRandomAccessSource : object {
    private IRandomAccessSource source;
    private Byte[] getBuffer;
    private long getBufferStart;
    private long getBufferEnd;
    public long Length { get; }
    public GetBufferedRandomAccessSource(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
internal class iTextSharp.text.io.GroupedRandomAccessSource : object {
    private SourceEntry[] sources;
    private SourceEntry currentSourceEntry;
    private long size;
    public long Length { get; }
    public GroupedRandomAccessSource(ICollection`1<IRandomAccessSource> sources);
    protected internal virtual int GetStartingSourceIndex(long offset);
    private SourceEntry GetSourceEntryForOffset(long offset);
    protected internal virtual void SourceReleased(IRandomAccessSource source);
    protected internal virtual void SourceInUse(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.IndependentRandomAccessSource : object {
    private IRandomAccessSource source;
    public long Length { get; }
    public IndependentRandomAccessSource(IRandomAccessSource source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public interface iTextSharp.text.io.IRandomAccessSource {
    public long Length { get; }
    public abstract virtual int Get(long position);
    public abstract virtual int Get(long position, Byte[] bytes, int off, int len);
    public abstract virtual long get_Length();
    public abstract virtual void Close();
}
internal class iTextSharp.text.io.RAFRandomAccessSource : object {
    private FileStream raf;
    private long length;
    public long Length { get; }
    public RAFRandomAccessSource(FileStream raf);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public class iTextSharp.text.io.RandomAccessSourceFactory : object {
    private bool forceRead;
    private bool usePlainRandomAccess;
    private bool exclusivelyLockFile;
    public RandomAccessSourceFactory SetForceRead(bool forceRead);
    public RandomAccessSourceFactory SetExclusivelyLockFile(bool exclusivelyLockFile);
    public IRandomAccessSource CreateSource(Byte[] data);
    public IRandomAccessSource CreateSource(FileStream raf);
    public IRandomAccessSource CreateSource(Uri url);
    public IRandomAccessSource CreateSource(Stream inp);
    public IRandomAccessSource CreateBestSource(string filename);
    public IRandomAccessSource CreateRanged(IRandomAccessSource source, IList`1<long> ranges);
    private IRandomAccessSource CreateByReadingToMemory(string filename);
    private IRandomAccessSource CreateByReadingToMemory(Stream inp);
}
public class iTextSharp.text.io.RASInputStream : Stream {
    private IRandomAccessSource source;
    private long position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RASInputStream(IRandomAccessSource source);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public static class iTextSharp.text.io.StreamUtil : object {
    internal static List`1<object> resourceSearch;
    private static StreamUtil();
    public static Byte[] InputStreamToArray(Stream inp);
    public static void CopyBytes(IRandomAccessSource source, long start, long length, Stream outs);
    public static void AddToResourceSearch(object obj);
    public static Stream GetResourceStream(string key);
}
public class iTextSharp.text.io.WindowRandomAccessSource : object {
    private IRandomAccessSource source;
    private long offset;
    private long length;
    public long Length { get; }
    public WindowRandomAccessSource(IRandomAccessSource source, long offset);
    public WindowRandomAccessSource(IRandomAccessSource source, long offset, long length);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
public interface iTextSharp.text.IRtfElementInterface {
}
public interface iTextSharp.text.ISplitCharacter {
    public abstract virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public interface iTextSharp.text.ITextElementArray {
    public abstract virtual bool Add(IElement o);
}
public class iTextSharp.text.Jpeg : Image {
    public static int NOT_A_MARKER;
    public static int VALID_MARKER;
    public static Int32[] VALID_MARKERS;
    public static int UNSUPPORTED_MARKER;
    public static Int32[] UNSUPPORTED_MARKERS;
    public static int NOPARAM_MARKER;
    public static Int32[] NOPARAM_MARKERS;
    public static int M_APP0;
    public static int M_APP2;
    public static int M_APPE;
    public static int M_APPD;
    public static Byte[] JFIF_ID;
    public static Byte[] PS_8BIM_RESO;
    private Byte[][] icc;
    public Jpeg(Image image);
    public Jpeg(Uri Uri);
    public Jpeg(Byte[] img);
    public Jpeg(Byte[] img, float width, float height);
    private static Jpeg();
    private static int GetShort(Stream istr);
    private static int GetShortInverted(Stream istr);
    private static int MarkerType(int marker);
    private void ProcessParameters();
}
public class iTextSharp.text.Jpeg2000 : Image {
    public static int JP2_JP;
    public static int JP2_IHDR;
    public static int JPIP_JPIP;
    public static int JP2_FTYP;
    public static int JP2_JP2H;
    public static int JP2_COLR;
    public static int JP2_JP2C;
    public static int JP2_URL;
    public static int JP2_DBTL;
    public static int JP2_BPCC;
    public static int JP2_JP2;
    private Stream inp;
    private int boxLength;
    private int boxType;
    private int numOfComps;
    private List`1<ColorSpecBox> colorSpecBoxes;
    private bool isJp2;
    private Byte[] bpcBoxData;
    private static int ZERO_BOX_SIZE;
    public Jpeg2000(Image image);
    public Jpeg2000(Uri url);
    public Jpeg2000(Byte[] img);
    public Jpeg2000(Byte[] img, float width, float height);
    private int Cio_read(int n);
    public virtual void Jp2_read_boxhdr();
    private void ProcessParameters();
    private ColorSpecBox Jp2_read_colr();
    public virtual int GetNumOfComps();
    public virtual Byte[] GetBpcBoxData();
    public virtual List`1<ColorSpecBox> GetColorSpecBoxes();
    public virtual bool IsJp2();
}
public class iTextSharp.text.List : object {
    public static bool ORDERED;
    public static bool UNORDERED;
    public static bool NUMERICAL;
    public static bool ALPHABETICAL;
    public static bool UPPERCASE;
    public static bool LOWERCASE;
    protected List`1<IElement> list;
    protected bool numbered;
    protected bool lettered;
    protected bool lowercase;
    protected bool autoindent;
    protected bool alignindent;
    protected int first;
    protected Chunk symbol;
    protected string preSymbol;
    protected string postSymbol;
    protected float indentationLeft;
    protected float indentationRight;
    protected float symbolIndent;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public bool Numbered { get; public set; }
    public bool Lettered { get; public set; }
    public bool Lowercase { get; public set; }
    public bool IsLowercase { get; public set; }
    public bool Autoindent { get; public set; }
    public bool Alignindent { get; public set; }
    public int First { get; public set; }
    unknown Chunk ListSymbol {public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SymbolIndent { get; public set; }
    public List`1<IElement> Items { get; }
    public int Size { get; }
    public float TotalLeading { get; }
    public Chunk Symbol { get; public set; }
    public string PostSymbol { get; public set; }
    public string PreSymbol { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public List(float symbolIndent);
    public List(bool numbered);
    public List(bool numbered, bool lettered);
    public List(bool numbered, float symbolIndent);
    public List(bool numbered, bool lettered, float symbolIndent);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Add(string s);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
    protected void PopulateProperties(List clone);
    public virtual void NormalizeIndentation();
    public virtual void set_Numbered(bool value);
    public virtual bool get_Numbered();
    public virtual void set_Lettered(bool value);
    public virtual bool get_Lettered();
    public virtual void set_Lowercase(bool value);
    public virtual bool get_Lowercase();
    public virtual void set_IsLowercase(bool value);
    public virtual bool get_IsLowercase();
    public virtual void set_Autoindent(bool value);
    public virtual bool get_Autoindent();
    public virtual void set_Alignindent(bool value);
    public virtual bool get_Alignindent();
    public virtual int get_First();
    public virtual void set_First(int value);
    public virtual void set_ListSymbol(Chunk value);
    public virtual void SetListSymbol(string symbol);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual void set_SymbolIndent(float value);
    public virtual float get_SymbolIndent();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual List`1<IElement> get_Items();
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual float get_TotalLeading();
    public virtual Chunk get_Symbol();
    public virtual void set_Symbol(Chunk value);
    public virtual string getPostSymbol();
    public virtual void set_PostSymbol(string value);
    public virtual string get_PostSymbol();
    public virtual void set_PreSymbol(string value);
    public virtual string get_PreSymbol();
    public virtual ListItem GetFirstItem();
    public virtual ListItem GetLastItem();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.ListItem : Paragraph {
    protected Chunk symbol;
    private ListBody listBody;
    private ListLabel listLabel;
    public int Type { get; }
    public Chunk ListSymbol { get; public set; }
    public ListBody ListBody { get; }
    public ListLabel ListLabel { get; }
    public ListItem(float leading);
    public ListItem(Chunk chunk);
    public ListItem(string str);
    public ListItem(string str, Font font);
    public ListItem(float leading, Chunk chunk);
    public ListItem(float leading, string str);
    public ListItem(float leading, string str, Font font);
    public ListItem(Phrase phrase);
    public virtual int get_Type();
    public virtual Paragraph CloneShallow(bool spacingBefore);
    public virtual Chunk get_ListSymbol();
    public virtual void set_ListSymbol(Chunk value);
    public virtual void SetIndentationLeft(float indentation, bool autoindent);
    public virtual void AdjustListSymbolFont();
    public virtual ListBody get_ListBody();
    public virtual ListLabel get_ListLabel();
}
public class iTextSharp.text.log.CounterFactory : object {
    private static CounterFactory myself;
    private ICounter counter;
    private static CounterFactory();
    public static CounterFactory getInstance();
    public static ICounter GetCounter(Type klass);
    public virtual ICounter GetCounter();
    public virtual void SetCounter(ICounter counter);
}
public class iTextSharp.text.log.DefaultCounter : object {
    private int count;
    private int level;
    private Int32[] repeat;
    private int repeat_level;
    private static Byte[] message;
    private static DefaultCounter();
    public sealed virtual ICounter GetCounter(Type klass);
    public sealed virtual void Read(long l);
    public sealed virtual void Written(long l);
    private void PlusOne();
}
public interface iTextSharp.text.log.ICounter {
    public abstract virtual ICounter GetCounter(Type klass);
    public abstract virtual void Read(long l);
    public abstract virtual void Written(long l);
}
public interface iTextSharp.text.log.ILogger {
    public abstract virtual ILogger GetLogger(Type klass);
    public abstract virtual ILogger GetLogger(string name);
    public abstract virtual bool IsLogging(Level level);
    public abstract virtual void Warn(string message);
    public abstract virtual void Trace(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string message, Exception e);
}
public enum iTextSharp.text.log.Level : Enum {
    public int value__;
    public static Level ERROR;
    public static Level WARN;
    public static Level INFO;
    public static Level DEBUG;
    public static Level TRACE;
}
public class iTextSharp.text.log.LoggerFactory : object {
    private static LoggerFactory myself;
    private ILogger logger;
    private static LoggerFactory();
    public static ILogger GetLogger(Type klass);
    public static ILogger GetLogger(string name);
    public static LoggerFactory GetInstance();
    public virtual void SetLogger(ILogger logger);
    public virtual ILogger Logger();
}
public class iTextSharp.text.log.NoOpCounter : object {
    public virtual ICounter GetCounter(Type klass);
    public virtual void Read(long l);
    public virtual void Written(long l);
}
public class iTextSharp.text.log.NoOpLogger : object {
    public sealed virtual ILogger GetLogger(Type name);
    public sealed virtual void Warn(string message);
    public sealed virtual void Trace(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Error(string message, Exception e);
    public sealed virtual bool IsLogging(Level level);
    public sealed virtual void Error(string message);
    public sealed virtual ILogger GetLogger(string name);
}
public class iTextSharp.text.log.SysoCounter : object {
    protected string name;
    protected SysoCounter(Type klass);
    public virtual ICounter GetCounter(Type klass);
    public virtual void Read(long l);
    public virtual void Written(long l);
}
public class iTextSharp.text.log.SysoLogger : object {
    private string name;
    private int shorten;
    public SysoLogger(int packageReduce);
    protected SysoLogger(string klass, int shorten);
    public virtual ILogger GetLogger(Type klass);
    public virtual ILogger GetLogger(string name);
    public virtual bool IsLogging(Level level);
    public virtual void Warn(string message);
    private string Shorten(string className);
    public virtual void Trace(string message);
    public virtual void Debug(string message);
    public virtual void Info(string message);
    public virtual void Error(string message);
    public virtual void Error(string message, Exception e);
}
[ObsoleteAttribute]
public class iTextSharp.text.MarkedObject : object {
    protected internal IElement element;
    protected internal Properties markupAttributes;
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public Properties MarkupAttributes { get; }
    public MarkedObject(IElement element);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual Properties get_MarkupAttributes();
    public virtual void SetMarkupAttribute(string key, string value);
}
[ObsoleteAttribute]
public class iTextSharp.text.MarkedSection : MarkedObject {
    protected MarkedObject title;
    public MarkedObject Title { get; public set; }
    unknown int NumberDepth {public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    unknown float Indentation {public set; }
    unknown bool BookmarkOpen {public set; }
    unknown bool TriggerNewPage {public set; }
    unknown string BookmarkTitle {public set; }
    public MarkedSection(Section section);
    public virtual void Add(int index, IElement o);
    public virtual bool Add(IElement o);
    public virtual bool Process(IElementListener listener);
    public virtual bool AddAll(ICollection`1<T> collection);
    public virtual MarkedSection AddSection(float indentation, int numberDepth);
    public virtual MarkedSection AddSection(float indentation);
    public virtual MarkedSection AddSection(int numberDepth);
    public virtual MarkedSection AddSection();
    public virtual void set_Title(MarkedObject value);
    public virtual MarkedObject get_Title();
    public virtual void set_NumberDepth(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual void set_Indentation(float value);
    public virtual void set_BookmarkOpen(bool value);
    public virtual void set_TriggerNewPage(bool value);
    public virtual void set_BookmarkTitle(string value);
    public virtual void NewPage();
}
public class iTextSharp.text.Meta : object {
    private int type;
    private StringBuilder content;
    public static string UNKNOWN;
    public static string PRODUCER;
    public static string CREATIONDATE;
    public static string AUTHOR;
    public static string KEYWORDS;
    public static string SUBJECT;
    public static string TITLE;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public string Content { get; }
    public string Name { get; }
    public Meta(int type, string content);
    public Meta(string tag, string content);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual StringBuilder Append(string str);
    public virtual string get_Content();
    public virtual string get_Name();
    public static int GetType(string tag);
    public virtual string ToString();
}
public class iTextSharp.text.PageSize : object {
    public static Rectangle LETTER;
    public static Rectangle NOTE;
    public static Rectangle LEGAL;
    public static Rectangle TABLOID;
    public static Rectangle EXECUTIVE;
    public static Rectangle POSTCARD;
    public static Rectangle A0;
    public static Rectangle A1;
    public static Rectangle A2;
    public static Rectangle A3;
    public static Rectangle A4;
    public static Rectangle A5;
    public static Rectangle A6;
    public static Rectangle A7;
    public static Rectangle A8;
    public static Rectangle A9;
    public static Rectangle A10;
    public static Rectangle B0;
    public static Rectangle B1;
    public static Rectangle B2;
    public static Rectangle B3;
    public static Rectangle B4;
    public static Rectangle B5;
    public static Rectangle B6;
    public static Rectangle B7;
    public static Rectangle B8;
    public static Rectangle B9;
    public static Rectangle B10;
    public static Rectangle ARCH_E;
    public static Rectangle ARCH_D;
    public static Rectangle ARCH_C;
    public static Rectangle ARCH_B;
    public static Rectangle ARCH_A;
    public static Rectangle FLSA;
    public static Rectangle FLSE;
    public static Rectangle HALFLETTER;
    public static Rectangle _11X17;
    public static Rectangle ID_1;
    public static Rectangle ID_2;
    public static Rectangle ID_3;
    public static Rectangle LEDGER;
    public static Rectangle CROWN_QUARTO;
    public static Rectangle LARGE_CROWN_QUARTO;
    public static Rectangle DEMY_QUARTO;
    public static Rectangle ROYAL_QUARTO;
    public static Rectangle CROWN_OCTAVO;
    public static Rectangle LARGE_CROWN_OCTAVO;
    public static Rectangle DEMY_OCTAVO;
    public static Rectangle ROYAL_OCTAVO;
    public static Rectangle SMALL_PAPERBACK;
    public static Rectangle PENGUIN_SMALL_PAPERBACK;
    public static Rectangle PENGUIN_LARGE_PAPERBACK;
    [ObsoleteAttribute]
public static Rectangle LETTER_LANDSCAPE;
    [ObsoleteAttribute]
public static Rectangle LEGAL_LANDSCAPE;
    [ObsoleteAttribute]
public static Rectangle A4_LANDSCAPE;
    private static PageSize();
    public static Rectangle GetRectangle(string name);
}
public class iTextSharp.text.Paragraph : Phrase {
    protected int alignment;
    protected float indentationLeft;
    protected float indentationRight;
    private float firstLineIndent;
    protected float spacingBefore;
    protected float spacingAfter;
    private float extraParagraphSpace;
    protected bool keeptogether;
    protected float paddingTop;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public int Type { get; }
    public int Alignment { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public bool KeepTogether { get; public set; }
    public float FirstLineIndent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public float PaddingTop { get; public set; }
    public Paragraph(float leading);
    public Paragraph(Chunk chunk);
    public Paragraph(float leading, Chunk chunk);
    public Paragraph(string str);
    public Paragraph(string str, Font font);
    public Paragraph(float leading, string str);
    public Paragraph(float leading, string str, Font font);
    public Paragraph(Phrase phrase);
    public virtual Paragraph CloneShallow(bool spacingBefore);
    protected void PopulateProperties(Paragraph copy, bool spacingBefore);
    [ObsoleteAttribute]
public virtual Paragraph cloneShallow(bool spacingBefore);
    public virtual IList`1<IElement> BreakUp();
    [ObsoleteAttribute]
public IList`1<IElement> breakUp();
    public virtual int get_Type();
    public virtual bool Add(IElement o);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual bool get_KeepTogether();
    public virtual void set_KeepTogether(bool value);
    public virtual float get_FirstLineIndent();
    public virtual void set_FirstLineIndent(float value);
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
}
public class iTextSharp.text.pdf.AcroFields : object {
    public static int DA_FONT;
    public static int DA_SIZE;
    public static int DA_COLOR;
    public static int FIELD_TYPE_NONE;
    public static int FIELD_TYPE_PUSHBUTTON;
    public static int FIELD_TYPE_CHECKBOX;
    public static int FIELD_TYPE_RADIOBUTTON;
    public static int FIELD_TYPE_TEXT;
    public static int FIELD_TYPE_LIST;
    public static int FIELD_TYPE_COMBO;
    public static int FIELD_TYPE_SIGNATURE;
    private static Dictionary`2<string, String[]> stdFieldFontNames;
    internal PdfReader reader;
    internal PdfWriter writer;
    internal IDictionary`2<string, Item> fields;
    private int topFirst;
    private Dictionary`2<string, Int32[]> sigNames;
    private bool append;
    private Dictionary`2<int, BaseFont> extensionFonts;
    private XfaForm xfa;
    private bool lastWasString;
    private bool generateAppearances;
    private Dictionary`2<string, BaseFont> localFonts;
    private float extraMarginLeft;
    private float extraMarginTop;
    private List`1<BaseFont> substitutionFonts;
    private List`1<string> orderedSignatureNames;
    private int totalRevisions;
    private IDictionary`2<string, TextField> fieldCache;
    private static PdfName[] buttonRemove;
    public IDictionary`2<string, Item> Fields { get; }
    public bool GenerateAppearances { get; public set; }
    public int TotalRevisions { get; }
    public IDictionary`2<string, TextField> FieldCache { get; public set; }
    public List`1<BaseFont> SubstitutionFonts { get; public set; }
    public XfaForm Xfa { get; }
    private static AcroFields();
    internal AcroFields(PdfReader reader, PdfWriter writer);
    public static Object[] SplitDAelements(string da);
    private static void ClearSigDic(PdfDictionary dic);
    internal void Fill();
    public virtual String[] GetAppearanceStates(string fieldName);
    private String[] GetListOption(string fieldName, int idx);
    public virtual String[] GetListOptionExport(string fieldName);
    public virtual String[] GetListOptionDisplay(string fieldName);
    public virtual bool SetListOption(string fieldName, String[] exportValues, String[] displayValues);
    public virtual int GetFieldType(string fieldName);
    public virtual void ExportAsFdf(FdfWriter writer);
    public virtual bool RenameField(string oldName, string newName);
    public virtual void DecodeGenericDictionary(PdfDictionary merged, BaseField tx);
    internal PdfAppearance GetAppearance(PdfDictionary merged, String[] values, string fieldName);
    internal PdfAppearance GetAppearance(PdfDictionary merged, string text, string fieldName);
    internal BaseColor GetMKColor(PdfArray ar);
    public virtual string GetFieldRichValue(string name);
    public virtual string GetField(string name);
    public virtual String[] GetListSelection(string name);
    public virtual bool SetFieldProperty(string field, string name, object value, Int32[] inst);
    public virtual bool SetFieldProperty(string field, string name, int value, Int32[] inst);
    public virtual void MergeXfaData(XmlNode n);
    public virtual void SetFields(FdfReader fdf);
    public virtual void SetFields(XfdfReader xfdf);
    public virtual bool RegenerateField(string name);
    public virtual bool SetField(string name, string value);
    public virtual bool SetField(string name, string value, bool saveAppearance);
    public virtual bool SetFieldRichValue(string name, string richValue);
    public virtual bool SetField(string name, string value, string display);
    public virtual bool SetField(string name, string value, string display, bool saveAppearance);
    public virtual bool SetListSelection(string name, String[] value);
    internal bool IsInAP(PdfDictionary nDic, PdfName check);
    public virtual IDictionary`2<string, Item> get_Fields();
    public virtual Item GetFieldItem(string name);
    public virtual string GetTranslatedFieldName(string name);
    public virtual IList`1<FieldPosition> GetFieldPositions(string name);
    private int RemoveRefFromArray(PdfArray array, PdfObject refo);
    public virtual bool RemoveFieldsFromPage(int page);
    public virtual bool RemoveField(string name, int page);
    public virtual bool RemoveField(string name);
    public virtual void set_GenerateAppearances(bool value);
    public virtual bool get_GenerateAppearances();
    public virtual bool ClearSignatureField(string name);
    private void FindSignatureNames();
    public virtual List`1<string> GetSignatureNames();
    public virtual List`1<string> GetBlankSignatureNames();
    public virtual PdfDictionary GetSignatureDictionary(string name);
    public virtual PdfIndirectReference GetNormalAppearance(string name);
    public virtual bool SignatureCoversWholeDocument(string name);
    public virtual PdfPKCS7 VerifySignature(string name);
    private void UpdateByteRange(PdfPKCS7 pkcs7, PdfDictionary v);
    public virtual int get_TotalRevisions();
    public virtual int GetRevision(string field);
    public virtual Stream ExtractRevision(string field);
    public virtual void set_FieldCache(IDictionary`2<string, TextField> value);
    public virtual IDictionary`2<string, TextField> get_FieldCache();
    private void MarkUsed(PdfObject obj);
    public virtual void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public virtual void AddSubstitutionFont(BaseFont font);
    public virtual void set_SubstitutionFonts(List`1<BaseFont> value);
    public virtual List`1<BaseFont> get_SubstitutionFonts();
    public virtual XfaForm get_Xfa();
    public virtual void RemoveXfa();
    public virtual PushbuttonField GetNewPushbuttonFromField(string field);
    public virtual PushbuttonField GetNewPushbuttonFromField(string field, int order);
    public virtual bool ReplacePushbuttonField(string field, PdfFormField button);
    public virtual bool ReplacePushbuttonField(string field, PdfFormField button, int order);
    public virtual bool DoesSignatureFieldExist(string name);
}
public class iTextSharp.text.pdf.ArabicLigaturizer : object {
    private static Dictionary`2<char, Char[]> maptable;
    private static Dictionary`2<char, char> reverseLigatureMapTable;
    private static char ALEF;
    private static char ALEFHAMZA;
    private static char ALEFHAMZABELOW;
    private static char ALEFMADDA;
    private static char LAM;
    private static char HAMZA;
    private static char TATWEEL;
    private static char ZWJ;
    private static char HAMZAABOVE;
    private static char HAMZABELOW;
    private static char WAWHAMZA;
    private static char YEHHAMZA;
    private static char WAW;
    private static char ALEFMAKSURA;
    private static char YEH;
    private static char FARSIYEH;
    private static char SHADDA;
    private static char KASRA;
    private static char FATHA;
    private static char DAMMA;
    private static char MADDA;
    private static char LAM_ALEF;
    private static char LAM_ALEFHAMZA;
    private static char LAM_ALEFHAMZABELOW;
    private static char LAM_ALEFMADDA;
    private static Char[][] chartable;
    public static int ar_nothing;
    public static int ar_novowel;
    public static int ar_composedtashkeel;
    public static int ar_lig;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    private static int DIGITS_RESERVED;
    public static int DIGITS_MASK;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int DIGIT_TYPE_MASK;
    protected int options;
    protected int runDirection;
    private static ArabicLigaturizer();
    public ArabicLigaturizer(int runDirection, int options);
    private static bool IsVowel(char s);
    private static char Charshape(char s, int which);
    private static int Shapecount(char s);
    private static int Ligature(char newchar, Charstruct oldchar);
    private static void Copycstostring(StringBuilder str, Charstruct s, int level);
    internal static void Doublelig(StringBuilder str, int level);
    private static bool Connects_to_left(Charstruct a);
    internal static void Shape(Char[] text, StringBuilder str, int level);
    internal static int Arabic_shape(Char[] src, int srcoffset, int srclength, Char[] dest, int destoffset, int destlength, int level);
    internal static void ProcessNumbers(Char[] text, int offset, int length, int options);
    internal static void ShapeToArabicDigitsWithContext(Char[] dest, int start, int length, char digitBase, bool lastStrongWasAL);
    public static bool TryGetReverseMapping(char key, Char& value);
    public virtual string Process(string s);
    public virtual bool IsRTL();
}
public class iTextSharp.text.pdf.BadPdfFormatException : Exception {
    public BadPdfFormatException(string message);
    protected BadPdfFormatException(SerializationInfo info, StreamingContext context);
}
public abstract class iTextSharp.text.pdf.Barcode : object {
    public static int EAN13;
    public static int EAN8;
    public static int UPCA;
    public static int UPCE;
    public static int SUPP2;
    public static int SUPP5;
    public static int POSTNET;
    public static int PLANET;
    public static int CODE128;
    public static int CODE128_UCC;
    public static int CODE128_RAW;
    public static int CODABAR;
    protected float x;
    protected float n;
    protected BaseFont font;
    protected float size;
    protected float baseline;
    protected float barHeight;
    protected int textAlignment;
    protected bool generateChecksum;
    protected bool checksumText;
    protected bool startStopText;
    protected bool extended;
    protected string code;
    protected bool guardBars;
    protected int codeType;
    protected float inkSpreading;
    protected string altText;
    public float X { get; public set; }
    public float N { get; public set; }
    public BaseFont Font { get; public set; }
    public float Size { get; public set; }
    public float Baseline { get; public set; }
    public float BarHeight { get; public set; }
    public int TextAlignment { get; public set; }
    public bool GenerateChecksum { get; public set; }
    public bool ChecksumText { get; public set; }
    public bool StartStopText { get; public set; }
    public bool Extended { get; public set; }
    public string Code { get; public set; }
    public bool GuardBars { get; public set; }
    public int CodeType { get; public set; }
    public Rectangle BarcodeSize { get; }
    public float InkSpreading { get; public set; }
    public string AltText { get; public set; }
    public virtual float get_X();
    public virtual void set_X(float value);
    public virtual float get_N();
    public virtual void set_N(float value);
    public virtual BaseFont get_Font();
    public virtual void set_Font(BaseFont value);
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public virtual float get_Baseline();
    public virtual void set_Baseline(float value);
    public virtual float get_BarHeight();
    public virtual void set_BarHeight(float value);
    public virtual int get_TextAlignment();
    public virtual void set_TextAlignment(int value);
    public virtual void set_GenerateChecksum(bool value);
    public virtual bool get_GenerateChecksum();
    public virtual void set_ChecksumText(bool value);
    public virtual bool get_ChecksumText();
    public virtual void set_StartStopText(bool value);
    public virtual bool get_StartStopText();
    public virtual void set_Extended(bool value);
    public virtual bool get_Extended();
    public virtual string get_Code();
    public virtual void set_Code(string value);
    public virtual void set_GuardBars(bool value);
    public virtual bool get_GuardBars();
    public virtual int get_CodeType();
    public virtual void set_CodeType(int value);
    public abstract virtual Rectangle get_BarcodeSize();
    public virtual void set_InkSpreading(float value);
    public virtual float get_InkSpreading();
    public abstract virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual PdfTemplate CreateTemplateWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateImageWithBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual void set_AltText(string value);
    public virtual string get_AltText();
    public abstract virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.Barcode128 : Barcode {
    private static Byte[][] BARS;
    private static Byte[] BARS_STOP;
    public static char CODE_AB_TO_C;
    public static char CODE_AC_TO_B;
    public static char CODE_BC_TO_A;
    public static char FNC1_INDEX;
    public static char START_A;
    public static char START_B;
    public static char START_C;
    public static char FNC1;
    public static char DEL;
    public static char FNC3;
    public static char FNC2;
    public static char SHIFT;
    public static char CODE_C;
    public static char CODE_A;
    public static char FNC4;
    public static char STARTA;
    public static char STARTB;
    public static char STARTC;
    private static IntHashtable ais;
    private Barcode128CodeSet codeSet;
    public Barcode128CodeSet CodeSet { get; public set; }
    public Rectangle BarcodeSize { get; }
    unknown string Code {public set; }
    private static Barcode128();
    public static char GetStartSymbol(Barcode128CodeSet codeSet);
    public virtual Barcode128CodeSet get_CodeSet();
    public virtual void set_CodeSet(Barcode128CodeSet value);
    public static string RemoveFNC1(string code);
    public static string GetHumanReadableUCCEAN(string code);
    internal static bool IsNextDigits(string text, int textIndex, int numDigits);
    internal static string GetPackedRawDigits(string text, int textIndex, int numDigits);
    public static string GetRawText(string text, bool ucc, Barcode128CodeSet codeSet);
    public static string GetRawText(string text, bool ucc);
    public static Byte[] GetBarsCode128Raw(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual void set_Code(string value);
}
public class iTextSharp.text.pdf.Barcode39 : Barcode {
    private static Byte[][] BARS;
    private static string CHARS;
    private static string EXTENDED;
    public Rectangle BarcodeSize { get; }
    private static Barcode39();
    public static Byte[] GetBarsCode39(string text);
    public static string GetCode39Ex(string text);
    internal static char GetChecksum(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeCodabar : Barcode {
    private static Byte[][] BARS;
    private static string CHARS;
    private static int START_STOP_IDX;
    public Rectangle BarcodeSize { get; }
    private static BarcodeCodabar();
    public static Byte[] GetBarsCodabar(string text);
    public static string CalculateChecksum(string code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeDatamatrix : object {
    public static int DM_NO_ERROR;
    public static int DM_ERROR_TEXT_TOO_BIG;
    public static int DM_ERROR_INVALID_SQUARE;
    public static int DM_ERROR_EXTENSION;
    public static int DM_AUTO;
    public static int DM_ASCII;
    public static int DM_C40;
    public static int DM_TEXT;
    public static int DM_B256;
    public static int DM_X12;
    public static int DM_X21;
    public static int DM_EDIFACT;
    public static int DM_RAW;
    public static int DM_EXTENSION;
    public static int DM_TEST;
    private static byte LATCH_B256;
    private static byte LATCH_EDIFACT;
    private static byte LATCH_X12;
    private static byte LATCH_TEXT;
    private static byte LATCH_C40;
    private static byte UNLATCH;
    private static byte EXTENDED_ASCII;
    private static byte PADDING;
    private string encoding;
    public static string DEFAULT_DATA_MATRIX_ENCODING;
    private static DmParams[] dmSizes;
    private static string X12;
    private int extOut;
    private Int16[] place;
    private Byte[] image;
    private int height;
    private int width;
    private int ws;
    private int options;
    private bool forceSquareSize;
    private static Int32[][] f;
    private static Int32[][] switchMode;
    public Byte[] BitImage { get; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public int Ws { get; public set; }
    public int Options { get; public set; }
    unknown bool ForceSquareSize {public set; }
    public BarcodeDatamatrix(string code);
    public BarcodeDatamatrix(string code, string encoding);
    private static BarcodeDatamatrix();
    private void SetBit(int x, int y, int xByte);
    private void Draw(Byte[] data, int dataSize, DmParams dm);
    private static void MakePadding(Byte[] data, int position, int count);
    private static bool IsDigit(int c);
    private static int AsciiEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static int B256Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static void RandomizationAlgorithm255(Byte[] data, int j);
    private static int X12Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset);
    private static int EdifactEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, int symbolIndex, int prevEnc, int origDataOffset, bool sizeFixed);
    private static int C40OrTextEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, bool c40, int symbolIndex, int prevEnc, int origDataOffset);
    private static int MinValueInColumn(Int32[][] array, int column);
    private static int ValuePositionInColumn(Int32[][] array, int column, int value);
    private static void SolveFAndSwitchMode(Int32[] forMin, int mode, int currIndex);
    private static int GetEncodation(Byte[] text, int textOffset, int textSize, Byte[] data, int dataOffset, int dataSize, int options, bool sizeFixed);
    private static int GetNumber(Byte[] text, int ptrIn, int n);
    private int ProcessExtensions(Byte[] text, int textOffset, int textSize, Byte[] data);
    public virtual int Generate(string text);
    public virtual int Generate(string text, string encoding);
    public virtual int Generate(Byte[] text, int textOffset, int textSize);
    public virtual void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleHeight, float moduleWidth);
    public virtual Image CreateImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual Byte[] get_BitImage();
    public virtual int get_Height();
    public virtual void set_Height(int value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
    public virtual int get_Ws();
    public virtual void set_Ws(int value);
    public virtual int get_Options();
    public virtual void set_Options(int value);
    public virtual void set_ForceSquareSize(bool value);
}
public class iTextSharp.text.pdf.BarcodeEAN : Barcode {
    private static Int32[] GUARD_EMPTY;
    private static Int32[] GUARD_UPCA;
    private static Int32[] GUARD_EAN13;
    private static Int32[] GUARD_EAN8;
    private static Int32[] GUARD_UPCE;
    private static Single[] TEXTPOS_EAN13;
    private static Single[] TEXTPOS_EAN8;
    private static Byte[][] BARS;
    private static int TOTALBARS_EAN13;
    private static int TOTALBARS_EAN8;
    private static int TOTALBARS_UPCE;
    private static int TOTALBARS_SUPP2;
    private static int TOTALBARS_SUPP5;
    private static byte ODD;
    private static byte EVEN;
    private static Byte[][] PARITY13;
    private static Byte[][] PARITY2;
    private static Byte[][] PARITY5;
    private static Byte[][] PARITYE;
    public Rectangle BarcodeSize { get; }
    private static BarcodeEAN();
    public static int CalculateEANParity(string code);
    public static string ConvertUPCAtoUPCE(string text);
    public static Byte[] GetBarsEAN13(string _code);
    public static Byte[] GetBarsEAN8(string _code);
    public static Byte[] GetBarsUPCE(string _code);
    public static Byte[] GetBarsSupplemental2(string _code);
    public static Byte[] GetBarsSupplemental5(string _code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeEANSUPP : Barcode {
    protected Barcode ean;
    protected Barcode supp;
    public Rectangle BarcodeSize { get; }
    public BarcodeEANSUPP(Barcode ean, Barcode supp);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeInter25 : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodeInter25();
    public static string KeepNumbers(string text);
    public static char GetChecksum(string text);
    public static Byte[] GetBarsInter25(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodePDF417 : object {
    public static int PDF417_USE_ASPECT_RATIO;
    public static int PDF417_FIXED_RECTANGLE;
    public static int PDF417_FIXED_COLUMNS;
    public static int PDF417_FIXED_ROWS;
    public static int PDF417_AUTO_ERROR_LEVEL;
    public static int PDF417_USE_ERROR_LEVEL;
    public static int PDF417_FORCE_BINARY;
    public static int PDF417_USE_RAW_CODEWORDS;
    public static int PDF417_INVERT_BITMAP;
    public static int PDF417_USE_MACRO;
    private int macroSegmentCount;
    private int macroSegmentId;
    private string macroFileId;
    private int macroIndex;
    protected int bitPtr;
    protected int cwPtr;
    protected SegmentList segmentList;
    protected static int START_PATTERN;
    protected static int STOP_PATTERN;
    protected static int START_CODE_SIZE;
    protected static int STOP_SIZE;
    protected static int MOD;
    protected static int ALPHA;
    protected static int LOWER;
    protected static int MIXED;
    protected static int PUNCTUATION;
    protected static int ISBYTE;
    protected static int BYTESHIFT;
    protected static int PL;
    protected static int LL;
    protected static int AS;
    protected static int ML;
    protected static int AL;
    protected static int PS;
    protected static int PAL;
    protected static int SPACE;
    protected static int TEXT_MODE;
    protected static int BYTE_MODE_6;
    protected static int BYTE_MODE;
    protected static int NUMERIC_MODE;
    protected static int ABSOLUTE_MAX_TEXT_SIZE;
    protected static int MAX_DATA_CODEWORDS;
    protected static int MACRO_SEGMENT_ID;
    protected static int MACRO_LAST_SEGMENT;
    private static string MIXED_SET;
    private static string PUNCTUATION_SET;
    private static Int32[][] CLUSTERS;
    private static Int32[][] ERROR_LEVEL;
    private Byte[] outBits;
    private int bitColumns;
    private int codeRows;
    private int codeColumns;
    private Int32[] codewords;
    private int lenCodewords;
    private int errorLevel;
    private Byte[] text;
    private int options;
    private float aspectRatio;
    private float yHeight;
    unknown int MacroSegmentId {public set; }
    unknown int MacroSegmentCount {public set; }
    unknown string MacroFileId {public set; }
    public Byte[] OutBits { get; }
    public int BitColumns { get; }
    public int CodeRows { get; public set; }
    public int CodeColumns { get; public set; }
    public Int32[] Codewords { get; }
    public int LenCodewords { get; public set; }
    public int ErrorLevel { get; public set; }
    public Byte[] Text { get; public set; }
    public int Options { get; public set; }
    public float AspectRatio { get; public set; }
    public float YHeight { get; public set; }
    private static BarcodePDF417();
    public virtual void set_MacroSegmentId(int value);
    public virtual void set_MacroSegmentCount(int value);
    public virtual void set_MacroFileId(string value);
    protected virtual bool CheckSegmentType(Segment segment, char type);
    protected virtual int GetSegmentLength(Segment segment);
    public virtual void SetDefaultParameters();
    protected virtual void OutCodeword17(int codeword);
    protected virtual void OutCodeword18(int codeword);
    protected virtual void OutCodeword(int codeword);
    protected virtual void OutStopPattern();
    protected virtual void OutStartPattern();
    protected virtual void OutPaintCode();
    protected virtual void CalculateErrorCorrection(int dest);
    private static int GetTextTypeAndValue(Byte[] input, int maxLength, int idx);
    protected virtual int GetTextTypeAndValue(int maxLength, int idx);
    private void TextCompaction(Byte[] input, int start, int length);
    protected virtual void TextCompaction(int start, int length);
    protected virtual void BasicNumberCompaction(int start, int length);
    private void BasicNumberCompaction(Byte[] input, int start, int length);
    private void NumberCompaction(Byte[] input, int start, int length);
    protected virtual void NumberCompaction(int start, int length);
    protected virtual void ByteCompaction6(int start);
    internal void ByteCompaction(int start, int length);
    internal void BreakString();
    protected virtual void Assemble();
    private void MacroCodes();
    private void Append(int inp, int len);
    private void Append(string s);
    protected static int MaxPossibleErrorLevel(int remain);
    protected virtual void DumpList();
    protected virtual int GetMaxSquare();
    public virtual void PaintCode();
    public virtual Image GetImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual Byte[] get_OutBits();
    public virtual int get_BitColumns();
    public virtual void set_CodeRows(int value);
    public virtual int get_CodeRows();
    public virtual void set_CodeColumns(int value);
    public virtual int get_CodeColumns();
    public virtual Int32[] get_Codewords();
    public virtual void set_LenCodewords(int value);
    public virtual int get_LenCodewords();
    public virtual void set_ErrorLevel(int value);
    public virtual int get_ErrorLevel();
    public virtual void set_Text(Byte[] value);
    public virtual Byte[] get_Text();
    public virtual void SetText(string s);
    public virtual void set_Options(int value);
    public virtual int get_Options();
    public virtual void set_AspectRatio(float value);
    public virtual float get_AspectRatio();
    public virtual void set_YHeight(float value);
    public virtual float get_YHeight();
    public virtual void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleHeight, float moduleWidth);
    public virtual Rectangle GetBarcodeSize();
}
public class iTextSharp.text.pdf.BarcodePostnet : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodePostnet();
    public static Byte[] GetBarsPostnet(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeQRCode : object {
    private ByteMatrix bm;
    public BarcodeQRCode(string content, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private Byte[] GetBitMatrix();
    public virtual Image GetImage();
    public void PlaceBarcode(PdfContentByte cb, BaseColor foreground, float moduleSide);
    public Rectangle GetBarcodeSize();
}
public abstract class iTextSharp.text.pdf.BaseField : object {
    public static float BORDER_WIDTH_THIN;
    public static float BORDER_WIDTH_MEDIUM;
    public static float BORDER_WIDTH_THICK;
    public static int VISIBLE;
    public static int HIDDEN;
    public static int VISIBLE_BUT_DOES_NOT_PRINT;
    public static int HIDDEN_BUT_PRINTABLE;
    public static int READ_ONLY;
    public static int REQUIRED;
    public static int MULTILINE;
    public static int DO_NOT_SCROLL;
    public static int PASSWORD;
    public static int FILE_SELECTION;
    public static int DO_NOT_SPELL_CHECK;
    public static int EDIT;
    public static int MULTISELECT;
    public static int COMB;
    protected float borderWidth;
    protected int borderStyle;
    protected BaseColor borderColor;
    protected BaseColor backgroundColor;
    protected BaseColor textColor;
    protected BaseFont font;
    protected float fontSize;
    protected int alignment;
    protected PdfWriter writer;
    protected string text;
    protected Rectangle box;
    protected int rotation;
    protected int visibility;
    protected string fieldName;
    protected int options;
    protected int maxCharacterLength;
    private static Dictionary`2<PdfName, int> fieldKeys;
    protected BaseFont RealFont { get; }
    public float BorderWidth { get; public set; }
    public int BorderStyle { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    public BaseColor TextColor { get; public set; }
    public BaseFont Font { get; public set; }
    public float FontSize { get; public set; }
    public int Alignment { get; public set; }
    public string Text { get; public set; }
    public Rectangle Box { get; public set; }
    public int Rotation { get; public set; }
    public int Visibility { get; public set; }
    public string FieldName { get; public set; }
    public int Options { get; public set; }
    public int MaxCharacterLength { get; public set; }
    public PdfWriter Writer { get; public set; }
    private static BaseField();
    public BaseField(PdfWriter writer, Rectangle box, string fieldName);
    protected virtual BaseFont get_RealFont();
    protected virtual PdfAppearance GetBorderAppearance();
    protected static List`1<string> GetHardBreaks(string text);
    protected static void TrimRight(StringBuilder buf);
    protected static List`1<string> BreakLines(List`1<string> breaks, BaseFont font, float fontSize, float width);
    private void DrawTopFrame(PdfAppearance app);
    private void DrawBottomFrame(PdfAppearance app);
    public virtual void set_BorderWidth(float value);
    public virtual float get_BorderWidth();
    public virtual void set_BorderStyle(int value);
    public virtual int get_BorderStyle();
    public virtual void set_BorderColor(BaseColor value);
    public virtual BaseColor get_BorderColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_TextColor(BaseColor value);
    public virtual BaseColor get_TextColor();
    public virtual void set_Font(BaseFont value);
    public virtual BaseFont get_Font();
    public virtual void set_FontSize(float value);
    public virtual float get_FontSize();
    public virtual void set_Alignment(int value);
    public virtual int get_Alignment();
    public virtual void set_Text(string value);
    public virtual string get_Text();
    public virtual void set_Box(Rectangle value);
    public virtual Rectangle get_Box();
    public virtual void set_Rotation(int value);
    public virtual int get_Rotation();
    public virtual void SetRotationFromPage(Rectangle page);
    public virtual void set_Visibility(int value);
    public virtual int get_Visibility();
    public virtual void set_FieldName(string value);
    public virtual string get_FieldName();
    public virtual void set_Options(int value);
    public virtual int get_Options();
    public virtual void set_MaxCharacterLength(int value);
    public virtual int get_MaxCharacterLength();
    public virtual PdfWriter get_Writer();
    public virtual void set_Writer(PdfWriter value);
    public static void MoveFields(PdfDictionary from, PdfDictionary to);
}
public abstract class iTextSharp.text.pdf.BaseFont : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    public static int ASCENT;
    public static int CAPHEIGHT;
    public static int DESCENT;
    public static int ITALICANGLE;
    public static int BBOXLLX;
    public static int BBOXLLY;
    public static int BBOXURX;
    public static int BBOXURY;
    public static int AWT_ASCENT;
    public static int AWT_DESCENT;
    public static int AWT_LEADING;
    public static int AWT_MAXADVANCE;
    public static int UNDERLINE_POSITION;
    public static int UNDERLINE_THICKNESS;
    public static int STRIKETHROUGH_POSITION;
    public static int STRIKETHROUGH_THICKNESS;
    public static int SUBSCRIPT_SIZE;
    public static int SUBSCRIPT_OFFSET;
    public static int SUPERSCRIPT_SIZE;
    public static int SUPERSCRIPT_OFFSET;
    public static int WEIGHT_CLASS;
    public static int WIDTH_CLASS;
    public static int FONT_WEIGHT;
    public static int FONT_TYPE_T1;
    public static int FONT_TYPE_TT;
    public static int FONT_TYPE_CJK;
    public static int FONT_TYPE_TTUNI;
    public static int FONT_TYPE_DOCUMENT;
    public static int FONT_TYPE_T3;
    public static string IDENTITY_H;
    public static string IDENTITY_V;
    public static string CP1250;
    public static string CP1252;
    public static string CP1257;
    public static string WINANSI;
    public static string MACROMAN;
    public static Int32[] CHAR_RANGE_LATIN;
    public static Int32[] CHAR_RANGE_ARABIC;
    public static Int32[] CHAR_RANGE_HEBREW;
    public static Int32[] CHAR_RANGE_CYRILLIC;
    public static Double[] DEFAULT_FONT_MATRIX;
    public static bool EMBEDDED;
    public static bool NOT_EMBEDDED;
    public static bool CACHED;
    public static bool NOT_CACHED;
    public static string RESOURCE_PATH;
    public static char CID_NEWLINE;
    public static char PARAGRAPH_SEPARATOR;
    protected List`1<Int32[]> subsetRanges;
    internal int fontType;
    public static string notdef;
    protected Int32[] widths;
    protected String[] differences;
    protected Char[] unicodeDifferences;
    protected Int32[][] charBBoxes;
    protected string encoding;
    protected bool embedded;
    protected int compressionLevel;
    protected bool fontSpecific;
    protected static Dictionary`2<string, BaseFont> fontCache;
    protected static Dictionary`2<string, PdfName> BuiltinFonts14;
    protected bool forceWidthsOutput;
    protected bool directTextToByte;
    protected bool subset;
    protected bool fastWinansi;
    protected IntHashtable specialMap;
    private static Random random;
    protected bool vertical;
    public List`1<Int32[]> SubsetRanges { get; }
    public string Encoding { get; }
    public int FontType { get; public set; }
    public string PostscriptFontName { get; public set; }
    public string Subfamily { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[] CodePagesSupported { get; }
    public Int32[] Widths { get; }
    public String[] Differences { get; }
    public Char[] UnicodeDifferences { get; }
    public bool ForceWidthsOutput { get; public set; }
    public bool DirectTextToByte { get; public set; }
    public bool Subset { get; public set; }
    public int CompressionLevel { get; public set; }
    private static BaseFont();
    public virtual List`1<Int32[]> get_SubsetRanges();
    public static BaseFont CreateFont();
    public static BaseFont CreateFont(string name, string encoding, bool embedded);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool forceRead);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow, bool forceRead);
    public static BaseFont CreateFont(PRIndirectReference fontRef);
    public virtual bool IsVertical();
    protected static string GetBaseName(string name);
    protected static string NormalizeEncoding(string enc);
    protected virtual void CreateEncoding();
    internal abstract virtual int GetRawWidth(int c, string name);
    public abstract virtual int GetKerning(int char1, int char2);
    public abstract virtual bool SetKerning(int char1, int char2, int kern);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual int GetDescent(string text);
    public virtual int GetAscent(string text);
    public virtual float GetDescentPoint(string text, float fontSize);
    public virtual float GetAscentPoint(string text, float fontSize);
    public virtual float GetWidthPointKerned(string text, float fontSize);
    public virtual float GetWidthPoint(string text, float fontSize);
    public virtual float GetWidthPoint(int char1, float fontSize);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal abstract virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public abstract virtual PdfStream GetFullFontStream();
    public virtual string get_Encoding();
    public abstract virtual float GetFontDescriptor(int key, float fontSize);
    public virtual void SetFontDescriptor(int key, float value);
    public virtual int get_FontType();
    public virtual void set_FontType(int value);
    public virtual bool IsEmbedded();
    public virtual bool IsFontSpecific();
    public static string CreateSubsetPrefix();
    internal char GetUnicodeDifferences(int index);
    public abstract virtual string get_PostscriptFontName();
    public abstract virtual void set_PostscriptFontName(string value);
    public virtual string get_Subfamily();
    public abstract virtual String[][] get_FullFontName();
    public abstract virtual String[][] get_AllNameEntries();
    public static String[][] GetFullFontName(string name, string encoding, Byte[] ttfAfm);
    public static Object[] GetAllFontNames(string name, string encoding, Byte[] ttfAfm);
    public static String[][] GetAllNameEntries(string name, string encoding, Byte[] ttfAfm);
    public abstract virtual String[][] get_FamilyFontName();
    public virtual String[] get_CodePagesSupported();
    public static String[] EnumerateTTCNames(string ttcFile);
    public static String[] EnumerateTTCNames(Byte[] ttcArray);
    public virtual Int32[] get_Widths();
    public virtual String[] get_Differences();
    public virtual Char[] get_UnicodeDifferences();
    public virtual void set_ForceWidthsOutput(bool value);
    public virtual bool get_ForceWidthsOutput();
    public virtual void set_DirectTextToByte(bool value);
    public virtual bool get_DirectTextToByte();
    public virtual void set_Subset(bool value);
    public virtual bool get_Subset();
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public abstract virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    private static void AddFont(PRIndirectReference fontRef, IntHashtable hits, List`1<Object[]> fonts);
    private static void RecourseFonts(PdfDictionary page, IntHashtable hits, List`1<Object[]> fonts, int level, HashSet2`1<PdfDictionary> visitedResources);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader);
    public static List`1<Object[]> GetDocumentFonts(PdfReader reader, int page);
    internal static PdfDictionary createBuiltInFontDictionary(string name);
    private static PdfDictionary createBuiltInFontDictionary(PdfName name);
    public virtual Int32[] GetCharBBox(int c);
    public virtual Double[] GetFontMatrix();
    protected abstract virtual Int32[] GetRawCharBBox(int c, string name);
    public virtual void CorrectArabicAdvance();
    public virtual void AddSubsetRange(Int32[] range);
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
}
public class iTextSharp.text.pdf.BidiLine : object {
    private static int pieceSizeStart;
    protected int runDirection;
    protected int pieceSize;
    protected Char[] text;
    protected PdfChunk[] detailChunks;
    protected int totalTextLength;
    protected Byte[] orderLevels;
    protected Int32[] indexChars;
    protected internal List`1<PdfChunk> chunks;
    protected int indexChunk;
    protected int indexChunkChar;
    protected int currentChar;
    protected int storedRunDirection;
    protected Char[] storedText;
    protected PdfChunk[] storedDetailChunks;
    protected int storedTotalTextLength;
    protected Byte[] storedOrderLevels;
    protected Int32[] storedIndexChars;
    protected int storedIndexChunk;
    protected int storedIndexChunkChar;
    protected int storedCurrentChar;
    protected bool isWordSplit;
    protected bool shortStore;
    protected static IntHashtable mirrorChars;
    protected int arabicOptions;
    public BidiLine(BidiLine org);
    private static BidiLine();
    public virtual bool IsEmpty();
    public virtual void ClearChunks();
    public virtual bool GetParagraph(int runDirection);
    public virtual void AddChunk(PdfChunk chunk);
    public virtual void AddChunks(List`1<PdfChunk> chunks);
    public virtual void AddPiece(char c, PdfChunk chunk);
    public virtual void Save();
    public virtual void Restore();
    public virtual void MirrorGlyphs();
    public virtual void DoArabicShapping();
    public virtual PdfLine ProcessLine(float leftX, float width, int alignment, int runDirection, int arabicOptions, float minY, float yLine, float descender);
    private float ProcessTabStop(TabStop tabStop, float tabPosition, float originalWidth, float width, float tabStopAnchorPosition, bool isRTL, IList`1<TabStop> rtlTabsToBeAligned);
    public virtual bool IsWordSplit();
    public virtual float GetWidth(int startIdx, int lastIdx);
    public virtual float GetWidth(int startIdx, int lastIdx, float originalWidth);
    public virtual List`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx);
    public virtual List`1<PdfChunk> CreateArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk);
    public virtual Int32[] GetWord(int startIdx, int idx);
    public virtual int TrimRight(int startIdx, int endIdx);
    public virtual int TrimLeft(int startIdx, int endIdx);
    public virtual int TrimRightEx(int startIdx, int endIdx);
    public virtual int TrimLeftEx(int startIdx, int endIdx);
    public virtual void Reorder(int start, int end);
    public virtual void Flip(int start, int end);
    public static bool IsWS(char c);
    public static string ProcessLTR(string s, int runDirection, int arabicOptions);
}
public class iTextSharp.text.pdf.BidiOrder : object {
    private SByte[] initialTypes;
    private SByte[] embeddings;
    private sbyte paragraphEmbeddingLevel;
    private int textLength;
    private SByte[] resultTypes;
    private SByte[] resultLevels;
    public static sbyte L;
    public static sbyte LRE;
    public static sbyte LRO;
    public static sbyte R;
    public static sbyte AL;
    public static sbyte RLE;
    public static sbyte RLO;
    public static sbyte PDF;
    public static sbyte EN;
    public static sbyte ES;
    public static sbyte ET;
    public static sbyte AN;
    public static sbyte CS;
    public static sbyte NSM;
    public static sbyte BN;
    public static sbyte B;
    public static sbyte S;
    public static sbyte WS;
    public static sbyte ON;
    public static sbyte TYPE_MIN;
    public static sbyte TYPE_MAX;
    private static SByte[] rtypes;
    private static Char[] baseTypes;
    public BidiOrder(SByte[] types);
    public BidiOrder(SByte[] types, sbyte paragraphEmbeddingLevel);
    public BidiOrder(Char[] text, int offset, int length, sbyte paragraphEmbeddingLevel);
    private static BidiOrder();
    public static sbyte GetDirection(char c);
    private void RunAlgorithm();
    private void DetermineParagraphEmbeddingLevel();
    private void DetermineExplicitEmbeddingLevels();
    private int RemoveExplicitCodes();
    private int ReinsertExplicitCodes(int textLength);
    private static SByte[] ProcessEmbeddings(SByte[] resultTypes, sbyte paragraphEmbeddingLevel);
    private void ResolveWeakTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveNeutralTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveImplicitLevels(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    public Byte[] GetLevels();
    public Byte[] GetLevels(Int32[] linebreaks);
    private static Int32[] ComputeMultilineReordering(SByte[] levels, Int32[] linebreaks);
    private static Int32[] ComputeReordering(SByte[] levels);
    public sbyte GetBaseLevel();
    private static bool IsWhitespace(sbyte biditype);
    private static sbyte TypeForLevel(int level);
    private int FindRunLimit(int index, int limit, SByte[] validSet);
    private int FindRunStart(int index, SByte[] validSet);
    private void SetTypes(int start, int limit, sbyte newType);
    private void SetLevels(int start, int limit, sbyte newLevel);
    private static void ValidateTypes(SByte[] types);
    private static void ValidateParagraphEmbeddingLevel(sbyte paragraphEmbeddingLevel);
    private static void ValidateLineBreaks(Int32[] linebreaks, int textLength);
}
public class iTextSharp.text.pdf.ByteBuffer : Stream {
    protected int count;
    protected Byte[] buf;
    private static int byteCacheSize;
    private static Byte[][] byteCache;
    public static byte ZERO;
    private static Char[] chars;
    private static Byte[] bytes;
    public static bool HIGH_PRECISION;
    public int Size { get; public set; }
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ByteBuffer(int size);
    private static ByteBuffer();
    public static void SetCacheSize(int size);
    public static void FillCache(int decimals);
    private static Byte[] ConvertToBytes(int i);
    public virtual ByteBuffer Append_i(int b);
    public virtual ByteBuffer Append(Byte[] b, int off, int len);
    public virtual ByteBuffer Append(Byte[] b);
    public virtual ByteBuffer Append(string str);
    public virtual ByteBuffer Append(char c);
    public virtual ByteBuffer Append(ByteBuffer buf);
    public virtual ByteBuffer Append(int i);
    public virtual ByteBuffer Append(long i);
    public virtual ByteBuffer Append(byte b);
    public virtual ByteBuffer AppendHex(byte b);
    public virtual ByteBuffer Append(float i);
    public virtual ByteBuffer Append(double d);
    public static string FormatDouble(double d);
    public static string FormatDouble(double d, ByteBuffer buf);
    public virtual void Reset();
    public virtual Byte[] ToByteArray();
    public virtual int get_Size();
    public virtual void set_Size(int value);
    public virtual string ToString();
    public virtual void WriteTo(Stream str);
    private Char[] ConvertToChar(Byte[] buf);
    public virtual Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.pdf.CFFFont : object {
    internal static String[] operatorNames;
    internal static String[] standardStrings;
    internal int nextIndexOffset;
    protected string key;
    protected Object[] args;
    protected int arg_count;
    protected RandomAccessFileOrArray buf;
    private int offSize;
    protected int nameIndexOffset;
    protected int topdictIndexOffset;
    protected int stringIndexOffset;
    protected int gsubrIndexOffset;
    protected Int32[] nameOffsets;
    protected Int32[] topdictOffsets;
    protected Int32[] stringOffsets;
    protected Int32[] gsubrOffsets;
    protected Font[] fonts;
    public CFFFont(RandomAccessFileOrArray inputbuffer);
    private static CFFFont();
    public virtual string GetString(char sid);
    internal char GetCard8();
    internal char GetCard16();
    internal int GetOffset(int offSize);
    internal void Seek(int offset);
    internal short GetShort();
    internal int GetInt();
    internal int GetPosition();
    internal Int32[] GetIndex(int nextIndexOffset);
    protected virtual void GetDictItem();
    protected virtual RangeItem GetEntireIndexRange(int indexOffset);
    public virtual Byte[] GetCID(string fontName);
    public virtual bool IsCID(string fontName);
    public virtual bool Exists(string fontName);
    public virtual String[] GetNames();
    internal void ReadEncoding(int nextIndexOffset);
}
public class iTextSharp.text.pdf.CFFFontSubset : CFFFont {
    internal static String[] SubrsFunctions;
    internal static String[] SubrsEscapeFuncs;
    internal static byte ENDCHAR_OP;
    internal static byte RETURN_OP;
    internal Dictionary`2<int, Int32[]> GlyphsUsed;
    internal List`1<int> glyphsInList;
    internal Dictionary`2<int, object> FDArrayUsed;
    internal Dictionary`2[] hSubrsUsed;
    internal List`1[] lSubrsUsed;
    internal Dictionary`2<int, Int32[]> hGSubrsUsed;
    internal List`1<int> lGSubrsUsed;
    internal Dictionary`2<int, Int32[]> hSubrsUsedNonCID;
    internal List`1<int> lSubrsUsedNonCID;
    internal Byte[][] NewLSubrsIndex;
    internal Byte[] NewSubrsIndexNonCID;
    internal Byte[] NewGSubrsIndex;
    internal Byte[] NewCharStringsIndex;
    internal int GBias;
    internal List`1<Item> OutputList;
    internal int NumOfHints;
    public CFFFontSubset(RandomAccessFileOrArray rf, Dictionary`2<int, Int32[]> GlyphsUsed);
    private static CFFFontSubset();
    internal int CountCharset(int Offset, int NumofGlyphs);
    private int CountRange(int NumofGlyphs, int Type);
    protected virtual void ReadFDSelect(int Font);
    protected virtual void BuildFDArrayUsed(int Font);
    protected virtual void ReadFDArray(int Font);
    public virtual Byte[] Process(string fontName);
    protected virtual int CalcBias(int Offset, int Font);
    protected virtual void BuildNewCharString(int FontIndex);
    protected virtual void BuildNewLGSubrs(int Font);
    protected virtual void BuildFDSubrsOffsets(int Font, int FD);
    protected virtual void BuildSubrUsed(int Font, int FD, int SubrOffset, Int32[] SubrsOffsets, Dictionary`2<int, Int32[]> hSubr, List`1<int> lSubr);
    protected virtual void BuildGSubrsUsed(int Font);
    protected virtual void ReadASubr(int begin, int end, int GBias, int LBias, Dictionary`2<int, Int32[]> hSubr, List`1<int> lSubr, Int32[] LSubrsOffsets);
    protected virtual void HandelStack();
    protected virtual int StackOpp();
    protected virtual void EmptyStack();
    protected virtual void PopStack();
    protected virtual void PushStack();
    protected virtual void ReadCommand();
    protected virtual int CalcHints(int begin, int end, int LBias, int GBias, Int32[] LSubrsOffsets);
    protected virtual Byte[] BuildNewIndex(Int32[] Offsets, Dictionary`2<int, Int32[]> Used, byte OperatorForUnusedEntries);
    protected virtual Byte[] BuildNewIndexAndCopyAllGSubrs(Int32[] Offsets, byte OperatorForUnusedEntries);
    protected virtual Byte[] AssembleIndex(Int32[] NewOffsets, Byte[] NewObjects);
    protected virtual Byte[] BuildNewFile(int Font);
    protected virtual void CopyHeader();
    protected virtual void BuildIndexHeader(int Count, int Offsize, int First);
    protected virtual void CreateKeys(OffsetItem fdarrayRef, OffsetItem fdselectRef, OffsetItem charsetRef, OffsetItem charstringsRef);
    protected virtual void CreateNewStringIndex(int Font);
    protected virtual void CreateFDSelect(OffsetItem fdselectRef, int nglyphs);
    protected virtual void CreateCharset(OffsetItem charsetRef, int nglyphs);
    protected virtual void CreateFDArray(OffsetItem fdarrayRef, OffsetItem privateRef, int Font);
    private void Reconstruct(int Font);
    private void ReconstructFDArray(int Font, OffsetItem[] fdPrivate);
    internal void ReconstructPrivateDict(int Font, OffsetItem[] fdPrivate, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal void ReconstructPrivateSubrs(int Font, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal int CalcSubrOffsetSize(int Offset, int Size);
    protected virtual int CountEntireIndexRange(int indexOffset);
    internal void CreateNonCIDPrivate(int Font, OffsetItem Subr);
    internal void CreateNonCIDSubrs(int Font, IndexBaseItem PrivateBase, OffsetItem Subrs);
}
internal class iTextSharp.text.pdf.CJKFont : BaseFont {
    internal static string CJK_ENCODING;
    private static int FIRST;
    private static int BRACKET;
    private static int SERIAL;
    private static int V1Y;
    internal static Properties cjkFonts;
    internal static Properties cjkEncodings;
    private static Dictionary`2<string, Dictionary`2<string, object>> allFonts;
    private static bool propertiesLoaded;
    public static string RESOURCE_PATH_CMAP;
    private static Dictionary`2<string, Dictionary`2<string, object>> registryNames;
    private CMapCidByte cidByte;
    private CMapUniCid uniCid;
    private CMapCidUni cidUni;
    private string uniMap;
    private string fontName;
    private string style;
    private string CMap;
    private bool cidDirect;
    private IntHashtable vMetrics;
    private IntHashtable hMetrics;
    private Dictionary`2<string, object> fontDesc;
    private static Char[] cspace;
    internal string UniMap { get; }
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal CJKFont(string fontName, string enc, bool emb);
    private static CJKFont();
    private static void LoadProperties();
    private static void LoadRegistry();
    internal string get_UniMap();
    private void LoadCMaps();
    public static string GetCompatibleFont(string enc);
    public static bool IsCJKFont(string fontName, string enc);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    private PdfDictionary GetFontDescriptor();
    private PdfDictionary GetCIDFont(PdfIndirectReference fontDescriptor, IntHashtable cjkTag);
    private PdfDictionary GetFontBaseType(PdfIndirectReference CIDFont);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    private float GetDescNumber(string name);
    private float GetBBox(int idx);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    internal static IntHashtable CreateMetric(string s);
    internal static string ConvertToHCIDMetrics(Int32[] keys, IntHashtable h);
    internal static string ConvertToVCIDMetrics(Int32[] keys, IntHashtable v, IntHashtable h);
    internal static Dictionary`2<string, object> ReadFontProperties(string name);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual bool IsIdentity();
}
public class iTextSharp.text.pdf.CMapAwareDocumentFont : DocumentFont {
    private static ILogger LOGGER;
    private PdfDictionary fontDic;
    private int spaceWidth;
    private CMapToUnicode toUnicodeCmap;
    private CMapByteCid byteCid;
    private CMapCidUni cidUni;
    private Char[] cidbyte2uni;
    private IDictionary`2<int, int> uni2cid;
    public CMapAwareDocumentFont(PdfDictionary font);
    public CMapAwareDocumentFont(PRIndirectReference refFont);
    private static CMapAwareDocumentFont();
    private void InitFont();
    private void ProcessToUnicode();
    private void ProcessUni2Byte();
    private int ComputeAverageWidth();
    public virtual int GetWidth(int char1);
    private string DecodeSingleCID(Byte[] bytes, int offset, int len);
    public virtual string Decode(Byte[] cidbytes, int offset, int len);
    public virtual string DecodeSingleCharacter(Byte[] cidbytes, int offset, int len);
    public virtual string Encode(Byte[] bytes, int offset, int len);
}
public class iTextSharp.text.pdf.CMYKColor : ExtendedColor {
    private float ccyan;
    private float cmagenta;
    private float cyellow;
    private float cblack;
    public float Cyan { get; }
    public float Magenta { get; }
    public float Yellow { get; }
    public float Black { get; }
    public CMYKColor(int intCyan, int intMagenta, int intYellow, int intBlack);
    public CMYKColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack);
    public virtual float get_Cyan();
    public virtual float get_Magenta();
    public virtual float get_Yellow();
    public virtual float get_Black();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.codec.BitFile : object {
    private Stream output_;
    private Byte[] buffer_;
    private int index_;
    private int bitsLeft_;
    private bool blocks_;
    public BitFile(Stream output, bool blocks);
    public virtual void Flush();
    public virtual void WriteBits(int bits, int numbits);
}
public class iTextSharp.text.pdf.codec.BmpImage : object {
    private Stream inputStream;
    private long bitmapFileSize;
    private long bitmapOffset;
    private long compression;
    private long imageSize;
    private Byte[] palette;
    private int imageType;
    private int numBands;
    private bool isBottomUp;
    private int bitsPerPixel;
    private int redMask;
    private int greenMask;
    private int blueMask;
    private int alphaMask;
    public Dictionary`2<string, object> properties;
    private long xPelsPerMeter;
    private long yPelsPerMeter;
    private static int VERSION_2_1_BIT;
    private static int VERSION_2_4_BIT;
    private static int VERSION_2_8_BIT;
    private static int VERSION_2_24_BIT;
    private static int VERSION_3_1_BIT;
    private static int VERSION_3_4_BIT;
    private static int VERSION_3_8_BIT;
    private static int VERSION_3_24_BIT;
    private static int VERSION_3_NT_16_BIT;
    private static int VERSION_3_NT_32_BIT;
    private static int VERSION_4_1_BIT;
    private static int VERSION_4_4_BIT;
    private static int VERSION_4_8_BIT;
    private static int VERSION_4_16_BIT;
    private static int VERSION_4_24_BIT;
    private static int VERSION_4_32_BIT;
    private static int LCS_CALIBRATED_RGB;
    private static int LCS_sRGB;
    private static int LCS_CMYK;
    private static int BI_RGB;
    private static int BI_RLE8;
    private static int BI_RLE4;
    private static int BI_BITFIELDS;
    private int width;
    private int height;
    internal BmpImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    protected virtual void Process(Stream stream, bool noHeader);
    private Byte[] GetPalette(int group);
    private Image GetImage();
    private Image IndexedModel(Byte[] bdata, int bpc, int paletteEntries);
    private void ReadPalette(int sizeOfPalette);
    private Image Read1Bit(int paletteEntries);
    private Image Read4Bit(int paletteEntries);
    private Image Read8Bit(int paletteEntries);
    private void Read24Bit(Byte[] bdata);
    private int FindMask(int mask);
    private int FindShift(int mask);
    private Image Read1632Bit(bool is32);
    private Image ReadRLE8();
    private Image ReadRLE4();
    private Byte[] DecodeRLE(bool is8, Byte[] values);
    private int ReadUnsignedByte(Stream stream);
    private int ReadUnsignedShort(Stream stream);
    private int ReadShort(Stream stream);
    private int ReadWord(Stream stream);
    private long ReadUnsignedInt(Stream stream);
    private int ReadInt(Stream stream);
    private long ReadDWord(Stream stream);
    private int ReadLong(Stream stream);
}
public class iTextSharp.text.pdf.codec.CCITTG4Encoder : object {
    private int rowbytes;
    private int rowpixels;
    private int bit;
    private int data;
    private Byte[] refline;
    private ByteBuffer outBuf;
    private Byte[] dataBp;
    private int offsetData;
    private int sizeData;
    private static Byte[] zeroruns;
    private static Byte[] oneruns;
    private static int LENGTH;
    private static int CODE;
    private static int RUNLEN;
    private static int EOL;
    private static int G3CODE_EOL;
    private static int G3CODE_INVALID;
    private static int G3CODE_EOF;
    private static int G3CODE_INCOMP;
    private Int32[][] TIFFFaxWhiteCodes;
    private Int32[][] TIFFFaxBlackCodes;
    private Int32[] horizcode;
    private Int32[] passcode;
    private Int32[][] vcodes;
    private Int32[] msbmask;
    public CCITTG4Encoder(int width);
    private static CCITTG4Encoder();
    public virtual void Fax4Encode(Byte[] data, int offset, int size);
    public static Byte[] Compress(Byte[] data, int width, int height);
    public virtual void Fax4Encode(Byte[] data, int height);
    private void Putcode(Int32[] table);
    private void Putspan(int span, Int32[][] tab);
    private void PutBits(int bits, int length);
    private void Fax3Encode2DRow();
    private void Fax4PostEncode();
    public virtual Byte[] Close();
    private int Pixel(Byte[] data, int offset, int bit);
    private static int Find1span(Byte[] bp, int offset, int bs, int be);
    private static int Find0span(Byte[] bp, int offset, int bs, int be);
    private static int Finddiff(Byte[] bp, int offset, int bs, int be, int color);
    private static int Finddiff2(Byte[] bp, int offset, int bs, int be, int color);
}
public class iTextSharp.text.pdf.codec.GifImage : object {
    protected Stream inp;
    protected int width;
    protected int height;
    protected bool gctFlag;
    protected int bgIndex;
    protected int bgColor;
    protected int pixelAspect;
    protected bool lctFlag;
    protected bool interlace;
    protected int lctSize;
    protected int ix;
    protected int iy;
    protected int iw;
    protected int ih;
    protected Byte[] block;
    protected int blockSize;
    protected int dispose;
    protected bool transparency;
    protected int delay;
    protected int transIndex;
    protected static int MaxStackSize;
    protected Int16[] prefix;
    protected Byte[] suffix;
    protected Byte[] pixelStack;
    protected Byte[] pixels;
    protected Byte[] m_out;
    protected int m_bpc;
    protected int m_gbpc;
    protected Byte[] m_global_table;
    protected Byte[] m_local_table;
    protected Byte[] m_curr_table;
    protected int m_line_stride;
    protected Byte[] fromData;
    protected Uri fromUrl;
    internal List`1<GifFrame> frames;
    public GifImage(Uri url);
    public GifImage(string file);
    public GifImage(Byte[] data);
    public GifImage(Stream isp);
    public virtual int GetFrameCount();
    public virtual Image GetImage(int frame);
    public virtual Int32[] GetFramePosition(int frame);
    public virtual Int32[] GetLogicalScreen();
    internal void Process(Stream isp);
    protected virtual void ReadHeader();
    protected virtual void ReadLSD();
    protected virtual int ReadShort();
    protected virtual int ReadBlock();
    protected virtual Byte[] ReadColorTable(int bpc);
    protected static int NewBpc(int bpc);
    protected virtual void ReadContents();
    protected virtual void ReadImage();
    protected virtual bool DecodeImageData();
    protected virtual void SetPixel(int x, int y, int v);
    protected virtual void ResetFrame();
    protected virtual void ReadGraphicControlExt();
    protected virtual void Skip();
    private void ReadFully(Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.JBIG2Image : object {
    public static Byte[] GetGlobalSegment(RandomAccessFileOrArray ra);
    public static Image GetJbig2Image(RandomAccessFileOrArray ra, int page);
    public static int GetNumberOfPages(RandomAccessFileOrArray ra);
}
public class iTextSharp.text.pdf.codec.JBIG2SegmentReader : object {
    public static int SYMBOL_DICTIONARY;
    public static int INTERMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_LOSSLESS_TEXT_REGION;
    public static int PATTERN_DICTIONARY;
    public static int INTERMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_LOSSLESS_HALFTONE_REGION;
    public static int INTERMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REGION;
    public static int INTERMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REFINEMENT_REGION;
    public static int PAGE_INFORMATION;
    public static int END_OF_PAGE;
    public static int END_OF_STRIPE;
    public static int END_OF_FILE;
    public static int PROFILES;
    public static int TABLES;
    public static int EXTENSION;
    private SortedDictionary`2<int, JBIG2Segment> segments;
    private SortedDictionary`2<int, JBIG2Page> pages;
    private SortedDictionary`2<JBIG2Segment, object> globals;
    private RandomAccessFileOrArray ra;
    private bool sequential;
    private bool number_of_pages_known;
    private int number_of_pages;
    private bool read;
    public JBIG2SegmentReader(RandomAccessFileOrArray ra);
    public static Byte[] CopyByteArray(Byte[] b);
    public virtual void Read();
    private void ReadSegment(JBIG2Segment s);
    private JBIG2Segment ReadHeader();
    private void ReadFileHeader();
    public virtual int NumberOfPages();
    public virtual int GetPageHeight(int i);
    public virtual int GetPageWidth(int i);
    public virtual JBIG2Page GetPage(int page);
    public virtual Byte[] GetGlobal(bool for_embedding);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.codec.LZWCompressor : object {
    private int codeSize_;
    private int clearCode_;
    private int endOfInfo_;
    private int numBits_;
    private int limit_;
    private short prefix_;
    private BitFile bf_;
    private LZWStringTable lzss_;
    private bool tiffFudge_;
    public LZWCompressor(Stream outp, int codeSize, bool TIFF);
    public virtual void Compress(Byte[] buf, int offset, int length);
    public virtual void Flush();
}
public class iTextSharp.text.pdf.codec.LZWStringTable : object {
    private static int RES_CODES;
    private static short HASH_FREE;
    private static short NEXT_FIRST;
    private static int MAXBITS;
    private static int MAXSTR;
    private static short HASHSIZE;
    private static short HASHSTEP;
    private Byte[] strChr_;
    private Int16[] strNxt_;
    private Int16[] strHsh_;
    private short numStrings_;
    private Int32[] strLen_;
    public virtual int AddCharString(short index, byte b);
    public virtual short FindCharString(short index, byte b);
    public virtual void ClearTable(int codesize);
    public static int Hash(short index, byte lastbyte);
    public virtual int ExpandCode(Byte[] buf, int offset, short code, int skipHead);
}
public class iTextSharp.text.pdf.codec.PngImage : object {
    public static Int32[] PNGID;
    public static string IHDR;
    public static string PLTE;
    public static string IDAT;
    public static string IEND;
    public static string tRNS;
    public static string pHYs;
    public static string gAMA;
    public static string cHRM;
    public static string sRGB;
    public static string iCCP;
    private ILogger LOGGER;
    private static int TRANSFERSIZE;
    private static int PNG_FILTER_NONE;
    private static int PNG_FILTER_SUB;
    private static int PNG_FILTER_UP;
    private static int PNG_FILTER_AVERAGE;
    private static int PNG_FILTER_PAETH;
    private static PdfName[] intents;
    private Stream isp;
    private Stream dataStream;
    private int width;
    private int height;
    private int bitDepth;
    private int colorType;
    private int compressionMethod;
    private int filterMethod;
    private int interlaceMethod;
    private PdfDictionary additional;
    private Byte[] image;
    private Byte[] smask;
    private Byte[] trans;
    private MemoryStream idat;
    private int dpiX;
    private int dpiY;
    private float XYRatio;
    private bool genBWMask;
    private bool palShades;
    private int transRedGray;
    private int transGreen;
    private int transBlue;
    private int inputBands;
    private int bytesPerPixel;
    private Byte[] colorTable;
    private float gamma;
    private bool hasCHRM;
    private float xW;
    private float yW;
    private float xR;
    private float yR;
    private float xG;
    private float yG;
    private float xB;
    private float yB;
    private PdfName intent;
    private ICC_Profile icc_profile;
    private PngImage(Stream isp);
    private static PngImage();
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    private static bool CheckMarker(string s);
    private void ReadPng();
    private PdfObject GetColorspace();
    private Image GetImage();
    private void DecodeIdat();
    private void DecodePass(int xOffset, int yOffset, int xStep, int yStep, int passWidth, int passHeight);
    private void ProcessPixels(Byte[] curr, int xOffset, int step, int y, int width);
    private static int GetPixel(Byte[] image, int x, int y, int bitDepth, int bytesPerRow);
    private static void SetPixel(Byte[] image, Int32[] data, int offset, int size, int x, int y, int bitDepth, int bytesPerRow);
    private Int32[] GetPixel(Byte[] curr);
    private int GetExpectedIccNumberOfComponents();
    private void CheckIccProfile();
    private static void DecodeSubFilter(Byte[] curr, int count, int bpp);
    private static void DecodeUpFilter(Byte[] curr, Byte[] prev, int count);
    private static void DecodeAverageFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    private static int PaethPredictor(int a, int b, int c);
    private static void DecodePaethFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    public static int GetInt(Stream isp);
    public static int GetWord(Stream isp);
    public static string GetString(Stream isp);
    private static void ReadFully(Stream inp, Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.PngWriter : object {
    private static Byte[] PNG_SIGNTURE;
    private static Byte[] IHDR;
    private static Byte[] PLTE;
    private static Byte[] IDAT;
    private static Byte[] IEND;
    private static Byte[] iCCP;
    private static UInt32[] crc_table;
    private Stream outp;
    public PngWriter(Stream outp);
    private static PngWriter();
    public virtual void WriteHeader(int width, int height, int bitDepth, int colorType);
    public virtual void WriteEnd();
    public virtual void WriteData(Byte[] data, int stride);
    public virtual void WritePalette(Byte[] data);
    public virtual void WriteIccProfile(Byte[] data);
    private static void make_crc_table();
    private static UInt32 update_crc(UInt32 crc, Byte[] buf, int offset, int len);
    private static UInt32 crc(Byte[] buf, int offset, int len);
    private static UInt32 crc(Byte[] buf);
    public virtual void OutputInt(int n);
    public static void OutputInt(int n, Stream s);
    public virtual void WriteChunk(Byte[] chunkType, Byte[] data);
}
public class iTextSharp.text.pdf.codec.TIFFConstants : object {
    public static int TIFFTAG_SUBFILETYPE;
    public static int FILETYPE_REDUCEDIMAGE;
    public static int FILETYPE_PAGE;
    public static int FILETYPE_MASK;
    public static int TIFFTAG_OSUBFILETYPE;
    public static int OFILETYPE_IMAGE;
    public static int OFILETYPE_REDUCEDIMAGE;
    public static int OFILETYPE_PAGE;
    public static int TIFFTAG_IMAGEWIDTH;
    public static int TIFFTAG_IMAGELENGTH;
    public static int TIFFTAG_BITSPERSAMPLE;
    public static int TIFFTAG_COMPRESSION;
    public static int COMPRESSION_NONE;
    public static int COMPRESSION_CCITTRLE;
    public static int COMPRESSION_CCITTFAX3;
    public static int COMPRESSION_CCITTFAX4;
    public static int COMPRESSION_LZW;
    public static int COMPRESSION_OJPEG;
    public static int COMPRESSION_JPEG;
    public static int COMPRESSION_NEXT;
    public static int COMPRESSION_CCITTRLEW;
    public static int COMPRESSION_PACKBITS;
    public static int COMPRESSION_THUNDERSCAN;
    public static int COMPRESSION_IT8CTPAD;
    public static int COMPRESSION_IT8LW;
    public static int COMPRESSION_IT8MP;
    public static int COMPRESSION_IT8BL;
    public static int COMPRESSION_PIXARFILM;
    public static int COMPRESSION_PIXARLOG;
    public static int COMPRESSION_DEFLATE;
    public static int COMPRESSION_ADOBE_DEFLATE;
    public static int COMPRESSION_DCS;
    public static int COMPRESSION_JBIG;
    public static int COMPRESSION_SGILOG;
    public static int COMPRESSION_SGILOG24;
    public static int TIFFTAG_PHOTOMETRIC;
    public static int PHOTOMETRIC_MINISWHITE;
    public static int PHOTOMETRIC_MINISBLACK;
    public static int PHOTOMETRIC_RGB;
    public static int PHOTOMETRIC_PALETTE;
    public static int PHOTOMETRIC_MASK;
    public static int PHOTOMETRIC_SEPARATED;
    public static int PHOTOMETRIC_YCBCR;
    public static int PHOTOMETRIC_CIELAB;
    public static int PHOTOMETRIC_LOGL;
    public static int PHOTOMETRIC_LOGLUV;
    public static int TIFFTAG_THRESHHOLDING;
    public static int THRESHHOLD_BILEVEL;
    public static int THRESHHOLD_HALFTONE;
    public static int THRESHHOLD_ERRORDIFFUSE;
    public static int TIFFTAG_CELLWIDTH;
    public static int TIFFTAG_CELLLENGTH;
    public static int TIFFTAG_FILLORDER;
    public static int FILLORDER_MSB2LSB;
    public static int FILLORDER_LSB2MSB;
    public static int TIFFTAG_DOCUMENTNAME;
    public static int TIFFTAG_IMAGEDESCRIPTION;
    public static int TIFFTAG_MAKE;
    public static int TIFFTAG_MODEL;
    public static int TIFFTAG_STRIPOFFSETS;
    public static int TIFFTAG_ORIENTATION;
    public static int ORIENTATION_TOPLEFT;
    public static int ORIENTATION_TOPRIGHT;
    public static int ORIENTATION_BOTRIGHT;
    public static int ORIENTATION_BOTLEFT;
    public static int ORIENTATION_LEFTTOP;
    public static int ORIENTATION_RIGHTTOP;
    public static int ORIENTATION_RIGHTBOT;
    public static int ORIENTATION_LEFTBOT;
    public static int TIFFTAG_SAMPLESPERPIXEL;
    public static int TIFFTAG_ROWSPERSTRIP;
    public static int TIFFTAG_STRIPBYTECOUNTS;
    public static int TIFFTAG_MINSAMPLEVALUE;
    public static int TIFFTAG_MAXSAMPLEVALUE;
    public static int TIFFTAG_XRESOLUTION;
    public static int TIFFTAG_YRESOLUTION;
    public static int TIFFTAG_PLANARCONFIG;
    public static int PLANARCONFIG_CONTIG;
    public static int PLANARCONFIG_SEPARATE;
    public static int TIFFTAG_PAGENAME;
    public static int TIFFTAG_XPOSITION;
    public static int TIFFTAG_YPOSITION;
    public static int TIFFTAG_FREEOFFSETS;
    public static int TIFFTAG_FREEBYTECOUNTS;
    public static int TIFFTAG_GRAYRESPONSEUNIT;
    public static int GRAYRESPONSEUNIT_10S;
    public static int GRAYRESPONSEUNIT_100S;
    public static int GRAYRESPONSEUNIT_1000S;
    public static int GRAYRESPONSEUNIT_10000S;
    public static int GRAYRESPONSEUNIT_100000S;
    public static int TIFFTAG_GRAYRESPONSECURVE;
    public static int TIFFTAG_GROUP3OPTIONS;
    public static int GROUP3OPT_2DENCODING;
    public static int GROUP3OPT_UNCOMPRESSED;
    public static int GROUP3OPT_FILLBITS;
    public static int TIFFTAG_GROUP4OPTIONS;
    public static int GROUP4OPT_UNCOMPRESSED;
    public static int TIFFTAG_RESOLUTIONUNIT;
    public static int RESUNIT_NONE;
    public static int RESUNIT_INCH;
    public static int RESUNIT_CENTIMETER;
    public static int TIFFTAG_PAGENUMBER;
    public static int TIFFTAG_COLORRESPONSEUNIT;
    public static int COLORRESPONSEUNIT_10S;
    public static int COLORRESPONSEUNIT_100S;
    public static int COLORRESPONSEUNIT_1000S;
    public static int COLORRESPONSEUNIT_10000S;
    public static int COLORRESPONSEUNIT_100000S;
    public static int TIFFTAG_TRANSFERFUNCTION;
    public static int TIFFTAG_SOFTWARE;
    public static int TIFFTAG_DATETIME;
    public static int TIFFTAG_ARTIST;
    public static int TIFFTAG_HOSTCOMPUTER;
    public static int TIFFTAG_PREDICTOR;
    public static int PREDICTOR_NONE;
    public static int PREDICTOR_HORIZONTAL_DIFFERENCING;
    public static int TIFFTAG_WHITEPOINT;
    public static int TIFFTAG_PRIMARYCHROMATICITIES;
    public static int TIFFTAG_COLORMAP;
    public static int TIFFTAG_HALFTONEHINTS;
    public static int TIFFTAG_TILEWIDTH;
    public static int TIFFTAG_TILELENGTH;
    public static int TIFFTAG_TILEOFFSETS;
    public static int TIFFTAG_TILEBYTECOUNTS;
    public static int TIFFTAG_BADFAXLINES;
    public static int TIFFTAG_CLEANFAXDATA;
    public static int CLEANFAXDATA_CLEAN;
    public static int CLEANFAXDATA_REGENERATED;
    public static int CLEANFAXDATA_UNCLEAN;
    public static int TIFFTAG_CONSECUTIVEBADFAXLINES;
    public static int TIFFTAG_SUBIFD;
    public static int TIFFTAG_INKSET;
    public static int INKSET_CMYK;
    public static int TIFFTAG_INKNAMES;
    public static int TIFFTAG_NUMBEROFINKS;
    public static int TIFFTAG_DOTRANGE;
    public static int TIFFTAG_TARGETPRINTER;
    public static int TIFFTAG_EXTRASAMPLES;
    public static int EXTRASAMPLE_UNSPECIFIED;
    public static int EXTRASAMPLE_ASSOCALPHA;
    public static int EXTRASAMPLE_UNASSALPHA;
    public static int TIFFTAG_SAMPLEFORMAT;
    public static int SAMPLEFORMAT_UINT;
    public static int SAMPLEFORMAT_INT;
    public static int SAMPLEFORMAT_IEEEFP;
    public static int SAMPLEFORMAT_VOID;
    public static int SAMPLEFORMAT_COMPLEXINT;
    public static int SAMPLEFORMAT_COMPLEXIEEEFP;
    public static int TIFFTAG_SMINSAMPLEVALUE;
    public static int TIFFTAG_SMAXSAMPLEVALUE;
    public static int TIFFTAG_JPEGTABLES;
    public static int TIFFTAG_JPEGPROC;
    public static int JPEGPROC_BASELINE;
    public static int JPEGPROC_LOSSLESS;
    public static int TIFFTAG_JPEGIFOFFSET;
    public static int TIFFTAG_JPEGIFBYTECOUNT;
    public static int TIFFTAG_JPEGRESTARTINTERVAL;
    public static int TIFFTAG_JPEGLOSSLESSPREDICTORS;
    public static int TIFFTAG_JPEGPOINTTRANSFORM;
    public static int TIFFTAG_JPEGQTABLES;
    public static int TIFFTAG_JPEGDCTABLES;
    public static int TIFFTAG_JPEGACTABLES;
    public static int TIFFTAG_YCBCRCOEFFICIENTS;
    public static int TIFFTAG_YCBCRSUBSAMPLING;
    public static int TIFFTAG_YCBCRPOSITIONING;
    public static int YCBCRPOSITION_CENTERED;
    public static int YCBCRPOSITION_COSITED;
    public static int TIFFTAG_REFERENCEBLACKWHITE;
    public static int TIFFTAG_REFPTS;
    public static int TIFFTAG_REGIONTACKPOINT;
    public static int TIFFTAG_REGIONWARPCORNERS;
    public static int TIFFTAG_REGIONAFFINE;
    public static int TIFFTAG_MATTEING;
    public static int TIFFTAG_DATATYPE;
    public static int TIFFTAG_IMAGEDEPTH;
    public static int TIFFTAG_TILEDEPTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLWIDTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLLENGTH;
    public static int TIFFTAG_PIXAR_TEXTUREFORMAT;
    public static int TIFFTAG_PIXAR_WRAPMODES;
    public static int TIFFTAG_PIXAR_FOVCOT;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA;
    public static int TIFFTAG_WRITERSERIALNUMBER;
    public static int TIFFTAG_COPYRIGHT;
    public static int TIFFTAG_RICHTIFFIPTC;
    public static int TIFFTAG_IT8SITE;
    public static int TIFFTAG_IT8COLORSEQUENCE;
    public static int TIFFTAG_IT8HEADER;
    public static int TIFFTAG_IT8RASTERPADDING;
    public static int TIFFTAG_IT8BITSPERRUNLENGTH;
    public static int TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH;
    public static int TIFFTAG_IT8COLORTABLE;
    public static int TIFFTAG_IT8IMAGECOLORINDICATOR;
    public static int TIFFTAG_IT8BKGCOLORINDICATOR;
    public static int TIFFTAG_IT8IMAGECOLORVALUE;
    public static int TIFFTAG_IT8BKGCOLORVALUE;
    public static int TIFFTAG_IT8PIXELINTENSITYRANGE;
    public static int TIFFTAG_IT8TRANSPARENCYINDICATOR;
    public static int TIFFTAG_IT8COLORCHARACTERIZATION;
    public static int TIFFTAG_FRAMECOUNT;
    public static int TIFFTAG_ICCPROFILE;
    public static int TIFFTAG_PHOTOSHOP;
    public static int TIFFTAG_JBIGOPTIONS;
    public static int TIFFTAG_FAXRECVPARAMS;
    public static int TIFFTAG_FAXSUBADDRESS;
    public static int TIFFTAG_FAXRECVTIME;
    public static int TIFFTAG_STONITS;
    public static int TIFFTAG_FEDEX_EDR;
    public static int TIFFTAG_DCSHUESHIFTVALUES;
}
public class iTextSharp.text.pdf.codec.TIFFDirectory : object {
    private bool isBigEndian;
    private int numEntries;
    private TIFFField[] fields;
    private Dictionary`2<int, int> fieldIndex;
    private long IFDOffset;
    private long nextIFDOffset;
    private static Int32[] sizeOfType;
    public TIFFDirectory(RandomAccessFileOrArray stream, int directory);
    public TIFFDirectory(RandomAccessFileOrArray stream, long ifd_offset, int directory);
    private static TIFFDirectory();
    private static bool IsValidEndianTag(int endian);
    private void Initialize(RandomAccessFileOrArray stream);
    public virtual int GetNumEntries();
    public virtual TIFFField GetField(int tag);
    public virtual bool IsTagPresent(int tag);
    public virtual Int32[] GetTags();
    public virtual TIFFField[] GetFields();
    public virtual byte GetFieldAsByte(int tag, int index);
    public virtual byte GetFieldAsByte(int tag);
    public virtual long GetFieldAsLong(int tag, int index);
    public virtual long GetFieldAsLong(int tag);
    public virtual float GetFieldAsFloat(int tag, int index);
    public virtual float GetFieldAsFloat(int tag);
    public virtual double GetFieldAsDouble(int tag, int index);
    public virtual double GetFieldAsDouble(int tag);
    private short ReadShort(RandomAccessFileOrArray stream);
    private int ReadUnsignedShort(RandomAccessFileOrArray stream);
    private int ReadInt(RandomAccessFileOrArray stream);
    private long ReadUnsignedInt(RandomAccessFileOrArray stream);
    private long ReadLong(RandomAccessFileOrArray stream);
    private float ReadFloat(RandomAccessFileOrArray stream);
    private double ReadDouble(RandomAccessFileOrArray stream);
    private static int ReadUnsignedShort(RandomAccessFileOrArray stream, bool isBigEndian);
    private static long ReadUnsignedInt(RandomAccessFileOrArray stream, bool isBigEndian);
    public static int GetNumDirectories(RandomAccessFileOrArray stream);
    public virtual bool IsBigEndian();
    public virtual long GetIFDOffset();
    public virtual long GetNextIFDOffset();
}
public class iTextSharp.text.pdf.codec.TIFFFaxDecoder : object {
    private int bitPointer;
    private int bytePointer;
    private Byte[] data;
    private int w;
    private int h;
    private long fillOrder;
    private int changingElemSize;
    private Int32[] prevChangingElems;
    private Int32[] currChangingElems;
    private int lastChangingElement;
    private int compression;
    private int uncompressedMode;
    private int fillBits;
    private int oneD;
    private bool recoverFromImageError;
    private static Int32[] table1;
    private static Int32[] table2;
    internal static Byte[] flipTable;
    private static Int16[] white;
    private static Int16[] additionalMakeup;
    private static Int16[] initBlack;
    private static Int16[] twoBitBlack;
    private static Int16[] black;
    private static Byte[] twoDCodes;
    unknown bool RecoverFromImageError {public set; }
    public TIFFFaxDecoder(long fillOrder, int w, int h);
    private static TIFFFaxDecoder();
    public static void ReverseBits(Byte[] b);
    public virtual void Decode1D(Byte[] buffer, Byte[] compData, int startX, int height);
    public virtual void DecodeNextScanline(Byte[] buffer, int lineOffset, int bitOffset);
    public virtual void Decode2D(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT4Options);
    public virtual void DecodeT6(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT6Options);
    private void SetToBlack(Byte[] buffer, int lineOffset, int bitOffset, int numBits);
    private int DecodeWhiteCodeWord();
    private int DecodeBlackCodeWord();
    private int ReadEOL(bool isFirstEOL);
    private void GetNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int NextNBits(int bitsToGet);
    private int NextLesserThan8Bits(int bitsToGet);
    private void UpdatePointer(int bitsToMoveBack);
    private bool AdvancePointer();
    public virtual void set_RecoverFromImageError(bool value);
}
public class iTextSharp.text.pdf.codec.TIFFFaxDecompressor : object {
    protected int fillOrder;
    protected int compression;
    private int t4Options;
    private int t6Options;
    public int fails;
    protected int uncompressedMode;
    protected int fillBits;
    protected int oneD;
    private Byte[] data;
    private int bitPointer;
    private int bytePointer;
    private Byte[] buffer;
    private int w;
    private int h;
    private int bitsPerScanline;
    private int lineBitNum;
    private int changingElemSize;
    private Int32[] prevChangingElems;
    private Int32[] currChangingElems;
    private int lastChangingElement;
    private static Int32[] table1;
    private static Int32[] table2;
    internal static Byte[] flipTable;
    private static Int16[] white;
    private static Int16[] additionalMakeup;
    private static Int16[] initBlack;
    private static Int16[] twoBitBlack;
    private static Int16[] black;
    private static Byte[] twoDCodes;
    private static TIFFFaxDecompressor();
    public virtual void SetOptions(int fillOrder, int compression, int t4Options, int t6Options);
    public virtual void DecodeRaw(Byte[] buffer, Byte[] compData, int w, int h);
    public virtual void DecodeRLE();
    public virtual void DecodeNextScanline();
    public virtual void DecodeT4();
    public virtual void DecodeT6();
    private void SetToBlack(int bitNum, int numBits);
    private int DecodeWhiteCodeWord();
    private int DecodeBlackCodeWord();
    private int FindNextLine();
    private void GetNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int NextNBits(int bitsToGet);
    private int NextLesserThan8Bits(int bitsToGet);
    private void UpdatePointer(int bitsToMoveBack);
}
public class iTextSharp.text.pdf.codec.TIFFField : object {
    public static int TIFF_BYTE;
    public static int TIFF_ASCII;
    public static int TIFF_SHORT;
    public static int TIFF_LONG;
    public static int TIFF_RATIONAL;
    public static int TIFF_SBYTE;
    public static int TIFF_UNDEFINED;
    public static int TIFF_SSHORT;
    public static int TIFF_SLONG;
    public static int TIFF_SRATIONAL;
    public static int TIFF_FLOAT;
    public static int TIFF_DOUBLE;
    private int tag;
    private int type;
    private int count;
    private object data;
    public TIFFField(int tag, int type, int count, object data);
    public virtual int GetTag();
    public int GetType();
    public virtual int GetCount();
    public virtual Byte[] GetAsBytes();
    public virtual Char[] GetAsChars();
    public virtual Int16[] GetAsShorts();
    public virtual Int32[] GetAsInts();
    public virtual Int64[] GetAsLongs();
    public virtual Single[] GetAsFloats();
    public virtual Double[] GetAsDoubles();
    public virtual Int32[][] GetAsSRationals();
    public virtual Int64[][] GetAsRationals();
    public virtual int GetAsInt(int index);
    public virtual long GetAsLong(int index);
    public virtual float GetAsFloat(int index);
    public virtual double GetAsDouble(int index);
    public virtual string GetAsString(int index);
    public virtual Int32[] GetAsSRational(int index);
    public virtual Int64[] GetAsRational(int index);
    public virtual int CompareTo(TIFFField o);
}
public class iTextSharp.text.pdf.codec.TiffImage : object {
    public static int GetNumberOfPages(RandomAccessFileOrArray s);
    private static int GetDpi(TIFFField fd, int resolutionUnit);
    public static Image GetTiffImage(RandomAccessFileOrArray s, bool recoverFromImageError, int page, bool direct);
    public static Image GetTiffImage(RandomAccessFileOrArray s, bool recoverFromImageError, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page, bool direct);
    protected static Image GetTiffImageColor(TIFFDirectory dir, RandomAccessFileOrArray s);
    private static Image ProcessExtraSamples(ZDeflaterOutputStream zip, ZDeflaterOutputStream mzip, Byte[] outBuf, int samplePerPixel, int bitsPerSample, int width, int height);
    private static Int64[] GetArrayLongShort(TIFFDirectory dir, int tag);
    public static void DecodePackbits(Byte[] data, Byte[] dst);
    public static void Inflate(Byte[] deflated, Byte[] inflated);
    public static void ApplyPredictor(Byte[] uncompData, int predictor, int w, int h, int samplesPerPixel);
}
public class iTextSharp.text.pdf.codec.TIFFLZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Byte[] uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int dstIndex;
    private int w;
    private int h;
    private int predictor;
    private int samplesPerPixel;
    private int nextData;
    private int nextBits;
    private Int32[] andTable;
    public TIFFLZWDecoder(int w, int predictor, int samplesPerPixel);
    public virtual Byte[] Decode(Byte[] data, Byte[] uncompData, int h);
    public virtual void InitializeStringTable();
    public virtual void WriteString(Byte[] strn);
    public virtual void AddStringToTable(Byte[] oldString, byte newString);
    public virtual void AddStringToTable(Byte[] strn);
    public virtual Byte[] ComposeString(Byte[] oldString, byte newString);
    public virtual int GetNextCode();
}
public class iTextSharp.text.pdf.codec.TiffWriter : object {
    private SortedDictionary`2<int, FieldBase> ifd;
    public virtual void AddField(FieldBase field);
    public virtual int GetIfdSize();
    public virtual void WriteFile(Stream stream);
    public static void WriteShort(int v, Stream stream);
    public static void WriteLong(int v, Stream stream);
    public static void CompressLZW(Stream stream, int predictor, Byte[] b, int height, int samplesPerPixel, int stride);
}
public class iTextSharp.text.pdf.codec.wmf.InputMeta : object {
    private Stream sr;
    private int length;
    public int Length { get; }
    public InputMeta(Stream istr);
    public virtual int ReadWord();
    public virtual int ReadShort();
    public virtual int ReadInt();
    public virtual int ReadByte();
    public virtual void Skip(int len);
    public virtual int get_Length();
    public virtual BaseColor ReadColor();
}
public class iTextSharp.text.pdf.codec.wmf.MetaBrush : MetaObject {
    public static int BS_SOLID;
    public static int BS_NULL;
    public static int BS_HATCHED;
    public static int BS_PATTERN;
    public static int BS_DIBPATTERN;
    public static int HS_HORIZONTAL;
    public static int HS_VERTICAL;
    public static int HS_FDIAGONAL;
    public static int HS_BDIAGONAL;
    public static int HS_CROSS;
    public static int HS_DIAGCROSS;
    private int style;
    private int hatch;
    private BaseColor color;
    public int Style { get; }
    public int Hatch { get; }
    public BaseColor Color { get; }
    public virtual void Init(InputMeta meta);
    public virtual int get_Style();
    public virtual int get_Hatch();
    public virtual BaseColor get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaDo : object {
    public static int META_SETBKCOLOR;
    public static int META_SETBKMODE;
    public static int META_SETMAPMODE;
    public static int META_SETROP2;
    public static int META_SETRELABS;
    public static int META_SETPOLYFILLMODE;
    public static int META_SETSTRETCHBLTMODE;
    public static int META_SETTEXTCHAREXTRA;
    public static int META_SETTEXTCOLOR;
    public static int META_SETTEXTJUSTIFICATION;
    public static int META_SETWINDOWORG;
    public static int META_SETWINDOWEXT;
    public static int META_SETVIEWPORTORG;
    public static int META_SETVIEWPORTEXT;
    public static int META_OFFSETWINDOWORG;
    public static int META_SCALEWINDOWEXT;
    public static int META_OFFSETVIEWPORTORG;
    public static int META_SCALEVIEWPORTEXT;
    public static int META_LINETO;
    public static int META_MOVETO;
    public static int META_EXCLUDECLIPRECT;
    public static int META_INTERSECTCLIPRECT;
    public static int META_ARC;
    public static int META_ELLIPSE;
    public static int META_FLOODFILL;
    public static int META_PIE;
    public static int META_RECTANGLE;
    public static int META_ROUNDRECT;
    public static int META_PATBLT;
    public static int META_SAVEDC;
    public static int META_SETPIXEL;
    public static int META_OFFSETCLIPRGN;
    public static int META_TEXTOUT;
    public static int META_BITBLT;
    public static int META_STRETCHBLT;
    public static int META_POLYGON;
    public static int META_POLYLINE;
    public static int META_ESCAPE;
    public static int META_RESTOREDC;
    public static int META_FILLREGION;
    public static int META_FRAMEREGION;
    public static int META_INVERTREGION;
    public static int META_PAINTREGION;
    public static int META_SELECTCLIPREGION;
    public static int META_SELECTOBJECT;
    public static int META_SETTEXTALIGN;
    public static int META_CHORD;
    public static int META_SETMAPPERFLAGS;
    public static int META_EXTTEXTOUT;
    public static int META_SETDIBTODEV;
    public static int META_SELECTPALETTE;
    public static int META_REALIZEPALETTE;
    public static int META_ANIMATEPALETTE;
    public static int META_SETPALENTRIES;
    public static int META_POLYPOLYGON;
    public static int META_RESIZEPALETTE;
    public static int META_DIBBITBLT;
    public static int META_DIBSTRETCHBLT;
    public static int META_DIBCREATEPATTERNBRUSH;
    public static int META_STRETCHDIB;
    public static int META_EXTFLOODFILL;
    public static int META_DELETEOBJECT;
    public static int META_CREATEPALETTE;
    public static int META_CREATEPATTERNBRUSH;
    public static int META_CREATEPENINDIRECT;
    public static int META_CREATEFONTINDIRECT;
    public static int META_CREATEBRUSHINDIRECT;
    public static int META_CREATEREGION;
    public PdfContentByte cb;
    public InputMeta meta;
    private int left;
    private int top;
    private int right;
    private int bottom;
    private int inch;
    private MetaState state;
    public MetaDo(Stream meta, PdfContentByte cb);
    public virtual void ReadAll();
    public virtual void OutputText(int x, int y, int flag, int x1, int y1, int x2, int y2, string text);
    public virtual bool IsNullStrokeFill(bool isRectangle);
    public virtual void StrokeAndFill();
    internal static double GetArc(double xCenter, double yCenter, double xDot, double yDot);
    public static Byte[] WrapBMP(Image image);
    public static void WriteWord(Stream os, int v);
    public static void WriteDWord(Stream os, int v);
}
public class iTextSharp.text.pdf.codec.wmf.MetaFont : MetaObject {
    private static String[] fontNames;
    internal static int MARKER_BOLD;
    internal static int MARKER_ITALIC;
    internal static int MARKER_COURIER;
    internal static int MARKER_HELVETICA;
    internal static int MARKER_TIMES;
    internal static int MARKER_SYMBOL;
    internal static int DEFAULT_PITCH;
    internal static int FIXED_PITCH;
    internal static int VARIABLE_PITCH;
    internal static int FF_DONTCARE;
    internal static int FF_ROMAN;
    internal static int FF_SWISS;
    internal static int FF_MODERN;
    internal static int FF_SCRIPT;
    internal static int FF_DECORATIVE;
    internal static int BOLDTHRESHOLD;
    internal static int nameSize;
    internal static int ETO_OPAQUE;
    internal static int ETO_CLIPPED;
    private int height;
    private float angle;
    private int bold;
    private int italic;
    private bool underline;
    private bool strikeout;
    private int charset;
    private int pitchAndFamily;
    private string faceName;
    private BaseFont font;
    public BaseFont Font { get; }
    public float Angle { get; }
    private static MetaFont();
    public virtual void Init(InputMeta meta);
    public virtual BaseFont get_Font();
    public virtual float get_Angle();
    public virtual bool IsUnderline();
    public virtual bool IsStrikeout();
    public virtual float GetFontSize(MetaState state);
}
public class iTextSharp.text.pdf.codec.wmf.MetaObject : object {
    public static int META_NOT_SUPPORTED;
    public static int META_PEN;
    public static int META_BRUSH;
    public static int META_FONT;
    public int type;
    public int Type { get; }
    public MetaObject(int type);
    public virtual int get_Type();
}
public class iTextSharp.text.pdf.codec.wmf.MetaPen : MetaObject {
    public static int PS_SOLID;
    public static int PS_DASH;
    public static int PS_DOT;
    public static int PS_DASHDOT;
    public static int PS_DASHDOTDOT;
    public static int PS_NULL;
    public static int PS_INSIDEFRAME;
    private int style;
    private int penWidth;
    private BaseColor color;
    public int Style { get; }
    public int PenWidth { get; }
    public BaseColor Color { get; }
    public virtual void Init(InputMeta meta);
    public virtual int get_Style();
    public virtual int get_PenWidth();
    public virtual BaseColor get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaState : object {
    public static int TA_NOUPDATECP;
    public static int TA_UPDATECP;
    public static int TA_LEFT;
    public static int TA_RIGHT;
    public static int TA_CENTER;
    public static int TA_TOP;
    public static int TA_BOTTOM;
    public static int TA_BASELINE;
    public static int TRANSPARENT;
    public static int OPAQUE;
    public static int ALTERNATE;
    public static int WINDING;
    public Stack`1<MetaState> savedStates;
    public List`1<MetaObject> MetaObjects;
    public Point currentPoint;
    public MetaPen currentPen;
    public MetaBrush currentBrush;
    public MetaFont currentFont;
    public BaseColor currentBackgroundColor;
    public BaseColor currentTextColor;
    public int backgroundMode;
    public int polyFillMode;
    public int lineJoin;
    public int textAlign;
    public int offsetWx;
    public int offsetWy;
    public int extentWx;
    public int extentWy;
    public float scalingX;
    public float scalingY;
    unknown MetaState metaState {public set; }
    unknown float ScalingX {public set; }
    unknown float ScalingY {public set; }
    unknown int OffsetWx {public set; }
    unknown int OffsetWy {public set; }
    unknown int ExtentWx {public set; }
    unknown int ExtentWy {public set; }
    public Point CurrentPoint { get; public set; }
    public MetaBrush CurrentBrush { get; }
    public MetaPen CurrentPen { get; }
    public MetaFont CurrentFont { get; }
    public BaseColor CurrentBackgroundColor { get; public set; }
    public BaseColor CurrentTextColor { get; public set; }
    public int BackgroundMode { get; public set; }
    public int TextAlign { get; public set; }
    public int PolyFillMode { get; public set; }
    unknown PdfContentByte LineJoinRectangle {public set; }
    unknown PdfContentByte LineJoinPolygon {public set; }
    public bool LineNeutral { get; }
    public MetaState(MetaState state);
    private static MetaState();
    public virtual void set_metaState(MetaState value);
    public virtual void AddMetaObject(MetaObject obj);
    public virtual void SelectMetaObject(int index, PdfContentByte cb);
    public virtual void DeleteMetaObject(int index);
    public virtual void SaveState(PdfContentByte cb);
    public virtual void RestoreState(int index, PdfContentByte cb);
    public virtual void Cleanup(PdfContentByte cb);
    public virtual float TransformX(int x);
    public virtual float TransformY(int y);
    public virtual void set_ScalingX(float value);
    public virtual void set_ScalingY(float value);
    public virtual void set_OffsetWx(int value);
    public virtual void set_OffsetWy(int value);
    public virtual void set_ExtentWx(int value);
    public virtual void set_ExtentWy(int value);
    public virtual float TransformAngle(float angle);
    public virtual Point get_CurrentPoint();
    public virtual void set_CurrentPoint(Point value);
    public virtual MetaBrush get_CurrentBrush();
    public virtual MetaPen get_CurrentPen();
    public virtual MetaFont get_CurrentFont();
    public virtual BaseColor get_CurrentBackgroundColor();
    public virtual void set_CurrentBackgroundColor(BaseColor value);
    public virtual BaseColor get_CurrentTextColor();
    public virtual void set_CurrentTextColor(BaseColor value);
    public virtual int get_BackgroundMode();
    public virtual void set_BackgroundMode(int value);
    public virtual int get_TextAlign();
    public virtual void set_TextAlign(int value);
    public virtual int get_PolyFillMode();
    public virtual void set_PolyFillMode(int value);
    public virtual void set_LineJoinRectangle(PdfContentByte value);
    public virtual void set_LineJoinPolygon(PdfContentByte value);
    public virtual bool get_LineNeutral();
}
public class iTextSharp.text.pdf.codec.wmf.Point : object {
    public int x;
    public int y;
    public Point(int x, int y);
}
public class iTextSharp.text.pdf.collection.PdfCollection : PdfDictionary {
    public static int DETAILS;
    public static int TILE;
    public static int HIDDEN;
    public static int CUSTOM;
    unknown string InitialDocument {public set; }
    public PdfCollectionSchema Schema { get; public set; }
    unknown PdfCollectionSort Sort {public set; }
    public PdfCollection(int type);
    public virtual void set_InitialDocument(string value);
    public virtual void set_Schema(PdfCollectionSchema value);
    public virtual PdfCollectionSchema get_Schema();
    public virtual void set_Sort(PdfCollectionSort value);
}
public class iTextSharp.text.pdf.collection.PdfCollectionField : PdfDictionary {
    public static int TEXT;
    public static int DATE;
    public static int NUMBER;
    public static int FILENAME;
    public static int DESC;
    public static int MODDATE;
    public static int CREATIONDATE;
    public static int SIZE;
    protected internal int fieldType;
    unknown int Order {public set; }
    unknown bool Visible {public set; }
    unknown bool Editable {public set; }
    public PdfCollectionField(string name, int type);
    public virtual void set_Order(int value);
    public virtual void set_Visible(bool value);
    public virtual void set_Editable(bool value);
    public virtual bool IsCollectionItem();
    public virtual PdfObject GetValue(string v);
}
public class iTextSharp.text.pdf.collection.PdfCollectionItem : PdfDictionary {
    internal PdfCollectionSchema schema;
    public PdfCollectionItem(PdfCollectionSchema schema);
    public virtual void AddItem(string key, string value);
    public virtual void AddItem(string key, PdfString value);
    public virtual void AddItem(string key, PdfDate d);
    public virtual void AddItem(string key, PdfNumber n);
    public virtual void AddItem(string key, DateTime c);
    public virtual void AddItem(string key, int i);
    public virtual void AddItem(string key, float f);
    public virtual void AddItem(string key, double d);
    public virtual void SetPrefix(string key, string prefix);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSchema : PdfDictionary {
    public virtual void AddField(string name, PdfCollectionField field);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSort : PdfDictionary {
    public PdfCollectionSort(string key);
    public PdfCollectionSort(String[] keys);
    public virtual void SetSortOrder(bool ascending);
    public virtual void SetSortOrder(Boolean[] ascending);
}
public class iTextSharp.text.pdf.collection.PdfTargetDictionary : PdfDictionary {
    unknown string EmbeddedFileName {public set; }
    unknown string FileAttachmentPagename {public set; }
    unknown int FileAttachmentPage {public set; }
    unknown string FileAttachmentName {public set; }
    unknown int FileAttachmentIndex {public set; }
    unknown PdfTargetDictionary AdditionalPath {public set; }
    public PdfTargetDictionary(PdfTargetDictionary nested);
    public PdfTargetDictionary(bool child);
    public virtual void set_EmbeddedFileName(string value);
    public virtual void set_FileAttachmentPagename(string value);
    public virtual void set_FileAttachmentPage(int value);
    public virtual void set_FileAttachmentName(string value);
    public virtual void set_FileAttachmentIndex(int value);
    public virtual void set_AdditionalPath(PdfTargetDictionary value);
}
public class iTextSharp.text.pdf.ColorDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName colorSpaceName;
    private ICachedColorSpace colorSpace;
    public PdfIndirectReference IndirectReference { get; }
    internal PdfName ColorSpaceName { get; }
    internal ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, ICachedColorSpace scolor);
    public virtual PdfIndirectReference get_IndirectReference();
    internal virtual PdfName get_ColorSpaceName();
    public virtual PdfObject GetPdfObject(PdfWriter writer);
}
public class iTextSharp.text.pdf.ColumnText : object {
    private ILogger LOGGER;
    public static int AR_NOVOWEL;
    public static int AR_COMPOSEDTASHKEEL;
    public static int AR_LIG;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    protected int runDirection;
    public static float GLOBAL_SPACE_CHAR_RATIO;
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected static int LINE_STATUS_OK;
    protected static int LINE_STATUS_OFFLIMITS;
    protected static int LINE_STATUS_NOLINE;
    protected float maxY;
    protected float minY;
    protected float leftX;
    protected float rightX;
    protected int alignment;
    protected List`1<Single[]> leftWall;
    protected List`1<Single[]> rightWall;
    protected BidiLine bidiLine;
    protected bool isWordSplit;
    protected float yLine;
    protected float lastX;
    protected float currentLeading;
    protected float fixedLeading;
    protected float multipliedLeading;
    protected PdfContentByte canvas;
    protected PdfContentByte[] canvases;
    protected int lineStatus;
    protected float indent;
    protected float followingIndent;
    protected float rightIndent;
    protected float extraParagraphSpace;
    protected float rectangularWidth;
    protected bool rectangularMode;
    private float spaceCharRatio;
    private bool lastWasNewline;
    private bool repeatFirstLineIndent;
    private int linesWritten;
    private float firstLineY;
    private bool firstLineYDone;
    private int arabicOptions;
    protected float descender;
    protected bool composite;
    protected ColumnText compositeColumn;
    protected internal List`1<IElement> compositeElements;
    protected int listIdx;
    protected int rowIdx;
    private int splittedRow;
    protected Phrase waitPhrase;
    private bool useAscender;
    private bool inheritGraphicState;
    private bool ignoreSpacingBefore;
    private float filledWidth;
    private bool adjustFirstLine;
    public float Leading { get; public set; }
    public float MultipliedLeading { get; }
    public float YLine { get; public set; }
    public int RowsDrawn { get; }
    public int Alignment { get; public set; }
    public float Indent { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float CurrentLeading { get; }
    public bool InheritGraphicState { get; public set; }
    public bool IgnoreSpacingBefore { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public int LinesWritten { get; }
    public float LastX { get; }
    public int ArabicOptions { get; public set; }
    public float Descender { get; }
    public PdfContentByte Canvas { get; public set; }
    public PdfContentByte[] Canvases { get; public set; }
    public IList`1<IElement> CompositeElements { get; }
    public bool UseAscender { get; public set; }
    public float FilledWidth { get; public set; }
    public bool AdjustFirstLine { get; public set; }
    public ColumnText(PdfContentByte canvas);
    private static ColumnText();
    public static ColumnText Duplicate(ColumnText org);
    public virtual ColumnText SetACopy(ColumnText org);
    protected internal virtual void SetSimpleVars(ColumnText org);
    private void AddWaitingPhrase();
    public virtual void AddText(Phrase phrase);
    public virtual void SetText(Phrase phrase);
    public virtual void AddText(Chunk chunk);
    public virtual void AddElement(IElement element);
    public static bool isAllowedElement(IElement element);
    protected virtual List`1<Single[]> ConvertColumn(Single[] cLine);
    protected virtual float FindLimitsPoint(List`1<Single[]> wall);
    protected virtual Single[] FindLimitsOneLine();
    protected virtual Single[] FindLimitsTwoLines();
    public virtual void SetColumns(Single[] leftLine, Single[] rightLine);
    public virtual void SetSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public virtual void SetSimpleColumn(Rectangle rect);
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public virtual float get_MultipliedLeading();
    public virtual float get_YLine();
    public virtual void set_YLine(float value);
    public virtual int get_RowsDrawn();
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
    public virtual float get_Indent();
    public virtual void set_Indent(float value);
    public virtual void SetIndent(float indent, bool repeatFirstLineIndent);
    public virtual float get_FollowingIndent();
    public virtual void set_FollowingIndent(float value);
    public virtual float get_RightIndent();
    public virtual void set_RightIndent(float value);
    public virtual float get_CurrentLeading();
    public virtual bool get_InheritGraphicState();
    public virtual void set_InheritGraphicState(bool value);
    public virtual bool get_IgnoreSpacingBefore();
    public virtual void set_IgnoreSpacingBefore(bool value);
    public virtual int Go();
    public virtual int Go(bool simulate);
    public virtual int Go(bool simulate, IElement elementToGo);
    public virtual bool IsWordSplit();
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual void ClearChunks();
    public virtual float get_SpaceCharRatio();
    public virtual void set_SpaceCharRatio(float value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual int get_LinesWritten();
    public virtual float get_LastX();
    public virtual void set_ArabicOptions(int value);
    public virtual int get_ArabicOptions();
    public virtual float get_Descender();
    public static float GetWidth(Phrase phrase, int runDirection, int arabicOptions);
    public static float GetWidth(Phrase phrase);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation);
    public static float FitText(Font font, string text, Rectangle rect, float maxFontSize, int runDirection);
    protected virtual int GoComposite(bool simulate);
    public virtual void set_Canvas(PdfContentByte value);
    public virtual PdfContentByte get_Canvas();
    public virtual void set_Canvases(PdfContentByte[] value);
    public virtual PdfContentByte[] get_Canvases();
    public virtual bool ZeroHeightElement();
    public virtual IList`1<IElement> get_CompositeElements();
    public virtual void set_UseAscender(bool value);
    public virtual bool get_UseAscender();
    public static bool HasMoreText(int status);
    public virtual void set_FilledWidth(float value);
    public virtual float get_FilledWidth();
    public virtual void UpdateFilledWidth(float w);
    public virtual void set_AdjustFirstLine(bool value);
    public virtual bool get_AdjustFirstLine();
    private static bool IsTagged(PdfContentByte canvas);
}
public class iTextSharp.text.pdf.crypto.AESCipher : object {
    private PaddedBufferedBlockCipher bp;
    public AESCipher(bool forEncryption, Byte[] key, Byte[] iv);
    public virtual Byte[] Update(Byte[] inp, int inpOff, int inpLen);
    public virtual Byte[] DoFinal();
}
public class iTextSharp.text.pdf.crypto.AESCipherCBCnoPad : object {
    private IBlockCipher cbc;
    public AESCipherCBCnoPad(bool forEncryption, Byte[] key);
    public virtual Byte[] ProcessBlock(Byte[] inp, int inpOff, int inpLen);
}
public class iTextSharp.text.pdf.crypto.ARCFOUREncryption : object {
    private Byte[] state;
    private int x;
    private int y;
    public virtual void PrepareARCFOURKey(Byte[] key);
    public virtual void PrepareARCFOURKey(Byte[] key, int off, int len);
    public virtual void EncryptARCFOUR(Byte[] dataIn, int off, int len, Byte[] dataOut, int offOut);
    public virtual void EncryptARCFOUR(Byte[] data, int off, int len);
    public virtual void EncryptARCFOUR(Byte[] dataIn, Byte[] dataOut);
    public virtual void EncryptARCFOUR(Byte[] data);
}
public class iTextSharp.text.pdf.crypto.IVGenerator : object {
    private static ARCFOUREncryption rc4;
    private static IVGenerator();
    public static Byte[] GetIV();
    public static Byte[] GetIV(int len);
}
public class iTextSharp.text.pdf.crypto.StandardDecryption : object {
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] key;
    private static int AES_128;
    private static int AES_256;
    private bool aes;
    private bool initiated;
    private Byte[] iv;
    private int ivptr;
    public StandardDecryption(Byte[] key, int off, int len, int revision);
    public virtual Byte[] Update(Byte[] b, int off, int len);
    public virtual Byte[] Finish();
}
public class iTextSharp.text.pdf.DefaultSplitCharacter : object {
    public static ISplitCharacter DEFAULT;
    protected Char[] characters;
    private static string DATE_PATTERN;
    public DefaultSplitCharacter(char character);
    public DefaultSplitCharacter(Char[] characters);
    private static DefaultSplitCharacter();
    public virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    protected virtual char GetCurrentCharacter(int current, Char[] cc, PdfChunk[] ck);
    private static bool containsDate(string data);
}
public class iTextSharp.text.pdf.DeviceNColor : ExtendedColor {
    private PdfDeviceNColor pdfDeviceNColor;
    private Single[] tints;
    public PdfDeviceNColor PdfDeviceNColor { get; }
    public Single[] Tints { get; }
    public DeviceNColor(PdfDeviceNColor pdfDeviceNColor, Single[] tints);
    public virtual PdfDeviceNColor get_PdfDeviceNColor();
    public virtual Single[] get_Tints();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.DocumentFont : BaseFont {
    private Dictionary`2<int, Int32[]> metrics;
    private string fontName;
    private PRIndirectReference refFont;
    private PdfDictionary font;
    private Double[] fontMatrix;
    private IntHashtable uni2byte;
    private IntHashtable byte2uni;
    private IntHashtable diffmap;
    private float Ascender;
    private float CapHeight;
    private float Descender;
    private float ItalicAngle;
    private float fontWeight;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    protected bool isType0;
    protected int defaultWidth;
    private IntHashtable hMetrics;
    protected internal string cjkEncoding;
    protected internal string uniMap;
    private BaseFont cjkMirror;
    private static Int32[] stdEnc;
    public PdfDictionary FontDictionary { get; }
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    internal PdfIndirectReference IndirectReference { get; }
    internal IntHashtable Uni2Byte { get; }
    internal IntHashtable Byte2Uni { get; }
    internal IntHashtable Diffmap { get; }
    internal DocumentFont(PdfDictionary font);
    internal DocumentFont(PRIndirectReference refFont);
    internal DocumentFont(PRIndirectReference refFont, PdfDictionary drEncoding);
    private static DocumentFont();
    private void Init();
    public virtual PdfDictionary get_FontDictionary();
    private void ProcessType0(PdfDictionary font);
    private IntHashtable ReadWidths(PdfArray ws);
    private string DecodeString(PdfString ps);
    private void FillMetricsIdentity(IntHashtable widths, int dw);
    private void FillMetrics(Byte[] touni, IntHashtable widths, int dw);
    private void DoType1TT();
    private void FillWidths();
    private void FillDiffMap(PdfDictionary encDic, CMapToUnicode toUnicode);
    private CMapToUnicode ProcessToUnicode();
    private void FillFontDesc(PdfDictionary fontDesc);
    private void FillEncoding(PdfName encoding);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference refi, Object[] param);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal PdfIndirectReference get_IndirectReference();
    public virtual bool CharExists(int c);
    public virtual Double[] GetFontMatrix();
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    public virtual bool IsVertical();
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal IntHashtable get_Uni2Byte();
    internal IntHashtable get_Byte2Uni();
    internal IntHashtable get_Diffmap();
    private bool IsSymbolic();
}
public class iTextSharp.text.pdf.draw.DottedLineSeparator : LineSeparator {
    protected float gap;
    public float Gap { get; public set; }
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual float get_Gap();
    public virtual void set_Gap(float value);
}
public interface iTextSharp.text.pdf.draw.IDrawInterface {
    public abstract virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
}
public class iTextSharp.text.pdf.draw.LineSeparator : VerticalPositionMark {
    protected float lineWidth;
    protected float percentage;
    protected BaseColor lineColor;
    protected int alignment;
    public float LineWidth { get; public set; }
    public float Percentage { get; public set; }
    public BaseColor LineColor { get; public set; }
    public int Alignment { get; public set; }
    public LineSeparator(float lineWidth, float percentage, BaseColor lineColor, int align, float offset);
    public LineSeparator(Font font);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual void DrawLine(PdfContentByte canvas, float leftX, float rightX, float y);
    public virtual float get_LineWidth();
    public virtual void set_LineWidth(float value);
    public virtual float get_Percentage();
    public virtual void set_Percentage(float value);
    public virtual BaseColor get_LineColor();
    public virtual void set_LineColor(BaseColor value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
}
public class iTextSharp.text.pdf.draw.VerticalPositionMark : object {
    protected IDrawInterface drawInterface;
    protected float offset;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public IDrawInterface DrawInterface { get; public set; }
    public float Offset { get; public set; }
    public VerticalPositionMark(IDrawInterface drawInterface, float offset);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual void set_DrawInterface(IDrawInterface value);
    public virtual IDrawInterface get_DrawInterface();
    public virtual void set_Offset(float value);
    public virtual float get_Offset();
}
internal class iTextSharp.text.pdf.EnumerateTTC : TrueTypeFont {
    protected String[] names;
    internal String[] Names { get; }
    internal EnumerateTTC(string ttcFile);
    internal EnumerateTTC(Byte[] ttcArray);
    internal void FindNames();
    internal String[] get_Names();
}
public class iTextSharp.text.pdf.events.FieldPositioningEvents : PdfPageEventHelper {
    protected Dictionary`2<string, PdfFormField> genericChunkFields;
    protected PdfFormField cellField;
    protected PdfWriter fieldWriter;
    protected PdfFormField parent;
    public float padding;
    public float Padding { get; public set; }
    public PdfFormField Parent { get; public set; }
    public FieldPositioningEvents(PdfWriter writer, PdfFormField field);
    public FieldPositioningEvents(PdfFormField parent, PdfFormField field);
    public FieldPositioningEvents(PdfWriter writer, string text);
    public FieldPositioningEvents(PdfWriter writer, PdfFormField parent, string text);
    public virtual void AddField(string text, PdfFormField field);
    public virtual void set_Padding(float value);
    public virtual float get_Padding();
    public virtual void set_Parent(PdfFormField value);
    public virtual PdfFormField get_Parent();
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual void CellLayout(PdfPCell cell, Rectangle rect, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.IndexEvents : PdfPageEventHelper {
    private Dictionary`2<string, int> indextag;
    private long indexcounter;
    private List`1<Entry> indexentry;
    private IComparer`1<Entry> comparator;
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public virtual Chunk Create(string text, string in1, string in2, string in3);
    public virtual Chunk Create(string text, string in1);
    public virtual Chunk Create(string text, string in1, string in2);
    public virtual void Create(Chunk text, string in1, string in2, string in3);
    public virtual void Create(Chunk text, string in1);
    public virtual void Create(Chunk text, string in1, string in2);
    public virtual void SetComparator(IComparer`1<Entry> aComparator);
    public virtual List`1<Entry> GetSortedEntries();
}
public class iTextSharp.text.pdf.events.PdfPageEventForwarder : object {
    protected List`1<IPdfPageEvent> events;
    public virtual void AddPageEvent(IPdfPageEvent eventa);
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.events.PdfPCellEventForwarder : object {
    protected List`1<IPdfPCellEvent> events;
    public virtual void AddCellEvent(IPdfPCellEvent eventa);
    public virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.PdfPTableEventForwarder : object {
    protected List`1<IPdfPTableEvent> events;
    public virtual void AddTableEvent(IPdfPTableEvent eventa);
    public virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
    public virtual void SplitTable(PdfPTable table);
    public virtual void AfterSplitTable(PdfPTable table, PdfPRow startRow, int startIdx);
}
public abstract class iTextSharp.text.pdf.ExtendedColor : BaseColor {
    public static int TYPE_RGB;
    public static int TYPE_GRAY;
    public static int TYPE_CMYK;
    public static int TYPE_SEPARATION;
    public static int TYPE_PATTERN;
    public static int TYPE_SHADING;
    public static int TYPE_DEVICEN;
    public static int TYPE_LAB;
    protected int type;
    public int Type { get; }
    public ExtendedColor(int type);
    public ExtendedColor(int type, float red, float green, float blue);
    public ExtendedColor(int type, int red, int green, int blue, int alpha);
    public virtual int get_Type();
    public static int GetType(object color);
    internal static float Normalize(float value);
}
public class iTextSharp.text.pdf.FdfReader : PdfReader {
    internal Dictionary`2<string, PdfDictionary> fields;
    internal string fileSpec;
    internal PdfName encoding;
    protected static ICounter COUNTER;
    public Dictionary`2<string, PdfDictionary> Fields { get; }
    public string FileSpec { get; }
    public FdfReader(string filename);
    public FdfReader(Byte[] pdfIn);
    public FdfReader(Uri url);
    public FdfReader(Stream isp);
    private static FdfReader();
    protected virtual ICounter GetCounter();
    protected internal virtual void ReadPdf();
    protected virtual void KidNode(PdfDictionary merged, string name);
    protected virtual void ReadFields();
    public virtual Dictionary`2<string, PdfDictionary> get_Fields();
    public virtual PdfDictionary GetField(string name);
    public virtual Byte[] GetAttachedFile(string name);
    public virtual string GetFieldValue(string name);
    public virtual string get_FileSpec();
}
public class iTextSharp.text.pdf.FdfWriter : object {
    private static Byte[] HEADER_FDF;
    private Dictionary`2<string, object> fields;
    private Wrt wrt;
    private string file;
    private string statusMessage;
    protected ICounter COUNTER;
    public string StatusMessage { get; public set; }
    public string File { get; public set; }
    public FdfWriter(Stream os);
    private static FdfWriter();
    public virtual void WriteTo(Stream os);
    public virtual void Write();
    public virtual string get_StatusMessage();
    public virtual void set_StatusMessage(string value);
    internal bool SetField(string field, PdfObject value);
    internal void IterateFields(Dictionary`2<string, object> values, Dictionary`2<string, object> map, string name);
    public virtual bool RemoveField(string field);
    public virtual Dictionary`2<string, object> GetFields();
    public virtual string GetField(string field);
    public virtual bool SetFieldAsName(string field, string value);
    public virtual bool SetFieldAsString(string field, string value);
    public virtual bool SetFieldAsAction(string field, PdfAction action);
    public virtual bool SetFieldAsTemplate(string field, PdfTemplate template);
    public virtual bool SetFieldAsImage(string field, Image image);
    public virtual bool SetFieldAsJavascript(string field, PdfName jsTrigName, string js);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfTemplate CreateTemplate(float width, float height);
    public virtual void SetFields(FdfReader fdf);
    public virtual void SetFields(PdfReader pdf);
    public virtual void SetFields(AcroFields af);
    public virtual string get_File();
    public virtual void set_File(string value);
    protected virtual ICounter GetCounter();
}
public class iTextSharp.text.pdf.FilterHandlers : object {
    private static IDictionary`2<PdfName, IFilterHandler> defaults;
    private static FilterHandlers();
    public static IDictionary`2<PdfName, IFilterHandler> GetDefaultFilterHandlers();
    public static MemoryStream EnableMemoryLimitsAwareHandler(PdfDictionary streamDictionary);
}
public class iTextSharp.text.pdf.FloatLayout : object {
    protected float maxY;
    protected float minY;
    protected float leftX;
    protected float rightX;
    protected float yLine;
    protected float floatLeftX;
    protected float floatRightX;
    protected float filledWidth;
    public ColumnText compositeColumn;
    public List`1<IElement> content;
    protected bool useAscender;
    public float YLine { get; public set; }
    public float FilledWidth { get; public set; }
    public int RunDirection { get; public set; }
    public FloatLayout(List`1<IElement> elements, bool useAscender);
    public virtual float get_YLine();
    public virtual void set_YLine(float value);
    public virtual float get_FilledWidth();
    public virtual void set_FilledWidth(float value);
    public virtual void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public virtual int Layout(PdfContentByte canvas, bool simulate);
    private int FloatingLayout(List`1<IElement> floatingElements, bool simulate);
}
public class iTextSharp.text.pdf.FontDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName fontName;
    private BaseFont baseFont;
    private TrueTypeFontUnicode ttu;
    private CJKFont cjkFont;
    private Byte[] shortTag;
    private Dictionary`2<int, Int32[]> longTag;
    private IntHashtable cjkTag;
    private int fontType;
    private bool symbolic;
    protected bool subset;
    internal PdfIndirectReference IndirectReference { get; }
    internal PdfName FontName { get; }
    internal BaseFont BaseFont { get; }
    public bool Subset { get; public set; }
    internal FontDetails(PdfName fontName, PdfIndirectReference indirectReference, BaseFont baseFont);
    internal PdfIndirectReference get_IndirectReference();
    internal PdfName get_FontName();
    internal BaseFont get_BaseFont();
    internal virtual Object[] ConvertToBytesGid(string gids);
    internal Byte[] ConvertToBytes(string text);
    public virtual void WriteFont(PdfWriter writer);
    public virtual void set_Subset(bool value);
    public virtual bool get_Subset();
}
public abstract class iTextSharp.text.pdf.fonts.cmaps.AbstractCMap : object {
    private string cmapName;
    private string registry;
    private string ordering;
    private int supplement;
    public int Supplement { get; public set; }
    public string Name { get; public set; }
    public string Ordering { get; public set; }
    public string Registry { get; public set; }
    public virtual int get_Supplement();
    public virtual void set_Supplement(int value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Ordering();
    public virtual void set_Ordering(string value);
    public virtual string get_Registry();
    public virtual void set_Registry(string value);
    internal abstract virtual void AddChar(PdfString mark, PdfObject code);
    internal void AddRange(PdfString from, PdfString to, PdfObject code);
    private static void IntToByteArray(int v, Byte[] b);
    private static int ByteArrayToInt(Byte[] b);
    public static Byte[] DecodeStringToByte(PdfString s);
    public virtual string DecodeStringToUnicode(PdfString ps);
}
public class iTextSharp.text.pdf.fonts.cmaps.CidLocationFromByte : object {
    private Byte[] data;
    public CidLocationFromByte(Byte[] data);
    public virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.CidResource : object {
    public virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapByteCid : AbstractCMap {
    private List`1<Char[]> planes;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    private void EncodeSequence(Byte[] seqs, char cid);
    public virtual int DecodeSingle(CMapSequence seq);
    public virtual string DecodeSequence(CMapSequence seq);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCache : object {
    private static Dictionary`2<string, CMapUniCid> cacheUniCid;
    private static Dictionary`2<string, CMapCidUni> cacheCidUni;
    private static Dictionary`2<string, CMapCidByte> cacheCidByte;
    private static Dictionary`2<string, CMapByteCid> cacheByteCid;
    private static CMapCache();
    public static CMapUniCid GetCachedCMapUniCid(string name);
    public static CMapCidUni GetCachedCMapCidUni(string name);
    public static CMapCidByte GetCachedCMapCidByte(string name);
    public static CMapByteCid GetCachedCMapByteCid(string name);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCidByte : AbstractCMap {
    private Dictionary`2<int, Byte[]> map;
    private static Byte[] EMPTY;
    private static CMapCidByte();
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual Byte[] Lookup(int cid);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapCidUni : AbstractCMap {
    private IntHashtable map;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual int Lookup(int character);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapParserEx : object {
    private static PdfName CMAPNAME;
    private static string DEF;
    private static string ENDCIDRANGE;
    private static string ENDCIDCHAR;
    private static string ENDBFRANGE;
    private static string ENDBFCHAR;
    private static string USECMAP;
    private static int MAXLEVEL;
    private static CMapParserEx();
    public static void ParseCid(string cmapName, AbstractCMap cmap, ICidLocation location);
    private static void ParseCid(string cmapName, AbstractCMap cmap, ICidLocation location, int level);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapSequence : object {
    public Byte[] seq;
    public int off;
    public int len;
    public CMapSequence(Byte[] seq, int off, int len);
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode : AbstractCMap {
    private IDictionary`2<int, string> singleByteMappings;
    private IDictionary`2<int, string> doubleByteMappings;
    private Encoding enc;
    public virtual bool HasOneByteMappings();
    public virtual bool HasTwoByteMappings();
    public virtual string Lookup(Byte[] code, int offset, int length);
    public virtual IDictionary`2<int, int> CreateReverseMapping();
    public virtual IDictionary`2<int, int> CreateDirectMapping();
    private int ConvertToInt(string s);
    internal void AddChar(int cid, string uni);
    internal virtual void AddChar(PdfString mark, PdfObject code);
    private string CreateStringFromBytes(Byte[] bytes);
    public static CMapToUnicode GetIdentity();
}
public class iTextSharp.text.pdf.fonts.cmaps.CMapUniCid : AbstractCMap {
    private IntHashtable map;
    internal virtual void AddChar(PdfString mark, PdfObject code);
    public virtual int Lookup(int character);
    public virtual CMapToUnicode ExportToUnicode();
}
public interface iTextSharp.text.pdf.fonts.cmaps.ICidLocation {
    public abstract virtual PRTokeniser GetLocation(string location);
}
public class iTextSharp.text.pdf.fonts.cmaps.IdentityToUnicode : object {
    private static CMapToUnicode identityCNS;
    private static CMapToUnicode identityJapan;
    private static CMapToUnicode identityKorea;
    private static CMapToUnicode identityGB;
    private static CMapToUnicode identityH;
    public static CMapToUnicode GetMapFromOrdering(string ordering);
}
public class iTextSharp.text.pdf.FontSelector : object {
    private static ILogger LOGGER;
    protected List`1<Font> fonts;
    protected List`1<Font> unsupportedFonts;
    protected Font currentFont;
    private static FontSelector();
    public virtual void AddFont(Font font);
    public virtual Phrase Process(string text);
    protected virtual Chunk ProcessChar(Char[] cc, int k, StringBuilder sb);
    protected int GetSize();
    protected Font GetFont(int i);
    private bool IsSupported(Font font);
}
public class iTextSharp.text.pdf.GlyphList : object {
    private static Dictionary`2<int, string> unicode2names;
    private static Dictionary`2<string, Int32[]> names2unicode;
    private static GlyphList();
    public static Int32[] NameToUnicode(string name);
    public static string UnicodeToName(int num);
}
public class iTextSharp.text.pdf.GrayColor : ExtendedColor {
    private float cgray;
    public static GrayColor GRAYBLACK;
    public static GrayColor GRAYWHITE;
    public float Gray { get; }
    public GrayColor(int intGray);
    public GrayColor(float floatGray);
    private static GrayColor();
    public virtual float get_Gray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.ByteVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Byte[] arr;
    private int n;
    public Byte[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public byte Item { get; public set; }
    public ByteVector(int capacity);
    public ByteVector(Byte[] a);
    public ByteVector(Byte[] a, int capacity);
    private static ByteVector();
    public virtual Byte[] get_Arr();
    public virtual int get_Length();
    public virtual int get_Capacity();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.CharVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Char[] array;
    private int n;
    public Char[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public CharVector(int capacity);
    public CharVector(Char[] a);
    public CharVector(Char[] a, int capacity);
    private static CharVector();
    public virtual void Clear();
    public virtual object Clone();
    public virtual Char[] get_Arr();
    public virtual int get_Length();
    public virtual int get_Capacity();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
public class iTextSharp.text.pdf.hyphenation.Hyphen : object {
    public string preBreak;
    public string noBreak;
    public string postBreak;
    internal Hyphen(string pre, string no, string post);
    internal Hyphen(string pre);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenation : object {
    private Int32[] hyphenPoints;
    private string word;
    private int len;
    public int Length { get; }
    public Int32[] HyphenationPoints { get; }
    public Hyphenation(string word, Int32[] points);
    public virtual int get_Length();
    public virtual string GetPreHyphenText(int index);
    public virtual string GetPostHyphenText(int index);
    public virtual Int32[] get_HyphenationPoints();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.HyphenationException : Exception {
    public HyphenationException(string msg);
    protected HyphenationException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.hyphenation.HyphenationTree : TernaryTree {
    protected ByteVector vspace;
    protected Dictionary`2<string, List`1<object>> stoplist;
    protected TernaryTree classmap;
    private TernaryTree ivalues;
    protected virtual int PackValues(string values);
    protected virtual string UnpackValues(int k);
    public virtual void LoadSimplePatterns(Stream stream);
    public virtual string FindPattern(string pat);
    protected virtual int Hstrcmp(Char[] s, int si, Char[] t, int ti);
    protected virtual Byte[] GetValues(int k);
    protected virtual void SearchPatterns(Char[] word, int index, Byte[] il);
    public virtual Hyphenation Hyphenate(string word, int remainCharCount, int pushCharCount);
    public virtual Hyphenation Hyphenate(Char[] w, int offset, int len, int remainCharCount, int pushCharCount);
    public virtual void AddClass(string chargroup);
    public virtual void AddException(string word, List`1<object> hyphenatedword);
    public virtual void AddPattern(string pattern, string ivalue);
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenator : object {
    private static Hashtable hyphenTrees;
    private HyphenationTree hyphenTree;
    private int remainCharCount;
    private int pushCharCount;
    private static string defaultHyphLocation;
    public Hyphenator(string lang, string country, int leftMin, int rightMin);
    private static Hyphenator();
    public static HyphenationTree GetHyphenationTree(string lang, string country);
    public static HyphenationTree GetResourceHyphenationTree(string key);
    public static Hyphenation Hyphenate(string lang, string country, string word, int leftMin, int rightMin);
    public static Hyphenation Hyphenate(string lang, string country, Char[] word, int offset, int len, int leftMin, int rightMin);
    public virtual void SetMinRemainCharCount(int min);
    public virtual void SetMinPushCharCount(int min);
    public virtual void SetLanguage(string lang, string country);
    public virtual Hyphenation Hyphenate(Char[] word, int offset, int len);
    public virtual Hyphenation Hyphenate(string word);
}
public interface iTextSharp.text.pdf.hyphenation.IPatternConsumer {
    public abstract virtual void AddClass(string chargroup);
    public abstract virtual void AddException(string word, List`1<object> hyphenatedword);
    public abstract virtual void AddPattern(string pattern, string values);
}
public class iTextSharp.text.pdf.hyphenation.SimplePatternParser : object {
    internal int currElement;
    internal IPatternConsumer consumer;
    internal StringBuilder token;
    internal List`1<object> exception;
    internal char hyphenChar;
    internal static int ELEM_CLASSES;
    internal static int ELEM_EXCEPTIONS;
    internal static int ELEM_PATTERNS;
    internal static int ELEM_HYPHEN;
    public virtual void Parse(Stream stream, IPatternConsumer consumer);
    protected static string GetPattern(string word);
    protected virtual List`1<object> NormalizeException(List`1<object> ex);
    protected virtual string GetExceptionWord(List`1<object> ex);
    protected static string GetInterletterValues(string pat);
    public virtual void EndDocument();
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void Text(string str);
}
public class iTextSharp.text.pdf.hyphenation.TernaryTree : object {
    protected Char[] lo;
    protected Char[] hi;
    protected Char[] eq;
    protected Char[] sc;
    protected CharVector kv;
    protected char root;
    protected char freenode;
    protected int length;
    protected static int BLOCK_SIZE;
    public int Size { get; }
    public Iterator Keys { get; }
    private static TernaryTree();
    protected virtual void Init();
    public virtual void Insert(string key, char val);
    public virtual void Insert(Char[] key, int start, char val);
    private char Insert(char p, Char[] key, int start, char val);
    public static int Strcmp(Char[] a, int startA, Char[] b, int startB);
    public static int Strcmp(string str, Char[] a, int start);
    public static void Strcpy(Char[] dst, int di, Char[] src, int si);
    public static int Strlen(Char[] a, int start);
    public static int Strlen(Char[] a);
    public virtual int Find(string key);
    public virtual int Find(Char[] key, int start);
    public virtual bool Knows(string key);
    private void RedimNodeArrays(int newsize);
    public virtual int get_Size();
    public virtual object Clone();
    protected virtual void InsertBalanced(String[] k, Char[] v, int offset, int n);
    public virtual void Balance();
    public virtual void TrimToSize();
    private void Compact(CharVector kx, TernaryTree map, char p);
    public virtual Iterator get_Keys();
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.HyphenationAuto : object {
    protected Hyphenator hyphenator;
    protected string post;
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public HyphenationAuto(string lang, string country, int leftMin, int rightMin);
    public virtual string get_HyphenSymbol();
    public virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public virtual string get_HyphenatedWordPost();
}
public interface iTextSharp.text.pdf.ICachedColorSpace {
    public abstract virtual PdfObject GetPdfObject(PdfWriter writer);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
public class iTextSharp.text.pdf.ICC_Profile : object {
    protected Byte[] data;
    protected int numComponents;
    private static Dictionary`2<string, int> cstags;
    public Byte[] Data { get; }
    public int NumComponents { get; }
    private static ICC_Profile();
    public static ICC_Profile GetInstance(Byte[] data, int numComponents);
    public static ICC_Profile GetInstance(Byte[] data);
    public static ICC_Profile GetInstance(Stream file);
    public static ICC_Profile GetInstance(string fname);
    public virtual Byte[] get_Data();
    public virtual int get_NumComponents();
}
public interface iTextSharp.text.pdf.IExtraEncoding {
    public abstract virtual Byte[] CharToByte(string text, string encoding);
    public abstract virtual Byte[] CharToByte(char char1, string encoding);
    public abstract virtual string ByteToChar(Byte[] b, string encoding);
}
public interface iTextSharp.text.pdf.IHyphenationEvent {
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public abstract virtual string get_HyphenSymbol();
    public abstract virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public abstract virtual string get_HyphenatedWordPost();
}
public interface iTextSharp.text.pdf.interfaces.IAccessibleElement {
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public abstract virtual PdfObject GetAccessibleAttribute(PdfName key);
    public abstract virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public abstract virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public abstract virtual PdfName get_Role();
    public abstract virtual void set_Role(PdfName value);
    public abstract virtual AccessibleElementId get_ID();
    public abstract virtual void set_ID(AccessibleElementId value);
    public abstract virtual bool get_IsInline();
}
public interface iTextSharp.text.pdf.interfaces.IAlternateDescription {
    public string Alt { get; public set; }
    public abstract virtual string get_Alt();
    public abstract virtual void set_Alt(string value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfAnnotations {
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public abstract virtual PdfAcroForm get_AcroForm();
    public abstract virtual void AddAnnotation(PdfAnnotation annot);
    public abstract virtual void AddCalculationOrder(PdfFormField annot);
    public abstract virtual void set_SigFlags(int value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfDocumentActions {
    public abstract virtual void SetOpenAction(string name);
    public abstract virtual void SetOpenAction(PdfAction action);
    public abstract virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
}
public interface iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings {
    public abstract virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public abstract virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
public interface iTextSharp.text.pdf.interfaces.IPdfIsoConformance {
    public abstract virtual bool IsPdfIso();
    public abstract virtual void CheckPdfIsoConformance(int key, object obj1);
}
public interface iTextSharp.text.pdf.interfaces.IPdfPageActions {
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    public abstract virtual void SetPageAction(PdfName actionType, PdfAction action);
    public abstract virtual void set_Duration(int value);
    public abstract virtual void set_Transition(PdfTransition value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfRunDirection {
    public int RunDirection { get; public set; }
    public abstract virtual void set_RunDirection(int value);
    public abstract virtual int get_RunDirection();
}
public interface iTextSharp.text.pdf.interfaces.IPdfStructureElement {
    public abstract virtual PdfObject GetAttribute(PdfName name);
    public abstract virtual void SetAttribute(PdfName name, PdfObject obj);
}
public interface iTextSharp.text.pdf.interfaces.IPdfVersion {
    unknown char PdfVersion {public set; }
    public abstract virtual void set_PdfVersion(char value);
    public abstract virtual void SetAtLeastPdfVersion(char version);
    public abstract virtual void SetPdfVersion(PdfName version);
    public abstract virtual void AddDeveloperExtension(PdfDeveloperExtension de);
}
public interface iTextSharp.text.pdf.interfaces.IPdfViewerPreferences {
    unknown int ViewerPreferences {public set; }
    public abstract virtual void set_ViewerPreferences(int value);
    public abstract virtual void AddViewerPreference(PdfName key, PdfObject value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfXConformance {
    public int PDFXConformance { get; public set; }
    public abstract virtual void set_PDFXConformance(int value);
    public abstract virtual int get_PDFXConformance();
    public abstract virtual bool IsPdfX();
}
public class iTextSharp.text.pdf.intern.PdfAnnotationsImp : object {
    protected internal PdfAcroForm acroForm;
    protected internal List`1<PdfAnnotation> annotations;
    protected internal List`1<PdfAnnotation> delayedAnnotations;
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public PdfAnnotationsImp(PdfWriter writer);
    public virtual bool HasValidAcroForm();
    public virtual PdfAcroForm get_AcroForm();
    public virtual void set_SigFlags(int value);
    public virtual void AddCalculationOrder(PdfFormField formField);
    public virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void AddPlainAnnotation(PdfAnnotation annot);
    private void AddFormFieldRaw(PdfFormField field);
    public virtual bool HasUnusedAnnotations();
    public virtual void ResetAnnotations();
    public virtual PdfArray RotateAnnotations(PdfWriter writer, Rectangle pageSize);
    public static PdfAnnotation ConvertAnnotation(PdfWriter writer, Annotation annot, Rectangle defaultRect);
}
public class iTextSharp.text.pdf.intern.PdfIsoKeys : object {
    public static int PDFISOKEY_COLOR;
    public static int PDFISOKEY_CMYK;
    public static int PDFISOKEY_RGB;
    public static int PDFISOKEY_FONT;
    public static int PDFISOKEY_IMAGE;
    public static int PDFISOKEY_GSTATE;
    public static int PDFISOKEY_LAYER;
    public static int PDFISOKEY_TRAILER;
    public static int PDFISOKEY_STREAM;
    public static int PDFISOKEY_FILESPEC;
    public static int PDFISOKEY_OBJECT;
    public static int PDFISOKEY_CANVAS;
    public static int PDFISOKEY_ANNOTATION;
    public static int PDFISOKEY_ACTION;
    public static int PDFISOKEY_FORM;
    public static int PDFISOKEY_STRUCTELEM;
    public static int PDFISOKEY_INLINE_IMAGE;
    public static int PDFISOKEY_GRAY;
    public static int PDFISOKEY_OUTPUTINTENT;
    public static int PDFISOKEY_FORM_XOBJ;
}
public class iTextSharp.text.pdf.intern.PdfVersionImp : object {
    public static Byte[][] HEADER;
    protected bool headerWasWritten;
    protected bool appendmode;
    protected char header_version;
    protected PdfName catalog_version;
    protected char version;
    protected PdfDictionary extensions;
    unknown char PdfVersion {public set; }
    public char Version { get; }
    private static PdfVersionImp();
    public virtual void set_PdfVersion(char value);
    public virtual void SetAtLeastPdfVersion(char version);
    public virtual void SetPdfVersion(PdfName version);
    public virtual void SetAppendmode(bool appendmode);
    public virtual void WriteHeader(OutputStreamCounter os);
    public virtual PdfName GetVersionAsName(char version);
    public virtual Byte[] GetVersionAsByteArray(char version);
    public virtual void AddToCatalog(PdfDictionary catalog);
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public virtual char get_Version();
}
public class iTextSharp.text.pdf.intern.PdfViewerPreferencesImp : object {
    public static PdfName[] VIEWER_PREFERENCES;
    public static PdfName[] NONFULLSCREENPAGEMODE_PREFERENCES;
    public static PdfName[] DIRECTION_PREFERENCES;
    public static PdfName[] PAGE_BOUNDARIES;
    public static PdfName[] PRINTSCALING_PREFERENCES;
    public static PdfName[] DUPLEX_PREFERENCES;
    private int pageLayoutAndMode;
    private PdfDictionary viewerPreferences;
    private static int viewerPreferencesMask;
    public int PageLayoutAndMode { get; }
    unknown int ViewerPreferences {public set; }
    private static PdfViewerPreferencesImp();
    public virtual int get_PageLayoutAndMode();
    public virtual PdfDictionary GetViewerPreferences();
    public virtual void set_ViewerPreferences(int value);
    private int GetIndex(PdfName key);
    private bool IsPossibleValue(PdfName value, PdfName[] accepted);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void AddToCatalog(PdfDictionary catalog);
    public static PdfViewerPreferencesImp GetViewerPreferences(PdfDictionary catalog);
}
public class iTextSharp.text.pdf.intern.PdfXConformanceImp : object {
    protected internal int pdfxConformance;
    protected PdfWriter writer;
    public int PDFXConformance { get; public set; }
    public PdfXConformanceImp(PdfWriter writer);
    public virtual void set_PDFXConformance(int value);
    public virtual int get_PDFXConformance();
    public virtual bool IsPdfIso();
    public virtual bool IsPdfX();
    public virtual bool IsPdfX1A2001();
    public virtual bool IsPdfX32002();
    public virtual void CheckPdfIsoConformance(int key, object obj1);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.IntHashtable : object {
    private IntHashtableEntry[] table;
    private int count;
    private int threshold;
    private float loadFactor;
    public int Size { get; }
    public int Item { get; public set; }
    public IntHashtable(int initialCapacity, float loadFactor);
    public IntHashtable(int initialCapacity);
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Contains(int value);
    public virtual bool ContainsKey(int key);
    public int get_Item(int key);
    public void set_Item(int key, int value);
    protected virtual void Rehash();
    public virtual int Remove(int key);
    public virtual void Clear();
    public virtual IntHashtable Clone();
    public virtual Int32[] ToOrderedKeys();
    public virtual Int32[] GetKeys();
    public virtual IntHashtableIterator GetEntryIterator();
}
public interface iTextSharp.text.pdf.IPdfOCG {
    public PdfIndirectReference Ref { get; }
    public PdfObject PdfObject { get; }
    public abstract virtual PdfIndirectReference get_Ref();
    public abstract virtual PdfObject get_PdfObject();
}
public interface iTextSharp.text.pdf.IPdfPageEvent {
    public abstract virtual void OnOpenDocument(PdfWriter writer, Document document);
    public abstract virtual void OnStartPage(PdfWriter writer, Document document);
    public abstract virtual void OnEndPage(PdfWriter writer, Document document);
    public abstract virtual void OnCloseDocument(PdfWriter writer, Document document);
    public abstract virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public abstract virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public abstract virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public interface iTextSharp.text.pdf.IPdfPCellEvent {
    public abstract virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEvent {
    public abstract virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEventAfterSplit {
    public abstract virtual void AfterSplitTable(PdfPTable table, PdfPRow startRow, int startIdx);
}
public interface iTextSharp.text.pdf.IPdfPTableEventSplit {
    public abstract virtual void SplitTable(PdfPTable table);
}
public interface iTextSharp.text.pdf.IPdfSpecialColorSpace {
    public abstract virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
}
public class iTextSharp.text.pdf.LabColor : ExtendedColor {
    private PdfLabColor labColorSpace;
    private float l;
    private float a;
    private float b;
    public PdfLabColor LabColorSpace { get; }
    public float L { get; }
    public float A { get; }
    public float B { get; }
    public LabColor(PdfLabColor labColorSpace, float l, float a, float b);
    public virtual PdfLabColor get_LabColorSpace();
    public virtual float get_L();
    public virtual float get_A();
    public virtual float get_B();
    public virtual BaseColor ToRgb();
    internal virtual CMYKColor ToCmyk();
}
public class iTextSharp.text.pdf.languages.GujaratiLigaturizer : IndicLigaturizer {
    public static char GUJR_MATRA_AA;
    public static char GUJR_MATRA_I;
    public static char GUJR_MATRA_E;
    public static char GUJR_MATRA_AI;
    public static char GUJR_MATRA_HLR;
    public static char GUJR_MATRA_HLRR;
    public static char GUJR_LETTER_A;
    public static char GUJR_LETTER_AU;
    public static char GUJR_LETTER_KA;
    public static char GUJR_LETTER_HA;
    public static char GUJR_HALANTA;
    private static GujaratiLigaturizer();
}
public class iTextSharp.text.pdf.languages.HebrewProcessor : object {
    protected int runDirection;
    public HebrewProcessor(int runDirection);
    public virtual string Process(string s);
    public virtual bool IsRTL();
}
public interface iTextSharp.text.pdf.languages.ILanguageProcessor {
    public abstract virtual string Process(string s);
    public abstract virtual bool IsRTL();
}
public abstract class iTextSharp.text.pdf.languages.IndicLigaturizer : object {
    public static int MATRA_AA;
    public static int MATRA_I;
    public static int MATRA_E;
    public static int MATRA_AI;
    public static int MATRA_HLR;
    public static int MATRA_HLRR;
    public static int LETTER_A;
    public static int LETTER_AU;
    public static int LETTER_KA;
    public static int LETTER_HA;
    public static int HALANTA;
    protected Char[] langTable;
    private static IndicLigaturizer();
    public virtual string Process(string s);
    public virtual bool IsRTL();
    protected virtual bool IsSwaraLetter(char ch);
    protected virtual bool IsSwaraMatra(char ch);
    protected virtual bool IsVyanjana(char ch);
    private static void Swap(StringBuilder s, int i, int j);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.LongHashtable : object {
    private LongHashtableEntry[] table;
    private int count;
    private int threshold;
    private float loadFactor;
    public int Size { get; }
    public long Item { get; public set; }
    public LongHashtable(int initialCapacity, float loadFactor);
    public LongHashtable(int initialCapacity);
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Contains(long value);
    public virtual bool ContainsKey(long key);
    public long get_Item(long key);
    public void set_Item(long key, long value);
    protected virtual void Rehash();
    public virtual long Remove(long key);
    public virtual void Clear();
    public virtual LongHashtable Clone();
    public virtual Int64[] ToOrderedKeys();
    public virtual Int64[] GetKeys();
    public virtual LongHashtableIterator GetEntryIterator();
}
public class iTextSharp.text.pdf.LZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Stream uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int nextData;
    private int nextBits;
    internal Int32[] andTable;
    public int NextCode { get; }
    public virtual void Decode(Byte[] data, Stream uncompData);
    public virtual void InitializeStringTable();
    public virtual void WriteString(Byte[] str);
    public virtual void AddStringToTable(Byte[] oldstring, byte newstring);
    public virtual void AddStringToTable(Byte[] str);
    public virtual Byte[] ComposeString(Byte[] oldstring, byte newstring);
    public virtual int get_NextCode();
}
public class iTextSharp.text.pdf.MemoryLimitsAwareException : Exception {
    public static string DuringDecompressionMultipleStreamsInSumOccupiedMoreMemoryThanAllowed;
    public static string DuringDecompressionSingleStreamOccupiedMoreMemoryThanAllowed;
    public static string DuringDecompressionSingleStreamOccupiedMoreThanMaxIntegerValue;
    public static string UnknownPdfException;
    public MemoryLimitsAwareException(string message);
    private static MemoryLimitsAwareException();
}
public class iTextSharp.text.pdf.MemoryLimitsAwareHandler : object {
    private static int SINGLE_SCALE_COEFFICIENT;
    private static int SUM_SCALE_COEFFICIENT;
    private static int SINGLE_DECOMPRESSED_PDF_STREAM_MIN_SIZE;
    private static long SUM_OF_DECOMPRESSED_PDF_STREAMW_MIN_SIZE;
    private int MaxSizeOfSingleDecompressedPdfStream;
    private long MaxSizeOfDecompressedPdfStreamsSum;
    private long AllMemoryUsedForDecompression;
    private long MemoryUsedForCurrentPdfStreamDecompression;
    internal bool ConsiderCurrentPdfStream;
    public MemoryLimitsAwareHandler(long documentSize);
    private static MemoryLimitsAwareHandler();
    public int GetMaxSizeOfSingleDecompressedPdfStream();
    public MemoryLimitsAwareHandler SetMaxSizeOfSingleDecompressedPdfStream(int maxSizeOfSingleDecompressedPdfStream);
    public long GetMaxSizeOfDecompressedPdfStreamsSum();
    public MemoryLimitsAwareHandler SetMaxSizeOfDecompressedPdfStreamsSum(long maxSizeOfDecompressedPdfStreamsSum);
    internal MemoryLimitsAwareHandler ConsiderBytesOccupiedByDecompressedPdfStream(long numOfOccupiedBytes);
    internal MemoryLimitsAwareHandler BeginDecompressedPdfStreamProcessing();
    internal MemoryLimitsAwareHandler EndDecompressedPdfStreamProcessing();
    internal long GetAllMemoryUsedForDecompression();
    private static long CalculateDefaultParameter(long documentSize, int scale, long min);
    private void EnsureCurrentStreamIsReset();
}
internal class iTextSharp.text.pdf.MemoryLimitsAwareOutputStream : MemoryStream {
    private static int DEFAULT_MAX_STREAM_SIZE;
    private int maxStreamSize;
    public MemoryLimitsAwareOutputStream(int size);
    private static MemoryLimitsAwareOutputStream();
    public long GetMaxStreamSize();
    public MemoryLimitsAwareOutputStream SetMaxStreamSize(int maxStreamSize);
    public virtual void Write(Byte[] b, int off, int len);
}
public class iTextSharp.text.pdf.NumberArray : PdfArray {
    public NumberArray(Single[] numbers);
    public NumberArray(float n1);
    public NumberArray(float n1, float n2);
    public NumberArray(float n1, float n2, float n3);
    public NumberArray(float n1, float n2, float n3, float n4);
    public NumberArray(float n1, float n2, float n3, float n4, float n5);
    public NumberArray(float n1, float n2, float n3, float n4, float n5, float n6);
    public NumberArray(IList`1<PdfNumber> numbers);
}
public class iTextSharp.text.pdf.OutputStreamCounter : Stream {
    protected Stream outc;
    protected long counter;
    public long Counter { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamCounter(Stream _outc);
    public virtual long get_Counter();
    public virtual void ResetCounter();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class iTextSharp.text.pdf.OutputStreamEncryption : Stream {
    protected Stream outc;
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] buf;
    private static int AES_128;
    private static int AES_256;
    private bool aes;
    private bool finished;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamEncryption(Stream outc, Byte[] key, int off, int len, int revision);
    public OutputStreamEncryption(Stream outc, Byte[] key, int revision);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void WriteByte(byte value);
    public virtual void Finish();
}
public class iTextSharp.text.pdf.PageResources : object {
    protected PdfDictionary fontDictionary;
    protected PdfDictionary xObjectDictionary;
    protected PdfDictionary colorDictionary;
    protected PdfDictionary patternDictionary;
    protected PdfDictionary shadingDictionary;
    protected PdfDictionary extGStateDictionary;
    protected PdfDictionary propertyDictionary;
    protected Dictionary`2<PdfName, object> forbiddenNames;
    protected PdfDictionary originalResources;
    protected Int32[] namePtr;
    protected Dictionary`2<PdfName, PdfName> usedNames;
    internal PdfDictionary Resources { get; }
    internal void SetOriginalResources(PdfDictionary resources, Int32[] newNamePtr);
    internal PdfName TranslateName(PdfName name);
    internal PdfName AddFont(PdfName name, PdfIndirectReference reference);
    internal PdfName AddXObject(PdfName name, PdfIndirectReference reference);
    internal PdfName AddColor(PdfName name, PdfIndirectReference reference);
    internal void AddDefaultColor(PdfName name, PdfObject obj);
    internal void AddDefaultColor(PdfDictionary dic);
    internal void AddDefaultColorDiff(PdfDictionary dic);
    internal PdfName AddShading(PdfName name, PdfIndirectReference reference);
    internal PdfName AddPattern(PdfName name, PdfIndirectReference reference);
    internal PdfName AddExtGState(PdfName name, PdfIndirectReference reference);
    internal PdfName AddProperty(PdfName name, PdfIndirectReference reference);
    internal PdfDictionary get_Resources();
    internal bool HasResources();
}
public class iTextSharp.text.pdf.parser.BezierCurve : object {
    public static double CurveCollinearityEpsilon;
    public static double DistanceToleranceSquare;
    public static double DistanceToleranceManhattan;
    private IList`1<Point2D> controlPoints;
    public BezierCurve(IList`1<Point2D> controlPoints);
    private static BezierCurve();
    public virtual IList`1<Point2D> GetBasePoints();
    public virtual IList`1<Point2D> GetPiecewiseLinearApproximation();
    private void RecursiveApproximation(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, IList`1<Point2D> points);
}
public class iTextSharp.text.pdf.parser.clipper.Clipper : ClipperBase {
    public static int ioReverseSolution;
    public static int ioStrictlySimple;
    public static int ioPreserveCollinear;
    private List`1<OutRec> m_PolyOuts;
    private ClipType m_ClipType;
    private Scanbeam m_Scanbeam;
    private Maxima m_Maxima;
    private TEdge m_ActiveEdges;
    private TEdge m_SortedEdges;
    private List`1<IntersectNode> m_IntersectList;
    private IComparer`1<IntersectNode> m_IntersectNodeComparer;
    private bool m_ExecuteLocked;
    private PolyFillType m_ClipFillType;
    private PolyFillType m_SubjFillType;
    private List`1<Join> m_Joins;
    private List`1<Join> m_GhostJoins;
    private bool m_UsingPolyTree;
    private bool reverseSolution;
    private bool strictlySimple;
    public bool ReverseSolution { get; public set; }
    public bool StrictlySimple { get; public set; }
    public Clipper(int InitOptions);
    private void InsertScanbeam(long Y);
    private void InsertMaxima(long X);
    protected virtual void Reset();
    public bool get_ReverseSolution();
    public void set_ReverseSolution(bool value);
    public bool get_StrictlySimple();
    public void set_StrictlySimple(bool value);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution, PolyFillType FillType);
    public bool Execute(ClipType clipType, PolyTree polytree);
    public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType FillType);
    public bool Execute(ClipType clipType, List`1<List`1<IntPoint>> solution, PolyFillType subjFillType, PolyFillType clipFillType);
    public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType subjFillType, PolyFillType clipFillType);
    internal void FixHoleLinkage(OutRec outRec);
    private bool ExecuteInternal();
    private long PopScanbeam();
    private void DisposeAllPolyPts();
    private void DisposeOutRec(int index);
    private void AddJoin(OutPt Op1, OutPt Op2, IntPoint OffPt);
    private void AddGhostJoin(OutPt Op, IntPoint OffPt);
    private void InsertLocalMinimaIntoAEL(long botY);
    private void InsertEdgeIntoAEL(TEdge edge, TEdge startEdge);
    private bool E2InsertsBeforeE1(TEdge e1, TEdge e2);
    private bool IsEvenOddFillType(TEdge edge);
    private bool IsEvenOddAltFillType(TEdge edge);
    private bool IsContributing(TEdge edge);
    private void SetWindingCount(TEdge edge);
    private void AddEdgeToSEL(TEdge edge);
    private void CopyAELToSEL();
    private void SwapPositionsInAEL(TEdge edge1, TEdge edge2);
    private void SwapPositionsInSEL(TEdge edge1, TEdge edge2);
    private void AddLocalMaxPoly(TEdge e1, TEdge e2, IntPoint pt);
    private OutPt AddLocalMinPoly(TEdge e1, TEdge e2, IntPoint pt);
    private OutRec CreateOutRec();
    private OutPt AddOutPt(TEdge e, IntPoint pt);
    private OutPt GetLastOutPt(TEdge e);
    internal void SwapPoints(IntPoint& pt1, IntPoint& pt2);
    private bool HorzSegmentsOverlap(long seg1a, long seg1b, long seg2a, long seg2b);
    private void SetHoleState(TEdge e, OutRec outRec);
    private double GetDx(IntPoint pt1, IntPoint pt2);
    private bool FirstIsBottomPt(OutPt btmPt1, OutPt btmPt2);
    private OutPt GetBottomPt(OutPt pp);
    private OutRec GetLowermostRec(OutRec outRec1, OutRec outRec2);
    private bool Param1RightOfParam2(OutRec outRec1, OutRec outRec2);
    private OutRec GetOutRec(int idx);
    private void AppendPolygon(TEdge e1, TEdge e2);
    private void ReversePolyPtLinks(OutPt pp);
    private static void SwapSides(TEdge edge1, TEdge edge2);
    private static void SwapPolyIndexes(TEdge edge1, TEdge edge2);
    private void IntersectEdges(TEdge e1, TEdge e2, IntPoint pt);
    private void DeleteFromAEL(TEdge e);
    private void DeleteFromSEL(TEdge e);
    private void UpdateEdgeIntoAEL(TEdge& e);
    private void ProcessHorizontals();
    private void GetHorzDirection(TEdge HorzEdge, Direction& Dir, Int64& Left, Int64& Right);
    private void ProcessHorizontal(TEdge horzEdge);
    private TEdge GetNextInAEL(TEdge e, Direction Direction);
    private bool IsMinima(TEdge e);
    private bool IsMaxima(TEdge e, double Y);
    private bool IsIntermediate(TEdge e, double Y);
    private TEdge GetMaximaPair(TEdge e);
    private bool ProcessIntersections(long topY);
    private void BuildIntersectList(long topY);
    private bool EdgesAdjacent(IntersectNode inode);
    private static int IntersectNodeSort(IntersectNode node1, IntersectNode node2);
    private bool FixupIntersectionOrder();
    private void ProcessIntersectList();
    internal static long Round(double value);
    private static long TopX(TEdge edge, long currentY);
    private void IntersectPoint(TEdge edge1, TEdge edge2, IntPoint& ip);
    private void ProcessEdgesAtTopOfScanbeam(long topY);
    private void DoMaxima(TEdge e);
    public static void ReversePaths(List`1<List`1<IntPoint>> polys);
    public static bool Orientation(List`1<IntPoint> poly);
    private int PointCount(OutPt pts);
    private void BuildResult(List`1<List`1<IntPoint>> polyg);
    private void BuildResult2(PolyTree polytree);
    private void FixupOutPolyline(OutRec outrec);
    private void FixupOutPolygon(OutRec outRec);
    private OutPt DupOutPt(OutPt outPt, bool InsertAfter);
    private bool GetOverlap(long a1, long a2, long b1, long b2, Int64& Left, Int64& Right);
    private bool JoinHorz(OutPt op1, OutPt op1b, OutPt op2, OutPt op2b, IntPoint Pt, bool DiscardLeft);
    private bool JoinPoints(Join j, OutRec outRec1, OutRec outRec2);
    public static int PointInPolygon(IntPoint pt, List`1<IntPoint> path);
    private static int PointInPolygon(IntPoint pt, OutPt op);
    private static bool Poly2ContainsPoly1(OutPt outPt1, OutPt outPt2);
    private void FixupFirstLefts1(OutRec OldOutRec, OutRec NewOutRec);
    private void FixupFirstLefts2(OutRec OldOutRec, OutRec NewOutRec);
    private static OutRec ParseFirstLeft(OutRec FirstLeft);
    private void JoinCommonEdges();
    private void UpdateOutPtIdxs(OutRec outrec);
    private void DoSimplePolygons();
    public static double Area(List`1<IntPoint> poly);
    private double Area(OutRec outRec);
    public static List`1<List`1<IntPoint>> SimplifyPolygon(List`1<IntPoint> poly);
    public static List`1<List`1<IntPoint>> SimplifyPolygon(List`1<IntPoint> poly, PolyFillType fillType);
    public static List`1<List`1<IntPoint>> SimplifyPolygons(List`1<List`1<IntPoint>> polys);
    public static List`1<List`1<IntPoint>> SimplifyPolygons(List`1<List`1<IntPoint>> polys, PolyFillType fillType);
    private static double DistanceSqrd(IntPoint pt1, IntPoint pt2);
    private static double DistanceFromLineSqrd(IntPoint pt, IntPoint ln1, IntPoint ln2);
    private static bool SlopesNearCollinear(IntPoint pt1, IntPoint pt2, IntPoint pt3, double distSqrd);
    private static bool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd);
    private static OutPt ExcludeOp(OutPt op);
    public static List`1<IntPoint> CleanPolygon(List`1<IntPoint> path);
    public static List`1<IntPoint> CleanPolygon(List`1<IntPoint> path, double distance);
    public static List`1<List`1<IntPoint>> CleanPolygons(List`1<List`1<IntPoint>> polys);
    public static List`1<List`1<IntPoint>> CleanPolygons(List`1<List`1<IntPoint>> polys, double distance);
    internal static List`1<List`1<IntPoint>> Minkowski(List`1<IntPoint> pattern, List`1<IntPoint> path, bool IsSum, bool IsClosed);
    public static List`1<List`1<IntPoint>> MinkowskiSum(List`1<IntPoint> pattern, List`1<IntPoint> path, bool pathIsClosed);
    private static List`1<IntPoint> TranslatePath(List`1<IntPoint> path, IntPoint delta);
    public static List`1<List`1<IntPoint>> MinkowskiSum(List`1<IntPoint> pattern, List`1<List`1<IntPoint>> paths, bool pathIsClosed);
    public static List`1<List`1<IntPoint>> MinkowskiDiff(List`1<IntPoint> poly1, List`1<IntPoint> poly2);
    public static List`1<List`1<IntPoint>> PolyTreeToPaths(PolyTree polytree);
    internal static void AddPolyNodeToPaths(PolyNode polynode, NodeType nt, List`1<List`1<IntPoint>> paths);
    public static List`1<List`1<IntPoint>> OpenPathsFromPolyTree(PolyTree polytree);
    public static List`1<List`1<IntPoint>> ClosedPathsFromPolyTree(PolyTree polytree);
}
public class iTextSharp.text.pdf.parser.clipper.ClipperBase : object {
    protected static double horizontal;
    protected static int Skip;
    protected static int Unassigned;
    protected static double tolerance;
    public static long loRange;
    public static long hiRange;
    internal LocalMinima m_MinimaList;
    internal LocalMinima m_CurrentLM;
    internal List`1<List`1<TEdge>> m_edges;
    internal bool m_UseFullRange;
    internal bool m_HasOpenPaths;
    internal bool preserveCollinear;
    public bool PreserveCollinear { get; public set; }
    internal static bool near_zero(double val);
    public bool get_PreserveCollinear();
    public void set_PreserveCollinear(bool value);
    public void Swap(Int64& val1, Int64& val2);
    internal static bool IsHorizontal(TEdge e);
    internal bool PointIsVertex(IntPoint pt, OutPt pp);
    internal bool PointOnLineSegment(IntPoint pt, IntPoint linePt1, IntPoint linePt2, bool UseFullRange);
    internal bool PointOnPolygon(IntPoint pt, OutPt pp, bool UseFullRange);
    internal static bool SlopesEqual(TEdge e1, TEdge e2, bool UseFullRange);
    protected static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, bool UseFullRange);
    protected static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, IntPoint pt4, bool UseFullRange);
    public virtual void Clear();
    private void DisposeLocalMinimaList();
    private void RangeTest(IntPoint Pt, Boolean& useFullRange);
    private void InitEdge(TEdge e, TEdge eNext, TEdge ePrev, IntPoint pt);
    private void InitEdge2(TEdge e, PolyType polyType);
    private TEdge FindNextLocMin(TEdge E);
    private TEdge ProcessBound(TEdge E, bool LeftBoundIsForward);
    public bool AddPath(List`1<IntPoint> pg, PolyType polyType, bool Closed);
    public bool AddPaths(List`1<List`1<IntPoint>> ppg, PolyType polyType, bool closed);
    internal bool Pt2IsBetweenPt1AndPt3(IntPoint pt1, IntPoint pt2, IntPoint pt3);
    private TEdge RemoveEdge(TEdge e);
    private void SetDx(TEdge e);
    private void InsertLocalMinima(LocalMinima newLm);
    protected void PopLocalMinima();
    private void ReverseHorizontal(TEdge e);
    protected virtual void Reset();
    public static IntRect GetBounds(List`1<List`1<IntPoint>> paths);
}
internal class iTextSharp.text.pdf.parser.clipper.ClipperException : Exception {
    public ClipperException(string description);
}
public class iTextSharp.text.pdf.parser.clipper.ClipperOffset : object {
    private List`1<List`1<IntPoint>> m_destPolys;
    private List`1<IntPoint> m_srcPoly;
    private List`1<IntPoint> m_destPoly;
    private List`1<DoublePoint> m_normals;
    private double m_delta;
    private double m_sinA;
    private double m_sin;
    private double m_cos;
    private double m_miterLim;
    private double m_StepsPerRad;
    private double arcTolerance;
    private double miterLimit;
    private IntPoint m_lowest;
    private PolyNode m_polyNodes;
    private static double two_pi;
    private static double def_arc_tolerance;
    public double ArcTolerance { get; public set; }
    public double MiterLimit { get; public set; }
    public ClipperOffset(double miterLimit, double arcTolerance);
    public double get_ArcTolerance();
    public void set_ArcTolerance(double value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public void Clear();
    internal static long Round(double value);
    public void AddPath(List`1<IntPoint> path, JoinType joinType, EndType endType);
    public void AddPaths(List`1<List`1<IntPoint>> paths, JoinType joinType, EndType endType);
    private void FixOrientations();
    internal static DoublePoint GetUnitNormal(IntPoint pt1, IntPoint pt2);
    private void DoOffset(double delta);
    public void Execute(List`1& solution, double delta);
    public void Execute(PolyTree& solution, double delta);
    private void OffsetPoint(int j, Int32& k, JoinType jointype);
    internal void DoSquare(int j, int k, bool addExtra);
    internal void DoMiter(int j, int k, double r);
    internal void DoRound(int j, int k);
}
public enum iTextSharp.text.pdf.parser.clipper.ClipType : Enum {
    public int value__;
    public static ClipType ctIntersection;
    public static ClipType ctUnion;
    public static ClipType ctDifference;
    public static ClipType ctXor;
}
internal enum iTextSharp.text.pdf.parser.clipper.Direction : Enum {
    public int value__;
    public static Direction dRightToLeft;
    public static Direction dLeftToRight;
}
public class iTextSharp.text.pdf.parser.clipper.DoublePoint : ValueType {
    public double X;
    public double Y;
    public DoublePoint(double x, double y);
    public DoublePoint(DoublePoint dp);
    public DoublePoint(IntPoint ip);
}
internal enum iTextSharp.text.pdf.parser.clipper.EdgeSide : Enum {
    public int value__;
    public static EdgeSide esLeft;
    public static EdgeSide esRight;
}
public enum iTextSharp.text.pdf.parser.clipper.EndType : Enum {
    public int value__;
    public static EndType etClosedPolygon;
    public static EndType etClosedLine;
    public static EndType etOpenButt;
    public static EndType etOpenSquare;
    public static EndType etOpenRound;
}
internal class iTextSharp.text.pdf.parser.clipper.Int128 : ValueType {
    private long hi;
    private ulong lo;
    public Int128(long _lo);
    public Int128(long _hi, ulong _lo);
    public Int128(Int128 val);
    public bool IsNegative();
    public static bool op_Equality(Int128 val1, Int128 val2);
    public static bool op_Inequality(Int128 val1, Int128 val2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(Int128 val1, Int128 val2);
    public static bool op_LessThan(Int128 val1, Int128 val2);
    public static Int128 op_Addition(Int128 lhs, Int128 rhs);
    public static Int128 op_Subtraction(Int128 lhs, Int128 rhs);
    public static Int128 op_UnaryNegation(Int128 val);
    public static double op_Explicit(Int128 val);
    public static Int128 Int128Mul(long lhs, long rhs);
}
public class iTextSharp.text.pdf.parser.clipper.IntersectNode : object {
    internal TEdge Edge1;
    internal TEdge Edge2;
    internal IntPoint Pt;
}
public class iTextSharp.text.pdf.parser.clipper.IntPoint : ValueType {
    public long X;
    public long Y;
    public IntPoint(long X, long Y);
    public IntPoint(double x, double y);
    public IntPoint(IntPoint pt);
    public static bool op_Equality(IntPoint a, IntPoint b);
    public static bool op_Inequality(IntPoint a, IntPoint b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.parser.clipper.IntRect : ValueType {
    public long left;
    public long top;
    public long right;
    public long bottom;
    public IntRect(long l, long t, long r, long b);
    public IntRect(IntRect ir);
}
internal class iTextSharp.text.pdf.parser.clipper.Join : object {
    internal OutPt OutPt1;
    internal OutPt OutPt2;
    internal IntPoint OffPt;
}
public enum iTextSharp.text.pdf.parser.clipper.JoinType : Enum {
    public int value__;
    public static JoinType jtBevel;
    public static JoinType jtRound;
    public static JoinType jtMiter;
}
internal class iTextSharp.text.pdf.parser.clipper.LocalMinima : object {
    internal long Y;
    internal TEdge LeftBound;
    internal TEdge RightBound;
    internal LocalMinima Next;
}
internal class iTextSharp.text.pdf.parser.clipper.Maxima : object {
    internal long X;
    internal Maxima Next;
    internal Maxima Prev;
}
public class iTextSharp.text.pdf.parser.clipper.MyIntersectNodeSort : object {
    public sealed virtual int Compare(IntersectNode node1, IntersectNode node2);
}
internal class iTextSharp.text.pdf.parser.clipper.OutPt : object {
    internal int Idx;
    internal IntPoint Pt;
    internal OutPt Next;
    internal OutPt Prev;
}
internal class iTextSharp.text.pdf.parser.clipper.OutRec : object {
    internal int Idx;
    internal bool IsHole;
    internal bool IsOpen;
    internal OutRec FirstLeft;
    internal OutPt Pts;
    internal OutPt BottomPt;
    internal PolyNode PolyNode;
}
public enum iTextSharp.text.pdf.parser.clipper.PolyFillType : Enum {
    public int value__;
    public static PolyFillType pftEvenOdd;
    public static PolyFillType pftNonZero;
    public static PolyFillType pftPositive;
    public static PolyFillType pftNegative;
}
public class iTextSharp.text.pdf.parser.clipper.PolyNode : object {
    internal PolyNode m_Parent;
    internal List`1<IntPoint> m_polygon;
    internal int m_Index;
    internal JoinType m_jointype;
    internal EndType m_endtype;
    internal List`1<PolyNode> m_Childs;
    internal bool isOpen;
    public int ChildCount { get; }
    public List`1<IntPoint> Contour { get; }
    public List`1<PolyNode> Childs { get; }
    public PolyNode Parent { get; }
    public bool IsHole { get; }
    public bool IsOpen { get; public set; }
    private bool IsHoleNode();
    public int get_ChildCount();
    public List`1<IntPoint> get_Contour();
    internal void AddChild(PolyNode Child);
    public PolyNode GetNext();
    internal PolyNode GetNextSiblingUp();
    public List`1<PolyNode> get_Childs();
    public PolyNode get_Parent();
    public bool get_IsHole();
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
}
public class iTextSharp.text.pdf.parser.clipper.PolyTree : PolyNode {
    internal List`1<PolyNode> m_AllPolys;
    public int Total { get; }
    public void Clear();
    public PolyNode GetFirst();
    public int get_Total();
}
public enum iTextSharp.text.pdf.parser.clipper.PolyType : Enum {
    public int value__;
    public static PolyType ptSubject;
    public static PolyType ptClip;
}
internal class iTextSharp.text.pdf.parser.clipper.Scanbeam : object {
    internal long Y;
    internal Scanbeam Next;
}
internal class iTextSharp.text.pdf.parser.clipper.TEdge : object {
    internal IntPoint Bot;
    internal IntPoint Curr;
    internal IntPoint Top;
    internal IntPoint Delta;
    internal double Dx;
    internal PolyType PolyTyp;
    internal EdgeSide Side;
    internal int WindDelta;
    internal int WindCnt;
    internal int WindCnt2;
    internal int OutIdx;
    internal TEdge Next;
    internal TEdge Prev;
    internal TEdge NextInLML;
    internal TEdge NextInAEL;
    internal TEdge PrevInAEL;
    internal TEdge NextInSEL;
    internal TEdge PrevInSEL;
}
public class iTextSharp.text.pdf.parser.ContentByteUtils : object {
    public static Byte[] GetContentBytesFromContentObject(PdfObject contentObject);
    public static Byte[] GetContentBytesForPage(PdfReader reader, int pageNum);
}
public class iTextSharp.text.pdf.parser.FilteredRenderListener : object {
    private IRenderListener deleg;
    private RenderFilter[] filters;
    public FilteredRenderListener(IRenderListener deleg, RenderFilter[] filters);
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.FilteredTextRenderListener : FilteredRenderListener {
    private ITextExtractionStrategy deleg;
    public FilteredTextRenderListener(ITextExtractionStrategy deleg, RenderFilter[] filters);
    public virtual string GetResultantText();
}
public class iTextSharp.text.pdf.parser.GlyphRenderListener : object {
    private IRenderListener deleg;
    public GlyphRenderListener(IRenderListener deleg);
    public virtual void BeginTextBlock();
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.GlyphTextRenderListener : GlyphRenderListener {
    private ITextExtractionStrategy deleg;
    public GlyphTextRenderListener(ITextExtractionStrategy deleg);
    public virtual string GetResultantText();
}
public class iTextSharp.text.pdf.parser.GraphicsState : object {
    internal Matrix ctm;
    internal float characterSpacing;
    internal float wordSpacing;
    internal float horizontalScaling;
    internal float leading;
    internal CMapAwareDocumentFont font;
    internal float fontSize;
    internal int renderMode;
    internal float rise;
    internal bool knockout;
    internal PdfName colorSpaceFill;
    internal PdfName colorSpaceStroke;
    internal BaseColor fillColor;
    internal BaseColor strokeColor;
    private float lineWidth;
    private int lineCapStyle;
    private int lineJoinStyle;
    private float miterLimit;
    private LineDashPattern lineDashPattern;
    public float CharacterSpacing { get; }
    public float WordSpacing { get; }
    public float HorizontalScaling { get; }
    public CMapAwareDocumentFont Font { get; }
    public float FontSize { get; }
    public PdfName ColorSpaceFill { get; }
    public PdfName ColorSpaceStroke { get; }
    public BaseColor FillColor { get; }
    public BaseColor StrokeColor { get; }
    public float LineWidth { get; public set; }
    public int LineCapStyle { get; public set; }
    public int LineJoinStyle { get; public set; }
    public float MiterLimit { get; public set; }
    public GraphicsState(GraphicsState source);
    public virtual float get_CharacterSpacing();
    public virtual float get_WordSpacing();
    public virtual float get_HorizontalScaling();
    public virtual CMapAwareDocumentFont get_Font();
    public virtual float get_FontSize();
    public virtual Matrix GetCtm();
    public virtual float GetCharacterSpacing();
    public virtual float GetWordSpacing();
    public virtual float GetHorizontalScaling();
    public virtual float GetLeading();
    public virtual CMapAwareDocumentFont GetFont();
    public virtual float GetFontSize();
    public virtual int GetRenderMode();
    public virtual float GetRise();
    public virtual bool IsKnockout();
    public virtual PdfName get_ColorSpaceFill();
    public virtual PdfName get_ColorSpaceStroke();
    public virtual BaseColor get_FillColor();
    public virtual BaseColor get_StrokeColor();
    public float get_LineWidth();
    public void set_LineWidth(float value);
    public int get_LineCapStyle();
    public void set_LineCapStyle(int value);
    public int get_LineJoinStyle();
    public void set_LineJoinStyle(int value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public virtual LineDashPattern GetLineDashPattern();
    public virtual void SetLineDashPattern(LineDashPattern lineDashPattern);
}
public interface iTextSharp.text.pdf.parser.IContentOperator {
    public abstract virtual void Invoke(PdfContentStreamProcessor processor, PdfLiteral oper, List`1<PdfObject> operands);
}
public interface iTextSharp.text.pdf.parser.IExtRenderListener {
    public abstract virtual void ModifyPath(PathConstructionRenderInfo renderInfo);
    public abstract virtual Path RenderPath(PathPaintingRenderInfo renderInfo);
    public abstract virtual void ClipPath(int rule);
}
public class iTextSharp.text.pdf.parser.ImageRenderInfo : object {
    private GraphicsState gs;
    private PdfIndirectReference refi;
    private InlineImageInfo inlineImageInfo;
    private PdfDictionary colorSpaceDictionary;
    private PdfImageObject imageObject;
    private ICollection`1<MarkedContentInfo> markedContentInfos;
    private ImageRenderInfo(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    private ImageRenderInfo(GraphicsState gs, InlineImageInfo inlineImageInfo, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    public static ImageRenderInfo CreateForXObject(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary);
    public static ImageRenderInfo CreateForXObject(GraphicsState gs, PdfIndirectReference refi, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    protected internal static ImageRenderInfo CreateForEmbeddedImage(GraphicsState gs, InlineImageInfo inlineImageInfo, PdfDictionary colorSpaceDictionary, ICollection markedContentInfos);
    public virtual PdfImageObject GetImage();
    private void PrepareImageObject();
    public virtual Vector GetStartPoint();
    public virtual Matrix GetImageCTM();
    public virtual float GetArea();
    public virtual PdfIndirectReference GetRef();
    public BaseColor GetCurrentFillColor();
    public virtual bool HasMcid(int mcid);
    public virtual bool HasMcid(int mcid, bool checkTheTopmostLevelOnly);
    public virtual Nullable`1<int> GetMcid();
}
public class iTextSharp.text.pdf.parser.InlineImageInfo : object {
    private Byte[] samples;
    private PdfDictionary imageDictionary;
    public PdfDictionary ImageDictionary { get; }
    public Byte[] Samples { get; }
    public InlineImageInfo(Byte[] samples, PdfDictionary imageDictionary);
    public virtual PdfDictionary get_ImageDictionary();
    public virtual Byte[] get_Samples();
}
public static class iTextSharp.text.pdf.parser.InlineImageUtils : object {
    private static ILogger LOGGER;
    private static IDictionary`2<PdfName, PdfName> inlineImageEntryAbbreviationMap;
    private static IDictionary`2<PdfName, PdfName> inlineImageColorSpaceAbbreviationMap;
    private static IDictionary`2<PdfName, PdfName> inlineImageFilterAbbreviationMap;
    private static InlineImageUtils();
    public static InlineImageInfo ParseInlineImage(PdfContentParser ps, PdfDictionary colorSpaceDic);
    private static PdfDictionary ParseInlineImageDictionary(PdfContentParser ps);
    private static PdfObject GetAlternateValue(PdfName key, PdfObject value);
    private static int GetComponentsPerPixel(PdfName colorSpaceName, PdfDictionary colorSpaceDic);
    private static int ComputeBytesPerRow(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic);
    private static Byte[] ParseUnfilteredSamples(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic, PdfContentParser ps);
    private static Byte[] ParseInlineImageSamples(PdfDictionary imageDictionary, PdfDictionary colorSpaceDic, PdfContentParser ps);
    private static bool InlineImageStreamBytesAreComplete(Byte[] samples, PdfDictionary imageDictionary);
}
public interface iTextSharp.text.pdf.parser.IRenderListener {
    public abstract virtual void BeginTextBlock();
    public abstract virtual void RenderText(TextRenderInfo renderInfo);
    public abstract virtual void EndTextBlock();
    public abstract virtual void RenderImage(ImageRenderInfo renderInfo);
}
public interface iTextSharp.text.pdf.parser.IShape {
    public abstract virtual IList`1<Point2D> GetBasePoints();
}
public interface iTextSharp.text.pdf.parser.ITextExtractionStrategy {
    public abstract virtual string GetResultantText();
}
public interface iTextSharp.text.pdf.parser.IXObjectDoHandler {
    public abstract virtual void HandleXObject(PdfContentStreamProcessor processor, PdfStream stream, PdfIndirectReference refi);
    public abstract virtual void HandleXObject(PdfContentStreamProcessor processor, PdfStream stream, PdfIndirectReference refi, ICollection markedContentInfoStack);
}
public class iTextSharp.text.pdf.parser.Line : object {
    private Point2D p1;
    private Point2D p2;
    public Line(float x1, float y1, float x2, float y2);
    public Line(Point2D p1, Point2D p2);
    public virtual IList`1<Point2D> GetBasePoints();
}
public class iTextSharp.text.pdf.parser.LineDashPattern : object {
    private PdfArray dashArray;
    private float dashPhase;
    private int currentIndex;
    private int elemOrdinalNumber;
    private DashArrayElem currentElem;
    public PdfArray DashArray { get; public set; }
    public float DashPhase { get; public set; }
    public LineDashPattern(PdfArray dashArray, float dashPhase);
    public PdfArray get_DashArray();
    public void set_DashArray(PdfArray value);
    public float get_DashPhase();
    public void set_DashPhase(float value);
    public DashArrayElem Next();
    public bool IsSolid();
    public void Reset();
    private void InitFirst(float phase);
    private bool IsEven(int num);
}
public class iTextSharp.text.pdf.parser.LineSegment : object {
    private Vector startPoint;
    private Vector endPoint;
    public LineSegment(Vector startPoint, Vector endPoint);
    public virtual Vector GetStartPoint();
    public virtual Vector GetEndPoint();
    public virtual float GetLength();
    public virtual RectangleJ GetBoundingRectange();
    public virtual LineSegment TransformBy(Matrix m);
}
public class iTextSharp.text.pdf.parser.LocationTextExtractionStrategy : object {
    public static bool DUMP_STATE;
    private List`1<TextChunk> locationalResult;
    private ITextChunkLocationStrategy tclStrat;
    public LocationTextExtractionStrategy(ITextChunkLocationStrategy strat);
    private static LocationTextExtractionStrategy();
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    private bool StartsWithSpace(string str);
    private bool EndsWithSpace(string str);
    private List`1<TextChunk> filterTextChunks(List`1<TextChunk> textChunks, ITextChunkFilter filter);
    protected virtual bool IsChunkAtWordBoundary(TextChunk chunk, TextChunk previousChunk);
    public virtual string GetResultantText(ITextChunkFilter chunkFilter);
    public virtual string GetResultantText();
    private void DumpState();
    public virtual void RenderText(TextRenderInfo renderInfo);
    private static int CompareInts(int int1, int int2);
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.MarkedContentInfo : object {
    private PdfName tag;
    private PdfDictionary dictionary;
    public MarkedContentInfo(PdfName tag, PdfDictionary dictionary);
    public virtual PdfName GetTag();
    public virtual bool HasMcid();
    public virtual int GetMcid();
}
public class iTextSharp.text.pdf.parser.MarkedContentRenderFilter : RenderFilter {
    private int mcid;
    public MarkedContentRenderFilter(int mcid);
    public virtual bool AllowText(TextRenderInfo renderInfo);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.parser.Matrix : object {
    public static int I11;
    public static int I12;
    public static int I13;
    public static int I21;
    public static int I22;
    public static int I23;
    public static int I31;
    public static int I32;
    public static int I33;
    private Single[] vals;
    public float Item { get; }
    public Matrix(float tx, float ty);
    public Matrix(float a, float b, float c, float d, float e, float f);
    public float get_Item(int index);
    public virtual Matrix Multiply(Matrix by);
    public virtual Matrix Subtract(Matrix arg);
    public virtual float GetDeterminant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.parser.MultiFilteredRenderListener : object {
    private List`1<IRenderListener> delegates;
    private List`1<RenderFilter[]> filters;
    public virtual E AttachRenderListener(E deleg, RenderFilter[] filterSet);
    public virtual void BeginTextBlock();
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.Path : object {
    private static string START_PATH_ERR_MSG;
    private IList`1<Subpath> subpaths;
    private Point2D currentPoint;
    public IList`1<Subpath> Subpaths { get; }
    public Point2D CurrentPoint { get; }
    private Subpath LastSubpath { get; }
    public Path(IList`1<Subpath> subpaths);
    private static Path();
    public virtual IList`1<Subpath> get_Subpaths();
    public void AddSubpath(Subpath subpath);
    public void AddSubpaths(IList`1<Subpath> subpaths);
    public virtual Point2D get_CurrentPoint();
    public virtual void MoveTo(float x, float y);
    public virtual void LineTo(float x, float y);
    public virtual void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public virtual void CurveTo(float x2, float y2, float x3, float y3);
    public virtual void CurveFromTo(float x1, float y1, float x3, float y3);
    public virtual void Rectangle(float x, float y, float w, float h);
    public virtual void CloseSubpath();
    public virtual void CloseAllSubpaths();
    public virtual IList`1<int> ReplaceCloseWithLine();
    public virtual bool IsEmpty();
    private Subpath get_LastSubpath();
}
public class iTextSharp.text.pdf.parser.PathConstructionRenderInfo : object {
    public static int MOVETO;
    public static int LINETO;
    public static int CURVE_123;
    public static int CURVE_23;
    public static int CURVE_13;
    public static int CLOSE;
    public static int RECT;
    private int operation;
    private IList`1<float> segmentData;
    private Matrix ctm;
    public int Operation { get; }
    public IList`1<float> SegmentData { get; }
    public Matrix Ctm { get; }
    public PathConstructionRenderInfo(int operation, IList`1<float> segmentData, Matrix ctm);
    public PathConstructionRenderInfo(int operation, Matrix ctm);
    public virtual int get_Operation();
    public virtual IList`1<float> get_SegmentData();
    public virtual Matrix get_Ctm();
}
public class iTextSharp.text.pdf.parser.PathPaintingRenderInfo : object {
    public static int NONZERO_WINDING_RULE;
    public static int EVEN_ODD_RULE;
    public static int NO_OP;
    public static int STROKE;
    public static int FILL;
    private int operation;
    private int rule;
    private GraphicsState gs;
    public int Operation { get; }
    public int Rule { get; }
    public Matrix Ctm { get; }
    public float LineWidth { get; }
    public int LineCapStyle { get; }
    public int LineJoinStyle { get; }
    public float MiterLimit { get; }
    public LineDashPattern LineDashPattern { get; }
    public PathPaintingRenderInfo(int operation, int rule, GraphicsState gs);
    public PathPaintingRenderInfo(int operation, GraphicsState gs);
    public virtual int get_Operation();
    public virtual int get_Rule();
    public virtual Matrix get_Ctm();
    public virtual float get_LineWidth();
    public virtual int get_LineCapStyle();
    public virtual int get_LineJoinStyle();
    public virtual float get_MiterLimit();
    public virtual LineDashPattern get_LineDashPattern();
}
public class iTextSharp.text.pdf.parser.PdfContentReaderTool : object {
    public static string GetDictionaryDetail(PdfDictionary dic);
    public static string GetDictionaryDetail(PdfDictionary dic, int depth);
    public static string GetXObjectDetail(PdfDictionary resourceDic);
    public static void ListContentStreamForPage(PdfReader reader, int pageNum, TextWriter outp);
    public static void ListContentStream(string pdfFile, TextWriter outp);
    public static void ListContentStream(string pdfFile, int pageNum, TextWriter outp);
    public static void Main(String[] args);
}
public class iTextSharp.text.pdf.parser.PdfContentStreamProcessor : object {
    public static string DEFAULTOPERATOR;
    private IDictionary`2<string, IContentOperator> operators;
    private ResourceDictionary resources;
    private Stack`1<GraphicsState> gsStack;
    private Matrix textMatrix;
    private Matrix textLineMatrix;
    private IRenderListener renderListener;
    private IDictionary`2<PdfName, IXObjectDoHandler> xobjectDoHandlers;
    private IDictionary`2<int, WeakReference> cachedFonts;
    private Stack`1<MarkedContentInfo> markedContentStack;
    public ICollection`1<string> RegisteredOperatorStrings { get; }
    public IRenderListener RenderListener { get; }
    public PdfContentStreamProcessor(IRenderListener renderListener);
    private void PopulateXObjectDoHandlers();
    public virtual IXObjectDoHandler RegisterXObjectDoHandler(PdfName xobjectSubType, IXObjectDoHandler handler);
    private CMapAwareDocumentFont GetFont(PRIndirectReference ind);
    private CMapAwareDocumentFont GetFont(PdfDictionary fontResource);
    private void PopulateOperators();
    public virtual IContentOperator RegisterContentOperator(string operatorString, IContentOperator oper);
    public virtual ICollection`1<string> get_RegisteredOperatorStrings();
    public virtual void Reset();
    public GraphicsState Gs();
    private void InvokeOperator(PdfLiteral oper, List`1<PdfObject> operands);
    private void BeginMarkedContent(PdfName tag, PdfDictionary dict);
    private void EndMarkedContent();
    private void BeginText();
    private void EndText();
    private void DisplayPdfString(PdfString str);
    private void DisplayXObject(PdfName xobjectName);
    private void PaintPath(int operation, int rule, bool close);
    private void ModifyPath(int operation, IList`1<float> segmentData);
    private void ClipPath(int rule);
    private void ApplyTextAdjust(float tj);
    public virtual void ProcessContent(Byte[] contentBytes, PdfDictionary resources);
    protected virtual void HandleInlineImage(InlineImageInfo info, PdfDictionary colorSpaceDic);
    public virtual IRenderListener get_RenderListener();
    private static BaseColor GetColor(PdfName colorSpace, List`1<PdfObject> operands);
    private static BaseColor GetColor(int nOperands, List`1<PdfObject> operands);
}
public class iTextSharp.text.pdf.parser.PdfImageObject : object {
    private PdfDictionary dictionary;
    private Byte[] imageBytes;
    private PdfDictionary colorSpaceDic;
    private int pngColorType;
    private int pngBitDepth;
    private int width;
    private int height;
    private int bpc;
    private Byte[] palette;
    private Byte[] icc;
    private int stride;
    private ImageBytesType streamContentType;
    public PdfImageObject(PRStream stream);
    public PdfImageObject(PRStream stream, PdfDictionary colorSpaceDic);
    protected internal PdfImageObject(PdfDictionary dictionary, Byte[] samples, PdfDictionary colorSpaceDic);
    public virtual string GetFileType();
    public virtual ImageBytesType GetImageBytesType();
    public virtual PdfObject Get(PdfName key);
    public virtual PdfDictionary GetDictionary();
    private void FindColorspace(PdfObject colorspace, bool allowIndexed);
    private void DecodeImageBytes();
    public virtual Byte[] GetImageAsBytes();
    public Image GetDrawingImage();
}
public class iTextSharp.text.pdf.parser.PdfReaderContentParser : object {
    private PdfReader reader;
    public PdfReaderContentParser(PdfReader reader);
    public virtual E ProcessContent(int pageNumber, E renderListener, IDictionary`2<string, IContentOperator> additionalContentOperators);
    public virtual E ProcessContent(int pageNumber, E renderListener);
}
public static class iTextSharp.text.pdf.parser.PdfTextExtractor : object {
    public static string GetTextFromPage(PdfReader reader, int pageNumber, ITextExtractionStrategy strategy, IDictionary`2<string, IContentOperator> additionalContentOperators);
    public static string GetTextFromPage(PdfReader reader, int pageNumber, ITextExtractionStrategy strategy);
    public static string GetTextFromPage(PdfReader reader, int pageNumber);
}
public class iTextSharp.text.pdf.parser.RegionTextRenderFilter : RenderFilter {
    private RectangleJ filterRect;
    public RegionTextRenderFilter(RectangleJ filterRect);
    public RegionTextRenderFilter(Rectangle filterRect);
    public virtual bool AllowText(TextRenderInfo renderInfo);
}
public abstract class iTextSharp.text.pdf.parser.RenderFilter : object {
    public virtual bool AllowText(TextRenderInfo renderInfo);
    public virtual bool AllowImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy : object {
    private Vector lastStart;
    private Vector lastEnd;
    private StringBuilder result;
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual string GetResultantText();
    protected void AppendTextChunk(string text);
    protected void AppendTextChunk(char text);
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.Subpath : object {
    private Point2D startPoint;
    private IList`1<IShape> segments;
    private bool closed;
    public bool Closed { get; public set; }
    public Subpath(Subpath subpath);
    public Subpath(Point2D startPoint);
    public Subpath(float startPointX, float startPointY);
    public virtual void SetStartPoint(Point2D startPoint);
    public virtual void SetStartPoint(float x, float y);
    public virtual Point2D GetStartPoint();
    public Point2D GetLastPoint();
    public virtual void AddSegment(IShape segment);
    public virtual IList`1<IShape> GetSegments();
    public virtual bool IsEmpty();
    public virtual bool IsSinglePointOpen();
    public virtual bool IsSinglePointClosed();
    public virtual bool get_Closed();
    public virtual void set_Closed(bool value);
    public virtual bool IsDegenerate();
    public virtual IList`1<Point2D> GetPiecewiseLinearApproximation();
}
public class iTextSharp.text.pdf.parser.TaggedPdfReaderTool : object {
    protected internal PdfReader reader;
    protected internal StreamWriter outp;
    public virtual void ConvertToXml(PdfReader reader, Stream os, Encoding encoding);
    public virtual void ConvertToXml(PdfReader reader, Stream os);
    public virtual void InspectChild(PdfObject k);
    public virtual void InspectChildArray(PdfArray k);
    public virtual void InspectChildDictionary(PdfDictionary k);
    public virtual void InspectChildDictionary(PdfDictionary k, bool inspectAttributes);
    protected virtual string XmlName(PdfName name);
    private static string FixTagName(string tag);
    public virtual void ParseTag(string tag, PdfObject obj, PdfDictionary page);
}
public class iTextSharp.text.pdf.parser.TextMarginFinder : object {
    private RectangleJ textRectangle;
    public virtual void RenderText(TextRenderInfo renderInfo);
    public virtual float GetLlx();
    public virtual float GetLly();
    public virtual float GetUrx();
    public virtual float GetUry();
    public virtual float GetWidth();
    public virtual float GetHeight();
    public virtual void BeginTextBlock();
    public virtual void EndTextBlock();
    public virtual void RenderImage(ImageRenderInfo renderInfo);
}
public class iTextSharp.text.pdf.parser.TextRenderInfo : object {
    private PdfString string;
    private string text;
    private Matrix textToUserSpaceTransformMatrix;
    private GraphicsState gs;
    private Nullable`1<float> unscaledWidth;
    private Double[] fontMatrix;
    private static Encoding utf_16BeEncoding;
    private ICollection`1<MarkedContentInfo> markedContentInfos;
    public PdfString PdfString { get; }
    private Encoding Utf_16BeEncoding { get; }
    internal TextRenderInfo(PdfString string, GraphicsState gs, Matrix textMatrix, ICollection markedContentInfo);
    private TextRenderInfo(TextRenderInfo parent, PdfString string, float horizontalOffset);
    public virtual string GetText();
    public virtual PdfString get_PdfString();
    public virtual bool HasMcid(int mcid);
    public virtual bool HasMcid(int mcid, bool checkTheTopmostLevelOnly);
    public virtual Nullable`1<int> GetMcid();
    internal float GetUnscaledWidth();
    public virtual LineSegment GetBaseline();
    public virtual LineSegment GetUnscaledBaseline();
    public virtual LineSegment GetAscentLine();
    public virtual LineSegment GetDescentLine();
    private LineSegment GetUnscaledBaselineWithOffset(float yOffset);
    public virtual DocumentFont GetFont();
    public virtual float GetRise();
    private float ConvertWidthFromTextSpaceToUserSpace(float width);
    private float ConvertHeightFromTextSpaceToUserSpace(float height);
    public virtual float GetSingleSpaceWidth();
    public virtual int GetTextRenderMode();
    public virtual BaseColor GetFillColor();
    public virtual BaseColor GetStrokeColor();
    private float GetUnscaledFontSpaceWidth();
    private float GetStringWidth(string string);
    private float GetPdfStringWidth(PdfString string, bool singleCharString);
    public virtual IList`1<TextRenderInfo> GetCharacterRenderInfos();
    private Single[] GetWidthAndWordSpacing(PdfString string, bool singleCharString);
    private string Decode(PdfString in);
    private string DecodeSingleCharacter(PdfString in);
    private int GetCharCode(string string);
    private PdfString[] SplitString(PdfString string);
    private Encoding get_Utf_16BeEncoding();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.parser.Vector : object {
    public static int I1;
    public static int I2;
    public static int I3;
    private Single[] vals;
    public float Item { get; }
    public float Length { get; }
    public float LengthSquared { get; }
    public Vector(float x, float y, float z);
    public float get_Item(int index);
    public virtual Vector Cross(Matrix by);
    public virtual Vector Subtract(Vector v);
    public virtual Vector Cross(Vector with);
    public virtual Vector Normalize();
    public virtual Vector Multiply(float by);
    public virtual float Dot(Vector with);
    public virtual float get_Length();
    public virtual float get_LengthSquared();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PatternColor : ExtendedColor {
    private PdfPatternPainter painter;
    public PdfPatternPainter Painter { get; }
    public PatternColor(PdfPatternPainter painter);
    public virtual PdfPatternPainter get_Painter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfAcroForm : PdfDictionary {
    private PdfWriter writer;
    private Dictionary`2<PdfTemplate, object> fieldTemplates;
    private PdfArray documentFields;
    private PdfArray calculationOrder;
    private int sigFlags;
    unknown bool NeedAppearances {public set; }
    unknown int SigFlags {public set; }
    public PdfAcroForm(PdfWriter writer);
    public virtual void set_NeedAppearances(bool value);
    public virtual void AddFieldTemplates(Dictionary`2<PdfTemplate, object> ft);
    public virtual void AddDocumentField(PdfIndirectReference piref);
    public virtual bool IsValid();
    public virtual void AddCalculationOrder(PdfFormField formField);
    public virtual void set_SigFlags(int value);
    public virtual void AddFormField(PdfFormField formField);
    public virtual PdfFormField AddHtmlPostButton(string name, string caption, string value, string url, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddResetButton(string name, string caption, string value, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddMap(string name, string value, string url, PdfContentByte appearance, float llx, float lly, float urx, float ury);
    public virtual void SetButtonParams(PdfFormField button, int characteristics, string name, string value);
    public virtual void DrawButton(PdfFormField button, string caption, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddHiddenField(string name, string value);
    public virtual PdfFormField AddSingleLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddMultiLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSingleLinePasswordField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void SetTextFieldParams(PdfFormField field, string text, string name, float llx, float lly, float urx, float ury);
    public virtual void DrawSingleLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void DrawMultiLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddCheckBox(string name, string value, bool status, float llx, float lly, float urx, float ury);
    public virtual void SetCheckBoxParams(PdfFormField field, string name, string value, bool status, float llx, float lly, float urx, float ury);
    public virtual void DrawCheckBoxAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public virtual PdfFormField GetRadioGroup(string name, string defaultValue, bool noToggleToOff);
    public virtual void AddRadioGroup(PdfFormField radiogroup);
    public virtual PdfFormField AddRadioButton(PdfFormField radiogroup, string value, float llx, float lly, float urx, float ury);
    public virtual void DrawRadioAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSelectList(string name, String[] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSelectList(string name, String[0...,0...] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddComboBox(string name, String[] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddComboBox(string name, String[0...,0...] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public virtual void SetChoiceParams(PdfFormField field, string name, string defaultValue, float llx, float lly, float urx, float ury);
    public virtual PdfFormField AddSignature(string name, float llx, float lly, float urx, float ury);
    public virtual void SetSignatureParams(PdfFormField field, string name, float llx, float lly, float urx, float ury);
    public virtual void DrawSignatureAppearences(PdfFormField field, float llx, float lly, float urx, float ury);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfAction : PdfDictionary {
    public static int FIRSTPAGE;
    public static int PREVPAGE;
    public static int NEXTPAGE;
    public static int LASTPAGE;
    public static int PRINTDIALOG;
    public static int SUBMIT_EXCLUDE;
    public static int SUBMIT_INCLUDE_NO_VALUE_FIELDS;
    public static int SUBMIT_HTML_FORMAT;
    public static int SUBMIT_HTML_GET;
    public static int SUBMIT_COORDINATES;
    public static int SUBMIT_XFDF;
    public static int SUBMIT_INCLUDE_APPEND_SAVES;
    public static int SUBMIT_INCLUDE_ANNOTATIONS;
    public static int SUBMIT_PDF;
    public static int SUBMIT_CANONICAL_FORMAT;
    public static int SUBMIT_EXCL_NON_USER_ANNOTS;
    public static int SUBMIT_EXCL_F_KEY;
    public static int SUBMIT_EMBED_FORM;
    public static int RESET_EXCLUDE;
    public PdfAction(Uri url);
    public PdfAction(Uri url, bool isMap);
    public PdfAction(string url);
    public PdfAction(string url, bool isMap);
    internal PdfAction(PdfIndirectReference destination);
    public PdfAction(string filename, string name);
    public PdfAction(string filename, int page);
    public PdfAction(int named);
    public PdfAction(string application, string parameters, string operation, string defaultDir);
    public static PdfAction CreateLaunch(string application, string parameters, string operation, string defaultDir);
    public static PdfAction Rendition(string file, PdfFileSpecification fs, string mimeType, PdfIndirectReference refi);
    public static PdfAction JavaScript(string code, PdfWriter writer, bool unicode);
    public static PdfAction JavaScript(string code, PdfWriter writer);
    internal static PdfAction CreateHide(PdfObject obj, bool hide);
    public static PdfAction CreateHide(PdfAnnotation annot, bool hide);
    public static PdfAction CreateHide(string name, bool hide);
    internal static PdfArray BuildArray(Object[] names);
    public static PdfAction CreateHide(Object[] names, bool hide);
    public static PdfAction CreateSubmitForm(string file, Object[] names, int flags);
    public static PdfAction CreateResetForm(Object[] names, int flags);
    public static PdfAction CreateImportData(string file);
    public virtual void Next(PdfAction na);
    public static PdfAction GotoLocalPage(int page, PdfDestination dest, PdfWriter writer);
    public static PdfAction GotoLocalPage(string dest, bool isName);
    public static PdfAction GotoRemotePage(string filename, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, PdfObject dest, bool newWindow);
    public static PdfAction SetOCGstate(List`1<object> state, bool preserveRB);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfAnnotation : PdfDictionary {
    public static PdfName HIGHLIGHT_NONE;
    public static PdfName HIGHLIGHT_INVERT;
    public static PdfName HIGHLIGHT_OUTLINE;
    public static PdfName HIGHLIGHT_PUSH;
    public static PdfName HIGHLIGHT_TOGGLE;
    public static int FLAGS_INVISIBLE;
    public static int FLAGS_HIDDEN;
    public static int FLAGS_PRINT;
    public static int FLAGS_NOZOOM;
    public static int FLAGS_NOROTATE;
    public static int FLAGS_NOVIEW;
    public static int FLAGS_READONLY;
    public static int FLAGS_LOCKED;
    public static int FLAGS_TOGGLENOVIEW;
    public static int FLAGS_LOCKEDCONTENTS;
    public static PdfName APPEARANCE_NORMAL;
    public static PdfName APPEARANCE_ROLLOVER;
    public static PdfName APPEARANCE_DOWN;
    public static PdfName AA_ENTER;
    public static PdfName AA_EXIT;
    public static PdfName AA_DOWN;
    public static PdfName AA_UP;
    public static PdfName AA_FOCUS;
    public static PdfName AA_BLUR;
    public static PdfName AA_JS_KEY;
    public static PdfName AA_JS_FORMAT;
    public static PdfName AA_JS_CHANGE;
    public static PdfName AA_JS_OTHER_CHANGE;
    public static int MARKUP_HIGHLIGHT;
    public static int MARKUP_UNDERLINE;
    public static int MARKUP_STRIKEOUT;
    public static int MARKUP_SQUIGGLY;
    protected internal PdfWriter writer;
    protected internal PdfIndirectReference reference;
    protected internal HashSet2`1<PdfTemplate> templates;
    protected internal bool form;
    protected internal bool annotation;
    protected internal bool used;
    private int placeInPage;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public PdfIndirectReference IndirectReference { get; }
    unknown PdfContentByte DefaultAppearanceString {public set; }
    unknown int Flags {public set; }
    unknown PdfBorderArray Border {public set; }
    unknown PdfBorderDictionary BorderStyle {public set; }
    unknown string AppearanceState {public set; }
    unknown BaseColor Color {public set; }
    unknown string Title {public set; }
    unknown PdfAnnotation Popup {public set; }
    unknown PdfAction Action {public set; }
    [ObsoleteAttribute("Use GetTemplates() instead")]
public Dictionary`2<PdfTemplate, object> Templates { get; }
    unknown int Page {public set; }
    public int PlaceInPage { get; public set; }
    unknown int Rotate {public set; }
    internal PdfDictionary MK { get; }
    unknown int MKRotation {public set; }
    unknown BaseColor MKBorderColor {public set; }
    unknown BaseColor MKBackgroundColor {public set; }
    unknown string MKNormalCaption {public set; }
    unknown string MKRolloverCaption {public set; }
    unknown string MKAlternateCaption {public set; }
    unknown PdfTemplate MKNormalIcon {public set; }
    unknown PdfTemplate MKRolloverIcon {public set; }
    unknown PdfTemplate MKAlternateIcon {public set; }
    unknown int MKTextPosition {public set; }
    unknown IPdfOCG Layer {public set; }
    unknown string Name {public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfAnnotation(PdfWriter writer, Rectangle rect);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfString title, PdfString content);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    private static PdfAnnotation();
    public static PdfAnnotation CreateScreen(PdfWriter writer, Rectangle rect, string clipTitle, PdfFileSpecification fs, string mimeType, bool playOnDisplay);
    public virtual PdfIndirectReference get_IndirectReference();
    public static PdfAnnotation CreateText(PdfWriter writer, Rectangle rect, string title, string contents, bool open, string icon);
    protected static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, PdfAction action);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, string namedDestination);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, int page, PdfDestination dest);
    public static PdfAnnotation CreateFreeText(PdfWriter writer, Rectangle rect, string contents, PdfContentByte defaultAppearance);
    public static PdfAnnotation CreateLine(PdfWriter writer, Rectangle rect, string contents, float x1, float y1, float x2, float y2);
    public static PdfAnnotation CreateSquareCircle(PdfWriter writer, Rectangle rect, string contents, bool square);
    public static PdfAnnotation CreateMarkup(PdfWriter writer, Rectangle rect, string contents, int type, Single[] quadPoints);
    public static PdfAnnotation CreateStamp(PdfWriter writer, Rectangle rect, string contents, string name);
    public static PdfAnnotation CreateInk(PdfWriter writer, Rectangle rect, string contents, Single[][] inkList);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, Byte[] fileStore, string file, string fileDisplay);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, PdfFileSpecification fs);
    public static PdfAnnotation CreatePopup(PdfWriter writer, Rectangle rect, string contents, bool open);
    public static PdfAnnotation CreatePolygonPolyline(PdfWriter writer, Rectangle rect, string contents, bool polygon, PdfArray vertices);
    public virtual void set_DefaultAppearanceString(PdfContentByte value);
    public virtual void set_Flags(int value);
    public virtual void set_Border(PdfBorderArray value);
    public virtual void set_BorderStyle(PdfBorderDictionary value);
    public virtual void SetHighlighting(PdfName highlight);
    public virtual void SetAppearance(PdfName ap, PdfTemplate template);
    public virtual void SetAppearance(PdfName ap, string state, PdfTemplate template);
    public virtual void set_AppearanceState(string value);
    public virtual void set_Color(BaseColor value);
    public virtual void set_Title(string value);
    public virtual void set_Popup(PdfAnnotation value);
    public virtual void set_Action(PdfAction value);
    public virtual void SetAdditionalActions(PdfName key, PdfAction action);
    internal virtual bool IsUsed();
    public virtual void SetUsed();
    public virtual Dictionary`2<PdfTemplate, object> get_Templates();
    public virtual HashSet2`1<PdfTemplate> GetTemplates();
    public virtual bool IsForm();
    public virtual bool IsAnnotation();
    public virtual void set_Page(int value);
    public virtual void SetPage();
    public virtual int get_PlaceInPage();
    public virtual void set_PlaceInPage(int value);
    public static PdfAnnotation ShallowDuplicate(PdfAnnotation annot);
    public virtual void set_Rotate(int value);
    internal PdfDictionary get_MK();
    public virtual void set_MKRotation(int value);
    public static PdfArray GetMKColor(BaseColor color);
    public virtual void set_MKBorderColor(BaseColor value);
    public virtual void set_MKBackgroundColor(BaseColor value);
    public virtual void set_MKNormalCaption(string value);
    public virtual void set_MKRolloverCaption(string value);
    public virtual void set_MKAlternateCaption(string value);
    public virtual void set_MKNormalIcon(PdfTemplate value);
    public virtual void set_MKRolloverIcon(PdfTemplate value);
    public virtual void set_MKAlternateIcon(PdfTemplate value);
    public virtual void SetMKIconFit(PdfName scale, PdfName scalingType, float leftoverLeft, float leftoverBottom, bool fitInBounds);
    public virtual void set_MKTextPosition(int value);
    public virtual void set_Layer(IPdfOCG value);
    public virtual void set_Name(string value);
    public virtual void ApplyCTM(AffineTransform ctm);
    [ObsoleteAttribute]
public void ApplyCTM(Matrix ctm);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfAppearance : PdfTemplate {
    public static Dictionary`2<string, PdfName> stdFieldFontNames;
    public PdfContentByte Duplicate { get; }
    private static PdfAppearance();
    internal PdfAppearance(PdfIndirectReference iref);
    internal PdfAppearance(PdfWriter wr);
    public static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height);
    internal static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height, PdfName forcedName);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual PdfContentByte get_Duplicate();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.PdfArray : PdfObject {
    protected List`1<PdfObject> arrayList;
    public PdfObject Item { get; public set; }
    public List`1<PdfObject> ArrayList { get; }
    public int Size { get; }
    public PdfArray(int capcity);
    public PdfArray(PdfObject obj);
    public PdfArray(Single[] values);
    public PdfArray(Int32[] values);
    public PdfArray(IList`1<PdfObject> l);
    public PdfArray(PdfArray array);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public PdfObject get_Item(int idx);
    public void set_Item(int idx, PdfObject value);
    public virtual PdfObject GetPdfObject(int idx);
    public virtual PdfObject Set(int idx, PdfObject obj);
    public virtual PdfObject Remove(int idx);
    public virtual List`1<PdfObject> get_ArrayList();
    public virtual int get_Size();
    public virtual bool IsEmpty();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void Add(int index, PdfObject element);
    public virtual void AddFirst(PdfObject obj);
    public virtual bool Contains(PdfObject obj);
    public virtual ListIterator`1<PdfObject> GetListIterator();
    public virtual string ToString();
    public virtual PdfObject GetDirectObject(int idx);
    public virtual PdfDictionary GetAsDict(int idx);
    public virtual PdfArray GetAsArray(int idx);
    public virtual PdfStream GetAsStream(int idx);
    public virtual PdfString GetAsString(int idx);
    public virtual PdfNumber GetAsNumber(int idx);
    public virtual PdfName GetAsName(int idx);
    public virtual PdfBoolean GetAsBoolean(int idx);
    public virtual PdfIndirectReference GetAsIndirectObject(int idx);
    public virtual IEnumerator`1<PdfObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Int64[] AsLongArray();
    public Double[] AsDoubleArray();
}
public class iTextSharp.text.pdf.PdfArtifact : object {
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private static HashSet2`1<string> allowedArtifactTypes;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfString Type { get; public set; }
    public PdfArray BBox { get; public set; }
    public PdfArray Attached { get; public set; }
    private static PdfArtifact();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual PdfString get_Type();
    public virtual void set_Type(PdfString value);
    public virtual void SetType(ArtifactType type);
    public virtual PdfArray get_BBox();
    public virtual void set_BBox(PdfArray value);
    public virtual PdfArray get_Attached();
    public virtual void set_Attached(PdfArray value);
}
public class iTextSharp.text.pdf.PdfBody : Rectangle {
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public PdfBody(Rectangle rectangle);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
}
public class iTextSharp.text.pdf.PdfBoolean : PdfObject {
    public static PdfBoolean PDFTRUE;
    public static PdfBoolean PDFFALSE;
    public static string TRUE;
    public static string FALSE;
    private bool value;
    public bool BooleanValue { get; }
    public PdfBoolean(bool value);
    public PdfBoolean(string value);
    private static PdfBoolean();
    public virtual bool get_BooleanValue();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfBorderArray : PdfArray {
    public PdfBorderArray(float hRadius, float vRadius, float width);
    public PdfBorderArray(float hRadius, float vRadius, float width, PdfDashPattern dash);
}
public class iTextSharp.text.pdf.PdfBorderDictionary : PdfDictionary {
    public static int STYLE_SOLID;
    public static int STYLE_DASHED;
    public static int STYLE_BEVELED;
    public static int STYLE_INSET;
    public static int STYLE_UNDERLINE;
    public PdfBorderDictionary(float borderWidth, int borderStyle, PdfDashPattern dashes);
    public PdfBorderDictionary(float borderWidth, int borderStyle);
}
public class iTextSharp.text.pdf.PdfChunk : object {
    private static Char[] singleSpace;
    private static float ITALIC_ANGLE;
    private static Dictionary`2<string, object> keysAttributes;
    private static Dictionary`2<string, object> keysNoStroke;
    private static string TABSTOP;
    protected string value;
    protected string encoding;
    protected PdfFont font;
    protected BaseFont baseFont;
    protected ISplitCharacter splitCharacter;
    protected Dictionary`2<string, object> attributes;
    protected Dictionary`2<string, object> noStroke;
    protected bool newlineSplit;
    protected Image image;
    protected float imageScalePercentage;
    protected float offsetX;
    protected float offsetY;
    protected bool changeLeading;
    protected float leading;
    internal IAccessibleElement accessibleElement;
    public static float UNDERLINE_THICKNESS;
    public static float UNDERLINE_OFFSET;
    internal PdfFont Font { get; }
    internal BaseColor Color { get; }
    public float TextRise { get; }
    internal TabStop TabStop { get; internal set; }
    internal Image Image { get; }
    internal float ImageHeight { get; }
    internal float ImageWidth { get; }
    public float ImageScalePercentage { get; public set; }
    internal float ImageOffsetX { get; internal set; }
    internal float ImageOffsetY { get; internal set; }
    unknown string Value {internal set; }
    internal string Encoding { get; }
    internal int Length { get; }
    internal int LengthUtf32 { get; }
    public bool ChangeLeading { get; }
    public float Leading { get; }
    private static PdfChunk();
    internal PdfChunk(string str, PdfChunk other);
    internal PdfChunk(Chunk chunk, PdfAction action);
    internal PdfChunk(Chunk chunk, PdfAction action, TabSettings tabSettings);
    public virtual int GetUnicodeEquivalent(int c);
    protected virtual int GetWord(string text, int start);
    internal PdfChunk Split(float width);
    internal PdfChunk Truncate(float width);
    internal PdfFont get_Font();
    internal BaseColor get_Color();
    internal float Width();
    internal float Width(string str);
    internal float Height();
    public virtual bool IsNewlineSplit();
    public virtual float GetWidthCorrected(float charSpacing, float wordSpacing);
    public virtual float get_TextRise();
    public virtual float TrimLastSpace();
    public virtual float TrimFirstSpace();
    internal object GetAttribute(string name);
    internal bool IsAttribute(string name);
    internal bool IsStroked();
    internal bool IsSeparator();
    internal bool IsHorizontalSeparator();
    internal bool IsTab();
    [ObsoleteAttribute]
internal void AdjustLeft(float newValue);
    internal static TabStop GetTabStop(PdfChunk tab, float tabPosition);
    internal TabStop get_TabStop();
    internal void set_TabStop(TabStop value);
    internal bool IsImage();
    internal Image get_Image();
    internal float get_ImageHeight();
    internal float get_ImageWidth();
    public virtual float get_ImageScalePercentage();
    public virtual void set_ImageScalePercentage(float value);
    internal float get_ImageOffsetX();
    internal void set_ImageOffsetX(float value);
    internal float get_ImageOffsetY();
    internal void set_ImageOffsetY(float value);
    internal void set_Value(string value);
    public virtual string ToString();
    internal bool IsSpecialEncoding();
    internal string get_Encoding();
    internal int get_Length();
    internal int get_LengthUtf32();
    internal bool IsExtSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    internal string Trim(string str);
    public virtual bool get_ChangeLeading();
    public virtual float get_Leading();
    internal float GetCharWidth(int c);
    public static bool NoPrint(int c);
}
internal class iTextSharp.text.pdf.PdfColor : PdfArray {
    internal PdfColor(int red, int green, int blue);
    internal PdfColor(BaseColor color);
}
public class iTextSharp.text.pdf.PdfConcatenate : object {
    protected internal Document document;
    protected internal PdfCopy copy;
    public PdfCopy Writer { get; }
    public PdfConcatenate(Stream os);
    public PdfConcatenate(Stream os, bool smart);
    public virtual int AddPages(PdfReader reader);
    public virtual PdfCopy get_Writer();
    public virtual void Open();
    public virtual void Close();
}
public class iTextSharp.text.pdf.PdfContentByte : object {
    public static int ALIGN_CENTER;
    public static int ALIGN_LEFT;
    public static int ALIGN_RIGHT;
    public static int LINE_CAP_BUTT;
    public static int LINE_CAP_ROUND;
    public static int LINE_CAP_PROJECTING_SQUARE;
    public static int LINE_JOIN_MITER;
    public static int LINE_JOIN_ROUND;
    public static int LINE_JOIN_BEVEL;
    public static int TEXT_RENDER_MODE_FILL;
    public static int TEXT_RENDER_MODE_STROKE;
    public static int TEXT_RENDER_MODE_FILL_STROKE;
    public static int TEXT_RENDER_MODE_INVISIBLE;
    public static int TEXT_RENDER_MODE_FILL_CLIP;
    public static int TEXT_RENDER_MODE_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_FILL_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_CLIP;
    private static Single[] unitRect;
    protected ByteBuffer content;
    protected int markedContentSize;
    protected internal PdfWriter writer;
    protected internal PdfDocument pdf;
    protected GraphicState state;
    protected List`1<int> layerDepth;
    protected List`1<GraphicState> stateList;
    protected int separator;
    private bool suppressTagging;
    private int mcDepth;
    private bool inText;
    private IList`1<IAccessibleElement> mcElements;
    protected internal PdfContentByte duplicatedFrom;
    private static Dictionary`2<PdfName, string> abrev;
    public bool SuppressTagging { get; public set; }
    public ByteBuffer InternalBuffer { get; }
    public float XTLM { get; }
    public float YTLM { get; }
    public float CharacterSpacing { get; }
    public float WordSpacing { get; }
    public float HorizontalScaling { get; }
    public float Leading { get; }
    internal int Size { get; }
    public PdfOutline RootOutline { get; }
    public PdfWriter PdfWriter { get; }
    public PdfDocument PdfDocument { get; }
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    protected PdfIndirectReference CurrentPage { get; }
    protected internal bool InText { get; }
    private static PdfContentByte();
    public PdfContentByte(PdfWriter wr);
    public virtual string ToString();
    public bool get_SuppressTagging();
    public void set_SuppressTagging(bool value);
    public virtual bool IsTagged();
    public virtual ByteBuffer get_InternalBuffer();
    public virtual Byte[] ToPdf(PdfWriter writer);
    public virtual void Add(PdfContentByte other);
    public virtual float get_XTLM();
    public virtual float get_YTLM();
    public virtual float get_CharacterSpacing();
    public virtual float get_WordSpacing();
    public virtual float get_HorizontalScaling();
    public virtual float get_Leading();
    public virtual void SetLeading(float v);
    public virtual void SetFlatness(float value);
    public virtual void SetFlatness(double value);
    public virtual void SetLineCap(int value);
    public virtual void SetRenderingIntent(PdfName ri);
    public virtual void SetLineDash(float value);
    public virtual void SetLineDash(double value);
    public virtual void SetLineDash(float unitsOn, float phase);
    public virtual void SetLineDash(double unitsOn, double phase);
    public virtual void SetLineDash(float unitsOn, float unitsOff, float phase);
    public virtual void SetLineDash(double unitsOn, double unitsOff, double phase);
    public void SetLineDash(Single[] array, float phase);
    public void SetLineDash(Double[] array, double phase);
    public virtual void SetLineJoin(int value);
    public virtual void SetLineWidth(float value);
    public virtual void SetLineWidth(double value);
    public virtual void SetMiterLimit(float value);
    public virtual void SetMiterLimit(double value);
    public virtual void Clip();
    public virtual void EoClip();
    public virtual void SetGrayFill(float value);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float value);
    public virtual void ResetGrayStroke();
    private void HelperRGB(float red, float green, float blue);
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    private void HelperCMYK(float cyan, float magenta, float yellow, float black);
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public virtual void MoveTo(float x, float y);
    public virtual void MoveTo(double x, double y);
    public virtual void LineTo(float x, float y);
    public virtual void LineTo(double x, double y);
    public virtual void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public virtual void CurveTo(double x1, double y1, double x2, double y2, double x3, double y3);
    public virtual void CurveTo(float x2, float y2, float x3, float y3);
    public virtual void CurveTo(double x2, double y2, double x3, double y3);
    public virtual void CurveFromTo(float x1, float y1, float x3, float y3);
    public virtual void CurveFromTo(double x1, double y1, double x3, double y3);
    public virtual void Circle(float x, float y, float r);
    public virtual void Circle(double x, double y, double r);
    public virtual void Rectangle(float x, float y, float w, float h);
    public virtual void Rectangle(double x, double y, double w, double h);
    private bool CompareColors(BaseColor c1, BaseColor c2);
    public virtual void VariableRectangle(Rectangle rect);
    public virtual void Rectangle(Rectangle rectangle);
    public virtual void ClosePath();
    public virtual void NewPath();
    public virtual void Stroke();
    public virtual void ClosePathStroke();
    public virtual void Fill();
    public virtual void EoFill();
    public virtual void FillStroke();
    public virtual void ClosePathFillStroke();
    public virtual void EoFillStroke();
    public virtual void ClosePathEoFillStroke();
    public virtual void AddImage(Image image);
    public virtual void AddImage(Image image, bool inlineImage);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddImage(Image image, double a, double b, double c, double d, double e, double f);
    public virtual void AddImage(Image image, AffineTransform transform);
    [ObsoleteAttribute]
public void AddImage(Image image, Matrix transform);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public virtual void AddImage(Image image, double a, double b, double c, double d, double e, double f, bool inlineImage);
    protected internal void AddImage(Image image, double a, double b, double c, double d, double e, double f, bool inlineImage, bool isMCBlockOpened);
    public virtual void Reset();
    public virtual void Reset(bool validateContent);
    protected internal virtual void BeginText(bool restoreTM);
    public virtual void BeginText();
    public virtual void EndText();
    public virtual void SaveState();
    public virtual void RestoreState();
    public virtual void SetCharacterSpacing(float value);
    public virtual void SetWordSpacing(float value);
    public virtual void SetHorizontalScaling(float value);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void SetTextRenderingMode(int value);
    public virtual void SetTextRise(float value);
    public virtual void SetTextRise(double value);
    private void ShowText2(string text);
    public virtual void ShowText(string text);
    public virtual void ShowTextGid(string gids);
    public static PdfTextArray GetKernArray(string text, BaseFont font);
    public virtual void ShowTextKerned(string text);
    public virtual void NewlineShowText(string text);
    public virtual void NewlineShowText(float wordSpacing, float charSpacing, string text);
    public virtual void SetTextMatrix(float a, float b, float c, float d, float x, float y);
    public virtual void SetTextMatrix(AffineTransform transform);
    [ObsoleteAttribute]
public void SetTextMatrix(Matrix transform);
    public virtual void SetTextMatrix(float x, float y);
    public virtual void MoveText(float x, float y);
    public virtual void MoveTextWithLeading(float x, float y);
    public virtual void NewlineText();
    internal int get_Size();
    internal int GetSize(bool includeMarkedContentSize);
    public virtual void AddOutline(PdfOutline outline, string name);
    public virtual PdfOutline get_RootOutline();
    public virtual float GetEffectiveStringWidth(string text, bool kerned);
    private float GetEffectiveStringWidth(string text, bool kerned, float kerning);
    public virtual void ShowTextAligned(int alignment, string text, float x, float y, float rotation);
    private void ShowTextAligned(int alignment, string text, float x, float y, float rotation, bool kerned);
    public virtual void ShowTextAlignedKerned(int alignment, string text, float x, float y, float rotation);
    public virtual void ConcatCTM(float a, float b, float c, float d, float e, float f);
    public virtual void ConcatCTM(double a, double b, double c, double d, double e, double f);
    public virtual void ConcatCTM(AffineTransform transform);
    [ObsoleteAttribute]
public void ConcatCTM(Matrix transform);
    public static List`1<Double[]> BezierArc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public static List`1<Double[]> BezierArc(double x1, double y1, double x2, double y2, double startAng, double extent);
    public virtual void Arc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public virtual void Arc(double x1, double y1, double x2, double y2, double startAng, double extent);
    public virtual void Ellipse(double x1, double y1, double x2, double y2);
    public virtual void Ellipse(float x1, float y1, float x2, float y2);
    public virtual PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep);
    public virtual PdfPatternPainter CreatePattern(float width, float height);
    public virtual PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep, BaseColor color);
    public virtual PdfPatternPainter CreatePattern(float width, float height, BaseColor color);
    public virtual PdfTemplate CreateTemplate(float width, float height);
    internal PdfTemplate CreateTemplate(float width, float height, PdfName forcedName);
    public virtual PdfAppearance CreateAppearance(float width, float height);
    internal PdfAppearance CreateAppearance(float width, float height, PdfName forcedName);
    public virtual void AddPSXObject(PdfPSXObject psobject);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double a, double b, double c, double d, double e, double f, bool tagTemplate, bool tagContent);
    public virtual PdfName AddFormXObj(PdfStream formXObj, PdfName name, float a, float b, float c, float d, float e, float f);
    public virtual PdfName AddFormXObj(PdfStream formXObj, PdfName name, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, AffineTransform transform);
    public virtual void AddTemplate(PdfTemplate template, AffineTransform transform, bool tagContent);
    [ObsoleteAttribute]
public void AddTemplate(PdfTemplate template, Matrix transform, bool tagContent);
    [ObsoleteAttribute]
public void AddTemplate(PdfTemplate template, Matrix transform);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, float a, float b, float c, float d, float e, float f);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, double a, double b, double c, double d, double e, double f);
    public virtual void AddTemplate(PdfTemplate template, float x, float y);
    public virtual void AddTemplate(PdfTemplate template, double x, double y);
    public virtual void AddTemplate(PdfTemplate template, float x, float y, bool tagContent);
    public virtual void AddTemplate(PdfTemplate template, double x, double y, bool tagContent);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(BaseColor value);
    public virtual void SetColorFill(BaseColor value);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorFill(PdfDeviceNColor dn, Single[] tints);
    public virtual void SetColorFill(PdfLabColor lab, float l, float a, float b);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfDeviceNColor sp, Single[] tints);
    public virtual void SetColorStroke(PdfLabColor lab, float l, float a, float b);
    public virtual void SetPatternFill(PdfPatternPainter p);
    internal void OutputColorNumbers(BaseColor color, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    public virtual void PaintShading(PdfShading shading);
    public virtual void PaintShading(PdfShadingPattern shading);
    public virtual void SetShadingFill(PdfShadingPattern shading);
    public virtual void SetShadingStroke(PdfShadingPattern shading);
    protected virtual void CheckWriter();
    public virtual void ShowText(PdfTextArray text);
    public virtual PdfWriter get_PdfWriter();
    public virtual PdfDocument get_PdfDocument();
    public virtual void LocalGoto(string name, float llx, float lly, float urx, float ury);
    public virtual bool LocalDestination(string name, PdfDestination destination);
    public virtual PdfContentByte get_Duplicate();
    public virtual PdfContentByte GetDuplicate(bool inheritGraphicState);
    public virtual void InheritGraphicState(PdfContentByte parentCanvas);
    public virtual void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    public virtual void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    public virtual void RoundRectangle(float x, float y, float w, float h, float r);
    public virtual void RoundRectangle(double x, double y, double w, double h, double r);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public virtual void SetLiteral(string s);
    public virtual void SetLiteral(char c);
    public virtual void SetLiteral(float n);
    internal void CheckNoPattern(PdfTemplate t);
    public virtual void DrawRadioField(float llx, float lly, float urx, float ury, bool on);
    public virtual void DrawRadioField(double llx, double lly, double urx, double ury, bool on);
    public virtual void DrawTextField(float llx, float lly, float urx, float ury);
    public virtual void DrawTextField(double llx, double lly, double urx, double ury);
    public virtual void DrawButton(float llx, float lly, float urx, float ury, string text, BaseFont bf, float size);
    public virtual void DrawButton(double llx, double lly, double urx, double ury, string text, BaseFont bf, float size);
    internal virtual PageResources get_PageResources();
    public virtual void SetGState(PdfGState gstate);
    public virtual void BeginLayer(IPdfOCG layer);
    private void BeginLayer2(IPdfOCG layer);
    public virtual void EndLayer();
    internal virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void AddAnnotation(PdfAnnotation annot, bool applyCTM);
    public virtual void SetDefaultColorspace(PdfName name, PdfObject obj);
    public virtual void Transform(AffineTransform af);
    [ObsoleteAttribute]
public void Transform(Matrix tx);
    public virtual void BeginMarkedContentSequence(PdfStructureElement struc);
    public virtual void BeginMarkedContentSequence(PdfStructureElement struc, string expansion);
    protected virtual PdfIndirectReference get_CurrentPage();
    public virtual void EndMarkedContentSequence();
    public virtual void BeginMarkedContentSequence(PdfName tag, PdfDictionary property, bool inline);
    public virtual void BeginMarkedContentSequence(PdfName tag);
    public virtual void SanityCheck();
    public virtual void OpenMCBlock(IAccessibleElement element);
    private PdfDictionary GetParentStructureElement();
    private PdfStructureElement OpenMCBlockInt(IAccessibleElement element);
    public virtual void CloseMCBlock(IAccessibleElement element);
    private void CloseMCBlockInt(IAccessibleElement element);
    private void EnsureDocumentTagIsOpen();
    internal IList`1<IAccessibleElement> SaveMCBlocks();
    internal void RestoreMCBlocks(IList`1<IAccessibleElement> mcElements);
    internal int GetMcDepth();
    internal void SetMcDepth(int value);
    internal IList`1<IAccessibleElement> GetMcElements();
    internal void SetMcElements(IList`1<IAccessibleElement> value);
    internal void UpdateTx(string text, float Tj);
    private void SaveColor(BaseColor color, bool fill);
    protected internal virtual bool get_InText();
    protected virtual void CheckState();
}
public class iTextSharp.text.pdf.PdfContentParser : object {
    public static int COMMAND_TYPE;
    private PRTokeniser tokeniser;
    public PRTokeniser Tokeniser { get; public set; }
    public PdfContentParser(PRTokeniser tokeniser);
    public virtual List`1<PdfObject> Parse(List`1<PdfObject> ls);
    public virtual PRTokeniser GetTokeniser();
    public virtual void set_Tokeniser(PRTokeniser value);
    public virtual PRTokeniser get_Tokeniser();
    public virtual PdfDictionary ReadDictionary();
    public virtual PdfArray ReadArray();
    public virtual PdfObject ReadPRObject();
    public virtual bool NextValidToken();
}
public class iTextSharp.text.pdf.PdfContents : PdfStream {
    internal static Byte[] SAVESTATE;
    internal static Byte[] RESTORESTATE;
    internal static Byte[] ROTATE90;
    internal static Byte[] ROTATE180;
    internal static Byte[] ROTATE270;
    internal static Byte[] ROTATEFINAL;
    internal PdfContents(PdfContentByte under, PdfContentByte content, PdfContentByte text, PdfContentByte secondContent, Rectangle page);
    private static PdfContents();
}
public class iTextSharp.text.pdf.PdfCopy : PdfWriter {
    private static ILogger LOGGER;
    protected static ICounter COUNTER;
    protected internal Dictionary`2<RefKey, IndirectReferences> indirects;
    protected Dictionary`2<PdfReader, Dictionary`2<RefKey, IndirectReferences>> indirectMap;
    protected Dictionary`2<PdfObject, PdfObject> parentObjects;
    protected HashSet2`1<PdfObject> disableIndirects;
    protected PdfReader reader;
    protected Int32[] namePtr;
    private bool rotateContents;
    protected internal PdfArray fieldArray;
    protected internal HashSet2`1<PdfTemplate> fieldTemplates;
    private PdfStructTreeController structTreeController;
    private int currentStructArrayNumber;
    protected PRIndirectReference structTreeRootReference;
    protected Dictionary`2<RefKey, PdfIndirectObject> indirectObjects;
    protected List`1<PdfIndirectObject> savedObjects;
    protected List`1<ImportedPage> importedPages;
    internal bool updateRootKids;
    private static PdfName annotId;
    private static int annotIdCnt;
    protected bool mergeFields;
    private bool needAppearances;
    private bool hasSignature;
    private PdfIndirectReference acroForm;
    private Dictionary`2<PdfArray, List`1<int>> tabOrder;
    private List`1<object> calculationOrderRefs;
    private PdfDictionary resources;
    protected List`1<AcroFields> fields;
    private List`1<string> calculationOrder;
    private Dictionary`2<string, object> fieldTree;
    private Dictionary`2<int, PdfIndirectObject> unmergedMap;
    private Dictionary`2<RefKey, PdfIndirectObject> unmergedIndirectRefsMap;
    private Dictionary`2<int, PdfIndirectObject> mergedMap;
    private HashSet2`1<PdfIndirectObject> mergedSet;
    private bool mergeFieldsInternalCall;
    private static PdfName iTextTag;
    internal static int zero;
    private HashSet2`1<object> mergedRadioButtons;
    private Dictionary`2<object, PdfString> mergedTextFields;
    private HashSet2`1<PdfReader> readersWithImportedStructureTreeRootKids;
    protected static HashSet2`1<PdfName> widgetKeys;
    protected static HashSet2`1<PdfName> fieldKeys;
    unknown IPdfPageEvent PageEvent {public set; }
    public bool RotateContents { get; public set; }
    public PdfCopy(Document document, Stream os);
    private static PdfCopy();
    protected virtual ICounter GetCounter();
    public virtual void set_PageEvent(IPdfPageEvent value);
    public virtual void set_RotateContents(bool value);
    public virtual bool get_RotateContents();
    public virtual void SetMergeFields();
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber, bool keepTaggedPdfStructure);
    private void ClearIndirects(PdfReader reader);
    private int CheckStructureTreeRootKids(ImportedPage newPage);
    protected internal virtual void StructureTreeRootKidsForReaderImported(PdfReader reader);
    internal virtual void FixStructureTreeRoot(HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    protected virtual PdfImportedPage GetImportedPageImpl(PdfReader reader, int pageNumber);
    protected internal virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp, bool keepStructure, bool directRootKids);
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
    protected virtual PdfDictionary CopyDictionary(PdfDictionary inp, bool keepStruct, bool directRootKids);
    protected virtual PdfDictionary CopyDictionary(PdfDictionary inp);
    protected virtual PdfStream CopyStream(PRStream inp);
    protected virtual PdfArray CopyArray(PdfArray inp, bool keepStruct, bool directRootKids);
    protected virtual PdfArray CopyArray(PdfArray inp);
    protected internal virtual PdfObject CopyObject(PdfObject inp, bool keepStruct, bool directRootKids);
    protected internal virtual PdfObject CopyObject(PdfObject inp);
    protected virtual int SetFromIPage(PdfImportedPage iPage);
    protected virtual void SetFromReader(PdfReader reader);
    public virtual void AddPage(PdfImportedPage iPage);
    public virtual void AddPage(Rectangle rect, int rotation);
    public virtual void AddDocument(PdfReader reader, List`1<int> pagesToKeep);
    public virtual void CopyDocumentFields(PdfReader reader);
    public virtual void AddDocument(PdfReader reader);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool formBranching);
    protected internal virtual void CacheObject(PdfIndirectObject iobj);
    internal virtual void FlushTaggedObjects();
    internal virtual void FlushAcroFields();
    protected virtual void FixTaggedStructure();
    private void RemoveInactiveReferences(PdfArray array, HashSet2`1<RefKey> activeKeys);
    private bool ContainsInactivePg(PdfDictionary dict, HashSet2`1<RefKey> activeKeys);
    private List`1<PdfIndirectReference> FindActiveParents(HashSet2`1<RefKey> activeKeys);
    private void FixPgKey(List`1<PdfIndirectReference> newRefs, HashSet2`1<RefKey> activeKeys);
    private void FindActives(List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    private void FindActivesFromReference(PdfIndirectReference iref, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys);
    private void FindActivesFromArray(PdfArray array, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    private void FindActivesFromDict(PdfDictionary dict, List`1<PdfIndirectReference> actives, HashSet2`1<RefKey> activeKeys, HashSet2`1<PdfName> activeClassMaps);
    protected virtual void FlushIndirectObjects();
    private void WriteObjectToBody(PdfIndirectObject objecta);
    private void UpdateAnnotationReferences(PdfObject obj);
    private void UpdateCalculationOrder(PdfReader reader);
    private static string GetCOName(PdfReader reader, PRIndirectReference refa);
    private void MergeFields();
    private void AddPageOffsetToField(IDictionary`2<string, Item> fd, int pageOffset);
    private void MergeWithMaster(IDictionary`2<string, Item> fd);
    internal void MergeField(string name, Item item);
    private void CreateWidgets(List`1<object> list, Item item);
    private PdfObject Propagate(PdfObject obj);
    private void CreateAcroForms();
    private void UpdateReferences(PdfObject obj);
    private PdfArray BranchForm(Dictionary`2<string, object> level, PdfIndirectReference parent, string fname);
    private void AdjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual bool IsStructTreeRootReference(PdfIndirectReference prRef);
    private void AddFieldResources(PdfDictionary catalog);
    public virtual void Close();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public virtual void FreeReader(PdfReader reader);
    protected virtual PdfName GetOffStateName(PdfDictionary widget);
    internal static Nullable`1<int> GetFlags(PdfDictionary field);
    internal static bool IsCheckButton(PdfDictionary field);
    internal static bool IsRadioButton(PdfDictionary field);
    internal static bool IsTextField(PdfDictionary field);
    public virtual PageStamp CreatePageStamp(PdfImportedPage iPage);
}
[ObsoleteAttribute]
public class iTextSharp.text.pdf.PdfCopyFields : object {
    private PdfCopyFieldsImp fc;
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyFields(Stream os);
    public PdfCopyFields(Stream os, char pdfVersion);
    public virtual void AddDocument(PdfReader reader);
    public virtual void AddDocument(PdfReader reader, IList`1<int> pagesToKeep);
    public virtual void AddDocument(PdfReader reader, string ranges);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void Close();
    public virtual void Open();
    public virtual void AddJavaScript(string js);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual PdfWriter get_Writer();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_ViewerPreferences(int value);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
[ObsoleteAttribute]
internal class iTextSharp.text.pdf.PdfCopyFieldsImp : PdfWriter {
    internal static PdfName iTextTag;
    internal static int zero;
    internal List`1<PdfReader> readers;
    internal Dictionary`2<PdfReader, IntHashtable> readers2intrefs;
    internal Dictionary`2<PdfReader, IntHashtable> pages2intrefs;
    internal Dictionary`2<PdfReader, IntHashtable> visited;
    internal List`1<AcroFields> fields;
    internal RandomAccessFileOrArray file;
    internal Dictionary`2<string, object> fieldTree;
    internal List`1<PdfIndirectReference> pageRefs;
    internal List`1<PdfDictionary> pageDics;
    internal PdfDictionary resources;
    internal PdfDictionary form;
    private bool closing;
    internal Document nd;
    private Dictionary`2<PdfArray, List`1<int>> tabOrder;
    private List`1<string> calculationOrder;
    private List`1<object> calculationOrderRefs;
    private bool hasSignature;
    private bool needAppearances;
    private Dictionary`2<object, object> mergedRadioButtons;
    protected ICounter COUNTER;
    protected internal static Dictionary`2<PdfName, int> widgetKeys;
    protected internal static Dictionary`2<PdfName, int> fieldKeys;
    internal PdfCopyFieldsImp(Stream os);
    internal PdfCopyFieldsImp(Stream os, char pdfVersion);
    private static PdfCopyFieldsImp();
    protected virtual ICounter GetCounter();
    internal void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    internal void AddDocument(PdfReader reader);
    internal static string GetCOName(PdfReader reader, PRIndirectReference refi);
    protected internal virtual void UpdateCalculationOrder(PdfReader reader);
    internal void Propagate(PdfObject obj, PdfIndirectReference refo, bool restricted);
    private void AdjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
    protected virtual PdfArray BranchForm(Dictionary`2<string, object> level, PdfIndirectReference parent, string fname);
    protected virtual PdfName GetOffStateName(PdfDictionary widget);
    protected virtual void CreateAcroForms();
    public virtual void Close();
    protected virtual void CloseIt();
    internal void AddPageOffsetToField(IDictionary`2<string, Item> fd, int pageOffset);
    internal void CreateWidgets(List`1<object> list, Item item);
    internal void MergeField(string name, Item item);
    internal void MergeWithMaster(IDictionary`2<string, Item> fd);
    internal virtual void MergeFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual PdfIndirectReference GetNewReference(PRIndirectReference refi);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal virtual bool SetVisited(PRIndirectReference refi);
    protected internal virtual bool IsVisited(PRIndirectReference refi);
    protected internal virtual bool IsVisited(PdfReader reader, int number, int generation);
    protected internal virtual bool IsPage(PRIndirectReference refi);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public virtual void OpenDoc();
}
public class iTextSharp.text.pdf.PdfCopyForms : object {
    private PdfCopyFormsImp fc;
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyForms(Stream os);
    public virtual void AddDocument(PdfReader reader);
    public virtual void AddDocument(PdfReader reader, ICollection`1<int> pagesToKeep);
    public virtual void AddDocument(PdfReader reader, string ranges);
    public virtual void CopyDocumentFields(PdfReader reader);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void Close();
    public virtual void Open();
    public virtual void AddJavaScript(string js);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual PdfWriter get_Writer();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_ViewerPreferences(int value);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
internal class iTextSharp.text.pdf.PdfCopyFormsImp : PdfCopyFieldsImp {
    internal PdfCopyFormsImp(Stream os);
    public virtual void CopyDocumentFields(PdfReader reader);
    internal virtual void MergeFields();
}
public class iTextSharp.text.pdf.PdfDashPattern : PdfArray {
    private float dash;
    private float gap;
    private float phase;
    public PdfDashPattern(float dash);
    public PdfDashPattern(float dash, float gap);
    public PdfDashPattern(float dash, float gap, float phase);
    public virtual void Add(float n);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfDate : PdfString {
    public PdfDate(DateTime d);
    private static string SetLength(int i, int length);
    public virtual string GetW3CDate();
    public static string GetW3CDate(string d);
    public static DateTime Decode(string date);
}
public class iTextSharp.text.pdf.PdfDestination : PdfArray {
    public static int XYZ;
    public static int FIT;
    public static int FITH;
    public static int FITV;
    public static int FITR;
    public static int FITB;
    public static int FITBH;
    public static int FITBV;
    private bool status;
    public PdfDestination(int type);
    public PdfDestination(int type, float parameter);
    public PdfDestination(int type, float left, float top, float zoom);
    public PdfDestination(int type, float left, float bottom, float right, float top);
    public PdfDestination(PdfDestination d);
    public PdfDestination(string dest);
    public virtual bool HasPage();
    public virtual bool AddPage(PdfIndirectReference page);
}
public class iTextSharp.text.pdf.PdfDeveloperExtension : object {
    public static PdfDeveloperExtension ADOBE_1_7_EXTENSIONLEVEL3;
    public static PdfDeveloperExtension ESIC_1_7_EXTENSIONLEVEL2;
    public static PdfDeveloperExtension ESIC_1_7_EXTENSIONLEVEL5;
    protected PdfName prefix;
    protected PdfName baseversion;
    protected int extensionLevel;
    public PdfName Prefix { get; }
    public PdfName Baseversion { get; }
    public int ExtensionLevel { get; }
    public PdfDeveloperExtension(PdfName prefix, PdfName baseversion, int extensionLevel);
    private static PdfDeveloperExtension();
    public virtual PdfName get_Prefix();
    public virtual PdfName get_Baseversion();
    public virtual int get_ExtensionLevel();
    public virtual PdfDictionary GetDeveloperExtensions();
}
public class iTextSharp.text.pdf.PdfDeviceNColor : object {
    private PdfSpotColor[] spotColors;
    private ColorDetails[] colorantsDetails;
    public int NumberOfColorants { get; }
    public PdfSpotColor[] SpotColors { get; }
    public PdfDeviceNColor(PdfSpotColor[] spotColors);
    public virtual int get_NumberOfColorants();
    public virtual PdfSpotColor[] get_SpotColors();
    public virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfDictionary : PdfObject {
    public static PdfName FONT;
    public static PdfName OUTLINES;
    public static PdfName PAGE;
    public static PdfName PAGES;
    public static PdfName CATALOG;
    private PdfName dictionaryType;
    protected internal Dictionary`2<PdfName, PdfObject> hashMap;
    public KeyCollection<PdfName, PdfObject> Keys { get; }
    public int Size { get; }
    public PdfDictionary(PdfName type);
    public PdfDictionary(int capacity);
    private static PdfDictionary();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void Put(PdfName key, PdfObject value);
    public virtual void PutEx(PdfName key, PdfObject value);
    public virtual void PutAll(PdfDictionary dic);
    public virtual void Remove(PdfName key);
    public virtual void Clear();
    public virtual PdfObject Get(PdfName key);
    public virtual bool IsFont();
    public virtual bool IsPage();
    public virtual bool IsPages();
    public virtual bool IsCatalog();
    public virtual bool IsOutlineTree();
    public virtual bool CheckType(PdfName type);
    public virtual void Merge(PdfDictionary other);
    public virtual void MergeDifferent(PdfDictionary other);
    public virtual KeyCollection<PdfName, PdfObject> get_Keys();
    public virtual int get_Size();
    public virtual bool Contains(PdfName key);
    public virtual Enumerator<PdfName, PdfObject> GetEnumerator();
    public virtual string ToString();
    public virtual PdfObject GetDirectObject(PdfName key);
    public virtual PdfDictionary GetAsDict(PdfName key);
    public virtual PdfArray GetAsArray(PdfName key);
    public virtual PdfStream GetAsStream(PdfName key);
    public virtual PdfString GetAsString(PdfName key);
    public virtual PdfNumber GetAsNumber(PdfName key);
    public virtual PdfName GetAsName(PdfName key);
    public virtual PdfBoolean GetAsBoolean(PdfName key);
    public virtual PdfIndirectReference GetAsIndirectObject(PdfName key);
}
public class iTextSharp.text.pdf.PdfDiv : object {
    private List`1<IElement> content;
    private Nullable`1<float> left;
    private Nullable`1<float> top;
    private Nullable`1<float> right;
    private Nullable`1<float> bottom;
    private Nullable`1<float> width;
    private Nullable`1<float> height;
    private Nullable`1<float> percentageHeight;
    private Nullable`1<float> percentageWidth;
    private float contentWidth;
    private float contentHeight;
    private int textAlignment;
    private float paddingLeft;
    private float paddingRight;
    private float paddingTop;
    private float paddingBottom;
    private BaseColor backgroundColor;
    private Image backgroundImage;
    private Nullable`1<float> backgroundImageWidth;
    private float backgroundImageHeight;
    protected float spacingBefore;
    protected float spacingAfter;
    private FloatType floatType;
    private PositionType position;
    private DisplayType display;
    private FloatLayout floatLayout;
    private BorderTopStyle borderTopStyle;
    private float yLine;
    protected int runDirection;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private bool keepTogether;
    public Nullable`1<float> Left { get; public set; }
    public Nullable`1<float> Top { get; public set; }
    public Nullable`1<float> Right { get; public set; }
    public Nullable`1<float> Bottom { get; public set; }
    public Nullable`1<float> Width { get; public set; }
    public Nullable`1<float> Height { get; public set; }
    public Nullable`1<float> PercentageHeight { get; public set; }
    public Nullable`1<float> PercentageWidth { get; public set; }
    public float ContentWidth { get; public set; }
    public float ContentHeight { get; public set; }
    public int TextAlignment { get; public set; }
    public float PaddingLeft { get; public set; }
    public float PaddingRight { get; public set; }
    public float PaddingTop { get; public set; }
    public float PaddingBottom { get; public set; }
    public FloatType Float { get; public set; }
    public PositionType Position { get; public set; }
    public FloatLayout FloatLayout { get; public set; }
    public DisplayType Display { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    unknown Image BackgroundImage {public set; }
    public float YLine { get; }
    public int RunDirection { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public List`1<IElement> Content { get; }
    public BorderTopStyle BorderStyle { get; public set; }
    public bool KeepTogether { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public virtual Nullable`1<float> get_Left();
    public virtual void set_Left(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Top();
    public virtual void set_Top(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Right();
    public virtual void set_Right(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Bottom();
    public virtual void set_Bottom(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Width();
    public virtual void set_Width(Nullable`1<float> value);
    public virtual Nullable`1<float> get_Height();
    public virtual void set_Height(Nullable`1<float> value);
    public virtual Nullable`1<float> get_PercentageHeight();
    public virtual void set_PercentageHeight(Nullable`1<float> value);
    public virtual Nullable`1<float> get_PercentageWidth();
    public virtual void set_PercentageWidth(Nullable`1<float> value);
    public virtual float get_ContentWidth();
    public virtual void set_ContentWidth(float value);
    public virtual float get_ContentHeight();
    public virtual void set_ContentHeight(float value);
    public virtual float getActualHeight();
    public virtual float getActualWidth();
    public virtual int get_TextAlignment();
    public virtual void set_TextAlignment(int value);
    public virtual float get_PaddingLeft();
    public virtual void set_PaddingLeft(float value);
    public virtual float get_PaddingRight();
    public virtual void set_PaddingRight(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_PaddingBottom();
    public virtual void set_PaddingBottom(float value);
    public virtual FloatType get_Float();
    public virtual void set_Float(FloatType value);
    public virtual PositionType get_Position();
    public virtual void set_Position(PositionType value);
    public virtual FloatLayout get_FloatLayout();
    public virtual void set_FloatLayout(FloatLayout value);
    public virtual DisplayType get_Display();
    public virtual void set_Display(DisplayType value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual void set_BackgroundImage(Image value);
    public virtual void SetBackgroundImage(Image image, float width, float height);
    public virtual float get_YLine();
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual List`1<IElement> get_Content();
    public virtual BorderTopStyle get_BorderStyle();
    public virtual void set_BorderStyle(BorderTopStyle value);
    public virtual bool get_KeepTogether();
    public virtual void set_KeepTogether(bool value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual void AddElement(IElement element);
    public virtual int Layout(PdfContentByte canvas, bool useAscender, bool simulate, float llx, float lly, float urx, float ury);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfDocument : Document {
    protected internal PdfWriter writer;
    internal Dictionary`2<AccessibleElementId, PdfStructureElement> structElements;
    protected internal bool openMCDocument;
    protected Dictionary`2<object, Int32[]> structParentIndices;
    protected Dictionary`2<object, int> markPoints;
    protected internal PdfContentByte text;
    protected internal PdfContentByte graphics;
    protected internal float leading;
    protected internal float currentHeight;
    protected bool isSectionTitle;
    protected internal int alignment;
    protected internal PdfAction anchorAction;
    protected TabSettings tabSettings;
    private Stack`1<float> leadingStack;
    private PdfBody body;
    protected internal int textEmptySize;
    protected float nextMarginLeft;
    protected float nextMarginRight;
    protected float nextMarginTop;
    protected float nextMarginBottom;
    protected internal bool firstPageEvent;
    protected internal PdfLine line;
    protected internal List`1<PdfLine> lines;
    protected internal int lastElementType;
    internal static string hangingPunctuation;
    protected internal Indentation indentation;
    protected internal PdfInfo info;
    protected internal PdfOutline rootOutline;
    protected internal PdfOutline currentOutline;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected internal PdfPageLabels pageLabels;
    protected internal SortedDictionary`2<string, Destination> localDestinations;
    private int jsCounter;
    protected internal Dictionary`2<string, PdfObject> documentLevelJS;
    protected internal Dictionary`2<string, PdfObject> documentFileAttachment;
    protected internal string openActionName;
    protected internal PdfAction openActionAction;
    protected internal PdfDictionary additionalActions;
    protected internal PdfCollection collection;
    internal PdfAnnotationsImp annotationsImp;
    protected PdfString language;
    protected Rectangle nextPageSize;
    protected Dictionary`2<string, PdfRectangle> thisBoxSize;
    protected Dictionary`2<string, PdfRectangle> boxSize;
    private bool pageEmpty;
    protected PdfDictionary pageAA;
    protected internal PageResources pageResources;
    protected internal bool strictImageSequence;
    protected internal float imageEnd;
    protected internal Image imageWait;
    internal List`1<IElement> floatingElements;
    public float Leading { get; public set; }
    public TabSettings TabSettings { get; public set; }
    unknown Byte[] XmpMetadata {public set; }
    unknown int PageCount {public set; }
    protected internal float IndentLeft { get; }
    protected internal float IndentRight { get; }
    protected internal float IndentTop { get; }
    protected internal float IndentBottom { get; }
    internal PdfInfo Info { get; }
    public PdfOutline RootOutline { get; }
    unknown int ViewerPreferences {internal set; }
    public PdfPageLabels PageLabels { get; internal set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {internal set; }
    unknown Rectangle CropBoxSize {internal set; }
    internal bool PageEmpty { get; internal set; }
    unknown int Duration {internal set; }
    unknown PdfTransition Transition {internal set; }
    unknown Image Thumbnail {internal set; }
    internal PageResources PageResources { get; }
    internal bool StrictImageSequence { get; internal set; }
    public virtual void AddWriter(PdfWriter writer);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    protected virtual void PushLeading();
    protected virtual void PopLeading();
    public virtual TabSettings get_TabSettings();
    public virtual void set_TabSettings(TabSettings value);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void Close();
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual bool NewPage();
    public IList`1<IAccessibleElement> EndPage();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetMarginMirroring(bool MarginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroringTopBottom);
    public virtual void set_PageCount(int value);
    public virtual void ResetPageCount();
    protected internal virtual void InitPage();
    protected internal virtual void NewLine();
    protected virtual float CalculateLineHeight();
    protected internal virtual void CarriageReturn();
    public virtual float GetVerticalPosition(bool ensureNewLine);
    protected internal virtual void EnsureNewLine();
    protected internal virtual float FlushLines();
    internal float WriteLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object[] currentValues, float ratio);
    protected internal virtual float get_IndentLeft();
    protected internal virtual float get_IndentRight();
    protected internal virtual float get_IndentTop();
    protected internal virtual float get_IndentBottom();
    protected internal virtual void AddSpacing(float extraspace, float oldleading, Font f);
    protected internal virtual void AddSpacing(float extraspace, float oldleading, Font f, bool spacingAfter);
    internal PdfInfo get_Info();
    internal PdfCatalog GetCatalog(PdfIndirectReference pages);
    internal void AddOutline(PdfOutline outline, string name);
    public virtual PdfOutline get_RootOutline();
    internal void CalculateOutlineCount();
    internal void TraverseOutlineCount(PdfOutline outline);
    internal void WriteOutlines();
    internal void OutlineTree(PdfOutline outline);
    internal void set_ViewerPreferences(int value);
    internal void AddViewerPreference(PdfName key, PdfObject value);
    public virtual PdfPageLabels get_PageLabels();
    internal virtual void set_PageLabels(PdfPageLabels value);
    internal void LocalGoto(string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    internal void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    internal PdfAction GetLocalGotoAction(string name);
    internal bool LocalDestination(string name, PdfDestination destination);
    internal void AddJavaScript(PdfAction js);
    internal void AddJavaScript(string name, PdfAction js);
    internal Dictionary`2<string, PdfObject> GetDocumentLevelJS();
    internal void AddFileAttachment(string description, PdfFileSpecification fs);
    internal Dictionary`2<string, PdfObject> GetDocumentFileAttachment();
    internal void SetOpenAction(string name);
    internal void SetOpenAction(PdfAction action);
    internal void AddAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void set_Collection(PdfCollection value);
    public virtual PdfAcroForm get_AcroForm();
    internal void set_SigFlags(int value);
    internal void AddCalculationOrder(PdfFormField formField);
    internal void AddAnnotation(PdfAnnotation annot);
    internal void SetLanguage(string language);
    internal void set_CropBoxSize(Rectangle value);
    internal void SetBoxSize(string boxName, Rectangle size);
    protected internal virtual void SetNewPageSizeAndMargins();
    internal Rectangle GetBoxSize(string boxName);
    internal void set_PageEmpty(bool value);
    internal bool get_PageEmpty();
    internal void set_Duration(int value);
    internal void set_Transition(PdfTransition value);
    internal void SetPageAction(PdfName actionType, PdfAction action);
    internal void set_Thumbnail(Image value);
    internal PageResources get_PageResources();
    internal void set_StrictImageSequence(bool value);
    internal bool get_StrictImageSequence();
    public virtual void ClearTextWrap();
    public virtual int GetStructParentIndex(object obj);
    public virtual int GetNextMarkPoint(object obj);
    public virtual Int32[] GetStructParentIndexAndNextMarkPoint(object obj);
    protected internal virtual void Add(Image image);
    internal void AddPTable(PdfPTable ptable);
    internal void AddDiv(PdfDiv div);
    internal void FlushFloatingElements();
    internal bool FitsPage(PdfPTable table, float margin);
    private static bool IsTagged(PdfWriter writer);
    private PdfLine GetLastLine();
}
public class iTextSharp.text.pdf.PdfEFStream : PdfStream {
    public PdfEFStream(Stream inp, PdfWriter writer);
    public PdfEFStream(Byte[] fileStore);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfEncodings : object {
    internal static Char[] winansiByteToChar;
    internal static Char[] pdfEncodingByteToChar;
    internal static IntHashtable winansi;
    internal static IntHashtable pdfEncoding;
    internal static Dictionary`2<string, IExtraEncoding> extraEncodings;
    private static PdfEncodings();
    public static Byte[] ConvertToBytes(string text, string encoding);
    public static Byte[] ConvertToBytes(char char1, string encoding);
    public static string ConvertToString(Byte[] bytes, string encoding);
    public static bool IsPdfDocEncoding(string text);
    public static void AddExtraEncoding(string name, IExtraEncoding enc);
}
public class iTextSharp.text.pdf.PdfEncryption : object {
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int AES_128;
    public static int AES_256;
    private static Byte[] pad;
    private static Byte[] salt;
    internal static Byte[] metadataPad;
    internal Byte[] key;
    internal int keySize;
    internal Byte[] mkey;
    internal Byte[] extra;
    internal IDigest md5;
    internal Byte[] ownerKey;
    internal Byte[] userKey;
    internal Byte[] oeKey;
    internal Byte[] ueKey;
    internal Byte[] perms;
    protected PdfPublicKeySecurityHandler publicKeyHandler;
    internal long permissions;
    internal Byte[] documentID;
    internal static long seq;
    private int revision;
    private ARCFOUREncryption rc4;
    private int keyLength;
    private bool encryptMetadata;
    private bool embeddedFilesOnly;
    private int cryptoMode;
    private static int VALIDATION_SALT_OFFSET;
    private static int KEY_SALT_OFFSET;
    private static int SALT_LENGHT;
    private static int OU_LENGHT;
    public PdfEncryption(PdfEncryption enc);
    private static PdfEncryption();
    public virtual void SetCryptoMode(int mode, int kl);
    public virtual int GetCryptoMode();
    public virtual bool IsMetadataEncrypted();
    public virtual long GetPermissions();
    public virtual bool IsEmbeddedFilesOnly();
    private Byte[] PadPassword(Byte[] userPassword);
    private Byte[] ComputeOwnerKey(Byte[] userPad, Byte[] ownerPad);
    private void SetupGlobalEncryptionKey(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, long permissions);
    private void SetupUserKey();
    public virtual void SetupAllKeys(Byte[] userPassword, Byte[] ownerPassword, int permissions);
    public virtual bool ReadKey(PdfDictionary enc, Byte[] password);
    private static bool CompareArray(Byte[] a, Byte[] b, int len);
    public static Byte[] CreateDocumentId();
    public virtual void SetupByUserPassword(Byte[] documentID, Byte[] userPassword, Byte[] ownerKey, long permissions);
    private void SetupByUserPad(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, long permissions);
    public virtual void SetupByOwnerPassword(Byte[] documentID, Byte[] ownerPassword, Byte[] userKey, Byte[] ownerKey, long permissions);
    private void SetupByOwnerPad(Byte[] documentID, Byte[] ownerPad, Byte[] userKey, Byte[] ownerKey, long permissions);
    public virtual void SetKey(Byte[] key);
    public virtual void SetupByEncryptionKey(Byte[] key, int keylength);
    public virtual void SetHashKey(int number, int generation);
    public static PdfObject CreateInfoId(Byte[] id, bool modified);
    public virtual PdfDictionary GetEncryptionDictionary();
    public virtual PdfObject GetFileID(bool modified);
    public virtual OutputStreamEncryption GetEncryptionStream(Stream os);
    public virtual int CalculateStreamSize(int n);
    public virtual Byte[] EncryptByteArray(Byte[] b);
    public virtual StandardDecryption GetDecryptor();
    public virtual Byte[] DecryptByteArray(Byte[] b);
    public virtual void AddRecipient(X509Certificate cert, int permission);
    public virtual Byte[] ComputeUserPassword(Byte[] ownerPassword);
}
public class iTextSharp.text.pdf.PdfEncryptor : object {
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions, Dictionary`2<string, string> newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions);
    public static string GetPermissionsVerbose(int permissions);
    public static bool IsPrintingAllowed(int permissions);
    public static bool IsModifyContentsAllowed(int permissions);
    public static bool IsCopyAllowed(int permissions);
    public static bool IsModifyAnnotationsAllowed(int permissions);
    public static bool IsFillInAllowed(int permissions);
    public static bool IsScreenReadersAllowed(int permissions);
    public static bool IsAssemblyAllowed(int permissions);
    public static bool IsDegradedPrintingAllowed(int permissions);
}
public class iTextSharp.text.pdf.PdfException : DocumentException {
    public PdfException(string message);
    protected PdfException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.PdfFileSpecification : PdfDictionary {
    protected PdfWriter writer;
    protected PdfIndirectReference refi;
    public PdfIndirectReference Reference { get; }
    unknown Byte[] MultiByteFileName {public set; }
    unknown bool Volatile {public set; }
    public static PdfFileSpecification Url(PdfWriter writer, string url);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, int compressionLevel);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress, string mimeType, PdfDictionary fileParameter);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, string mimeType, PdfDictionary fileParameter, int compressionLevel);
    public static PdfFileSpecification FileExtern(PdfWriter writer, string filePath);
    public virtual PdfIndirectReference get_Reference();
    public virtual void set_MultiByteFileName(Byte[] value);
    public virtual void SetUnicodeFileName(string filename, bool unicode);
    public virtual void set_Volatile(bool value);
    public virtual void AddDescription(string description, bool unicode);
    public virtual void AddCollectionItem(PdfCollectionItem ci);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfFont : object {
    private BaseFont font;
    private float size;
    protected float hScale;
    internal float Size { get; }
    internal BaseFont Font { get; }
    internal static PdfFont DefaultFont { get; }
    internal float HorizontalScaling { get; internal set; }
    internal PdfFont(BaseFont bf, float size);
    public virtual int CompareTo(PdfFont pdfFont);
    internal float get_Size();
    internal float Width();
    internal float Width(int character);
    internal float Width(string s);
    internal BaseFont get_Font();
    internal static PdfFont get_DefaultFont();
    internal void set_HorizontalScaling(float value);
    internal float get_HorizontalScaling();
}
public class iTextSharp.text.pdf.PdfFormField : PdfAnnotation {
    public static int FF_READ_ONLY;
    public static int FF_REQUIRED;
    public static int FF_NO_EXPORT;
    public static int FF_NO_TOGGLE_TO_OFF;
    public static int FF_RADIO;
    public static int FF_PUSHBUTTON;
    public static int FF_MULTILINE;
    public static int FF_PASSWORD;
    public static int FF_COMBO;
    public static int FF_EDIT;
    public static int FF_FILESELECT;
    public static int FF_MULTISELECT;
    public static int FF_DONOTSPELLCHECK;
    public static int FF_DONOTSCROLL;
    public static int FF_COMB;
    public static int FF_RADIOSINUNISON;
    public static int FF_RICHTEXT;
    public static int Q_LEFT;
    public static int Q_CENTER;
    public static int Q_RIGHT;
    public static int MK_NO_ICON;
    public static int MK_NO_CAPTION;
    public static int MK_CAPTION_BELOW;
    public static int MK_CAPTION_ABOVE;
    public static int MK_CAPTION_RIGHT;
    public static int MK_CAPTION_LEFT;
    public static int MK_CAPTION_OVERLAID;
    public static PdfName IF_SCALE_ALWAYS;
    public static PdfName IF_SCALE_BIGGER;
    public static PdfName IF_SCALE_SMALLER;
    public static PdfName IF_SCALE_NEVER;
    public static PdfName IF_SCALE_ANAMORPHIC;
    public static PdfName IF_SCALE_PROPORTIONAL;
    public static bool MULTILINE;
    public static bool SINGLELINE;
    public static bool PLAINTEXT;
    public static bool PASSWORD;
    public static PdfName[] mergeTarget;
    internal PdfFormField parent;
    internal List`1<PdfFormField> kids;
    unknown int Button {public set; }
    public PdfFormField Parent { get; }
    public List`1<PdfFormField> Kids { get; }
    unknown string ValueAsString {public set; }
    unknown string ValueAsName {public set; }
    unknown PdfSignature ValueAsSig {public set; }
    unknown string RichValue {public set; }
    unknown string DefaultValueAsString {public set; }
    unknown string DefaultValueAsName {public set; }
    unknown string FieldName {public set; }
    unknown string UserName {public set; }
    unknown string MappingName {public set; }
    unknown int Quadding {public set; }
    public PdfFormField(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    internal PdfFormField(PdfWriter writer);
    private static PdfFormField();
    public virtual void SetWidget(Rectangle rect, PdfName highlight);
    public static PdfFormField CreateEmpty(PdfWriter writer);
    public virtual void set_Button(int value);
    protected static PdfFormField CreateButton(PdfWriter writer, int flags);
    public static PdfFormField CreatePushButton(PdfWriter writer);
    public static PdfFormField CreateCheckBox(PdfWriter writer);
    public static PdfFormField CreateRadioButton(PdfWriter writer, bool noToggleToOff);
    public static PdfFormField CreateTextField(PdfWriter writer, bool multiline, bool password, int maxLen);
    protected static PdfFormField CreateChoice(PdfWriter writer, int flags, PdfArray options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[] options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[0...,0...] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[0...,0...] options, int topIndex);
    protected static PdfArray ProcessOptions(String[] options);
    protected static PdfArray ProcessOptions(String[0...,0...] options);
    public static PdfFormField CreateSignature(PdfWriter writer);
    public virtual PdfFormField get_Parent();
    public virtual void AddKid(PdfFormField field);
    public virtual List`1<PdfFormField> get_Kids();
    public virtual int SetFieldFlags(int flags);
    public virtual void set_ValueAsString(string value);
    public virtual void set_ValueAsName(string value);
    public virtual void set_ValueAsSig(PdfSignature value);
    public virtual void set_RichValue(string value);
    public virtual void set_DefaultValueAsString(string value);
    public virtual void set_DefaultValueAsName(string value);
    public virtual void set_FieldName(string value);
    public virtual void set_UserName(string value);
    public virtual void set_MappingName(string value);
    public virtual void set_Quadding(int value);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source, PdfStamperImp writer);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source);
    public virtual void SetUsed();
}
public class iTextSharp.text.pdf.PdfFormXObject : PdfStream {
    public static PdfNumber ZERO;
    public static PdfNumber ONE;
    public static PdfLiteral MATRIX;
    internal PdfFormXObject(PdfTemplate template, int compressionLevel);
    private static PdfFormXObject();
}
public class iTextSharp.text.pdf.PdfFunction : object {
    protected PdfWriter writer;
    protected PdfIndirectReference reference;
    protected PdfDictionary dictionary;
    internal PdfIndirectReference Reference { get; }
    protected PdfFunction(PdfWriter writer);
    internal PdfIndirectReference get_Reference();
    public static PdfFunction Type0(PdfWriter writer, Single[] domain, Single[] range, Int32[] size, int bitsPerSample, int order, Single[] encode, Single[] decode, Byte[] stream);
    public static PdfFunction Type2(PdfWriter writer, Single[] domain, Single[] range, Single[] c0, Single[] c1, float n);
    public static PdfFunction Type3(PdfWriter writer, Single[] domain, Single[] range, PdfFunction[] functions, Single[] bounds, Single[] encode);
    public static PdfFunction Type4(PdfWriter writer, Single[] domain, Single[] range, string postscript);
}
public class iTextSharp.text.pdf.PdfGState : PdfDictionary {
    public static PdfName BM_NORMAL;
    public static PdfName BM_COMPATIBLE;
    public static PdfName BM_MULTIPLY;
    public static PdfName BM_SCREEN;
    public static PdfName BM_OVERLAY;
    public static PdfName BM_DARKEN;
    public static PdfName BM_LIGHTEN;
    public static PdfName BM_COLORDODGE;
    public static PdfName BM_COLORBURN;
    public static PdfName BM_HARDLIGHT;
    public static PdfName BM_SOFTLIGHT;
    public static PdfName BM_DIFFERENCE;
    public static PdfName BM_EXCLUSION;
    unknown bool OverPrintStroking {public set; }
    unknown bool OverPrintNonStroking {public set; }
    unknown int OverPrintMode {public set; }
    unknown float StrokeOpacity {public set; }
    unknown float FillOpacity {public set; }
    unknown bool AlphaIsShape {public set; }
    unknown bool TextKnockout {public set; }
    unknown PdfName BlendMode {public set; }
    unknown PdfName RenderingIntent {public set; }
    private static PdfGState();
    public virtual void set_OverPrintStroking(bool value);
    public virtual void set_OverPrintNonStroking(bool value);
    public virtual void set_OverPrintMode(int value);
    public virtual void set_StrokeOpacity(float value);
    public virtual void set_FillOpacity(float value);
    public virtual void set_AlphaIsShape(bool value);
    public virtual void set_TextKnockout(bool value);
    public virtual void set_BlendMode(PdfName value);
    public virtual void set_RenderingIntent(PdfName value);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfICCBased : PdfStream {
    public PdfICCBased(ICC_Profile profile);
    public PdfICCBased(ICC_Profile profile, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfImage : PdfStream {
    internal static int TRANSFERSIZE;
    protected PdfName name;
    protected Image image;
    public PdfName Name { get; }
    public Image Image { get; }
    public PdfImage(Image image, string name, PdfIndirectReference maskRef);
    public virtual PdfName get_Name();
    public virtual Image get_Image();
    internal static void TransferBytes(Stream inp, Stream outp, int len);
    protected virtual void ImportAll(PdfImage dup);
    private void GenerateImgResName(Image img);
}
public class iTextSharp.text.pdf.PdfImportedPage : PdfTemplate {
    internal PdfReaderInstance readerInstance;
    internal int pageNumber;
    internal int rotation;
    protected internal bool toCopy;
    public PdfImportedPage FromReader { get; }
    public int PageNumber { get; }
    public int Rotation { get; }
    public PdfContentByte Duplicate { get; }
    internal PdfObject Resources { get; }
    unknown PdfTransparencyGroup Group {public set; }
    internal PdfReaderInstance PdfReaderInstance { get; }
    internal PdfImportedPage(PdfReaderInstance readerInstance, PdfWriter writer, int pageNumber);
    public virtual PdfImportedPage get_FromReader();
    public virtual int get_PageNumber();
    public virtual int get_Rotation();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    public virtual PdfContentByte get_Duplicate();
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    internal virtual PdfObject get_Resources();
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void set_Group(PdfTransparencyGroup value);
    internal void ThrowError();
    internal PdfReaderInstance get_PdfReaderInstance();
    public virtual bool IsToCopy();
    public virtual void SetCopied();
}
public class iTextSharp.text.pdf.PdfIndirectObject : object {
    protected int number;
    protected int generation;
    internal static Byte[] STARTOBJ;
    internal static Byte[] ENDOBJ;
    internal static int SIZEOBJ;
    protected internal PdfObject objecti;
    protected internal PdfWriter writer;
    public int Number { get; }
    public int Generation { get; }
    public PdfIndirectReference IndirectReference { get; }
    public PdfIndirectObject(int number, PdfObject objecti, PdfWriter writer);
    public PdfIndirectObject(PdfIndirectReference refi, PdfObject objecti, PdfWriter writer);
    public PdfIndirectObject(int number, int generation, PdfObject objecti, PdfWriter writer);
    private static PdfIndirectObject();
    public virtual int get_Number();
    public virtual int get_Generation();
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void WriteTo(Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfIndirectReference : PdfObject {
    protected int number;
    protected int generation;
    public int Number { get; }
    public int Generation { get; }
    internal PdfIndirectReference(int type, int number, int generation);
    protected internal PdfIndirectReference(int type, int number);
    public virtual int get_Number();
    public virtual int get_Generation();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfIsoConformanceException : Exception {
    private static long serialVersionUID;
    public PdfIsoConformanceException(string s);
    protected PdfIsoConformanceException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.PdfLabColor : object {
    private Single[] whitePoint;
    private Single[] blackPoint;
    private Single[] range;
    public PdfLabColor(Single[] whitePoint);
    public PdfLabColor(Single[] whitePoint, Single[] blackPoint);
    public PdfLabColor(Single[] whitePoint, Single[] blackPoint, Single[] range);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual BaseColor Lab2Rgb(float l, float a, float b);
    internal virtual CMYKColor Lab2Cmyk(float l, float a, float b);
    protected virtual Double[] Lab2RgbLinear(float l, float a, float b);
    public virtual LabColor Rgb2lab(BaseColor baseColor);
    private static double FXyz(double t);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfLayer : PdfDictionary {
    protected PdfIndirectReference refi;
    protected List`1<PdfLayer> children;
    protected PdfLayer parent;
    protected string title;
    private bool on;
    private bool onPanel;
    internal string Title { get; }
    public PdfLayer Parent { get; }
    public List`1<PdfLayer> Children { get; }
    public PdfIndirectReference Ref { get; public set; }
    unknown string Name {public set; }
    public PdfObject PdfObject { get; }
    public bool On { get; public set; }
    private PdfDictionary Usage { get; }
    unknown bool Export {public set; }
    unknown bool View {public set; }
    unknown string PageElement {public set; }
    public bool OnPanel { get; public set; }
    internal PdfLayer(string title);
    public PdfLayer(string name, PdfWriter writer);
    public static PdfLayer CreateTitle(string title, PdfWriter writer);
    internal string get_Title();
    public virtual void AddChild(PdfLayer child);
    public virtual PdfLayer get_Parent();
    public virtual List`1<PdfLayer> get_Children();
    public virtual PdfIndirectReference get_Ref();
    public virtual void set_Ref(PdfIndirectReference value);
    public virtual void set_Name(string value);
    public virtual PdfObject get_PdfObject();
    public virtual bool get_On();
    public virtual void set_On(bool value);
    private PdfDictionary get_Usage();
    public virtual void SetCreatorInfo(string creator, string subtype);
    public virtual void SetLanguage(string lang, bool preferred);
    public virtual void set_Export(bool value);
    public virtual void SetZoom(float min, float max);
    public virtual void SetPrint(string subtype, bool printstate);
    public virtual void set_View(bool value);
    public virtual void set_PageElement(string value);
    public virtual void SetUser(string type, String[] names);
    public virtual bool get_OnPanel();
    public virtual void set_OnPanel(bool value);
}
public class iTextSharp.text.pdf.PdfLayerMembership : PdfDictionary {
    public static PdfName ALLON;
    public static PdfName ANYON;
    public static PdfName ANYOFF;
    public static PdfName ALLOFF;
    internal PdfIndirectReference refi;
    internal PdfArray members;
    internal Dictionary`2<PdfLayer, object> layers;
    public PdfIndirectReference Ref { get; }
    public KeyCollection<PdfLayer, object> Layers { get; }
    unknown PdfName VisibilityPolicy {public set; }
    unknown PdfVisibilityExpression VisibilityExpression {public set; }
    public PdfObject PdfObject { get; }
    public PdfLayerMembership(PdfWriter writer);
    private static PdfLayerMembership();
    public virtual PdfIndirectReference get_Ref();
    public virtual void AddMember(PdfLayer layer);
    public virtual KeyCollection<PdfLayer, object> get_Layers();
    public virtual void set_VisibilityPolicy(PdfName value);
    public virtual void set_VisibilityExpression(PdfVisibilityExpression value);
    public virtual PdfObject get_PdfObject();
}
public class iTextSharp.text.pdf.PdfLine : object {
    protected internal List`1<PdfChunk> line;
    protected internal float left;
    protected internal float width;
    protected internal int alignment;
    protected internal float height;
    protected internal bool newlineSplit;
    protected internal float originalWidth;
    protected internal bool isRTL;
    protected internal ListItem listItem;
    protected TabStop tabStop;
    protected float tabStopAnchorPosition;
    protected float tabPosition;
    public int Size { get; }
    internal float Height { get; }
    internal float IndentLeft { get; }
    internal float WidthLeft { get; }
    internal int NumberOfSpaces { get; }
    public ListItem ListItem { get; public set; }
    public Chunk ListSymbol { get; }
    public float ListIndent { get; }
    public bool NewlineSplit { get; }
    public int LastStrokeChunk { get; }
    public float OriginalWidth { get; }
    internal bool RTL { get; }
    public float Ascender { get; }
    public float Descender { get; }
    internal PdfLine(float left, float right, int alignment, float height);
    internal PdfLine(float left, float originalWidth, float remainingWidth, int alignment, bool newlineSplit, List`1<PdfChunk> line, bool isRTL);
    internal PdfChunk Add(PdfChunk chunk, float currentLeading);
    internal PdfChunk Add(PdfChunk chunk);
    private void AddToLine(PdfChunk chunk);
    public virtual int get_Size();
    public virtual IEnumerator`1<PdfChunk> GetEnumerator();
    internal float get_Height();
    internal float get_IndentLeft();
    public virtual bool HasToBeJustified();
    public virtual void ResetAlignment();
    internal void SetExtraIndent(float extra);
    internal float get_WidthLeft();
    internal int get_NumberOfSpaces();
    public virtual void set_ListItem(ListItem value);
    public virtual ListItem get_ListItem();
    public virtual Chunk get_ListSymbol();
    public virtual float get_ListIndent();
    public virtual string ToString();
    public virtual int GetLineLengthUtf32();
    public virtual bool get_NewlineSplit();
    public virtual int get_LastStrokeChunk();
    public virtual PdfChunk GetChunk(int idx);
    public virtual float get_OriginalWidth();
    internal Single[] GetMaxSize(float fixedLeading, float multipliedLeading);
    internal bool get_RTL();
    internal int GetSeparatorCount();
    public virtual float GetWidthCorrected(float charSpacing, float wordSpacing);
    public virtual float get_Ascender();
    public virtual float get_Descender();
    public virtual void Flush();
}
public class iTextSharp.text.pdf.PdfLiteral : PdfObject {
    private long position;
    public long Position { get; }
    public int PosLength { get; }
    public PdfLiteral(string text);
    public PdfLiteral(Byte[] b);
    public PdfLiteral(int type, string text);
    public PdfLiteral(int type, Byte[] b);
    public PdfLiteral(int size);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual long get_Position();
    public virtual int get_PosLength();
}
public class iTextSharp.text.pdf.PdfMediaClipData : PdfDictionary {
    internal PdfMediaClipData(string file, PdfFileSpecification fs, string mimeType);
}
public class iTextSharp.text.pdf.PdfName : PdfObject {
    public static PdfName _3D;
    public static PdfName A;
    public static PdfName A85;
    public static PdfName AA;
    public static PdfName ABSOLUTECOLORIMETRIC;
    public static PdfName AC;
    public static PdfName ACROFORM;
    public static PdfName ACTION;
    public static PdfName ACTIVATION;
    public static PdfName ADBE;
    public static PdfName ACTUALTEXT;
    public static PdfName ADBE_PKCS7_DETACHED;
    public static PdfName ADBE_PKCS7_S4;
    public static PdfName ADBE_PKCS7_S5;
    public static PdfName ADBE_PKCS7_SHA1;
    public static PdfName ADBE_X509_RSA_SHA1;
    public static PdfName ADOBE_PPKLITE;
    public static PdfName ADOBE_PPKMS;
    public static PdfName AESV2;
    public static PdfName AESV3;
    public static PdfName AFRELATIONSHIP;
    public static PdfName AHX;
    public static PdfName AIS;
    public static PdfName ALL;
    public static PdfName ALLPAGES;
    public static PdfName ALT;
    public static PdfName ALTERNATE;
    public static PdfName AF;
    public static PdfName ALTERNATEPRESENTATION;
    public static PdfName ALTERNATES;
    public static PdfName AND;
    public static PdfName ANIMATION;
    public static PdfName ANNOT;
    public static PdfName ANNOTS;
    public static PdfName ANTIALIAS;
    public static PdfName AP;
    public static PdfName APP;
    public static PdfName APPDEFAULT;
    public static PdfName ART;
    public static PdfName ARTBOX;
    public static PdfName ARTIFACT;
    public static PdfName ASCENT;
    public static PdfName AS;
    public static PdfName ASCII85DECODE;
    public static PdfName ASCIIHEXDECODE;
    public static PdfName ASSET;
    public static PdfName ASSETS;
    public static PdfName ATTACHED;
    public static PdfName AUTHEVENT;
    public static PdfName AUTHOR;
    public static PdfName B;
    public static PdfName BACKGROUND;
    public static PdfName BACKGROUNDCOLOR;
    public static PdfName BASEENCODING;
    public static PdfName BASEFONT;
    public static PdfName BASEVERSION;
    public static PdfName BBOX;
    public static PdfName BC;
    public static PdfName BG;
    public static PdfName BIBENTRY;
    public static PdfName BIGFIVE;
    public static PdfName BINDING;
    public static PdfName BINDINGMATERIALNAME;
    public static PdfName BITSPERCOMPONENT;
    public static PdfName BITSPERSAMPLE;
    public static PdfName BL;
    public static PdfName BLACKIS1;
    public static PdfName BLACKPOINT;
    public static PdfName BLOCKQUOTE;
    public static PdfName BLEEDBOX;
    public static PdfName BLINDS;
    public static PdfName BM;
    public static PdfName BORDER;
    public static PdfName BOTH;
    public static PdfName BOUNDS;
    public static PdfName BOX;
    public static PdfName BS;
    public static PdfName BTN;
    public static PdfName BYTERANGE;
    public static PdfName C;
    public static PdfName C0;
    public static PdfName C1;
    public static PdfName CA;
    public static PdfName ca;
    public static PdfName CALGRAY;
    public static PdfName CALRGB;
    public static PdfName CAPHEIGHT;
    public static PdfName CARET;
    public static PdfName CAPTION;
    public static PdfName CATALOG;
    public static PdfName CATEGORY;
    public static PdfName CB;
    public static PdfName CCITTFAXDECODE;
    public static PdfName CENTER;
    public static PdfName CENTERWINDOW;
    public static PdfName CERT;
    public static PdfName CERTS;
    public static PdfName CF;
    public static PdfName CFM;
    public static PdfName CH;
    public static PdfName CHARPROCS;
    public static PdfName CHECKSUM;
    public static PdfName CI;
    public static PdfName CIDFONTTYPE0;
    public static PdfName CIDFONTTYPE2;
    public static PdfName CIDSET;
    public static PdfName CIDSYSTEMINFO;
    public static PdfName CIDTOGIDMAP;
    public static PdfName CIRCLE;
    public static PdfName CLASSMAP;
    public static PdfName CLOUD;
    public static PdfName CMD;
    public static PdfName CO;
    public static PdfName CODE;
    public static PdfName COLOR;
    public static PdfName COLORANTS;
    public static PdfName COLORS;
    public static PdfName COLORSPACE;
    public static PdfName COLORTRANSFORM;
    public static PdfName COLLECTION;
    public static PdfName COLLECTIONFIELD;
    public static PdfName COLLECTIONITEM;
    public static PdfName COLLECTIONSCHEMA;
    public static PdfName COLLECTIONSORT;
    public static PdfName COLLECTIONSUBITEM;
    public static PdfName COLSPAN;
    public static PdfName COLUMN;
    public static PdfName COLUMNS;
    public static PdfName CONDITION;
    public static PdfName CONFIGS;
    public static PdfName CONFIGURATION;
    public static PdfName CONFIGURATIONS;
    public static PdfName CONTACTINFO;
    public static PdfName CONTENT;
    public static PdfName CONTENTS;
    public static PdfName COORDS;
    public static PdfName COUNT;
    public static PdfName COURIER;
    public static PdfName COURIER_BOLD;
    public static PdfName COURIER_OBLIQUE;
    public static PdfName COURIER_BOLDOBLIQUE;
    public static PdfName CREATIONDATE;
    public static PdfName CREATOR;
    public static PdfName CREATORINFO;
    public static PdfName CRL;
    public static PdfName CRLS;
    public static PdfName CROPBOX;
    public static PdfName CRYPT;
    public static PdfName CS;
    public static PdfName CUEPOINT;
    public static PdfName CUEPOINTS;
    public static PdfName CYX;
    public static PdfName D;
    public static PdfName DA;
    public static PdfName DATA;
    public static PdfName DC;
    public static PdfName DCS;
    public static PdfName DCTDECODE;
    public static PdfName DECIMAL;
    public static PdfName DEACTIVATION;
    public static PdfName DECODE;
    public static PdfName DECODEPARMS;
    public static PdfName DEFAULT;
    public static PdfName DEFAULTCRYPTFILTER;
    public static PdfName DEFAULTCMYK;
    public static PdfName DEFAULTGRAY;
    public static PdfName DEFAULTRGB;
    public static PdfName DESC;
    public static PdfName DESCENDANTFONTS;
    public static PdfName DESCENT;
    public static PdfName DEST;
    public static PdfName DESTOUTPUTPROFILE;
    public static PdfName DESTS;
    public static PdfName DEVICEGRAY;
    public static PdfName DEVICERGB;
    public static PdfName DEVICECMYK;
    public static PdfName DEVICEN;
    public static PdfName DI;
    public static PdfName DIFFERENCES;
    public static PdfName DISSOLVE;
    public static PdfName DIRECTION;
    public static PdfName DISPLAYDOCTITLE;
    public static PdfName DIV;
    public static PdfName DL;
    public static PdfName DM;
    public static PdfName DOS;
    public static PdfName DOCMDP;
    public static PdfName DOCOPEN;
    public static PdfName DOCTIMESTAMP;
    public static PdfName DOCUMENT;
    public static PdfName DOMAIN;
    public static PdfName DP;
    public static PdfName DR;
    public static PdfName DS;
    public static PdfName DSS;
    public static PdfName DUR;
    public static PdfName DUPLEX;
    public static PdfName DUPLEXFLIPSHORTEDGE;
    public static PdfName DUPLEXFLIPLONGEDGE;
    public static PdfName DV;
    public static PdfName DW;
    public static PdfName E;
    public static PdfName EARLYCHANGE;
    public static PdfName EF;
    public static PdfName EFF;
    public static PdfName EFOPEN;
    public static PdfName EMBEDDED;
    public static PdfName EMBEDDEDFILE;
    public static PdfName EMBEDDEDFILES;
    public static PdfName ENCODE;
    public static PdfName ENCODEDBYTEALIGN;
    public static PdfName ENCODING;
    public static PdfName ENCRYPT;
    public static PdfName ENCRYPTMETADATA;
    public static PdfName END;
    public static PdfName ENDINDENT;
    public static PdfName ENDOFBLOCK;
    public static PdfName ENDOFLINE;
    public static PdfName EPSG;
    public static PdfName ESIC;
    public static PdfName ETSI_CADES_DETACHED;
    public static PdfName ETSI_RFC3161;
    public static PdfName EXCLUDE;
    public static PdfName EXTEND;
    public static PdfName EXTENSIONS;
    public static PdfName EXTENSIONLEVEL;
    public static PdfName EXTGSTATE;
    public static PdfName EXPORT;
    public static PdfName EXPORTSTATE;
    public static PdfName EVENT;
    public static PdfName F;
    public static PdfName FAR;
    public static PdfName FB;
    public static PdfName FD;
    public static PdfName FDECODEPARMS;
    public static PdfName FDF;
    public static PdfName FF;
    public static PdfName FFILTER;
    public static PdfName FG;
    public static PdfName FIELDMDP;
    public static PdfName FIELDS;
    public static PdfName FIGURE;
    public static PdfName FILEATTACHMENT;
    public static PdfName FILESPEC;
    public static PdfName FILTER;
    public static PdfName FIRST;
    public static PdfName FIRSTCHAR;
    public static PdfName FIRSTPAGE;
    public static PdfName FIT;
    public static PdfName FITH;
    public static PdfName FITV;
    public static PdfName FITR;
    public static PdfName FITB;
    public static PdfName FITBH;
    public static PdfName FITBV;
    public static PdfName FITWINDOW;
    public static PdfName FL;
    public static PdfName FLAGS;
    public static PdfName FLASH;
    public static PdfName FLASHVARS;
    public static PdfName FLATEDECODE;
    public static PdfName FO;
    public static PdfName FONT;
    public static PdfName FONTBBOX;
    public static PdfName FONTDESCRIPTOR;
    public static PdfName FONTFAMILY;
    public static PdfName FONTFILE;
    public static PdfName FONTFILE2;
    public static PdfName FONTFILE3;
    public static PdfName FONTMATRIX;
    public static PdfName FONTNAME;
    public static PdfName FONTWEIGHT;
    public static PdfName FOREGROUND;
    public static PdfName FORM;
    public static PdfName FORMTYPE;
    public static PdfName FORMULA;
    public static PdfName FREETEXT;
    public static PdfName FRM;
    public static PdfName FS;
    public static PdfName FT;
    public static PdfName FULLSCREEN;
    public static PdfName FUNCTION;
    public static PdfName FUNCTIONS;
    public static PdfName FUNCTIONTYPE;
    public static PdfName GAMMA;
    public static PdfName GBK;
    public static PdfName GCS;
    public static PdfName GEO;
    public static PdfName GEOGCS;
    public static PdfName GLITTER;
    public static PdfName GOTO;
    public static PdfName GOTO3DVIEW;
    public static PdfName GOTOE;
    public static PdfName GOTOR;
    public static PdfName GPTS;
    public static PdfName GROUP;
    public static PdfName GTS_PDFA1;
    public static PdfName GTS_PDFX;
    public static PdfName GTS_PDFXVERSION;
    public static PdfName H;
    public static PdfName H1;
    public static PdfName H2;
    public static PdfName H3;
    public static PdfName H4;
    public static PdfName H5;
    public static PdfName H6;
    public static PdfName HALFTONENAME;
    public static PdfName HALFTONETYPE;
    public static PdfName HALIGN;
    public static PdfName HEADERS;
    public static PdfName HEIGHT;
    public static PdfName HELV;
    public static PdfName HELVETICA;
    public static PdfName HELVETICA_BOLD;
    public static PdfName HELVETICA_OBLIQUE;
    public static PdfName HELVETICA_BOLDOBLIQUE;
    public static PdfName HF;
    public static PdfName HID;
    public static PdfName HIDE;
    public static PdfName HIDEMENUBAR;
    public static PdfName HIDETOOLBAR;
    public static PdfName HIDEWINDOWUI;
    public static PdfName HIGHLIGHT;
    public static PdfName HOFFSET;
    public static PdfName HT;
    public static PdfName HTP;
    public static PdfName I;
    public static PdfName IC;
    public static PdfName ICCBASED;
    public static PdfName ID;
    public static PdfName IDENTITY;
    public static PdfName IDTREE;
    public static PdfName IF;
    public static PdfName IM;
    public static PdfName IMAGE;
    public static PdfName IMAGEB;
    public static PdfName IMAGEC;
    public static PdfName IMAGEI;
    public static PdfName IMAGEMASK;
    public static PdfName INCLUDE;
    public static PdfName IND;
    public static PdfName INDEX;
    public static PdfName INDEXED;
    public static PdfName INFO;
    public static PdfName INK;
    public static PdfName INKLIST;
    public static PdfName INSTANCES;
    public static PdfName IMPORTDATA;
    public static PdfName INTENT;
    public static PdfName INTERPOLATE;
    public static PdfName ISMAP;
    public static PdfName IRT;
    public static PdfName ITALICANGLE;
    public static PdfName ITXT;
    public static PdfName IX;
    public static PdfName JAVASCRIPT;
    public static PdfName JBIG2DECODE;
    public static PdfName JBIG2GLOBALS;
    public static PdfName JPXDECODE;
    public static PdfName JS;
    public static PdfName JUSTIFY;
    public static PdfName K;
    public static PdfName KEYWORDS;
    public static PdfName KIDS;
    public static PdfName L;
    public static PdfName L2R;
    public static PdfName LAB;
    public static PdfName LANG;
    public static PdfName LANGUAGE;
    public static PdfName LAST;
    public static PdfName LASTCHAR;
    public static PdfName LASTPAGE;
    public static PdfName LAUNCH;
    public static PdfName LAYOUT;
    public static PdfName LBL;
    public static PdfName LBODY;
    public static PdfName LENGTH;
    public static PdfName LENGTH1;
    public static PdfName LI;
    public static PdfName LIMITS;
    public static PdfName LINE;
    public static PdfName LINEAR;
    public static PdfName LINEHEIGHT;
    public static PdfName LINK;
    public static PdfName LIST;
    public static PdfName LISTMODE;
    public static PdfName LISTNUMBERING;
    public static PdfName LOCATION;
    public static PdfName LOCK;
    public static PdfName LOCKED;
    public static PdfName LOWERALPHA;
    public static PdfName LOWERROMAN;
    public static PdfName LPTS;
    public static PdfName LZWDECODE;
    public static PdfName M;
    public static PdfName MAC;
    public static PdfName MATERIAL;
    public static PdfName MATRIX;
    public static PdfName MAC_EXPERT_ENCODING;
    public static PdfName MAC_ROMAN_ENCODING;
    public static PdfName MARKED;
    public static PdfName MARKINFO;
    public static PdfName MASK;
    public static PdfName MAX_LOWER_CASE;
    public static PdfName MAX_CAMEL_CASE;
    public static PdfName MAXLEN;
    public static PdfName MEDIABOX;
    public static PdfName MCID;
    public static PdfName MCR;
    public static PdfName MEASURE;
    public static PdfName METADATA;
    public static PdfName MIN_LOWER_CASE;
    public static PdfName MIN_CAMEL_CASE;
    public static PdfName MK;
    public static PdfName MMTYPE1;
    public static PdfName MODDATE;
    public static PdfName MOVIE;
    public static PdfName N;
    public static PdfName N0;
    public static PdfName N1;
    public static PdfName N2;
    public static PdfName N3;
    public static PdfName N4;
    public static PdfName NAME;
    public static PdfName NAMED;
    public static PdfName NAMES;
    public static PdfName NAVIGATION;
    public static PdfName NAVIGATIONPANE;
    public static PdfName NCHANNEL;
    public static PdfName NEAR;
    public static PdfName NEEDAPPEARANCES;
    public static PdfName NEEDRENDERING;
    public static PdfName NEWWINDOW;
    public static PdfName NEXT;
    public static PdfName NEXTPAGE;
    public static PdfName NM;
    public static PdfName NONE;
    public static PdfName NONFULLSCREENPAGEMODE;
    public static PdfName NONSTRUCT;
    public static PdfName NOT;
    public static PdfName NOTE;
    public static PdfName NUMBERFORMAT;
    public static PdfName NUMCOPIES;
    public static PdfName NUMS;
    public static PdfName O;
    public static PdfName OBJ;
    public static PdfName OBJR;
    public static PdfName OBJSTM;
    public static PdfName OC;
    public static PdfName OCG;
    public static PdfName OCGS;
    public static PdfName OCMD;
    public static PdfName OCPROPERTIES;
    public static PdfName OCSP;
    public static PdfName OCSPS;
    public static PdfName OE;
    public static PdfName Off_;
    public static PdfName OFF;
    public static PdfName ON;
    public static PdfName ONECOLUMN;
    public static PdfName OPEN;
    public static PdfName OPENACTION;
    public static PdfName OP;
    public static PdfName op_;
    public static PdfName OPI;
    public static PdfName OPM;
    public static PdfName OPT;
    public static PdfName OR;
    public static PdfName ORDER;
    public static PdfName ORDERING;
    public static PdfName ORG;
    public static PdfName OSCILLATING;
    public static PdfName OUTLINES;
    public static PdfName OUTPUTCONDITION;
    public static PdfName OUTPUTCONDITIONIDENTIFIER;
    public static PdfName OUTPUTINTENT;
    public static PdfName OUTPUTINTENTS;
    public static PdfName OVERLAYTEXT;
    public static PdfName P;
    public static PdfName PAGE;
    public static PdfName PAGEELEMENT;
    public static PdfName PAGELABELS;
    public static PdfName PAGELAYOUT;
    public static PdfName PAGEMODE;
    public static PdfName PAGES;
    public static PdfName PAINTTYPE;
    public static PdfName PANOSE;
    public static PdfName PARAMS;
    public static PdfName PARENT;
    public static PdfName PARENTTREE;
    public static PdfName PARENTTREENEXTKEY;
    public static PdfName PART;
    public static PdfName PASSCONTEXTCLICK;
    public static PdfName PATTERN;
    public static PdfName PATTERNTYPE;
    public static PdfName PB;
    public static PdfName PC;
    public static PdfName PDF;
    public static PdfName PDFDOCENCODING;
    public static PdfName PDU;
    public static PdfName PERCEPTUAL;
    public static PdfName PERMS;
    public static PdfName PG;
    public static PdfName PI;
    public static PdfName PICKTRAYBYPDFSIZE;
    public static PdfName PIECEINFO;
    public static PdfName PLAYCOUNT;
    public static PdfName PO;
    public static PdfName POLYGON;
    public static PdfName POLYLINE;
    public static PdfName POPUP;
    public static PdfName POSITION;
    public static PdfName PREDICTOR;
    public static PdfName PREFERRED;
    public static PdfName PRESENTATION;
    public static PdfName PRESERVERB;
    public static PdfName PRESSTEPS;
    public static PdfName PREV;
    public static PdfName PREVPAGE;
    public static PdfName PRINT;
    public static PdfName PRINTAREA;
    public static PdfName PRINTCLIP;
    public static PdfName PRINTERMARK;
    public static PdfName PRINTFIELD;
    public static PdfName PRINTPAGERANGE;
    public static PdfName PRINTSCALING;
    public static PdfName PRINTSTATE;
    public static PdfName PRIVATE;
    public static PdfName PROCSET;
    public static PdfName PRODUCER;
    public static PdfName PROJCS;
    public static PdfName PROP_BUILD;
    public static PdfName PROPERTIES;
    public static PdfName PS;
    public static PdfName PTDATA;
    public static PdfName PUBSEC;
    public static PdfName PV;
    public static PdfName Q;
    public static PdfName QUADPOINTS;
    public static PdfName QUOTE;
    public static PdfName R;
    public static PdfName R2L;
    public static PdfName RANGE;
    public static PdfName RB;
    public static PdfName rb;
    public static PdfName RBGROUPS;
    public static PdfName RC;
    public static PdfName RD;
    public static PdfName REASON;
    public static PdfName RECIPIENTS;
    public static PdfName RECT;
    public static PdfName REDACT;
    public static PdfName REFERENCE;
    public static PdfName REGISTRY;
    public static PdfName REGISTRYNAME;
    public static PdfName RELATIVECOLORIMETRIC;
    public static PdfName RENDITION;
    public static PdfName REPEAT;
    public static PdfName REVERSEDCHARS;
    public static PdfName RESETFORM;
    public static PdfName RESOURCES;
    public static PdfName REQUIREMENTS;
    public static PdfName RI;
    public static PdfName RICHMEDIA;
    public static PdfName RICHMEDIAACTIVATION;
    public static PdfName RICHMEDIAANIMATION;
    public static PdfName RICHMEDIACOMMAND;
    public static PdfName RICHMEDIACONFIGURATION;
    public static PdfName RICHMEDIACONTENT;
    public static PdfName RICHMEDIADEACTIVATION;
    public static PdfName RICHMEDIAEXECUTE;
    public static PdfName RICHMEDIAINSTANCE;
    public static PdfName RICHMEDIAPARAMS;
    public static PdfName RICHMEDIAPOSITION;
    public static PdfName RICHMEDIAPRESENTATION;
    public static PdfName RICHMEDIASETTINGS;
    public static PdfName RICHMEDIAWINDOW;
    public static PdfName RL;
    public static PdfName ROLE;
    public static PdfName RO;
    public static PdfName ROLEMAP;
    public static PdfName ROOT;
    public static PdfName ROTATE;
    public static PdfName ROW;
    public static PdfName ROWS;
    public static PdfName ROWSPAN;
    public static PdfName RP;
    public static PdfName RT;
    public static PdfName RUBY;
    public static PdfName RUNLENGTHDECODE;
    public static PdfName RV;
    public static PdfName S;
    public static PdfName SATURATION;
    public static PdfName SCHEMA;
    public static PdfName SCOPE;
    public static PdfName SCREEN;
    public static PdfName SCRIPTS;
    public static PdfName SECT;
    public static PdfName SEPARATION;
    public static PdfName SETOCGSTATE;
    public static PdfName SETTINGS;
    public static PdfName SHADING;
    public static PdfName SHADINGTYPE;
    public static PdfName SHIFT_JIS;
    public static PdfName SIG;
    public static PdfName SIGFIELDLOCK;
    public static PdfName SIGFLAGS;
    public static PdfName SIGREF;
    public static PdfName SIMPLEX;
    public static PdfName SINGLEPAGE;
    public static PdfName SIZE;
    public static PdfName SMASK;
    public static PdfName SMASKINDATA;
    public static PdfName SORT;
    public static PdfName SOUND;
    public static PdfName SPACEAFTER;
    public static PdfName SPACEBEFORE;
    public static PdfName SPAN;
    public static PdfName SPEED;
    public static PdfName SPLIT;
    public static PdfName SQUARE;
    public static PdfName SQUIGGLY;
    public static PdfName SS;
    public static PdfName ST;
    public static PdfName STAMP;
    public static PdfName STANDARD;
    public static PdfName START;
    public static PdfName STARTINDENT;
    public static PdfName STATE;
    public static PdfName STATUS;
    public static PdfName STDCF;
    public static PdfName STEMV;
    public static PdfName STMF;
    public static PdfName STRF;
    public static PdfName STRIKEOUT;
    public static PdfName STRUCTELEM;
    public static PdfName STRUCTPARENT;
    public static PdfName STRUCTPARENTS;
    public static PdfName STRUCTTREEROOT;
    public static PdfName STYLE;
    public static PdfName SUBFILTER;
    public static PdfName SUBJECT;
    public static PdfName SUBMITFORM;
    public static PdfName SUBTYPE;
    public static PdfName SUMMARY;
    public static PdfName SUPPLEMENT;
    public static PdfName SV;
    public static PdfName SW;
    public static PdfName SYMBOL;
    public static PdfName T;
    public static PdfName TA;
    public static PdfName TABLE;
    public static PdfName TABS;
    public static PdfName TBODY;
    public static PdfName TD;
    public static PdfName TR;
    public static PdfName TR2;
    public static PdfName TEXT;
    public static PdfName TEXTALIGN;
    public static PdfName TEXTDECORATIONCOLOR;
    public static PdfName TEXTDECORATIONTHICKNESS;
    public static PdfName TEXTDECORATIONTYPE;
    public static PdfName TEXTINDENT;
    public static PdfName TFOOT;
    public static PdfName TH;
    public static PdfName THEAD;
    public static PdfName THUMB;
    public static PdfName THREADS;
    public static PdfName TI;
    public static PdfName TIME;
    public static PdfName TILINGTYPE;
    public static PdfName TIMES_ROMAN;
    public static PdfName TIMES_BOLD;
    public static PdfName TIMES_ITALIC;
    public static PdfName TIMES_BOLDITALIC;
    public static PdfName TITLE;
    public static PdfName TK;
    public static PdfName TM;
    public static PdfName TOC;
    public static PdfName TOCI;
    public static PdfName TOGGLE;
    public static PdfName TOOLBAR;
    public static PdfName TOUNICODE;
    public static PdfName TP;
    public static PdfName TABLEROW;
    public static PdfName TRANS;
    public static PdfName TRANSFORMPARAMS;
    public static PdfName TRANSFORMMETHOD;
    public static PdfName TRANSPARENCY;
    public static PdfName TRANSPARENT;
    public static PdfName TRAPNET;
    public static PdfName TRAPPED;
    public static PdfName TRIMBOX;
    public static PdfName TRUETYPE;
    public static PdfName TS;
    public static PdfName TTL;
    public static PdfName TU;
    public static PdfName TV;
    public static PdfName TWOCOLUMNLEFT;
    public static PdfName TWOCOLUMNRIGHT;
    public static PdfName TWOPAGELEFT;
    public static PdfName TWOPAGERIGHT;
    public static PdfName TX;
    public static PdfName TYPE;
    public static PdfName TYPE0;
    public static PdfName TYPE1;
    public static PdfName TYPE3;
    public static PdfName U;
    public static PdfName UE;
    public static PdfName UF;
    public static PdfName UHC;
    public static PdfName UNDERLINE;
    public static PdfName UNIX;
    public static PdfName UPPERALPHA;
    public static PdfName UPPERROMAN;
    public static PdfName UR;
    public static PdfName UR3;
    public static PdfName URI;
    public static PdfName URL;
    public static PdfName USAGE;
    public static PdfName USEATTACHMENTS;
    public static PdfName USENONE;
    public static PdfName USEOC;
    public static PdfName USEOUTLINES;
    public static PdfName USER;
    public static PdfName USERPROPERTIES;
    public static PdfName USERUNIT;
    public static PdfName USETHUMBS;
    public static PdfName UTF_8;
    public static PdfName V;
    public static PdfName V2;
    public static PdfName VALIGN;
    public static PdfName VE;
    public static PdfName VERISIGN_PPKVS;
    public static PdfName VERSION;
    public static PdfName VERTICES;
    public static PdfName VIDEO;
    public static PdfName VIEW;
    public static PdfName VIEWS;
    public static PdfName VIEWAREA;
    public static PdfName VIEWCLIP;
    public static PdfName VIEWERPREFERENCES;
    public static PdfName VIEWPORT;
    public static PdfName VIEWSTATE;
    public static PdfName VISIBLEPAGES;
    public static PdfName VOFFSET;
    public static PdfName VP;
    public static PdfName VRI;
    public static PdfName W;
    public static PdfName W2;
    public static PdfName WARICHU;
    public static PdfName WATERMARK;
    public static PdfName WC;
    public static PdfName WIDGET;
    public static PdfName WIDTH;
    public static PdfName WIDTHS;
    public static PdfName WIN;
    public static PdfName WIN_ANSI_ENCODING;
    public static PdfName WINDOW;
    public static PdfName WINDOWED;
    public static PdfName WIPE;
    public static PdfName WHITEPOINT;
    public static PdfName WKT;
    public static PdfName WP;
    public static PdfName WS;
    public static PdfName WT;
    public static PdfName X;
    public static PdfName XA;
    public static PdfName XD;
    public static PdfName XFA;
    public static PdfName XML;
    public static PdfName XOBJECT;
    public static PdfName XPTS;
    public static PdfName XREF;
    public static PdfName XREFSTM;
    public static PdfName XSTEP;
    public static PdfName XYZ;
    public static PdfName YSTEP;
    public static PdfName ZADB;
    public static PdfName ZAPFDINGBATS;
    public static PdfName ZOOM;
    public static Dictionary`2<string, PdfName> staticNames;
    private int hash;
    private static PdfName();
    public PdfName(string name);
    public PdfName(string name, bool lengthCheck);
    public PdfName(Byte[] bytes);
    public virtual int CompareTo(PdfName name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Byte[] EncodeName(string name);
    public static string DecodeName(string name);
}
public class iTextSharp.text.pdf.PdfNameTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Dictionary`2<string, T> items, PdfWriter writer);
    private static PdfString IterateItems(PdfDictionary dic, Dictionary`2<string, PdfObject> items, PdfString leftOverString);
    public static Dictionary`2<string, PdfObject> ReadTree(PdfDictionary dic);
}
public class iTextSharp.text.pdf.PdfNull : PdfObject {
    public static PdfNull PDFNULL;
    private static PdfNull();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfNumber : PdfObject {
    private double value;
    public int IntValue { get; }
    public long LongValue { get; }
    public double DoubleValue { get; }
    public float FloatValue { get; }
    public PdfNumber(string content);
    public PdfNumber(int value);
    public PdfNumber(long value);
    public PdfNumber(double value);
    public PdfNumber(float value);
    public virtual int get_IntValue();
    public virtual long get_LongValue();
    public virtual double get_DoubleValue();
    public virtual float get_FloatValue();
    public virtual void Increment();
}
public class iTextSharp.text.pdf.PdfNumberTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Dictionary`2<int, T> items, PdfWriter writer);
    private static void IterateItems(PdfDictionary dic, Dictionary`2<int, PdfObject> items);
    public static Dictionary`2<int, PdfObject> ReadTree(PdfDictionary dic);
}
public abstract class iTextSharp.text.pdf.PdfObject : object {
    public static int BOOLEAN;
    public static int NUMBER;
    public static int STRING;
    public static int NAME;
    public static int ARRAY;
    public static int DICTIONARY;
    public static int STREAM;
    public static int NULL;
    public static int INDIRECT;
    public static string NOTHING;
    public static string TEXT_PDFDOCENCODING;
    public static string TEXT_UNICODE;
    protected Byte[] bytes;
    protected int type;
    protected PRIndirectReference indRef;
    private int hashCode;
    private static int objCounter;
    private static object locker;
    public int Length { get; }
    unknown string Content {protected set; }
    public int Type { get; }
    public PRIndirectReference IndRef { get; public set; }
    protected PdfObject(int type);
    protected PdfObject(int type, string content);
    protected PdfObject(int type, Byte[] bytes);
    private static PdfObject();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual Byte[] GetBytes();
    public virtual bool CanBeInObjStm();
    public virtual string ToString();
    public virtual int get_Length();
    protected virtual void set_Content(string value);
    public virtual int get_Type();
    public virtual bool IsNull();
    public virtual bool IsBoolean();
    public virtual bool IsNumber();
    public virtual bool IsString();
    public virtual bool IsName();
    public virtual bool IsArray();
    public virtual bool IsDictionary();
    public virtual bool IsStream();
    public virtual bool IsIndirect();
    public virtual PRIndirectReference get_IndRef();
    public virtual void set_IndRef(PRIndirectReference value);
    public virtual int CompareTo(PdfObject obj);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static int IncrementObjCounter();
}
public class iTextSharp.text.pdf.PdfOCProperties : PdfDictionary {
}
public class iTextSharp.text.pdf.PdfOutline : PdfDictionary {
    private PdfIndirectReference reference;
    private int count;
    private PdfOutline parent;
    private PdfDestination destination;
    private PdfAction action;
    protected List`1<PdfOutline> kids;
    protected PdfWriter writer;
    private string tag;
    private bool open;
    private BaseColor color;
    private int style;
    public PdfIndirectReference IndirectReference { get; public set; }
    public PdfOutline Parent { get; }
    public PdfDestination PdfDestination { get; }
    internal int Count { get; internal set; }
    public int Level { get; }
    public List`1<PdfOutline> Kids { get; public set; }
    public string Tag { get; public set; }
    public string Title { get; public set; }
    public bool Open { get; public set; }
    public BaseColor Color { get; public set; }
    public int Style { get; public set; }
    internal PdfOutline(PdfWriter writer);
    public PdfOutline(PdfOutline parent, PdfAction action, string title);
    public PdfOutline(PdfOutline parent, PdfAction action, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title, bool open);
    internal void InitOutline(PdfOutline parent, string title, bool open);
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void set_IndirectReference(PdfIndirectReference value);
    public virtual PdfOutline get_Parent();
    public virtual bool SetDestinationPage(PdfIndirectReference pageReference);
    public virtual PdfDestination get_PdfDestination();
    internal int get_Count();
    internal void set_Count(int value);
    public virtual int get_Level();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void AddKid(PdfOutline outline);
    public virtual List`1<PdfOutline> get_Kids();
    public virtual void set_Kids(List`1<PdfOutline> value);
    public virtual string get_Tag();
    public virtual void set_Tag(string value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual void set_Open(bool value);
    public virtual bool get_Open();
    public virtual BaseColor get_Color();
    public virtual void set_Color(BaseColor value);
    public virtual int get_Style();
    public virtual void set_Style(int value);
}
public class iTextSharp.text.pdf.PdfPage : PdfDictionary {
    private static String[] boxStrings;
    private static PdfName[] boxNames;
    public static PdfNumber PORTRAIT;
    public static PdfNumber LANDSCAPE;
    public static PdfNumber INVERTEDPORTRAIT;
    public static PdfNumber SEASCAPE;
    private PdfRectangle mediaBox;
    internal PdfRectangle MediaBox { get; }
    internal PdfPage(PdfRectangle mediaBox, Dictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources, int rotate);
    internal PdfPage(PdfRectangle mediaBox, Dictionary`2<string, PdfRectangle> boxSize, PdfDictionary resources);
    private static PdfPage();
    public virtual bool IsParent();
    internal void Add(PdfIndirectReference contents);
    internal PdfRectangle RotateMediaBox();
    internal PdfRectangle get_MediaBox();
}
public class iTextSharp.text.pdf.PdfPageEventHelper : object {
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.PdfPageLabels : object {
    public static int DECIMAL_ARABIC_NUMERALS;
    public static int UPPERCASE_ROMAN_NUMERALS;
    public static int LOWERCASE_ROMAN_NUMERALS;
    public static int UPPERCASE_LETTERS;
    public static int LOWERCASE_LETTERS;
    public static int EMPTY;
    internal static PdfName[] numberingStyle;
    internal Dictionary`2<int, PdfDictionary> map;
    private static PdfPageLabels();
    public virtual void AddPageLabel(int page, int numberStyle, string text, int firstPage);
    public void AddPageLabel(int page, int numberStyle, string text, int firstPage, bool includeFirstPage);
    public virtual void AddPageLabel(int page, int numberStyle, string text);
    public virtual void AddPageLabel(int page, int numberStyle);
    public virtual void AddPageLabel(PdfPageLabelFormat format);
    public virtual void RemovePageLabel(int page);
    public virtual PdfDictionary GetDictionary(PdfWriter writer);
    public static String[] GetPageLabels(PdfReader reader);
    public static PdfPageLabelFormat[] GetPageLabelFormats(PdfReader reader);
}
public class iTextSharp.text.pdf.PdfPages : object {
    private List`1<PdfIndirectReference> pages;
    private List`1<PdfIndirectReference> parents;
    private int leafSize;
    private PdfWriter writer;
    private PdfIndirectReference topParent;
    internal PdfIndirectReference TopParent { get; }
    internal PdfPages(PdfWriter writer);
    internal void AddPage(PdfDictionary page);
    internal PdfIndirectReference AddPageRef(PdfIndirectReference pageRef);
    internal PdfIndirectReference WritePageTree();
    internal PdfIndirectReference get_TopParent();
    internal void SetLinearMode(PdfIndirectReference topParent);
    internal void AddPage(PdfIndirectReference page);
    internal int ReorderPages(Int32[] order);
}
public class iTextSharp.text.pdf.PdfPattern : PdfStream {
    internal PdfPattern(PdfPatternPainter painter);
    internal PdfPattern(PdfPatternPainter painter, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPatternPainter : PdfTemplate {
    internal float xstep;
    internal float ystep;
    internal bool stencil;
    internal BaseColor defaultColor;
    public float XStep { get; public set; }
    public float YStep { get; public set; }
    public PdfContentByte Duplicate { get; }
    public BaseColor DefaultColor { get; }
    internal PdfPatternPainter(PdfWriter wr);
    internal PdfPatternPainter(PdfWriter wr, BaseColor defaultColor);
    public float get_XStep();
    public void set_XStep(float value);
    public float get_YStep();
    public void set_YStep(float value);
    public bool IsStencil();
    public void SetPatternMatrix(float a, float b, float c, float d, float e, float f);
    public PdfPattern GetPattern();
    public PdfPattern GetPattern(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public BaseColor get_DefaultColor();
    public virtual void SetGrayFill(float gray);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float gray);
    public virtual void ResetGrayStroke();
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(BaseColor color);
    public virtual void SetColorFill(BaseColor color);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p);
    public virtual void SetPatternFill(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, BaseColor color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    internal void CheckNoColor();
}
public class iTextSharp.text.pdf.PdfPCell : Rectangle {
    private ColumnText column;
    private int verticalAlignment;
    private float paddingLeft;
    private float paddingRight;
    private float paddingTop;
    private float paddingBottom;
    private float fixedHeight;
    private float calculatedHeight;
    private bool noWrap;
    private PdfPTable table;
    private float minimumHeight;
    private float cachedMaxHeight;
    private int colspan;
    private int rowspan;
    private Image image;
    private IPdfPCellEvent cellEvent;
    private bool useDescender;
    private bool useBorderPadding;
    protected Phrase phrase;
    private int rotation;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected internal AccessibleElementId id;
    protected List`1<PdfPHeaderCell> headers;
    public Phrase Phrase { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float EffectivePaddingLeft { get; }
    public float PaddingLeft { get; public set; }
    public float EffectivePaddingRight { get; }
    public float PaddingRight { get; public set; }
    public float EffectivePaddingTop { get; }
    public float PaddingTop { get; public set; }
    public float EffectivePaddingBottom { get; }
    public float PaddingBottom { get; public set; }
    unknown float Padding {public set; }
    public bool UseBorderPadding { get; public set; }
    public float Leading { get; }
    public float MultipliedLeading { get; }
    public float Indent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float CalculatedHeight { get; public set; }
    public float FixedHeight { get; public set; }
    public float CachedMaxHeight { get; }
    public bool NoWrap { get; public set; }
    public PdfPTable Table { get; public set; }
    public float MinimumHeight { get; public set; }
    public int Colspan { get; public set; }
    public int Rowspan { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public Image Image { get; public set; }
    public IPdfPCellEvent CellEvent { get; public set; }
    public int ArabicOptions { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public ColumnText Column { get; public set; }
    public List`1<IElement> CompositeElements { get; }
    public int Rotation { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public List`1<PdfPHeaderCell> Headers { get; }
    public PdfPCell(Phrase phrase);
    public PdfPCell(Image image);
    public PdfPCell(Image image, bool fit);
    public PdfPCell(PdfPTable table);
    public PdfPCell(PdfPTable table, PdfPCell style);
    public PdfPCell(PdfPCell cell);
    public virtual void AddElement(IElement element);
    public virtual Phrase get_Phrase();
    public virtual void set_Phrase(Phrase value);
    public virtual int get_HorizontalAlignment();
    public virtual void set_HorizontalAlignment(int value);
    public virtual int get_VerticalAlignment();
    public virtual void set_VerticalAlignment(int value);
    public virtual float get_EffectivePaddingLeft();
    public virtual float get_PaddingLeft();
    public virtual void set_PaddingLeft(float value);
    public virtual float get_EffectivePaddingRight();
    public virtual float get_PaddingRight();
    public virtual void set_PaddingRight(float value);
    public virtual float get_EffectivePaddingTop();
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual float get_EffectivePaddingBottom();
    public virtual float get_PaddingBottom();
    public virtual void set_PaddingBottom(float value);
    public virtual void set_Padding(float value);
    public virtual void set_UseBorderPadding(bool value);
    public virtual bool get_UseBorderPadding();
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_Leading();
    public virtual float get_MultipliedLeading();
    public virtual float get_Indent();
    public virtual void set_Indent(float value);
    public virtual float get_ExtraParagraphSpace();
    public virtual void set_ExtraParagraphSpace(float value);
    public virtual float get_CalculatedHeight();
    public virtual void set_CalculatedHeight(float value);
    public virtual bool HasCalculatedHeight();
    public virtual float get_FixedHeight();
    public virtual void set_FixedHeight(float value);
    public virtual bool HasFixedHeight();
    public float get_CachedMaxHeight();
    public bool HasCachedMaxHeight();
    public virtual void set_NoWrap(bool value);
    public virtual bool get_NoWrap();
    public virtual PdfPTable get_Table();
    public virtual void set_Table(PdfPTable value);
    public virtual float get_MinimumHeight();
    public virtual void set_MinimumHeight(float value);
    public virtual bool HasMinimumHeight();
    public virtual int get_Colspan();
    public virtual void set_Colspan(int value);
    public virtual int get_Rowspan();
    public virtual void set_Rowspan(int value);
    public virtual float get_FollowingIndent();
    public virtual void set_FollowingIndent(float value);
    public virtual float get_RightIndent();
    public virtual void set_RightIndent(float value);
    public virtual float get_SpaceCharRatio();
    public virtual void set_SpaceCharRatio(float value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual IPdfPCellEvent get_CellEvent();
    public virtual void set_CellEvent(IPdfPCellEvent value);
    public virtual int get_ArabicOptions();
    public virtual void set_ArabicOptions(int value);
    public virtual bool get_UseAscender();
    public virtual void set_UseAscender(bool value);
    public virtual bool get_UseDescender();
    public virtual void set_UseDescender(bool value);
    public virtual ColumnText get_Column();
    public virtual void set_Column(ColumnText value);
    public virtual List`1<IElement> get_CompositeElements();
    public void set_Rotation(int value);
    public int get_Rotation();
    public virtual float GetMaxHeight();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual List`1<PdfPHeaderCell> get_Headers();
    public virtual void AddHeader(PdfPHeaderCell header);
}
public class iTextSharp.text.pdf.PdfPHeaderCell : PdfPCell {
    public static int NONE;
    public static int ROW;
    public static int COLUMN;
    public static int BOTH;
    protected int scope;
    protected string name;
    public int Scope { get; public set; }
    public string Name { get; public set; }
    public PdfName Role { get; public set; }
    public PdfPHeaderCell(PdfPHeaderCell headerCell);
    public virtual int get_Scope();
    public virtual void set_Scope(int value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPRow : object {
    private ILogger LOGGER;
    public bool mayNotBreak;
    public static float BOTTOM_LIMIT;
    public static float RIGHT_LIMIT;
    protected PdfPCell[] cells;
    protected Single[] widths;
    protected Single[] extraHeights;
    protected internal float maxHeight;
    protected internal bool calculated;
    protected bool adjusted;
    private Int32[] canvasesPos;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    public bool MayNotBreak { get; public set; }
    public float MaxHeights { get; public set; }
    public bool Adjusted { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfPRow(PdfPCell[] cells);
    public PdfPRow(PdfPCell[] cells, PdfPRow source);
    public PdfPRow(PdfPRow row);
    public virtual bool SetWidths(Single[] widths);
    protected internal virtual void InitExtraHeights();
    public virtual void SetExtraHeight(int cell, float height);
    protected internal virtual void CalculateHeights();
    public virtual bool get_MayNotBreak();
    public virtual void set_MayNotBreak(bool value);
    public virtual void WriteBorderAndBackground(float xPos, float yPos, float currentMaxHeight, PdfPCell cell, PdfContentByte[] canvases);
    protected virtual void SaveAndRotateCanvases(PdfContentByte[] canvases, float a, float b, float c, float d, float e, float f);
    protected virtual void RestoreCanvases(PdfContentByte[] canvases);
    public static float SetColumn(ColumnText ct, float left, float bottom, float right, float top);
    public virtual void WriteCells(int colStart, int colEnd, float xPos, float yPos, PdfContentByte[] canvases, bool reusable);
    public virtual bool IsCalculated();
    public virtual float get_MaxHeights();
    public virtual void set_MaxHeights(float value);
    internal Single[] GetEventWidth(float xPos, Single[] absoluteWidths);
    public virtual void CopyRowContent(PdfPTable table, int idx);
    public virtual PdfPRow SplitRow(PdfPTable table, int rowIndex, float new_height);
    public virtual float GetMaxRowHeightsWithoutCalculating();
    public virtual void SetFinalMaxHeights(float maxHeight);
    public virtual void SplitRowspans(PdfPTable original, int originalIdx, PdfPTable part, int partIdx);
    public virtual PdfPCell[] GetCells();
    public virtual bool HasRowspan();
    public virtual bool get_Adjusted();
    public virtual void set_Adjusted(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    private static bool IsTagged(PdfContentByte canvas);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfPSXObject : PdfTemplate {
    public PdfContentByte Duplicate { get; }
    public PdfPSXObject(PdfWriter wr);
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
}
public class iTextSharp.text.pdf.PdfPTable : object {
    private ILogger LOGGER;
    public static int BASECANVAS;
    public static int BACKGROUNDCANVAS;
    public static int LINECANVAS;
    public static int TEXTCANVAS;
    protected List`1<PdfPRow> rows;
    protected float totalHeight;
    protected PdfPCell[] currentRow;
    protected int currentColIdx;
    protected PdfPCell defaultCell;
    protected float totalWidth;
    protected Single[] relativeWidths;
    protected Single[] absoluteWidths;
    protected IPdfPTableEvent tableEvent;
    protected int headerRows;
    protected float widthPercentage;
    private int horizontalAlignment;
    private bool skipFirstHeader;
    private bool skipLastFooter;
    protected bool isColspan;
    protected int runDirection;
    private bool lockedWidth;
    private bool splitRows;
    protected float spacingBefore;
    protected float spacingAfter;
    protected float paddingTop;
    private Boolean[] extendLastRow;
    private bool headersInEvent;
    private bool splitLate;
    private bool keepTogether;
    protected bool complete;
    private int footerRows;
    protected bool rowCompleted;
    protected bool loopCheck;
    protected bool rowsNotChecked;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    protected AccessibleElementId id;
    private PdfPTableHeader header;
    private PdfPTableBody body;
    private PdfPTableFooter footer;
    private int numberOfWrittenRows;
    public bool Complete { get; public set; }
    public float TotalWidth { get; public set; }
    public PdfPCell DefaultCell { get; }
    public int Size { get; }
    public float TotalHeight { get; }
    public float HeaderHeight { get; }
    public float FooterHeight { get; }
    public int NumberOfColumns { get; }
    public int HeaderRows { get; public set; }
    public int FooterRows { get; public set; }
    public IList`1<Chunk> Chunks { get; }
    public int Type { get; }
    public float WidthPercentage { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public List`1<PdfPRow> Rows { get; }
    public IPdfPTableEvent TableEvent { get; public set; }
    public Single[] AbsoluteWidths { get; }
    public bool SkipFirstHeader { get; public set; }
    public bool SkipLastFooter { get; public set; }
    public int RunDirection { get; public set; }
    public bool LockedWidth { get; public set; }
    public bool SplitRows { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float PaddingTop { get; public set; }
    public string Summary { get; public set; }
    public bool ExtendLastRow { get; public set; }
    public bool HeadersInEvent { get; public set; }
    public bool SplitLate { get; public set; }
    public bool KeepTogether { get; public set; }
    public bool ElementComplete { get; public set; }
    public bool LoopCheck { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public PdfPTable(Single[] relativeWidths);
    public PdfPTable(int numColumns);
    public PdfPTable(PdfPTable table);
    public virtual bool get_Complete();
    public virtual void set_Complete(bool value);
    public virtual void Init();
    public static PdfPTable ShallowCopy(PdfPTable table);
    protected internal virtual void CopyFormat(PdfPTable sourceTable);
    public virtual void SetWidths(Single[] relativeWidths);
    public virtual void SetWidths(Int32[] relativeWidths);
    protected internal virtual void CalculateWidths();
    public virtual void SetTotalWidth(Single[] columnWidth);
    public virtual void SetWidthPercentage(Single[] columnWidth, Rectangle pageSize);
    public virtual float get_TotalWidth();
    public virtual void set_TotalWidth(float value);
    public virtual float CalculateHeights();
    public virtual void ResetColumnCount(int newColCount);
    public virtual PdfPCell get_DefaultCell();
    public virtual PdfPCell AddCell(PdfPCell cell);
    private void SkipColsWithRowspanAbove();
    internal PdfPCell CellAt(int row, int col);
    internal bool RowSpanAbove(int currRow, int currCol);
    public virtual void AddCell(string text);
    public virtual void AddCell(PdfPTable table);
    public virtual void AddCell(Image image);
    public virtual void AddCell(Phrase phrase);
    public virtual float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases, bool reusable);
    private PdfPTableBody OpenTableBlock(PdfPTableBody block, PdfContentByte canvas);
    private PdfPTableBody CloseTableBlock(PdfPTableBody block, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public virtual float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas, bool reusable);
    public static PdfContentByte[] BeginWritingRows(PdfContentByte canvas);
    public static void EndWritingRows(PdfContentByte[] canvases);
    public virtual int get_Size();
    public virtual float get_TotalHeight();
    public virtual float GetRowHeight(int idx);
    protected internal virtual float GetRowHeight(int idx, bool firsttime);
    public virtual float GetRowspanHeight(int rowIndex, int cellIndex);
    public virtual bool HasRowspan(int rowIdx);
    public virtual void NormalizeHeadersFooters();
    public virtual float get_HeaderHeight();
    public virtual float get_FooterHeight();
    public virtual bool DeleteRow(int rowNumber);
    public virtual bool DeleteLastRow();
    public virtual void DeleteBodyRows();
    public virtual int get_NumberOfColumns();
    public virtual int get_HeaderRows();
    public virtual void set_HeaderRows(int value);
    public virtual int get_FooterRows();
    public virtual void set_FooterRows(int value);
    public virtual IList`1<Chunk> get_Chunks();
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual bool Process(IElementListener listener);
    public virtual float get_WidthPercentage();
    public virtual void set_WidthPercentage(float value);
    public virtual int get_HorizontalAlignment();
    public virtual void set_HorizontalAlignment(int value);
    public virtual PdfPRow GetRow(int idx);
    public virtual int getLastCompletedRowIndex();
    public virtual void SetBreakPoints(Int32[] breakPoints);
    public virtual void KeepRowsTogether(Int32[] rows);
    public virtual void KeepRowsTogether(int start, int end);
    public virtual void KeepRowsTogether(int start);
    public virtual List`1<PdfPRow> get_Rows();
    public virtual List`1<PdfPRow> GetRows(int start, int end);
    protected virtual PdfPRow AdjustCellsInRow(int start, int end);
    public virtual IPdfPTableEvent get_TableEvent();
    public virtual void set_TableEvent(IPdfPTableEvent value);
    public virtual Single[] get_AbsoluteWidths();
    internal Single[][] GetEventWidths(float xPos, int firstRow, int lastRow, bool includeHeaders);
    public virtual bool get_SkipFirstHeader();
    public virtual void set_SkipFirstHeader(bool value);
    public virtual bool get_SkipLastFooter();
    public virtual void set_SkipLastFooter(bool value);
    public virtual int get_RunDirection();
    public virtual void set_RunDirection(int value);
    public virtual bool get_LockedWidth();
    public virtual void set_LockedWidth(bool value);
    public virtual bool get_SplitRows();
    public virtual void set_SplitRows(bool value);
    public virtual float get_SpacingBefore();
    public virtual void set_SpacingBefore(float value);
    public virtual float get_SpacingAfter();
    public virtual void set_SpacingAfter(float value);
    public virtual float get_PaddingTop();
    public virtual void set_PaddingTop(float value);
    public virtual string get_Summary();
    public virtual void set_Summary(string value);
    public virtual bool get_ExtendLastRow();
    public virtual void set_ExtendLastRow(bool value);
    public virtual void SetExtendLastRow(bool extendLastRows, bool extendFinalRow);
    public virtual bool IsExtendLastRow(bool newPageFollows);
    public virtual bool get_HeadersInEvent();
    public virtual void set_HeadersInEvent(bool value);
    public virtual bool get_SplitLate();
    public virtual void set_SplitLate(bool value);
    public virtual void set_KeepTogether(bool value);
    public virtual bool get_KeepTogether();
    public virtual void CompleteRow();
    public virtual void FlushContent();
    internal virtual void AddNumberOfRowsWritten(int numberOfWrittenRows);
    public virtual bool get_ElementComplete();
    public virtual void set_ElementComplete(bool value);
    public virtual bool get_LoopCheck();
    public virtual void set_LoopCheck(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
    public virtual PdfPTableHeader GetHeader();
    public virtual PdfPTableBody GetBody();
    public virtual PdfPTableFooter GetFooter();
    public virtual int GetCellStartRowIndex(int rowIdx, int colIdx);
    public virtual FittingRows GetFittingRows(float availableHeight, int startIdx);
}
public class iTextSharp.text.pdf.PdfPTableBody : object {
    protected AccessibleElementId id;
    protected internal List`1<PdfPRow> rows;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfPTableFooter : PdfPTableBody {
    public PdfName Role { get; public set; }
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPTableHeader : PdfPTableBody {
    public PdfName Role { get; public set; }
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
}
public class iTextSharp.text.pdf.PdfPublicKeyRecipient : object {
    private X509Certificate certificate;
    private int permission;
    protected Byte[] cms;
    public X509Certificate Certificate { get; }
    public int Permission { get; }
    protected internal Byte[] Cms { get; protected internal set; }
    public PdfPublicKeyRecipient(X509Certificate certificate, int permission);
    public virtual X509Certificate get_Certificate();
    public virtual int get_Permission();
    protected internal virtual void set_Cms(Byte[] value);
    protected internal virtual Byte[] get_Cms();
}
public class iTextSharp.text.pdf.PdfPublicKeySecurityHandler : object {
    private static int SEED_LENGTH;
    private List`1<PdfPublicKeyRecipient> recipients;
    private Byte[] seed;
    public virtual void AddRecipient(PdfPublicKeyRecipient recipient);
    protected internal virtual Byte[] GetSeed();
    public virtual int GetRecipientsSize();
    public virtual Byte[] GetEncodedRecipient(int index);
    public virtual PdfArray GetEncodedRecipients();
    private Asn1Object CreateDERForRecipient(Byte[] inp, X509Certificate cert);
    private KeyTransRecipientInfo ComputeRecipientInfo(X509Certificate x509certificate, Byte[] abyte0);
}
public class iTextSharp.text.pdf.PdfReader : object {
    public static bool unethicalreading;
    public static bool debugmode;
    private static ILogger LOGGER;
    private static PdfName[] pageInhCandidates;
    private static Byte[] endstream;
    private static Byte[] endobj;
    protected internal PRTokeniser tokens;
    protected internal Int64[] xref;
    protected internal Dictionary`2<int, IntHashtable> objStmMark;
    protected internal LongHashtable objStmToOffset;
    protected internal bool newXrefType;
    protected List`1<PdfObject> xrefObj;
    private PdfDictionary rootPages;
    protected internal PdfDictionary trailer;
    protected internal PdfDictionary catalog;
    protected internal PageRefs pageRefs;
    protected internal PRAcroForm acroForm;
    protected internal bool acroFormParsed;
    protected internal bool encrypted;
    protected internal bool rebuilt;
    protected internal int freeXref;
    protected internal bool tampered;
    protected internal long lastXref;
    protected internal long eofPos;
    protected internal char pdfVersion;
    protected internal PdfEncryption decrypt;
    protected internal Byte[] password;
    protected ICipherParameters certificateKey;
    protected X509Certificate certificate;
    private bool ownerPasswordUsed;
    protected internal List`1<PdfString> strings;
    protected internal bool sharedStreams;
    protected internal bool consolidateNamedDestinations;
    protected bool remoteToLocalNamedDestinations;
    protected internal int rValue;
    protected internal long pValue;
    private int objNum;
    private int objGen;
    private long fileLength;
    private bool hybridXref;
    private int lastXrefPartial;
    private bool partial;
    private PRIndirectReference cryptoRef;
    private PdfViewerPreferencesImp viewerPreferences;
    private bool encryptionError;
    internal MemoryLimitsAwareHandler memoryLimitsAwareHandler;
    private bool appendable;
    protected static ICounter COUNTER;
    private int readDepth;
    public RandomAccessFileOrArray SafeFile { get; }
    public int NumberOfPages { get; }
    public PdfDictionary Catalog { get; }
    public PRAcroForm AcroForm { get; }
    public Dictionary`2<string, string> Info { get; }
    public bool Tampered { get; public set; }
    public Byte[] Metadata { get; }
    public long LastXref { get; }
    public int XrefSize { get; }
    public long EofPos { get; }
    public char PdfVersion { get; }
    public long Permissions { get; }
    public PdfDictionary Trailer { get; }
    internal PdfEncryption Decrypt { get; }
    public AcroFields AcroFields { get; }
    public string JavaScript { get; }
    unknown int ViewerPreferences {public set; }
    public int SimpleViewerPreferences { get; }
    public bool Appendable { get; public set; }
    public long FileLength { get; }
    public bool IsOpenedWithFullPermissions { get; }
    private PdfReader(IRandomAccessSource byteSource, bool partialRead, Byte[] ownerPassword, X509Certificate certificate, ICipherParameters certificateKey, bool closeSourceOnConstructorError);
    private PdfReader(ReaderProperties properties, IRandomAccessSource byteSource);
    public PdfReader(string filename);
    public PdfReader(ReaderProperties properties, string filename);
    public PdfReader(string filename, Byte[] ownerPassword);
    public PdfReader(string filename, Byte[] ownerPassword, bool partial);
    public PdfReader(Byte[] pdfIn);
    public PdfReader(Byte[] pdfIn, Byte[] ownerPassword);
    public PdfReader(string filename, X509Certificate certificate, ICipherParameters certificateKey);
    public PdfReader(Uri url);
    public PdfReader(Uri url, Byte[] ownerPassword);
    public PdfReader(Stream isp, Byte[] ownerPassword);
    public PdfReader(ReaderProperties properties, Stream isp);
    public PdfReader(Stream isp);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword, bool partial);
    public PdfReader(PdfReader reader);
    private static PdfReader();
    protected virtual ICounter GetCounter();
    internal MemoryLimitsAwareHandler GetMemoryLimitsAwareHandler();
    private static PRTokeniser GetOffsetTokeniser(IRandomAccessSource byteSource);
    public virtual RandomAccessFileOrArray get_SafeFile();
    protected internal virtual PdfReaderInstance GetPdfReaderInstance(PdfWriter writer);
    public virtual int get_NumberOfPages();
    public virtual PdfDictionary get_Catalog();
    public virtual PRAcroForm get_AcroForm();
    public virtual int GetPageRotation(int index);
    internal int GetPageRotation(PdfDictionary page);
    public virtual Rectangle GetPageSizeWithRotation(int index);
    public virtual Rectangle GetPageSizeWithRotation(PdfDictionary page);
    public virtual Rectangle GetPageSize(int index);
    public virtual Rectangle GetPageSize(PdfDictionary page);
    public virtual Rectangle GetCropBox(int index);
    public virtual Rectangle GetBoxSize(int index, string boxName);
    public virtual Dictionary`2<string, string> get_Info();
    public static Rectangle GetNormalizedRectangle(PdfArray box);
    public virtual bool IsTagged();
    protected internal virtual void ReadPdf();
    protected internal virtual void ReadPdfPartial();
    private bool EqualsArray(Byte[] ar1, Byte[] ar2, int size);
    private void ReadDecryptedDocObj();
    public static PdfObject GetPdfObjectRelease(PdfObject obj);
    public static PdfObject GetPdfObject(PdfObject obj);
    public static PdfObject GetPdfObjectRelease(PdfObject obj, PdfObject parent);
    public static PdfObject GetPdfObject(PdfObject obj, PdfObject parent);
    public virtual PdfObject GetPdfObjectRelease(int idx);
    public virtual PdfObject GetPdfObject(int idx);
    public virtual void ResetLastXrefPartial();
    public virtual void ReleaseLastXrefPartial();
    public static void ReleaseLastXrefPartial(PdfObject obj);
    private void SetXrefPartialObject(int idx, PdfObject obj);
    public virtual PRIndirectReference AddPdfObject(PdfObject obj);
    protected internal virtual void ReadPages();
    protected internal virtual void ReadDocObjPartial();
    protected internal virtual PdfObject ReadSingleObject(int k);
    protected internal virtual PdfObject ReadOneObjStm(PRStream stream, int idx);
    public virtual double DumpPerc();
    protected internal virtual void ReadDocObj();
    private void CheckPRStreamLength(PRStream stream);
    protected internal virtual void ReadObjStm(PRStream stream, IntHashtable map);
    public static PdfObject KillIndirect(PdfObject obj);
    private void EnsureXrefSize(int size);
    protected internal virtual void ReadXref();
    protected internal virtual PdfDictionary ReadXrefSection();
    protected internal virtual bool ReadXRefStream(long ptr);
    protected internal virtual void RebuildXref();
    protected internal virtual PdfDictionary ReadDictionary();
    protected internal virtual PdfArray ReadArray();
    protected internal virtual PdfObject ReadPRObject();
    public static Byte[] FlateDecode(Byte[] inp);
    internal static Byte[] FlateDecode(Byte[] inp, MemoryStream outS);
    public static Byte[] DecodePredictor(Byte[] inp, PdfObject dicPar);
    public static Byte[] FlateDecode(Byte[] inp, bool strict);
    internal static Byte[] FlateDecode(Byte[] inp, bool strict, MemoryStream outp);
    public static Byte[] ASCIIHexDecode(Byte[] inp);
    internal static Byte[] ASCIIHexDecode(Byte[] inp, MemoryStream outp);
    public static Byte[] ASCII85Decode(Byte[] inp);
    internal static Byte[] ASCII85Decode(Byte[] inp, MemoryStream outp);
    public static Byte[] LZWDecode(Byte[] inp);
    internal static Byte[] LZWDecode(Byte[] inp, MemoryStream outp);
    public virtual bool IsRebuilt();
    public virtual PdfDictionary GetPageN(int pageNum);
    public virtual PdfDictionary GetPageNRelease(int pageNum);
    public virtual void ReleasePage(int pageNum);
    public virtual void ResetReleasePage();
    public virtual PRIndirectReference GetPageOrigRef(int pageNum);
    public virtual Byte[] GetPageContent(int pageNum, RandomAccessFileOrArray file);
    public static Byte[] GetPageContent(PdfDictionary page);
    public virtual PdfDictionary GetPageResources(int pageNum);
    public virtual PdfDictionary GetPageResources(PdfDictionary pageDict);
    public virtual Byte[] GetPageContent(int pageNum);
    protected internal virtual void KillXref(PdfObject obj);
    public virtual void SetPageContent(int pageNum, Byte[] content);
    public virtual void SetPageContent(int pageNum, Byte[] content, int compressionLevel, bool killOldXRefRecursively);
    public static Byte[] DecodeBytes(Byte[] b, PdfDictionary streamDictionary);
    public static Byte[] DecodeBytes(Byte[] b, PdfDictionary streamDictionary, IDictionary`2<PdfName, IFilterHandler> filterHandlers);
    public static Byte[] GetStreamBytes(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytes(PRStream stream);
    public static Byte[] GetStreamBytesRaw(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytesRaw(PRStream stream);
    public virtual void EliminateSharedStreams();
    public virtual bool get_Tampered();
    public virtual void set_Tampered(bool value);
    public virtual Byte[] get_Metadata();
    public virtual long get_LastXref();
    public virtual int get_XrefSize();
    public virtual long get_EofPos();
    public virtual char get_PdfVersion();
    public virtual bool IsEncrypted();
    public virtual long get_Permissions();
    public virtual bool Is128Key();
    public virtual PdfDictionary get_Trailer();
    internal PdfEncryption get_Decrypt();
    internal static bool Equalsn(Byte[] a1, Byte[] a2);
    internal static bool ExistsName(PdfDictionary dic, PdfName key, PdfName value);
    internal static string GetFontName(PdfDictionary dic);
    internal static string GetSubsetPrefix(PdfDictionary dic);
    public virtual int ShuffleSubsetNames();
    public virtual int CreateFakeFontSubsets();
    private static PdfArray GetNameArray(PdfObject obj);
    public virtual Dictionary`2<object, PdfObject> GetNamedDestination();
    public virtual Dictionary`2<object, PdfObject> GetNamedDestination(bool keepNames);
    public virtual Dictionary`2<string, PdfObject> GetNamedDestinationFromNames();
    public virtual Dictionary`2<object, PdfObject> GetNamedDestinationFromNames(bool keepNames);
    public virtual Dictionary`2<string, PdfObject> GetNamedDestinationFromStrings();
    public virtual void RemoveFields();
    public virtual void RemoveAnnotations();
    public virtual List`1<PdfImportedLink> GetLinks(int page);
    private void IterateBookmarks(PdfObject outlineRef, Dictionary`2<object, PdfObject> names);
    public virtual void MakeRemoteNamedDestinationsLocal();
    private bool ConvertNamedDestination(PdfObject obj, Dictionary`2<object, PdfObject> names);
    public virtual void ConsolidateNamedDestinations();
    private bool ReplaceNamedDestination(PdfObject obj, Dictionary`2<object, PdfObject> names);
    protected internal static PdfDictionary DuplicatePdfDictionary(PdfDictionary original, PdfDictionary copy, PdfReader newReader);
    protected internal static PdfObject DuplicatePdfObject(PdfObject original, PdfReader newReader);
    public virtual void Close();
    protected internal virtual void RemoveUnusedNode(PdfObject obj, Boolean[] hits);
    public virtual int RemoveUnusedObjects();
    public virtual AcroFields get_AcroFields();
    public virtual string GetJavaScript(RandomAccessFileOrArray file);
    public virtual string get_JavaScript();
    public virtual void SelectPages(string ranges);
    public virtual void SelectPages(ICollection`1<int> pagesToKeep);
    internal void SelectPages(ICollection`1<int> pagesToKeep, bool removeUnused);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void SetViewerPreferences(PdfViewerPreferencesImp vp);
    public virtual int get_SimpleViewerPreferences();
    public virtual void set_Appendable(bool value);
    public virtual bool get_Appendable();
    public virtual bool IsNewXrefType();
    public virtual long get_FileLength();
    public virtual bool IsHybridXref();
    internal PdfIndirectReference GetCryptoRef();
    public virtual bool HasUsageRights();
    public virtual void RemoveUsageRights();
    public virtual int GetCertificationLevel();
    public bool get_IsOpenedWithFullPermissions();
    public virtual int GetCryptoMode();
    public virtual bool IsMetadataEncrypted();
    public virtual Byte[] ComputeUserPassword();
    public virtual void Dispose();
}
public class iTextSharp.text.pdf.PdfReaderInstance : object {
    internal static PdfLiteral IDENTITYMATRIX;
    internal static PdfNumber ONE;
    internal Int32[] myXref;
    internal PdfReader reader;
    internal RandomAccessFileOrArray file;
    internal Dictionary`2<int, PdfImportedPage> importedPages;
    internal PdfWriter writer;
    internal Dictionary`2<int, object> visited;
    internal List`1<int> nextRound;
    internal PdfReader Reader { get; }
    internal RandomAccessFileOrArray ReaderFile { get; }
    internal PdfReaderInstance(PdfReader reader, PdfWriter writer);
    private static PdfReaderInstance();
    internal PdfReader get_Reader();
    internal PdfImportedPage GetImportedPage(int pageNumber);
    internal int GetNewObjectNumber(int number, int generation);
    internal RandomAccessFileOrArray get_ReaderFile();
    internal PdfObject GetResources(int pageNumber);
    internal PdfStream GetFormXObject(int pageNumber, int compressionLevel);
    internal void WriteAllVisited();
    public virtual void WriteAllPages();
}
public class iTextSharp.text.pdf.PdfRectangle : NumberArray {
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public Rectangle Rectangle { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public float Width { get; }
    public float Height { get; }
    public PdfRectangle Rotate { get; }
    public PdfRectangle(float llx, float lly, float urx, float ury, int rotation);
    public PdfRectangle(float llx, float lly, float urx, float ury);
    public PdfRectangle(float urx, float ury, int rotation);
    public PdfRectangle(float urx, float ury);
    public PdfRectangle(Rectangle rectangle, int rotation);
    public PdfRectangle(Rectangle rectangle);
    public virtual Rectangle get_Rectangle();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void AddFirst(PdfObject obj);
    public virtual float get_Left();
    public virtual float get_Right();
    public virtual float get_Top();
    public virtual float get_Bottom();
    public virtual float GetLeft(int margin);
    public virtual float GetRight(int margin);
    public virtual float GetTop(int margin);
    public virtual float GetBottom(int margin);
    public virtual float get_Width();
    public virtual float get_Height();
    public virtual PdfRectangle get_Rotate();
    [ObsoleteAttribute]
public PdfRectangle Transform(Matrix transform);
    public virtual PdfRectangle Transform(AffineTransform transform);
}
public class iTextSharp.text.pdf.PdfRendition : PdfDictionary {
    public PdfRendition(string file, PdfFileSpecification fs, string mimeType);
}
internal class iTextSharp.text.pdf.PdfResources : PdfDictionary {
    internal void Add(PdfName key, PdfDictionary resource);
}
public class iTextSharp.text.pdf.PdfShading : object {
    protected PdfDictionary shading;
    protected PdfWriter writer;
    protected int shadingType;
    protected ColorDetails colorDetails;
    protected PdfName shadingName;
    protected PdfIndirectReference shadingReference;
    protected Single[] bBox;
    protected bool antiAlias;
    private BaseColor cspace;
    public BaseColor ColorSpace { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    internal PdfWriter Writer { get; }
    internal ColorDetails ColorDetails { get; }
    public Single[] BBox { get; public set; }
    public bool AntiAlias { get; public set; }
    protected PdfShading(PdfWriter writer);
    protected virtual void SetColorSpace(BaseColor color);
    public virtual BaseColor get_ColorSpace();
    public static void ThrowColorSpaceError();
    public static void CheckCompatibleColors(BaseColor c1, BaseColor c2);
    public static Single[] GetColorArray(BaseColor color);
    public static PdfShading Type1(PdfWriter writer, BaseColor colorSpace, Single[] domain, Single[] tMatrix, PdfFunction function);
    public static PdfShading Type2(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading Type3(PdfWriter writer, BaseColor colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, BaseColor startColor, BaseColor endColor);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, BaseColor startColor, BaseColor endColor);
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    public virtual void AddToBody();
    internal PdfWriter get_Writer();
    internal ColorDetails get_ColorDetails();
    public virtual Single[] get_BBox();
    public virtual void set_BBox(Single[] value);
    public virtual void set_AntiAlias(bool value);
    public virtual bool get_AntiAlias();
}
public class iTextSharp.text.pdf.PdfShadingPattern : PdfDictionary {
    protected PdfShading shading;
    protected PdfWriter writer;
    protected Single[] matrix;
    protected PdfName patternName;
    protected PdfIndirectReference patternReference;
    internal PdfName PatternName { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference PatternReference { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    public Single[] Matrix { get; public set; }
    public PdfShading Shading { get; }
    internal ColorDetails ColorDetails { get; }
    public PdfShadingPattern(PdfShading shading);
    internal PdfName get_PatternName();
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_PatternReference();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    public virtual void AddToBody();
    public virtual Single[] get_Matrix();
    public virtual void set_Matrix(Single[] value);
    public virtual PdfShading get_Shading();
    internal ColorDetails get_ColorDetails();
}
public class iTextSharp.text.pdf.PdfSigLockDictionary : PdfDictionary {
    public PdfSigLockDictionary(LockPermissions p);
    public PdfSigLockDictionary(LockAction action, String[] fields);
    public PdfSigLockDictionary(LockAction action, LockPermissions p, String[] fields);
}
public class iTextSharp.text.pdf.PdfSignature : PdfDictionary {
    unknown Int32[] ByteRange {public set; }
    unknown Byte[] Contents {public set; }
    unknown Byte[] Cert {public set; }
    unknown string Name {public set; }
    unknown PdfDate Date {public set; }
    unknown string Location {public set; }
    unknown string Reason {public set; }
    unknown string SignatureCreator {public set; }
    private PdfSignatureBuildProperties PdfSignatureBuildProperties { get; }
    unknown string Contact {public set; }
    public PdfSignature(PdfName filter, PdfName subFilter);
    public virtual void set_ByteRange(Int32[] value);
    public virtual void set_Contents(Byte[] value);
    public virtual void set_Cert(Byte[] value);
    public virtual void set_Name(string value);
    public virtual void set_Date(PdfDate value);
    public virtual void set_Location(string value);
    public virtual void set_Reason(string value);
    public virtual void set_SignatureCreator(string value);
    private PdfSignatureBuildProperties get_PdfSignatureBuildProperties();
    public virtual void set_Contact(string value);
}
public class iTextSharp.text.pdf.PdfSignatureAppearance : object {
    public static int NOT_CERTIFIED;
    public static int CERTIFIED_NO_CHANGES_ALLOWED;
    public static int CERTIFIED_FORM_FILLING;
    public static int CERTIFIED_FORM_FILLING_AND_ANNOTATIONS;
    private int certificationLevel;
    private string reasonCaption;
    private string locationCaption;
    private string reason;
    private string location;
    private DateTime signDate;
    private string signatureCreator;
    private string contact;
    private FileStream raf;
    private Byte[] bout;
    private Int64[] range;
    private X509Certificate signCertificate;
    private PdfDictionary cryptoDictionary;
    private ISignatureEvent signatureEvent;
    private string fieldName;
    private int page;
    private Rectangle rect;
    private Rectangle pageRect;
    private RenderingMode renderingMode;
    private Image signatureGraphic;
    private bool acro6Layers;
    private PdfTemplate[] app;
    private bool reuseAppearance;
    public static string questionMark;
    private Image image;
    private float imageScale;
    private string layer2Text;
    private Font layer2Font;
    private int runDirection;
    private string layer4Text;
    private PdfTemplate frm;
    private static float TOP_SECTION;
    private static float MARGIN;
    private PdfStamper stamper;
    private PdfStamperImp writer;
    private ByteBuffer sigout;
    private Stream originalout;
    private string tempFile;
    private Dictionary`2<PdfName, PdfLiteral> exclusionLocations;
    private int boutLen;
    private bool preClosed;
    private PdfSigLockDictionary fieldLock;
    public int CertificationLevel { get; public set; }
    public string Reason { get; public set; }
    unknown string ReasonCaption {public set; }
    public string Location { get; public set; }
    unknown string LocationCaption {public set; }
    public string SignatureCreator { get; public set; }
    public string Contact { get; public set; }
    public DateTime SignDate { get; public set; }
    public PdfDictionary CryptoDictionary { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public ISignatureEvent SignatureEvent { get; public set; }
    public string FieldName { get; }
    public int Page { get; }
    public Rectangle Rect { get; }
    public Rectangle PageRect { get; }
    public RenderingMode SignatureRenderingMode { get; public set; }
    public Image SignatureGraphic { get; public set; }
    public bool Acro6Layers { get; public set; }
    unknown bool ReuseAppearance {public set; }
    public Image Image { get; public set; }
    public float ImageScale { get; public set; }
    public string Layer2Text { get; public set; }
    public Font Layer2Font { get; public set; }
    public int RunDirection { get; public set; }
    public string Layer4Text { get; public set; }
    public PdfStamper Stamper { get; }
    public ByteBuffer Sigout { get; public set; }
    public Stream Originalout { get; public set; }
    public string TempFile { get; }
    public PdfSigLockDictionary FieldLockDict { get; public set; }
    public PdfSignatureAppearance(PdfStamperImp writer);
    public virtual int get_CertificationLevel();
    public virtual void set_CertificationLevel(int value);
    public virtual string get_Reason();
    public virtual void set_Reason(string value);
    public virtual void set_ReasonCaption(string value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public virtual void set_LocationCaption(string value);
    public virtual string get_SignatureCreator();
    public virtual void set_SignatureCreator(string value);
    public virtual string get_Contact();
    public virtual void set_Contact(string value);
    public virtual DateTime get_SignDate();
    public virtual void set_SignDate(DateTime value);
    public virtual Stream GetRangeStream();
    private IRandomAccessSource GetUnderlyingSource();
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    public virtual PdfDictionary get_CryptoDictionary();
    public virtual void set_CryptoDictionary(PdfDictionary value);
    public virtual X509Certificate get_Certificate();
    public virtual void set_Certificate(X509Certificate value);
    public virtual ISignatureEvent get_SignatureEvent();
    public virtual void set_SignatureEvent(ISignatureEvent value);
    public virtual string get_FieldName();
    public virtual string GetNewSigName();
    public virtual int get_Page();
    public virtual Rectangle get_Rect();
    public virtual Rectangle get_PageRect();
    public virtual bool IsInvisible();
    public virtual void SetVisibleSignature(Rectangle pageRect, int page, string fieldName);
    public virtual void SetVisibleSignature(string fieldName);
    public virtual RenderingMode get_SignatureRenderingMode();
    public virtual void set_SignatureRenderingMode(RenderingMode value);
    public virtual Image get_SignatureGraphic();
    public virtual void set_SignatureGraphic(Image value);
    public virtual bool get_Acro6Layers();
    public virtual void set_Acro6Layers(bool value);
    public virtual PdfTemplate GetLayer(int layer);
    public virtual void set_ReuseAppearance(bool value);
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual float get_ImageScale();
    public virtual void set_ImageScale(float value);
    public virtual string get_Layer2Text();
    public virtual void set_Layer2Text(string value);
    public virtual Font get_Layer2Font();
    public virtual void set_Layer2Font(Font value);
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public virtual string get_Layer4Text();
    public virtual void set_Layer4Text(string value);
    public virtual PdfTemplate GetTopLayer();
    public virtual PdfTemplate GetAppearance();
    private void CreateBlankN0();
    public virtual PdfStamper get_Stamper();
    public virtual void SetStamper(PdfStamper stamper);
    public virtual ByteBuffer get_Sigout();
    public virtual void set_Sigout(ByteBuffer value);
    public virtual Stream get_Originalout();
    public virtual void set_Originalout(Stream value);
    public virtual string get_TempFile();
    public virtual void SetTempFile(string tempFile);
    public virtual PdfSigLockDictionary get_FieldLockDict();
    public virtual void set_FieldLockDict(PdfSigLockDictionary value);
    public virtual bool IsPreClosed();
    public virtual void PreClose(Dictionary`2<PdfName, int> exclusionSizes);
    private void AddDocMDP(PdfDictionary crypto);
    private void AddFieldMDP(PdfDictionary crypto, PdfDictionary fieldLock);
    public virtual void Close(PdfDictionary update);
}
public class iTextSharp.text.pdf.PdfSmartCopy : PdfCopy {
    private static ILogger LOGGER;
    private Dictionary`2<ByteStore, PdfIndirectReference> streamMap;
    private Dictionary`2<RefKey, int> serialized;
    protected ICounter COUNTER;
    public PdfSmartCopy(Document document, Stream os);
    private static PdfSmartCopy();
    protected virtual ICounter GetCounter();
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
    public virtual void FreeReader(PdfReader reader);
    public virtual void AddPage(PdfImportedPage iPage);
}
public class iTextSharp.text.pdf.PdfSpotColor : object {
    public PdfName name;
    public BaseColor altcs;
    public ColorDetails altColorDetails;
    public BaseColor AlternativeCS { get; }
    public PdfName Name { get; }
    public PdfSpotColor(string name, BaseColor altcs);
    public virtual ColorDetails[] GetColorantDetails(PdfWriter writer);
    public virtual BaseColor get_AlternativeCS();
    public virtual PdfName get_Name();
    [ObsoleteAttribute]
protected internal virtual PdfObject GetSpotObject(PdfWriter writer);
    public virtual PdfObject GetPdfObject(PdfWriter writer);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfStamper : object {
    protected PdfStamperImp stamper;
    private IDictionary`2<string, string> moreInfo;
    protected internal bool hasSignature;
    protected PdfSignatureAppearance sigApp;
    protected XmlSignatureAppearance sigXmlApp;
    private LtvVerification verification;
    public IDictionary`2<string, string> MoreInfo { get; public set; }
    public PdfSignatureAppearance SignatureAppearance { get; }
    public XmlSignatureAppearance XmlSignatureAppearance { get; }
    public bool RotateContents { get; public set; }
    public PdfWriter Writer { get; }
    public PdfReader Reader { get; }
    public AcroFields AcroFields { get; }
    unknown bool FormFlattening {public set; }
    unknown bool FreeTextFlattening {public set; }
    unknown bool AnnotationFlattening {public set; }
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    unknown string JavaScript {public set; }
    unknown int ViewerPreferences {public set; }
    unknown Byte[] XmpMetadata {public set; }
    public XmpWriter XmpWriter { get; }
    public bool FullCompression { get; }
    public LtvVerification LtvVerification { get; }
    public PdfStamper(PdfReader reader, Stream os);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion, bool append);
    public virtual void set_MoreInfo(IDictionary`2<string, string> value);
    public virtual IDictionary`2<string, string> get_MoreInfo();
    public virtual void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    public virtual void InsertPage(int pageNumber, Rectangle mediabox);
    public virtual PdfSignatureAppearance get_SignatureAppearance();
    public virtual XmlSignatureAppearance get_XmlSignatureAppearance();
    public virtual void Close();
    public virtual PdfContentByte GetUnderContent(int pageNum);
    public virtual PdfContentByte GetOverContent(int pageNum);
    public virtual void set_RotateContents(bool value);
    public virtual bool get_RotateContents();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual PdfWriter get_Writer();
    public virtual PdfReader get_Reader();
    public virtual AcroFields get_AcroFields();
    public virtual void set_FormFlattening(bool value);
    public virtual void set_FreeTextFlattening(bool value);
    public virtual void set_AnnotationFlattening(bool value);
    public virtual void AddAnnotation(PdfAnnotation annot, int page);
    public virtual PdfFormField AddSignature(string name, int page, float llx, float lly, float urx, float ury);
    public virtual void AddComments(FdfReader fdf);
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    public virtual void SetThumbnail(Image image, int page);
    public virtual bool PartialFormFlattening(string name);
    public virtual void set_JavaScript(string value);
    public virtual void AddJavaScript(string name, string js);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public virtual void MakePackage(PdfName initialView);
    public virtual void MakePackage(PdfCollection collection);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual void CreateXmpMetadata();
    public virtual XmpWriter get_XmpWriter();
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void SetPageAction(PdfName actionType, PdfAction action, int page);
    public virtual void SetDuration(int seconds, int page);
    public virtual void SetTransition(PdfTransition transition, int page);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile, bool append);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile);
    public static PdfStamper createXmlSignature(PdfReader reader, Stream os);
    public virtual Dictionary`2<string, PdfLayer> GetPdfLayers();
    public virtual void Dispose();
    public virtual void MarkUsed(PdfObject obj);
    public virtual LtvVerification get_LtvVerification();
    internal void MergeVerification();
}
public class iTextSharp.text.pdf.PdfStamperImp : PdfWriter {
    internal Dictionary`2<PdfReader, IntHashtable> readers2intrefs;
    internal Dictionary`2<PdfReader, RandomAccessFileOrArray> readers2file;
    protected internal RandomAccessFileOrArray file;
    protected internal PdfReader reader;
    internal IntHashtable myXref;
    internal Dictionary`2<PdfDictionary, PageStamp> pagesToContent;
    protected internal bool closed;
    private bool rotateContents;
    protected AcroFields acroFields;
    protected bool flat;
    protected bool flatFreeText;
    protected bool flatannotations;
    protected Int32[] namePtr;
    protected HashSet2`1<string> partialFlattening;
    protected bool useVp;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected HashSet2`1<PdfTemplate> fieldTemplates;
    protected bool fieldsAdded;
    protected int sigFlags;
    protected internal bool append;
    protected IntHashtable marked;
    protected int initialXrefSize;
    protected PdfAction openAction;
    private Dictionary`2<string, PdfIndirectReference> builtInAnnotationFonts;
    private static Dictionary`2<string, string> fromShortToFullAnnotationFontNames;
    private Double[] DEFAULT_MATRIX;
    protected ICounter COUNTER;
    private ILogger logger;
    private bool originalLayersAreRead;
    internal bool RotateContents { get; internal set; }
    internal bool ContentWritten { get; }
    unknown bool FormFlattening {internal set; }
    unknown bool FreeTextFlattening {internal set; }
    unknown bool FlatAnnotations {public set; }
    unknown int ViewerPreferences {public set; }
    unknown int SigFlags {public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    private static PdfStamperImp();
    protected internal PdfStamperImp(PdfReader reader, Stream os, char pdfVersion, bool append);
    protected virtual ICounter GetCounter();
    protected virtual void ReadColorProfile();
    protected virtual void SetViewerPreferences();
    protected internal virtual void Close(IDictionary`2<string, string> moreInfo);
    protected virtual void Close(PdfIndirectReference info, int skipInfo);
    internal void ApplyRotation(PdfDictionary pageN, ByteBuffer out_p);
    protected internal virtual void AlterContents();
    internal void AlterResources(PageStamp ps);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public virtual void RegisterReader(PdfReader reader, bool openFile);
    public virtual void UnRegisterReader(PdfReader reader);
    internal static void FindAllObjects(PdfReader reader, PdfObject obj, IntHashtable hits);
    public virtual void AddComments(FdfReader fdf);
    internal PageStamp GetPageStamp(int pageNum);
    internal PdfContentByte GetUnderContent(int pageNum);
    internal PdfContentByte GetOverContent(int pageNum);
    internal void CorrectAcroFieldPages(int page);
    private static void MoveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, string name);
    internal void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    internal void InsertPage(int pageNumber, Rectangle mediabox);
    internal void set_RotateContents(bool value);
    internal bool get_RotateContents();
    internal bool get_ContentWritten();
    internal AcroFields GetAcroFields();
    internal void set_FormFlattening(bool value);
    internal void set_FreeTextFlattening(bool value);
    internal bool PartialFormFlattening(string name);
    protected internal virtual void FlatFields();
    internal void EliminateAcroformObjects();
    internal AffineTransform CalculateTemplateTransformationMatrix(AffineTransform currentMatrix, double fieldRotation, Rectangle box);
    internal void SweepKids(PdfObject obj);
    public virtual void set_FlatAnnotations(bool value);
    protected internal virtual void FlattenAnnotations();
    private void FlattenAnnotations(bool flattenFreeTextAnnotations);
    private Rectangle TransformBBoxByMatrix(Rectangle bBox, Double[] matrix);
    private Point TransformPoint(double x, double y, Double[] matrix);
    protected internal virtual void FlatFreeTextFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal void AddDocumentField(PdfIndirectReference ref_p);
    protected internal virtual void AddFieldResources();
    internal void ExpandFields(PdfFormField field, List`1<PdfAnnotation> allAnnots);
    internal void AddAnnotation(PdfAnnotation annot, PdfDictionary pageN);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    private void OutlineTravel(PRIndirectReference outline);
    internal void DeleteOutlines();
    protected internal virtual void SetJavaScript();
    protected virtual void AddFileAttachments();
    internal void MakePackage(PdfCollection collection);
    protected internal virtual void SetOutlines();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_SigFlags(int value);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    internal void SetPageAction(PdfName actionType, PdfAction action, int page);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    internal void SetDuration(int seconds, int page);
    internal void SetTransition(PdfTransition transition, int page);
    public virtual void MarkUsed(PdfObject obj);
    protected internal virtual void MarkUsed(int num);
    internal bool IsAppend();
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetOpenAction(string name);
    public virtual void set_Thumbnail(Image value);
    internal void SetThumbnail(Image image, int page);
    protected virtual void ReadOCProperties();
    private void AddOrder(PdfLayer parent, PdfArray arr, Dictionary`2<string, PdfLayer> ocgmap);
    public virtual Dictionary`2<string, PdfLayer> GetPdfLayers();
    internal virtual void RegisterLayer(IPdfOCG layer);
    public virtual void CreateXmpMetadata();
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    public PdfReader GetPdfReader();
}
public class iTextSharp.text.pdf.PdfStream : PdfDictionary {
    public static int DEFAULT_COMPRESSION;
    public static int NO_COMPRESSION;
    public static int BEST_SPEED;
    public static int BEST_COMPRESSION;
    protected bool compressed;
    protected int compressionLevel;
    protected MemoryStream streamBytes;
    protected Stream inputStream;
    protected PdfIndirectReference iref;
    protected int inputStreamLength;
    protected PdfWriter writer;
    protected int rawLength;
    internal static Byte[] STARTSTREAM;
    internal static Byte[] ENDSTREAM;
    internal static int SIZESTREAM;
    public int RawLength { get; }
    public PdfStream(Byte[] bytes);
    public PdfStream(Stream inputStream, PdfWriter writer);
    private static PdfStream();
    public virtual void WriteLength();
    public virtual int get_RawLength();
    public virtual void FlateCompress();
    public virtual void FlateCompress(int compressionLevel);
    protected virtual void SuperToPdf(PdfWriter writer, Stream os);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual void WriteContent(Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfString : PdfObject {
    protected string value;
    protected string originalValue;
    protected string encoding;
    protected int objNum;
    protected int objGen;
    protected bool hexWriting;
    public string Encoding { get; }
    public PdfString(string value);
    public PdfString(string value, string encoding);
    public PdfString(Byte[] bytes);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
    public virtual string get_Encoding();
    public virtual string ToUnicodeString();
    internal void SetObjNum(int objNum, int objGen);
    internal void Decrypt(PdfReader reader);
    public virtual Byte[] GetBytes();
    public virtual Byte[] GetOriginalBytes();
    public virtual PdfString SetHexWriting(bool hexWriting);
    public virtual bool IsHexWriting();
}
public class iTextSharp.text.pdf.PdfStructTreeController : object {
    private PdfDictionary structTreeRoot;
    private PdfCopy writer;
    private PdfStructureTreeRoot structureTreeRoot;
    private PdfDictionary parentTree;
    protected internal PdfReader reader;
    private PdfDictionary roleMap;
    private PdfDictionary sourceRoleMap;
    private PdfDictionary sourceClassMap;
    private PdfIndirectReference nullReference;
    protected internal PdfStructTreeController(PdfReader reader, PdfCopy writer);
    protected internal virtual void SetReader(PdfReader reader);
    public static bool CheckTagged(PdfReader reader);
    public static PdfObject GetDirectObject(PdfObject obj);
    public virtual void CopyStructTreeForPage(PdfNumber sourceArrayNumber, int newArrayNumber);
    private ReturnType CopyPageMarks(PdfDictionary parentTree, PdfNumber arrayNumber, int newArrayNumber);
    private ReturnType FindAndCopyMarks(PdfArray pages, int arrayNumber, int newArrayNumber);
    protected internal virtual void AttachStructTreeRootKids(PdfObject firstNotNullKid);
    internal static PdfDictionary GetKDict(PdfDictionary obj);
    private void AddKid(PdfObject obj);
    private static PdfArray GetDirectArray(PdfArray input);
    private static PdfDictionary GetDirectDict(PdfDictionary input);
    public static bool CompareObjects(PdfObject value1, PdfObject value2);
    internal void AddClass(PdfObject obj);
    internal void AddRole(PdfName structType);
    protected virtual void AddKid(PdfDictionary parent, PdfObject kid);
}
public class iTextSharp.text.pdf.PdfStructureElement : PdfDictionary {
    private PdfStructureElement parent;
    private PdfStructureTreeRoot top;
    private PdfIndirectReference reference;
    private PdfName structureType;
    public PdfName StructureType { get; }
    public PdfDictionary Parent { get; }
    public PdfIndirectReference Reference { get; }
    public PdfStructureElement(PdfStructureElement parent, PdfName structureType);
    public PdfStructureElement(PdfStructureTreeRoot root, PdfName structureType);
    internal PdfStructureElement(PdfDictionary parent, PdfName structureType);
    public virtual PdfName get_StructureType();
    private void Init(PdfDictionary parent, PdfName structureType);
    public virtual PdfDictionary get_Parent();
    public virtual PdfDictionary GetParent(bool includeStructTreeRoot);
    internal virtual void SetPageMark(int page, int mark);
    internal virtual void SetAnnotation(PdfAnnotation annot, PdfIndirectReference currentPage);
    public virtual PdfIndirectReference get_Reference();
    public virtual PdfObject GetAttribute(PdfName name);
    public virtual void SetAttribute(PdfName name, PdfObject obj);
    public virtual void WriteAttributes(IAccessibleElement element);
    private void WriteAttributes(Chunk chunk);
    private void WriteAttributes(Image image);
    private void WriteAttributes(PdfTemplate template);
    private void WriteAttributes(Paragraph paragraph);
    private void WriteAttributes(List list);
    private void WriteAttributes(ListItem listItem);
    private void WriteAttributes(ListBody listBody);
    private void WriteAttributes(ListLabel listLabel);
    private void WriteAttributes(PdfPTable table);
    private void WriteAttributes(PdfPRow row);
    private void WriteAttributes(PdfPCell cell);
    private void WriteAttributes(PdfPHeaderCell headerCell);
    private void WriteAttributes(PdfPTableHeader header);
    private void WriteAttributes(PdfPTableBody body);
    private void WriteAttributes(PdfPTableFooter footer);
    private void WriteAttributes(PdfDiv div);
    private void WriteAttributes(Document document);
    private bool ColorsEqual(PdfArray parentColor, Single[] color);
    private void SetColorAttribute(BaseColor newColor, PdfObject oldColor, PdfName attributeName);
    private void SetTextAlignAttribute(int elementAlign);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    private PdfObject GetParentAttribute(IPdfStructureElement parent, PdfName name);
}
public class iTextSharp.text.pdf.PdfStructureTreeRoot : PdfDictionary {
    private Dictionary`2<int, PdfObject> parentTree;
    private PdfIndirectReference reference;
    private PdfDictionary classMap;
    internal Dictionary`2<PdfName, PdfObject> classes;
    private Dictionary`2<int, PdfIndirectReference> numTree;
    private Dictionary`2<string, PdfObject> idTreeMap;
    private PdfWriter writer;
    public PdfWriter Writer { get; }
    public Dictionary`2<int, PdfIndirectReference> NumTree { get; }
    public PdfIndirectReference Reference { get; }
    internal PdfStructureTreeRoot(PdfWriter writer);
    private void CreateNumTree();
    public virtual void MapRole(PdfName used, PdfName standard);
    public virtual void MapClass(PdfName name, PdfObject obj);
    internal virtual void PutIDTree(string record, PdfObject reference);
    public virtual PdfObject GetMappedClass(PdfName name);
    public virtual PdfWriter get_Writer();
    public virtual Dictionary`2<int, PdfIndirectReference> get_NumTree();
    public virtual PdfIndirectReference get_Reference();
    internal void SetPageMark(int page, PdfIndirectReference struc);
    internal void SetAnnotationMark(int structParentIndex, PdfIndirectReference struc);
    private void NodeProcess(PdfDictionary struc, PdfIndirectReference reference);
    internal void BuildTree();
    public virtual PdfObject GetAttribute(PdfName name);
    public virtual void SetAttribute(PdfName name, PdfObject obj);
}
public class iTextSharp.text.pdf.PdfTemplate : PdfContentByte {
    public static int TYPE_TEMPLATE;
    public static int TYPE_IMPORTED;
    public static int TYPE_PATTERN;
    protected int type;
    protected PdfIndirectReference thisReference;
    protected PageResources pageResources;
    protected Rectangle bBox;
    protected PdfArray matrix;
    protected PdfTransparencyGroup group;
    protected IPdfOCG layer;
    protected PdfIndirectReference pageReference;
    protected bool contentTagged;
    private PdfDictionary additional;
    protected PdfName role;
    protected Dictionary`2<PdfName, PdfObject> accessibleAttributes;
    private AccessibleElementId id;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public Rectangle BoundingBox { get; public set; }
    public IPdfOCG Layer { get; public set; }
    internal PdfArray Matrix { get; }
    public PdfIndirectReference IndirectReference { get; }
    internal PdfObject Resources { get; }
    public PdfContentByte Duplicate { get; }
    public int Type { get; }
    internal PageResources PageResources { get; }
    public PdfTransparencyGroup Group { get; public set; }
    public PdfDictionary Additional { get; public set; }
    protected PdfIndirectReference CurrentPage { get; }
    public PdfIndirectReference PageReference { get; public set; }
    public bool ContentTagged { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    internal PdfTemplate(PdfWriter wr);
    public static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height);
    internal static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height, PdfName forcedName);
    public virtual bool IsTagged();
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual Rectangle get_BoundingBox();
    public virtual void set_BoundingBox(Rectangle value);
    public virtual IPdfOCG get_Layer();
    public virtual void set_Layer(IPdfOCG value);
    public virtual void SetMatrix(float a, float b, float c, float d, float e, float f);
    internal PdfArray get_Matrix();
    public virtual PdfIndirectReference get_IndirectReference();
    public virtual void BeginVariableText();
    public virtual void EndVariableText();
    internal virtual PdfObject get_Resources();
    public virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public virtual int get_Type();
    internal virtual PageResources get_PageResources();
    public virtual PdfTransparencyGroup get_Group();
    public virtual void set_Group(PdfTransparencyGroup value);
    public virtual void set_Additional(PdfDictionary value);
    public virtual PdfDictionary get_Additional();
    protected virtual PdfIndirectReference get_CurrentPage();
    public virtual PdfIndirectReference get_PageReference();
    public virtual void set_PageReference(PdfIndirectReference value);
    public virtual bool get_ContentTagged();
    public virtual void set_ContentTagged(bool value);
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.pdf.PdfTextArray : object {
    private List`1<object> arrayList;
    private string lastStr;
    private float lastNum;
    internal List`1<object> ArrayList { get; }
    public PdfTextArray(string str);
    public virtual void Add(PdfNumber number);
    public virtual void Add(float number);
    public virtual void Add(string str);
    internal List`1<object> get_ArrayList();
    private void ReplaceLast(object obj);
}
public class iTextSharp.text.pdf.PdfTransition : object {
    public static int SPLITVOUT;
    public static int SPLITHOUT;
    public static int SPLITVIN;
    public static int SPLITHIN;
    public static int BLINDV;
    public static int BLINDH;
    public static int INBOX;
    public static int OUTBOX;
    public static int LRWIPE;
    public static int RLWIPE;
    public static int BTWIPE;
    public static int TBWIPE;
    public static int DISSOLVE;
    public static int LRGLITTER;
    public static int TBGLITTER;
    public static int DGLITTER;
    protected int duration;
    protected int type;
    public int Duration { get; }
    public int Type { get; }
    public PdfDictionary TransitionDictionary { get; }
    public PdfTransition(int type);
    public PdfTransition(int type, int duration);
    public virtual int get_Duration();
    public virtual int get_Type();
    public virtual PdfDictionary get_TransitionDictionary();
}
public class iTextSharp.text.pdf.PdfTransparencyGroup : PdfDictionary {
    unknown bool Isolated {public set; }
    unknown bool Knockout {public set; }
    public virtual void set_Isolated(bool value);
    public virtual void set_Knockout(bool value);
}
public class iTextSharp.text.pdf.PdfVisibilityExpression : PdfArray {
    public static int OR;
    public static int AND;
    public static int NOT;
    public PdfVisibilityExpression(int type);
    public virtual void Add(int index, PdfObject element);
    public virtual bool Add(PdfObject obj);
    public virtual void AddFirst(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
}
public class iTextSharp.text.pdf.PdfWriter : DocWriter {
    public static int GENERATION_MAX;
    protected static ICounter COUNTER;
    protected internal PdfDocument pdf;
    protected PdfContentByte directContent;
    protected PdfContentByte directContentUnder;
    protected internal PdfBody body;
    protected ICC_Profile colorProfile;
    protected internal PdfDictionary extraCatalog;
    protected PdfPages root;
    internal List`1<PdfIndirectReference> pageReferences;
    protected int currentPageNumber;
    protected PdfName tabs;
    protected PdfDictionary pageDictEntries;
    private IPdfPageEvent pageEvent;
    protected long prevxref;
    protected Byte[] originalFileID;
    protected IList`1<Dictionary`2<string, object>> newBookmarks;
    public static char VERSION_1_2;
    public static char VERSION_1_3;
    public static char VERSION_1_4;
    public static char VERSION_1_5;
    public static char VERSION_1_6;
    public static char VERSION_1_7;
    public static PdfName PDF_VERSION_1_2;
    public static PdfName PDF_VERSION_1_3;
    public static PdfName PDF_VERSION_1_4;
    public static PdfName PDF_VERSION_1_5;
    public static PdfName PDF_VERSION_1_6;
    public static PdfName PDF_VERSION_1_7;
    protected PdfVersionImp pdf_version;
    public static int PageLayoutSinglePage;
    public static int PageLayoutOneColumn;
    public static int PageLayoutTwoColumnLeft;
    public static int PageLayoutTwoColumnRight;
    public static int PageLayoutTwoPageLeft;
    public static int PageLayoutTwoPageRight;
    public static int PageModeUseNone;
    public static int PageModeUseOutlines;
    public static int PageModeUseThumbs;
    public static int PageModeFullScreen;
    public static int PageModeUseOC;
    public static int PageModeUseAttachments;
    public static int HideToolbar;
    public static int HideMenubar;
    public static int HideWindowUI;
    public static int FitWindow;
    public static int CenterWindow;
    public static int DisplayDocTitle;
    public static int NonFullScreenPageModeUseNone;
    public static int NonFullScreenPageModeUseOutlines;
    public static int NonFullScreenPageModeUseThumbs;
    public static int NonFullScreenPageModeUseOC;
    public static int DirectionL2R;
    public static int DirectionR2L;
    public static int PrintScalingNone;
    public static PdfName DOCUMENT_CLOSE;
    public static PdfName WILL_SAVE;
    public static PdfName DID_SAVE;
    public static PdfName WILL_PRINT;
    public static PdfName DID_PRINT;
    public static int SIGNATURE_EXISTS;
    public static int SIGNATURE_APPEND_ONLY;
    protected Byte[] xmpMetadata;
    protected XmpWriter xmpWriter;
    public static int PDFXNONE;
    public static int PDFX1A2001;
    public static int PDFX32002;
    protected IPdfIsoConformance pdfIsoConformance;
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int ENCRYPTION_AES_128;
    public static int ENCRYPTION_AES_256;
    internal static int ENCRYPTION_MASK;
    public static int DO_NOT_ENCRYPT_METADATA;
    public static int EMBEDDED_FILES_ONLY;
    public static int ALLOW_PRINTING;
    public static int ALLOW_MODIFY_CONTENTS;
    public static int ALLOW_COPY;
    public static int ALLOW_MODIFY_ANNOTATIONS;
    public static int ALLOW_FILL_IN;
    public static int ALLOW_SCREENREADERS;
    public static int ALLOW_ASSEMBLY;
    public static int ALLOW_DEGRADED_PRINTING;
    public static int AllowPrinting;
    public static int AllowModifyContents;
    public static int AllowCopy;
    public static int AllowModifyAnnotations;
    public static int AllowFillIn;
    public static int AllowScreenReaders;
    public static int AllowAssembly;
    public static int AllowDegradedPrinting;
    public static bool STRENGTH40BITS;
    public static bool STRENGTH128BITS;
    protected PdfEncryption crypto;
    internal bool fullCompression;
    protected internal int compressionLevel;
    protected Dictionary`2<BaseFont, FontDetails> documentFonts;
    protected int fontNumber;
    protected Dictionary`2<PdfIndirectReference, Object[]> formXObjects;
    protected int formXObjectsCounter;
    protected Dictionary`2<PdfReader, PdfReaderInstance> readerInstances;
    protected PdfReaderInstance currentPdfReaderInstance;
    protected Dictionary`2<ICachedColorSpace, ColorDetails> documentColors;
    protected int colorNumber;
    protected Dictionary`2<PdfPatternPainter, PdfName> documentPatterns;
    protected int patternNumber;
    protected Dictionary`2<PdfShadingPattern, object> documentShadingPatterns;
    protected Dictionary`2<PdfShading, object> documentShadings;
    protected Dictionary`2<PdfDictionary, PdfObject[]> documentExtGState;
    protected Dictionary`2<object, PdfObject[]> documentProperties;
    public static int markAll;
    public static int markInlineElementsOnly;
    protected bool tagged;
    protected int taggingMode;
    protected PdfStructureTreeRoot structureTreeRoot;
    protected Dictionary`2<IPdfOCG, object> documentOCG;
    protected List`1<IPdfOCG> documentOCGorder;
    protected PdfOCProperties vOCProperties;
    protected PdfArray OCGRadioGroup;
    protected PdfArray OCGLocked;
    public static PdfName PAGE_OPEN;
    public static PdfName PAGE_CLOSE;
    protected PdfDictionary group;
    public static float SPACE_CHAR_RATIO_DEFAULT;
    public static float NO_SPACE_CHAR_RATIO;
    private float spaceCharRatio;
    public static int RUN_DIRECTION_DEFAULT;
    public static int RUN_DIRECTION_NO_BIDI;
    public static int RUN_DIRECTION_LTR;
    public static int RUN_DIRECTION_RTL;
    protected int runDirection;
    protected PdfDictionary defaultColorspace;
    protected Dictionary`2<ColorDetails, ColorDetails> documentSpotPatterns;
    protected ColorDetails patternColorspaceRGB;
    protected ColorDetails patternColorspaceGRAY;
    protected ColorDetails patternColorspaceCMYK;
    protected PdfDictionary imageDictionary;
    private Dictionary`2<long, PdfName> images;
    protected Dictionary`2<PdfStream, PdfIndirectReference> JBIG2Globals;
    private bool userProperties;
    private bool rgbTransparencyBlending;
    protected TtfUnicodeWriter ttfUnicodeWriter;
    private static List`1<PdfName> standardStructElems_1_4;
    private static List`1<PdfName> standardStructElems_1_7;
    internal PdfDocument PdfDocument { get; }
    public PdfDictionary Info { get; }
    unknown float InitialLeading {public set; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    public ICC_Profile ColorProfile { get; }
    public PdfIndirectReference PdfIndirectReference { get; }
    protected internal int IndirectReferenceNumber { get; }
    public OutputStreamCounter Os { get; }
    public PdfDictionary ExtraCatalog { get; }
    public PdfDictionary PageDictEntries { get; }
    public int PageNumber { get; }
    internal PdfIndirectReference CurrentPage { get; }
    public int CurrentPageNumber { get; }
    public PdfName Tabs { get; public set; }
    public IPdfPageEvent PageEvent { get; public set; }
    public PdfOutline RootOutline { get; }
    unknown IList`1<Dictionary`2<string, object>> Outlines {public set; }
    unknown char PdfVersion {public set; }
    unknown int ViewerPreferences {public set; }
    unknown PdfPageLabels PageLabels {public set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public Byte[] XmpMetadata { get; public set; }
    unknown Byte[] PageXmpMetadata {public set; }
    public XmpWriter XmpWriter { get; }
    public int PDFXConformance { get; public set; }
    internal PdfEncryption Encryption { get; }
    public bool FullCompression { get; }
    public int CompressionLevel { get; public set; }
    public long CurrentDocumentSize { get; }
    public PdfStructureTreeRoot StructureTreeRoot { get; }
    public PdfOCProperties OCProperties { get; }
    public Rectangle PageSize { get; }
    unknown Rectangle CropBoxSize {public set; }
    public bool PageEmpty { get; public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfDictionary Group { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    unknown float Userunit {public set; }
    public PdfDictionary DefaultColorspace { get; }
    public bool StrictImageSequence { get; public set; }
    public bool UserProperties { get; public set; }
    public bool RgbTransparencyBlending { get; public set; }
    protected PdfWriter(PdfDocument document, Stream os);
    private static PdfWriter();
    protected virtual ICounter GetCounter();
    public static PdfWriter GetInstance(Document document, Stream os);
    public static PdfWriter GetInstance(Document document, Stream os, IDocListener listener);
    internal PdfDocument get_PdfDocument();
    public virtual PdfDictionary get_Info();
    public virtual float GetVerticalPosition(bool ensureNewLine);
    public virtual void set_InitialLeading(float value);
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    internal void ResetContent();
    public virtual ICC_Profile get_ColorProfile();
    internal void AddLocalDestinations(SortedDictionary`2<string, Destination> desto);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, bool inObjStm);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool inObjStm);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, int refNumber);
    public virtual PdfIndirectObject AddToBody(PdfObject objecta, int refNumber, bool inObjStm);
    protected internal virtual void CacheObject(PdfIndirectObject iobj);
    public virtual PdfIndirectReference get_PdfIndirectReference();
    protected internal virtual int get_IndirectReferenceNumber();
    public virtual OutputStreamCounter get_Os();
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected virtual void BuildStructTreeRootForTagged(PdfDictionary catalog);
    public virtual PdfDictionary get_ExtraCatalog();
    public virtual void AddPageDictEntry(PdfName key, PdfObject obj);
    public virtual PdfDictionary get_PageDictEntries();
    public virtual void ResetPageDictEntries();
    public virtual void SetLinearPageMode();
    public virtual int ReorderPages(Int32[] order);
    public virtual PdfIndirectReference GetPageReference(int page);
    public virtual int get_PageNumber();
    internal virtual PdfIndirectReference get_CurrentPage();
    public virtual int get_CurrentPageNumber();
    public virtual void SetPageViewport(PdfArray vp);
    public virtual PdfName get_Tabs();
    public virtual void set_Tabs(PdfName value);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public virtual IPdfPageEvent get_PageEvent();
    public virtual void set_PageEvent(IPdfPageEvent value);
    public virtual void Open();
    public virtual void Close();
    protected virtual void AddXFormsToBody();
    protected virtual void AddSharedObjectsToBody();
    public virtual PdfOutline get_RootOutline();
    public virtual void set_Outlines(IList`1<Dictionary`2<string, object>> value);
    protected internal virtual void WriteOutlines(PdfDictionary catalog, bool namedAsNames);
    public virtual void set_PdfVersion(char value);
    public virtual void SetAtLeastPdfVersion(char version);
    public virtual void SetPdfVersion(PdfName version);
    public virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    internal PdfVersionImp GetPdfVersion();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_PageLabels(PdfPageLabels value);
    public virtual void AddNamedDestinations(IDictionary`2<string, string> map, int page_offset);
    public virtual void AddNamedDestination(string name, int page, PdfDestination dest);
    public virtual void AddJavaScript(PdfAction js);
    public virtual void AddJavaScript(string code, bool unicode);
    public virtual void AddJavaScript(string code);
    public virtual void AddJavaScript(string name, PdfAction js);
    public virtual void AddJavaScript(string name, string code, bool unicode);
    public virtual void AddJavaScript(string name, string code);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public virtual void AddFileAttachment(PdfFileSpecification fs);
    public virtual void SetOpenAction(string name);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void set_Collection(PdfCollection value);
    public virtual PdfAcroForm get_AcroForm();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    public virtual void AddCalculationOrder(PdfFormField annot);
    public virtual void set_SigFlags(int value);
    public virtual void SetLanguage(string language);
    public virtual void set_XmpMetadata(Byte[] value);
    public virtual Byte[] get_XmpMetadata();
    public virtual void set_PageXmpMetadata(Byte[] value);
    public virtual XmpWriter get_XmpWriter();
    public virtual void CreateXmpMetadata();
    public virtual IPdfIsoConformance InitPdfIsoConformance();
    public virtual void set_PDFXConformance(int value);
    public virtual int get_PDFXConformance();
    public virtual bool IsPdfIso();
    public virtual bool IsPdfX();
    public virtual void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, ICC_Profile colorProfile);
    public virtual void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, Byte[] destOutputProfile);
    public virtual bool SetOutputIntents(PdfReader reader, bool checkExistence);
    protected static string GetNameString(PdfDictionary dic, PdfName key);
    internal PdfEncryption get_Encryption();
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public virtual void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public virtual void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public virtual bool get_FullCompression();
    public virtual void SetFullCompression();
    public virtual void set_CompressionLevel(int value);
    public virtual int get_CompressionLevel();
    internal FontDetails AddSimple(BaseFont bf);
    internal void EliminateFontSubset(PdfDictionary fonts);
    internal PdfName AddDirectTemplateSimple(PdfTemplate template, PdfName forcedName);
    public virtual void ReleaseTemplate(PdfTemplate tp);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    protected virtual PdfReaderInstance GetPdfReaderInstance(PdfReader reader);
    public virtual void FreeReader(PdfReader reader);
    public virtual long get_CurrentDocumentSize();
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal PdfName GetColorspaceName();
    internal virtual ColorDetails AddSimple(ICachedColorSpace spc);
    internal virtual PdfName AddSimplePattern(PdfPatternPainter painter);
    internal void AddSimpleShadingPattern(PdfShadingPattern shading);
    internal void AddSimpleShading(PdfShading shading);
    internal PdfObject[] AddSimpleExtGState(PdfDictionary gstate);
    internal PdfObject[] AddSimpleProperty(object prop, PdfIndirectReference refi);
    internal bool PropertyExists(object prop);
    public virtual void SetTagged();
    public virtual void SetTagged(int taggingMode);
    public virtual bool NeedToBeMarkedInContent(IAccessibleElement element);
    public virtual void CheckElementRole(IAccessibleElement element, IAccessibleElement parent);
    public virtual bool IsTagged();
    internal virtual void FlushTaggedObjects();
    internal virtual void FlushAcroFields();
    public virtual PdfStructureTreeRoot get_StructureTreeRoot();
    public virtual PdfOCProperties get_OCProperties();
    public virtual void AddOCGRadioGroup(List`1<PdfLayer> group);
    public virtual void LockLayer(PdfLayer layer);
    private static void GetOCGOrder(PdfArray order, PdfLayer layer);
    private void AddASEvent(PdfName eventa, PdfName category);
    protected virtual void FillOCProperties(bool erase);
    internal virtual void RegisterLayer(IPdfOCG layer);
    public virtual Rectangle get_PageSize();
    public virtual void set_CropBoxSize(Rectangle value);
    public virtual void SetBoxSize(string boxName, Rectangle size);
    public virtual Rectangle GetBoxSize(string boxName);
    public virtual Rectangle GetBoxSize(string boxName, Rectangle intersectingRectangle);
    public virtual void set_PageEmpty(bool value);
    public virtual bool get_PageEmpty();
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    public virtual void set_Thumbnail(Image value);
    public virtual PdfDictionary get_Group();
    public virtual void set_Group(PdfDictionary value);
    public virtual void set_SpaceCharRatio(float value);
    public virtual float get_SpaceCharRatio();
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public virtual void set_Userunit(float value);
    public virtual PdfDictionary get_DefaultColorspace();
    public virtual void SetDefaultColorspace(PdfName key, PdfObject cs);
    internal ColorDetails AddSimplePatternColorspace(BaseColor color);
    public virtual void set_StrictImageSequence(bool value);
    public virtual bool get_StrictImageSequence();
    public virtual void ClearTextWrap();
    public virtual PdfName AddDirectImageSimple(Image image);
    public virtual PdfName AddDirectImageSimple(Image image, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference Add(PdfImage pdfImage, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference GetImageReference(PdfName name);
    protected virtual PdfIndirectReference Add(PdfICCBased icc);
    protected internal virtual PdfIndirectReference GetReferenceJBIG2Globals(Byte[] content);
    public virtual void set_UserProperties(bool value);
    public virtual bool get_UserProperties();
    public virtual bool get_RgbTransparencyBlending();
    public virtual void set_RgbTransparencyBlending(bool value);
    protected static void WriteKeyInfo(Stream os);
    protected internal virtual TtfUnicodeWriter GetTtfUnicodeWriter();
    protected internal virtual XmpWriter CreateXmpWriter(MemoryStream baos, PdfDictionary info);
    protected internal virtual XmpWriter CreateXmpWriter(MemoryStream baos, IDictionary`2<string, string> info);
    public virtual PdfAnnotation CreateAnnotation(Rectangle rect, PdfName subtype);
    public virtual PdfAnnotation CreateAnnotation(float llx, float lly, float urx, float ury, PdfString title, PdfString content, PdfName subtype);
    public virtual PdfAnnotation CreateAnnotation(float llx, float lly, float urx, float ury, PdfAction action, PdfName subtype);
    public static void CheckPdfIsoConformance(PdfWriter writer, int key, object obj1);
    public virtual void CheckPdfIsoConformance(int key, object obj1);
    private void CompleteInfoDictionary(PdfDictionary info);
    private void CompleteExtraCatalog(PdfDictionary extraCatalog);
    public virtual List`1<PdfName> GetStandardStructElems();
}
public class iTextSharp.text.pdf.PdfXConformanceException : PdfIsoConformanceException {
    public PdfXConformanceException(string s);
    protected PdfXConformanceException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.Pfm2afm : object {
    private RandomAccessFileOrArray inp;
    private StreamWriter outp;
    private Encoding encoding;
    private short vers;
    private int h_len;
    private string copyright;
    private short type;
    private short points;
    private short verres;
    private short horres;
    private short ascent;
    private short intleading;
    private short extleading;
    private byte italic;
    private byte uline;
    private byte overs;
    private short weight;
    private byte charset;
    private short pixwidth;
    private short pixheight;
    private byte kind;
    private short avgwidth;
    private short maxwidth;
    private int firstchar;
    private int lastchar;
    private byte defchar;
    private byte brkchar;
    private short widthby;
    private int device;
    private int face;
    private int bits;
    private int bitoff;
    private short extlen;
    private int psext;
    private int chartab;
    private int res1;
    private int kernpairs;
    private int res2;
    private int fontname;
    private short capheight;
    private short xheight;
    private short ascender;
    private short descender;
    private bool isMono;
    private Int32[] Win2PSStd;
    private Int32[] WinClass;
    private String[] WinChars;
    private Pfm2afm(RandomAccessFileOrArray inp, Stream outp);
    public static void Convert(RandomAccessFileOrArray inp, Stream outp);
    private string ReadString(int n);
    private string ReadString();
    private void Outval(int n);
    private void Outchar(int code, int width, string name);
    private void Openpfm();
    private void Putheader();
    private void Putchartab();
    private void Putkerntab();
    private void Puttrailer();
}
public class iTextSharp.text.pdf.PRAcroForm : PdfDictionary {
    internal List`1<FieldInformation> fields;
    internal List`1<PdfDictionary> stack;
    internal Dictionary`2<string, FieldInformation> fieldByName;
    internal PdfReader reader;
    public int Size { get; }
    public List`1<FieldInformation> Fields { get; }
    public PRAcroForm(PdfReader reader);
    public int get_Size();
    public virtual List`1<FieldInformation> get_Fields();
    public virtual FieldInformation GetField(string name);
    public virtual PRIndirectReference GetRefByName(string name);
    public virtual void ReadAcroForm(PdfDictionary root);
    protected virtual void IterateFields(PdfArray fieldlist, PRIndirectReference fieldDict, string parentPath);
    protected virtual PdfDictionary MergeAttrib(PdfDictionary parent, PdfDictionary child);
    protected virtual void PushAttrib(PdfDictionary dict);
}
public class iTextSharp.text.pdf.PRIndirectReference : PdfIndirectReference {
    protected PdfReader reader;
    public PdfReader Reader { get; }
    public PRIndirectReference(PdfReader reader, int number, int generation);
    public PRIndirectReference(PdfReader reader, int number);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual PdfReader get_Reader();
    public virtual void SetNumber(int number, int generation);
}
public class iTextSharp.text.pdf.PRStream : PdfStream {
    protected PdfReader reader;
    protected long offset;
    protected int length;
    protected int objNum;
    protected int objGen;
    public int Length { get; public set; }
    public long Offset { get; }
    public PdfReader Reader { get; }
    public int ObjNum { get; public set; }
    public int ObjGen { get; public set; }
    public PRStream(PRStream stream, PdfDictionary newDic);
    public PRStream(PRStream stream, PdfDictionary newDic, PdfReader reader);
    public PRStream(PdfReader reader, long offset);
    public PRStream(PdfReader reader, Byte[] conts);
    public PRStream(PdfReader reader, Byte[] conts, int compressionLevel);
    public virtual void SetData(Byte[] data, bool compress);
    public virtual void SetData(Byte[] data, bool compress, int compressionLevel);
    public virtual void SetDataRaw(Byte[] data);
    public virtual void SetData(Byte[] data);
    public void set_Length(int value);
    public int get_Length();
    public virtual long get_Offset();
    public virtual PdfReader get_Reader();
    public Byte[] GetBytes();
    public virtual int get_ObjNum();
    public virtual void set_ObjNum(int value);
    public virtual int get_ObjGen();
    public virtual void set_ObjGen(int value);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PRTokeniser : object {
    internal static string EMPTY;
    private RandomAccessFileOrArray file;
    protected TokType type;
    protected string stringValue;
    protected int reference;
    protected int generation;
    protected bool hexString;
    private StringBuilder outBuf;
    public long FilePointer { get; }
    public long Length { get; }
    public RandomAccessFileOrArray SafeFile { get; }
    public RandomAccessFileOrArray File { get; }
    public TokType TokenType { get; }
    public string StringValue { get; }
    public int Reference { get; }
    public int Generation { get; }
    public long LongValue { get; }
    public int IntValue { get; }
    public PRTokeniser(RandomAccessFileOrArray file);
    public virtual void Seek(long pos);
    public virtual long get_FilePointer();
    public virtual void Close();
    public virtual long get_Length();
    public virtual int Read();
    public virtual RandomAccessFileOrArray get_SafeFile();
    public virtual RandomAccessFileOrArray get_File();
    public virtual string ReadString(int size);
    public static bool IsWhitespace(int ch);
    public static bool IsWhitespace(int ch, bool isWhitespace);
    public static bool IsDelimiter(int ch);
    public virtual TokType get_TokenType();
    public virtual string get_StringValue();
    public virtual int get_Reference();
    public virtual int get_Generation();
    public virtual void BackOnePosition(int ch);
    public virtual void ThrowError(string error);
    public virtual int GetHeaderOffset();
    public virtual char CheckPdfHeader();
    public virtual void CheckFdfHeader();
    public virtual long GetStartxref();
    public static int GetHex(int v);
    public virtual void NextValidToken();
    public virtual bool NextToken();
    public virtual long get_LongValue();
    public virtual int get_IntValue();
    public virtual bool ReadLineSegment(Byte[] input);
    public virtual bool ReadLineSegment(Byte[] input, bool isNullWhitespace);
    public static Int64[] CheckObjectStart(Byte[] line);
    public virtual bool IsHexString();
}
public class iTextSharp.text.pdf.PushbuttonField : BaseField {
    public static int LAYOUT_LABEL_ONLY;
    public static int LAYOUT_ICON_ONLY;
    public static int LAYOUT_ICON_TOP_LABEL_BOTTOM;
    public static int LAYOUT_LABEL_TOP_ICON_BOTTOM;
    public static int LAYOUT_ICON_LEFT_LABEL_RIGHT;
    public static int LAYOUT_LABEL_LEFT_ICON_RIGHT;
    public static int LAYOUT_LABEL_OVER_ICON;
    public static int SCALE_ICON_ALWAYS;
    public static int SCALE_ICON_NEVER;
    public static int SCALE_ICON_IS_TOO_BIG;
    public static int SCALE_ICON_IS_TOO_SMALL;
    private int layout;
    private Image image;
    private PdfTemplate template;
    private int scaleIcon;
    private bool proportionalIcon;
    private float iconVerticalAdjustment;
    private float iconHorizontalAdjustment;
    private bool iconFitToBounds;
    private PdfTemplate tp;
    private PRIndirectReference iconReference;
    public int Layout { get; public set; }
    public Image Image { get; public set; }
    public PdfTemplate Template { get; public set; }
    public int ScaleIcon { get; public set; }
    public bool ProportionalIcon { get; public set; }
    public float IconVerticalAdjustment { get; public set; }
    public float IconHorizontalAdjustment { get; public set; }
    public PdfFormField Field { get; }
    public bool IconFitToBounds { get; public set; }
    public PRIndirectReference IconReference { get; public set; }
    public PushbuttonField(PdfWriter writer, Rectangle box, string fieldName);
    public virtual void set_Layout(int value);
    public virtual int get_Layout();
    public virtual Image get_Image();
    public virtual void set_Image(Image value);
    public virtual void set_Template(PdfTemplate value);
    public virtual PdfTemplate get_Template();
    public virtual void set_ScaleIcon(int value);
    public virtual int get_ScaleIcon();
    public virtual bool get_ProportionalIcon();
    public virtual void set_ProportionalIcon(bool value);
    public virtual float get_IconVerticalAdjustment();
    public virtual void set_IconVerticalAdjustment(float value);
    public virtual float get_IconHorizontalAdjustment();
    public virtual void set_IconHorizontalAdjustment(float value);
    private float CalculateFontSize(float w, float h);
    public virtual PdfAppearance GetAppearance();
    public virtual PdfFormField get_Field();
    public virtual bool get_IconFitToBounds();
    public virtual void set_IconFitToBounds(bool value);
    public virtual PRIndirectReference get_IconReference();
    public virtual void set_IconReference(PRIndirectReference value);
}
public class iTextSharp.text.pdf.qrcode.BitArray : object {
    public Int32[] bits;
    public int size;
    public BitArray(int size);
    public int GetSize();
    public bool Get(int i);
    public void Set(int i);
    public void Flip(int i);
    public void SetBulk(int i, int newBits);
    public void Clear();
    public bool IsRange(int start, int end, bool value);
    public Int32[] GetBitArray();
    public void Reverse();
    private static Int32[] MakeArray(int size);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.BitMatrix : object {
    public int width;
    public int height;
    public int rowSize;
    public Int32[] bits;
    public BitMatrix(int dimension);
    public BitMatrix(int width, int height);
    public bool Get(int x, int y);
    public void Set(int x, int y);
    public void Flip(int x, int y);
    public void Clear();
    public void SetRegion(int left, int top, int width, int height);
    public BitArray GetRow(int y, BitArray row);
    public int GetWidth();
    public int GetHeight();
    public int GetDimension();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.BitVector : object {
    private int sizeInBits;
    private Byte[] array;
    private static int DEFAULT_SIZE_IN_BYTES;
    public int At(int index);
    public int Size();
    public int SizeInBytes();
    public void AppendBit(int bit);
    public void AppendBits(int value, int numBits);
    public void AppendBitVector(BitVector bits);
    public void Xor(BitVector other);
    public virtual string ToString();
    public Byte[] GetArray();
    private void AppendByte(int value);
}
public class iTextSharp.text.pdf.qrcode.BlockPair : object {
    private ByteArray dataBytes;
    private ByteArray errorCorrectionBytes;
    internal BlockPair(ByteArray data, ByteArray errorCorrection);
    public ByteArray GetDataBytes();
    public ByteArray GetErrorCorrectionBytes();
}
public class iTextSharp.text.pdf.qrcode.ByteArray : object {
    private static int INITIAL_SIZE;
    private Byte[] bytes;
    private int size;
    public ByteArray(int size);
    public ByteArray(Byte[] byteArray);
    public int At(int index);
    public void Set(int index, int value);
    public int Size();
    public bool IsEmpty();
    public void AppendByte(int value);
    public void Reserve(int capacity);
    public void Set(Byte[] source, int offset, int count);
}
public class iTextSharp.text.pdf.qrcode.ByteMatrix : object {
    private SByte[][] bytes;
    private int width;
    private int height;
    public ByteMatrix(int width, int height);
    public int GetHeight();
    public int GetWidth();
    public sbyte Get(int x, int y);
    public SByte[][] GetArray();
    public void Set(int x, int y, sbyte value);
    public void Set(int x, int y, int value);
    public void Clear(sbyte value);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.CharacterSetECI : object {
    private static Dictionary`2<string, CharacterSetECI> NAME_TO_ECI;
    private string encodingName;
    private int value;
    private CharacterSetECI(int value, string encodingName);
    private static void Initialize();
    public virtual string GetEncodingName();
    public virtual int GetValue();
    private static void AddCharacterSet(int value, string encodingName, Dictionary`2<string, CharacterSetECI> n);
    private static void AddCharacterSet(int value, String[] encodingNames, Dictionary`2<string, CharacterSetECI> n);
    public static CharacterSetECI GetCharacterSetECIByName(string name);
}
public class iTextSharp.text.pdf.qrcode.EncodeHintType : object {
    public static EncodeHintType ERROR_CORRECTION;
    public static EncodeHintType CHARACTER_SET;
    private static EncodeHintType();
}
public class iTextSharp.text.pdf.qrcode.Encoder : object {
    private static Int32[] ALPHANUMERIC_TABLE;
    private static string DEFAULT_BYTE_MODE_ENCODING;
    private static Encoder();
    private static int CalculateMaskPenalty(ByteMatrix matrix);
    public static void Encode(string content, ErrorCorrectionLevel ecLevel, QRCode qrCode);
    public static void Encode(string content, ErrorCorrectionLevel ecLevel, IDictionary`2<EncodeHintType, object> hints, QRCode qrCode);
    private static int GetAlphanumericCode(int code);
    public static Mode ChooseMode(string content);
    public static Mode ChooseMode(string content, string encoding);
    private static bool IsOnlyDoubleByteKanji(string content);
    private static int ChooseMaskPattern(BitVector bits, ErrorCorrectionLevel ecLevel, int version, ByteMatrix matrix);
    private static void InitQRCode(int numInputBytes, ErrorCorrectionLevel ecLevel, Mode mode, QRCode qrCode);
    private static void TerminateBits(int numDataBytes, BitVector bits);
    private static void GetNumDataBytesAndNumECBytesForBlockID(int numTotalBytes, int numDataBytes, int numRSBlocks, int blockID, Int32[] numDataBytesInBlock, Int32[] numECBytesInBlock);
    private static void InterleaveWithECBytes(BitVector bits, int numTotalBytes, int numDataBytes, int numRSBlocks, BitVector result);
    private static ByteArray GenerateECBytes(ByteArray dataBytes, int numEcBytesInBlock);
    private static void AppendModeInfo(Mode mode, BitVector bits);
    private static void AppendLengthInfo(int numLetters, int version, Mode mode, BitVector bits);
    private static void AppendBytes(string content, Mode mode, BitVector bits, string encoding);
    private static void AppendNumericBytes(string content, BitVector bits);
    private static void AppendAlphanumericBytes(string content, BitVector bits);
    private static void Append8BitBytes(string content, BitVector bits, string encoding);
    private static void AppendKanjiBytes(string content, BitVector bits);
    private static void AppendECI(CharacterSetECI eci, BitVector bits);
}
public class iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel : object {
    public static ErrorCorrectionLevel L;
    public static ErrorCorrectionLevel M;
    public static ErrorCorrectionLevel Q;
    public static ErrorCorrectionLevel H;
    private static ErrorCorrectionLevel[] FOR_BITS;
    private int ordinal;
    private int bits;
    private string name;
    private ErrorCorrectionLevel(int ordinal, int bits, string name);
    private static ErrorCorrectionLevel();
    public int Ordinal();
    public int GetBits();
    public string GetName();
    public virtual string ToString();
    public static ErrorCorrectionLevel ForBits(int bits);
}
public class iTextSharp.text.pdf.qrcode.FormatInformation : object {
    private static int FORMAT_INFO_MASK_QR;
    private static Int32[][] FORMAT_INFO_DECODE_LOOKUP;
    private static Int32[] BITS_SET_IN_HALF_BYTE;
    private ErrorCorrectionLevel errorCorrectionLevel;
    private byte dataMask;
    private FormatInformation(int formatInfo);
    private static FormatInformation();
    public static int NumBitsDiffering(int a, int b);
    public static FormatInformation DecodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    private static FormatInformation DoDecodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    public ErrorCorrectionLevel GetErrorCorrectionLevel();
    public byte GetDataMask();
    public int HashCode();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class iTextSharp.text.pdf.qrcode.GF256 : object {
    public static GF256 QR_CODE_FIELD;
    public static GF256 DATA_MATRIX_FIELD;
    private Int32[] expTable;
    private Int32[] logTable;
    private GF256Poly zero;
    private GF256Poly one;
    private GF256(int primitive);
    private static GF256();
    internal GF256Poly GetZero();
    internal GF256Poly GetOne();
    internal GF256Poly BuildMonomial(int degree, int coefficient);
    internal static int AddOrSubtract(int a, int b);
    internal int Exp(int a);
    internal int Log(int a);
    internal int Inverse(int a);
    internal int Multiply(int a, int b);
}
internal class iTextSharp.text.pdf.qrcode.GF256Poly : object {
    private GF256 field;
    private Int32[] coefficients;
    internal GF256Poly(GF256 field, Int32[] coefficients);
    internal Int32[] GetCoefficients();
    internal int GetDegree();
    internal bool IsZero();
    internal int GetCoefficient(int degree);
    internal int EvaluateAt(int a);
    internal GF256Poly AddOrSubtract(GF256Poly other);
    internal GF256Poly Multiply(GF256Poly other);
    internal GF256Poly Multiply(int scalar);
    internal GF256Poly MultiplyByMonomial(int degree, int coefficient);
    internal GF256Poly[] Divide(GF256Poly other);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.MaskUtil : object {
    public static int ApplyMaskPenaltyRule1(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule2(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule3(ByteMatrix matrix);
    public static int ApplyMaskPenaltyRule4(ByteMatrix matrix);
    public static bool GetDataMaskBit(int maskPattern, int x, int y);
    private static int ApplyMaskPenaltyRule1Internal(ByteMatrix matrix, bool isHorizontal);
}
public class iTextSharp.text.pdf.qrcode.MatrixUtil : object {
    private static Int32[][] POSITION_DETECTION_PATTERN;
    private static Int32[][] HORIZONTAL_SEPARATION_PATTERN;
    private static Int32[][] VERTICAL_SEPARATION_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
    private static Int32[][] TYPE_INFO_COORDINATES;
    private static int VERSION_INFO_POLY;
    private static int TYPE_INFO_POLY;
    private static int TYPE_INFO_MASK_PATTERN;
    private static MatrixUtil();
    public static void ClearMatrix(ByteMatrix matrix);
    public static void BuildMatrix(BitVector dataBits, ErrorCorrectionLevel ecLevel, int version, int maskPattern, ByteMatrix matrix);
    public static void EmbedBasicPatterns(int version, ByteMatrix matrix);
    public static void EmbedTypeInfo(ErrorCorrectionLevel ecLevel, int maskPattern, ByteMatrix matrix);
    public static void MaybeEmbedVersionInfo(int version, ByteMatrix matrix);
    public static void EmbedDataBits(BitVector dataBits, int maskPattern, ByteMatrix matrix);
    public static int FindMSBSet(int value);
    public static int CalculateBCHCode(int value, int poly);
    public static void MakeTypeInfoBits(ErrorCorrectionLevel ecLevel, int maskPattern, BitVector bits);
    public static void MakeVersionInfoBits(int version, BitVector bits);
    private static bool IsEmpty(int value);
    private static bool IsValidValue(int value);
    private static void EmbedTimingPatterns(ByteMatrix matrix);
    private static void EmbedDarkDotAtLeftBottomCorner(ByteMatrix matrix);
    private static void EmbedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedVerticalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionAdjustmentPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionDetectionPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void EmbedPositionDetectionPatternsAndSeparators(ByteMatrix matrix);
    private static void MaybeEmbedPositionAdjustmentPatterns(int version, ByteMatrix matrix);
}
public class iTextSharp.text.pdf.qrcode.Mode : object {
    public static Mode TERMINATOR;
    public static Mode NUMERIC;
    public static Mode ALPHANUMERIC;
    public static Mode STRUCTURED_APPEND;
    public static Mode BYTE;
    public static Mode ECI;
    public static Mode KANJI;
    public static Mode FNC1_FIRST_POSITION;
    public static Mode FNC1_SECOND_POSITION;
    private Int32[] characterCountBitsForVersions;
    private int bits;
    private string name;
    private Mode(Int32[] characterCountBitsForVersions, int bits, string name);
    private static Mode();
    public static Mode ForBits(int bits);
    public int GetCharacterCountBits(Version version);
    public int GetBits();
    public string GetName();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.qrcode.QRCode : object {
    public static int NUM_MASK_PATTERNS;
    private Mode mode;
    private ErrorCorrectionLevel ecLevel;
    private int version;
    private int matrixWidth;
    private int maskPattern;
    private int numTotalBytes;
    private int numDataBytes;
    private int numECBytes;
    private int numRSBlocks;
    private ByteMatrix matrix;
    public Mode GetMode();
    public ErrorCorrectionLevel GetECLevel();
    public int GetVersion();
    public int GetMatrixWidth();
    public int GetMaskPattern();
    public int GetNumTotalBytes();
    public int GetNumDataBytes();
    public int GetNumECBytes();
    public int GetNumRSBlocks();
    public ByteMatrix GetMatrix();
    public int At(int x, int y);
    public bool IsValid();
    public virtual string ToString();
    public void SetMode(Mode value);
    public void SetECLevel(ErrorCorrectionLevel value);
    public void SetVersion(int value);
    public void SetMatrixWidth(int value);
    public void SetMaskPattern(int value);
    public void SetNumTotalBytes(int value);
    public void SetNumDataBytes(int value);
    public void SetNumECBytes(int value);
    public void SetNumRSBlocks(int value);
    public void SetMatrix(ByteMatrix value);
    public static bool IsValidMaskPattern(int maskPattern);
}
public class iTextSharp.text.pdf.qrcode.QRCodeWriter : object {
    private static int QUIET_ZONE_SIZE;
    public ByteMatrix Encode(string contents, int width, int height);
    public ByteMatrix Encode(string contents, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private static ByteMatrix RenderResult(QRCode code, int width, int height);
    private static void SetRowColor(SByte[] row, sbyte value);
}
public class iTextSharp.text.pdf.qrcode.ReedSolomonEncoder : object {
    private GF256 field;
    private List`1<GF256Poly> cachedGenerators;
    public ReedSolomonEncoder(GF256 field);
    private GF256Poly BuildGenerator(int degree);
    public void Encode(Int32[] toEncode, int ecBytes);
}
public class iTextSharp.text.pdf.qrcode.ReedSolomonException : Exception {
    public ReedSolomonException(string message);
    protected ReedSolomonException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.qrcode.Version : object {
    private static Int32[] VERSION_DECODE_INFO;
    private static Version[] VERSIONS;
    private int versionNumber;
    private Int32[] alignmentPatternCenters;
    private ECBlocks[] ecBlocks;
    private int totalCodewords;
    private Version(int versionNumber, Int32[] alignmentPatternCenters, ECBlocks ecBlocks1, ECBlocks ecBlocks2, ECBlocks ecBlocks3, ECBlocks ecBlocks4);
    private static Version();
    public int GetVersionNumber();
    public Int32[] GetAlignmentPatternCenters();
    public int GetTotalCodewords();
    public int GetDimensionForVersion();
    public ECBlocks GetECBlocksForLevel(ErrorCorrectionLevel ecLevel);
    public static Version GetProvisionalVersionForDimension(int dimension);
    public static Version GetVersionForNumber(int versionNumber);
    private static Version DecodeVersionInformation(int versionBits);
    private BitMatrix BuildFunctionPattern();
    public virtual string ToString();
    private static Version[] BuildVersions();
}
public class iTextSharp.text.pdf.qrcode.WriterException : Exception {
    public WriterException(string message);
    protected WriterException(SerializationInfo info, StreamingContext context);
}
public class iTextSharp.text.pdf.RadioCheckField : BaseField {
    public static int TYPE_CHECK;
    public static int TYPE_CIRCLE;
    public static int TYPE_CROSS;
    public static int TYPE_DIAMOND;
    public static int TYPE_SQUARE;
    public static int TYPE_STAR;
    protected static String[] typeChars;
    protected int checkType;
    private string onValue;
    private bool vchecked;
    public int CheckType { get; public set; }
    public string OnValue { get; public set; }
    public bool Checked { get; public set; }
    public PdfFormField RadioField { get; }
    public PdfFormField CheckField { get; }
    public RadioCheckField(PdfWriter writer, Rectangle box, string fieldName, string onValue);
    private static RadioCheckField();
    public virtual int get_CheckType();
    public virtual void set_CheckType(int value);
    public virtual string get_OnValue();
    public virtual void set_OnValue(string value);
    public virtual bool get_Checked();
    public virtual void set_Checked(bool value);
    public virtual PdfAppearance GetAppearance(bool isRadio, bool on);
    public virtual PdfAppearance GetAppearanceRadioCircle(bool on);
    public virtual PdfFormField GetRadioGroup(bool noToggleToOff, bool radiosInUnison);
    public virtual PdfFormField get_RadioField();
    public virtual PdfFormField get_CheckField();
    protected virtual PdfFormField GetField(bool isRadio);
}
public class iTextSharp.text.pdf.RandomAccessFileOrArray : object {
    private IRandomAccessSource byteSource;
    private long byteSourcePosition;
    private byte back;
    private bool isBack;
    public long Length { get; }
    public long FilePointer { get; }
    public RandomAccessFileOrArray(string filename);
    public RandomAccessFileOrArray(RandomAccessFileOrArray source);
    public RandomAccessFileOrArray(IRandomAccessSource byteSource);
    public RandomAccessFileOrArray(string filename, bool forceRead);
    public RandomAccessFileOrArray(Uri url);
    public RandomAccessFileOrArray(Stream inp);
    public RandomAccessFileOrArray(Byte[] arrayIn);
    public virtual RandomAccessFileOrArray CreateView();
    public virtual IRandomAccessSource CreateSourceView();
    protected internal virtual IRandomAccessSource GetByteSource();
    public virtual void PushBack(byte b);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int Read(Byte[] b);
    public virtual void ReadFully(Byte[] b);
    public virtual void ReadFully(Byte[] b, int off, int len);
    public virtual long Skip(long n);
    public virtual long SkipBytes(long n);
    public virtual void ReOpen();
    public virtual void Close();
    public virtual long get_Length();
    public virtual void Seek(long pos);
    public virtual void Seek(int pos);
    public virtual long get_FilePointer();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual int ReadUnsignedByte();
    public virtual short ReadShort();
    public short ReadShortLE();
    public virtual int ReadUnsignedShort();
    public int ReadUnsignedShortLE();
    public virtual char ReadChar();
    public char ReadCharLE();
    public virtual int ReadInt();
    public int ReadIntLE();
    public long ReadUnsignedInt();
    public long ReadUnsignedIntLE();
    public virtual long ReadLong();
    public long ReadLongLE();
    public virtual float ReadFloat();
    public float ReadFloatLE();
    public virtual double ReadDouble();
    public double ReadDoubleLE();
    public virtual string ReadLine();
    public virtual string ReadString(int length, string encoding);
}
public class iTextSharp.text.pdf.ReaderProperties : object {
    internal X509Certificate certificate;
    internal ICipherParameters certificateKey;
    internal Byte[] ownerPassword;
    internal bool partialRead;
    internal bool closeSourceOnconstructorError;
    internal MemoryLimitsAwareHandler memoryLimitsAwareHandler;
    public ReaderProperties SetCertificate(X509Certificate certificate);
    public ReaderProperties SetCertificateKey(ICipherParameters certificateKey);
    public ReaderProperties SetOwnerPassword(Byte[] ownerPassword);
    public ReaderProperties SetPartialRead(bool partialRead);
    public ReaderProperties SetCloseSourceOnconstructorError(bool closeSourceOnconstructorError);
    public ReaderProperties SetMemoryLimitsAwareHandler(MemoryLimitsAwareHandler memoryLimitsAwareHandler);
}
public class iTextSharp.text.pdf.RefKey : object {
    private int num;
    private int gen;
    internal RefKey(int num, int gen);
    public RefKey(PdfIndirectReference referemce);
    internal RefKey(PRIndirectReference reference);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.security.AsymmetricAlgorithmSignature : object {
    private AsymmetricAlgorithm algorithm;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    private AsymmetricAlgorithmSignature(AsymmetricAlgorithm algorithm, string hashAlgorithm);
    public AsymmetricAlgorithmSignature(RSACryptoServiceProvider algorithm, string hashAlgorithm);
    public AsymmetricAlgorithmSignature(DSACryptoServiceProvider algorithm);
    public sealed virtual Byte[] Sign(Byte[] message);
    public sealed virtual string GetHashAlgorithm();
    public sealed virtual string GetEncryptionAlgorithm();
}
public static class iTextSharp.text.pdf.security.CertificateInfo : object {
    public static X509Name GetIssuerFields(X509Certificate cert);
    public static Asn1Object GetIssuer(Byte[] enc);
    public static X509Name GetSubjectFields(X509Certificate cert);
    private static Asn1Object GetSubject(Byte[] enc);
}
public static class iTextSharp.text.pdf.security.CertificateUtil : object {
    public static string GetCRLURL(X509Certificate certificate);
    public static string GetOCSPURL(X509Certificate certificate);
    public static string GetTSAURL(X509Certificate certificate);
    private static Asn1Object GetExtensionValue(X509Certificate cert, string oid);
    private static string GetStringFromGeneralName(Asn1Object names);
}
public static class iTextSharp.text.pdf.security.CertificateVerification : object {
    public static string VerifyCertificate(X509Certificate cert, ICollection`1<X509Crl> crls, DateTime calendar);
    public static IList`1<VerificationException> VerifyCertificates(ICollection`1<X509Certificate> certs, ICollection`1<X509Certificate> keystore, ICollection`1<X509Crl> crls, DateTime calendar);
    public static IList`1<VerificationException> VerifyCertificates(ICollection`1<X509Certificate> certs, ICollection`1<X509Certificate> keystore, DateTime calendar);
    public static bool VerifyOcspCertificates(BasicOcspResp ocsp, ICollection`1<X509Certificate> keystore);
    public static bool VerifyTimestampCertificates(TimeStampToken ts, ICollection`1<X509Certificate> keystore);
}
public class iTextSharp.text.pdf.security.CertificateVerifier : object {
    protected CertificateVerifier verifier;
    protected bool onlineCheckingAllowed;
    unknown bool OnlineCheckingAllowed {public set; }
    public CertificateVerifier(CertificateVerifier verifier);
    public virtual void set_OnlineCheckingAllowed(bool value);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
}
public class iTextSharp.text.pdf.security.CrlClientOffline : object {
    private List`1<Byte[]> crls;
    public CrlClientOffline(Byte[] crlEncoded);
    public virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public class iTextSharp.text.pdf.security.CrlClientOnline : object {
    private static ILogger LOGGER;
    protected IList`1<string> urls;
    public CrlClientOnline(String[] crls);
    public CrlClientOnline(ICollection`1<X509Certificate> chain);
    private static CrlClientOnline();
    protected virtual void AddUrl(string url);
    public virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public class iTextSharp.text.pdf.security.CrlVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    private List`1<X509Crl> crls;
    public CrlVerifier(CertificateVerifier verifier, List`1<X509Crl> crls);
    private static CrlVerifier();
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual bool Verify(X509Crl crl, X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual X509Crl GetCrl(X509Certificate signCert, X509Certificate issuerCert);
    public virtual bool IsSignatureValid(X509Crl crl, X509Certificate crlIssuer);
}
public enum iTextSharp.text.pdf.security.CryptoStandard : Enum {
    public int value__;
    public static CryptoStandard CMS;
    public static CryptoStandard CADES;
}
public static class iTextSharp.text.pdf.security.DigestAlgorithms : object {
    public static string SHA1;
    public static string SHA256;
    public static string SHA384;
    public static string SHA512;
    public static string RIPEMD160;
    private static Dictionary`2<string, string> digestNames;
    private static Dictionary`2<string, string> allowedDigests;
    private static DigestAlgorithms();
    public static IDigest GetMessageDigestFromOid(string digestOid);
    public static IDigest GetMessageDigest(string hashAlgorithm);
    public static Byte[] Digest(Stream data, string hashAlgorithm);
    public static Byte[] Digest(Stream data, IDigest messageDigest);
    public static string GetDigest(string oid);
    public static string GetAllowedDigests(string name);
    public static Byte[] Digest(string algo, Byte[] b, int offset, int len);
    public static Byte[] Digest(string algo, Byte[] b);
    public static Byte[] Digest(IDigest d, Byte[] b, int offset, int len);
    public static Byte[] Digest(IDigest d, Byte[] b);
}
public static class iTextSharp.text.pdf.security.EncryptionAlgorithms : object {
    private static Dictionary`2<string, string> algorithmNames;
    private static EncryptionAlgorithms();
    public static string GetAlgorithm(string oid);
}
public interface iTextSharp.text.pdf.security.ICrlClient {
    public abstract virtual ICollection`1<Byte[]> GetEncoded(X509Certificate checkCert, string url);
}
public interface iTextSharp.text.pdf.security.IExternalSignature {
    public abstract virtual string GetHashAlgorithm();
    public abstract virtual string GetEncryptionAlgorithm();
    public abstract virtual Byte[] Sign(Byte[] message);
}
public interface iTextSharp.text.pdf.security.IExternalSignatureContainer {
    public abstract virtual Byte[] Sign(Stream data);
    public abstract virtual void ModifySigningDictionary(PdfDictionary signDic);
}
public interface iTextSharp.text.pdf.security.IOcspClient {
    public abstract virtual Byte[] GetEncoded(X509Certificate checkCert, X509Certificate rootCert, string url);
}
public interface iTextSharp.text.pdf.security.ITSAClient {
    public abstract virtual int GetTokenSizeEstimate();
    public abstract virtual IDigest GetMessageDigest();
    public abstract virtual Byte[] GetTimeStampToken(Byte[] imprint);
}
public interface iTextSharp.text.pdf.security.ITSAInfoBouncyCastle {
    public abstract virtual void InspectTimeStampTokenInfo(TimeStampTokenInfo info);
}
public interface iTextSharp.text.pdf.security.IXmlLocator {
    public abstract virtual XmlDocument GetDocument();
    public abstract virtual void SetDocument(XmlDocument document);
    public abstract virtual string GetEncoding();
}
public interface iTextSharp.text.pdf.security.IXpathConstructor {
    public abstract virtual string GetXpathExpression();
    public abstract virtual XmlNamespaceManager GetNamespaceManager();
}
public static class iTextSharp.text.pdf.security.LtvTimestamp : object {
    public static void Timestamp(PdfSignatureAppearance sap, ITSAClient tsa, string signatureName);
}
public class iTextSharp.text.pdf.security.LtvVerification : object {
    private ILogger LOGGER;
    private PdfStamper stp;
    private PdfWriter writer;
    private PdfReader reader;
    private AcroFields acroFields;
    private IDictionary`2<PdfName, ValidationData> validated;
    private bool used;
    public LtvVerification(PdfStamper stp);
    public virtual bool AddVerification(string signatureName, IOcspClient ocsp, ICrlClient crl, CertificateOption certOption, Level level, CertificateInclusion certInclude);
    private X509Certificate GetParent(X509Certificate cert, X509Certificate[] certs);
    public virtual bool AddVerification(string signatureName, ICollection`1<Byte[]> ocsps, ICollection`1<Byte[]> crls, ICollection`1<Byte[]> certs);
    private static Byte[] BuildOCSPResponse(Byte[] BasicOCSPResponse);
    private PdfName GetSignatureHashKey(string signatureName);
    private static Byte[] HashBytesSha1(Byte[] b);
    public virtual void Merge();
    private void UpdateDss();
    private static void DeleteOldReferences(PdfArray all, PdfArray toDelete);
    private void CreateDss();
    private void OutputDss(PdfDictionary dss, PdfDictionary vrim, PdfArray ocsps, PdfArray crls, PdfArray certs);
}
public class iTextSharp.text.pdf.security.LtvVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    protected CertificateOption option;
    protected bool verifyRootCertificate;
    protected PdfReader reader;
    protected AcroFields fields;
    protected DateTime signDate;
    protected string signatureName;
    protected PdfPKCS7 pkcs7;
    protected bool latestRevision;
    protected PdfDictionary dss;
    unknown CertificateVerifier Verifier {public set; }
    unknown CertificateOption CertificateOption {public set; }
    unknown bool VerifyRootCertificate {public set; }
    public LtvVerifier(PdfReader reader);
    private static LtvVerifier();
    public virtual void set_Verifier(CertificateVerifier value);
    public virtual void set_CertificateOption(CertificateOption value);
    public virtual void set_VerifyRootCertificate(bool value);
    protected virtual PdfPKCS7 CoversWholeDocument();
    public virtual List`1<VerificationOK> Verify(List`1<VerificationOK> result);
    public virtual List`1<VerificationOK> VerifySignature();
    public virtual void VerifyChain(X509Certificate[] chain);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime sigDate);
    public virtual void SwitchToPreviousRevision();
    public virtual List`1<X509Crl> GetCRLsFromDSS();
    public virtual List`1<BasicOcspResp> GetOCSPResponsesFromDSS();
}
public static class iTextSharp.text.pdf.security.MakeSignature : object {
    private static ILogger LOGGER;
    private static MakeSignature();
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype);
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype, SignaturePolicyInfo signaturePolicy);
    public static void SignDetached(PdfSignatureAppearance sap, IExternalSignature externalSignature, ICollection`1<X509Certificate> chain, ICollection`1<ICrlClient> crlList, IOcspClient ocspClient, ITSAClient tsaClient, int estimatedSize, CryptoStandard sigtype, SignaturePolicyIdentifier signaturePolicy);
    public static ICollection`1<Byte[]> ProcessCrl(X509Certificate cert, ICollection`1<ICrlClient> crlList);
    public static void SignExternalContainer(PdfSignatureAppearance sap, IExternalSignatureContainer externalSignatureContainer, int estimatedSize);
    public static void SignDeferred(PdfReader reader, string fieldName, Stream outs, IExternalSignatureContainer externalSignatureContainer);
}
public class iTextSharp.text.pdf.security.MakeXmlSignature : object {
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, KeyInfoClause keyInfo);
    public static void SignXades(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain, bool includeSignaturePolicy);
    public static void SignXadesBes(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXadesEpes(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, X509Certificate[] chain);
    public static void SignXmlDSig(XmlSignatureAppearance sap, IExternalSignature externalSignature, AsymmetricAlgorithm publicKey);
    private static void VerifyArguments(XmlSignatureAppearance sap, IExternalSignature externalSignature);
    private static void NormalizeNamespaces(XPathNavigator src, XPathNavigator dest);
    private static void NormalizeNamespaces(XPathNavigator src, XPathNavigator dest, string excludedNs);
    private static Byte[] CalculateC14nByteRange(XmlDocument doc);
    private static Byte[] CalculateC14nDigest(XmlDocument doc, HashAlgorithm hash);
    private static XmlElement GenerateSignatureElement(IXmlLocator locator, string signatureId, bool isXades);
    private static KeyInfoClause GenerateKeyInfo(X509Certificate[] chain, XmlSignatureAppearance sap);
    private static KeyInfoClause GenerateKeyInfo(AsymmetricAlgorithm publicKey);
    private static string GetRandomId();
    private static XmlElement GenerateXadesObject(XmlSignatureAppearance sap, string signatureId, string contentReferenceId, string signedPropertiesId, String[] signaturePolicy, XmlElement& signedProperty);
    private static string GetX509IssuerName(X509Certificate cert);
    private static string GetX509SerialNumber(X509Certificate cert);
    private static XmlElement GenerateContentReference(XmlDocument doc, XmlSignatureAppearance sap, string referenceId);
    private static XmlElement GenerateCustomReference(XmlDocument doc, XmlElement signedElement, string uri, string type, string id);
    private static void Sign(XmlElement signature, IXmlLocator xmlLocator, IExternalSignature externalSignature, List`1<XmlElement> references, XmlElement dsObject, KeyInfoClause keyInfo);
}
public class iTextSharp.text.pdf.security.OcspClientBouncyCastle : object {
    private static ILogger LOGGER;
    private OcspVerifier verifier;
    public OcspClientBouncyCastle(OcspVerifier verifier);
    private static OcspClientBouncyCastle();
    public virtual BasicOcspResp GetBasicOCSPResp(X509Certificate checkCert, X509Certificate rootCert, string url);
    public sealed virtual Byte[] GetEncoded(X509Certificate checkCert, X509Certificate rootCert, string url);
    private static OcspReq GenerateOCSPRequest(X509Certificate issuerCert, BigInteger serialNumber);
    private OcspResp GetOcspResponse(X509Certificate checkCert, X509Certificate rootCert, string url);
}
public class iTextSharp.text.pdf.security.OcspVerifier : RootStoreVerifier {
    private static ILogger LOGGER;
    protected static string id_kp_OCSPSigning;
    protected List`1<BasicOcspResp> ocsps;
    public OcspVerifier(CertificateVerifier verifier, List`1<BasicOcspResp> ocsps);
    private static OcspVerifier();
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual bool Verify(BasicOcspResp ocspResp, X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
    public virtual void IsValidResponse(BasicOcspResp ocspResp, X509Certificate issuerCert);
    [ObsoleteAttribute]
public virtual bool VerifyResponse(BasicOcspResp ocspResp, X509Certificate issuerCert);
    public virtual bool IsSignatureValid(BasicOcspResp ocspResp, X509Certificate responderCert);
    public virtual BasicOcspResp GetOcspResponse(X509Certificate signCert, X509Certificate issuerCert);
}
public class iTextSharp.text.pdf.security.PdfPKCS7 : object {
    private SignaturePolicyIdentifier signaturePolicyIdentifier;
    private string signName;
    private string reason;
    private string location;
    private DateTime signDate;
    private int version;
    private int signerversion;
    private string digestAlgorithmOid;
    private IDigest messageDigest;
    private Dictionary`2<string, object> digestalgos;
    private Byte[] digestAttr;
    private PdfName filterSubtype;
    private string digestEncryptionAlgorithmOid;
    private Byte[] externalDigest;
    private Byte[] externalRSAdata;
    private ISigner sig;
    private Byte[] digest;
    private Byte[] RSAdata;
    private Byte[] sigAttr;
    private Byte[] sigAttrDer;
    private IDigest encContDigest;
    private bool verified;
    private bool verifyResult;
    private List`1<X509Certificate> certs;
    private ICollection`1<X509Certificate> signCerts;
    private X509Certificate signCert;
    private ICollection`1<X509Crl> crls;
    private BasicOcspResp basicResp;
    private bool isTsp;
    private bool isCades;
    private TimeStampToken timeStampToken;
    public string SignName { get; public set; }
    public string Reason { get; public set; }
    public string Location { get; public set; }
    public DateTime SignDate { get; public set; }
    public int Version { get; }
    public int SigningInfoVersion { get; }
    public string DigestAlgorithmOid { get; }
    public string DigestEncryptionAlgorithmOid { get; }
    public X509Certificate[] Certificates { get; }
    public X509Certificate[] SignCertificateChain { get; }
    public X509Certificate SigningCertificate { get; }
    public ICollection`1<X509Crl> CRLs { get; }
    public BasicOcspResp Ocsp { get; }
    public bool IsTsp { get; }
    public TimeStampToken TimeStampToken { get; }
    public DateTime TimeStampDate { get; }
    public PdfPKCS7(ICipherParameters privKey, ICollection`1<X509Certificate> certChain, string hashAlgorithm, bool hasRSAdata);
    public PdfPKCS7(Byte[] contentsKey, Byte[] certsKey);
    public PdfPKCS7(Byte[] contentsKey, PdfName filterSubtype);
    internal IDigest GetHashClass();
    public virtual void SetSignaturePolicy(SignaturePolicyInfo signaturePolicy);
    public virtual void SetSignaturePolicy(SignaturePolicyIdentifier signaturePolicy);
    public virtual string get_SignName();
    public virtual void set_SignName(string value);
    public virtual string get_Reason();
    public virtual void set_Reason(string value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public virtual DateTime get_SignDate();
    public virtual void set_SignDate(DateTime value);
    public virtual int get_Version();
    public virtual int get_SigningInfoVersion();
    public virtual string get_DigestAlgorithmOid();
    public virtual string GetHashAlgorithm();
    public virtual string get_DigestEncryptionAlgorithmOid();
    public virtual string GetDigestAlgorithm();
    public virtual void SetExternalDigest(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    private ISigner InitSignature(ICipherParameters key);
    private ISigner InitSignature(AsymmetricKeyParameter key);
    public virtual void Update(Byte[] buf, int off, int len);
    public virtual Byte[] GetEncodedPKCS1();
    public virtual Byte[] GetEncodedPKCS7();
    public virtual Byte[] GetEncodedPKCS7(Byte[] secondDigest);
    public virtual Byte[] GetEncodedPKCS7(Byte[] secondDigest, ITSAClient tsaClient, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    private Asn1EncodableVector BuildUnauthenticatedAttributes(Byte[] timeStampToken);
    public virtual Byte[] getAuthenticatedAttributeBytes(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    private DerSet GetAuthenticatedAttributeSet(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptoStandard sigtype);
    public virtual bool Verify();
    private bool VerifySigAttributes(Byte[] attr);
    public virtual bool VerifyTimestampImprint();
    public virtual X509Certificate[] get_Certificates();
    public virtual X509Certificate[] get_SignCertificateChain();
    public virtual X509Certificate get_SigningCertificate();
    private void CalcSignCertificateChain();
    public virtual ICollection`1<X509Crl> get_CRLs();
    private void FindCRL(Asn1Sequence seq);
    public virtual BasicOcspResp get_Ocsp();
    public virtual bool IsRevocationValid();
    private void FindOcsp(Asn1Sequence seq);
    public virtual bool get_IsTsp();
    public virtual TimeStampToken get_TimeStampToken();
    public virtual DateTime get_TimeStampDate();
    public virtual PdfName GetFilterSubtype();
    public virtual string GetEncryptionAlgorithm();
}
internal class iTextSharp.text.pdf.security.PdfSignatureAppDictionary : PdfDictionary {
    unknown string SignatureCreator {public set; }
    public virtual void set_SignatureCreator(string value);
}
internal class iTextSharp.text.pdf.security.PdfSignatureBuildProperties : PdfDictionary {
    unknown string SignatureCreator {public set; }
    public virtual void set_SignatureCreator(string value);
    private PdfSignatureAppDictionary GetPdfSignatureAppProperty();
}
public class iTextSharp.text.pdf.security.PrivateKeySignature : object {
    private ICipherParameters pk;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    public PrivateKeySignature(ICipherParameters pk, string hashAlgorithm);
    public virtual Byte[] Sign(Byte[] b);
    public virtual string GetHashAlgorithm();
    public virtual string GetEncryptionAlgorithm();
}
public class iTextSharp.text.pdf.security.RootStoreVerifier : CertificateVerifier {
    private static ILogger LOGGER;
    protected List`1<X509Certificate> certificates;
    unknown List`1<X509Certificate> Certificates {public set; }
    public RootStoreVerifier(CertificateVerifier verifier);
    private static RootStoreVerifier();
    public virtual void set_Certificates(List`1<X509Certificate> value);
    public virtual List`1<VerificationOK> Verify(X509Certificate signCert, X509Certificate issuerCert, DateTime signDate);
}
internal class iTextSharp.text.pdf.security.SecurityConstants : object {
    public static string XMLNS;
    public static string XMLNS_XADES;
    public static string XMLNS_URI;
    public static string XMLDSIG_URI;
    public static string XADES_132_URI;
    public static string XMLDSIG_URI_C14N;
    public static string XMLDSIG_URI_RSA_SHA1;
    public static string XMLDSIG_URI_DSA_SHA1;
    public static string XMLDSIG_URI_ENVELOPED;
    public static string XMLDSIG_URI_XPATH_FILTER2;
    public static string XMLDSIG_URI_SHA1;
    public static string SignedProperties_Type;
    public static string OIDAsURN;
    public static string OID_DSA_SHA1;
    public static string OID_DSA_SHA1_DESC;
    public static string OID_RSA_SHA1;
    public static string OID_RSA_SHA1_DESC;
    public static string DSA;
    public static string RSA;
    public static string SHA1;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Signature;
    public static string SignatureValue;
    public static string X509SerialNumber;
    public static string X509IssuerName;
    public static string Algorithm;
    public static string Id;
    public static string ObjectReference;
    public static string Target;
    public static string Qualifier;
    public static string XADES_Encoding;
    public static string XADES_MimeType;
    public static string XADES_Description;
    public static string XADES_DataObjectFormat;
    public static string XADES_SignedDataObjectProperties;
    public static string XADES_IssuerSerial;
    public static string XADES_CertDigest;
    public static string XADES_Cert;
    public static string XADES_SigningCertificate;
    public static string XADES_SigningTime;
    public static string XADES_SignedSignatureProperties;
    public static string XADES_SignedProperties;
    public static string XADES_QualifyingProperties;
    public static string XADES_SignaturePolicyIdentifier;
    public static string XADES_SignaturePolicyId;
    public static string XADES_SigPolicyId;
    public static string XADES_Identifier;
    public static string XADES_SigPolicyHash;
    public static string Reference_;
    public static string SignedProperties_;
    public static string Signature_;
    public static string SigningTimeFormat;
}
public class iTextSharp.text.pdf.security.SecurityIDs : object {
    public static string ID_PKCS7_DATA;
    public static string ID_PKCS7_SIGNED_DATA;
    public static string ID_RSA;
    public static string ID_DSA;
    public static string ID_ECDSA;
    public static string ID_CONTENT_TYPE;
    public static string ID_MESSAGE_DIGEST;
    public static string ID_SIGNING_TIME;
    public static string ID_ADBE_REVOCATION;
    public static string ID_TSA;
    public static string ID_OCSP;
    public static string ID_AA_SIGNING_CERTIFICATE_V1;
    public static string ID_AA_SIGNING_CERTIFICATE_V2;
}
public class iTextSharp.text.pdf.security.SignaturePermissions : object {
    private bool certification;
    private bool fillInAllowed;
    private bool annotationsAllowed;
    private List`1<FieldLock> fieldLocks;
    public bool Certification { get; }
    public bool FillInAllowed { get; }
    public bool AnnotationsAllowed { get; }
    public List`1<FieldLock> FieldLocks { get; }
    public SignaturePermissions(PdfDictionary sigDict, SignaturePermissions previous);
    public virtual bool get_Certification();
    public virtual bool get_FillInAllowed();
    public virtual bool get_AnnotationsAllowed();
    public virtual List`1<FieldLock> get_FieldLocks();
}
public class iTextSharp.text.pdf.security.SignaturePolicyInfo : object {
    private string policyIdentifier;
    private Byte[] policyHash;
    private string policyDigestAlgorithm;
    private string policyUri;
    public string PolicyIdentifier { get; }
    public Byte[] PolicyHash { get; }
    public string PolicyDigestAlgorithm { get; }
    public string PolicyUri { get; }
    public SignaturePolicyInfo(string policyIdentifier, Byte[] policyHash, string policyDigestAlgorithm, string policyUri);
    public SignaturePolicyInfo(string policyIdentifier, string policyHashBase64, string policyDigestAlgorithm, string policyUri);
    public string get_PolicyIdentifier();
    public Byte[] get_PolicyHash();
    public string get_PolicyDigestAlgorithm();
    public string get_PolicyUri();
    protected internal SignaturePolicyIdentifier ToSignaturePolicyIdentifier();
}
public class iTextSharp.text.pdf.security.TSAClientBouncyCastle : object {
    private static ILogger LOGGER;
    protected internal string tsaURL;
    protected internal string tsaUsername;
    protected internal string tsaPassword;
    protected ITSAInfoBouncyCastle tsaInfo;
    public static int DEFAULTTOKENSIZE;
    protected internal int tokenSizeEstimate;
    public static string DEFAULTHASHALGORITHM;
    protected internal string digestAlgorithm;
    private string tsaReqPolicy;
    public TSAClientBouncyCastle(string url);
    public TSAClientBouncyCastle(string url, string username, string password);
    public TSAClientBouncyCastle(string url, string username, string password, int tokSzEstimate, string digestAlgorithm);
    private static TSAClientBouncyCastle();
    public virtual void SetTSAInfo(ITSAInfoBouncyCastle tsaInfo);
    public virtual string GetTSAReqPolicy();
    public virtual void SetTSAReqPolicy(string tsaReqPolicy);
    public virtual int GetTokenSizeEstimate();
    public virtual IDigest GetMessageDigest();
    public virtual Byte[] GetTimeStampToken(Byte[] imprint);
    protected internal virtual Byte[] GetTSAResponse(Byte[] requestBytes);
}
public class iTextSharp.text.pdf.security.VerificationException : GeneralSecurityException {
    public VerificationException(X509Certificate cert, string message);
}
public class iTextSharp.text.pdf.security.VerificationOK : object {
    protected X509Certificate certificate;
    protected CertificateVerifier verifierClass;
    protected string message;
    public VerificationOK(X509Certificate cert, CertificateVerifier verifierClass, string message);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.security.X509Certificate2Signature : object {
    private X509Certificate2 certificate;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    public X509Certificate2Signature(X509Certificate2 certificate, string hashAlgorithm);
    public virtual Byte[] Sign(Byte[] message);
    public virtual string GetHashAlgorithm();
    public virtual string GetEncryptionAlgorithm();
}
public class iTextSharp.text.pdf.SequenceList : object {
    protected static int COMMA;
    protected static int MINUS;
    protected static int NOT;
    protected static int TEXT;
    protected static int NUMBER;
    protected static int END;
    protected static char EOT;
    private static int FIRST;
    private static int DIGIT;
    private static int OTHER;
    private static int DIGIT2;
    private static string NOT_OTHER;
    protected Char[] text;
    protected int ptr;
    protected int number;
    protected string other;
    protected int low;
    protected int high;
    protected bool odd;
    protected bool even;
    protected bool inverse;
    protected int Type { get; }
    protected SequenceList(string range);
    protected virtual char NextChar();
    protected virtual void PutBack();
    protected virtual int get_Type();
    private void OtherProc();
    protected virtual bool GetAttributes();
    public static ICollection`1<int> Expand(string ranges, int maxNumber);
}
public class iTextSharp.text.pdf.ShadingColor : ExtendedColor {
    private PdfShadingPattern shadingPattern;
    public PdfShadingPattern PdfShadingPattern { get; }
    public ShadingColor(PdfShadingPattern shadingPattern);
    public virtual PdfShadingPattern get_PdfShadingPattern();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.SimpleBookmark : object {
    private List`1<Dictionary`2<string, object>> topList;
    private Stack`1<Dictionary`2<string, object>> attr;
    private static IList`1<Dictionary`2<string, object>> BookmarkDepth(PdfReader reader, PdfDictionary outline, IntHashtable pages, bool processCurrentOutlineOnly);
    private static void MapGotoBookmark(Dictionary`2<string, object> map, PdfObject dest, IntHashtable pages);
    private static string MakeBookmarkParam(PdfArray dest, IntHashtable pages);
    private static int GetNumber(PdfIndirectReference indirect);
    public static IList`1<Dictionary`2<string, object>> GetBookmark(PdfReader reader);
    public static IList`1<Dictionary`2<string, object>> GetBookmark(PdfReader reader, PdfDictionary outline, bool includeRoot);
    public static void EliminatePages(IList`1<Dictionary`2<string, object>> list, Int32[] pageRange);
    public static void ShiftPageNumbers(IList`1<Dictionary`2<string, object>> list, int pageShift, Int32[] pageRange);
    public static string GetVal(Dictionary`2<string, object> map, string key);
    internal static void CreateOutlineAction(PdfDictionary outline, Dictionary`2<string, object> map, PdfWriter writer, bool namedAsNames);
    public static Object[] IterateOutlines(PdfWriter writer, PdfIndirectReference parent, IList`1<Dictionary`2<string, object>> kids, bool namedAsNames);
    public static void ExportToXMLNode(IList`1<Dictionary`2<string, object>> list, TextWriter outp, int indent, bool onlyASCII);
    public static void ExportToXML(IList`1<Dictionary`2<string, object>> list, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(IList`1<Dictionary`2<string, object>> list, TextWriter wrt, string encoding, bool onlyASCII);
    public static IList`1<Dictionary`2<string, object>> ImportFromXML(Stream inp);
    public static IList`1<Dictionary`2<string, object>> ImportFromXML(TextReader inp);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SimpleNamedDestination : object {
    private Dictionary`2<string, string> xmlNames;
    private Dictionary`2<string, string> xmlLast;
    public static Dictionary`2<string, string> GetNamedDestination(PdfReader reader, bool fromNames);
    public static void ExportToXML(Dictionary`2<string, string> names, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(Dictionary`2<string, string> names, TextWriter wrt, string encoding, bool onlyASCII);
    public static Dictionary`2<string, string> ImportFromXML(Stream inp);
    public static Dictionary`2<string, string> ImportFromXML(TextReader inp);
    internal static PdfArray CreateDestinationArray(string value, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsNames(Dictionary`2<string, string> names, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsStrings(Dictionary`2<string, string> names, PdfWriter writer);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SpotColor : ExtendedColor {
    private PdfSpotColor spot;
    private float tint;
    public PdfSpotColor PdfSpotColor { get; }
    public float Tint { get; }
    public SpotColor(PdfSpotColor spot, float tint);
    public virtual PdfSpotColor get_PdfSpotColor();
    public virtual float get_Tint();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.StampContent : PdfContentByte {
    internal PageStamp ps;
    internal PageResources pageResources;
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    protected PdfIndirectReference CurrentPage { get; }
    internal StampContent(PdfStamperImp stamper, PageStamp ps);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PageResources get_PageResources();
    internal virtual void AddAnnotation(PdfAnnotation annot);
    protected virtual PdfIndirectReference get_CurrentPage();
}
public class iTextSharp.text.pdf.StringUtils : object {
    private static Byte[] r;
    private static Byte[] n;
    private static Byte[] t;
    private static Byte[] b;
    private static Byte[] f;
    private static StringUtils();
    public static Byte[] EscapeString(Byte[] b);
    public static void EscapeString(Byte[] bytes, ByteBuffer content);
    public static Byte[] ConvertCharsToBytes(Char[] chars);
}
public class iTextSharp.text.pdf.TextField : BaseField {
    private string defaultText;
    private String[] choices;
    private String[] choiceExports;
    private List`1<int> choiceSelections;
    private int topFirst;
    private int visibleTopChoice;
    private float extraMarginLeft;
    private float extraMarginTop;
    private List`1<BaseFont> substitutionFonts;
    private BaseFont extensionFont;
    public string DefaultText { get; public set; }
    public String[] Choices { get; public set; }
    public String[] ChoiceExports { get; public set; }
    public int ChoiceSelection { get; public set; }
    public List`1<int> ChoiceSelections { get; public set; }
    public int VisibleTopChoice { get; public set; }
    internal int TopFirst { get; }
    public List`1<BaseFont> SubstitutionFonts { get; public set; }
    public BaseFont ExtensionFont { get; public set; }
    public TextField(PdfWriter writer, Rectangle box, string fieldName);
    private static bool CheckRTL(string text);
    private static void ChangeFontSize(Phrase p, float size);
    private Phrase ComposePhrase(string text, BaseFont ufont, BaseColor color, float fontSize);
    public static string RemoveCRLF(string text);
    public static string ObfuscatePassword(string text);
    public virtual PdfAppearance GetAppearance();
    internal PdfAppearance GetListAppearance();
    public virtual PdfFormField GetTextField();
    public virtual PdfFormField GetComboField();
    public virtual PdfFormField GetListField();
    private int GetTopChoice();
    protected virtual PdfFormField GetChoiceField(bool isList);
    private void WriteMultipleValues(PdfFormField field, String[0...,0...] mix);
    public virtual string get_DefaultText();
    public virtual void set_DefaultText(string value);
    public virtual String[] get_Choices();
    public virtual void set_Choices(String[] value);
    public virtual String[] get_ChoiceExports();
    public virtual void set_ChoiceExports(String[] value);
    public virtual int get_ChoiceSelection();
    public virtual void set_ChoiceSelection(int value);
    public virtual List`1<int> get_ChoiceSelections();
    public virtual void set_ChoiceSelections(List`1<int> value);
    public virtual int get_VisibleTopChoice();
    public virtual void set_VisibleTopChoice(int value);
    public virtual void AddChoiceSelection(int selection);
    internal int get_TopFirst();
    public virtual void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public virtual void set_SubstitutionFonts(List`1<BaseFont> value);
    public virtual List`1<BaseFont> get_SubstitutionFonts();
    public virtual void set_ExtensionFont(BaseFont value);
    public virtual BaseFont get_ExtensionFont();
}
public class iTextSharp.text.pdf.TrueTypeFont : BaseFont {
    internal static String[] codePages;
    protected bool justNames;
    protected Dictionary`2<string, Int32[]> tables;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool cff;
    protected int cffOffset;
    protected int cffLength;
    protected int directoryOffset;
    protected string ttcIndex;
    protected string style;
    protected FontHeader head;
    protected HorizontalHeader hhea;
    protected WindowsMetrics os_2;
    protected Int32[] glyphWidthsByIndex;
    protected Int32[][] bboxes;
    protected Dictionary`2<int, Int32[]> cmap10;
    protected Dictionary`2<int, Int32[]> cmap31;
    protected Dictionary`2<int, Int32[]> cmapExt;
    protected Int32[] glyphIdToChar;
    protected int maxGlyphId;
    protected IntHashtable kerning;
    protected string fontName;
    protected String[][] subFamily;
    protected String[][] fullName;
    protected String[][] allNameEntries;
    protected String[][] familyName;
    protected double italicAngle;
    protected bool isFixedPitch;
    protected int underlinePosition;
    protected int underlineThickness;
    public RandomAccessFileOrArray Rf { get; }
    public string FileName { get; }
    public bool Cff { get; }
    public int DirectoryOffset { get; }
    internal string BaseFont { get; }
    public string PostscriptFontName { get; public set; }
    public String[] CodePagesSupported { get; }
    public String[][] FullFontName { get; }
    public string Subfamily { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public int MaxGlyphId { get; }
    internal TrueTypeFont(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool justNames, bool forceRead);
    private static TrueTypeFont();
    public virtual RandomAccessFileOrArray get_Rf();
    public virtual string get_FileName();
    public virtual bool get_Cff();
    public virtual int get_DirectoryOffset();
    protected static string GetTTCName(string name);
    internal void FillTables();
    internal string get_BaseFont();
    internal String[][] GetNames(int id);
    internal String[][] GetAllNames();
    internal void CheckCff();
    internal void Process(Byte[] ttfAfm, bool preload);
    protected virtual string ReadStandardString(int length);
    protected virtual string ReadUnicodeString(int length);
    protected virtual void ReadGlyphWidths();
    protected internal virtual int GetGlyphWidth(int glyph);
    private void ReadBbox();
    internal void ReadCMaps();
    internal Dictionary`2<int, Int32[]> ReadFormat12();
    internal Dictionary`2<int, Int32[]> ReadFormat0();
    internal Dictionary`2<int, Int32[]> ReadFormat4();
    internal Dictionary`2<int, Int32[]> ReadFormat6();
    internal void ReadKerning();
    public virtual int GetKerning(int char1, int char2);
    internal virtual int GetRawWidth(int c, string name);
    public virtual PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream, string subsetPrefix, PdfIndirectReference cidset);
    protected virtual PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, string subsetPrefix, int firstChar, int lastChar, Byte[] shortTag);
    public virtual Byte[] GetFullFont();
    protected internal virtual Byte[] GetSubSet(HashSet2`1<int> glyphs, bool subsetp);
    protected static Int32[] CompactRanges(List`1<Int32[]> ranges);
    public virtual void AddRangeUni(Dictionary`2<int, Int32[]> longTag, bool includeMetrics, bool subsetp);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual Byte[] ReadCffFont();
    public virtual PdfStream GetFullFontStream();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[] get_CodePagesSupported();
    public virtual String[][] get_FullFontName();
    public virtual string get_Subfamily();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal bool IsWinAnsiSupported();
    public int get_MaxGlyphId();
}
public class iTextSharp.text.pdf.TrueTypeFontSubSet : object {
    internal static String[] tableNamesSimple;
    internal static String[] tableNamesCmap;
    internal static String[] tableNamesExtra;
    internal static Int32[] entrySelectors;
    internal static int TABLE_CHECKSUM;
    internal static int TABLE_OFFSET;
    internal static int TABLE_LENGTH;
    internal static int HEAD_LOCA_FORMAT_OFFSET;
    internal static int ARG_1_AND_2_ARE_WORDS;
    internal static int WE_HAVE_A_SCALE;
    internal static int MORE_COMPONENTS;
    internal static int WE_HAVE_AN_X_AND_Y_SCALE;
    internal static int WE_HAVE_A_TWO_BY_TWO;
    protected Dictionary`2<string, Int32[]> tableDirectory;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool includeCmap;
    protected bool includeExtras;
    protected bool locaShortTable;
    protected Int32[] locaTable;
    protected HashSet2`1<int> glyphsUsed;
    protected List`1<int> glyphsInList;
    protected int tableGlyphOffset;
    protected Int32[] newLocaTable;
    protected Byte[] newLocaTableOut;
    protected Byte[] newGlyfTable;
    protected int glyfTableRealSize;
    protected int locaTableRealSize;
    protected Byte[] outFont;
    protected int fontPtr;
    protected int directoryOffset;
    public TrueTypeFontSubSet(string fileName, RandomAccessFileOrArray rf, HashSet2`1<int> glyphsUsed, int directoryOffset, bool includeCmap, bool includeExtras);
    private static TrueTypeFontSubSet();
    public virtual Byte[] Process();
    protected virtual void AssembleFont();
    protected virtual void CreateTableDirectory();
    protected virtual void ReadLoca();
    protected virtual void CreateNewGlyphTables();
    protected virtual void LocaTobytes();
    protected virtual void FlatGlyphs();
    protected virtual void CheckGlyphComposite(int glyph);
    protected virtual string ReadStandardString(int length);
    protected virtual void WriteFontShort(int n);
    protected virtual void WriteFontInt(int n);
    protected virtual void WriteFontString(string s);
    protected virtual int CalculateChecksum(Byte[] b);
}
public class iTextSharp.text.pdf.TrueTypeFontUnicode : TrueTypeFont {
    private static Byte[] rotbits;
    internal TrueTypeFontUnicode(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool forceRead);
    private static TrueTypeFontUnicode();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual PdfStream GetToUnicode(Object[] metrics);
    internal static string ToHex(int n);
    public virtual PdfDictionary GetCIDFontType2(PdfIndirectReference fontDescriptor, string subsetPrefix, Object[] metrics);
    public virtual PdfDictionary GetFontBaseType(PdfIndirectReference descendant, string subsetPrefix, PdfIndirectReference toUnicode);
    public virtual int GetCharFromGlyphId(int gid);
    public virtual int Compare(Int32[] o1, Int32[] o2);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual Int32[] GetCharBBox(int c);
}
public class iTextSharp.text.pdf.TtfUnicodeWriter : object {
    protected PdfWriter writer;
    public TtfUnicodeWriter(PdfWriter writer);
    protected internal virtual void WriteFont(TrueTypeFontUnicode font, PdfIndirectReference refer, Object[] parms, Byte[] rotbits);
}
internal class iTextSharp.text.pdf.Type1Font : BaseFont {
    private object lockObject;
    protected Byte[] pfb;
    private string FontName;
    private string FullName;
    private string FamilyName;
    private string Weight;
    private float ItalicAngle;
    private bool IsFixedPitch;
    private string CharacterSet;
    private int llx;
    private int lly;
    private int urx;
    private int ury;
    private int UnderlinePosition;
    private int UnderlineThickness;
    private string EncodingScheme;
    private int CapHeight;
    private int XHeight;
    private int Ascender;
    private int Descender;
    private int StdHW;
    private int StdVW;
    private Dictionary`2<object, Object[]> CharMetrics;
    private Dictionary`2<string, Object[]> KernPairs;
    private string fileName;
    private bool builtinFont;
    private static Int32[] PFB_TYPES;
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal Type1Font(string afmFile, string enc, bool emb, Byte[] ttfAfm, Byte[] pfb, bool forceRead);
    private static Type1Font();
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    public virtual void Process(RandomAccessFileOrArray rf);
    public virtual PdfStream GetFullFontStream();
    public virtual PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream);
    private PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, int firstChar, int lastChar, Byte[] shortTag);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual void SetFontDescriptor(int key, float value);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
public class iTextSharp.text.pdf.Type3Font : BaseFont {
    private Boolean[] usedSlot;
    private IntHashtable widths3;
    private Dictionary`2<char, Type3Glyph> char2glyph;
    private PdfWriter writer;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    private PageResources pageResources;
    private bool colorized;
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    public Type3Font(PdfWriter writer, Char[] chars, bool colorized);
    public Type3Font(PdfWriter writer, bool colorized);
    public virtual PdfContentByte DefineGlyph(char c, float wx, float llx, float lly, float urx, float ury);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public virtual PdfStream GetFullFontStream();
    public virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual Int32[] GetCharBBox(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
}
public class iTextSharp.text.pdf.Type3Glyph : PdfContentByte {
    private PageResources pageResources;
    private bool colorized;
    internal PageResources PageResources { get; }
    internal Type3Glyph(PdfWriter writer, PageResources pageResources, float wx, float llx, float lly, float urx, float ury, bool colorized);
    internal virtual PageResources get_PageResources();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public PdfContentByte GetDuplicate();
}
public class iTextSharp.text.pdf.VerticalText : object {
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected List`1<PdfChunk> chunks;
    protected PdfContentByte text;
    protected int alignment;
    protected int currentChunkMarker;
    protected PdfChunk currentStandbyChunk;
    protected string splittedChunkText;
    protected float leading;
    protected float startX;
    protected float startY;
    protected int maxLines;
    protected float height;
    private float curCharSpace;
    public float Leading { get; public set; }
    public float OriginX { get; }
    public float OriginY { get; }
    public int MaxLines { get; public set; }
    public float Height { get; public set; }
    public int Alignment { get; public set; }
    public VerticalText(PdfContentByte text);
    private static VerticalText();
    public virtual void AddText(Phrase phrase);
    public virtual void AddText(Chunk chunk);
    public virtual void SetVerticalLayout(float startX, float startY, float height, int maxLines, float leading);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    protected virtual PdfLine CreateLine(float width);
    protected virtual void ShortenChunkArray();
    public virtual int Go();
    public virtual int Go(bool simulate);
    internal void WriteLine(PdfLine line, PdfContentByte text, PdfContentByte graphics);
    public virtual void SetOrigin(float startX, float startY);
    public virtual float get_OriginX();
    public virtual float get_OriginY();
    public virtual int get_MaxLines();
    public virtual void set_MaxLines(int value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual int get_Alignment();
    public virtual void set_Alignment(int value);
}
public class iTextSharp.text.pdf.XfaForm : object {
    private Xml2SomTemplate templateSom;
    private XmlNode templateNode;
    private Xml2SomDatasets datasetsSom;
    private AcroFieldsSearch acroFieldsSom;
    private PdfReader reader;
    private bool xfaPresent;
    private XmlDocument domDocument;
    private bool changed;
    private XmlNode datasetsNode;
    public static string XFA_DATA_SCHEMA;
    public bool XfaPresent { get; public set; }
    public XmlDocument DomDocument { get; public set; }
    public PdfReader Reader { get; public set; }
    public bool Changed { get; public set; }
    public Xml2SomTemplate TemplateSom { get; public set; }
    public Xml2SomDatasets DatasetsSom { get; public set; }
    public AcroFieldsSearch AcroFieldsSom { get; public set; }
    public XmlNode DatasetsNode { get; }
    public XfaForm(PdfReader reader);
    public static PdfObject GetXfaObject(PdfReader reader);
    private void ExtractNodes();
    private XmlNode FindDataNode(XmlNode datasetsNode);
    public static Dictionary`2<string, XmlNode> ExtractXFANodes(XmlDocument domDocument);
    private void CreateDatasetsNode(XmlNode n);
    public static void SetXfa(XfaForm form, PdfReader reader, PdfWriter writer);
    public virtual void SetXfa(PdfWriter writer);
    public static Byte[] SerializeDoc(XmlNode n);
    public virtual bool get_XfaPresent();
    public virtual void set_XfaPresent(bool value);
    public virtual XmlDocument get_DomDocument();
    public virtual void set_DomDocument(XmlDocument value);
    public virtual string FindFieldName(string name, AcroFields af);
    public virtual string FindDatasetsName(string name);
    public virtual XmlNode FindDatasetsNode(string name);
    public static string GetNodeText(XmlNode n);
    private static string GetNodeText(XmlNode n, string name);
    public virtual void SetNodeText(XmlNode n, string text);
    public virtual void set_Reader(PdfReader value);
    public virtual PdfReader get_Reader();
    public virtual bool get_Changed();
    public virtual void set_Changed(bool value);
    public virtual Xml2SomTemplate get_TemplateSom();
    public virtual void set_TemplateSom(Xml2SomTemplate value);
    public virtual Xml2SomDatasets get_DatasetsSom();
    public virtual void set_DatasetsSom(Xml2SomDatasets value);
    public virtual AcroFieldsSearch get_AcroFieldsSom();
    public virtual void set_AcroFieldsSom(AcroFieldsSearch value);
    public virtual XmlNode get_DatasetsNode();
    public virtual void FillXfaForm(string file);
    public virtual void FillXfaForm(Stream stream);
    public virtual void FillXfaForm(Stream stream, bool readOnly);
    public virtual void FillXfaForm(XmlReader reader);
    public virtual void FillXfaForm(XmlReader reader, bool readOnly);
    public virtual void FillXfaForm(XmlNode node);
    public virtual void FillXfaForm(XmlNode node, bool readOnly);
    private XmlNode GetFirstElementNode(XmlNode src);
}
public class iTextSharp.text.pdf.XfaXmlLocator : object {
    private PdfStamper stamper;
    private XfaForm xfaForm;
    private string encoding;
    public XfaXmlLocator(PdfStamper stamper);
    protected virtual void CreateXfaForm();
    public virtual XmlDocument GetDocument();
    public virtual void SetDocument(XmlDocument document);
    public virtual string GetEncoding();
    public virtual void SetEncoding(string encoding);
}
public class iTextSharp.text.pdf.XfaXpathConstructor : object {
    private static string CONFIG;
    private static string CONNECTIONSET;
    private static string DATASETS;
    private static string LOCALESET;
    private static string PDF;
    private static string SOURCESET;
    private static string STYLESHEET;
    private static string TEMPLATE;
    private static string XDC;
    private static string XFDF;
    private static string XMPMETA;
    private string xpathExpression;
    private XmlNamespaceManager namespaceManager;
    public XfaXpathConstructor(XdpPackage xdpPackage);
    public virtual string GetXpathExpression();
    public virtual XmlNamespaceManager GetNamespaceManager();
}
public class iTextSharp.text.pdf.XfdfReader : object {
    private bool foundRoot;
    private Stackr fieldNames;
    private Stackr fieldValues;
    internal Dictionary`2<string, string> fields;
    protected Dictionary`2<string, List`1<string>> listFields;
    internal string fileSpec;
    public Dictionary`2<string, string> Fields { get; }
    public string FileSpec { get; }
    public XfdfReader(string filename);
    public XfdfReader(Byte[] xfdfIn);
    public XfdfReader(Stream isp);
    public virtual Dictionary`2<string, string> get_Fields();
    public virtual string GetField(string name);
    public virtual string GetFieldValue(string name);
    public virtual List`1<string> GetListValues(string name);
    public virtual string get_FileSpec();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void EndDocument();
    public virtual void Text(string str);
}
public class iTextSharp.text.pdf.XmlSignatureAppearance : object {
    private PdfStamperImp writer;
    private PdfStamper stamper;
    private X509Certificate signCertificate;
    private IXmlLocator xmlLocator;
    private IXpathConstructor xpathConstructor;
    private DateTime signDate;
    private string description;
    private string mimeType;
    internal XmlSignatureAppearance(PdfStamperImp writer);
    public virtual PdfStamperImp GetWriter();
    public virtual PdfStamper GetStamper();
    public virtual void SetStamper(PdfStamper stamper);
    public virtual void SetCertificate(X509Certificate signCertificate);
    public virtual X509Certificate GetCertificate();
    public virtual void SetDescription(string description);
    public virtual string GetDescription();
    public virtual string GetMimeType();
    public virtual void SetMimeType(string mimeType);
    public virtual DateTime GetSignDate();
    public virtual void SetSignDate(DateTime signDate);
    public virtual IXmlLocator GetXmlLocator();
    public virtual void SetXmlLocator(IXmlLocator xmlLocator);
    public virtual IXpathConstructor GetXpathConstructor();
    public virtual void SetXpathConstructor(IXpathConstructor xpathConstructor);
    public virtual void Close();
}
public class iTextSharp.text.Phrase : List`1<IElement> {
    protected float leading;
    protected float multipliedLeading;
    protected Font font;
    protected IHyphenationEvent hyphenation;
    protected TabSettings tabSettings;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public float MultipliedLeading { get; public set; }
    public float Leading { get; public set; }
    public float TotalLeading { get; }
    public Font Font { get; public set; }
    public string Content { get; }
    public IHyphenationEvent Hyphenation { get; public set; }
    public TabSettings TabSettings { get; public set; }
    public Phrase(Phrase phrase);
    public Phrase(float leading);
    public Phrase(Chunk chunk);
    public Phrase(float leading, Chunk chunk);
    public Phrase(string str);
    public Phrase(string str, Font font);
    public Phrase(float leading, string str);
    public Phrase(float leading, string str, Font font);
    private Phrase(bool dummy);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Add(int index, IElement element);
    public virtual bool Add(string s);
    public virtual bool Add(IElement element);
    public virtual bool AddAll(ICollection`1<T> collection);
    protected virtual bool AddChunk(Chunk chunk);
    public virtual void AddSpecial(IElement obj);
    public virtual bool IsEmpty();
    public virtual bool HasLeading();
    public virtual void SetLeading(float fixedLeading, float multipliedLeading);
    public virtual float get_MultipliedLeading();
    public virtual void set_MultipliedLeading(float value);
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public virtual float get_TotalLeading();
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public virtual string get_Content();
    public virtual void set_Hyphenation(IHyphenationEvent value);
    public virtual IHyphenationEvent get_Hyphenation();
    public virtual TabSettings get_TabSettings();
    public virtual void set_TabSettings(TabSettings value);
    public static Phrase GetInstance(string str);
    public static Phrase GetInstance(int leading, string str);
    public static Phrase GetInstance(int leading, string str, Font font);
    public virtual bool Trim();
}
public class iTextSharp.text.Rectangle : Element {
    public static int UNDEFINED;
    public static int TOP_BORDER;
    public static int BOTTOM_BORDER;
    public static int LEFT_BORDER;
    public static int RIGHT_BORDER;
    public static int NO_BORDER;
    public static int BOX;
    protected float llx;
    protected float lly;
    protected float urx;
    protected float ury;
    protected int border;
    protected float borderWidth;
    protected BaseColor borderColor;
    protected BaseColor borderColorLeft;
    protected BaseColor borderColorRight;
    protected BaseColor borderColorTop;
    protected BaseColor borderColorBottom;
    protected float borderWidthLeft;
    protected float borderWidthRight;
    protected float borderWidthTop;
    protected float borderWidthBottom;
    protected bool useVariableBorders;
    protected BaseColor backgroundColor;
    protected int rotation;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public float Top { get; public set; }
    public int Border { get; public set; }
    public float GrayFill { get; public set; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public BaseColor BorderColorBottom { get; public set; }
    public BaseColor BorderColorTop { get; public set; }
    public BaseColor BorderColorLeft { get; public set; }
    public BaseColor BorderColorRight { get; public set; }
    public float Width { get; public set; }
    public float Height { get; }
    public float BorderWidth { get; public set; }
    public BaseColor BorderColor { get; public set; }
    public BaseColor BackgroundColor { get; public set; }
    public int Rotation { get; public set; }
    public float BorderWidthLeft { get; public set; }
    public float BorderWidthRight { get; public set; }
    public float BorderWidthTop { get; public set; }
    public float BorderWidthBottom { get; public set; }
    public bool UseVariableBorders { get; public set; }
    public Rectangle(float llx, float lly, float urx, float ury);
    public Rectangle(float llx, float lly, float urx, float ury, int rotation);
    public Rectangle(float urx, float ury);
    public Rectangle(float urx, float ury, int rotation);
    public Rectangle(Rectangle rect);
    public Rectangle(RectangleJ rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Normalize();
    public virtual Rectangle GetRectangle(float top, float bottom);
    public virtual Rectangle Rotate();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual int get_Border();
    public virtual void set_Border(int value);
    public virtual float get_GrayFill();
    public virtual void set_GrayFill(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual BaseColor get_BorderColorBottom();
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual BaseColor get_BorderColorTop();
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual BaseColor get_BorderColorLeft();
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual BaseColor get_BorderColorRight();
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public virtual float GetBottom(float margin);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual bool HasBorders();
    public virtual bool HasBorder(int type);
    public virtual float get_BorderWidth();
    public virtual void set_BorderWidth(float value);
    public virtual BaseColor get_BorderColor();
    public virtual void set_BorderColor(BaseColor value);
    public virtual BaseColor get_BackgroundColor();
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual int get_Rotation();
    public virtual void set_Rotation(int value);
    public virtual float get_BorderWidthLeft();
    public virtual void set_BorderWidthLeft(float value);
    public virtual float get_BorderWidthRight();
    public virtual void set_BorderWidthRight(float value);
    public virtual float get_BorderWidthTop();
    public virtual void set_BorderWidthTop(float value);
    public virtual float get_BorderWidthBottom();
    public virtual void set_BorderWidthBottom(float value);
    private void UpdateBorderBasedOnWidth(float width, int side);
    private float GetVariableBorderWidth(float variableWidthValue, int side);
    public virtual bool get_UseVariableBorders();
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
}
public class iTextSharp.text.RectangleReadOnly : Rectangle {
    unknown float Top {public set; }
    unknown int Border {public set; }
    unknown float GrayFill {public set; }
    unknown float Left {public set; }
    unknown float Right {public set; }
    unknown float Bottom {public set; }
    unknown BaseColor BorderColorBottom {public set; }
    unknown BaseColor BorderColorTop {public set; }
    unknown BaseColor BorderColorLeft {public set; }
    unknown BaseColor BorderColorRight {public set; }
    unknown float BorderWidth {public set; }
    unknown BaseColor BorderColor {public set; }
    unknown BaseColor BackgroundColor {public set; }
    unknown int Rotation {public set; }
    unknown float BorderWidthLeft {public set; }
    unknown float BorderWidthRight {public set; }
    unknown float BorderWidthTop {public set; }
    unknown float BorderWidthBottom {public set; }
    unknown bool UseVariableBorders {public set; }
    public RectangleReadOnly(float llx, float lly, float urx, float ury);
    public RectangleReadOnly(float llx, float lly, float urx, float ury, int rotation);
    public RectangleReadOnly(float urx, float ury);
    public RectangleReadOnly(float urx, float ury, int rotation);
    public RectangleReadOnly(Rectangle rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    private void ThrowReadOnlyError();
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual void Normalize();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual void set_Border(int value);
    public virtual void set_GrayFill(float value);
    public virtual void set_Left(float value);
    public virtual void set_Right(float value);
    public virtual void set_Bottom(float value);
    public virtual void set_BorderColorBottom(BaseColor value);
    public virtual void set_BorderColorTop(BaseColor value);
    public virtual void set_BorderColorLeft(BaseColor value);
    public virtual void set_BorderColorRight(BaseColor value);
    public virtual void set_BorderWidth(float value);
    public virtual void set_BorderColor(BaseColor value);
    public virtual void set_BackgroundColor(BaseColor value);
    public virtual void set_Rotation(int value);
    public virtual void set_BorderWidthLeft(float value);
    public virtual void set_BorderWidthRight(float value);
    public virtual void set_BorderWidthTop(float value);
    public virtual void set_BorderWidthBottom(float value);
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
}
public class iTextSharp.text.RomanList : List {
    public RomanList(int symbolIndent);
    public RomanList(bool romanlower, int symbolIndent);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.Section : List`1<IElement> {
    public static int NUMBERSTYLE_DOTTED;
    public static int NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT;
    protected Paragraph title;
    protected int numberDepth;
    protected int numberStyle;
    protected float indentationLeft;
    protected float indentationRight;
    protected float indentation;
    protected int subsections;
    protected internal List`1<int> numbers;
    protected bool complete;
    protected bool addedCompletely;
    protected bool notAddedYet;
    protected bool bookmarkOpen;
    protected bool triggerNewPage;
    protected string bookmarkTitle;
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public Paragraph Title { get; public set; }
    public int NumberStyle { get; public set; }
    public int NumberDepth { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float Indentation { get; public set; }
    public int Depth { get; }
    public bool BookmarkOpen { get; public set; }
    unknown string BookmarkTitle {public set; }
    public bool TriggerNewPage { get; public set; }
    public bool NotAddedYet { get; public set; }
    protected bool AddedCompletely { get; protected set; }
    public bool ElementComplete { get; public set; }
    public PdfName Role { get; public set; }
    public AccessibleElementId ID { get; public set; }
    public bool IsInline { get; }
    protected internal Section(Paragraph title, int numberDepth);
    private void SetNumbers(int number, List`1<int> numbers);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual IList`1<Chunk> get_Chunks();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Add(int index, IElement element);
    public sealed virtual bool Add(IElement element);
    public virtual bool AddAll(ICollection`1<T> collection);
    public virtual Section AddSection(float indentation, Paragraph title, int numberDepth);
    public virtual Section AddSection(float indentation, Paragraph title);
    public virtual Section AddSection(Paragraph title, int numberDepth);
    public virtual MarkedSection AddMarkedSection();
    public virtual Section AddSection(Paragraph title);
    public virtual Section AddSection(float indentation, string title, int numberDepth);
    public virtual Section AddSection(string title, int numberDepth);
    public virtual Section AddSection(float indentation, string title);
    public virtual Section AddSection(string title);
    public virtual Paragraph get_Title();
    public virtual void set_Title(Paragraph value);
    public virtual void set_NumberStyle(int value);
    public virtual int get_NumberStyle();
    public static Paragraph ConstructTitle(Paragraph title, List`1<int> numbers, int numberDepth, int numberStyle);
    public virtual bool IsChapter();
    public virtual bool IsSection();
    public virtual int get_NumberDepth();
    public virtual void set_NumberDepth(int value);
    public virtual float get_IndentationLeft();
    public virtual void set_IndentationLeft(float value);
    public virtual float get_IndentationRight();
    public virtual void set_IndentationRight(float value);
    public virtual float get_Indentation();
    public virtual void set_Indentation(float value);
    public virtual int get_Depth();
    public virtual bool get_BookmarkOpen();
    public virtual void set_BookmarkOpen(bool value);
    public virtual Paragraph GetBookmarkTitle();
    public virtual void set_BookmarkTitle(string value);
    public virtual string ToString();
    public virtual bool get_TriggerNewPage();
    public virtual void set_TriggerNewPage(bool value);
    public virtual void SetChapterNumber(int number);
    public virtual bool get_NotAddedYet();
    public virtual void set_NotAddedYet(bool value);
    protected virtual bool get_AddedCompletely();
    protected virtual void set_AddedCompletely(bool value);
    public virtual void FlushContent();
    public virtual bool get_ElementComplete();
    public virtual void set_ElementComplete(bool value);
    public virtual void NewPage();
    public virtual PdfObject GetAccessibleAttribute(PdfName key);
    public virtual void SetAccessibleAttribute(PdfName key, PdfObject value);
    public virtual Dictionary`2<PdfName, PdfObject> GetAccessibleAttributes();
    public virtual PdfName get_Role();
    public virtual void set_Role(PdfName value);
    public virtual AccessibleElementId get_ID();
    public virtual void set_ID(AccessibleElementId value);
    public virtual bool get_IsInline();
}
public class iTextSharp.text.SpecialSymbol : object {
    public static int Index(string str);
    public static Chunk Get(char c, Font font);
    public static char GetCorrespondingSymbol(char c);
}
public class iTextSharp.text.TabSettings : object {
    public static float DEFAULT_TAB_INTERVAL;
    private List`1<TabStop> tabStops;
    private float tabInterval;
    public List`1<TabStop> TabStops { get; public set; }
    public float TabInterval { get; public set; }
    public TabSettings(List`1<TabStop> tabStops);
    public TabSettings(float tabInterval);
    public TabSettings(List`1<TabStop> tabStops, float tabInterval);
    public static TabStop getTabStopNewInstance(float currentPosition, TabSettings tabSettings);
    public virtual List`1<TabStop> get_TabStops();
    public virtual void set_TabStops(List`1<TabStop> value);
    public virtual float get_TabInterval();
    public virtual void set_TabInterval(float value);
    public virtual TabStop GetTabStopNewInstance(float currentPosition);
}
public class iTextSharp.text.TabSplitCharacter : object {
    public static ISplitCharacter TAB;
    private static TabSplitCharacter();
    public virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public class iTextSharp.text.TabStop : object {
    protected float position;
    protected Alignment alignment;
    protected IDrawInterface leader;
    protected char anchorChar;
    public float Position { get; public set; }
    public Alignment Align { get; public set; }
    public IDrawInterface Leader { get; public set; }
    public char AnchorChar { get; public set; }
    public TabStop(float position);
    public TabStop(float position, IDrawInterface leader);
    public TabStop(float position, Alignment alignment);
    public TabStop(float position, Alignment alignment, char anchorChar);
    public TabStop(float position, IDrawInterface leader, Alignment alignment);
    public TabStop(float position, IDrawInterface leader, Alignment alignment, char anchorChar);
    public TabStop(TabStop tabStop);
    public static TabStop NewInstance(float currentPosition, float tabInterval);
    public virtual float get_Position();
    public virtual void set_Position(float value);
    public virtual Alignment get_Align();
    public virtual void set_Align(Alignment value);
    public virtual IDrawInterface get_Leader();
    public virtual void set_Leader(IDrawInterface value);
    public virtual char get_AnchorChar();
    public virtual void set_AnchorChar(char value);
    public virtual float GetPosition(float tabPosition, float currentPosition, float anchorPosition);
}
public class iTextSharp.text.Utilities : object {
    private static Byte[] skipBuffer;
    private static Utilities();
    public static ICollection`1<K> GetKeySet(Dictionary`2<K, V> table);
    public static Object[][] AddToArray(Object[][] original, Object[] item);
    public static bool CheckTrueOrFalse(Properties attributes, string key);
    public static Uri ToURL(string filename);
    public static string UnEscapeURL(string src);
    public static void Skip(Stream istr, int size);
    public static float MillimetersToPoints(float value);
    public static float MillimetersToInches(float value);
    public static float PointsToMillimeters(float value);
    public static float PointsToInches(float value);
    public static float InchesToMillimeters(float value);
    public static float InchesToPoints(float value);
    public static bool IsSurrogateHigh(char c);
    public static bool IsSurrogateLow(char c);
    public static bool IsSurrogatePair(string text, int idx);
    public static bool IsSurrogatePair(Char[] text, int idx);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(Char[] text, int idx);
    public static int ConvertToUtf32(string text, int idx);
    public static string ConvertFromUtf32(int codePoint);
    public static string ReadFileToString(string path);
    public static string ConvertToHex(Byte[] bytes);
    public static float ComputeTabSpace(float lx, float rx, float tab);
    public static float ComputeTabSpace(float width, float tab);
    public static float Max(Single[] array);
    public static float Min(Single[] array);
}
public class iTextSharp.text.Version : object {
    private static object staticLock;
    public static string AGPL;
    private static Version modreq(System.Runtime.CompilerServices.IsVolatile) version;
    private static string iText;
    private static string release;
    private string iTextVersion;
    private string key;
    public string Product { get; }
    public string Release { get; }
    public string GetVersion { get; }
    public string Key { get; }
    public static bool IsAGPLVersion { get; }
    private static Version();
    private static Type GetLicenseKeyClass();
    public static Version GetInstance();
    private static bool DependsOnTheOldLicense();
    public string get_Product();
    public string get_Release();
    public string get_GetVersion();
    public string get_Key();
    public static bool get_IsAGPLVersion();
    private static Version AtomicSetVersion(Version newVersion);
}
public abstract class iTextSharp.text.WritableDirectElement : object {
    public static int DIRECT_ELEMENT_TYPE_UNKNOWN;
    public static int DIRECT_ELEMENT_TYPE_HEADER;
    protected int directElementType;
    public int DirectElemenType { get; }
    public int Type { get; }
    public IList`1<Chunk> Chunks { get; }
    public WritableDirectElement(int directElementType);
    private static WritableDirectElement();
    public int get_DirectElemenType();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual IList`1<Chunk> get_Chunks();
    public abstract virtual void Write(PdfWriter writer, Document doc);
}
public abstract class iTextSharp.text.xml.ParserBase : object {
    public virtual void Parse(XmlDocument xDoc);
    public virtual void Parse(XmlTextReader reader);
    public virtual void Parse(string url);
    public abstract virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public abstract virtual void EndElement(string uri, string lname, string name);
    public abstract virtual void Characters(string content, int start, int length);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToSymbol : object {
    private static Dictionary`2<string, char> map;
    private static EntitiesToSymbol();
    public static Chunk Get(string e, Font font);
    public static char GetCorrespondingSymbol(string name);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToUnicode : object {
    private static Dictionary`2<string, char> map;
    private static EntitiesToUnicode();
    public static char DecodeEntity(string name);
    public static string DecodeString(string s);
}
public class iTextSharp.text.xml.simpleparser.handler.HTMLNewLineHandler : object {
    private Dictionary`2<string, object> newLineTags;
    public virtual bool IsNewLineTag(string tag);
}
public class iTextSharp.text.xml.simpleparser.handler.NeverNewLineHandler : object {
    public virtual bool IsNewLineTag(string tag);
}
public class iTextSharp.text.xml.simpleparser.IanaEncodings : object {
    private static Dictionary`2<string, int> map;
    private static IanaEncodings();
    public static int GetEncodingNumber(string name);
    public static Encoding GetEncodingEncoding(string name);
}
public interface iTextSharp.text.xml.simpleparser.INewLineHandler {
    public abstract virtual bool IsNewLineTag(string tag);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler {
    public abstract virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public abstract virtual void EndElement(string tag);
    public abstract virtual void StartDocument();
    public abstract virtual void EndDocument();
    public abstract virtual void Text(string str);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment {
    public abstract virtual void Comment(string text);
}
public class iTextSharp.text.xml.simpleparser.SimpleXMLParser : object {
    private static int UNKNOWN;
    private static int TEXT;
    private static int TAG_ENCOUNTERED;
    private static int EXAMIN_TAG;
    private static int TAG_EXAMINED;
    private static int IN_CLOSETAG;
    private static int SINGLE_TAG;
    private static int CDATA;
    private static int COMMENT;
    private static int PI;
    private static int ENTITY;
    private static int QUOTE;
    private static int ATTRIBUTE_KEY;
    private static int ATTRIBUTE_EQUAL;
    private static int ATTRIBUTE_VALUE;
    private Stack`1<int> stack;
    private int character;
    private int previousCharacter;
    private int lines;
    private int columns;
    private bool eol;
    private bool nowhite;
    private int state;
    private bool html;
    private StringBuilder text;
    private StringBuilder entity;
    private string tag;
    private Dictionary`2<string, string> attributes;
    private ISimpleXMLDocHandler doc;
    private ISimpleXMLDocHandlerComment comment;
    private int nested;
    private int quoteCharacter;
    private string attributekey;
    private string attributevalue;
    private INewLineHandler newLineHandler;
    private SimpleXMLParser(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, bool html);
    private void Go(TextReader reader);
    private int RestoreState();
    private void SaveState(int s);
    private void Flush();
    private void InitTag();
    private void DoTag();
    private void ProcessTag(bool start);
    private void ThrowException(string s);
    public static void Parse(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, TextReader r, bool html);
    public static void Parse(ISimpleXMLDocHandler doc, Stream inp);
    private static string GetDeclaredEncoding(string decl);
    public static void Parse(ISimpleXMLDocHandler doc, TextReader r);
    public static string EscapeXML(string s, bool onlyASCII);
}
public class iTextSharp.text.xml.XmlDomWriter : object {
    protected TextWriter fOut;
    protected bool fCanonical;
    protected bool fXML11;
    public XmlDomWriter(bool canonical);
    public virtual void SetCanonical(bool canonical);
    public virtual void SetOutput(Stream stream, string encoding);
    public virtual void SetOutput(TextWriter writer);
    public virtual void Write(XmlNode node);
    protected virtual XmlAttribute[] SortAttributes(XmlAttributeCollection attrs);
    protected virtual void NormalizeAndPrint(string s, bool isAttValue);
    protected virtual void NormalizeAndPrint(char c, bool isAttValue);
}
public class iTextSharp.text.xml.XmlToTxt : object {
    protected internal StringBuilder buf;
    public static string Parse(Stream isp);
    public virtual string ToString();
    public virtual void StartElement(string tag, IDictionary`2<string, string> h);
    public virtual void EndElement(string tag);
    public virtual void StartDocument();
    public virtual void EndDocument();
    public virtual void Text(string str);
}
public static class iTextSharp.text.xml.XMLUtil : object {
    public static string EscapeXML(string s, bool onlyASCII);
    public static string UnescapeXML(string s);
    public static int Unescape(string s);
    public static bool IsValidCharacterValue(string s);
    public static bool IsValidCharacterValue(int c);
    public static int FindInArray(char needle, Char[] haystack, int start);
    public static string GetEncodingName(Byte[] b4);
}
public class iTextSharp.text.xml.xmp.DublinCoreProperties : object {
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    private static DublinCoreProperties();
    public static void AddTitle(IXmpMeta xmpMeta, string title);
    public static void SetTitle(IXmpMeta xmpMeta, string title, string genericLang, string specificLang);
    public static void AddDescription(IXmpMeta xmpMeta, string desc);
    public static void SetDescription(IXmpMeta xmpMeta, string desc, string genericLang, string specificLang);
    public static void AddSubject(IXmpMeta xmpMeta, string subject);
    public static void SetSubject(IXmpMeta xmpMeta, String[] subject);
    public static void AddAuthor(IXmpMeta xmpMeta, string author);
    public static void SetAuthor(IXmpMeta xmpMeta, String[] author);
    public static void AddPublisher(IXmpMeta xmpMeta, string publisher);
    public static void SetPublisher(IXmpMeta xmpMeta, String[] publisher);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.DublinCoreSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    public virtual void AddTitle(string title);
    public virtual void AddTitle(LangAlt title);
    public virtual void AddDescription(string desc);
    public virtual void AddDescription(LangAlt desc);
    public virtual void AddSubject(string subject);
    public virtual void AddSubject(String[] subject);
    public virtual void AddAuthor(string author);
    public virtual void AddAuthor(String[] author);
    public virtual void AddPublisher(string publisher);
    public virtual void AddPublisher(String[] publisher);
}
public class iTextSharp.text.xml.xmp.EncodingNoPreamble : Encoding {
    private Encoding encoding;
    private static Byte[] emptyPreamble;
    public string BodyName { get; }
    public int CodePage { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public EncodingNoPreamble(Encoding encoding);
    private static EncodingNoPreamble();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual Byte[] GetPreamble();
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.LangAlt : Properties {
    public static string DEFAULT;
    public LangAlt(string defaultValue);
    public virtual void AddLanguage(string language, string value);
    protected internal virtual void Process(StringBuilder buf, string lang);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.PdfProperties : object {
    public static string KEYWORDS;
    public static string VERSION;
    public static string PRODUCER;
    public static string PART;
    private static PdfProperties();
    public static void SetKeywords(IXmpMeta xmpMeta, string keywords);
    public static void SetProducer(IXmpMeta xmpMeta, string producer);
    public static void SetVersion(IXmpMeta xmpMeta, string version);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.PdfSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string KEYWORDS;
    public static string VERSION;
    public static string PRODUCER;
    public virtual void AddKeywords(string keywords);
    public virtual void AddProducer(string producer);
    public virtual void AddVersion(string version);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpArray : List`1<string> {
    public static string UNORDERED;
    public static string ORDERED;
    public static string ALTERNATIVE;
    protected string type;
    public XmpArray(string type);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.XmpBasicProperties : object {
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    private static XmpBasicProperties();
    public static void SetCreatorTool(IXmpMeta xmpMeta, string creator);
    public static void SetCreateDate(IXmpMeta xmpMeta, string date);
    public static void SetModDate(IXmpMeta xmpMeta, string date);
    public static void SetMetaDataDate(IXmpMeta xmpMeta, string date);
    public static void SetIdentifiers(IXmpMeta xmpMeta, String[] id);
    public static void SetNickname(IXmpMeta xmpMeta, string name);
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpBasicSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    public virtual void AddCreatorTool(string creator);
    public virtual void AddCreateDate(string date);
    public virtual void AddModDate(string date);
    public virtual void AddMetaDataDate(string date);
    public virtual void AddIdentifiers(String[] id);
    public virtual void AddNickname(string name);
}
public class iTextSharp.text.xml.xmp.XmpMMProperties : object {
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string MANAGERVARIANT;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
    private static XmpMMProperties();
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpMMSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string MANAGERVARIANT;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
}
[ObsoleteAttribute]
public class iTextSharp.text.xml.xmp.XmpReader : object {
    public static string EXTRASPACE;
    public static string XPACKET_PI_BEGIN;
    public static string XPACKET_PI_END_W;
    private XmlDocument domDocument;
    public XmpReader(Byte[] bytes);
    public virtual bool ReplaceNode(string namespaceURI, string localName, string value);
    public virtual bool ReplaceDescriptionAttribute(string namespaceURI, string localName, string value);
    public virtual bool Add(string parent, string namespaceURI, string localName, string value);
    public virtual bool SetNodeText(XmlDocument domDocument, XmlNode n, string value);
    public virtual Byte[] SerializeDoc();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute]
public abstract class iTextSharp.text.xml.xmp.XmpSchema : Properties {
    protected string xmlns;
    public string Xmlns { get; }
    unknown string Item {public set; }
    public XmpSchema(string xmlns);
    public virtual string ToString();
    protected virtual void Process(StringBuilder buf, object p);
    public virtual string get_Xmlns();
    public virtual void AddProperty(string key, string value);
    public virtual void set_Item(string key, string value);
    public virtual void SetProperty(string key, XmpArray value);
    public virtual void SetProperty(string key, LangAlt value);
    public static string Escape(string content);
}
public class iTextSharp.text.xml.xmp.XmpWriter : object {
    public static string UTF8;
    public static string UTF16;
    public static string UTF16BE;
    public static string UTF16LE;
    protected IXmpMeta xmpMeta;
    protected Stream outputStream;
    protected SerializeOptions serializeOptions;
    public IXmpMeta XmpMeta { get; }
    public bool ReadOnly { get; public set; }
    public string About { get; public set; }
    public XmpWriter(Stream os, string utfEncoding, int extraSpace);
    public XmpWriter(Stream os);
    public XmpWriter(Stream os, PdfDictionary info);
    public XmpWriter(Stream os, IDictionary`2<string, string> info);
    private static XmpWriter();
    public virtual IXmpMeta get_XmpMeta();
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    public virtual string get_About();
    public virtual void set_About(string value);
    [ObsoleteAttribute]
public virtual void AddRdfDescription(string xmlns, string content);
    [ObsoleteAttribute]
public virtual void AddRdfDescription(XmpSchema s);
    public virtual void SetProperty(string schemaNS, string propName, object value);
    public virtual void AppendArrayItem(string schemaNS, string arrayName, string value);
    public virtual void AppendOrderedArrayItem(string schemaNS, string arrayName, string value);
    public virtual void AppendAlternateArrayItem(string schemaNS, string arrayName, string value);
    public virtual void Serialize(Stream externalOutputStream);
    public virtual void Close();
    public virtual void AddDocInfoProperty(object key, string value);
}
public class iTextSharp.text.ZapfDingbatsList : List {
    protected int zn;
    public int CharNumber { get; public set; }
    public ZapfDingbatsList(int zn);
    public ZapfDingbatsList(int zn, int symbolIndent);
    public virtual void setDingbatColor(BaseColor zapfDingbatColor);
    public virtual void set_CharNumber(int value);
    public virtual int get_CharNumber();
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.text.ZapfDingbatsNumberList : List {
    protected int type;
    public int NumberType { get; public set; }
    public ZapfDingbatsNumberList(int type);
    public ZapfDingbatsNumberList(int type, int symbolIndent);
    public virtual int get_NumberType();
    public virtual void set_NumberType(int value);
    public virtual bool Add(IElement o);
    public virtual List CloneShallow();
}
public class iTextSharp.xmp.impl.Base64 : object {
    private static byte INVALID;
    private static byte WHITESPACE;
    private static byte EQUAL;
    private static Byte[] base64;
    private static Byte[] Ascii;
    private static Base64();
    public static Byte[] Encode(Byte[] src);
    public static Byte[] Encode(Byte[] src, int lineFeed);
    public static string Encode(string src);
    public static Byte[] Decode(Byte[] src);
    public static string Decode(string src);
    private static Byte[] GetBytes(string str);
    private static string GetString(Byte[] bytes);
}
public class iTextSharp.xmp.impl.ByteBuffer : object {
    private Byte[] _buffer;
    private string _encoding;
    private int _length;
    public Stream ByteStream { get; }
    public int Length { get; }
    public string Encoding { get; }
    public ByteBuffer(int initialCapacity);
    public ByteBuffer(Byte[] buffer);
    public ByteBuffer(Byte[] buffer, int length);
    public ByteBuffer(Stream inp);
    public ByteBuffer(Byte[] buffer, int offset, int length);
    public virtual Stream get_ByteStream();
    public virtual int get_Length();
    public virtual string get_Encoding();
    public virtual byte ByteAt(int index);
    public virtual int CharAt(int index);
    public virtual void Append(byte b);
    public virtual void Append(Byte[] bytes, int offset, int len);
    public virtual void Append(Byte[] bytes);
    public virtual void Append(ByteBuffer anotherBuffer);
    private void EnsureCapacity(int requestedLength);
}
public class iTextSharp.xmp.impl.CountOutputStream : Stream {
    private Stream _outp;
    private int _bytesWritten;
    public int BytesWritten { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal CountOutputStream(Stream outp);
    public int get_BytesWritten();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buf, int off, int len);
    public void Write(Byte[] buf);
    public void Write(int b);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
public abstract class iTextSharp.xmp.impl.FilterReader : TextReader {
    protected TextReader inp;
    protected FilterReader(TextReader inp);
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
    public virtual void Close();
}
public class iTextSharp.xmp.impl.FixAsciiControlsReader : PushbackReader {
    private static int STATE_START;
    private static int STATE_AMP;
    private static int STATE_HASH;
    private static int STATE_HEX;
    private static int STATE_DIG1;
    private static int STATE_ERROR;
    private static int BUFFER_SIZE;
    private int _control;
    private int _digits;
    private int _state;
    public FixAsciiControlsReader(TextReader inp);
    public virtual int Read(Char[] cbuf, int off, int len);
    private char ProcessChar(char ch);
}
public static class iTextSharp.xmp.impl.Iso8601Converter : object {
    public static IXmpDateTime Parse(string iso8601String);
    public static IXmpDateTime Parse(string iso8601String, IXmpDateTime binValue);
    public static string Render(IXmpDateTime dateTime);
}
public class iTextSharp.xmp.impl.Latin1Converter : object {
    private static int STATE_START;
    private static int STATE_UTF8CHAR;
    public static ByteBuffer Convert(ByteBuffer buffer);
    private static Byte[] ConvertToUtf8(byte ch);
}
internal class iTextSharp.xmp.impl.ParameterAsserts : XmpConst {
    public static void AssertArrayName(string arrayName);
    public static void AssertPropName(string propName);
    public static void AssertSchemaNs(string schemaNs);
    public static void AssertPrefix(string prefix);
    public static void AssertSpecificLang(string specificLang);
    public static void AssertStructName(string structName);
    public static void AssertNotNull(object param);
    public static void AssertImplementation(IXmpMeta xmp);
}
public class iTextSharp.xmp.impl.ParseRdf : XmpConst {
    public static int RDFTERM_OTHER;
    public static int RDFTERM_RDF;
    public static int RDFTERM_ID;
    public static int RDFTERM_ABOUT;
    public static int RDFTERM_PARSE_TYPE;
    public static int RDFTERM_RESOURCE;
    public static int RDFTERM_NODE_ID;
    public static int RDFTERM_DATATYPE;
    public static int RDFTERM_DESCRIPTION;
    public static int RDFTERM_LI;
    public static int RDFTERM_ABOUT_EACH;
    public static int RDFTERM_ABOUT_EACH_PREFIX;
    public static int RDFTERM_BAG_ID;
    public static int RDFTERM_FIRST_CORE;
    public static int RDFTERM_LAST_CORE;
    public static int RDFTERM_FIRST_SYNTAX;
    public static int RDFTERM_LAST_SYNTAX;
    public static int RDFTERM_FIRST_OLD;
    public static int RDFTERM_LAST_OLD;
    public static string DEFAULT_PREFIX;
    internal static XmpMetaImpl Parse(XmlNode xmlRoot);
    internal static void RdfRdf(XmpMetaImpl xmp, XmlNode rdfRdfNode);
    private static void RdfNodeElementList(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode rdfRdfNode);
    private static void RdfNodeElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfNodeElementAttrs(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfPropertyElementList(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlParent, bool isTopLevel);
    private static void RdfPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfResourcePropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfLiteralPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfParseTypeLiteralPropertyElement();
    private static void RdfParseTypeResourcePropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static void RdfParseTypeCollectionPropertyElement();
    private static void RdfParseTypeOtherPropertyElement();
    private static void RdfEmptyPropertyElement(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, bool isTopLevel);
    private static XmpNode AddChildNode(XmpMetaImpl xmp, XmpNode xmpParent, XmlNode xmlNode, string value, bool isTopLevel);
    private static XmpNode AddQualifierNode(XmpNode xmpParent, string name, string value);
    private static void FixupQualifiedNode(XmpNode xmpParent);
    private static bool IsWhitespaceNode(XmlNode node);
    private static bool IsPropertyElementName(int term);
    private static bool IsOldTerm(int term);
    private static bool IsCoreSyntaxTerm(int term);
    private static int GetRdfTermKind(XmlNode node);
}
internal class iTextSharp.xmp.impl.ParseState : object {
    private string _str;
    private int _pos;
    public ParseState(string str);
    public virtual int Length();
    public virtual bool HasNext();
    public virtual char Ch(int index);
    public virtual char Ch();
    public virtual void Skip();
    public virtual int Pos();
    public virtual int GatherInt(string errorMsg, int maxValue);
}
public class iTextSharp.xmp.impl.PushbackReader : FilterReader {
    private Char[] _buf;
    private int _pos;
    public PushbackReader(TextReader inp, int size);
    public PushbackReader(TextReader inp);
    private void EnsureOpen();
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
    public virtual void Unread(int c);
    public virtual void Unread(Char[] cbuf, int off, int len);
    public virtual void Unread(Char[] cbuf);
    public virtual void Close();
}
public class iTextSharp.xmp.impl.QName : object {
    private string _localName;
    private string _prefix;
    public string LocalName { get; }
    public string Prefix { get; }
    public QName(string qname);
    public QName(string prefix, string localName);
    public virtual string get_LocalName();
    public virtual string get_Prefix();
    public virtual bool HasPrefix();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.xmp.impl.ReadOnlyDictionary : object {
    private IDictionary _originalDictionary;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Values { get; }
    public ICollection Keys { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    private ReadOnlyDictionary(IDictionary original);
    public static ReadOnlyDictionary ReadOnly(IDictionary dictionary);
    private void ReportNotSupported();
    public virtual bool get_IsReadOnly();
    public virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public virtual void Remove(object key);
    public virtual bool Contains(object key);
    public virtual void Clear();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual ICollection get_Keys();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual int get_Count();
    public virtual void CopyTo(Array array, int index);
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class iTextSharp.xmp.impl.Utils : XmpConst {
    public static int UUID_SEGMENT_COUNT;
    public static int UUID_LENGTH;
    private static Boolean[] _xmlNameStartChars;
    private static Boolean[] _xmlNameChars;
    private static Utils();
    public static string NormalizeLangValue(string value);
    internal static String[] SplitNameAndValue(string selector);
    internal static bool IsInternalProperty(string schema, string prop);
    internal static bool CheckUuidFormat(string uuid);
    public static bool IsXmlName(string name);
    public static bool IsXmlNameNs(string name);
    internal static bool IsControlChar(char c);
    public static string EscapeXml(string value, bool forAttribute, bool escapeWhitespaces);
    internal static string RemoveControlChars(string value);
    private static bool IsNameStartChar(char ch);
    private static bool IsNameChar(char ch);
    private static void InitCharTables();
}
public class iTextSharp.xmp.impl.XmpDateTimeImpl : object {
    private int _day;
    private bool _hasDate;
    private bool _hasTime;
    private bool _hasTimeZone;
    private int _hour;
    private int _minute;
    private int _month;
    private int _nanoSeconds;
    private int _second;
    private TimeZone _timeZone;
    private int _year;
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int NanoSecond { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public XmpCalendar Calendar { get; }
    public string Iso8601String { get; }
    public XmpDateTimeImpl(XmpCalendar calendar);
    public XmpDateTimeImpl(DateTime date, TimeZone timeZone);
    public XmpDateTimeImpl(string strValue);
    public virtual int get_Year();
    public virtual void set_Year(int value);
    public virtual int get_Month();
    public virtual void set_Month(int value);
    public virtual int get_Day();
    public virtual void set_Day(int value);
    public virtual int get_Hour();
    public virtual void set_Hour(int value);
    public virtual int get_Minute();
    public virtual void set_Minute(int value);
    public virtual int get_Second();
    public virtual void set_Second(int value);
    public virtual int get_NanoSecond();
    public virtual void set_NanoSecond(int value);
    public virtual int CompareTo(object dt);
    public virtual TimeZone get_TimeZone();
    public virtual void set_TimeZone(TimeZone value);
    public virtual bool HasDate();
    public virtual bool HasTime();
    public virtual bool HasTimeZone();
    public virtual XmpCalendar get_Calendar();
    public virtual string get_Iso8601String();
    public virtual string ToString();
}
public class iTextSharp.xmp.impl.XmpIteratorImpl : object {
    private static IList EmptyList;
    private IEnumerator _nodeIterator;
    private IteratorOptions _options;
    private string _baseNs;
    private bool _skipSiblings;
    protected internal bool skipSubtree;
    protected internal IteratorOptions Options { get; }
    protected internal string BaseNs { get; protected internal set; }
    public object Current { get; }
    public XmpIteratorImpl(XmpMetaImpl xmp, string schemaNs, string propPath, IteratorOptions options);
    private static XmpIteratorImpl();
    protected internal virtual IteratorOptions get_Options();
    protected internal virtual string get_BaseNs();
    protected internal virtual void set_BaseNs(string value);
    public virtual void SkipSubtree();
    public virtual void SkipSiblings();
    public virtual bool MoveNext();
    public virtual object get_Current();
    public virtual void Reset();
}
public class iTextSharp.xmp.impl.XmpMetaImpl : XmpConst {
    private static int VALUE_STRING;
    private static int VALUE_BOOLEAN;
    private static int VALUE_INTEGER;
    private static int VALUE_LONG;
    private static int VALUE_DOUBLE;
    private static int VALUE_DATE;
    private static int VALUE_CALENDAR;
    private static int VALUE_BASE64;
    private XmpNode _tree;
    private string _packetHeader;
    public XmpNode Root { get; }
    public string ObjectName { get; public set; }
    public string PacketHeader { get; public set; }
    public XmpMetaImpl(XmpNode tree);
    public virtual XmpNode get_Root();
    public virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public virtual int CountArrayItems(string schemaNs, string arrayName);
    public virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public virtual void DeleteProperty(string schemaNs, string propName);
    public virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual bool DoesPropertyExist(string schemaNs, string propName);
    public virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public virtual IXmpProperty GetProperty(string schemaNs, string propName);
    public virtual Nullable`1<bool> GetPropertyBoolean(string schemaNs, string propName);
    public virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public virtual Nullable`1<int> GetPropertyInteger(string schemaNs, string propName);
    public virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public virtual Nullable`1<long> GetPropertyLong(string schemaNs, string propName);
    public virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public virtual Nullable`1<double> GetPropertyDouble(string schemaNs, string propName);
    public virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public virtual DateTime GetPropertyCalendar(string schemaNs, string propName);
    public virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue, PropertyOptions options);
    public virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue);
    public virtual SByte[] GetPropertyBase64(string schemaNs, string propName);
    public virtual string GetPropertyString(string schemaNs, string propName);
    public virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue, PropertyOptions options);
    public virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue);
    public virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public virtual IXmpIterator Iterator();
    public virtual IXmpIterator Iterator(IteratorOptions options);
    public virtual IXmpIterator Iterator(string schemaNs, string propName, IteratorOptions options);
    public virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public virtual void SetProperty(string schemaNs, string propName, object propValue);
    public virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public virtual string get_ObjectName();
    public virtual void set_ObjectName(string value);
    public virtual string get_PacketHeader();
    public virtual void set_PacketHeader(string value);
    public virtual object Clone();
    public virtual string DumpObject();
    public virtual void Sort();
    public virtual void Normalize(ParseOptions options);
    protected internal virtual IXmpProperty GetProperty(string schemaNs, string propName, int valueType);
    protected internal virtual object GetPropertyObject(string schemaNs, string propName, int valueType);
    private void DoSetArrayItem(XmpNode arrayNode, int itemIndex, string itemValue, PropertyOptions itemOptions, bool insert);
    internal virtual void SetNode(XmpNode node, object value, PropertyOptions newOptions, bool deleteExisting);
    private object evaluateNodeValue(int valueType, XmpNode propNode);
}
public class iTextSharp.xmp.impl.XmpMetaParser : object {
    private static object XmpRdf;
    private static XmpMetaParser();
    public static IXmpMeta Parse(object input, ParseOptions options);
    private static XmlDocument ParseXml(object input, ParseOptions options);
    private static XmlDocument ParseXmlFromInputStream(Stream stream, ParseOptions options);
    private static XmlDocument ParseXmlFromBytebuffer(ByteBuffer buffer, ParseOptions options);
    private static XmlDocument ParseXmlFromString(string input, ParseOptions options);
    private static Object[] FindRootNode(XmlNode root, bool xmpmetaRequired, Object[] result);
    private static XmlReaderSettings GetSecureReaderSettings();
    private static XmlReader GetSecureXmlReader(Stream stream);
    private static XmlReader GetSecureXmlReader(TextReader textReader);
    private static XmlReader GetSecureXmlReader(string str);
}
public class iTextSharp.xmp.impl.XmpNode : object {
    private static IList EmptyList;
    private bool _alias;
    private IList _children;
    private bool _hasAliases;
    private bool _hasValueChild;
    private bool _implicit;
    private string _name;
    private PropertyOptions _options;
    private XmpNode _parent;
    private IList _qualifier;
    private string _value;
    public XmpNode Parent { get; public set; }
    public int ChildrenLength { get; }
    public int QualifierLength { get; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    public PropertyOptions Options { get; public set; }
    public bool Implicit { get; public set; }
    public bool HasAliases { get; public set; }
    public bool Alias { get; public set; }
    public bool HasValueChild { get; public set; }
    private bool LanguageNode { get; }
    private bool TypeNode { get; }
    internal IList Children { get; }
    public IList UnmodifiableChildren { get; }
    private IList Qualifier { get; }
    public XmpNode(string name, string value, PropertyOptions options);
    public XmpNode(string name, PropertyOptions options);
    private static XmpNode();
    public virtual XmpNode get_Parent();
    public virtual void set_Parent(XmpNode value);
    public virtual int get_ChildrenLength();
    public virtual int get_QualifierLength();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual PropertyOptions get_Options();
    public virtual void set_Options(PropertyOptions value);
    public virtual bool get_Implicit();
    public virtual void set_Implicit(bool value);
    public virtual bool get_HasAliases();
    public virtual void set_HasAliases(bool value);
    public virtual bool get_Alias();
    public virtual void set_Alias(bool value);
    public virtual bool get_HasValueChild();
    public virtual void set_HasValueChild(bool value);
    private bool get_LanguageNode();
    private bool get_TypeNode();
    internal IList get_Children();
    public virtual IList get_UnmodifiableChildren();
    private IList get_Qualifier();
    public virtual object Clone();
    public virtual int CompareTo(object xmpNode);
    public virtual void Clear();
    public virtual XmpNode GetChild(int index);
    public virtual void AddChild(XmpNode node);
    public virtual void AddChild(int index, XmpNode node);
    public virtual void ReplaceChild(int index, XmpNode node);
    public virtual void RemoveChild(int itemIndex);
    public virtual void RemoveChild(XmpNode node);
    protected internal virtual void CleanupChildren();
    public virtual void RemoveChildren();
    public virtual XmpNode FindChildByName(string expr);
    public virtual XmpNode GetQualifier(int index);
    public virtual void AddQualifier(XmpNode qualNode);
    public virtual void RemoveQualifier(XmpNode qualNode);
    public virtual void RemoveQualifiers();
    public virtual XmpNode FindQualifierByName(string expr);
    public virtual bool HasChildren();
    public virtual IEnumerator IterateChildren();
    public virtual bool HasQualifier();
    public virtual IEnumerator IterateQualifier();
    public virtual void CloneSubtree(XmpNode destination);
    public virtual string DumpNode(bool recursive);
    public virtual void Sort();
    private void DumpNode(StringBuilder result, bool recursive, int indent, int index);
    private XmpNode find(IList list, string expr);
    private void AssertChildNotExisting(string childName);
    private void AssertQualifierNotExisting(string qualifierName);
}
public class iTextSharp.xmp.impl.XmpNodeUtils : XmpConst {
    internal static int CLT_NO_VALUES;
    internal static int CLT_SPECIFIC_MATCH;
    internal static int CLT_SINGLE_GENERIC;
    internal static int CLT_MULTIPLE_GENERIC;
    internal static int CLT_XDEFAULT;
    internal static int CLT_FIRST_ITEM;
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, bool createNodes);
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, string suggestedPrefix, bool createNodes);
    internal static XmpNode FindChildNode(XmpNode parent, string childName, bool createNodes);
    internal static XmpNode FindNode(XmpNode xmpTree, XmpPath xpath, bool createNodes, PropertyOptions leafOptions);
    internal static void DeleteNode(XmpNode node);
    internal static void SetNodeValue(XmpNode node, object value);
    internal static PropertyOptions VerifySetOptions(PropertyOptions options, object itemValue);
    internal static string SerializeNodeValue(object value);
    private static XmpNode FollowXPathStep(XmpNode parentNode, XmpPathSegment nextStep, bool createNodes);
    private static XmpNode FindQualifierNode(XmpNode parent, string qualName, bool createNodes);
    private static int FindIndexedItem(XmpNode arrayNode, string segment, bool createNodes);
    private static int LookupFieldSelector(XmpNode arrayNode, string fieldName, string fieldValue);
    private static int LookupQualSelector(XmpNode arrayNode, string qualName, string qualValue, UInt32 aliasForm);
    internal static void NormalizeLangArray(XmpNode arrayNode);
    internal static void DetectAltText(XmpNode arrayNode);
    internal static void AppendLangItem(XmpNode arrayNode, string itemLang, string itemValue);
    internal static Object[] ChooseLocalizedText(XmpNode arrayNode, string genericLang, string specificLang);
    internal static int LookupLanguageItem(XmpNode arrayNode, string language);
}
public class iTextSharp.xmp.impl.XmpNormalizer : object {
    private static IDictionary _dcArrayForms;
    private static XmpNormalizer();
    internal static IXmpMeta Process(XmpMetaImpl xmp, ParseOptions options);
    private static void TweakOldXmp(XmpNode tree);
    private static void TouchUpDataModel(XmpMetaImpl xmp);
    private static void NormalizeDcArrays(XmpNode dcSchema);
    private static void RepairAltText(XmpNode arrayNode);
    private static void MoveExplicitAliases(XmpNode tree, ParseOptions options);
    private static void TransplantArrayItemAlias(XmpNode childNode, XmpNode baseArray);
    private static void FixGpsTimeStamp(XmpNode exifSchema);
    private static void DeleteEmptySchemas(XmpNode tree);
    private static void CompareAliasedSubtrees(XmpNode aliasNode, XmpNode baseNode, bool outerCall);
    private static void MigrateAudioCopyright(IXmpMeta xmp, XmpNode dmCopyright);
    private static void InitDcArrays();
}
public class iTextSharp.xmp.impl.XmpSchemaRegistryImpl : XmpConst {
    private IDictionary _aliasMap;
    private IDictionary _namespaceToPrefixMap;
    private IDictionary _prefixToNamespaceMap;
    private Regex _regex;
    public sealed virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public sealed virtual void DeleteNamespace(string namespaceUri);
    public sealed virtual string GetNamespacePrefix(string namespaceUri);
    public sealed virtual string GetNamespaceUri(string namespacePrefix);
    public sealed virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public sealed virtual IXmpAliasInfo FindAlias(string qname);
    public sealed virtual IXmpAliasInfo[] FindAliases(string aliasNs);
    public sealed virtual IDictionary GetNamespaces();
    public sealed virtual IDictionary GetPrefixes();
    public sealed virtual IDictionary GetAliases();
    private void RegisterStandardNamespaces();
    private void RegisterAlias(string aliasNs, string aliasProp, string actualNs, string actualProp, AliasOptions aliasForm);
    private void RegisterStandardAliases();
}
public class iTextSharp.xmp.impl.XmpSerializerHelper : object {
    public static void Serialize(XmpMetaImpl xmp, Stream out, SerializeOptions options);
    public static string SerializeToString(XmpMetaImpl xmp, SerializeOptions options);
    public static Byte[] SerializeToBuffer(XmpMetaImpl xmp, SerializeOptions options);
    private static string GetString(Byte[] bytes);
}
public class iTextSharp.xmp.impl.XmpSerializerRdf : object {
    private static int DEFAULT_PAD;
    private static string RDF_XMPMETA_END;
    private static string RDF_RDF_END;
    private static string RDF_SCHEMA_START;
    private static string RDF_SCHEMA_END;
    private static string RDF_STRUCT_START;
    private static string RDF_STRUCT_END;
    private static string RDF_EMPTY_STRUCT;
    private static string PACKET_HEADER;
    private static string PACKET_TRAILER;
    private static string PACKET_TRAILER2;
    private static string RDF_XMPMETA_START;
    private static string RDF_RDF_START;
    internal static ICollection`1<string> RDF_ATTR_QUALIFIER;
    private SerializeOptions _options;
    private CountOutputStream _outputStream;
    private int _padding;
    private int _unicodeSize;
    private StreamWriter _writer;
    private XmpMetaImpl _xmp;
    private static XmpSerializerRdf();
    public virtual void Serialize(IXmpMeta xmp, Stream out, SerializeOptions options);
    private void AddPadding(int tailLength);
    protected internal virtual void CheckOptionsConsistence();
    private string SerializeAsRdf();
    private void SerializeCanonicalRdfSchemas(int level);
    private void WriteTreeName();
    private void SerializeCompactRdfSchemas(int level);
    private bool SerializeCompactRdfAttrProps(XmpNode parentNode, int indent);
    private void SerializeCompactRdfElementProps(XmpNode parentNode, int indent);
    private Object[] SerializeCompactRdfSimpleProp(XmpNode node);
    private void SerializeCompactRdfArrayProp(XmpNode node, int indent);
    private bool SerializeCompactRdfStructProp(XmpNode node, int indent, bool hasRdfResourceQual);
    private void SerializeCompactRdfGeneralQualifier(int indent, XmpNode node);
    private void SerializeCanonicalRdfSchema(XmpNode schemaNode, int level);
    private void DeclareUsedNamespaces(XmpNode node, ICollection`1<string> usedPrefixes, int indent);
    private void DeclareNamespace(string prefix, string namespace, ICollection`1<string> usedPrefixes, int indent);
    private void StartOuterRdfDescription(XmpNode schemaNode, int level);
    private void EndOuterRdfDescription(int level);
    private void SerializeCanonicalRdfProperty(XmpNode node, bool useCanonicalRdf, bool emitAsRdfValue, int indent);
    private void EmitRdfArrayTag(XmpNode arrayNode, bool isStartTag, int indent);
    private void AppendNodeValue(string value, bool forAttribute);
    private bool canBeRDFAttrProp(XmpNode node);
    private void WriteIndent(int times);
    private void Write(char c);
    private void Write(string str);
    private void WriteChars(int number, char c);
    private void WriteNewline();
}
public class iTextSharp.xmp.impl.XmpUtilsImpl : XmpConst {
    private static int UCK_NORMAL;
    private static int UCK_SPACE;
    private static int UCK_COMMA;
    private static int UCK_SEMICOLON;
    private static int UCK_QUOTE;
    private static int UCK_CONTROL;
    private static string SPACES;
    private static string COMMAS;
    private static string SEMICOLA;
    private static string CONTROLS;
    private static string QUOTES;
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    private static XmpNode SeparateFindCreateArray(string schemaNs, string arrayName, PropertyOptions arrayOptions, XmpMetaImpl xmp);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta destination, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    private static bool RemoveSchemaChildren(XmpNode schemaNode, bool doAllProperties);
    private static void AppendSubtree(XmpMetaImpl destXmp, XmpNode sourceNode, XmpNode destParent, bool replaceOldValues, bool deleteEmptyValues);
    private static bool ItemValuesMatch(XmpNode leftNode, XmpNode rightNode);
    private static void CheckSeparator(string separator);
    private static char CheckQuotes(string quotes, char openQuote);
    private static int ClassifyCharacter(char ch);
    private static char GetClosingQuote(char openQuote);
    private static string ApplyQuotes(string item, char openQuote, char closeQuote, bool allowCommas);
    private static bool IsSurroundingQuote(char ch, char openQuote, char closeQuote);
    private static bool IsClosingingQuote(char ch, char openQuote, char closeQuote);
}
public class iTextSharp.xmp.impl.xpath.PathPosition : object {
    internal int NameEnd;
    internal int NameStart;
    internal string Path;
    internal int StepBegin;
    internal int StepEnd;
}
public class iTextSharp.xmp.impl.xpath.XmpPath : object {
    public static UInt32 STRUCT_FIELD_STEP;
    public static UInt32 QUALIFIER_STEP;
    public static UInt32 ARRAY_INDEX_STEP;
    public static UInt32 ARRAY_LAST_STEP;
    public static UInt32 QUAL_SELECTOR_STEP;
    public static UInt32 FIELD_SELECTOR_STEP;
    public static UInt32 SCHEMA_NODE;
    public static UInt32 STEP_SCHEMA;
    public static UInt32 STEP_ROOT_PROP;
    private IList _segments;
    public virtual void Add(XmpPathSegment segment);
    public virtual XmpPathSegment GetSegment(int index);
    public virtual int Size();
    public virtual string ToString();
}
public class iTextSharp.xmp.impl.xpath.XmpPathParser : object {
    public static XmpPath ExpandXPath(string schemaNs, string path);
    internal static void SkipPathDelimiter(string path, PathPosition pos);
    internal static XmpPathSegment ParseStructSegment(PathPosition pos);
    internal static XmpPathSegment ParseIndexSegment(PathPosition pos);
    internal static void ParseRootNode(string schemaNs, PathPosition pos, XmpPath expandedXPath);
    internal static void VerifyQualName(string qualName);
    internal static void VerifySimpleXmlName(string name);
    internal static string VerifyXPathRoot(string schemaNs, string rootProp);
}
public class iTextSharp.xmp.impl.xpath.XmpPathSegment : object {
    private bool _alias;
    private UInt32 _aliasForm;
    private UInt32 _kind;
    private string _name;
    public UInt32 Kind { get; public set; }
    public string Name { get; public set; }
    public bool Alias { get; public set; }
    public UInt32 AliasForm { get; public set; }
    public XmpPathSegment(string name);
    public XmpPathSegment(string name, UInt32 kind);
    public virtual UInt32 get_Kind();
    public virtual void set_Kind(UInt32 value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void set_Alias(bool value);
    public virtual bool get_Alias();
    public virtual UInt32 get_AliasForm();
    public virtual void set_AliasForm(UInt32 value);
    public virtual string ToString();
}
public interface iTextSharp.xmp.IXmpDateTime {
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int NanoSecond { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public XmpCalendar Calendar { get; }
    public string Iso8601String { get; }
    public abstract virtual int get_Year();
    public abstract virtual void set_Year(int value);
    public abstract virtual int get_Month();
    public abstract virtual void set_Month(int value);
    public abstract virtual int get_Day();
    public abstract virtual void set_Day(int value);
    public abstract virtual int get_Hour();
    public abstract virtual void set_Hour(int value);
    public abstract virtual int get_Minute();
    public abstract virtual void set_Minute(int value);
    public abstract virtual int get_Second();
    public abstract virtual void set_Second(int value);
    public abstract virtual int get_NanoSecond();
    public abstract virtual void set_NanoSecond(int value);
    public abstract virtual TimeZone get_TimeZone();
    public abstract virtual void set_TimeZone(TimeZone value);
    public abstract virtual XmpCalendar get_Calendar();
    public abstract virtual string get_Iso8601String();
    public abstract virtual bool HasDate();
    public abstract virtual bool HasTime();
    public abstract virtual bool HasTimeZone();
}
public interface iTextSharp.xmp.IXmpIterator {
    public abstract virtual void SkipSubtree();
    public abstract virtual void SkipSiblings();
}
public interface iTextSharp.xmp.IXmpMeta {
    public string ObjectName { get; public set; }
    public string PacketHeader { get; }
    public abstract virtual string get_ObjectName();
    public abstract virtual void set_ObjectName(string value);
    public abstract virtual string get_PacketHeader();
    public abstract virtual IXmpProperty GetProperty(string schemaNs, string propName);
    public abstract virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual int CountArrayItems(string schemaNs, string arrayName);
    public abstract virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public abstract virtual void DeleteProperty(string schemaNs, string propName);
    public abstract virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual bool DoesPropertyExist(string schemaNs, string propName);
    public abstract virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public abstract virtual Nullable`1<bool> GetPropertyBoolean(string schemaNs, string propName);
    public abstract virtual Nullable`1<int> GetPropertyInteger(string schemaNs, string propName);
    public abstract virtual Nullable`1<long> GetPropertyLong(string schemaNs, string propName);
    public abstract virtual Nullable`1<double> GetPropertyDouble(string schemaNs, string propName);
    public abstract virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public abstract virtual DateTime GetPropertyCalendar(string schemaNs, string propName);
    public abstract virtual SByte[] GetPropertyBase64(string schemaNs, string propName);
    public abstract virtual string GetPropertyString(string schemaNs, string propName);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue, PropertyOptions options);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, DateTime propValue);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, SByte[] propValue);
    public abstract virtual IXmpIterator Iterator();
    public abstract virtual IXmpIterator Iterator(IteratorOptions options);
    public abstract virtual IXmpIterator Iterator(string schemaNs, string propName, IteratorOptions options);
    public abstract virtual void Sort();
    public abstract virtual void Normalize(ParseOptions options);
    public abstract virtual string DumpObject();
}
public interface iTextSharp.xmp.IXmpSchemaRegistry {
    public abstract virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public abstract virtual string GetNamespacePrefix(string namespaceUri);
    public abstract virtual string GetNamespaceUri(string namespacePrefix);
    public abstract virtual IDictionary GetNamespaces();
    public abstract virtual IDictionary GetPrefixes();
    public abstract virtual void DeleteNamespace(string namespaceUri);
    public abstract virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public abstract virtual IXmpAliasInfo[] FindAliases(string aliasNs);
    public abstract virtual IXmpAliasInfo FindAlias(string qname);
    public abstract virtual IDictionary GetAliases();
}
public interface iTextSharp.xmp.IXmpVersionInfo {
    public int Major { get; }
    public int Minor { get; }
    public int Micro { get; }
    public int Build { get; }
    public bool Debug { get; }
    public string Message { get; }
    public abstract virtual int get_Major();
    public abstract virtual int get_Minor();
    public abstract virtual int get_Micro();
    public abstract virtual int get_Build();
    public abstract virtual bool get_Debug();
    public abstract virtual string get_Message();
}
public class iTextSharp.xmp.options.AliasOptions : XmpOptions {
    public static UInt32 PROP_DIRECT;
    public static UInt32 PROP_ARRAY;
    public static UInt32 PROP_ARRAY_ORDERED;
    public static UInt32 PROP_ARRAY_ALTERNATE;
    public static UInt32 PROP_ARRAY_ALT_TEXT;
    public bool Simple { get; }
    public bool Array { get; public set; }
    public bool ArrayOrdered { get; public set; }
    public bool ArrayAlternate { get; public set; }
    public bool ArrayAltText { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public AliasOptions(UInt32 options);
    public bool get_Simple();
    public bool get_Array();
    public void set_Array(bool value);
    public bool get_ArrayOrdered();
    public void set_ArrayOrdered(bool value);
    public bool get_ArrayAlternate();
    public void set_ArrayAlternate(bool value);
    public bool get_ArrayAltText();
    public void set_ArrayAltText(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    public PropertyOptions ToPropertyOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.IteratorOptions : XmpOptions {
    public static UInt32 JUST_CHILDREN;
    public static UInt32 JUST_LEAFNODES;
    public static UInt32 JUST_LEAFNAME;
    public static UInt32 OMIT_QUALIFIERS;
    public bool JustChildren { get; public set; }
    public bool JustLeafname { get; public set; }
    public bool JustLeafnodes { get; public set; }
    public bool OmitQualifiers { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public bool get_JustChildren();
    public void set_JustChildren(bool value);
    public bool get_JustLeafname();
    public void set_JustLeafname(bool value);
    public bool get_JustLeafnodes();
    public void set_JustLeafnodes(bool value);
    public bool get_OmitQualifiers();
    public void set_OmitQualifiers(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.ParseOptions : XmpOptions {
    public static UInt32 REQUIRE_XMP_META;
    public static UInt32 STRICT_ALIASING;
    public static UInt32 FIX_CONTROL_CHARS;
    public static UInt32 ACCEPT_LATIN_1;
    public static UInt32 OMIT_NORMALIZATION;
    public bool RequireXmpMeta { get; public set; }
    public bool StrictAliasing { get; public set; }
    public bool FixControlChars { get; public set; }
    public bool AcceptLatin1 { get; public set; }
    public bool OmitNormalization { get; public set; }
    protected internal UInt32 ValidOptions { get; }
    public bool get_RequireXmpMeta();
    public void set_RequireXmpMeta(bool value);
    public bool get_StrictAliasing();
    public void set_StrictAliasing(bool value);
    public bool get_FixControlChars();
    public void set_FixControlChars(bool value);
    public bool get_AcceptLatin1();
    public void set_AcceptLatin1(bool value);
    public bool get_OmitNormalization();
    public void set_OmitNormalization(bool value);
    protected internal virtual UInt32 get_ValidOptions();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public class iTextSharp.xmp.options.PropertyOptions : XmpOptions {
    public static UInt32 NO_OPTIONS;
    public static UInt32 URI;
    public static UInt32 HAS_QUALIFIERS;
    public static UInt32 QUALIFIER;
    public static UInt32 HAS_LANGUAGE;
    public static UInt32 HAS_TYPE;
    public static UInt32 STRUCT;
    public static UInt32 ARRAY;
    public static UInt32 ARRAY_ORDERED;
    public static UInt32 ARRAY_ALTERNATE;
    public static UInt32 ARRAY_ALT_TEXT;
    public static UInt32 SCHEMA_NODE;
    public static UInt32 DELETE_EXISTING;
    public static int SEPARATE_NODE;
    public bool Uri { get; public set; }
    public bool HasQualifiers { get; public set; }
    public bool Qualifier { get; public set; }
    public bool HasLanguage { get; public set; }
    public bool HasType { get; public set; }
    public bool Struct { get; public set; }
    public bool Array { get; public set; }
    public bool ArrayOrdered { get; public set; }
    public bool ArrayAlternate { get; public set; }
    public bool ArrayAltText { get; public set; }
    public bool SchemaNode { get; public set; }
    public bool CompositeProperty { get; }
    public bool Simple { get; }
    public bool OnlyArrayOptions { get; }
    protected internal UInt32 ValidOptions { get; }
    public PropertyOptions(UInt32 options);
    public bool get_Uri();
    public void set_Uri(bool value);
    public bool get_HasQualifiers();
    public void set_HasQualifiers(bool value);
    public bool get_Qualifier();
    public void set_Qualifier(bool value);
    public bool get_HasLanguage();
    public void set_HasLanguage(bool value);
    public bool get_HasType();
    public void set_HasType(bool value);
    public bool get_Struct();
    public void set_Struct(bool value);
    public bool get_Array();
    public void set_Array(bool value);
    public bool get_ArrayOrdered();
    public void set_ArrayOrdered(bool value);
    public bool get_ArrayAlternate();
    public void set_ArrayAlternate(bool value);
    public bool get_ArrayAltText();
    public void set_ArrayAltText(bool value);
    public bool get_SchemaNode();
    public void set_SchemaNode(bool value);
    public bool get_CompositeProperty();
    public bool get_Simple();
    public bool get_OnlyArrayOptions();
    protected internal virtual UInt32 get_ValidOptions();
    public bool EqualArrayTypes(PropertyOptions options);
    public void MergeWith(PropertyOptions options);
    protected internal virtual string DefineOptionName(UInt32 option);
    protected internal virtual void AssertConsistency(UInt32 options);
}
public class iTextSharp.xmp.options.SerializeOptions : XmpOptions {
    public static UInt32 OMIT_PACKET_WRAPPER;
    public static UInt32 READONLY_PACKET;
    public static UInt32 USE_COMPACT_FORMAT;
    public static UInt32 USE_CANONICAL_FORMAT;
    public static UInt32 INCLUDE_THUMBNAIL_PAD;
    public static UInt32 EXACT_PACKET_LENGTH;
    public static UInt32 OMIT_XMPMETA_ELEMENT;
    public static UInt32 SORT;
    private static UInt32 LITTLEENDIAN_BIT;
    private static UInt32 UTF16_BIT;
    public static UInt32 ENCODE_UTF8;
    public static UInt32 ENCODE_UTF16BE;
    public static UInt32 ENCODE_UTF16LE;
    private static UInt32 ENCODING_MASK;
    private int _baseIndent;
    private string _indent;
    private string _newline;
    private bool _omitVersionAttribute;
    private int _padding;
    public bool OmitPacketWrapper { get; public set; }
    public bool OmitXmpMetaElement { get; public set; }
    public bool ReadOnlyPacket { get; public set; }
    public bool UseCompactFormat { get; public set; }
    public bool UseCanonicalFormat { get; public set; }
    public bool IncludeThumbnailPad { get; public set; }
    public bool ExactPacketLength { get; public set; }
    public bool Sort { get; public set; }
    public bool EncodeUtf16Be { get; public set; }
    public bool EncodeUtf16Le { get; public set; }
    public int BaseIndent { get; public set; }
    public string Indent { get; public set; }
    public string Newline { get; public set; }
    public int Padding { get; public set; }
    public bool OmitVersionAttribute { get; }
    public string Encoding { get; }
    protected internal UInt32 ValidOptions { get; }
    public SerializeOptions(UInt32 options);
    public bool get_OmitPacketWrapper();
    public void set_OmitPacketWrapper(bool value);
    public bool get_OmitXmpMetaElement();
    public void set_OmitXmpMetaElement(bool value);
    public bool get_ReadOnlyPacket();
    public void set_ReadOnlyPacket(bool value);
    public bool get_UseCompactFormat();
    public void set_UseCompactFormat(bool value);
    public bool get_UseCanonicalFormat();
    public void set_UseCanonicalFormat(bool value);
    public bool get_IncludeThumbnailPad();
    public void set_IncludeThumbnailPad(bool value);
    public bool get_ExactPacketLength();
    public void set_ExactPacketLength(bool value);
    public bool get_Sort();
    public void set_Sort(bool value);
    public bool get_EncodeUtf16Be();
    public void set_EncodeUtf16Be(bool value);
    public bool get_EncodeUtf16Le();
    public void set_EncodeUtf16Le(bool value);
    public int get_BaseIndent();
    public void set_BaseIndent(int value);
    public string get_Indent();
    public void set_Indent(string value);
    public string get_Newline();
    public void set_Newline(string value);
    public int get_Padding();
    public void set_Padding(int value);
    public bool get_OmitVersionAttribute();
    public string get_Encoding();
    protected internal virtual UInt32 get_ValidOptions();
    public object Clone();
    protected internal virtual string DefineOptionName(UInt32 option);
}
public abstract class iTextSharp.xmp.options.XmpOptions : object {
    private IDictionary _optionNames;
    private UInt32 _options;
    public UInt32 Options { get; public set; }
    public string OptionsString { get; }
    protected internal UInt32 ValidOptions { get; }
    public XmpOptions(UInt32 options);
    public virtual UInt32 get_Options();
    public virtual void set_Options(UInt32 value);
    public virtual string get_OptionsString();
    protected internal abstract virtual UInt32 get_ValidOptions();
    public virtual void Clear();
    public virtual bool IsExactly(UInt32 optionBits);
    public virtual bool ContainsAllOptions(UInt32 optionBits);
    public virtual bool ContainsOneOf(UInt32 optionBits);
    protected internal virtual bool GetOption(UInt32 optionBit);
    public virtual void SetOption(UInt32 optionBits, bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected internal abstract virtual string DefineOptionName(UInt32 option);
    protected internal virtual void AssertConsistency(UInt32 options);
    private void AssertOptionsValid(UInt32 options);
    private string GetOptionName(UInt32 option);
    private IDictionary ProcureOptionNames();
}
public interface iTextSharp.xmp.properties.IXmpAliasInfo {
    public string Namespace { get; }
    public string Prefix { get; }
    public string PropName { get; }
    public AliasOptions AliasForm { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Prefix();
    public abstract virtual string get_PropName();
    public abstract virtual AliasOptions get_AliasForm();
}
public interface iTextSharp.xmp.properties.IXmpProperty {
    public string Value { get; }
    public PropertyOptions Options { get; }
    public string Language { get; }
    public abstract virtual string get_Value();
    public abstract virtual PropertyOptions get_Options();
    public abstract virtual string get_Language();
}
public interface iTextSharp.xmp.properties.IXmpPropertyInfo {
    public string Namespace { get; }
    public string Path { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Path();
}
public class iTextSharp.xmp.XmpCalendar : object {
    private DateTime _dateTime;
    private TimeZone _timeZone;
    public DateTime DateTime { get; public set; }
    public TimeZone TimeZone { get; public set; }
    public long TimeInMillis { get; public set; }
    public XmpCalendar(DateTime dt, TimeZone tz);
    public XmpCalendar(DateTime dt);
    public XmpCalendar(TimeZone tz);
    public virtual DateTime get_DateTime();
    public virtual void set_DateTime(DateTime value);
    public virtual TimeZone get_TimeZone();
    public virtual void set_TimeZone(TimeZone value);
    public virtual long get_TimeInMillis();
    public virtual void set_TimeInMillis(long value);
}
public class iTextSharp.xmp.XmpConst : object {
    public static string NS_XML;
    public static string NS_RDF;
    public static string NS_DC;
    public static string NS_IPTCCORE;
    public static string NS_IPTCEXT;
    public static string NS_DICOM;
    public static string NS_PLUS;
    public static string NS_X;
    public static string NS_IX;
    public static string NS_XMP;
    public static string NS_XMP_RIGHTS;
    public static string NS_XMP_MM;
    public static string NS_XMP_BJ;
    public static string NS_XMP_NOTE;
    public static string NS_PDF;
    public static string NS_PDFX;
    public static string NS_PDFX_ID;
    public static string NS_PDFA_SCHEMA;
    public static string NS_PDFA_PROPERTY;
    public static string NS_PDFA_TYPE;
    public static string NS_PDFA_FIELD;
    public static string NS_PDFA_ID;
    public static string NS_PDFUA_ID;
    public static string NS_PDFA_EXTENSION;
    public static string NS_PHOTOSHOP;
    public static string NS_PSALBUM;
    public static string NS_EXIF;
    public static string NS_EXIFX;
    public static string NS_EXIF_AUX;
    public static string NS_TIFF;
    public static string NS_PNG;
    public static string NS_JPEG;
    public static string NS_JP2K;
    public static string NS_CAMERARAW;
    public static string NS_ADOBESTOCKPHOTO;
    public static string NS_CREATOR_ATOM;
    public static string NS_ASF;
    public static string NS_WAV;
    public static string NS_BWF;
    public static string NS_RIFFINFO;
    public static string NS_SCRIPT;
    public static string NS_TXMP;
    public static string NS_SWF;
    public static string NS_DM;
    public static string NS_TRANSIENT;
    public static string NS_DC_DEPRECATED;
    public static string TYPE_IDENTIFIERQUAL;
    public static string TYPE_DIMENSIONS;
    public static string TYPE_TEXT;
    public static string TYPE_PAGEDFILE;
    public static string TYPE_GRAPHICS;
    public static string TYPE_IMAGE;
    public static string TYPE_FONT;
    public static string TYPE_RESOURCEEVENT;
    public static string TYPE_RESOURCEREF;
    public static string TYPE_ST_VERSION;
    public static string TYPE_ST_JOB;
    public static string TYPE_MANIFESTITEM;
    public static string TRUESTR;
    public static string FALSESTR;
    public static int ARRAY_LAST_ITEM;
    public static string ARRAY_ITEM_NAME;
    public static string X_DEFAULT;
    public static string XML_LANG;
    public static string RDF_TYPE;
    public static string XMP_PI;
    public static string TAG_XMPMETA;
    public static string TAG_XAPMETA;
}
public static class iTextSharp.xmp.XmpDateTimeFactory : object {
    public static IXmpDateTime CurrentDateTime { get; }
    public static IXmpDateTime get_CurrentDateTime();
    public static IXmpDateTime CreateFromCalendar(XmpCalendar calendar);
    public static IXmpDateTime Create();
    public static IXmpDateTime Create(int year, int month, int day);
    public static IXmpDateTime Create(int year, int month, int day, int hour, int minute, int second, int nanoSecond);
    public static IXmpDateTime CreateFromIso8601(string strValue);
    public static IXmpDateTime SetLocalTimeZone(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToUtcTime(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToLocalTime(IXmpDateTime dateTime);
}
public class iTextSharp.xmp.XmpError : object {
    public static int UNKNOWN;
    public static int BADPARAM;
    public static int BADVALUE;
    public static int INTERNALFAILURE;
    public static int BADSCHEMA;
    public static int BADXPATH;
    public static int BADOPTIONS;
    public static int BADINDEX;
    public static int BADSERIALIZE;
    public static int BADXML;
    public static int BADRDF;
    public static int BADXMP;
    public static int BADSTREAM;
}
public class iTextSharp.xmp.XmpException : Exception {
    private int _errorCode;
    public int ErrorCode { get; }
    public XmpException(string message, int errorCode);
    public XmpException(string message, int errorCode, Exception t);
    public virtual int get_ErrorCode();
}
public static class iTextSharp.xmp.XmpMetaFactory : object {
    private static IXmpSchemaRegistry _schema;
    private static IXmpVersionInfo _versionInfo;
    public static IXmpSchemaRegistry SchemaRegistry { get; }
    private static XmpMetaFactory();
    public static IXmpSchemaRegistry get_SchemaRegistry();
    public static IXmpMeta Create();
    public static IXmpMeta Parse(Stream in);
    public static IXmpMeta Parse(Stream in, ParseOptions options);
    public static IXmpMeta ParseFromString(string packet);
    public static IXmpMeta ParseFromString(string packet, ParseOptions options);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer, ParseOptions options);
    public static void Serialize(IXmpMeta xmp, Stream out);
    public static void Serialize(IXmpMeta xmp, Stream out, SerializeOptions options);
    public static Byte[] SerializeToBuffer(IXmpMeta xmp, SerializeOptions options);
    public static string SerializeToString(IXmpMeta xmp, SerializeOptions options);
    private static void AssertImplementation(IXmpMeta xmp);
    public static void Reset();
    public static IXmpVersionInfo GetVersionInfo();
}
public static class iTextSharp.xmp.XmpPathFactory : object {
    public static string ComposeArrayItemPath(string arrayName, int itemIndex);
    public static string ComposeStructFieldPath(string fieldNs, string fieldName);
    public static string ComposeQualifierPath(string qualNs, string qualName);
    public static string ComposeLangSelector(string arrayName, string langName);
    public static string ComposeFieldSelector(string arrayName, string fieldNs, string fieldName, string fieldValue);
    private static void AssertQualNs(string qualNs);
    private static void AssertQualName(string qualName);
    private static void AssertFieldNs(string fieldNs);
    private static void AssertFieldName(string fieldName);
}
public class iTextSharp.xmp.XmpUtils : object {
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta dest, bool doAllProperties, bool replaceOldValues);
    public static void AppendProperties(IXmpMeta source, IXmpMeta dest, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    public static bool ConvertToBoolean(string value);
    public static string ConvertFromBoolean(bool value);
    public static int ConvertToInteger(string rawValue);
    public static string ConvertFromInteger(int value);
    public static long ConvertToLong(string rawValue);
    public static string ConvertFromLong(long value);
    public static double ConvertToDouble(string rawValue);
    public static string ConvertFromDouble(double value);
    public static IXmpDateTime ConvertToDate(string rawValue);
    public static string ConvertFromDate(IXmpDateTime value);
    public static string EncodeBase64(Byte[] buffer);
    public static Byte[] DecodeBase64(string base64String);
    private static Byte[] GetBytes(string str);
    private static string GetString(Byte[] bytes);
}
public class System.util.collections.HashSet2`1 : object {
    private Dictionary`2<T, object> set;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal Dictionary`2<T, object> InternalSet { get; }
    public HashSet2`1(IEnumerable`1<T> set);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool AddAndCheck(T item);
    public virtual void Add(T item);
    public virtual void AddAll(IEnumerable`1<T> set);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual bool Remove(T item);
    public virtual int get_Count();
    public virtual bool IsEmpty();
    public virtual bool get_IsReadOnly();
    public virtual bool RetainAll(ICollection`1<T> collection);
    internal virtual Dictionary`2<T, object> get_InternalSet();
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.LinkedDictionary`2 : object {
    private Dictionary`2<TKey, LinkedListNode`1<KeyValuePair`2<TKey, TValue>>> dic;
    private LinkedList`1<KeyValuePair`2<TKey, TValue>> link;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public virtual void Add(TKey key, TValue value);
    public virtual bool ContainsKey(TKey key);
    public virtual ICollection`1<TKey> get_Keys();
    public virtual bool Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    public virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.OrderedTree : object {
    private int intCount;
    private OrderedTreeNode rbTree;
    private OrderedTreeNode sentinelNode;
    private OrderedTreeNode lastNodeFound;
    public object Item { get; public set; }
    public OrderedTreeEnumerator Keys { get; }
    public OrderedTreeEnumerator Values { get; }
    public int Count { get; }
    public object get_Item(IComparable key);
    public void set_Item(IComparable key, object value);
    public virtual void Add(IComparable key, object data);
    private void RestoreAfterInsert(OrderedTreeNode x);
    public virtual void RotateLeft(OrderedTreeNode x);
    public virtual void RotateRight(OrderedTreeNode x);
    public virtual bool ContainsKey(IComparable key);
    public virtual object GetData(IComparable key);
    public virtual IComparable GetMinKey();
    public virtual IComparable GetMaxKey();
    public virtual object GetMinValue();
    public virtual object GetMaxValue();
    public virtual OrderedTreeEnumerator GetEnumerator();
    public virtual OrderedTreeEnumerator get_Keys();
    public virtual OrderedTreeEnumerator KeyElements(bool ascending);
    public virtual OrderedTreeEnumerator get_Values();
    public virtual OrderedTreeEnumerator Elements();
    public virtual OrderedTreeEnumerator Elements(bool ascending);
    public virtual bool IsEmpty();
    public virtual void Remove(IComparable key);
    private void Delete(OrderedTreeNode z);
    private void RestoreAfterDelete(OrderedTreeNode x);
    public virtual void RemoveMin();
    public virtual void RemoveMax();
    public virtual void Clear();
    public virtual int get_Count();
}
public class System.util.collections.OrderedTreeEnumerator : object {
    private Stack stack;
    private bool keys;
    private bool ascending;
    private OrderedTreeNode tnode;
    private OrderedTreeNode sentinelNode;
    private bool pre;
    private IComparable ordKey;
    private object objValue;
    public IComparable Key { get; public set; }
    public object Value { get; public set; }
    public object Current { get; }
    public OrderedTreeEnumerator(OrderedTreeNode tnode, bool keys, bool ascending, OrderedTreeNode sentinelNode);
    public virtual IComparable get_Key();
    public virtual void set_Key(IComparable value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual void Reset();
    public virtual object get_Current();
    public virtual bool HasMoreElements();
    public virtual object NextElement();
    public virtual bool MoveNext();
    public virtual OrderedTreeEnumerator GetEnumerator();
}
public class System.util.collections.OrderedTreeNode : object {
    public static bool RED;
    public static bool BLACK;
    private IComparable ordKey;
    private object objData;
    private bool intColor;
    private OrderedTreeNode rbnLeft;
    private OrderedTreeNode rbnRight;
    private OrderedTreeNode rbnParent;
    public IComparable Key { get; public set; }
    public object Data { get; public set; }
    public bool Color { get; public set; }
    public OrderedTreeNode Left { get; public set; }
    public OrderedTreeNode Right { get; public set; }
    public OrderedTreeNode Parent { get; public set; }
    public virtual IComparable get_Key();
    public virtual void set_Key(IComparable value);
    public virtual object get_Data();
    public virtual void set_Data(object value);
    public virtual bool get_Color();
    public virtual void set_Color(bool value);
    public virtual OrderedTreeNode get_Left();
    public virtual void set_Left(OrderedTreeNode value);
    public virtual OrderedTreeNode get_Right();
    public virtual void set_Right(OrderedTreeNode value);
    public virtual OrderedTreeNode get_Parent();
    public virtual void set_Parent(OrderedTreeNode value);
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> source;
    private object syncRoot;
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TValue Item { get; public set; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionaryToWrap);
    public virtual int get_Count();
    public virtual ICollection`1<TKey> get_Keys();
    public virtual ICollection`1<TValue> get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    public virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private static void ThrowNotSupportedException();
}
public class System.util.FilterStream : Stream {
    private Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class System.util.ListIterator`1 : object {
    private IList`1<T> col;
    private int cursor;
    private int lastRet;
    public ListIterator`1(IList`1<T> col);
    public virtual bool HasNext();
    public virtual T Next();
    public virtual T Previous();
    public virtual void Remove();
}
[DefaultMemberAttribute("Item")]
public class System.util.Properties : object {
    private Dictionary`2<string, string> _col;
    private static string whiteSpaceChars;
    private static string keyValueSeparators;
    private static string strictKeyValueSeparators;
    public int Count { get; }
    public string Item { get; public set; }
    public KeyCollection<string, string> Keys { get; }
    public virtual string Remove(string key);
    public virtual Enumerator<string, string> GetEnumerator();
    public virtual bool ContainsKey(string key);
    public virtual void Add(string key, string value);
    public virtual void AddAll(Properties col);
    public virtual int get_Count();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual KeyCollection<string, string> get_Keys();
    public virtual void Clear();
    public virtual void Load(Stream inStream);
    private string LoadConvert(string theString);
    private bool ContinueLine(string line);
}
public class System.util.PushbackStream : FilterStream {
    private int buf;
    public PushbackStream(Stream s);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class System.util.RectangleJ : object {
    public static int OUT_LEFT;
    public static int OUT_TOP;
    public static int OUT_RIGHT;
    public static int OUT_BOTTOM;
    private float x;
    private float y;
    private float width;
    private float height;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public RectangleJ(float x, float y, float width, float height);
    public RectangleJ(Rectangle rect);
    public virtual float get_X();
    public virtual void set_X(float value);
    public virtual float get_Y();
    public virtual void set_Y(float value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public virtual float get_Height();
    public virtual void set_Height(float value);
    public virtual void Add(RectangleJ rect);
    public virtual int Outcode(double x, double y);
    public virtual bool IntersectsLine(double x1, double y1, double x2, double y2);
    public virtual RectangleJ Intersection(RectangleJ r);
    public virtual bool IsEmpty();
    public virtual bool Contains(Point2D point);
    public virtual bool Contains(double x, double y);
}
public class System.util.StringTokenizer : object {
    private int pos;
    private string str;
    private int len;
    private string delim;
    private bool retDelims;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool retDelims);
    public virtual bool HasMoreTokens();
    public virtual string NextToken(string delim);
    public virtual string NextToken();
    public virtual int CountTokens();
}
public static class System.util.Util : object {
    public static int USR(int op1, int op2);
    public static bool EqualsIgnoreCase(string s1, string s2);
    public static int CompareToIgnoreCase(string s1, string s2);
    public static CultureInfo GetStandartEnUSLocale();
    public static int GetArrayHashCode(T[] a);
    public static int Compare(float f1, float f2);
    public static bool ArraysAreEqual(T[] a, T[] b);
    public static bool AreEqual(Stack`1<T> s1, Stack`1<T> s2);
    public static T Min(T[] array);
    public static T Max(T[] array);
    public static void AddAll(ICollection`1<T> dest, IEnumerable`1<T> source, int srcStartFrom);
    public static void AddAll(ICollection`1<T> dest, IEnumerable`1<T> source);
    public static void AddAll(Queue`1<T> to, IEnumerable`1<T> from);
}
internal class System.util.zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class System.util.zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static Config[] config_table;
    private static String[] z_errmsg;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class System.util.zlib.InfBlocks : object {
    private static int MANY;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class System.util.zlib.InfCodes : object {
    private static Int32[] inflate_mask;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class System.util.zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class System.util.zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private static int BMAX;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class System.util.zlib.JZlib : object {
    private static string _version;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class System.util.zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class System.util.zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
public class System.util.zlib.ZDeflaterOutputStream : Stream {
    protected ZStream z;
    protected int flushLevel;
    private static int BUFSIZE;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Finish();
    public virtual void End();
    public virtual void Close();
}
public class System.util.zlib.ZInflaterInputStream : Stream {
    protected ZStream z;
    protected int flushLevel;
    private static int BUFSIZE;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class System.util.zlib.ZInputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream input;
    protected bool closed;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZInputStream(Stream input);
    public ZInputStream(Stream input, bool nowrap);
    public ZInputStream(Stream input, int level);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int ReadByte();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public class System.util.zlib.ZOutputStream : Stream {
    private static int BufferSize;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    protected Byte[] buf1;
    protected bool compress;
    protected Stream output;
    protected bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int FlushMode { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public ZOutputStream(Stream output);
    public ZOutputStream(Stream output, int level);
    public ZOutputStream(Stream output, int level, bool nowrap);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void End();
    public virtual void Finish();
    public virtual void Flush();
    public virtual int get_FlushMode();
    public virtual void set_FlushMode(int value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
}
public class System.util.zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
[AttributeUsageAttribute("1")]
internal class Versions.Attributes.KeyVersionAttribute : Attribute {
    private string keyVersion;
    internal string KeyVersion { get; private set; }
    internal KeyVersionAttribute(string keyVersion);
    internal string get_KeyVersion();
    private void set_KeyVersion(string value);
}
