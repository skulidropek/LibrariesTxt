public class iTextSharp.text.Anchor : Phrase {
    protected string name;
    protected string reference;
    public ArrayList Chunks { get; }
    public int Type { get; }
    public string Name { get; public set; }
    public string Reference { get; public set; }
    public Uri Url { get; }
    public Anchor(float leading);
    public Anchor(Chunk chunk);
    public Anchor(string str);
    public Anchor(string str, Font font);
    public Anchor(float leading, Chunk chunk);
    public Anchor(float leading, string str);
    public Anchor(float leading, string str, Font font);
    public Anchor(Phrase phrase);
    public virtual bool Process(IElementListener listener);
    public virtual ArrayList get_Chunks();
    public virtual int get_Type();
    public string get_Name();
    public void set_Name(string value);
    public string get_Reference();
    public void set_Reference(string value);
    public Uri get_Url();
}
public class iTextSharp.text.Annotation : object {
    public static int TEXT;
    public static int URL_NET;
    public static int URL_AS_STRING;
    public static int FILE_DEST;
    public static int FILE_PAGE;
    public static int NAMED_DEST;
    public static int LAUNCH;
    public static int SCREEN;
    public static string TITLE;
    public static string CONTENT;
    public static string URL;
    public static string FILE;
    public static string DESTINATION;
    public static string PAGE;
    public static string NAMED;
    public static string APPLICATION;
    public static string PARAMETERS;
    public static string OPERATION;
    public static string DEFAULTDIR;
    public static string LLX;
    public static string LLY;
    public static string URX;
    public static string URY;
    public static string MIMETYPE;
    protected int annotationtype;
    protected Hashtable annotationAttributes;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public int AnnotationType { get; }
    public string Title { get; }
    public string Content { get; }
    public Hashtable Attributes { get; }
    private Annotation(float llx, float lly, float urx, float ury);
    public Annotation(Annotation an);
    public Annotation(string title, string text);
    public Annotation(string title, string text, float llx, float lly, float urx, float ury);
    public Annotation(float llx, float lly, float urx, float ury, Uri url);
    public Annotation(float llx, float lly, float urx, float ury, string url);
    public Annotation(float llx, float lly, float urx, float ury, string file, string dest);
    public Annotation(float llx, float lly, float urx, float ury, string moviePath, string mimeType, bool showOnDisplay);
    public Annotation(float llx, float lly, float urx, float ury, string file, int page);
    public Annotation(float llx, float lly, float urx, float ury, int named);
    public Annotation(float llx, float lly, float urx, float ury, string application, string parameters, string operation, string defaultdir);
    public sealed virtual int get_Type();
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual ArrayList get_Chunks();
    public void SetDimensions(float llx, float lly, float urx, float ury);
    public float GetLlx();
    public float GetLly();
    public float GetUrx();
    public float GetUry();
    public float GetLlx(float def);
    public float GetLly(float def);
    public float GetUrx(float def);
    public float GetUry(float def);
    public int get_AnnotationType();
    public string get_Title();
    public string get_Content();
    public Hashtable get_Attributes();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual string ToString();
}
public class iTextSharp.text.BadElementException : DocumentException {
    public BadElementException(string message);
}
public class iTextSharp.text.Cell : Rectangle {
    protected ArrayList arrayList;
    protected int horizontalAlignment;
    protected int verticalAlignment;
    protected float width;
    protected bool percentage;
    protected int colspan;
    protected int rowspan;
    private float leading;
    protected bool header;
    protected bool useAscender;
    protected bool useDescender;
    protected bool useBorderPadding;
    protected bool noWrap;
    protected bool groupChange;
    protected int maxLines;
    private string showTruncation;
    public static Cell DummyCell { get; }
    public int Type { get; }
    public ArrayList Chunks { get; }
    public float Width { get; public set; }
    public int Size { get; }
    public ArrayList Elements { get; }
    public int HorizontalAlignment { get; public set; }
    public int VerticalAlignment { get; public set; }
    public int Colspan { get; public set; }
    public int Rowspan { get; public set; }
    public float Leading { get; public set; }
    public bool Header { get; public set; }
    public bool NoWrap { get; public set; }
    public float Top { get; public set; }
    public float Bottom { get; public set; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public bool GroupChange { get; public set; }
    public int MaxLines { get; public set; }
    public string ShowTruncation { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public Cell(bool dummy);
    public Cell(string content);
    public Cell(IElement element);
    public static Cell get_DummyCell();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual ArrayList get_Chunks();
    public void AddElement(IElement element);
    public sealed virtual bool Add(object o);
    public void SetHorizontalAlignment(string alignment);
    public void SetVerticalAlignment(string alignment);
    public virtual void set_Width(float value);
    public virtual float get_Width();
    public void SetWidth(string value);
    public string GetWidthAsString();
    public int get_Size();
    public bool IsEmpty();
    internal void Fill();
    public bool IsTable();
    public ArrayList get_Elements();
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public int get_VerticalAlignment();
    public void set_VerticalAlignment(int value);
    public int get_Colspan();
    public void set_Colspan(int value);
    public int get_Rowspan();
    public void set_Rowspan(int value);
    public float get_Leading();
    public void set_Leading(float value);
    public bool get_Header();
    public void set_Header(bool value);
    public bool get_NoWrap();
    public void set_NoWrap(bool value);
    public void Clear();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public float GetTop(int margin);
    public float GetBottom(int margin);
    public float GetLeft(int margin);
    public float GetRight(int margin);
    public static bool IsTag(string tag);
    public bool get_GroupChange();
    public void set_GroupChange(bool value);
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public string get_ShowTruncation();
    public void set_ShowTruncation(string value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public bool get_UseBorderPadding();
    public void set_UseBorderPadding(bool value);
    public PdfPCell CreatePdfPCell();
}
public class iTextSharp.text.Chapter : Section {
    public int Type { get; }
    public Chapter(int number);
    public Chapter(Paragraph title, int number);
    public Chapter(string title, int number);
    public virtual int get_Type();
    public virtual bool IsNestable();
}
public class iTextSharp.text.ChapterAutoNumber : Chapter {
    protected bool numberSet;
    public ChapterAutoNumber(Paragraph para);
    public ChapterAutoNumber(string title);
    public virtual Section AddSection(string title);
    public virtual Section AddSection(Paragraph title);
    public int SetAutomaticNumber(int number);
}
public class iTextSharp.text.Chunk : object {
    public static string OBJECT_REPLACEMENT_CHARACTER;
    public static string SEPARATOR;
    public static string TAB;
    public static string HSCALE;
    public static string UNDERLINE;
    public static string SUBSUPSCRIPT;
    public static string SKEW;
    public static string BACKGROUND;
    public static string TEXTRENDERMODE;
    public static string SPLITCHARACTER;
    public static string HYPHENATION;
    public static string REMOTEGOTO;
    public static string LOCALGOTO;
    public static string LOCALDESTINATION;
    public static string GENERICTAG;
    public static string IMAGE;
    public static string ACTION;
    public static string NEWPAGE;
    public static string PDFANNOTATION;
    public static string COLOR;
    public static string ENCODING;
    public static Chunk NEWLINE;
    public static Chunk NEXTPAGE;
    protected StringBuilder content;
    protected Font font;
    protected Hashtable attributes;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public Font Font { get; public set; }
    public string Content { get; }
    public Hashtable Attributes { get; public set; }
    public float HorizontalScaling { get; }
    private static Chunk();
    public Chunk(Chunk ck);
    public Chunk(string content, Font font);
    public Chunk(string content);
    public Chunk(char c, Font font);
    public Chunk(char c);
    public Chunk(Image image, float offsetX, float offsetY);
    public Chunk(IDrawInterface separator);
    public Chunk(IDrawInterface separator, bool vertical);
    public Chunk(IDrawInterface separator, float tabPosition);
    public Chunk(IDrawInterface separator, float tabPosition, bool newline);
    public Chunk(Image image, float offsetX, float offsetY, bool changeLeading);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public StringBuilder Append(string str);
    public virtual Font get_Font();
    public virtual void set_Font(Font value);
    public virtual string get_Content();
    public virtual string ToString();
    public virtual bool IsEmpty();
    public float GetWidthPoint();
    public bool HasAttributes();
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    private Chunk SetAttribute(string name, object obj);
    public Chunk SetHorizontalScaling(float scale);
    public float get_HorizontalScaling();
    public Chunk SetUnderline(float thickness, float yPosition);
    public Chunk SetUnderline(Color color, float thickness, float thicknessMul, float yPosition, float yPositionMul, int cap);
    public Chunk SetTextRise(float rise);
    public float GetTextRise();
    public Chunk SetSkew(float alpha, float beta);
    public Chunk SetBackground(Color color);
    public Chunk SetBackground(Color color, float extraLeft, float extraBottom, float extraRight, float extraTop);
    public Chunk SetTextRenderMode(int mode, float strokeWidth, Color strokeColor);
    public Chunk SetSplitCharacter(ISplitCharacter splitCharacter);
    public Chunk SetHyphenation(IHyphenationEvent hyphenation);
    public Chunk SetRemoteGoto(string filename, string name);
    public Chunk SetRemoteGoto(string filename, int page);
    public Chunk SetLocalGoto(string name);
    public Chunk SetLocalDestination(string name);
    public Chunk SetGenericTag(string text);
    public Image GetImage();
    public static bool IsTag(string tag);
    public Chunk SetAction(PdfAction action);
    public Chunk SetAnchor(Uri url);
    public Chunk SetAnchor(string url);
    public Chunk SetNewPage();
    public Chunk SetAnnotation(PdfAnnotation annotation);
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public IHyphenationEvent GetHyphenation();
}
public class iTextSharp.text.Color : object {
    private static double FACTOR;
    public static Color WHITE;
    public static Color LIGHT_GRAY;
    public static Color GRAY;
    public static Color DARK_GRAY;
    public static Color BLACK;
    public static Color RED;
    public static Color PINK;
    public static Color ORANGE;
    public static Color YELLOW;
    public static Color GREEN;
    public static Color MAGENTA;
    public static Color CYAN;
    public static Color BLUE;
    private Color color;
    public int R { get; }
    public int G { get; }
    public int B { get; }
    public Color(int red, int green, int blue);
    public Color(int red, int green, int blue, int alpha);
    public Color(float red, float green, float blue);
    public Color(float red, float green, float blue, float alpha);
    public Color(int argb);
    public Color(Color color);
    private static Color();
    public int get_R();
    public int get_G();
    public int get_B();
    public Color Brighter();
    public Color Darker();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int ToArgb();
}
public class iTextSharp.text.Document : object {
    private static string ITEXT;
    private static string RELEASE;
    private static string ITEXT_VERSION;
    public static bool Compress;
    public static float WmfFontCorrection;
    private ArrayList listeners;
    protected bool open;
    protected bool close;
    protected Rectangle pageSize;
    protected float marginLeft;
    protected float marginRight;
    protected float marginTop;
    protected float marginBottom;
    protected bool marginMirroring;
    protected bool marginMirroringTopBottom;
    protected string javaScript_onLoad;
    protected string javaScript_onUnLoad;
    protected string htmlStyleClass;
    protected int pageN;
    protected HeaderFooter header;
    protected HeaderFooter footer;
    protected int chapternumber;
    unknown HeaderFooter Header {public set; }
    unknown HeaderFooter Footer {public set; }
    unknown int PageCount {public set; }
    public int PageNumber { get; }
    public float LeftMargin { get; }
    public float RightMargin { get; }
    public float TopMargin { get; }
    public float BottomMargin { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public Rectangle PageSize { get; }
    public static string Product { get; }
    public static string Release { get; }
    public static string Version { get; }
    public string JavaScript_onLoad { get; public set; }
    public string JavaScript_onUnLoad { get; public set; }
    public string HtmlStyleClass { get; public set; }
    public Document(Rectangle pageSize);
    public Document(Rectangle pageSize, float marginLeft, float marginRight, float marginTop, float marginBottom);
    private static Document();
    public void AddDocListener(IDocListener listener);
    public void RemoveIDocListener(IDocListener listener);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void set_Header(HeaderFooter value);
    public virtual void ResetHeader();
    public virtual void set_Footer(HeaderFooter value);
    public virtual void ResetFooter();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public int get_PageNumber();
    public virtual void Close();
    public bool AddHeader(string name, string content);
    public bool AddTitle(string title);
    public bool AddSubject(string subject);
    public bool AddKeywords(string keywords);
    public bool AddAuthor(string author);
    public bool AddCreator(string creator);
    public bool AddProducer();
    public bool AddCreationDate();
    public float get_LeftMargin();
    public float get_RightMargin();
    public float get_TopMargin();
    public float get_BottomMargin();
    public float get_Left();
    public float get_Right();
    public float get_Top();
    public float get_Bottom();
    public float GetLeft(float margin);
    public float GetRight(float margin);
    public float GetTop(float margin);
    public float GetBottom(float margin);
    public Rectangle get_PageSize();
    public bool IsOpen();
    public static string get_Product();
    public static string get_Release();
    public static string get_Version();
    public string get_JavaScript_onLoad();
    public void set_JavaScript_onLoad(string value);
    public string get_JavaScript_onUnLoad();
    public void set_JavaScript_onUnLoad(string value);
    public string get_HtmlStyleClass();
    public void set_HtmlStyleClass(string value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public bool IsMarginMirroring();
}
public class iTextSharp.text.DocumentException : Exception {
    public DocumentException(string message);
}
public abstract class iTextSharp.text.DocWriter : object {
    public static byte NEWLINE;
    public static byte TAB;
    public static byte LT;
    public static byte SPACE;
    public static byte EQUALS;
    public static byte QUOTE;
    public static byte GT;
    public static byte FORWARD;
    protected Rectangle pageSize;
    protected Document document;
    protected OutputStreamCounter os;
    protected bool open;
    protected bool pause;
    protected bool closeStream;
    unknown HeaderFooter Header {public set; }
    unknown HeaderFooter Footer {public set; }
    unknown int PageCount {public set; }
    public bool CloseStream { get; public set; }
    protected DocWriter(Document document, Stream os);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool NewPage();
    public virtual void set_Header(HeaderFooter value);
    public virtual void ResetHeader();
    public virtual void set_Footer(HeaderFooter value);
    public virtual void ResetFooter();
    public virtual void ResetPageCount();
    public virtual void set_PageCount(int value);
    public virtual void Close();
    public static Byte[] GetISOBytes(string text);
    public virtual void Pause();
    public bool IsPaused();
    public virtual void Resume();
    public virtual void Flush();
    protected void Write(string str);
    protected void AddTabs(int indent);
    protected void Write(string key, string value);
    protected void WriteStart(string tag);
    protected void WriteEnd(string tag);
    protected void WriteEnd();
    protected bool WriteMarkupAttributes(Properties markup);
    public virtual bool get_CloseStream();
    public virtual void set_CloseStream(bool value);
    public virtual bool SetMarginMirroring(bool marginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroring);
}
public class iTextSharp.text.Element : object {
    public static int HEADER;
    public static int TITLE;
    public static int SUBJECT;
    public static int KEYWORDS;
    public static int AUTHOR;
    public static int PRODUCER;
    public static int CREATIONDATE;
    public static int CREATOR;
    public static int CHUNK;
    public static int PHRASE;
    public static int PARAGRAPH;
    public static int SECTION;
    public static int LIST;
    public static int LISTITEM;
    public static int CHAPTER;
    public static int ANCHOR;
    public static int CELL;
    public static int ROW;
    public static int TABLE;
    public static int PTABLE;
    public static int ANNOTATION;
    public static int RECTANGLE;
    public static int JPEG;
    public static int JPEG2000;
    public static int IMGRAW;
    public static int IMGTEMPLATE;
    public static int JBIG2;
    public static int MULTI_COLUMN_TEXT;
    public static int MARKED;
    public static int YMARK;
    public static int ALIGN_UNDEFINED;
    public static int ALIGN_LEFT;
    public static int ALIGN_CENTER;
    public static int ALIGN_RIGHT;
    public static int ALIGN_JUSTIFIED;
    public static int ALIGN_TOP;
    public static int ALIGN_MIDDLE;
    public static int ALIGN_BOTTOM;
    public static int ALIGN_BASELINE;
    public static int ALIGN_JUSTIFIED_ALL;
    public static int CCITTG4;
    public static int CCITTG3_1D;
    public static int CCITTG3_2D;
    public static int CCITT_BLACKIS1;
    public static int CCITT_ENCODEDBYTEALIGN;
    public static int CCITT_ENDOFLINE;
    public static int CCITT_ENDOFBLOCK;
}
public class iTextSharp.text.ElementTags : object {
    public static string ITEXT;
    public static string TITLE;
    public static string SUBJECT;
    public static string KEYWORDS;
    public static string AUTHOR;
    public static string CREATIONDATE;
    public static string PRODUCER;
    public static string CHAPTER;
    public static string SECTION;
    public static string NUMBERDEPTH;
    public static string DEPTH;
    public static string NUMBER;
    public static string INDENT;
    public static string LEFT;
    public static string RIGHT;
    public static string PHRASE;
    public static string ANCHOR;
    public static string LIST;
    public static string LISTITEM;
    public static string PARAGRAPH;
    public static string LEADING;
    public static string ALIGN;
    public static string KEEPTOGETHER;
    public static string NAME;
    public static string REFERENCE;
    public static string LISTSYMBOL;
    public static string NUMBERED;
    public static string LETTERED;
    public static string FIRST;
    public static string SYMBOLINDENT;
    public static string INDENTATIONLEFT;
    public static string INDENTATIONRIGHT;
    public static string IGNORE;
    public static string ENTITY;
    public static string ID;
    public static string CHUNK;
    public static string ENCODING;
    public static string EMBEDDED;
    public static string COLOR;
    public static string RED;
    public static string GREEN;
    public static string BLUE;
    public static string TABLE;
    public static string ROW;
    public static string CELL;
    public static string COLUMNS;
    public static string LASTHEADERROW;
    public static string CELLPADDING;
    public static string CELLSPACING;
    public static string OFFSET;
    public static string WIDTHS;
    public static string TABLEFITSPAGE;
    public static string CELLSFITPAGE;
    public static string CONVERT2PDFP;
    public static string HORIZONTALALIGN;
    public static string VERTICALALIGN;
    public static string COLSPAN;
    public static string ROWSPAN;
    public static string HEADER;
    public static string FOOTER;
    public static string NOWRAP;
    public static string BORDERWIDTH;
    public static string TOP;
    public static string BOTTOM;
    public static string WIDTH;
    public static string BORDERCOLOR;
    public static string BACKGROUNDCOLOR;
    public static string BGRED;
    public static string BGGREEN;
    public static string BGBLUE;
    public static string GRAYFILL;
    public static string IMAGE;
    public static string BOOKMARKOPEN;
    public static string URL;
    public static string UNDERLYING;
    public static string TEXTWRAP;
    public static string ALT;
    public static string ABSOLUTEX;
    public static string ABSOLUTEY;
    public static string PLAINWIDTH;
    public static string PLAINHEIGHT;
    public static string SCALEDWIDTH;
    public static string SCALEDHEIGHT;
    public static string ROTATION;
    public static string NEWPAGE;
    public static string NEWLINE;
    public static string ANNOTATION;
    public static string FILE;
    public static string DESTINATION;
    public static string PAGE;
    public static string NAMED;
    public static string APPLICATION;
    public static string PARAMETERS;
    public static string OPERATION;
    public static string DEFAULTDIR;
    public static string LLX;
    public static string LLY;
    public static string URX;
    public static string URY;
    public static string CONTENT;
    public static string ALIGN_LEFT;
    public static string ALIGN_CENTER;
    public static string ALIGN_RIGHT;
    public static string ALIGN_JUSTIFIED;
    public static string ALIGN_JUSTIFIED_ALL;
    public static string ALIGN_TOP;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_BASELINE;
    public static string DEFAULT;
    public static string UNKNOWN;
    public static string FONT;
    public static string SIZE;
    public static string STYLE;
    public static string HORIZONTALRULE;
    public static string PAGE_SIZE;
    public static string ORIENTATION;
    public static string ALIGN_INDENTATION_ITEMS;
    public static string AUTO_INDENT_ITEMS;
    public static string LOWERCASE;
    public static string FACE;
    public static string SRC;
    public static string SUBSUPSCRIPT;
    public static string LOCALGOTO;
    public static string REMOTEGOTO;
    public static string LOCALDESTINATION;
    public static string GENERICTAG;
    private static ElementTags();
    public static string GetAlignment(int alignment);
    public static int AlignmentValue(string alignment);
}
public class iTextSharp.text.exceptions.BadPasswordException : IOException {
    public BadPasswordException(string message);
}
public class iTextSharp.text.exceptions.IllegalPdfSyntaxException : ArgumentException {
    public IllegalPdfSyntaxException(string message);
}
public class iTextSharp.text.exceptions.InvalidPdfException : IOException {
    public InvalidPdfException(string message);
}
public class iTextSharp.text.exceptions.UnsupportedPdfException : InvalidPdfException {
    public UnsupportedPdfException(string message);
}
public class iTextSharp.text.factories.ElementFactory : object {
    public static Chunk GetChunk(Properties attributes);
    public static Phrase GetPhrase(Properties attributes);
    public static Anchor GetAnchor(Properties attributes);
    public static Paragraph GetParagraph(Properties attributes);
    public static ListItem GetListItem(Properties attributes);
    public static List GetList(Properties attributes);
    public static Cell GetCell(Properties attributes);
    public static Table GetTable(Properties attributes);
    private static void SetRectangleProperties(Rectangle rect, Properties attributes);
    public static ChapterAutoNumber GetChapter(Properties attributes);
    public static Section GetSection(Section parent, Properties attributes);
    private static void SetSectionParameters(Section section, Properties attributes);
    public static Image GetImage(Properties attributes);
    public static Annotation GetAnnotation(Properties attributes);
}
public class iTextSharp.text.factories.GreekAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanAlphabetFactory : object {
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.factories.RomanNumberFactory : object {
    private static RomanDigit[] roman;
    private static RomanNumberFactory();
    public static string GetString(int index);
    public static string GetLowerCaseString(int index);
    public static string GetUpperCaseString(int index);
    public static string GetString(int index, bool lowercase);
}
public class iTextSharp.text.Font : object {
    public static int COURIER;
    public static int HELVETICA;
    public static int TIMES_ROMAN;
    public static int SYMBOL;
    public static int ZAPFDINGBATS;
    public static int NORMAL;
    public static int BOLD;
    public static int ITALIC;
    public static int UNDERLINE;
    public static int STRIKETHRU;
    public static int BOLDITALIC;
    public static int UNDEFINED;
    public static int DEFAULTSIZE;
    private int family;
    private float size;
    private int style;
    private Color color;
    private BaseFont baseFont;
    public int Family { get; }
    public string Familyname { get; }
    public float Size { get; public set; }
    public float CalculatedSize { get; }
    public int Style { get; }
    public int CalculatedStyle { get; }
    public Color Color { get; public set; }
    public BaseFont BaseFont { get; }
    public Font(Font other);
    public Font(int family, float size, int style, Color color);
    public Font(BaseFont bf, float size, int style, Color color);
    public Font(BaseFont bf, float size, int style);
    public Font(BaseFont bf, float size);
    public Font(BaseFont bf);
    public Font(int family, float size, int style);
    public Font(int family, float size);
    public Font(int family);
    public virtual int CompareTo(object obj);
    public int get_Family();
    public virtual string get_Familyname();
    public virtual void SetFamily(string family);
    public static int GetFamilyIndex(string family);
    public virtual float get_Size();
    public virtual void set_Size(float value);
    public float get_CalculatedSize();
    public float GetCalculatedLeading(float linespacing);
    public int get_Style();
    public int get_CalculatedStyle();
    public bool IsBold();
    public bool IsItalic();
    public bool IsUnderlined();
    public bool IsStrikethru();
    public virtual void SetStyle(string style);
    public virtual void SetStyle(int style);
    public static int GetStyleValue(string style);
    public virtual Color get_Color();
    public virtual void set_Color(Color value);
    public virtual void SetColor(int red, int green, int blue);
    public BaseFont get_BaseFont();
    public BaseFont GetCalculatedBaseFont(bool specialEncoding);
    public virtual bool IsStandardFont();
    public virtual Font Difference(Font font);
}
public class iTextSharp.text.FontFactory : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    private static FontFactoryImp fontImp;
    private static string defaultEncoding;
    private static bool defaultEmbedding;
    public static ICollection RegisteredFonts { get; }
    public static ICollection RegisteredFamilies { get; }
    public static string DefaultEncoding { get; }
    public static bool DefaultEmbedding { get; }
    public static FontFactoryImp FontImp { get; public set; }
    private static FontFactory();
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, Color color);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style, Color color, bool cached);
    public static Font GetFont(Properties attributes);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public static Font GetFont(string fontname, string encoding, bool embedded, float size);
    public static Font GetFont(string fontname, string encoding, bool embedded);
    public static Font GetFont(string fontname, string encoding, float size, int style, Color color);
    public static Font GetFont(string fontname, string encoding, float size, int style);
    public static Font GetFont(string fontname, string encoding, float size);
    public static Font GetFont(string fontname, string encoding);
    public static Font GetFont(string fontname, float size, int style, Color color);
    public static Font GetFont(string fontname, float size, Color color);
    public static Font GetFont(string fontname, float size, int style);
    public static Font GetFont(string fontname, float size);
    public static Font GetFont(string fontname);
    public void RegisterFamily(string familyName, string fullName, string path);
    public static void Register(Properties attributes);
    public static void Register(string path);
    public static void Register(string path, string alias);
    public static int RegisterDirectory(string dir);
    public static int RegisterDirectory(string dir, bool scanSubdirectories);
    public static int RegisterDirectories();
    public static ICollection get_RegisteredFonts();
    public static ICollection get_RegisteredFamilies();
    public static bool Contains(string fontname);
    public static bool IsRegistered(string fontname);
    public static string get_DefaultEncoding();
    public static bool get_DefaultEmbedding();
    public static FontFactoryImp get_FontImp();
    public static void set_FontImp(FontFactoryImp value);
}
public class iTextSharp.text.FontFactoryImp : object {
    private Properties trueTypeFonts;
    private static String[] TTFamilyOrder;
    private Hashtable fontFamilies;
    private string defaultEncoding;
    private bool defaultEmbedding;
    public ICollection RegisteredFonts { get; }
    public ICollection RegisteredFamilies { get; }
    public string DefaultEncoding { get; public set; }
    public bool DefaultEmbedding { get; public set; }
    private static FontFactoryImp();
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, Color color);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size, int style, Color color, bool cached);
    public virtual Font GetFont(Properties attributes);
    public Font GetFont(string fontname, string encoding, bool embedded, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, bool embedded, float size);
    public virtual Font GetFont(string fontname, string encoding, bool embedded);
    public virtual Font GetFont(string fontname, string encoding, float size, int style, Color color);
    public virtual Font GetFont(string fontname, string encoding, float size, int style);
    public virtual Font GetFont(string fontname, string encoding, float size);
    public virtual Font GetFont(string fontname, string encoding);
    public virtual Font GetFont(string fontname, float size, int style, Color color);
    public virtual Font GetFont(string fontname, float size, Color color);
    public virtual Font GetFont(string fontname, float size, int style);
    public virtual Font GetFont(string fontname, float size);
    public virtual Font GetFont(string fontname);
    public virtual void Register(Properties attributes);
    public void RegisterFamily(string familyName, string fullName, string path);
    public virtual void Register(string path);
    public virtual void Register(string path, string alias);
    public virtual int RegisterDirectory(string dir);
    public int RegisterDirectory(string dir, bool scanSubdirectories);
    public virtual int RegisterDirectories();
    public virtual ICollection get_RegisteredFonts();
    public virtual ICollection get_RegisteredFamilies();
    public virtual bool IsRegistered(string fontname);
    public virtual string get_DefaultEncoding();
    public virtual void set_DefaultEncoding(string value);
    public virtual bool get_DefaultEmbedding();
    public virtual void set_DefaultEmbedding(bool value);
}
public class iTextSharp.text.GreekList : List {
    public GreekList(int symbolIndent);
    public GreekList(bool greeklower, int symbolIndent);
    protected void SetGreekFont();
    public virtual bool Add(object o);
}
public class iTextSharp.text.Header : Meta {
    private StringBuilder name;
    public string Name { get; }
    public Header(string name, string content);
    public virtual string get_Name();
}
public class iTextSharp.text.HeaderFooter : Rectangle {
    private bool numbered;
    private Phrase before;
    private int pageN;
    private Phrase after;
    private int alignment;
    public Phrase Before { get; public set; }
    public Phrase After { get; public set; }
    unknown int PageNumber {public set; }
    public int Alignment { get; public set; }
    public Paragraph Paragraph { get; }
    public HeaderFooter(Phrase before, Phrase after);
    public HeaderFooter(Phrase before, bool numbered);
    public HeaderFooter(Properties attributes);
    public bool IsNumbered();
    public Phrase get_Before();
    public void set_Before(Phrase value);
    public Phrase get_After();
    public void set_After(Phrase value);
    public void set_PageNumber(int value);
    public void set_Alignment(int value);
    public int get_Alignment();
    public void SetAlignment(string alignment);
    public Paragraph get_Paragraph();
}
public class iTextSharp.text.html.HtmlEncoder : object {
    private static String[] htmlCode;
    private static HtmlEncoder();
    public static string Encode(string str);
    public static string Encode(Color color);
    public static string GetAlignment(int alignment);
}
public class iTextSharp.text.html.HtmlParser : XmlParser {
    public virtual void Go(IDocListener document, XmlDocument xDoc);
    public virtual void Go(IDocListener document, string file);
    public virtual void Go(IDocListener document, XmlTextReader reader);
    public virtual void Go(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public virtual void Go(IDocListener document, XmlTextReader reader, string tagmap);
    public virtual void Go(IDocListener document, string file, string tagmap);
    public virtual void Go(IDocListener document, string file, Hashtable tagmap);
    public virtual void Go(IDocListener document, XmlTextReader reader, Hashtable tagmap);
    public static void Parse(IDocListener document, XmlDocument xDoc);
    public static void Parse(IDocListener document, string file);
    public static void Parse(IDocListener document, XmlTextReader reader);
    public static void Parse(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public static void Parse(IDocListener document, string file, string tagmap);
    public static void Parse(IDocListener document, string file, Hashtable tagmap);
    public static void Parse(IDocListener document, XmlTextReader reader, string tagmap);
    public static void Parse(IDocListener document, XmlTextReader reader, Hashtable tagmap);
}
public class iTextSharp.text.html.HtmlPeer : XmlPeer {
    public HtmlPeer(string name, string alias);
    public virtual void AddAlias(string name, string alias);
    public virtual Properties GetAttributes(Hashtable attrs);
}
public class iTextSharp.text.html.HtmlTagMap : Hashtable {
    public static bool IsHtml(string tag);
    public static bool IsHead(string tag);
    public static bool IsMeta(string tag);
    public static bool IsLink(string tag);
    public static bool IsTitle(string tag);
    public static bool IsBody(string tag);
    public static bool IsSpecialTag(string tag);
}
public class iTextSharp.text.html.HtmlTags : object {
    public static string HTML;
    public static string HEAD;
    public static string CONTENT;
    public static string META;
    public static string SUBJECT;
    public static string KEYWORDS;
    public static string AUTHOR;
    public static string TITLE;
    public static string SCRIPT;
    public static string LANGUAGE;
    public static string JAVASCRIPT;
    public static string BODY;
    public static string JAVASCRIPT_ONLOAD;
    public static string JAVASCRIPT_ONUNLOAD;
    public static string TOPMARGIN;
    public static string BOTTOMMARGIN;
    public static string LEFTMARGIN;
    public static string RIGHTMARGIN;
    public static string CHUNK;
    public static string CODE;
    public static string VAR;
    public static string ANCHOR;
    public static string ORDEREDLIST;
    public static string UNORDEREDLIST;
    public static string LISTITEM;
    public static string PARAGRAPH;
    public static string NAME;
    public static string REFERENCE;
    public static string FONT;
    public static string SIZE;
    public static string COLOR;
    public static string EM;
    public static string I;
    public static string STRONG;
    public static string B;
    public static string S;
    public static string U;
    public static string SUB;
    public static string SUP;
    public static string HORIZONTALRULE;
    public static string TABLE;
    public static string ROW;
    public static string CELL;
    public static string HEADERCELL;
    public static string COLUMNS;
    public static string CELLPADDING;
    public static string CELLSPACING;
    public static string COLSPAN;
    public static string ROWSPAN;
    public static string NOWRAP;
    public static string BORDERWIDTH;
    public static string WIDTH;
    public static string BACKGROUNDCOLOR;
    public static string BORDERCOLOR;
    public static string ALIGN;
    public static string LEFT;
    public static string RIGHT;
    public static string HORIZONTALALIGN;
    public static string VERTICALALIGN;
    public static string TOP;
    public static string BOTTOM;
    public static string IMAGE;
    public static string URL;
    public static string ALT;
    public static string PLAINWIDTH;
    public static string PLAINHEIGHT;
    public static string NEWLINE;
    public static string ALIGN_LEFT;
    public static string ALIGN_CENTER;
    public static string ALIGN_RIGHT;
    public static string ALIGN_JUSTIFIED;
    public static string ALIGN_TOP;
    public static string ALIGN_MIDDLE;
    public static string ALIGN_BOTTOM;
    public static string ALIGN_BASELINE;
    public static string DEFAULT;
    public static string DIV;
    public static string SPAN;
    public static string LINK;
    public static string TEXT_CSS;
    public static string REL;
    public static string STYLE;
    public static string TYPE;
    public static string STYLESHEET;
    public static string PRE;
    public static String[] H;
    private static HtmlTags();
}
public class iTextSharp.text.html.HtmlWriter : DocWriter {
    public static string NBSP;
    public static Byte[] BEGINCOMMENT;
    public static Byte[] ENDCOMMENT;
    protected Stack currentfont;
    protected Font standardfont;
    protected string imagepath;
    protected int pageN;
    protected HeaderFooter header;
    protected HeaderFooter footer;
    protected Properties markup;
    protected HtmlWriter(Document doc, Stream os);
    private static HtmlWriter();
    public static HtmlWriter GetInstance(Document document, Stream os);
    public virtual bool NewPage();
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void Close();
    protected void InitHeader();
    protected void InitFooter();
    protected void WriteHeader(Meta meta);
    protected void WriteLink(Header header);
    protected void WriteJavaScript(Header header);
    protected void WriteComment(string comment);
    public void SetStandardFont(Font standardFont);
    public bool IsOtherFont(Font font);
    public void SetImagepath(string imagepath);
    public void ResetImagepath();
    public void SetHeader(HeaderFooter header);
    public void SetFooter(HeaderFooter footer);
    public bool Add(string str);
    protected void Write(IElement element, int indent);
    protected void WriteSection(Section section, int indent);
    protected void Write(Font font, Properties styleAttributes);
    protected void WriteCssProperty(string prop, string value);
}
public class iTextSharp.text.html.ITextmyHtmlHandler : ITextHandler {
    private Properties bodyAttributes;
    private bool tableBorder;
    public ITextmyHtmlHandler(IDocListener document);
    public ITextmyHtmlHandler(IDocListener document, BaseFont bf);
    public ITextmyHtmlHandler(IDocListener document, Hashtable htmlTags);
    public virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public virtual void EndElement(string uri, string lname, string name);
}
public class iTextSharp.text.html.Markup : object {
    public static string ITEXT_TAG;
    public static string HTML_TAG_BODY;
    public static string HTML_TAG_DIV;
    public static string HTML_TAG_LINK;
    public static string HTML_TAG_SPAN;
    public static string HTML_ATTR_HEIGHT;
    public static string HTML_ATTR_HREF;
    public static string HTML_ATTR_REL;
    public static string HTML_ATTR_STYLE;
    public static string HTML_ATTR_TYPE;
    public static string HTML_ATTR_STYLESHEET;
    public static string HTML_ATTR_WIDTH;
    public static string HTML_ATTR_CSS_CLASS;
    public static string HTML_ATTR_CSS_ID;
    public static string HTML_VALUE_JAVASCRIPT;
    public static string HTML_VALUE_CSS;
    public static string CSS_KEY_BGCOLOR;
    public static string CSS_KEY_COLOR;
    public static string CSS_KEY_DISPLAY;
    public static string CSS_KEY_FONTFAMILY;
    public static string CSS_KEY_FONTSIZE;
    public static string CSS_KEY_FONTSTYLE;
    public static string CSS_KEY_FONTWEIGHT;
    public static string CSS_KEY_LINEHEIGHT;
    public static string CSS_KEY_MARGIN;
    public static string CSS_KEY_MARGINLEFT;
    public static string CSS_KEY_MARGINRIGHT;
    public static string CSS_KEY_MARGINTOP;
    public static string CSS_KEY_MARGINBOTTOM;
    public static string CSS_KEY_PADDING;
    public static string CSS_KEY_PADDINGLEFT;
    public static string CSS_KEY_PADDINGRIGHT;
    public static string CSS_KEY_PADDINGTOP;
    public static string CSS_KEY_PADDINGBOTTOM;
    public static string CSS_KEY_BORDERCOLOR;
    public static string CSS_KEY_BORDERWIDTH;
    public static string CSS_KEY_BORDERWIDTHLEFT;
    public static string CSS_KEY_BORDERWIDTHRIGHT;
    public static string CSS_KEY_BORDERWIDTHTOP;
    public static string CSS_KEY_BORDERWIDTHBOTTOM;
    public static string CSS_KEY_PAGE_BREAK_AFTER;
    public static string CSS_KEY_PAGE_BREAK_BEFORE;
    public static string CSS_KEY_TEXTALIGN;
    public static string CSS_KEY_TEXTDECORATION;
    public static string CSS_KEY_VERTICALALIGN;
    public static string CSS_KEY_VISIBILITY;
    public static string CSS_VALUE_ALWAYS;
    public static string CSS_VALUE_BLOCK;
    public static string CSS_VALUE_BOLD;
    public static string CSS_VALUE_HIDDEN;
    public static string CSS_VALUE_INLINE;
    public static string CSS_VALUE_ITALIC;
    public static string CSS_VALUE_LINETHROUGH;
    public static string CSS_VALUE_LISTITEM;
    public static string CSS_VALUE_NONE;
    public static string CSS_VALUE_NORMAL;
    public static string CSS_VALUE_OBLIQUE;
    public static string CSS_VALUE_TABLE;
    public static string CSS_VALUE_TABLEROW;
    public static string CSS_VALUE_TABLECELL;
    public static string CSS_VALUE_TEXTALIGNLEFT;
    public static string CSS_VALUE_TEXTALIGNRIGHT;
    public static string CSS_VALUE_TEXTALIGNCENTER;
    public static string CSS_VALUE_TEXTALIGNJUSTIFY;
    public static string CSS_VALUE_UNDERLINE;
    public static float DEFAULT_FONT_SIZE;
    public static float ParseLength(string str);
    public static float ParseLength(string str, float actualFontSize);
    public static Color DecodeColor(string s);
    public static Properties ParseAttributes(string str);
    public static string RemoveComment(string str, string startComment, string endComment);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.html.simpleparser.ChainedProperties : object {
    public static Int32[] fontSizes;
    public ArrayList chain;
    public string Item { get; }
    private static ChainedProperties();
    public string get_Item(string key);
    public bool HasProperty(string key);
    public void AddToChain(string key, Hashtable prop);
    public void RemoveChain(string key);
}
public class iTextSharp.text.html.simpleparser.FactoryProperties : object {
    private FontFactoryImp fontImp;
    public static Hashtable followTags;
    public FontFactoryImp FontImp { get; public set; }
    private static FactoryProperties();
    public Chunk CreateChunk(string text, ChainedProperties props);
    private static void SetParagraphLeading(Paragraph p, string leading);
    public static void CreateParagraph(Paragraph p, ChainedProperties props);
    public static Paragraph CreateParagraph(ChainedProperties props);
    public static ListItem CreateListItem(ChainedProperties props);
    public Font GetFont(ChainedProperties props);
    public static IHyphenationEvent GetHyphenation(ChainedProperties props);
    public static IHyphenationEvent GetHyphenation(Hashtable props);
    public static IHyphenationEvent GetHyphenation(string s);
    public static void InsertStyle(Hashtable h);
    public static void InsertStyle(Hashtable h, ChainedProperties cprops);
    public FontFactoryImp get_FontImp();
    public void set_FontImp(FontFactoryImp value);
}
public class iTextSharp.text.html.simpleparser.HTMLWorker : object {
    public static string tagsSupportedString;
    protected ArrayList objectList;
    protected IDocListener document;
    private Paragraph currentParagraph;
    private ChainedProperties cprops;
    private Stack stack;
    private bool pendingTR;
    private bool pendingTD;
    private bool pendingLI;
    private StyleSheet style;
    private bool isPRE;
    private Stack tableState;
    private bool skipText;
    private Hashtable interfaceProps;
    private FactoryProperties factoryProperties;
    public static Hashtable tagsSupported;
    public StyleSheet Style { get; public set; }
    public Hashtable InterfaceProps { get; public set; }
    unknown HeaderFooter Footer {public set; }
    unknown HeaderFooter Header {public set; }
    unknown int PageCount {public set; }
    public HTMLWorker(IDocListener document);
    private static HTMLWorker();
    public void set_Style(StyleSheet value);
    public StyleSheet get_Style();
    public void set_InterfaceProps(Hashtable value);
    public Hashtable get_InterfaceProps();
    public void Parse(TextReader reader);
    public static ArrayList ParseToList(TextReader reader, StyleSheet style);
    public static ArrayList ParseToList(TextReader reader, StyleSheet style, Hashtable interfaceProps);
    public virtual void EndDocument();
    public virtual void StartDocument();
    public virtual void StartElement(string tag, Hashtable h);
    public virtual void EndElement(string tag);
    public virtual void Text(string str);
    public sealed virtual bool Add(IElement element);
    public void ClearTextWrap();
    public sealed virtual void Close();
    public sealed virtual bool NewPage();
    public sealed virtual void Open();
    public sealed virtual void ResetFooter();
    public sealed virtual void ResetHeader();
    public sealed virtual void ResetPageCount();
    public sealed virtual bool SetMarginMirroring(bool marginMirroring);
    public sealed virtual bool SetMarginMirroringTopBottom(bool marginMirroring);
    public sealed virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public sealed virtual bool SetPageSize(Rectangle pageSize);
    public sealed virtual void set_Footer(HeaderFooter value);
    public sealed virtual void set_Header(HeaderFooter value);
    public sealed virtual void set_PageCount(int value);
}
public interface iTextSharp.text.html.simpleparser.IALink {
    public abstract virtual bool Process(Paragraph current, ChainedProperties cprops);
}
public interface iTextSharp.text.html.simpleparser.IImageProvider {
    public abstract virtual Image GetImage(string src, Hashtable h, ChainedProperties cprops, IDocListener doc);
}
public interface iTextSharp.text.html.simpleparser.IImg {
    public abstract virtual bool Process(Image img, Hashtable h, ChainedProperties cprops, IDocListener doc);
}
public class iTextSharp.text.html.simpleparser.IncCell : object {
    private ArrayList chunks;
    private PdfPCell cell;
    public ArrayList Chunks { get; }
    public int Type { get; }
    public PdfPCell Cell { get; }
    public IncCell(string tag, ChainedProperties props);
    public sealed virtual bool Add(object o);
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public PdfPCell get_Cell();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual string ToString();
}
public class iTextSharp.text.html.simpleparser.IncTable : object {
    private Hashtable props;
    private ArrayList rows;
    private ArrayList cols;
    public ArrayList Rows { get; }
    public IncTable(Hashtable props);
    public void AddCol(PdfPCell cell);
    public void AddCols(ArrayList ncols);
    public void EndRow();
    public ArrayList get_Rows();
    public PdfPTable BuildTable();
}
public class iTextSharp.text.html.simpleparser.StyleSheet : object {
    public Hashtable classMap;
    public Hashtable tagMap;
    public void ApplyStyle(string tag, Hashtable props);
    private void ApplyMap(Hashtable map, Hashtable props);
    public void LoadStyle(string style, Hashtable props);
    public void LoadStyle(string style, string key, string value);
    public void LoadTagStyle(string tag, Hashtable props);
    public void LoadTagStyle(string tag, string key, string value);
}
public class iTextSharp.text.html.WebColors : Hashtable {
    public static WebColors NAMES;
    private static WebColors();
    public static Color GetRGBColor(string name);
}
public interface iTextSharp.text.IDocListener {
    unknown int PageCount {public set; }
    unknown HeaderFooter Header {public set; }
    unknown HeaderFooter Footer {public set; }
    public abstract virtual void Open();
    public abstract virtual void Close();
    public abstract virtual bool NewPage();
    public abstract virtual bool SetPageSize(Rectangle pageSize);
    public abstract virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public abstract virtual bool SetMarginMirroring(bool marginMirroring);
    public abstract virtual bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom);
    public abstract virtual void set_PageCount(int value);
    public abstract virtual void ResetPageCount();
    public abstract virtual void set_Header(HeaderFooter value);
    public abstract virtual void ResetHeader();
    public abstract virtual void set_Footer(HeaderFooter value);
    public abstract virtual void ResetFooter();
}
public interface iTextSharp.text.IElement {
    public int Type { get; }
    public ArrayList Chunks { get; }
    public abstract virtual bool Process(IElementListener listener);
    public abstract virtual int get_Type();
    public abstract virtual bool IsContent();
    public abstract virtual bool IsNestable();
    public abstract virtual ArrayList get_Chunks();
    public abstract virtual string ToString();
}
public interface iTextSharp.text.IElementListener {
    public abstract virtual bool Add(IElement element);
}
public interface iTextSharp.text.ILargeElement {
    public bool ElementComplete { get; public set; }
    public abstract virtual bool get_ElementComplete();
    public abstract virtual void set_ElementComplete(bool value);
    public abstract virtual void FlushContent();
}
public abstract class iTextSharp.text.Image : Rectangle {
    public static int DEFAULT;
    public static int RIGHT_ALIGN;
    public static int LEFT_ALIGN;
    public static int MIDDLE_ALIGN;
    public static int TEXTWRAP;
    public static int UNDERLYING;
    public static int AX;
    public static int AY;
    public static int BX;
    public static int BY;
    public static int CX;
    public static int CY;
    public static int DX;
    public static int DY;
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_JPEG;
    public static int ORIGINAL_PNG;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_BMP;
    public static int ORIGINAL_TIFF;
    public static int ORIGINAL_WMF;
    public static int ORIGINAL_JPEG2000;
    public static int ORIGINAL_JBIG2;
    protected bool invert;
    protected int type;
    protected Uri url;
    protected Byte[] rawData;
    protected PdfTemplate[] template;
    protected int alignment;
    protected string alt;
    protected float absoluteX;
    protected float absoluteY;
    protected float plainWidth;
    protected float plainHeight;
    protected float scaledWidth;
    protected float scaledHeight;
    protected int compressionLevel;
    protected float rotationRadians;
    protected int colorspace;
    protected int bpc;
    protected Int32[] transparency;
    protected float indentationLeft;
    protected float indentationRight;
    protected long mySerialId;
    private static object serialId;
    protected int dpiX;
    protected int dpiY;
    protected bool mask;
    protected Image imageMask;
    protected bool interpolation;
    protected Annotation annotation;
    protected ICC_Profile profile;
    protected bool deflated;
    private PdfDictionary additional;
    private bool smask;
    private float xyRatio;
    protected int originalType;
    protected Byte[] originalData;
    protected float spacingBefore;
    protected float spacingAfter;
    private float widthPercentage;
    protected IPdfOCG layer;
    private float initialRotation;
    private PdfIndirectReference directReference;
    unknown float Rotation {public set; }
    unknown float RotationDegrees {public set; }
    public Annotation Annotation { get; public set; }
    public int Bpc { get; }
    public Byte[] RawData { get; }
    public PdfTemplate TemplateData { get; public set; }
    public float AbsoluteX { get; }
    public float AbsoluteY { get; }
    public int Type { get; }
    public Uri Url { get; public set; }
    public int Alignment { get; public set; }
    public string Alt { get; public set; }
    public float ScaledWidth { get; }
    public float ScaledHeight { get; }
    public int Colorspace { get; }
    public Single[] Matrix { get; }
    public Int32[] Transparency { get; public set; }
    public float PlainWidth { get; }
    public float PlainHeight { get; }
    public long MySerialId { get; }
    public int DpiX { get; }
    public int DpiY { get; }
    public Image ImageMask { get; public set; }
    public bool Inverted { get; public set; }
    public bool Interpolation { get; public set; }
    public ICC_Profile TagICC { get; public set; }
    public bool Deflated { get; public set; }
    public PdfDictionary Additional { get; public set; }
    public bool Smask { get; public set; }
    public float XYRatio { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public int OriginalType { get; public set; }
    public Byte[] OriginalData { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public float WidthPercentage { get; public set; }
    public IPdfOCG Layer { get; public set; }
    public float InitialRotation { get; public set; }
    public PdfIndirectReference DirectReference { get; public set; }
    public int CompressionLevel { get; public set; }
    public Image(Uri url);
    public Image(Image image);
    private static Image();
    public static Image GetInstance(Image image);
    public static Image GetInstance(Uri url);
    public static Image GetInstance(Stream s);
    public static Image GetInstance(int width, int height, Byte[] data, Byte[] globals);
    public static Image GetInstance(Byte[] imgb);
    public static Image GetInstance(Image image, ImageFormat format);
    public static Image GetInstance(Image image, Color color, bool forceBW);
    public static Image GetInstance(Image image, Color color);
    public static Image GetInstance(string filename);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data);
    public static Image GetInstance(PRIndirectReference iref);
    public static Image GetInstance(PdfTemplate template);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
    public static Image GetInstance(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data, Int32[] transparency);
    public static Image GetInstance(int width, int height, int components, int bpc, Byte[] data, Int32[] transparency);
    public void SetAbsolutePosition(float absoluteX, float absoluteY);
    public void ScaleAbsolute(float newWidth, float newHeight);
    public void ScaleAbsoluteWidth(float newWidth);
    public void ScaleAbsoluteHeight(float newHeight);
    public void ScalePercent(float percent);
    public void ScalePercent(float percentX, float percentY);
    public void ScaleToFit(float fitWidth, float fitHeight);
    public float GetImageRotation();
    public void set_Rotation(float value);
    public void set_RotationDegrees(float value);
    public Annotation get_Annotation();
    public void set_Annotation(Annotation value);
    public int get_Bpc();
    public Byte[] get_RawData();
    public PdfTemplate get_TemplateData();
    public void set_TemplateData(PdfTemplate value);
    public bool HasAbsolutePosition();
    public bool HasAbsoluteX();
    public float get_AbsoluteX();
    public float get_AbsoluteY();
    public virtual int get_Type();
    public virtual bool IsNestable();
    public bool IsJpeg();
    public bool IsImgRaw();
    public bool IsImgTemplate();
    public Uri get_Url();
    public void set_Url(Uri value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public string get_Alt();
    public void set_Alt(string value);
    public float get_ScaledWidth();
    public float get_ScaledHeight();
    public int get_Colorspace();
    public Single[] get_Matrix();
    public Int32[] get_Transparency();
    public void set_Transparency(Int32[] value);
    public float get_PlainWidth();
    public float get_PlainHeight();
    protected static long GetSerialId();
    public long get_MySerialId();
    public int get_DpiX();
    public int get_DpiY();
    public void SetDpi(int dpiX, int dpiY);
    public bool IsMaskCandidate();
    public void MakeMask();
    public Image get_ImageMask();
    public void set_ImageMask(Image value);
    public bool IsMask();
    public void set_Inverted(bool value);
    public bool get_Inverted();
    public void set_Interpolation(bool value);
    public bool get_Interpolation();
    public ICC_Profile get_TagICC();
    public void set_TagICC(ICC_Profile value);
    public bool HasICCProfile();
    public bool get_Deflated();
    public void set_Deflated(bool value);
    public PdfDictionary get_Additional();
    public void set_Additional(PdfDictionary value);
    public bool get_Smask();
    public void set_Smask(bool value);
    public float get_XYRatio();
    public void set_XYRatio(float value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public int get_OriginalType();
    public void set_OriginalType(int value);
    public Byte[] get_OriginalData();
    public void set_OriginalData(Byte[] value);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public float get_WidthPercentage();
    public void set_WidthPercentage(float value);
    public IPdfOCG get_Layer();
    public void set_Layer(IPdfOCG value);
    private PdfObject SimplifyColorspace(PdfArray obj);
    public void SimplifyColorspace();
    public float get_InitialRotation();
    public void set_InitialRotation(float value);
    public void set_DirectReference(PdfIndirectReference value);
    public PdfIndirectReference get_DirectReference();
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
}
public class iTextSharp.text.ImgCCITT : Image {
    public ImgCCITT(Image image);
    public ImgCCITT(int width, int height, bool reverseBits, int typeCCITT, int parameters, Byte[] data);
}
public class iTextSharp.text.ImgJBIG2 : Image {
    private Byte[] global;
    private Byte[] globalHash;
    public Byte[] GlobalBytes { get; }
    public Byte[] GlobalHash { get; }
    private ImgJBIG2(Image image);
    public ImgJBIG2(int width, int height, Byte[] data, Byte[] globals);
    public Byte[] get_GlobalBytes();
    public Byte[] get_GlobalHash();
}
public class iTextSharp.text.ImgRaw : Image {
    public ImgRaw(Image image);
    public ImgRaw(int width, int height, int components, int bpc, Byte[] data);
}
public class iTextSharp.text.ImgTemplate : Image {
    public ImgTemplate(Image image);
    public ImgTemplate(PdfTemplate template);
}
public class iTextSharp.text.ImgWMF : Image {
    public ImgWMF(Image image);
    public ImgWMF(Uri url);
    public ImgWMF(string filename);
    public ImgWMF(Byte[] img);
    private void ProcessParameters();
    public void ReadWMF(PdfTemplate template);
}
public interface iTextSharp.text.IRtfElementInterface {
}
public interface iTextSharp.text.ISplitCharacter {
    public abstract virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
}
public interface iTextSharp.text.ITextElementArray {
    public abstract virtual bool Add(object o);
}
public class iTextSharp.text.Jpeg : Image {
    public static int NOT_A_MARKER;
    public static int VALID_MARKER;
    public static int UNSUPPORTED_MARKER;
    public static int NOPARAM_MARKER;
    public static int M_APP0;
    public static int M_APP2;
    public static int M_APPE;
    public static Int32[] VALID_MARKERS;
    public static Int32[] UNSUPPORTED_MARKERS;
    public static Int32[] NOPARAM_MARKERS;
    public static Byte[] JFIF_ID;
    private Byte[][] icc;
    public Jpeg(Image image);
    public Jpeg(Uri Uri);
    public Jpeg(Byte[] img);
    public Jpeg(Byte[] img, float width, float height);
    private static Jpeg();
    private static int GetShort(Stream istr);
    private static int GetShortInverted(Stream istr);
    private static int MarkerType(int marker);
    private void ProcessParameters();
}
public class iTextSharp.text.Jpeg2000 : Image {
    public static int JP2_JP;
    public static int JP2_IHDR;
    public static int JPIP_JPIP;
    public static int JP2_FTYP;
    public static int JP2_JP2H;
    public static int JP2_COLR;
    public static int JP2_JP2C;
    public static int JP2_URL;
    public static int JP2_DBTL;
    public static int JP2_BPCC;
    public static int JP2_JP2;
    private Stream inp;
    private int boxLength;
    private int boxType;
    public Jpeg2000(Image image);
    public Jpeg2000(Uri url);
    public Jpeg2000(Byte[] img);
    public Jpeg2000(Byte[] img, float width, float height);
    private int Cio_read(int n);
    public void Jp2_read_boxhdr();
    private void ProcessParameters();
}
public class iTextSharp.text.List : object {
    public static bool ORDERED;
    public static bool UNORDERED;
    public static bool NUMERICAL;
    public static bool ALPHABETICAL;
    public static bool UPPERCASE;
    public static bool LOWERCASE;
    protected ArrayList list;
    protected bool numbered;
    protected bool lettered;
    protected bool lowercase;
    protected bool autoindent;
    protected bool alignindent;
    protected int first;
    protected Chunk symbol;
    protected string preSymbol;
    protected string postSymbol;
    protected float indentationLeft;
    protected float indentationRight;
    protected float symbolIndent;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public bool Numbered { get; public set; }
    public bool Lettered { get; public set; }
    public bool Lowercase { get; public set; }
    public bool Autoindent { get; public set; }
    public bool Alignindent { get; public set; }
    public int First { get; public set; }
    unknown Chunk ListSymbol {public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SymbolIndent { get; public set; }
    public ArrayList Items { get; }
    public int Size { get; }
    public float TotalLeading { get; }
    public Chunk Symbol { get; public set; }
    public string PostSymbol { get; public set; }
    public string PreSymbol { get; public set; }
    public List(float symbolIndent);
    public List(bool numbered);
    public List(bool numbered, bool lettered);
    public List(bool numbered, float symbolIndent);
    public List(bool numbered, bool lettered, float symbolIndent);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public virtual bool Add(object o);
    public void NormalizeIndentation();
    public void set_Numbered(bool value);
    public bool get_Numbered();
    public void set_Lettered(bool value);
    public bool get_Lettered();
    public void set_Lowercase(bool value);
    public bool get_Lowercase();
    public void set_Autoindent(bool value);
    public bool get_Autoindent();
    public void set_Alignindent(bool value);
    public bool get_Alignindent();
    public int get_First();
    public void set_First(int value);
    public void set_ListSymbol(Chunk value);
    public void SetListSymbol(string symbol);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public void set_SymbolIndent(float value);
    public float get_SymbolIndent();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public ArrayList get_Items();
    public int get_Size();
    public virtual bool IsEmpty();
    public float get_TotalLeading();
    public Chunk get_Symbol();
    public void set_Symbol(Chunk value);
    public string getPostSymbol();
    public void set_PostSymbol(string value);
    public string get_PostSymbol();
    public void set_PreSymbol(string value);
    public string get_PreSymbol();
}
public class iTextSharp.text.ListItem : Paragraph {
    private Chunk symbol;
    public int Type { get; }
    public Chunk ListSymbol { get; public set; }
    public ListItem(float leading);
    public ListItem(Chunk chunk);
    public ListItem(string str);
    public ListItem(string str, Font font);
    public ListItem(float leading, Chunk chunk);
    public ListItem(float leading, string str);
    public ListItem(float leading, string str, Font font);
    public ListItem(Phrase phrase);
    public virtual int get_Type();
    public Chunk get_ListSymbol();
    public void set_ListSymbol(Chunk value);
    public static bool IsTag(string tag);
    public void SetIndentationLeft(float indentation, bool autoindent);
}
public class iTextSharp.text.MarkedObject : object {
    protected internal IElement element;
    protected internal Properties markupAttributes;
    public ArrayList Chunks { get; }
    public int Type { get; }
    public Properties MarkupAttributes { get; }
    public MarkedObject(IElement element);
    public virtual ArrayList get_Chunks();
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual Properties get_MarkupAttributes();
    public virtual void SetMarkupAttribute(string key, string value);
}
public class iTextSharp.text.MarkedSection : MarkedObject {
    protected MarkedObject title;
    public MarkedObject Title { get; public set; }
    unknown int NumberDepth {public set; }
    unknown float IndentationLeft {public set; }
    unknown float IndentationRight {public set; }
    unknown float Indentation {public set; }
    unknown bool BookmarkOpen {public set; }
    unknown bool TriggerNewPage {public set; }
    unknown string BookmarkTitle {public set; }
    public MarkedSection(Section section);
    public void Add(int index, object o);
    public bool Add(object o);
    public virtual bool Process(IElementListener listener);
    public bool AddAll(ICollection collection);
    public MarkedSection AddSection(float indentation, int numberDepth);
    public MarkedSection AddSection(float indentation);
    public MarkedSection AddSection(int numberDepth);
    public MarkedSection AddSection();
    public void set_Title(MarkedObject value);
    public MarkedObject get_Title();
    public void set_NumberDepth(int value);
    public void set_IndentationLeft(float value);
    public void set_IndentationRight(float value);
    public void set_Indentation(float value);
    public void set_BookmarkOpen(bool value);
    public void set_TriggerNewPage(bool value);
    public void set_BookmarkTitle(string value);
    public void NewPage();
}
public class iTextSharp.text.Meta : object {
    private int type;
    private StringBuilder content;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public string Content { get; }
    public string Name { get; }
    public Meta(int type, string content);
    public Meta(string tag, string content);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public StringBuilder Append(string str);
    public string get_Content();
    public virtual string get_Name();
    public static int GetType(string tag);
    public virtual string ToString();
}
public class iTextSharp.text.PageSize : object {
    public static Rectangle LETTER;
    public static Rectangle NOTE;
    public static Rectangle LEGAL;
    public static Rectangle TABLOID;
    public static Rectangle EXECUTIVE;
    public static Rectangle POSTCARD;
    public static Rectangle A0;
    public static Rectangle A1;
    public static Rectangle A2;
    public static Rectangle A3;
    public static Rectangle A4;
    public static Rectangle A5;
    public static Rectangle A6;
    public static Rectangle A7;
    public static Rectangle A8;
    public static Rectangle A9;
    public static Rectangle A10;
    public static Rectangle B0;
    public static Rectangle B1;
    public static Rectangle B2;
    public static Rectangle B3;
    public static Rectangle B4;
    public static Rectangle B5;
    public static Rectangle B6;
    public static Rectangle B7;
    public static Rectangle B8;
    public static Rectangle B9;
    public static Rectangle B10;
    public static Rectangle ARCH_E;
    public static Rectangle ARCH_D;
    public static Rectangle ARCH_C;
    public static Rectangle ARCH_B;
    public static Rectangle ARCH_A;
    public static Rectangle FLSA;
    public static Rectangle FLSE;
    public static Rectangle HALFLETTER;
    public static Rectangle _11X17;
    public static Rectangle ID_1;
    public static Rectangle ID_2;
    public static Rectangle ID_3;
    public static Rectangle LEDGER;
    public static Rectangle CROWN_QUARTO;
    public static Rectangle LARGE_CROWN_QUARTO;
    public static Rectangle DEMY_QUARTO;
    public static Rectangle ROYAL_QUARTO;
    public static Rectangle CROWN_OCTAVO;
    public static Rectangle LARGE_CROWN_OCTAVO;
    public static Rectangle DEMY_OCTAVO;
    public static Rectangle ROYAL_OCTAVO;
    public static Rectangle SMALL_PAPERBACK;
    public static Rectangle PENGUIN_SMALL_PAPERBACK;
    public static Rectangle PENGUIN_LARGE_PAPERBACK;
    private static PageSize();
    public static Rectangle GetRectangle(string name);
}
public class iTextSharp.text.Paragraph : Phrase {
    protected int alignment;
    protected float multipliedLeading;
    protected float indentationLeft;
    protected float indentationRight;
    private float firstLineIndent;
    protected float spacingBefore;
    protected float spacingAfter;
    private float extraParagraphSpace;
    protected bool keeptogether;
    public int Type { get; }
    unknown float Leading {public set; }
    public float MultipliedLeading { get; public set; }
    public int Alignment { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public bool KeepTogether { get; public set; }
    public float TotalLeading { get; }
    public float FirstLineIndent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public Paragraph(float leading);
    public Paragraph(Chunk chunk);
    public Paragraph(float leading, Chunk chunk);
    public Paragraph(string str);
    public Paragraph(string str, Font font);
    public Paragraph(float leading, string str);
    public Paragraph(float leading, string str, Font font);
    public Paragraph(Phrase phrase);
    public virtual int get_Type();
    public virtual bool Add(object o);
    public void SetAlignment(string alignment);
    public virtual void set_Leading(float value);
    public void SetLeading(float fixedLeading, float multipliedLeading);
    public float get_MultipliedLeading();
    public void set_MultipliedLeading(float value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public static bool IsTag(string tag);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public bool get_KeepTogether();
    public void set_KeepTogether(bool value);
    public float get_TotalLeading();
    public float get_FirstLineIndent();
    public void set_FirstLineIndent(float value);
    public float get_ExtraParagraphSpace();
    public void set_ExtraParagraphSpace(float value);
}
public class iTextSharp.text.pdf.AcroFields : object {
    public static int DA_FONT;
    public static int DA_SIZE;
    public static int DA_COLOR;
    public static int FIELD_TYPE_NONE;
    public static int FIELD_TYPE_PUSHBUTTON;
    public static int FIELD_TYPE_CHECKBOX;
    public static int FIELD_TYPE_RADIOBUTTON;
    public static int FIELD_TYPE_TEXT;
    public static int FIELD_TYPE_LIST;
    public static int FIELD_TYPE_COMBO;
    public static int FIELD_TYPE_SIGNATURE;
    internal PdfReader reader;
    internal PdfWriter writer;
    internal Hashtable fields;
    private int topFirst;
    private Hashtable sigNames;
    private bool append;
    private Hashtable extensionFonts;
    private XfaForm xfa;
    private bool lastWasString;
    private bool generateAppearances;
    private Hashtable localFonts;
    private float extraMarginLeft;
    private float extraMarginTop;
    private ArrayList substitutionFonts;
    private static Hashtable stdFieldFontNames;
    private Hashtable fieldCache;
    private int totalRevisions;
    private static PdfName[] buttonRemove;
    public Hashtable Fields { get; }
    public bool GenerateAppearances { get; public set; }
    public int TotalRevisions { get; }
    public Hashtable FieldCache { get; public set; }
    public ArrayList SubstitutionFonts { get; public set; }
    public XfaForm Xfa { get; }
    internal AcroFields(PdfReader reader, PdfWriter writer);
    private static AcroFields();
    internal void Fill();
    public String[] GetAppearanceStates(string fieldName);
    private String[] GetListOption(string fieldName, int idx);
    public String[] GetListOptionExport(string fieldName);
    public String[] GetListOptionDisplay(string fieldName);
    public bool SetListOption(string fieldName, String[] exportValues, String[] displayValues);
    public int GetFieldType(string fieldName);
    public void ExportAsFdf(FdfWriter writer);
    public bool RenameField(string oldName, string newName);
    public static Object[] SplitDAelements(string da);
    public void DecodeGenericDictionary(PdfDictionary merged, BaseField tx);
    internal PdfAppearance GetAppearance(PdfDictionary merged, string text, string fieldName);
    internal Color GetMKColor(PdfArray ar);
    public string GetField(string name);
    public String[] GetListSelection(string name);
    public bool SetFieldProperty(string field, string name, object value, Int32[] inst);
    public bool SetFieldProperty(string field, string name, int value, Int32[] inst);
    public void MergeXfaData(XmlNode n);
    public void SetFields(FdfReader fdf);
    public void SetFields(XfdfReader xfdf);
    public bool RegenerateField(string name);
    public bool SetField(string name, string value);
    public bool SetField(string name, string value, string display);
    public bool SetListSelection(string name, String[] value);
    internal bool IsInAP(PdfDictionary dic, PdfName check);
    public Hashtable get_Fields();
    public Item GetFieldItem(string name);
    public string GetTranslatedFieldName(string name);
    public Single[] GetFieldPositions(string name);
    private int RemoveRefFromArray(PdfArray array, PdfObject refo);
    public bool RemoveFieldsFromPage(int page);
    public bool RemoveField(string name, int page);
    public bool RemoveField(string name);
    public void set_GenerateAppearances(bool value);
    public bool get_GenerateAppearances();
    private void FindSignatureNames();
    public ArrayList GetSignatureNames();
    public ArrayList GetBlankSignatureNames();
    public PdfDictionary GetSignatureDictionary(string name);
    public bool SignatureCoversWholeDocument(string name);
    public PdfPKCS7 VerifySignature(string name);
    private void UpdateByteRange(PdfPKCS7 pkcs7, PdfDictionary v);
    public int get_TotalRevisions();
    public int GetRevision(string field);
    public Stream ExtractRevision(string field);
    public void set_FieldCache(Hashtable value);
    public Hashtable get_FieldCache();
    private void MarkUsed(PdfObject obj);
    public void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public void AddSubstitutionFont(BaseFont font);
    public void set_SubstitutionFonts(ArrayList value);
    public ArrayList get_SubstitutionFonts();
    public XfaForm get_Xfa();
    public PushbuttonField GetNewPushbuttonFromField(string field);
    public PushbuttonField GetNewPushbuttonFromField(string field, int order);
    public bool ReplacePushbuttonField(string field, PdfFormField button);
    public bool ReplacePushbuttonField(string field, PdfFormField button, int order);
}
public class iTextSharp.text.pdf.ArabicLigaturizer : object {
    private static char ALEF;
    private static char ALEFHAMZA;
    private static char ALEFHAMZABELOW;
    private static char ALEFMADDA;
    private static char LAM;
    private static char HAMZA;
    private static char TATWEEL;
    private static char ZWJ;
    private static char HAMZAABOVE;
    private static char HAMZABELOW;
    private static char WAWHAMZA;
    private static char YEHHAMZA;
    private static char WAW;
    private static char ALEFMAKSURA;
    private static char YEH;
    private static char FARSIYEH;
    private static char SHADDA;
    private static char KASRA;
    private static char FATHA;
    private static char DAMMA;
    private static char MADDA;
    private static char LAM_ALEF;
    private static char LAM_ALEFHAMZA;
    private static char LAM_ALEFHAMZABELOW;
    private static char LAM_ALEFMADDA;
    public static int ar_nothing;
    public static int ar_novowel;
    public static int ar_composedtashkeel;
    public static int ar_lig;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    private static int DIGITS_RESERVED;
    public static int DIGITS_MASK;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int DIGIT_TYPE_MASK;
    private static Char[][] chartable;
    private static ArabicLigaturizer();
    private static bool IsVowel(char s);
    private static char Charshape(char s, int which);
    private static int Shapecount(char s);
    private static int Ligature(char newchar, Charstruct oldchar);
    private static void Copycstostring(StringBuilder str, Charstruct s, int level);
    internal static void Doublelig(StringBuilder str, int level);
    private static bool Connects_to_left(Charstruct a);
    internal static void Shape(Char[] text, StringBuilder str, int level);
    internal static int Arabic_shape(Char[] src, int srcoffset, int srclength, Char[] dest, int destoffset, int destlength, int level);
    internal static void ProcessNumbers(Char[] text, int offset, int length, int options);
    internal static void ShapeToArabicDigitsWithContext(Char[] dest, int start, int length, char digitBase, bool lastStrongWasAL);
}
public class iTextSharp.text.pdf.BadPasswordException : IOException {
    public BadPasswordException(string message);
}
public class iTextSharp.text.pdf.BadPdfFormatException : Exception {
    public BadPdfFormatException(string message);
}
public abstract class iTextSharp.text.pdf.Barcode : object {
    public static int EAN13;
    public static int EAN8;
    public static int UPCA;
    public static int UPCE;
    public static int SUPP2;
    public static int SUPP5;
    public static int POSTNET;
    public static int PLANET;
    public static int CODE128;
    public static int CODE128_UCC;
    public static int CODE128_RAW;
    public static int CODABAR;
    protected float x;
    protected float n;
    protected BaseFont font;
    protected float size;
    protected float baseline;
    protected float barHeight;
    protected int textAlignment;
    protected bool generateChecksum;
    protected bool checksumText;
    protected bool startStopText;
    protected bool extended;
    protected string code;
    protected bool guardBars;
    protected int codeType;
    protected float inkSpreading;
    protected string altText;
    public float X { get; public set; }
    public float N { get; public set; }
    public BaseFont Font { get; public set; }
    public float Size { get; public set; }
    public float Baseline { get; public set; }
    public float BarHeight { get; public set; }
    public int TextAlignment { get; public set; }
    public bool GenerateChecksum { get; public set; }
    public bool ChecksumText { get; public set; }
    public bool StartStopText { get; public set; }
    public bool Extended { get; public set; }
    public string Code { get; public set; }
    public bool GuardBars { get; public set; }
    public int CodeType { get; public set; }
    public Rectangle BarcodeSize { get; }
    public float InkSpreading { get; public set; }
    public string AltText { get; public set; }
    public float get_X();
    public void set_X(float value);
    public float get_N();
    public void set_N(float value);
    public BaseFont get_Font();
    public void set_Font(BaseFont value);
    public float get_Size();
    public void set_Size(float value);
    public float get_Baseline();
    public void set_Baseline(float value);
    public float get_BarHeight();
    public void set_BarHeight(float value);
    public int get_TextAlignment();
    public void set_TextAlignment(int value);
    public void set_GenerateChecksum(bool value);
    public bool get_GenerateChecksum();
    public void set_ChecksumText(bool value);
    public bool get_ChecksumText();
    public void set_StartStopText(bool value);
    public bool get_StartStopText();
    public void set_Extended(bool value);
    public bool get_Extended();
    public virtual string get_Code();
    public virtual void set_Code(string value);
    public void set_GuardBars(bool value);
    public bool get_GuardBars();
    public int get_CodeType();
    public void set_CodeType(int value);
    public abstract virtual Rectangle get_BarcodeSize();
    public void set_InkSpreading(float value);
    public float get_InkSpreading();
    public abstract virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public PdfTemplate CreateTemplateWithBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public Image CreateImageWithBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public void set_AltText(string value);
    public string get_AltText();
    public abstract virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.Barcode128 : Barcode {
    public static char CODE_AB_TO_C;
    public static char CODE_AC_TO_B;
    public static char CODE_BC_TO_A;
    public static char FNC1_INDEX;
    public static char START_A;
    public static char START_B;
    public static char START_C;
    public static char FNC1;
    public static char DEL;
    public static char FNC3;
    public static char FNC2;
    public static char SHIFT;
    public static char CODE_C;
    public static char CODE_A;
    public static char FNC4;
    public static char STARTA;
    public static char STARTB;
    public static char STARTC;
    private static Byte[][] BARS;
    private static Byte[] BARS_STOP;
    private static IntHashtable ais;
    public Rectangle BarcodeSize { get; }
    unknown string Code {public set; }
    private static Barcode128();
    public static string RemoveFNC1(string code);
    public static string GetHumanReadableUCCEAN(string code);
    internal static bool IsNextDigits(string text, int textIndex, int numDigits);
    internal static string GetPackedRawDigits(string text, int textIndex, int numDigits);
    public static string GetRawText(string text, bool ucc);
    public static Byte[] GetBarsCode128Raw(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public virtual void set_Code(string value);
}
public class iTextSharp.text.pdf.Barcode39 : Barcode {
    private static string CHARS;
    private static string EXTENDED;
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static Barcode39();
    public static Byte[] GetBarsCode39(string text);
    public static string GetCode39Ex(string text);
    internal static char GetChecksum(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeCodabar : Barcode {
    private static string CHARS;
    private static int START_STOP_IDX;
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodeCodabar();
    public static Byte[] GetBarsCodabar(string text);
    public static string CalculateChecksum(string code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeDatamatrix : object {
    public static int DM_NO_ERROR;
    public static int DM_ERROR_TEXT_TOO_BIG;
    public static int DM_ERROR_INVALID_SQUARE;
    public static int DM_ERROR_EXTENSION;
    public static int DM_AUTO;
    public static int DM_ASCII;
    public static int DM_C40;
    public static int DM_TEXT;
    public static int DM_B256;
    public static int DM_X21;
    public static int DM_EDIFACT;
    public static int DM_RAW;
    public static int DM_EXTENSION;
    public static int DM_TEST;
    private static string x12;
    private static DmParams[] dmSizes;
    private int extOut;
    private Int16[] place;
    private Byte[] image;
    private int height;
    private int width;
    private int ws;
    private int options;
    public Byte[] BitImage { get; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public int Ws { get; public set; }
    public int Options { get; public set; }
    private static BarcodeDatamatrix();
    private void SetBit(int x, int y, int xByte);
    private void Draw(Byte[] data, int dataSize, DmParams dm);
    private static void MakePadding(Byte[] data, int position, int count);
    private static bool IsDigit(int c);
    private static int AsciiEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int B256Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int X12Encodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int EdifactEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength);
    private static int C40OrTextEncodation(Byte[] text, int textOffset, int textLength, Byte[] data, int dataOffset, int dataLength, bool c40);
    private static int GetEncodation(Byte[] text, int textOffset, int textSize, Byte[] data, int dataOffset, int dataSize, int options, bool firstMatch);
    private static int GetNumber(Byte[] text, int ptrIn, int n);
    private int ProcessExtensions(Byte[] text, int textOffset, int textSize, Byte[] data);
    public int Generate(string text);
    public int Generate(Byte[] text, int textOffset, int textSize);
    public Image CreateImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public Byte[] get_BitImage();
    public int get_Height();
    public void set_Height(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Ws();
    public void set_Ws(int value);
    public int get_Options();
    public void set_Options(int value);
}
public class iTextSharp.text.pdf.BarcodeEAN : Barcode {
    private static int TOTALBARS_EAN13;
    private static int TOTALBARS_EAN8;
    private static int TOTALBARS_UPCE;
    private static int TOTALBARS_SUPP2;
    private static int TOTALBARS_SUPP5;
    private static byte ODD;
    private static byte EVEN;
    private static Int32[] GUARD_EMPTY;
    private static Int32[] GUARD_UPCA;
    private static Int32[] GUARD_EAN13;
    private static Int32[] GUARD_EAN8;
    private static Int32[] GUARD_UPCE;
    private static Single[] TEXTPOS_EAN13;
    private static Single[] TEXTPOS_EAN8;
    private static Byte[][] BARS;
    private static Byte[][] PARITY13;
    private static Byte[][] PARITY2;
    private static Byte[][] PARITY5;
    private static Byte[][] PARITYE;
    public Rectangle BarcodeSize { get; }
    private static BarcodeEAN();
    public static int CalculateEANParity(string code);
    public static string ConvertUPCAtoUPCE(string text);
    public static Byte[] GetBarsEAN13(string _code);
    public static Byte[] GetBarsEAN8(string _code);
    public static Byte[] GetBarsUPCE(string _code);
    public static Byte[] GetBarsSupplemental2(string _code);
    public static Byte[] GetBarsSupplemental5(string _code);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeEANSUPP : Barcode {
    protected Barcode ean;
    protected Barcode supp;
    public Rectangle BarcodeSize { get; }
    public BarcodeEANSUPP(Barcode ean, Barcode supp);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodeInter25 : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodeInter25();
    public static string KeepNumbers(string text);
    public static char GetChecksum(string text);
    public static Byte[] GetBarsInter25(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public class iTextSharp.text.pdf.BarcodePDF417 : object {
    public static int PDF417_USE_ASPECT_RATIO;
    public static int PDF417_FIXED_RECTANGLE;
    public static int PDF417_FIXED_COLUMNS;
    public static int PDF417_FIXED_ROWS;
    public static int PDF417_AUTO_ERROR_LEVEL;
    public static int PDF417_USE_ERROR_LEVEL;
    public static int PDF417_FORCE_BINARY;
    public static int PDF417_USE_RAW_CODEWORDS;
    public static int PDF417_INVERT_BITMAP;
    public static int PDF417_USE_MACRO;
    protected static int START_PATTERN;
    protected static int STOP_PATTERN;
    protected static int START_CODE_SIZE;
    protected static int STOP_SIZE;
    protected static int MOD;
    protected static int ALPHA;
    protected static int LOWER;
    protected static int MIXED;
    protected static int PUNCTUATION;
    protected static int ISBYTE;
    protected static int BYTESHIFT;
    protected static int PL;
    protected static int LL;
    protected static int AS;
    protected static int ML;
    protected static int AL;
    protected static int PS;
    protected static int PAL;
    protected static int SPACE;
    protected static int TEXT_MODE;
    protected static int BYTE_MODE_6;
    protected static int BYTE_MODE;
    protected static int NUMERIC_MODE;
    protected static int ABSOLUTE_MAX_TEXT_SIZE;
    protected static int MAX_DATA_CODEWORDS;
    protected static int MACRO_SEGMENT_ID;
    protected static int MACRO_LAST_SEGMENT;
    private static string MIXED_SET;
    private static string PUNCTUATION_SET;
    private int macroSegmentCount;
    private int macroSegmentId;
    private string macroFileId;
    private int macroIndex;
    protected int bitPtr;
    protected int cwPtr;
    protected SegmentList segmentList;
    private static Int32[][] CLUSTERS;
    private static Int32[][] ERROR_LEVEL;
    private Byte[] outBits;
    private int bitColumns;
    private int codeRows;
    private int codeColumns;
    private Int32[] codewords;
    private int lenCodewords;
    private int errorLevel;
    private Byte[] text;
    private int options;
    private float aspectRatio;
    private float yHeight;
    unknown int MacroSegmentId {public set; }
    unknown int MacroSegmentCount {public set; }
    unknown string MacroFileId {public set; }
    public Byte[] OutBits { get; }
    public int BitColumns { get; }
    public int CodeRows { get; public set; }
    public int CodeColumns { get; public set; }
    public Int32[] Codewords { get; }
    public int LenCodewords { get; public set; }
    public int ErrorLevel { get; public set; }
    public Byte[] Text { get; public set; }
    public int Options { get; public set; }
    public float AspectRatio { get; public set; }
    public float YHeight { get; public set; }
    private static BarcodePDF417();
    public void set_MacroSegmentId(int value);
    public void set_MacroSegmentCount(int value);
    public void set_MacroFileId(string value);
    protected bool CheckSegmentType(Segment segment, char type);
    protected int GetSegmentLength(Segment segment);
    public void SetDefaultParameters();
    protected void OutCodeword17(int codeword);
    protected void OutCodeword18(int codeword);
    protected void OutCodeword(int codeword);
    protected void OutStopPattern();
    protected void OutStartPattern();
    protected void OutPaintCode();
    protected void CalculateErrorCorrection(int dest);
    private static int GetTextTypeAndValue(Byte[] input, int maxLength, int idx);
    protected int GetTextTypeAndValue(int maxLength, int idx);
    private void TextCompaction(Byte[] input, int start, int length);
    protected void TextCompaction(int start, int length);
    protected void BasicNumberCompaction(int start, int length);
    private void BasicNumberCompaction(Byte[] input, int start, int length);
    private void NumberCompaction(Byte[] input, int start, int length);
    protected void NumberCompaction(int start, int length);
    protected void ByteCompaction6(int start);
    internal void ByteCompaction(int start, int length);
    internal void BreakString();
    protected void Assemble();
    private void MacroCodes();
    private void Append(int inp, int len);
    private void Append(string s);
    protected static int MaxPossibleErrorLevel(int remain);
    protected void DumpList();
    protected int GetMaxSquare();
    public void PaintCode();
    public Image GetImage();
    public virtual Image CreateDrawingImage(Color foreground, Color background);
    public Byte[] get_OutBits();
    public int get_BitColumns();
    public void set_CodeRows(int value);
    public int get_CodeRows();
    public void set_CodeColumns(int value);
    public int get_CodeColumns();
    public Int32[] get_Codewords();
    public void set_LenCodewords(int value);
    public int get_LenCodewords();
    public void set_ErrorLevel(int value);
    public int get_ErrorLevel();
    public void set_Text(Byte[] value);
    public Byte[] get_Text();
    public void SetText(string s);
    public void set_Options(int value);
    public int get_Options();
    public void set_AspectRatio(float value);
    public float get_AspectRatio();
    public void set_YHeight(float value);
    public float get_YHeight();
}
public class iTextSharp.text.pdf.BarcodePostnet : Barcode {
    private static Byte[][] BARS;
    public Rectangle BarcodeSize { get; }
    private static BarcodePostnet();
    public static Byte[] GetBarsPostnet(string text);
    public virtual Rectangle get_BarcodeSize();
    public virtual Rectangle PlaceBarcode(PdfContentByte cb, Color barColor, Color textColor);
    public virtual Image CreateDrawingImage(Color foreground, Color background);
}
public abstract class iTextSharp.text.pdf.BaseField : object {
    public static float BORDER_WIDTH_THIN;
    public static float BORDER_WIDTH_MEDIUM;
    public static float BORDER_WIDTH_THICK;
    public static int VISIBLE;
    public static int HIDDEN;
    public static int VISIBLE_BUT_DOES_NOT_PRINT;
    public static int HIDDEN_BUT_PRINTABLE;
    public static int READ_ONLY;
    public static int REQUIRED;
    public static int MULTILINE;
    public static int DO_NOT_SCROLL;
    public static int PASSWORD;
    public static int FILE_SELECTION;
    public static int DO_NOT_SPELL_CHECK;
    public static int EDIT;
    public static int COMB;
    protected float borderWidth;
    protected int borderStyle;
    protected Color borderColor;
    protected Color backgroundColor;
    protected Color textColor;
    protected BaseFont font;
    protected float fontSize;
    protected int alignment;
    protected PdfWriter writer;
    protected string text;
    protected Rectangle box;
    protected int rotation;
    protected int visibility;
    protected string fieldName;
    protected int options;
    protected int maxCharacterLength;
    private static Hashtable fieldKeys;
    protected BaseFont RealFont { get; }
    public float BorderWidth { get; public set; }
    public int BorderStyle { get; public set; }
    public Color BorderColor { get; public set; }
    public Color BackgroundColor { get; public set; }
    public Color TextColor { get; public set; }
    public BaseFont Font { get; public set; }
    public float FontSize { get; public set; }
    public int Alignment { get; public set; }
    public string Text { get; public set; }
    public Rectangle Box { get; public set; }
    public int Rotation { get; public set; }
    public int Visibility { get; public set; }
    public string FieldName { get; public set; }
    public int Options { get; public set; }
    public int MaxCharacterLength { get; public set; }
    public PdfWriter Writer { get; public set; }
    private static BaseField();
    public BaseField(PdfWriter writer, Rectangle box, string fieldName);
    protected BaseFont get_RealFont();
    protected PdfAppearance GetBorderAppearance();
    protected static ArrayList GetHardBreaks(string text);
    protected static void TrimRight(StringBuilder buf);
    protected static ArrayList BreakLines(ArrayList breaks, BaseFont font, float fontSize, float width);
    private void DrawTopFrame(PdfAppearance app);
    private void DrawBottomFrame(PdfAppearance app);
    public void set_BorderWidth(float value);
    public float get_BorderWidth();
    public void set_BorderStyle(int value);
    public int get_BorderStyle();
    public void set_BorderColor(Color value);
    public Color get_BorderColor();
    public void set_BackgroundColor(Color value);
    public Color get_BackgroundColor();
    public void set_TextColor(Color value);
    public Color get_TextColor();
    public void set_Font(BaseFont value);
    public BaseFont get_Font();
    public void set_FontSize(float value);
    public float get_FontSize();
    public void set_Alignment(int value);
    public int get_Alignment();
    public void set_Text(string value);
    public string get_Text();
    public void set_Box(Rectangle value);
    public Rectangle get_Box();
    public void set_Rotation(int value);
    public int get_Rotation();
    public void SetRotationFromPage(Rectangle page);
    public void set_Visibility(int value);
    public int get_Visibility();
    public void set_FieldName(string value);
    public string get_FieldName();
    public void set_Options(int value);
    public int get_Options();
    public void set_MaxCharacterLength(int value);
    public int get_MaxCharacterLength();
    public PdfWriter get_Writer();
    public void set_Writer(PdfWriter value);
    public static void MoveFields(PdfDictionary from, PdfDictionary to);
}
public abstract class iTextSharp.text.pdf.BaseFont : object {
    public static string COURIER;
    public static string COURIER_BOLD;
    public static string COURIER_OBLIQUE;
    public static string COURIER_BOLDOBLIQUE;
    public static string HELVETICA;
    public static string HELVETICA_BOLD;
    public static string HELVETICA_OBLIQUE;
    public static string HELVETICA_BOLDOBLIQUE;
    public static string SYMBOL;
    public static string TIMES_ROMAN;
    public static string TIMES_BOLD;
    public static string TIMES_ITALIC;
    public static string TIMES_BOLDITALIC;
    public static string ZAPFDINGBATS;
    public static int ASCENT;
    public static int CAPHEIGHT;
    public static int DESCENT;
    public static int ITALICANGLE;
    public static int BBOXLLX;
    public static int BBOXLLY;
    public static int BBOXURX;
    public static int BBOXURY;
    public static int AWT_ASCENT;
    public static int AWT_DESCENT;
    public static int AWT_LEADING;
    public static int AWT_MAXADVANCE;
    public static int UNDERLINE_POSITION;
    public static int UNDERLINE_THICKNESS;
    public static int STRIKETHROUGH_POSITION;
    public static int STRIKETHROUGH_THICKNESS;
    public static int SUBSCRIPT_SIZE;
    public static int SUBSCRIPT_OFFSET;
    public static int SUPERSCRIPT_SIZE;
    public static int SUPERSCRIPT_OFFSET;
    public static int FONT_TYPE_T1;
    public static int FONT_TYPE_TT;
    public static int FONT_TYPE_CJK;
    public static int FONT_TYPE_TTUNI;
    public static int FONT_TYPE_DOCUMENT;
    public static int FONT_TYPE_T3;
    public static string IDENTITY_H;
    public static string IDENTITY_V;
    public static string CP1250;
    public static string CP1252;
    public static string CP1257;
    public static string WINANSI;
    public static string MACROMAN;
    public static bool EMBEDDED;
    public static bool NOT_EMBEDDED;
    public static bool CACHED;
    public static bool NOT_CACHED;
    public static string RESOURCE_PATH;
    public static char CID_NEWLINE;
    public static string notdef;
    public static Int32[] CHAR_RANGE_LATIN;
    public static Int32[] CHAR_RANGE_ARABIC;
    public static Int32[] CHAR_RANGE_HEBREW;
    public static Int32[] CHAR_RANGE_CYRILLIC;
    protected ArrayList subsetRanges;
    internal int fontType;
    protected Int32[] widths;
    protected String[] differences;
    protected Char[] unicodeDifferences;
    protected Int32[][] charBBoxes;
    protected string encoding;
    protected bool embedded;
    protected int compressionLevel;
    protected bool fontSpecific;
    protected static Hashtable fontCache;
    protected static Hashtable BuiltinFonts14;
    protected bool forceWidthsOutput;
    protected bool directTextToByte;
    protected bool subset;
    protected bool fastWinansi;
    protected IntHashtable specialMap;
    protected internal static ArrayList resourceSearch;
    private static Random random;
    public string Encoding { get; }
    public int FontType { get; public set; }
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    public String[] CodePagesSupported { get; }
    public Int32[] Widths { get; }
    public String[] Differences { get; }
    public Char[] UnicodeDifferences { get; }
    public bool ForceWidthsOutput { get; public set; }
    public bool DirectTextToByte { get; public set; }
    public bool Subset { get; public set; }
    public int CompressionLevel { get; public set; }
    private static BaseFont();
    public static BaseFont CreateFont();
    public static BaseFont CreateFont(string name, string encoding, bool embedded);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool forceRead);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow);
    public static BaseFont CreateFont(string name, string encoding, bool embedded, bool cached, Byte[] ttfAfm, Byte[] pfb, bool noThrow, bool forceRead);
    public static BaseFont CreateFont(PRIndirectReference fontRef);
    protected static string GetBaseName(string name);
    protected static string NormalizeEncoding(string enc);
    protected void CreateEncoding();
    internal abstract virtual int GetRawWidth(int c, string name);
    public abstract virtual int GetKerning(int char1, int char2);
    public abstract virtual bool SetKerning(int char1, int char2, int kern);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public int GetDescent(string text);
    public int GetAscent(string text);
    public float GetDescentPoint(string text, float fontSize);
    public float GetAscentPoint(string text, float fontSize);
    public float GetWidthPointKerned(string text, float fontSize);
    public float GetWidthPoint(string text, float fontSize);
    public float GetWidthPoint(int char1, float fontSize);
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal abstract virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public abstract virtual PdfStream GetFullFontStream();
    public string get_Encoding();
    public abstract virtual float GetFontDescriptor(int key, float fontSize);
    public int get_FontType();
    public void set_FontType(int value);
    public bool IsEmbedded();
    public bool IsFontSpecific();
    internal static string CreateSubsetPrefix();
    internal char GetUnicodeDifferences(int index);
    public abstract virtual string get_PostscriptFontName();
    public abstract virtual void set_PostscriptFontName(string value);
    public abstract virtual String[][] get_FullFontName();
    public abstract virtual String[][] get_AllNameEntries();
    public static String[][] GetFullFontName(string name, string encoding, Byte[] ttfAfm);
    public static Object[] GetAllFontNames(string name, string encoding, Byte[] ttfAfm);
    public static String[][] GetAllNameEntries(string name, string encoding, Byte[] ttfAfm);
    public abstract virtual String[][] get_FamilyFontName();
    public virtual String[] get_CodePagesSupported();
    public static String[] EnumerateTTCNames(string ttcFile);
    public static String[] EnumerateTTCNames(Byte[] ttcArray);
    public Int32[] get_Widths();
    public String[] get_Differences();
    public Char[] get_UnicodeDifferences();
    public void set_ForceWidthsOutput(bool value);
    public bool get_ForceWidthsOutput();
    public void set_DirectTextToByte(bool value);
    public bool get_DirectTextToByte();
    public void set_Subset(bool value);
    public bool get_Subset();
    public static void AddToResourceSearch(object obj);
    public static Stream GetResourceStream(string key);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public abstract virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    private static void AddFont(PRIndirectReference fontRef, IntHashtable hits, ArrayList fonts);
    private static void RecourseFonts(PdfDictionary page, IntHashtable hits, ArrayList fonts, int level);
    public static ArrayList GetDocumentFonts(PdfReader reader);
    public static ArrayList GetDocumentFonts(PdfReader reader, int page);
    public virtual Int32[] GetCharBBox(int c);
    protected abstract virtual Int32[] GetRawCharBBox(int c, string name);
    public void CorrectArabicAdvance();
    public void AddSubsetRange(Int32[] range);
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
}
public class iTextSharp.text.pdf.BidiLine : object {
    private static int pieceSizeStart;
    protected int runDirection;
    protected int pieceSize;
    protected Char[] text;
    protected PdfChunk[] detailChunks;
    protected int totalTextLength;
    protected Byte[] orderLevels;
    protected Int32[] indexChars;
    protected ArrayList chunks;
    protected int indexChunk;
    protected int indexChunkChar;
    protected int currentChar;
    protected int storedRunDirection;
    protected Char[] storedText;
    protected PdfChunk[] storedDetailChunks;
    protected int storedTotalTextLength;
    protected Byte[] storedOrderLevels;
    protected Int32[] storedIndexChars;
    protected int storedIndexChunk;
    protected int storedIndexChunkChar;
    protected int storedCurrentChar;
    protected bool shortStore;
    protected static IntHashtable mirrorChars;
    protected int arabicOptions;
    public BidiLine(BidiLine org);
    private static BidiLine();
    public bool IsEmpty();
    public void ClearChunks();
    public bool GetParagraph(int runDirection);
    public void AddChunk(PdfChunk chunk);
    public void AddChunks(ArrayList chunks);
    public void AddPiece(char c, PdfChunk chunk);
    public void Save();
    public void Restore();
    public void MirrorGlyphs();
    public void DoArabicShapping();
    public PdfLine ProcessLine(float leftX, float width, int alignment, int runDirection, int arabicOptions);
    public float GetWidth(int startIdx, int lastIdx);
    public ArrayList CreateArrayOfPdfChunks(int startIdx, int endIdx);
    public ArrayList CreateArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk);
    public Int32[] GetWord(int startIdx, int idx);
    public int TrimRight(int startIdx, int endIdx);
    public int TrimLeft(int startIdx, int endIdx);
    public int TrimRightEx(int startIdx, int endIdx);
    public int TrimLeftEx(int startIdx, int endIdx);
    public void Reorder(int start, int end);
    public void Flip(int start, int end);
    public static bool IsWS(char c);
}
public class iTextSharp.text.pdf.BidiOrder : object {
    public static sbyte L;
    public static sbyte LRE;
    public static sbyte LRO;
    public static sbyte R;
    public static sbyte AL;
    public static sbyte RLE;
    public static sbyte RLO;
    public static sbyte PDF;
    public static sbyte EN;
    public static sbyte ES;
    public static sbyte ET;
    public static sbyte AN;
    public static sbyte CS;
    public static sbyte NSM;
    public static sbyte BN;
    public static sbyte B;
    public static sbyte S;
    public static sbyte WS;
    public static sbyte ON;
    public static sbyte TYPE_MIN;
    public static sbyte TYPE_MAX;
    private SByte[] initialTypes;
    private SByte[] embeddings;
    private sbyte paragraphEmbeddingLevel;
    private int textLength;
    private SByte[] resultTypes;
    private SByte[] resultLevels;
    private static SByte[] rtypes;
    private static Char[] baseTypes;
    public BidiOrder(SByte[] types);
    public BidiOrder(SByte[] types, sbyte paragraphEmbeddingLevel);
    public BidiOrder(Char[] text, int offset, int length, sbyte paragraphEmbeddingLevel);
    private static BidiOrder();
    public static sbyte GetDirection(char c);
    private void RunAlgorithm();
    private void DetermineParagraphEmbeddingLevel();
    private void DetermineExplicitEmbeddingLevels();
    private int RemoveExplicitCodes();
    private int ReinsertExplicitCodes(int textLength);
    private static SByte[] ProcessEmbeddings(SByte[] resultTypes, sbyte paragraphEmbeddingLevel);
    private void ResolveWeakTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveNeutralTypes(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    private void ResolveImplicitLevels(int start, int limit, sbyte level, sbyte sor, sbyte eor);
    public Byte[] GetLevels();
    public Byte[] GetLevels(Int32[] linebreaks);
    private static Int32[] ComputeMultilineReordering(SByte[] levels, Int32[] linebreaks);
    private static Int32[] ComputeReordering(SByte[] levels);
    public sbyte GetBaseLevel();
    private static bool IsWhitespace(sbyte biditype);
    private static sbyte TypeForLevel(int level);
    private int FindRunLimit(int index, int limit, SByte[] validSet);
    private int FindRunStart(int index, SByte[] validSet);
    private void SetTypes(int start, int limit, sbyte newType);
    private void SetLevels(int start, int limit, sbyte newLevel);
    private static void ValidateTypes(SByte[] types);
    private static void ValidateParagraphEmbeddingLevel(sbyte paragraphEmbeddingLevel);
    private static void ValidateLineBreaks(Int32[] linebreaks, int textLength);
}
public class iTextSharp.text.pdf.ByteBuffer : Stream {
    public static byte ZERO;
    protected int count;
    protected Byte[] buf;
    private static int byteCacheSize;
    private static Byte[][] byteCache;
    private static Char[] chars;
    private static Byte[] bytes;
    public static bool HIGH_PRECISION;
    public int Size { get; public set; }
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ByteBuffer(int size);
    private static ByteBuffer();
    public static void SetCacheSize(int size);
    public static void FillCache(int decimals);
    private static Byte[] ConvertToBytes(int i);
    public ByteBuffer Append_i(int b);
    public ByteBuffer Append(Byte[] b, int off, int len);
    public ByteBuffer Append(Byte[] b);
    public ByteBuffer Append(string str);
    public ByteBuffer Append(char c);
    public ByteBuffer Append(ByteBuffer buf);
    public ByteBuffer Append(int i);
    public ByteBuffer Append(byte b);
    public ByteBuffer AppendHex(byte b);
    public ByteBuffer Append(float i);
    public ByteBuffer Append(double d);
    public static string FormatDouble(double d);
    public static string FormatDouble(double d, ByteBuffer buf);
    public void Reset();
    public Byte[] ToByteArray();
    public int get_Size();
    public void set_Size(int value);
    public virtual string ToString();
    public void WriteTo(Stream str);
    private Char[] ConvertToChar(Byte[] buf);
    public Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class iTextSharp.text.pdf.CFFFont : object {
    internal static String[] operatorNames;
    internal static String[] standardStrings;
    internal int nextIndexOffset;
    protected string key;
    protected Object[] args;
    protected int arg_count;
    protected RandomAccessFileOrArray buf;
    private int offSize;
    protected int nameIndexOffset;
    protected int topdictIndexOffset;
    protected int stringIndexOffset;
    protected int gsubrIndexOffset;
    protected Int32[] nameOffsets;
    protected Int32[] topdictOffsets;
    protected Int32[] stringOffsets;
    protected Int32[] gsubrOffsets;
    protected Font[] fonts;
    public CFFFont(RandomAccessFileOrArray inputbuffer);
    private static CFFFont();
    public string GetString(char sid);
    internal char GetCard8();
    internal char GetCard16();
    internal int GetOffset(int offSize);
    internal void Seek(int offset);
    internal short GetShort();
    internal int GetInt();
    internal int GetPosition();
    internal Int32[] GetIndex(int nextIndexOffset);
    protected void GetDictItem();
    protected virtual RangeItem GetEntireIndexRange(int indexOffset);
    public Byte[] GetCID(string fontName);
    public bool IsCID(string fontName);
    public bool Exists(string fontName);
    public String[] GetNames();
    internal void ReadEncoding(int nextIndexOffset);
}
public class iTextSharp.text.pdf.CFFFontSubset : CFFFont {
    internal static byte ENDCHAR_OP;
    internal static byte RETURN_OP;
    internal static String[] SubrsFunctions;
    internal static String[] SubrsEscapeFuncs;
    internal Hashtable GlyphsUsed;
    internal ArrayList glyphsInList;
    internal Hashtable FDArrayUsed;
    internal Hashtable[] hSubrsUsed;
    internal ArrayList[] lSubrsUsed;
    internal Hashtable hGSubrsUsed;
    internal ArrayList lGSubrsUsed;
    internal Hashtable hSubrsUsedNonCID;
    internal ArrayList lSubrsUsedNonCID;
    internal Byte[][] NewLSubrsIndex;
    internal Byte[] NewSubrsIndexNonCID;
    internal Byte[] NewGSubrsIndex;
    internal Byte[] NewCharStringsIndex;
    internal int GBias;
    internal ArrayList OutputList;
    internal int NumOfHints;
    public CFFFontSubset(RandomAccessFileOrArray rf, Hashtable GlyphsUsed);
    private static CFFFontSubset();
    internal int CountCharset(int Offset, int NumofGlyphs);
    private int CountRange(int NumofGlyphs, int Type);
    protected void ReadFDSelect(int Font);
    protected void BuildFDArrayUsed(int Font);
    protected void ReadFDArray(int Font);
    public Byte[] Process(string fontName);
    protected int CalcBias(int Offset, int Font);
    protected void BuildNewCharString(int FontIndex);
    protected void BuildNewLGSubrs(int Font);
    protected void BuildFDSubrsOffsets(int Font, int FD);
    protected void BuildSubrUsed(int Font, int FD, int SubrOffset, Int32[] SubrsOffsets, Hashtable hSubr, ArrayList lSubr);
    protected void BuildGSubrsUsed(int Font);
    protected void ReadASubr(int begin, int end, int GBias, int LBias, Hashtable hSubr, ArrayList lSubr, Int32[] LSubrsOffsets);
    protected void HandelStack();
    protected int StackOpp();
    protected void EmptyStack();
    protected void PopStack();
    protected void PushStack();
    protected void ReadCommand();
    protected int CalcHints(int begin, int end, int LBias, int GBias, Int32[] LSubrsOffsets);
    protected Byte[] BuildNewIndex(Int32[] Offsets, Hashtable Used, byte OperatorForUnusedEntries);
    protected Byte[] AssembleIndex(Int32[] NewOffsets, Byte[] NewObjects);
    protected Byte[] BuildNewFile(int Font);
    protected void CopyHeader();
    protected void BuildIndexHeader(int Count, int Offsize, int First);
    protected void CreateKeys(OffsetItem fdarrayRef, OffsetItem fdselectRef, OffsetItem charsetRef, OffsetItem charstringsRef);
    protected void CreateNewStringIndex(int Font);
    protected void CreateFDSelect(OffsetItem fdselectRef, int nglyphs);
    protected void CreateCharset(OffsetItem charsetRef, int nglyphs);
    protected void CreateFDArray(OffsetItem fdarrayRef, OffsetItem privateRef, int Font);
    private void Reconstruct(int Font);
    private void ReconstructFDArray(int Font, OffsetItem[] fdPrivate);
    internal void ReconstructPrivateDict(int Font, OffsetItem[] fdPrivate, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal void ReconstructPrivateSubrs(int Font, IndexBaseItem[] fdPrivateBase, OffsetItem[] fdSubrs);
    internal int CalcSubrOffsetSize(int Offset, int Size);
    protected int CountEntireIndexRange(int indexOffset);
    internal void CreateNonCIDPrivate(int Font, OffsetItem Subr);
    internal void CreateNonCIDSubrs(int Font, IndexBaseItem PrivateBase, OffsetItem Subrs);
}
internal class iTextSharp.text.pdf.CJKFont : BaseFont {
    internal static string CJK_ENCODING;
    private static int FIRST;
    private static int BRACKET;
    private static int SERIAL;
    private static int V1Y;
    internal static Properties cjkFonts;
    internal static Properties cjkEncodings;
    internal static Hashtable allCMaps;
    internal static Hashtable allFonts;
    private static bool propertiesLoaded;
    private string fontName;
    private string style;
    private string CMap;
    private bool cidDirect;
    private Char[] translationMap;
    private IntHashtable vMetrics;
    private IntHashtable hMetrics;
    private Hashtable fontDesc;
    private bool vertical;
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal CJKFont(string fontName, string enc, bool emb);
    private static CJKFont();
    private static void LoadProperties();
    public static bool IsCJKFont(string fontName, string enc);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    private PdfDictionary GetFontDescriptor();
    private PdfDictionary GetCIDFont(PdfIndirectReference fontDescriptor, IntHashtable cjkTag);
    private PdfDictionary GetFontBaseType(PdfIndirectReference CIDFont);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    private float GetDescNumber(string name);
    private float GetBBox(int idx);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    internal static Char[] ReadCMap(string name);
    internal static IntHashtable CreateMetric(string s);
    internal static string ConvertToHCIDMetrics(Int32[] keys, IntHashtable h);
    internal static string ConvertToVCIDMetrics(Int32[] keys, IntHashtable v, IntHashtable h);
    internal static Hashtable ReadFontProperties(string name);
    public virtual int GetUnicodeEquivalent(int c);
    public virtual int GetCidCode(int c);
    public virtual bool HasKernPairs();
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
public class iTextSharp.text.pdf.CMYKColor : ExtendedColor {
    private float ccyan;
    private float cmagenta;
    private float cyellow;
    private float cblack;
    public float Cyan { get; }
    public float Magenta { get; }
    public float Yellow { get; }
    public float Black { get; }
    public CMYKColor(int intCyan, int intMagenta, int intYellow, int intBlack);
    public CMYKColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack);
    public float get_Cyan();
    public float get_Magenta();
    public float get_Yellow();
    public float get_Black();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.codec.BmpImage : object {
    private static int VERSION_2_1_BIT;
    private static int VERSION_2_4_BIT;
    private static int VERSION_2_8_BIT;
    private static int VERSION_2_24_BIT;
    private static int VERSION_3_1_BIT;
    private static int VERSION_3_4_BIT;
    private static int VERSION_3_8_BIT;
    private static int VERSION_3_24_BIT;
    private static int VERSION_3_NT_16_BIT;
    private static int VERSION_3_NT_32_BIT;
    private static int VERSION_4_1_BIT;
    private static int VERSION_4_4_BIT;
    private static int VERSION_4_8_BIT;
    private static int VERSION_4_16_BIT;
    private static int VERSION_4_24_BIT;
    private static int VERSION_4_32_BIT;
    private static int LCS_CALIBRATED_RGB;
    private static int LCS_sRGB;
    private static int LCS_CMYK;
    private static int BI_RGB;
    private static int BI_RLE8;
    private static int BI_RLE4;
    private static int BI_BITFIELDS;
    private Stream inputStream;
    private long bitmapFileSize;
    private long bitmapOffset;
    private long compression;
    private long imageSize;
    private Byte[] palette;
    private int imageType;
    private int numBands;
    private bool isBottomUp;
    private int bitsPerPixel;
    private int redMask;
    private int greenMask;
    private int blueMask;
    private int alphaMask;
    public Hashtable properties;
    private long xPelsPerMeter;
    private long yPelsPerMeter;
    private int width;
    private int height;
    internal BmpImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(Stream isp, bool noHeader, int size);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    protected void Process(Stream stream, bool noHeader);
    private Byte[] GetPalette(int group);
    private Image GetImage();
    private Image IndexedModel(Byte[] bdata, int bpc, int paletteEntries);
    private void ReadPalette(int sizeOfPalette);
    private Image Read1Bit(int paletteEntries);
    private Image Read4Bit(int paletteEntries);
    private Image Read8Bit(int paletteEntries);
    private void Read24Bit(Byte[] bdata);
    private int FindMask(int mask);
    private int FindShift(int mask);
    private Image Read1632Bit(bool is32);
    private Image ReadRLE8();
    private Image ReadRLE4();
    private Byte[] DecodeRLE(bool is8, Byte[] values);
    private int ReadUnsignedByte(Stream stream);
    private int ReadUnsignedShort(Stream stream);
    private int ReadShort(Stream stream);
    private int ReadWord(Stream stream);
    private long ReadUnsignedInt(Stream stream);
    private int ReadInt(Stream stream);
    private long ReadDWord(Stream stream);
    private int ReadLong(Stream stream);
}
public class iTextSharp.text.pdf.codec.CCITTG4Encoder : object {
    private static int LENGTH;
    private static int CODE;
    private static int RUNLEN;
    private static int EOL;
    private static int G3CODE_EOL;
    private static int G3CODE_INVALID;
    private static int G3CODE_EOF;
    private static int G3CODE_INCOMP;
    private int rowbytes;
    private int rowpixels;
    private int bit;
    private int data;
    private Byte[] refline;
    private ByteBuffer outBuf;
    private Byte[] dataBp;
    private int offsetData;
    private int sizeData;
    private static Byte[] zeroruns;
    private static Byte[] oneruns;
    private Int32[][] TIFFFaxWhiteCodes;
    private Int32[][] TIFFFaxBlackCodes;
    private Int32[] horizcode;
    private Int32[] passcode;
    private Int32[][] vcodes;
    private Int32[] msbmask;
    public CCITTG4Encoder(int width);
    private static CCITTG4Encoder();
    public void Fax4Encode(Byte[] data, int offset, int size);
    public static Byte[] Compress(Byte[] data, int width, int height);
    public void Fax4Encode(Byte[] data, int height);
    private void Putcode(Int32[] table);
    private void Putspan(int span, Int32[][] tab);
    private void PutBits(int bits, int length);
    private void Fax3Encode2DRow();
    private void Fax4PostEncode();
    public Byte[] Close();
    private int Pixel(Byte[] data, int offset, int bit);
    private static int Find1span(Byte[] bp, int offset, int bs, int be);
    private static int Find0span(Byte[] bp, int offset, int bs, int be);
    private static int Finddiff(Byte[] bp, int offset, int bs, int be, int color);
    private static int Finddiff2(Byte[] bp, int offset, int bs, int be, int color);
}
public class iTextSharp.text.pdf.codec.GifImage : object {
    protected static int MaxStackSize;
    protected Stream inp;
    protected int width;
    protected int height;
    protected bool gctFlag;
    protected int bgIndex;
    protected int bgColor;
    protected int pixelAspect;
    protected bool lctFlag;
    protected bool interlace;
    protected int lctSize;
    protected int ix;
    protected int iy;
    protected int iw;
    protected int ih;
    protected Byte[] block;
    protected int blockSize;
    protected int dispose;
    protected bool transparency;
    protected int delay;
    protected int transIndex;
    protected Int16[] prefix;
    protected Byte[] suffix;
    protected Byte[] pixelStack;
    protected Byte[] pixels;
    protected Byte[] m_out;
    protected int m_bpc;
    protected int m_gbpc;
    protected Byte[] m_global_table;
    protected Byte[] m_local_table;
    protected Byte[] m_curr_table;
    protected int m_line_stride;
    protected Byte[] fromData;
    protected Uri fromUrl;
    protected ArrayList frames;
    public GifImage(Uri url);
    public GifImage(string file);
    public GifImage(Byte[] data);
    public GifImage(Stream isp);
    public int GetFrameCount();
    public Image GetImage(int frame);
    public Int32[] GetFramePosition(int frame);
    public Int32[] GetLogicalScreen();
    internal void Process(Stream isp);
    protected void ReadHeader();
    protected void ReadLSD();
    protected int ReadShort();
    protected int ReadBlock();
    protected Byte[] ReadColorTable(int bpc);
    protected static int NewBpc(int bpc);
    protected void ReadContents();
    protected void ReadImage();
    protected bool DecodeImageData();
    protected void SetPixel(int x, int y, int v);
    protected void ResetFrame();
    protected void ReadGraphicControlExt();
    protected void Skip();
    private void ReadFully(Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.JBIG2Image : object {
    public static Byte[] GetGlobalSegment(RandomAccessFileOrArray ra);
    public static Image GetJbig2Image(RandomAccessFileOrArray ra, int page);
    public static int GetNumberOfPages(RandomAccessFileOrArray ra);
}
public class iTextSharp.text.pdf.codec.JBIG2SegmentReader : object {
    public static int SYMBOL_DICTIONARY;
    public static int INTERMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_TEXT_REGION;
    public static int IMMEDIATE_LOSSLESS_TEXT_REGION;
    public static int PATTERN_DICTIONARY;
    public static int INTERMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_HALFTONE_REGION;
    public static int IMMEDIATE_LOSSLESS_HALFTONE_REGION;
    public static int INTERMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_GENERIC_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REGION;
    public static int INTERMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_GENERIC_REFINEMENT_REGION;
    public static int IMMEDIATE_LOSSLESS_GENERIC_REFINEMENT_REGION;
    public static int PAGE_INFORMATION;
    public static int END_OF_PAGE;
    public static int END_OF_STRIPE;
    public static int END_OF_FILE;
    public static int PROFILES;
    public static int TABLES;
    public static int EXTENSION;
    private OrderedTree segments;
    private OrderedTree pages;
    private OrderedTree globals;
    private RandomAccessFileOrArray ra;
    private bool sequential;
    private bool number_of_pages_known;
    private int number_of_pages;
    private bool read;
    public JBIG2SegmentReader(RandomAccessFileOrArray ra);
    public static Byte[] CopyByteArray(Byte[] b);
    public void Read();
    private void ReadSegment(JBIG2Segment s);
    private JBIG2Segment ReadHeader();
    private void ReadFileHeader();
    public int NumberOfPages();
    public int GetPageHeight(int i);
    public int GetPageWidth(int i);
    public JBIG2Page GetPage(int page);
    public Byte[] GetGlobal(bool for_embedding);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.codec.PngImage : object {
    public static string IHDR;
    public static string PLTE;
    public static string IDAT;
    public static string IEND;
    public static string tRNS;
    public static string pHYs;
    public static string gAMA;
    public static string cHRM;
    public static string sRGB;
    public static string iCCP;
    private static int TRANSFERSIZE;
    private static int PNG_FILTER_NONE;
    private static int PNG_FILTER_SUB;
    private static int PNG_FILTER_UP;
    private static int PNG_FILTER_AVERAGE;
    private static int PNG_FILTER_PAETH;
    public static Int32[] PNGID;
    private static PdfName[] intents;
    private Stream isp;
    private Stream dataStream;
    private int width;
    private int height;
    private int bitDepth;
    private int colorType;
    private int compressionMethod;
    private int filterMethod;
    private int interlaceMethod;
    private PdfDictionary additional;
    private Byte[] image;
    private Byte[] smask;
    private Byte[] trans;
    private MemoryStream idat;
    private int dpiX;
    private int dpiY;
    private float XYRatio;
    private bool genBWMask;
    private bool palShades;
    private int transRedGray;
    private int transGreen;
    private int transBlue;
    private int inputBands;
    private int bytesPerPixel;
    private Byte[] colorTable;
    private float gamma;
    private bool hasCHRM;
    private float xW;
    private float yW;
    private float xR;
    private float yR;
    private float xG;
    private float yG;
    private float xB;
    private float yB;
    private PdfName intent;
    private ICC_Profile icc_profile;
    private PngImage(Stream isp);
    private static PngImage();
    public static Image GetImage(Uri url);
    public static Image GetImage(Stream isp);
    public static Image GetImage(string file);
    public static Image GetImage(Byte[] data);
    private static bool CheckMarker(string s);
    private void ReadPng();
    private PdfObject GetColorspace();
    private Image GetImage();
    private void DecodeIdat();
    private void DecodePass(int xOffset, int yOffset, int xStep, int yStep, int passWidth, int passHeight);
    private void ProcessPixels(Byte[] curr, int xOffset, int step, int y, int width);
    private static int GetPixel(Byte[] image, int x, int y, int bitDepth, int bytesPerRow);
    private static void SetPixel(Byte[] image, Int32[] data, int offset, int size, int x, int y, int bitDepth, int bytesPerRow);
    private Int32[] GetPixel(Byte[] curr);
    private static void DecodeSubFilter(Byte[] curr, int count, int bpp);
    private static void DecodeUpFilter(Byte[] curr, Byte[] prev, int count);
    private static void DecodeAverageFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    private static int PaethPredictor(int a, int b, int c);
    private static void DecodePaethFilter(Byte[] curr, Byte[] prev, int count, int bpp);
    public static int GetInt(Stream isp);
    public static int GetWord(Stream isp);
    public static string GetString(Stream isp);
    private static void ReadFully(Stream inp, Byte[] b, int offset, int count);
}
public class iTextSharp.text.pdf.codec.TIFFConstants : object {
    public static int TIFFTAG_SUBFILETYPE;
    public static int FILETYPE_REDUCEDIMAGE;
    public static int FILETYPE_PAGE;
    public static int FILETYPE_MASK;
    public static int TIFFTAG_OSUBFILETYPE;
    public static int OFILETYPE_IMAGE;
    public static int OFILETYPE_REDUCEDIMAGE;
    public static int OFILETYPE_PAGE;
    public static int TIFFTAG_IMAGEWIDTH;
    public static int TIFFTAG_IMAGELENGTH;
    public static int TIFFTAG_BITSPERSAMPLE;
    public static int TIFFTAG_COMPRESSION;
    public static int COMPRESSION_NONE;
    public static int COMPRESSION_CCITTRLE;
    public static int COMPRESSION_CCITTFAX3;
    public static int COMPRESSION_CCITTFAX4;
    public static int COMPRESSION_LZW;
    public static int COMPRESSION_OJPEG;
    public static int COMPRESSION_JPEG;
    public static int COMPRESSION_NEXT;
    public static int COMPRESSION_CCITTRLEW;
    public static int COMPRESSION_PACKBITS;
    public static int COMPRESSION_THUNDERSCAN;
    public static int COMPRESSION_IT8CTPAD;
    public static int COMPRESSION_IT8LW;
    public static int COMPRESSION_IT8MP;
    public static int COMPRESSION_IT8BL;
    public static int COMPRESSION_PIXARFILM;
    public static int COMPRESSION_PIXARLOG;
    public static int COMPRESSION_DEFLATE;
    public static int COMPRESSION_ADOBE_DEFLATE;
    public static int COMPRESSION_DCS;
    public static int COMPRESSION_JBIG;
    public static int COMPRESSION_SGILOG;
    public static int COMPRESSION_SGILOG24;
    public static int TIFFTAG_PHOTOMETRIC;
    public static int PHOTOMETRIC_MINISWHITE;
    public static int PHOTOMETRIC_MINISBLACK;
    public static int PHOTOMETRIC_RGB;
    public static int PHOTOMETRIC_PALETTE;
    public static int PHOTOMETRIC_MASK;
    public static int PHOTOMETRIC_SEPARATED;
    public static int PHOTOMETRIC_YCBCR;
    public static int PHOTOMETRIC_CIELAB;
    public static int PHOTOMETRIC_LOGL;
    public static int PHOTOMETRIC_LOGLUV;
    public static int TIFFTAG_THRESHHOLDING;
    public static int THRESHHOLD_BILEVEL;
    public static int THRESHHOLD_HALFTONE;
    public static int THRESHHOLD_ERRORDIFFUSE;
    public static int TIFFTAG_CELLWIDTH;
    public static int TIFFTAG_CELLLENGTH;
    public static int TIFFTAG_FILLORDER;
    public static int FILLORDER_MSB2LSB;
    public static int FILLORDER_LSB2MSB;
    public static int TIFFTAG_DOCUMENTNAME;
    public static int TIFFTAG_IMAGEDESCRIPTION;
    public static int TIFFTAG_MAKE;
    public static int TIFFTAG_MODEL;
    public static int TIFFTAG_STRIPOFFSETS;
    public static int TIFFTAG_ORIENTATION;
    public static int ORIENTATION_TOPLEFT;
    public static int ORIENTATION_TOPRIGHT;
    public static int ORIENTATION_BOTRIGHT;
    public static int ORIENTATION_BOTLEFT;
    public static int ORIENTATION_LEFTTOP;
    public static int ORIENTATION_RIGHTTOP;
    public static int ORIENTATION_RIGHTBOT;
    public static int ORIENTATION_LEFTBOT;
    public static int TIFFTAG_SAMPLESPERPIXEL;
    public static int TIFFTAG_ROWSPERSTRIP;
    public static int TIFFTAG_STRIPBYTECOUNTS;
    public static int TIFFTAG_MINSAMPLEVALUE;
    public static int TIFFTAG_MAXSAMPLEVALUE;
    public static int TIFFTAG_XRESOLUTION;
    public static int TIFFTAG_YRESOLUTION;
    public static int TIFFTAG_PLANARCONFIG;
    public static int PLANARCONFIG_CONTIG;
    public static int PLANARCONFIG_SEPARATE;
    public static int TIFFTAG_PAGENAME;
    public static int TIFFTAG_XPOSITION;
    public static int TIFFTAG_YPOSITION;
    public static int TIFFTAG_FREEOFFSETS;
    public static int TIFFTAG_FREEBYTECOUNTS;
    public static int TIFFTAG_GRAYRESPONSEUNIT;
    public static int GRAYRESPONSEUNIT_10S;
    public static int GRAYRESPONSEUNIT_100S;
    public static int GRAYRESPONSEUNIT_1000S;
    public static int GRAYRESPONSEUNIT_10000S;
    public static int GRAYRESPONSEUNIT_100000S;
    public static int TIFFTAG_GRAYRESPONSECURVE;
    public static int TIFFTAG_GROUP3OPTIONS;
    public static int GROUP3OPT_2DENCODING;
    public static int GROUP3OPT_UNCOMPRESSED;
    public static int GROUP3OPT_FILLBITS;
    public static int TIFFTAG_GROUP4OPTIONS;
    public static int GROUP4OPT_UNCOMPRESSED;
    public static int TIFFTAG_RESOLUTIONUNIT;
    public static int RESUNIT_NONE;
    public static int RESUNIT_INCH;
    public static int RESUNIT_CENTIMETER;
    public static int TIFFTAG_PAGENUMBER;
    public static int TIFFTAG_COLORRESPONSEUNIT;
    public static int COLORRESPONSEUNIT_10S;
    public static int COLORRESPONSEUNIT_100S;
    public static int COLORRESPONSEUNIT_1000S;
    public static int COLORRESPONSEUNIT_10000S;
    public static int COLORRESPONSEUNIT_100000S;
    public static int TIFFTAG_TRANSFERFUNCTION;
    public static int TIFFTAG_SOFTWARE;
    public static int TIFFTAG_DATETIME;
    public static int TIFFTAG_ARTIST;
    public static int TIFFTAG_HOSTCOMPUTER;
    public static int TIFFTAG_PREDICTOR;
    public static int TIFFTAG_WHITEPOINT;
    public static int TIFFTAG_PRIMARYCHROMATICITIES;
    public static int TIFFTAG_COLORMAP;
    public static int TIFFTAG_HALFTONEHINTS;
    public static int TIFFTAG_TILEWIDTH;
    public static int TIFFTAG_TILELENGTH;
    public static int TIFFTAG_TILEOFFSETS;
    public static int TIFFTAG_TILEBYTECOUNTS;
    public static int TIFFTAG_BADFAXLINES;
    public static int TIFFTAG_CLEANFAXDATA;
    public static int CLEANFAXDATA_CLEAN;
    public static int CLEANFAXDATA_REGENERATED;
    public static int CLEANFAXDATA_UNCLEAN;
    public static int TIFFTAG_CONSECUTIVEBADFAXLINES;
    public static int TIFFTAG_SUBIFD;
    public static int TIFFTAG_INKSET;
    public static int INKSET_CMYK;
    public static int TIFFTAG_INKNAMES;
    public static int TIFFTAG_NUMBEROFINKS;
    public static int TIFFTAG_DOTRANGE;
    public static int TIFFTAG_TARGETPRINTER;
    public static int TIFFTAG_EXTRASAMPLES;
    public static int EXTRASAMPLE_UNSPECIFIED;
    public static int EXTRASAMPLE_ASSOCALPHA;
    public static int EXTRASAMPLE_UNASSALPHA;
    public static int TIFFTAG_SAMPLEFORMAT;
    public static int SAMPLEFORMAT_UINT;
    public static int SAMPLEFORMAT_INT;
    public static int SAMPLEFORMAT_IEEEFP;
    public static int SAMPLEFORMAT_VOID;
    public static int SAMPLEFORMAT_COMPLEXINT;
    public static int SAMPLEFORMAT_COMPLEXIEEEFP;
    public static int TIFFTAG_SMINSAMPLEVALUE;
    public static int TIFFTAG_SMAXSAMPLEVALUE;
    public static int TIFFTAG_JPEGTABLES;
    public static int TIFFTAG_JPEGPROC;
    public static int JPEGPROC_BASELINE;
    public static int JPEGPROC_LOSSLESS;
    public static int TIFFTAG_JPEGIFOFFSET;
    public static int TIFFTAG_JPEGIFBYTECOUNT;
    public static int TIFFTAG_JPEGRESTARTINTERVAL;
    public static int TIFFTAG_JPEGLOSSLESSPREDICTORS;
    public static int TIFFTAG_JPEGPOINTTRANSFORM;
    public static int TIFFTAG_JPEGQTABLES;
    public static int TIFFTAG_JPEGDCTABLES;
    public static int TIFFTAG_JPEGACTABLES;
    public static int TIFFTAG_YCBCRCOEFFICIENTS;
    public static int TIFFTAG_YCBCRSUBSAMPLING;
    public static int TIFFTAG_YCBCRPOSITIONING;
    public static int YCBCRPOSITION_CENTERED;
    public static int YCBCRPOSITION_COSITED;
    public static int TIFFTAG_REFERENCEBLACKWHITE;
    public static int TIFFTAG_REFPTS;
    public static int TIFFTAG_REGIONTACKPOINT;
    public static int TIFFTAG_REGIONWARPCORNERS;
    public static int TIFFTAG_REGIONAFFINE;
    public static int TIFFTAG_MATTEING;
    public static int TIFFTAG_DATATYPE;
    public static int TIFFTAG_IMAGEDEPTH;
    public static int TIFFTAG_TILEDEPTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLWIDTH;
    public static int TIFFTAG_PIXAR_IMAGEFULLLENGTH;
    public static int TIFFTAG_PIXAR_TEXTUREFORMAT;
    public static int TIFFTAG_PIXAR_WRAPMODES;
    public static int TIFFTAG_PIXAR_FOVCOT;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN;
    public static int TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA;
    public static int TIFFTAG_WRITERSERIALNUMBER;
    public static int TIFFTAG_COPYRIGHT;
    public static int TIFFTAG_RICHTIFFIPTC;
    public static int TIFFTAG_IT8SITE;
    public static int TIFFTAG_IT8COLORSEQUENCE;
    public static int TIFFTAG_IT8HEADER;
    public static int TIFFTAG_IT8RASTERPADDING;
    public static int TIFFTAG_IT8BITSPERRUNLENGTH;
    public static int TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH;
    public static int TIFFTAG_IT8COLORTABLE;
    public static int TIFFTAG_IT8IMAGECOLORINDICATOR;
    public static int TIFFTAG_IT8BKGCOLORINDICATOR;
    public static int TIFFTAG_IT8IMAGECOLORVALUE;
    public static int TIFFTAG_IT8BKGCOLORVALUE;
    public static int TIFFTAG_IT8PIXELINTENSITYRANGE;
    public static int TIFFTAG_IT8TRANSPARENCYINDICATOR;
    public static int TIFFTAG_IT8COLORCHARACTERIZATION;
    public static int TIFFTAG_FRAMECOUNT;
    public static int TIFFTAG_ICCPROFILE;
    public static int TIFFTAG_PHOTOSHOP;
    public static int TIFFTAG_JBIGOPTIONS;
    public static int TIFFTAG_FAXRECVPARAMS;
    public static int TIFFTAG_FAXSUBADDRESS;
    public static int TIFFTAG_FAXRECVTIME;
    public static int TIFFTAG_STONITS;
    public static int TIFFTAG_FEDEX_EDR;
    public static int TIFFTAG_DCSHUESHIFTVALUES;
}
public class iTextSharp.text.pdf.codec.TIFFDirectory : object {
    private bool isBigEndian;
    private int numEntries;
    private TIFFField[] fields;
    private Hashtable fieldIndex;
    private long IFDOffset;
    private long nextIFDOffset;
    private static Int32[] sizeOfType;
    public TIFFDirectory(RandomAccessFileOrArray stream, int directory);
    public TIFFDirectory(RandomAccessFileOrArray stream, long ifd_offset, int directory);
    private static TIFFDirectory();
    private static bool IsValidEndianTag(int endian);
    private void Initialize(RandomAccessFileOrArray stream);
    public int GetNumEntries();
    public TIFFField GetField(int tag);
    public bool IsTagPresent(int tag);
    public Int32[] GetTags();
    public TIFFField[] GetFields();
    public byte GetFieldAsByte(int tag, int index);
    public byte GetFieldAsByte(int tag);
    public long GetFieldAsLong(int tag, int index);
    public long GetFieldAsLong(int tag);
    public float GetFieldAsFloat(int tag, int index);
    public float GetFieldAsFloat(int tag);
    public double GetFieldAsDouble(int tag, int index);
    public double GetFieldAsDouble(int tag);
    private short ReadShort(RandomAccessFileOrArray stream);
    private int ReadUnsignedShort(RandomAccessFileOrArray stream);
    private int ReadInt(RandomAccessFileOrArray stream);
    private long ReadUnsignedInt(RandomAccessFileOrArray stream);
    private long ReadLong(RandomAccessFileOrArray stream);
    private float ReadFloat(RandomAccessFileOrArray stream);
    private double ReadDouble(RandomAccessFileOrArray stream);
    private static int ReadUnsignedShort(RandomAccessFileOrArray stream, bool isBigEndian);
    private static long ReadUnsignedInt(RandomAccessFileOrArray stream, bool isBigEndian);
    public static int GetNumDirectories(RandomAccessFileOrArray stream);
    public bool IsBigEndian();
    public long GetIFDOffset();
    public long GetNextIFDOffset();
}
public class iTextSharp.text.pdf.codec.TIFFFaxDecoder : object {
    private int bitPointer;
    private int bytePointer;
    private Byte[] data;
    private int w;
    private int h;
    private int fillOrder;
    private int changingElemSize;
    private Int32[] prevChangingElems;
    private Int32[] currChangingElems;
    private int lastChangingElement;
    private int compression;
    private int uncompressedMode;
    private int fillBits;
    private int oneD;
    private static Int32[] table1;
    private static Int32[] table2;
    internal static Byte[] flipTable;
    private static Int16[] white;
    private static Int16[] additionalMakeup;
    private static Int16[] initBlack;
    private static Int16[] twoBitBlack;
    private static Int16[] black;
    private static Byte[] twoDCodes;
    public TIFFFaxDecoder(int fillOrder, int w, int h);
    private static TIFFFaxDecoder();
    public static void ReverseBits(Byte[] b);
    public void Decode1D(Byte[] buffer, Byte[] compData, int startX, int height);
    public void DecodeNextScanline(Byte[] buffer, int lineOffset, int bitOffset);
    public void Decode2D(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT4Options);
    public void DecodeT6(Byte[] buffer, Byte[] compData, int startX, int height, long tiffT6Options);
    private void SetToBlack(Byte[] buffer, int lineOffset, int bitOffset, int numBits);
    private int DecodeWhiteCodeWord();
    private int DecodeBlackCodeWord();
    private int ReadEOL(bool isFirstEOL);
    private void GetNextChangingElement(int a0, bool isWhite, Int32[] ret);
    private int NextNBits(int bitsToGet);
    private int NextLesserThan8Bits(int bitsToGet);
    private void UpdatePointer(int bitsToMoveBack);
    private bool AdvancePointer();
}
public class iTextSharp.text.pdf.codec.TIFFField : object {
    public static int TIFF_BYTE;
    public static int TIFF_ASCII;
    public static int TIFF_SHORT;
    public static int TIFF_LONG;
    public static int TIFF_RATIONAL;
    public static int TIFF_SBYTE;
    public static int TIFF_UNDEFINED;
    public static int TIFF_SSHORT;
    public static int TIFF_SLONG;
    public static int TIFF_SRATIONAL;
    public static int TIFF_FLOAT;
    public static int TIFF_DOUBLE;
    private int tag;
    private int type;
    private int count;
    private object data;
    public TIFFField(int tag, int type, int count, object data);
    public int GetTag();
    public int GetType();
    public int GetCount();
    public Byte[] GetAsBytes();
    public Char[] GetAsChars();
    public Int16[] GetAsShorts();
    public Int32[] GetAsInts();
    public Int64[] GetAsLongs();
    public Single[] GetAsFloats();
    public Double[] GetAsDoubles();
    public Int32[][] GetAsSRationals();
    public Int64[][] GetAsRationals();
    public int GetAsInt(int index);
    public long GetAsLong(int index);
    public float GetAsFloat(int index);
    public double GetAsDouble(int index);
    public string GetAsString(int index);
    public Int32[] GetAsSRational(int index);
    public Int64[] GetAsRational(int index);
    public sealed virtual int CompareTo(object o);
}
public class iTextSharp.text.pdf.codec.TiffImage : object {
    public static int GetNumberOfPages(RandomAccessFileOrArray s);
    private static int GetDpi(TIFFField fd, int resolutionUnit);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page);
    public static Image GetTiffImage(RandomAccessFileOrArray s, int page, bool direct);
    protected static Image GetTiffImageColor(TIFFDirectory dir, RandomAccessFileOrArray s);
    private static Int64[] GetArrayLongShort(TIFFDirectory dir, int tag);
    public static void DecodePackbits(Byte[] data, Byte[] dst);
    public static void Inflate(Byte[] deflated, Byte[] inflated);
}
public class iTextSharp.text.pdf.codec.TIFFLZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Byte[] uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int dstIndex;
    private int w;
    private int h;
    private int predictor;
    private int samplesPerPixel;
    private int nextData;
    private int nextBits;
    private Int32[] andTable;
    public TIFFLZWDecoder(int w, int predictor, int samplesPerPixel);
    public Byte[] Decode(Byte[] data, Byte[] uncompData, int h);
    public void InitializeStringTable();
    public void WriteString(Byte[] strn);
    public void AddStringToTable(Byte[] oldString, byte newString);
    public void AddStringToTable(Byte[] strn);
    public Byte[] ComposeString(Byte[] oldString, byte newString);
    public int GetNextCode();
}
public class iTextSharp.text.pdf.codec.wmf.InputMeta : object {
    private Stream sr;
    private int length;
    public int Length { get; }
    public InputMeta(Stream istr);
    public int ReadWord();
    public int ReadShort();
    public int ReadInt();
    public int ReadByte();
    public void Skip(int len);
    public int get_Length();
    public Color ReadColor();
}
public class iTextSharp.text.pdf.codec.wmf.MetaBrush : MetaObject {
    public static int BS_SOLID;
    public static int BS_NULL;
    public static int BS_HATCHED;
    public static int BS_PATTERN;
    public static int BS_DIBPATTERN;
    public static int HS_HORIZONTAL;
    public static int HS_VERTICAL;
    public static int HS_FDIAGONAL;
    public static int HS_BDIAGONAL;
    public static int HS_CROSS;
    public static int HS_DIAGCROSS;
    private int style;
    private int hatch;
    private Color color;
    public int Style { get; }
    public int Hatch { get; }
    public Color Color { get; }
    public void Init(InputMeta meta);
    public int get_Style();
    public int get_Hatch();
    public Color get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaDo : object {
    public static int META_SETBKCOLOR;
    public static int META_SETBKMODE;
    public static int META_SETMAPMODE;
    public static int META_SETROP2;
    public static int META_SETRELABS;
    public static int META_SETPOLYFILLMODE;
    public static int META_SETSTRETCHBLTMODE;
    public static int META_SETTEXTCHAREXTRA;
    public static int META_SETTEXTCOLOR;
    public static int META_SETTEXTJUSTIFICATION;
    public static int META_SETWINDOWORG;
    public static int META_SETWINDOWEXT;
    public static int META_SETVIEWPORTORG;
    public static int META_SETVIEWPORTEXT;
    public static int META_OFFSETWINDOWORG;
    public static int META_SCALEWINDOWEXT;
    public static int META_OFFSETVIEWPORTORG;
    public static int META_SCALEVIEWPORTEXT;
    public static int META_LINETO;
    public static int META_MOVETO;
    public static int META_EXCLUDECLIPRECT;
    public static int META_INTERSECTCLIPRECT;
    public static int META_ARC;
    public static int META_ELLIPSE;
    public static int META_FLOODFILL;
    public static int META_PIE;
    public static int META_RECTANGLE;
    public static int META_ROUNDRECT;
    public static int META_PATBLT;
    public static int META_SAVEDC;
    public static int META_SETPIXEL;
    public static int META_OFFSETCLIPRGN;
    public static int META_TEXTOUT;
    public static int META_BITBLT;
    public static int META_STRETCHBLT;
    public static int META_POLYGON;
    public static int META_POLYLINE;
    public static int META_ESCAPE;
    public static int META_RESTOREDC;
    public static int META_FILLREGION;
    public static int META_FRAMEREGION;
    public static int META_INVERTREGION;
    public static int META_PAINTREGION;
    public static int META_SELECTCLIPREGION;
    public static int META_SELECTOBJECT;
    public static int META_SETTEXTALIGN;
    public static int META_CHORD;
    public static int META_SETMAPPERFLAGS;
    public static int META_EXTTEXTOUT;
    public static int META_SETDIBTODEV;
    public static int META_SELECTPALETTE;
    public static int META_REALIZEPALETTE;
    public static int META_ANIMATEPALETTE;
    public static int META_SETPALENTRIES;
    public static int META_POLYPOLYGON;
    public static int META_RESIZEPALETTE;
    public static int META_DIBBITBLT;
    public static int META_DIBSTRETCHBLT;
    public static int META_DIBCREATEPATTERNBRUSH;
    public static int META_STRETCHDIB;
    public static int META_EXTFLOODFILL;
    public static int META_DELETEOBJECT;
    public static int META_CREATEPALETTE;
    public static int META_CREATEPATTERNBRUSH;
    public static int META_CREATEPENINDIRECT;
    public static int META_CREATEFONTINDIRECT;
    public static int META_CREATEBRUSHINDIRECT;
    public static int META_CREATEREGION;
    public PdfContentByte cb;
    public InputMeta meta;
    private int left;
    private int top;
    private int right;
    private int bottom;
    private int inch;
    private MetaState state;
    public MetaDo(Stream meta, PdfContentByte cb);
    public void ReadAll();
    public void OutputText(int x, int y, int flag, int x1, int y1, int x2, int y2, string text);
    public bool IsNullStrokeFill(bool isRectangle);
    public void StrokeAndFill();
    internal static float GetArc(float xCenter, float yCenter, float xDot, float yDot);
    public static Byte[] WrapBMP(Image image);
    public static void WriteWord(Stream os, int v);
    public static void WriteDWord(Stream os, int v);
}
public class iTextSharp.text.pdf.codec.wmf.MetaFont : MetaObject {
    internal static int MARKER_BOLD;
    internal static int MARKER_ITALIC;
    internal static int MARKER_COURIER;
    internal static int MARKER_HELVETICA;
    internal static int MARKER_TIMES;
    internal static int MARKER_SYMBOL;
    internal static int DEFAULT_PITCH;
    internal static int FIXED_PITCH;
    internal static int VARIABLE_PITCH;
    internal static int FF_DONTCARE;
    internal static int FF_ROMAN;
    internal static int FF_SWISS;
    internal static int FF_MODERN;
    internal static int FF_SCRIPT;
    internal static int FF_DECORATIVE;
    internal static int BOLDTHRESHOLD;
    internal static int nameSize;
    internal static int ETO_OPAQUE;
    internal static int ETO_CLIPPED;
    private static String[] fontNames;
    private int height;
    private float angle;
    private int bold;
    private int italic;
    private bool underline;
    private bool strikeout;
    private int charset;
    private int pitchAndFamily;
    private string faceName;
    private BaseFont font;
    public BaseFont Font { get; }
    public float Angle { get; }
    private static MetaFont();
    public void Init(InputMeta meta);
    public BaseFont get_Font();
    public float get_Angle();
    public bool IsUnderline();
    public bool IsStrikeout();
    public float GetFontSize(MetaState state);
}
public class iTextSharp.text.pdf.codec.wmf.MetaObject : object {
    public static int META_NOT_SUPPORTED;
    public static int META_PEN;
    public static int META_BRUSH;
    public static int META_FONT;
    public int type;
    public int Type { get; }
    public MetaObject(int type);
    public int get_Type();
}
public class iTextSharp.text.pdf.codec.wmf.MetaPen : MetaObject {
    public static int PS_SOLID;
    public static int PS_DASH;
    public static int PS_DOT;
    public static int PS_DASHDOT;
    public static int PS_DASHDOTDOT;
    public static int PS_NULL;
    public static int PS_INSIDEFRAME;
    private int style;
    private int penWidth;
    private Color color;
    public int Style { get; }
    public int PenWidth { get; }
    public Color Color { get; }
    public void Init(InputMeta meta);
    public int get_Style();
    public int get_PenWidth();
    public Color get_Color();
}
public class iTextSharp.text.pdf.codec.wmf.MetaState : object {
    public static int TA_NOUPDATECP;
    public static int TA_UPDATECP;
    public static int TA_LEFT;
    public static int TA_RIGHT;
    public static int TA_CENTER;
    public static int TA_TOP;
    public static int TA_BOTTOM;
    public static int TA_BASELINE;
    public static int TRANSPARENT;
    public static int OPAQUE;
    public static int ALTERNATE;
    public static int WINDING;
    public Stack savedStates;
    public ArrayList MetaObjects;
    public Point currentPoint;
    public MetaPen currentPen;
    public MetaBrush currentBrush;
    public MetaFont currentFont;
    public Color currentBackgroundColor;
    public Color currentTextColor;
    public int backgroundMode;
    public int polyFillMode;
    public int lineJoin;
    public int textAlign;
    public int offsetWx;
    public int offsetWy;
    public int extentWx;
    public int extentWy;
    public float scalingX;
    public float scalingY;
    unknown MetaState metaState {public set; }
    unknown float ScalingX {public set; }
    unknown float ScalingY {public set; }
    unknown int OffsetWx {public set; }
    unknown int OffsetWy {public set; }
    unknown int ExtentWx {public set; }
    unknown int ExtentWy {public set; }
    public Point CurrentPoint { get; public set; }
    public MetaBrush CurrentBrush { get; }
    public MetaPen CurrentPen { get; }
    public MetaFont CurrentFont { get; }
    public Color CurrentBackgroundColor { get; public set; }
    public Color CurrentTextColor { get; public set; }
    public int BackgroundMode { get; public set; }
    public int TextAlign { get; public set; }
    public int PolyFillMode { get; public set; }
    unknown PdfContentByte LineJoinRectangle {public set; }
    unknown PdfContentByte LineJoinPolygon {public set; }
    public bool LineNeutral { get; }
    public MetaState(MetaState state);
    private static MetaState();
    public void set_metaState(MetaState value);
    public void AddMetaObject(MetaObject obj);
    public void SelectMetaObject(int index, PdfContentByte cb);
    public void DeleteMetaObject(int index);
    public void SaveState(PdfContentByte cb);
    public void RestoreState(int index, PdfContentByte cb);
    public void Cleanup(PdfContentByte cb);
    public float TransformX(int x);
    public float TransformY(int y);
    public void set_ScalingX(float value);
    public void set_ScalingY(float value);
    public void set_OffsetWx(int value);
    public void set_OffsetWy(int value);
    public void set_ExtentWx(int value);
    public void set_ExtentWy(int value);
    public float TransformAngle(float angle);
    public Point get_CurrentPoint();
    public void set_CurrentPoint(Point value);
    public MetaBrush get_CurrentBrush();
    public MetaPen get_CurrentPen();
    public MetaFont get_CurrentFont();
    public Color get_CurrentBackgroundColor();
    public void set_CurrentBackgroundColor(Color value);
    public Color get_CurrentTextColor();
    public void set_CurrentTextColor(Color value);
    public int get_BackgroundMode();
    public void set_BackgroundMode(int value);
    public int get_TextAlign();
    public void set_TextAlign(int value);
    public int get_PolyFillMode();
    public void set_PolyFillMode(int value);
    public void set_LineJoinRectangle(PdfContentByte value);
    public void set_LineJoinPolygon(PdfContentByte value);
    public bool get_LineNeutral();
}
public class iTextSharp.text.pdf.collection.PdfCollection : PdfDictionary {
    public static int DETAILS;
    public static int TILE;
    public static int HIDDEN;
    unknown string InitialDocument {public set; }
    public PdfCollectionSchema Schema { get; public set; }
    unknown PdfCollectionSort Sort {public set; }
    public PdfCollection(int type);
    public void set_InitialDocument(string value);
    public void set_Schema(PdfCollectionSchema value);
    public PdfCollectionSchema get_Schema();
    public void set_Sort(PdfCollectionSort value);
}
public class iTextSharp.text.pdf.collection.PdfCollectionField : PdfDictionary {
    public static int TEXT;
    public static int DATE;
    public static int NUMBER;
    public static int FILENAME;
    public static int DESC;
    public static int MODDATE;
    public static int CREATIONDATE;
    public static int SIZE;
    protected internal int fieldType;
    unknown int Order {public set; }
    unknown bool Visible {public set; }
    unknown bool Editable {public set; }
    public PdfCollectionField(string name, int type);
    public void set_Order(int value);
    public void set_Visible(bool value);
    public void set_Editable(bool value);
    public bool IsCollectionItem();
    public PdfObject GetValue(string v);
}
public class iTextSharp.text.pdf.collection.PdfCollectionItem : PdfDictionary {
    internal PdfCollectionSchema schema;
    public PdfCollectionItem(PdfCollectionSchema schema);
    public void AddItem(string key, string value);
    public void AddItem(string key, PdfString value);
    public void AddItem(string key, PdfDate d);
    public void AddItem(string key, PdfNumber n);
    public void AddItem(string key, DateTime c);
    public void AddItem(string key, int i);
    public void AddItem(string key, float f);
    public void AddItem(string key, double d);
    public void SetPrefix(string key, string prefix);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSchema : PdfDictionary {
    public void AddField(string name, PdfCollectionField field);
}
public class iTextSharp.text.pdf.collection.PdfCollectionSort : PdfDictionary {
    public PdfCollectionSort(string key);
    public PdfCollectionSort(String[] keys);
    public void SetSortOrder(bool ascending);
    public void SetSortOrder(Boolean[] ascending);
}
public class iTextSharp.text.pdf.collection.PdfTargetDictionary : PdfDictionary {
    unknown string EmbeddedFileName {public set; }
    unknown string FileAttachmentPagename {public set; }
    unknown int FileAttachmentPage {public set; }
    unknown string FileAttachmentName {public set; }
    unknown int FileAttachmentIndex {public set; }
    unknown PdfTargetDictionary AdditionalPath {public set; }
    public PdfTargetDictionary(PdfTargetDictionary nested);
    public PdfTargetDictionary(bool child);
    public void set_EmbeddedFileName(string value);
    public void set_FileAttachmentPagename(string value);
    public void set_FileAttachmentPage(int value);
    public void set_FileAttachmentName(string value);
    public void set_FileAttachmentIndex(int value);
    public void set_AdditionalPath(PdfTargetDictionary value);
}
public class iTextSharp.text.pdf.ColorDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName colorName;
    private PdfSpotColor spotcolor;
    internal PdfIndirectReference IndirectReference { get; }
    internal PdfName ColorName { get; }
    internal ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, PdfSpotColor scolor);
    internal PdfIndirectReference get_IndirectReference();
    internal PdfName get_ColorName();
    internal PdfObject GetSpotColor(PdfWriter writer);
}
public class iTextSharp.text.pdf.ColumnText : object {
    public static int AR_COMPOSEDTASHKEEL;
    public static int AR_LIG;
    public static int DIGITS_EN2AN;
    public static int DIGITS_AN2EN;
    public static int DIGITS_EN2AN_INIT_LR;
    public static int DIGITS_EN2AN_INIT_AL;
    public static int DIGIT_TYPE_AN;
    public static int DIGIT_TYPE_AN_EXTENDED;
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected static int LINE_STATUS_OK;
    protected static int LINE_STATUS_OFFLIMITS;
    protected static int LINE_STATUS_NOLINE;
    public int AR_NOVOWEL;
    protected int runDirection;
    public static float GLOBAL_SPACE_CHAR_RATIO;
    protected float maxY;
    protected float minY;
    protected float leftX;
    protected float rightX;
    protected int alignment;
    protected ArrayList leftWall;
    protected ArrayList rightWall;
    protected BidiLine bidiLine;
    protected float yLine;
    protected float currentLeading;
    protected float fixedLeading;
    protected float multipliedLeading;
    protected PdfContentByte canvas;
    protected PdfContentByte[] canvases;
    protected int lineStatus;
    protected float indent;
    protected float followingIndent;
    protected float rightIndent;
    protected float extraParagraphSpace;
    protected float rectangularWidth;
    protected bool rectangularMode;
    private float spaceCharRatio;
    private bool lastWasNewline;
    private int linesWritten;
    private float firstLineY;
    private bool firstLineYDone;
    private int arabicOptions;
    protected float descender;
    protected bool composite;
    protected ColumnText compositeColumn;
    protected internal ArrayList compositeElements;
    protected int listIdx;
    private bool splittedRow;
    protected Phrase waitPhrase;
    private bool useAscender;
    private float filledWidth;
    private bool adjustFirstLine;
    public float Leading { get; public set; }
    public float MultipliedLeading { get; }
    public float YLine { get; public set; }
    public int Alignment { get; public set; }
    public float Indent { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public int LinesWritten { get; }
    public int ArabicOptions { get; public set; }
    public float Descender { get; }
    public PdfContentByte Canvas { get; public set; }
    public PdfContentByte[] Canvases { get; public set; }
    public bool UseAscender { get; public set; }
    public float FilledWidth { get; public set; }
    public bool AdjustFirstLine { get; public set; }
    public ColumnText(PdfContentByte canvas);
    private static ColumnText();
    public static ColumnText Duplicate(ColumnText org);
    public ColumnText SetACopy(ColumnText org);
    protected internal void SetSimpleVars(ColumnText org);
    private void AddWaitingPhrase();
    public void AddText(Phrase phrase);
    public void SetText(Phrase phrase);
    public void AddText(Chunk chunk);
    public void AddElement(IElement element);
    protected ArrayList ConvertColumn(Single[] cLine);
    protected float FindLimitsPoint(ArrayList wall);
    protected Single[] FindLimitsOneLine();
    protected Single[] FindLimitsTwoLines();
    public void SetColumns(Single[] leftLine, Single[] rightLine);
    public void SetSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment);
    public void SetSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment);
    public void SetSimpleColumn(float llx, float lly, float urx, float ury);
    public void SetLeading(float fixedLeading, float multipliedLeading);
    public float get_Leading();
    public void set_Leading(float value);
    public float get_MultipliedLeading();
    public float get_YLine();
    public void set_YLine(float value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public float get_Indent();
    public void set_Indent(float value);
    public float get_FollowingIndent();
    public void set_FollowingIndent(float value);
    public float get_RightIndent();
    public void set_RightIndent(float value);
    public int Go();
    public int Go(bool simulate);
    public float get_ExtraParagraphSpace();
    public void set_ExtraParagraphSpace(float value);
    public void ClearChunks();
    public float get_SpaceCharRatio();
    public void set_SpaceCharRatio(float value);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public int get_LinesWritten();
    public void set_ArabicOptions(int value);
    public int get_ArabicOptions();
    public float get_Descender();
    public static float GetWidth(Phrase phrase, int runDirection, int arabicOptions);
    public static float GetWidth(Phrase phrase);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions);
    public static void ShowTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation);
    protected int GoComposite(bool simulate);
    public void set_Canvas(PdfContentByte value);
    public PdfContentByte get_Canvas();
    public void set_Canvases(PdfContentByte[] value);
    public PdfContentByte[] get_Canvases();
    public bool ZeroHeightElement();
    public void set_UseAscender(bool value);
    public bool get_UseAscender();
    public static bool HasMoreText(int status);
    public void set_FilledWidth(float value);
    public float get_FilledWidth();
    public void UpdateFilledWidth(float w);
    public void set_AdjustFirstLine(bool value);
    public bool get_AdjustFirstLine();
}
public class iTextSharp.text.pdf.crypto.AESCipher : object {
    private PaddedBufferedBlockCipher bp;
    public AESCipher(bool forEncryption, Byte[] key, Byte[] iv);
    public Byte[] Update(Byte[] inp, int inpOff, int inpLen);
    public Byte[] DoFinal();
}
public class iTextSharp.text.pdf.crypto.ARCFOUREncryption : object {
    private Byte[] state;
    private int x;
    private int y;
    public void PrepareARCFOURKey(Byte[] key);
    public void PrepareARCFOURKey(Byte[] key, int off, int len);
    public void EncryptARCFOUR(Byte[] dataIn, int off, int len, Byte[] dataOut, int offOut);
    public void EncryptARCFOUR(Byte[] data, int off, int len);
    public void EncryptARCFOUR(Byte[] dataIn, Byte[] dataOut);
    public void EncryptARCFOUR(Byte[] data);
}
public class iTextSharp.text.pdf.crypto.IVGenerator : object {
    private static ARCFOUREncryption rc4;
    private static IVGenerator();
    public static Byte[] GetIV();
    public static Byte[] GetIV(int len);
}
public class iTextSharp.text.pdf.crypto.StandardDecryption : object {
    private static int AES_128;
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] key;
    private bool aes;
    private bool initiated;
    private Byte[] iv;
    private int ivptr;
    public StandardDecryption(Byte[] key, int off, int len, int revision);
    public Byte[] Update(Byte[] b, int off, int len);
    public Byte[] Finish();
}
public class iTextSharp.text.pdf.DefaultSplitCharacter : object {
    public static ISplitCharacter DEFAULT;
    private static DefaultSplitCharacter();
    public sealed virtual bool IsSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    protected char GetCurrentCharacter(int current, Char[] cc, PdfChunk[] ck);
}
public class iTextSharp.text.pdf.DocumentFont : BaseFont {
    private Hashtable metrics;
    private string fontName;
    private PRIndirectReference refFont;
    private PdfDictionary font;
    private IntHashtable uni2byte;
    private IntHashtable diffmap;
    private float Ascender;
    private float CapHeight;
    private float Descender;
    private float ItalicAngle;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    private bool isType0;
    private BaseFont cjkMirror;
    private static String[] cjkNames;
    private static String[] cjkEncs;
    private static String[] cjkNames2;
    private static String[] cjkEncs2;
    private static Int32[] stdEnc;
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    internal PdfIndirectReference IndirectReference { get; }
    internal IntHashtable Uni2Byte { get; }
    internal DocumentFont(PRIndirectReference refFont);
    private static DocumentFont();
    private void ProcessType0(PdfDictionary font);
    private IntHashtable ReadWidths(PdfArray ws);
    private string DecodeString(PdfString ps);
    private void FillMetrics(Byte[] touni, IntHashtable widths, int dw);
    private void DoType1TT();
    private void FillFontDesc(PdfDictionary fontDesc);
    private void FillEncoding(PdfName encoding);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference refi, Object[] param);
    public virtual PdfStream GetFullFontStream();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    internal PdfIndirectReference get_IndirectReference();
    public virtual bool CharExists(int c);
    public virtual bool SetKerning(int char1, int char2, int kern);
    public virtual Int32[] GetCharBBox(int c);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal IntHashtable get_Uni2Byte();
}
public class iTextSharp.text.pdf.draw.DottedLineSeparator : LineSeparator {
    protected float gap;
    public float Gap { get; public set; }
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public float get_Gap();
    public void set_Gap(float value);
}
public interface iTextSharp.text.pdf.draw.IDrawInterface {
    public abstract virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
}
public class iTextSharp.text.pdf.draw.LineSeparator : VerticalPositionMark {
    protected float lineWidth;
    protected float percentage;
    protected Color lineColor;
    protected int alignment;
    public float LineWidth { get; public set; }
    public float Percentage { get; public set; }
    public Color LineColor { get; public set; }
    public int Alignment { get; public set; }
    public LineSeparator(float lineWidth, float percentage, Color lineColor, int align, float offset);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public void DrawLine(PdfContentByte canvas, float leftX, float rightX, float y);
    public float get_LineWidth();
    public void set_LineWidth(float value);
    public float get_Percentage();
    public void set_Percentage(float value);
    public Color get_LineColor();
    public void set_LineColor(Color value);
    public int get_Alignment();
    public void set_Alignment(int value);
}
public class iTextSharp.text.pdf.draw.VerticalPositionMark : object {
    protected IDrawInterface drawInterface;
    protected float offset;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public IDrawInterface DrawInterface { get; public set; }
    public float Offset { get; public set; }
    public VerticalPositionMark(IDrawInterface drawInterface, float offset);
    public virtual void Draw(PdfContentByte canvas, float llx, float lly, float urx, float ury, float y);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual ArrayList get_Chunks();
    public virtual void set_DrawInterface(IDrawInterface value);
    public virtual IDrawInterface get_DrawInterface();
    public virtual void set_Offset(float value);
    public virtual float get_Offset();
}
internal class iTextSharp.text.pdf.EnumerateTTC : TrueTypeFont {
    protected String[] names;
    internal String[] Names { get; }
    internal EnumerateTTC(string ttcFile);
    internal EnumerateTTC(Byte[] ttcArray);
    internal void FindNames();
    internal String[] get_Names();
}
public class iTextSharp.text.pdf.events.FieldPositioningEvents : PdfPageEventHelper {
    protected Hashtable genericChunkFields;
    protected PdfFormField cellField;
    protected PdfWriter fieldWriter;
    protected PdfFormField parent;
    public float padding;
    public float Padding { get; public set; }
    public PdfFormField Parent { get; public set; }
    public FieldPositioningEvents(PdfWriter writer, PdfFormField field);
    public FieldPositioningEvents(PdfFormField parent, PdfFormField field);
    public FieldPositioningEvents(PdfWriter writer, string text);
    public FieldPositioningEvents(PdfWriter writer, PdfFormField parent, string text);
    public void AddField(string text, PdfFormField field);
    public void set_Padding(float value);
    public float get_Padding();
    public void set_Parent(PdfFormField value);
    public PdfFormField get_Parent();
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle rect, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.IndexEvents : PdfPageEventHelper {
    private Hashtable indextag;
    private long indexcounter;
    private ArrayList indexentry;
    private IComparer comparator;
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
    public Chunk Create(string text, string in1, string in2, string in3);
    public Chunk Create(string text, string in1);
    public Chunk Create(string text, string in1, string in2);
    public void Create(Chunk text, string in1, string in2, string in3);
    public void Create(Chunk text, string in1);
    public void Create(Chunk text, string in1, string in2);
    public void SetComparator(IComparer aComparator);
    public ArrayList GetSortedEntries();
}
public class iTextSharp.text.pdf.events.PdfPageEventForwarder : object {
    protected ArrayList events;
    public void AddPageEvent(IPdfPageEvent eventa);
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.events.PdfPCellEventForwarder : object {
    protected ArrayList events;
    public void AddCellEvent(IPdfPCellEvent eventa);
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public class iTextSharp.text.pdf.events.PdfPTableEventForwarder : object {
    protected ArrayList events;
    public void AddTableEvent(IPdfPTableEvent eventa);
    public sealed virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
}
public abstract class iTextSharp.text.pdf.ExtendedColor : Color {
    internal static int TYPE_RGB;
    internal static int TYPE_GRAY;
    internal static int TYPE_CMYK;
    internal static int TYPE_SEPARATION;
    internal static int TYPE_PATTERN;
    internal static int TYPE_SHADING;
    protected int type;
    public int Type { get; }
    public ExtendedColor(int type);
    public ExtendedColor(int type, float red, float green, float blue);
    public int get_Type();
    public static int GetType(object color);
    internal static float Normalize(float value);
}
public class iTextSharp.text.pdf.FdfReader : PdfReader {
    internal Hashtable fields;
    internal string fileSpec;
    internal PdfName encoding;
    public Hashtable Fields { get; }
    public string FileSpec { get; }
    public FdfReader(string filename);
    public FdfReader(Byte[] pdfIn);
    public FdfReader(Uri url);
    public FdfReader(Stream isp);
    protected internal virtual void ReadPdf();
    protected virtual void KidNode(PdfDictionary merged, string name);
    protected virtual void ReadFields();
    public Hashtable get_Fields();
    public PdfDictionary GetField(string name);
    public string GetFieldValue(string name);
    public string get_FileSpec();
}
public class iTextSharp.text.pdf.FdfWriter : object {
    private static Byte[] HEADER_FDF;
    private Hashtable fields;
    private string file;
    public string File { get; public set; }
    private static FdfWriter();
    public void WriteTo(Stream os);
    internal bool SetField(string field, PdfObject value);
    internal void IterateFields(Hashtable values, Hashtable map, string name);
    public bool RemoveField(string field);
    public Hashtable GetFields();
    public string GetField(string field);
    public bool SetFieldAsName(string field, string value);
    public bool SetFieldAsString(string field, string value);
    public bool SetFieldAsAction(string field, PdfAction action);
    public void SetFields(FdfReader fdf);
    public void SetFields(PdfReader pdf);
    public void SetFields(AcroFields af);
    public string get_File();
    public void set_File(string value);
}
internal class iTextSharp.text.pdf.FontDetails : object {
    private PdfIndirectReference indirectReference;
    private PdfName fontName;
    private BaseFont baseFont;
    private TrueTypeFontUnicode ttu;
    private CJKFont cjkFont;
    private Byte[] shortTag;
    private Hashtable longTag;
    private IntHashtable cjkTag;
    private int fontType;
    private bool symbolic;
    protected bool subset;
    internal PdfIndirectReference IndirectReference { get; }
    internal PdfName FontName { get; }
    internal BaseFont BaseFont { get; }
    public bool Subset { get; public set; }
    internal FontDetails(PdfName fontName, PdfIndirectReference indirectReference, BaseFont baseFont);
    internal PdfIndirectReference get_IndirectReference();
    internal PdfName get_FontName();
    internal BaseFont get_BaseFont();
    internal Byte[] ConvertToBytes(string text);
    internal void WriteFont(PdfWriter writer);
    public void set_Subset(bool value);
    public bool get_Subset();
}
public class iTextSharp.text.pdf.FontSelector : object {
    protected ArrayList fonts;
    public void AddFont(Font font);
    public Phrase Process(string text);
}
public class iTextSharp.text.pdf.GlyphList : object {
    private static Hashtable unicode2names;
    private static Hashtable names2unicode;
    private static GlyphList();
    public static Int32[] NameToUnicode(string name);
    public static string UnicodeToName(int num);
}
public class iTextSharp.text.pdf.GrayColor : ExtendedColor {
    private float cgray;
    public static GrayColor GRAYBLACK;
    public static GrayColor GRAYWHITE;
    public float Gray { get; }
    public GrayColor(int intGray);
    public GrayColor(float floatGray);
    private static GrayColor();
    public float get_Gray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.ByteVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Byte[] arr;
    private int n;
    public Byte[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public byte Item { get; public set; }
    public ByteVector(int capacity);
    public ByteVector(Byte[] a);
    public ByteVector(Byte[] a, int capacity);
    private static ByteVector();
    public Byte[] get_Arr();
    public int get_Length();
    public int get_Capacity();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public int Alloc(int size);
    public void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.hyphenation.CharVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int BLOCK_SIZE;
    private Char[] array;
    private int n;
    public Char[] Arr { get; }
    public int Length { get; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public CharVector(int capacity);
    public CharVector(Char[] a);
    public CharVector(Char[] a, int capacity);
    private static CharVector();
    public void Clear();
    public sealed virtual object Clone();
    public Char[] get_Arr();
    public int get_Length();
    public int get_Capacity();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public int Alloc(int size);
    public void TrimToSize();
}
public class iTextSharp.text.pdf.hyphenation.Hyphen : object {
    public string preBreak;
    public string noBreak;
    public string postBreak;
    internal Hyphen(string pre, string no, string post);
    internal Hyphen(string pre);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenation : object {
    private Int32[] hyphenPoints;
    private string word;
    private int len;
    public int Length { get; }
    public Int32[] HyphenationPoints { get; }
    internal Hyphenation(string word, Int32[] points);
    public int get_Length();
    public string GetPreHyphenText(int index);
    public string GetPostHyphenText(int index);
    public Int32[] get_HyphenationPoints();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.hyphenation.HyphenationException : Exception {
    public HyphenationException(string msg);
}
public class iTextSharp.text.pdf.hyphenation.HyphenationTree : TernaryTree {
    protected ByteVector vspace;
    protected Hashtable stoplist;
    protected TernaryTree classmap;
    private TernaryTree ivalues;
    protected int PackValues(string values);
    protected string UnpackValues(int k);
    public void LoadSimplePatterns(Stream stream);
    public string FindPattern(string pat);
    protected int Hstrcmp(Char[] s, int si, Char[] t, int ti);
    protected Byte[] GetValues(int k);
    protected void SearchPatterns(Char[] word, int index, Byte[] il);
    public Hyphenation Hyphenate(string word, int remainCharCount, int pushCharCount);
    public Hyphenation Hyphenate(Char[] w, int offset, int len, int remainCharCount, int pushCharCount);
    public sealed virtual void AddClass(string chargroup);
    public sealed virtual void AddException(string word, ArrayList hyphenatedword);
    public sealed virtual void AddPattern(string pattern, string ivalue);
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.hyphenation.Hyphenator : object {
    private static string defaultHyphLocation;
    private static Hashtable hyphenTrees;
    private HyphenationTree hyphenTree;
    private int remainCharCount;
    private int pushCharCount;
    public Hyphenator(string lang, string country, int leftMin, int rightMin);
    private static Hyphenator();
    public static HyphenationTree GetHyphenationTree(string lang, string country);
    public static HyphenationTree GetResourceHyphenationTree(string key);
    public static Hyphenation Hyphenate(string lang, string country, string word, int leftMin, int rightMin);
    public static Hyphenation Hyphenate(string lang, string country, Char[] word, int offset, int len, int leftMin, int rightMin);
    public void SetMinRemainCharCount(int min);
    public void SetMinPushCharCount(int min);
    public void SetLanguage(string lang, string country);
    public Hyphenation Hyphenate(Char[] word, int offset, int len);
    public Hyphenation Hyphenate(string word);
}
public interface iTextSharp.text.pdf.hyphenation.IPatternConsumer {
    public abstract virtual void AddClass(string chargroup);
    public abstract virtual void AddException(string word, ArrayList hyphenatedword);
    public abstract virtual void AddPattern(string pattern, string values);
}
public class iTextSharp.text.pdf.hyphenation.SimplePatternParser : object {
    internal static int ELEM_CLASSES;
    internal static int ELEM_EXCEPTIONS;
    internal static int ELEM_PATTERNS;
    internal static int ELEM_HYPHEN;
    internal int currElement;
    internal IPatternConsumer consumer;
    internal StringBuilder token;
    internal ArrayList exception;
    internal char hyphenChar;
    public void Parse(Stream stream, IPatternConsumer consumer);
    protected static string GetPattern(string word);
    protected ArrayList NormalizeException(ArrayList ex);
    protected string GetExceptionWord(ArrayList ex);
    protected static string GetInterletterValues(string pat);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, Hashtable h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.hyphenation.TernaryTree : object {
    protected Char[] lo;
    protected Char[] hi;
    protected Char[] eq;
    protected Char[] sc;
    protected CharVector kv;
    protected char root;
    protected char freenode;
    protected int length;
    protected static int BLOCK_SIZE;
    public int Size { get; }
    public Iterator Keys { get; }
    private static TernaryTree();
    protected void Init();
    public void Insert(string key, char val);
    public void Insert(Char[] key, int start, char val);
    private char Insert(char p, Char[] key, int start, char val);
    public static int Strcmp(Char[] a, int startA, Char[] b, int startB);
    public static int Strcmp(string str, Char[] a, int start);
    public static void Strcpy(Char[] dst, int di, Char[] src, int si);
    public static int Strlen(Char[] a, int start);
    public static int Strlen(Char[] a);
    public int Find(string key);
    public int Find(Char[] key, int start);
    public bool Knows(string key);
    private void RedimNodeArrays(int newsize);
    public int get_Size();
    public sealed virtual object Clone();
    protected void InsertBalanced(String[] k, Char[] v, int offset, int n);
    public void Balance();
    public void TrimToSize();
    private void Compact(CharVector kx, TernaryTree map, char p);
    public Iterator get_Keys();
    public virtual void PrintStats();
}
public class iTextSharp.text.pdf.HyphenationAuto : object {
    protected Hyphenator hyphenator;
    protected string post;
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public HyphenationAuto(string lang, string country, int leftMin, int rightMin);
    public sealed virtual string get_HyphenSymbol();
    public sealed virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public sealed virtual string get_HyphenatedWordPost();
}
public class iTextSharp.text.pdf.ICC_Profile : object {
    protected Byte[] data;
    protected int numComponents;
    private static Hashtable cstags;
    public Byte[] Data { get; }
    public int NumComponents { get; }
    private static ICC_Profile();
    public static ICC_Profile GetInstance(Byte[] data);
    public static ICC_Profile GetInstance(Stream file);
    public static ICC_Profile GetInstance(string fname);
    public Byte[] get_Data();
    public int get_NumComponents();
}
public interface iTextSharp.text.pdf.IExtraEncoding {
    public abstract virtual Byte[] CharToByte(string text, string encoding);
    public abstract virtual Byte[] CharToByte(char char1, string encoding);
    public abstract virtual string ByteToChar(Byte[] b, string encoding);
}
public interface iTextSharp.text.pdf.IHyphenationEvent {
    public string HyphenSymbol { get; }
    public string HyphenatedWordPost { get; }
    public abstract virtual string get_HyphenSymbol();
    public abstract virtual string GetHyphenatedWordPre(string word, BaseFont font, float fontSize, float remainingWidth);
    public abstract virtual string get_HyphenatedWordPost();
}
public interface iTextSharp.text.pdf.interfaces.IPdfAnnotations {
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public abstract virtual PdfAcroForm get_AcroForm();
    public abstract virtual void AddAnnotation(PdfAnnotation annot);
    public abstract virtual void AddCalculationOrder(PdfFormField annot);
    public abstract virtual void set_SigFlags(int value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfDocumentActions {
    public abstract virtual void SetOpenAction(string name);
    public abstract virtual void SetOpenAction(PdfAction action);
    public abstract virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
}
public interface iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings {
    public abstract virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public abstract virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
public interface iTextSharp.text.pdf.interfaces.IPdfPageActions {
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    public abstract virtual void SetPageAction(PdfName actionType, PdfAction action);
    public abstract virtual void set_Duration(int value);
    public abstract virtual void set_Transition(PdfTransition value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfRunDirection {
    public int RunDirection { get; public set; }
    public abstract virtual void set_RunDirection(int value);
    public abstract virtual int get_RunDirection();
}
public interface iTextSharp.text.pdf.interfaces.IPdfVersion {
    unknown char PdfVersion {public set; }
    public abstract virtual void set_PdfVersion(char value);
    public abstract virtual void SetAtLeastPdfVersion(char version);
    public abstract virtual void SetPdfVersion(PdfName version);
    public abstract virtual void AddDeveloperExtension(PdfDeveloperExtension de);
}
public interface iTextSharp.text.pdf.interfaces.IPdfViewerPreferences {
    unknown int ViewerPreferences {public set; }
    public abstract virtual void set_ViewerPreferences(int value);
    public abstract virtual void AddViewerPreference(PdfName key, PdfObject value);
}
public interface iTextSharp.text.pdf.interfaces.IPdfXConformance {
    public int PDFXConformance { get; public set; }
    public abstract virtual void set_PDFXConformance(int value);
    public abstract virtual int get_PDFXConformance();
    public abstract virtual bool IsPdfX();
}
public class iTextSharp.text.pdf.intern.PdfAnnotationsImp : object {
    protected internal PdfAcroForm acroForm;
    protected internal ArrayList annotations;
    protected internal ArrayList delayedAnnotations;
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public PdfAnnotationsImp(PdfWriter writer);
    public bool HasValidAcroForm();
    public PdfAcroForm get_AcroForm();
    public void set_SigFlags(int value);
    public void AddCalculationOrder(PdfFormField formField);
    public void AddAnnotation(PdfAnnotation annot);
    public void AddPlainAnnotation(PdfAnnotation annot);
    private void AddFormFieldRaw(PdfFormField field);
    public bool HasUnusedAnnotations();
    public void ResetAnnotations();
    public PdfArray RotateAnnotations(PdfWriter writer, Rectangle pageSize);
    public static PdfAnnotation ConvertAnnotation(PdfWriter writer, Annotation annot, Rectangle defaultRect);
}
public class iTextSharp.text.pdf.intern.PdfVersionImp : object {
    public static Byte[][] HEADER;
    protected bool headerWasWritten;
    protected bool appendmode;
    protected char header_version;
    protected PdfName catalog_version;
    protected PdfDictionary extensions;
    unknown char PdfVersion {public set; }
    private static PdfVersionImp();
    public sealed virtual void set_PdfVersion(char value);
    public sealed virtual void SetAtLeastPdfVersion(char version);
    public sealed virtual void SetPdfVersion(PdfName version);
    public void SetAppendmode(bool appendmode);
    public void WriteHeader(OutputStreamCounter os);
    public PdfName GetVersionAsName(char version);
    public Byte[] GetVersionAsByteArray(char version);
    public void AddToCatalog(PdfDictionary catalog);
    public sealed virtual void AddDeveloperExtension(PdfDeveloperExtension de);
}
public class iTextSharp.text.pdf.intern.PdfViewerPreferencesImp : object {
    private static int viewerPreferencesMask;
    public static PdfName[] VIEWER_PREFERENCES;
    public static PdfName[] NONFULLSCREENPAGEMODE_PREFERENCES;
    public static PdfName[] DIRECTION_PREFERENCES;
    public static PdfName[] PAGE_BOUNDARIES;
    public static PdfName[] PRINTSCALING_PREFERENCES;
    public static PdfName[] DUPLEX_PREFERENCES;
    private int pageLayoutAndMode;
    private PdfDictionary viewerPreferences;
    public int PageLayoutAndMode { get; }
    unknown int ViewerPreferences {public set; }
    private static PdfViewerPreferencesImp();
    public int get_PageLayoutAndMode();
    public PdfDictionary GetViewerPreferences();
    public sealed virtual void set_ViewerPreferences(int value);
    private int GetIndex(PdfName key);
    private bool IsPossibleValue(PdfName value, PdfName[] accepted);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public void AddToCatalog(PdfDictionary catalog);
    public static PdfViewerPreferencesImp GetViewerPreferences(PdfDictionary catalog);
}
public class iTextSharp.text.pdf.intern.PdfXConformanceImp : object {
    public static int PDFXKEY_COLOR;
    public static int PDFXKEY_CMYK;
    public static int PDFXKEY_RGB;
    public static int PDFXKEY_FONT;
    public static int PDFXKEY_IMAGE;
    public static int PDFXKEY_GSTATE;
    public static int PDFXKEY_LAYER;
    protected internal int pdfxConformance;
    public int PDFXConformance { get; public set; }
    public sealed virtual void set_PDFXConformance(int value);
    public sealed virtual int get_PDFXConformance();
    public sealed virtual bool IsPdfX();
    public bool IsPdfX1A2001();
    public bool IsPdfX32002();
    public bool IsPdfA1();
    public bool IsPdfA1A();
    public void CompleteInfoDictionary(PdfDictionary info);
    public void CompleteExtraCatalog(PdfDictionary extraCatalog);
    public static void CheckPDFXConformance(PdfWriter writer, int key, object obj1);
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.IntHashtable : object {
    private IntHashtableEntry[] table;
    private int count;
    private int threshold;
    private float loadFactor;
    public int Size { get; }
    public int Item { get; public set; }
    public IntHashtable(int initialCapacity, float loadFactor);
    public IntHashtable(int initialCapacity);
    public int get_Size();
    public bool IsEmpty();
    public bool Contains(int value);
    public bool ContainsKey(int key);
    public int get_Item(int key);
    public void set_Item(int key, int value);
    protected void Rehash();
    public int Remove(int key);
    public void Clear();
    public IntHashtable Clone();
    public Int32[] ToOrderedKeys();
    public Int32[] GetKeys();
    public IntHashtableIterator GetEntryIterator();
}
public interface iTextSharp.text.pdf.IOcspClient {
    public abstract virtual Byte[] GetEncoded();
}
public interface iTextSharp.text.pdf.IPdfOCG {
    public PdfIndirectReference Ref { get; }
    public PdfObject PdfObject { get; }
    public abstract virtual PdfIndirectReference get_Ref();
    public abstract virtual PdfObject get_PdfObject();
}
public interface iTextSharp.text.pdf.IPdfPageEvent {
    public abstract virtual void OnOpenDocument(PdfWriter writer, Document document);
    public abstract virtual void OnStartPage(PdfWriter writer, Document document);
    public abstract virtual void OnEndPage(PdfWriter writer, Document document);
    public abstract virtual void OnCloseDocument(PdfWriter writer, Document document);
    public abstract virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public abstract virtual void OnChapterEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public abstract virtual void OnSectionEnd(PdfWriter writer, Document document, float paragraphPosition);
    public abstract virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public interface iTextSharp.text.pdf.IPdfPCellEvent {
    public abstract virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.IPdfPTableEvent {
    public abstract virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
}
public interface iTextSharp.text.pdf.ITSAClient {
    public abstract virtual int GetTokenSizeEstimate();
    public abstract virtual Byte[] GetTimeStampToken(PdfPKCS7 caller, Byte[] imprint);
}
public class iTextSharp.text.pdf.LZWDecoder : object {
    private Byte[][] stringTable;
    private Byte[] data;
    private Stream uncompData;
    private int tableIndex;
    private int bitsToGet;
    private int bytePointer;
    private int nextData;
    private int nextBits;
    internal Int32[] andTable;
    public int NextCode { get; }
    public void Decode(Byte[] data, Stream uncompData);
    public void InitializeStringTable();
    public void WriteString(Byte[] str);
    public void AddStringToTable(Byte[] oldstring, byte newstring);
    public void AddStringToTable(Byte[] str);
    public Byte[] ComposeString(Byte[] oldstring, byte newstring);
    public int get_NextCode();
}
public class iTextSharp.text.pdf.MultiColumnText : object {
    public static float AUTOMATIC;
    private float desiredHeight;
    private float totalHeight;
    private bool overflow;
    private float top;
    private ColumnText columnText;
    private ArrayList columnDefs;
    private bool simple;
    private int currentColumn;
    private float nextY;
    private bool columnsRightToLeft;
    private PdfDocument document;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public int CurrentColumn { get; }
    unknown float SpaceCharRatio {public set; }
    unknown int RunDirection {public set; }
    unknown int ArabicOptions {public set; }
    unknown int Alignment {public set; }
    public MultiColumnText(float height);
    public MultiColumnText(float top, float height);
    public bool IsOverflow();
    public void UseColumnParams(ColumnText sourceColumn);
    public void AddColumn(Single[] left, Single[] right);
    public void AddSimpleColumn(float left, float right);
    public void AddRegularColumns(float left, float right, float gutterWidth, int numColumns);
    public void AddText(Phrase phrase);
    public void AddText(Chunk chunk);
    public void AddElement(IElement element);
    public float Write(PdfContentByte canvas, PdfDocument document, float documentY);
    private void NewPage();
    private float GetHeight(Single[] left, Single[] right);
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    private float GetColumnBottom();
    public void NextColumn();
    public int get_CurrentColumn();
    public void ResetCurrentColumn();
    public bool ShiftCurrentColumn();
    public void SetColumnsRightToLeft(bool direction);
    public void set_SpaceCharRatio(float value);
    public void set_RunDirection(int value);
    public void set_ArabicOptions(int value);
    public void set_Alignment(int value);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.OcspClientBouncyCastle : object {
    private X509Certificate rootCert;
    private X509Certificate checkCert;
    private string url;
    public OcspClientBouncyCastle(X509Certificate checkCert, X509Certificate rootCert, string url);
    private static OcspReq GenerateOCSPRequest(X509Certificate issuerCert, BigInteger serialNumber);
    public sealed virtual Byte[] GetEncoded();
}
public class iTextSharp.text.pdf.OutputStreamCounter : Stream {
    protected Stream outc;
    protected int counter;
    public int Counter { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamCounter(Stream _outc);
    public int get_Counter();
    public void ResetCounter();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class iTextSharp.text.pdf.OutputStreamEncryption : Stream {
    private static int AES_128;
    protected Stream outc;
    protected ARCFOUREncryption arcfour;
    protected AESCipher cipher;
    private Byte[] buf;
    private bool aes;
    private bool finished;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OutputStreamEncryption(Stream outc, Byte[] key, int off, int len, int revision);
    public OutputStreamEncryption(Stream outc, Byte[] key, int revision);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void WriteByte(byte value);
    public void Finish();
}
public class iTextSharp.text.pdf.PageResources : object {
    protected PdfDictionary fontDictionary;
    protected PdfDictionary xObjectDictionary;
    protected PdfDictionary colorDictionary;
    protected PdfDictionary patternDictionary;
    protected PdfDictionary shadingDictionary;
    protected PdfDictionary extGStateDictionary;
    protected PdfDictionary propertyDictionary;
    protected Hashtable forbiddenNames;
    protected PdfDictionary originalResources;
    protected Int32[] namePtr;
    protected Hashtable usedNames;
    internal PdfDictionary Resources { get; }
    internal void SetOriginalResources(PdfDictionary resources, Int32[] newNamePtr);
    internal PdfName TranslateName(PdfName name);
    internal PdfName AddFont(PdfName name, PdfIndirectReference reference);
    internal PdfName AddXObject(PdfName name, PdfIndirectReference reference);
    internal PdfName AddColor(PdfName name, PdfIndirectReference reference);
    internal void AddDefaultColor(PdfName name, PdfObject obj);
    internal void AddDefaultColor(PdfDictionary dic);
    internal void AddDefaultColorDiff(PdfDictionary dic);
    internal PdfName AddShading(PdfName name, PdfIndirectReference reference);
    internal PdfName AddPattern(PdfName name, PdfIndirectReference reference);
    internal PdfName AddExtGState(PdfName name, PdfIndirectReference reference);
    internal PdfName AddProperty(PdfName name, PdfIndirectReference reference);
    internal PdfDictionary get_Resources();
    internal bool HasResources();
}
public class iTextSharp.text.pdf.PatternColor : ExtendedColor {
    private PdfPatternPainter painter;
    public PdfPatternPainter Painter { get; }
    public PatternColor(PdfPatternPainter painter);
    public PdfPatternPainter get_Painter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.PdfAcroForm : PdfDictionary {
    private PdfWriter writer;
    private Hashtable fieldTemplates;
    private PdfArray documentFields;
    private PdfArray calculationOrder;
    private int sigFlags;
    unknown bool NeedAppearances {public set; }
    unknown int SigFlags {public set; }
    public PdfAcroForm(PdfWriter writer);
    public void set_NeedAppearances(bool value);
    public void AddFieldTemplates(Hashtable ft);
    public void AddDocumentField(PdfIndirectReference piref);
    public bool IsValid();
    public void AddCalculationOrder(PdfFormField formField);
    public void set_SigFlags(int value);
    public void AddFormField(PdfFormField formField);
    public PdfFormField AddHtmlPostButton(string name, string caption, string value, string url, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddResetButton(string name, string caption, string value, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddMap(string name, string value, string url, PdfContentByte appearance, float llx, float lly, float urx, float ury);
    public void SetButtonParams(PdfFormField button, int characteristics, string name, string value);
    public void DrawButton(PdfFormField button, string caption, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddHiddenField(string name, string value);
    public PdfFormField AddSingleLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddMultiLineTextField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSingleLinePasswordField(string name, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void SetTextFieldParams(PdfFormField field, string text, string name, float llx, float lly, float urx, float ury);
    public void DrawSingleLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void DrawMultiLineOfText(PdfFormField field, string text, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddCheckBox(string name, string value, bool status, float llx, float lly, float urx, float ury);
    public void SetCheckBoxParams(PdfFormField field, string name, string value, bool status, float llx, float lly, float urx, float ury);
    public void DrawCheckBoxAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public PdfFormField GetRadioGroup(string name, string defaultValue, bool noToggleToOff);
    public void AddRadioGroup(PdfFormField radiogroup);
    public PdfFormField AddRadioButton(PdfFormField radiogroup, string value, float llx, float lly, float urx, float ury);
    public void DrawRadioAppearences(PdfFormField field, string value, float llx, float lly, float urx, float ury);
    public PdfFormField AddSelectList(string name, String[] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddSelectList(string name, String[0...,0...] options, string defaultValue, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddComboBox(string name, String[] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public PdfFormField AddComboBox(string name, String[0...,0...] options, string defaultValue, bool editable, BaseFont font, float fontSize, float llx, float lly, float urx, float ury);
    public void SetChoiceParams(PdfFormField field, string name, string defaultValue, float llx, float lly, float urx, float ury);
    public PdfFormField AddSignature(string name, float llx, float lly, float urx, float ury);
    public void SetSignatureParams(PdfFormField field, string name, float llx, float lly, float urx, float ury);
    public void DrawSignatureAppearences(PdfFormField field, float llx, float lly, float urx, float ury);
}
public class iTextSharp.text.pdf.PdfAction : PdfDictionary {
    public static int FIRSTPAGE;
    public static int PREVPAGE;
    public static int NEXTPAGE;
    public static int LASTPAGE;
    public static int PRINTDIALOG;
    public static int SUBMIT_EXCLUDE;
    public static int SUBMIT_INCLUDE_NO_VALUE_FIELDS;
    public static int SUBMIT_HTML_FORMAT;
    public static int SUBMIT_HTML_GET;
    public static int SUBMIT_COORDINATES;
    public static int SUBMIT_XFDF;
    public static int SUBMIT_INCLUDE_APPEND_SAVES;
    public static int SUBMIT_INCLUDE_ANNOTATIONS;
    public static int SUBMIT_PDF;
    public static int SUBMIT_CANONICAL_FORMAT;
    public static int SUBMIT_EXCL_NON_USER_ANNOTS;
    public static int SUBMIT_EXCL_F_KEY;
    public static int SUBMIT_EMBED_FORM;
    public static int RESET_EXCLUDE;
    public PdfAction(Uri url);
    public PdfAction(Uri url, bool isMap);
    public PdfAction(string url);
    public PdfAction(string url, bool isMap);
    internal PdfAction(PdfIndirectReference destination);
    public PdfAction(string filename, string name);
    public PdfAction(string filename, int page);
    public PdfAction(int named);
    public PdfAction(string application, string parameters, string operation, string defaultDir);
    public static PdfAction CreateLaunch(string application, string parameters, string operation, string defaultDir);
    public static PdfAction Rendition(string file, PdfFileSpecification fs, string mimeType, PdfIndirectReference refi);
    public static PdfAction JavaScript(string code, PdfWriter writer, bool unicode);
    public static PdfAction JavaScript(string code, PdfWriter writer);
    internal static PdfAction CreateHide(PdfObject obj, bool hide);
    public static PdfAction CreateHide(PdfAnnotation annot, bool hide);
    public static PdfAction CreateHide(string name, bool hide);
    internal static PdfArray BuildArray(Object[] names);
    public static PdfAction CreateHide(Object[] names, bool hide);
    public static PdfAction CreateSubmitForm(string file, Object[] names, int flags);
    public static PdfAction CreateResetForm(Object[] names, int flags);
    public static PdfAction CreateImportData(string file);
    public void Next(PdfAction na);
    public static PdfAction GotoLocalPage(int page, PdfDestination dest, PdfWriter writer);
    public static PdfAction GotoLocalPage(string dest, bool isName);
    public static PdfAction GotoRemotePage(string filename, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, string dest, bool isName, bool newWindow);
    public static PdfAction GotoEmbedded(string filename, PdfTargetDictionary target, PdfObject dest, bool newWindow);
    public static PdfAction SetOCGstate(ArrayList state, bool preserveRB);
}
public class iTextSharp.text.pdf.PdfAnnotation : PdfDictionary {
    public static int FLAGS_INVISIBLE;
    public static int FLAGS_HIDDEN;
    public static int FLAGS_PRINT;
    public static int FLAGS_NOZOOM;
    public static int FLAGS_NOROTATE;
    public static int FLAGS_NOVIEW;
    public static int FLAGS_READONLY;
    public static int FLAGS_LOCKED;
    public static int FLAGS_TOGGLENOVIEW;
    public static int MARKUP_HIGHLIGHT;
    public static int MARKUP_UNDERLINE;
    public static int MARKUP_STRIKEOUT;
    public static int MARKUP_SQUIGGLY;
    public static PdfName HIGHLIGHT_NONE;
    public static PdfName HIGHLIGHT_INVERT;
    public static PdfName HIGHLIGHT_OUTLINE;
    public static PdfName HIGHLIGHT_PUSH;
    public static PdfName HIGHLIGHT_TOGGLE;
    public static PdfName APPEARANCE_NORMAL;
    public static PdfName APPEARANCE_ROLLOVER;
    public static PdfName APPEARANCE_DOWN;
    public static PdfName AA_ENTER;
    public static PdfName AA_EXIT;
    public static PdfName AA_DOWN;
    public static PdfName AA_UP;
    public static PdfName AA_FOCUS;
    public static PdfName AA_BLUR;
    public static PdfName AA_JS_KEY;
    public static PdfName AA_JS_FORMAT;
    public static PdfName AA_JS_CHANGE;
    public static PdfName AA_JS_OTHER_CHANGE;
    protected internal PdfWriter writer;
    protected internal PdfIndirectReference reference;
    protected internal Hashtable templates;
    protected internal bool form;
    protected internal bool annotation;
    protected internal bool used;
    private int placeInPage;
    public PdfIndirectReference IndirectReference { get; }
    unknown PdfContentByte DefaultAppearanceString {public set; }
    unknown int Flags {public set; }
    unknown PdfBorderArray Border {public set; }
    unknown PdfBorderDictionary BorderStyle {public set; }
    unknown string AppearanceState {public set; }
    unknown Color Color {public set; }
    unknown string Title {public set; }
    unknown PdfAnnotation Popup {public set; }
    unknown PdfAction Action {public set; }
    public Hashtable Templates { get; }
    unknown int Page {public set; }
    public int PlaceInPage { get; public set; }
    unknown int Rotate {public set; }
    internal PdfDictionary MK { get; }
    unknown int MKRotation {public set; }
    unknown Color MKBorderColor {public set; }
    unknown Color MKBackgroundColor {public set; }
    unknown string MKNormalCaption {public set; }
    unknown string MKRolloverCaption {public set; }
    unknown string MKAlternateCaption {public set; }
    unknown PdfTemplate MKNormalIcon {public set; }
    unknown PdfTemplate MKRolloverIcon {public set; }
    unknown PdfTemplate MKAlternateIcon {public set; }
    unknown int MKTextPosition {public set; }
    unknown IPdfOCG Layer {public set; }
    unknown string Name {public set; }
    public PdfAnnotation(PdfWriter writer, Rectangle rect);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfString title, PdfString content);
    public PdfAnnotation(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    private static PdfAnnotation();
    public static PdfAnnotation CreateScreen(PdfWriter writer, Rectangle rect, string clipTitle, PdfFileSpecification fs, string mimeType, bool playOnDisplay);
    public PdfIndirectReference get_IndirectReference();
    public static PdfAnnotation CreateText(PdfWriter writer, Rectangle rect, string title, string contents, bool open, string icon);
    protected static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, PdfAction action);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, string namedDestination);
    public static PdfAnnotation CreateLink(PdfWriter writer, Rectangle rect, PdfName highlight, int page, PdfDestination dest);
    public static PdfAnnotation CreateFreeText(PdfWriter writer, Rectangle rect, string contents, PdfContentByte defaultAppearance);
    public static PdfAnnotation CreateLine(PdfWriter writer, Rectangle rect, string contents, float x1, float y1, float x2, float y2);
    public static PdfAnnotation CreateSquareCircle(PdfWriter writer, Rectangle rect, string contents, bool square);
    public static PdfAnnotation CreateMarkup(PdfWriter writer, Rectangle rect, string contents, int type, Single[] quadPoints);
    public static PdfAnnotation CreateStamp(PdfWriter writer, Rectangle rect, string contents, string name);
    public static PdfAnnotation CreateInk(PdfWriter writer, Rectangle rect, string contents, Single[][] inkList);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, Byte[] fileStore, string file, string fileDisplay);
    public static PdfAnnotation CreateFileAttachment(PdfWriter writer, Rectangle rect, string contents, PdfFileSpecification fs);
    public static PdfAnnotation CreatePopup(PdfWriter writer, Rectangle rect, string contents, bool open);
    public void set_DefaultAppearanceString(PdfContentByte value);
    public void set_Flags(int value);
    public void set_Border(PdfBorderArray value);
    public void set_BorderStyle(PdfBorderDictionary value);
    public void SetHighlighting(PdfName highlight);
    public void SetAppearance(PdfName ap, PdfTemplate template);
    public void SetAppearance(PdfName ap, string state, PdfTemplate template);
    public void set_AppearanceState(string value);
    public void set_Color(Color value);
    public void set_Title(string value);
    public void set_Popup(PdfAnnotation value);
    public void set_Action(PdfAction value);
    public void SetAdditionalActions(PdfName key, PdfAction action);
    internal virtual bool IsUsed();
    public virtual void SetUsed();
    public Hashtable get_Templates();
    public bool IsForm();
    public bool IsAnnotation();
    public void set_Page(int value);
    public void SetPage();
    public int get_PlaceInPage();
    public void set_PlaceInPage(int value);
    public static PdfAnnotation ShallowDuplicate(PdfAnnotation annot);
    public void set_Rotate(int value);
    internal PdfDictionary get_MK();
    public void set_MKRotation(int value);
    public static PdfArray GetMKColor(Color color);
    public void set_MKBorderColor(Color value);
    public void set_MKBackgroundColor(Color value);
    public void set_MKNormalCaption(string value);
    public void set_MKRolloverCaption(string value);
    public void set_MKAlternateCaption(string value);
    public void set_MKNormalIcon(PdfTemplate value);
    public void set_MKRolloverIcon(PdfTemplate value);
    public void set_MKAlternateIcon(PdfTemplate value);
    public void SetMKIconFit(PdfName scale, PdfName scalingType, float leftoverLeft, float leftoverBottom, bool fitInBounds);
    public void set_MKTextPosition(int value);
    public void set_Layer(IPdfOCG value);
    public void set_Name(string value);
}
public class iTextSharp.text.pdf.PdfAppearance : PdfTemplate {
    public static Hashtable stdFieldFontNames;
    public PdfContentByte Duplicate { get; }
    private static PdfAppearance();
    internal PdfAppearance(PdfIndirectReference iref);
    internal PdfAppearance(PdfWriter wr);
    public static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height);
    internal static PdfAppearance CreateAppearance(PdfWriter writer, float width, float height, PdfName forcedName);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual PdfContentByte get_Duplicate();
}
[DefaultMemberAttribute("Item")]
public class iTextSharp.text.pdf.PdfArray : PdfObject {
    protected ArrayList arrayList;
    public PdfObject Item { get; public set; }
    public ArrayList ArrayList { get; }
    public int Size { get; }
    public PdfArray(PdfObject obj);
    public PdfArray(Single[] values);
    public PdfArray(Int32[] values);
    public PdfArray(ArrayList l);
    public PdfArray(PdfArray array);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public PdfObject get_Item(int idx);
    public void set_Item(int idx, PdfObject value);
    public PdfObject Remove(int idx);
    public ArrayList get_ArrayList();
    public int get_Size();
    public bool IsEmpty();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void Add(int index, PdfObject element);
    public virtual void AddFirst(PdfObject obj);
    public bool Contains(PdfObject obj);
    public ListIterator GetListIterator();
    public virtual string ToString();
    public PdfObject GetDirectObject(int idx);
    public PdfDictionary GetAsDict(int idx);
    public PdfArray GetAsArray(int idx);
    public PdfStream GetAsStream(int idx);
    public PdfString GetAsString(int idx);
    public PdfNumber GetAsNumber(int idx);
    public PdfName GetAsName(int idx);
    public PdfBoolean GetAsBoolean(int idx);
    public PdfIndirectReference GetAsIndirectObject(int idx);
}
public class iTextSharp.text.pdf.PdfBoolean : PdfObject {
    public static string TRUE;
    public static string FALSE;
    public static PdfBoolean PDFTRUE;
    public static PdfBoolean PDFFALSE;
    private bool value;
    public bool BooleanValue { get; }
    public PdfBoolean(bool value);
    public PdfBoolean(string value);
    private static PdfBoolean();
    public bool get_BooleanValue();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfBorderArray : PdfArray {
    public PdfBorderArray(float hRadius, float vRadius, float width);
    public PdfBorderArray(float hRadius, float vRadius, float width, PdfDashPattern dash);
}
public class iTextSharp.text.pdf.PdfBorderDictionary : PdfDictionary {
    public static int STYLE_SOLID;
    public static int STYLE_DASHED;
    public static int STYLE_BEVELED;
    public static int STYLE_INSET;
    public static int STYLE_UNDERLINE;
    public PdfBorderDictionary(float borderWidth, int borderStyle, PdfDashPattern dashes);
    public PdfBorderDictionary(float borderWidth, int borderStyle);
}
public class iTextSharp.text.pdf.PdfCell : Rectangle {
    private ArrayList lines;
    private PdfLine line;
    private ArrayList images;
    private float leading;
    private int rownumber;
    private int rowspan;
    private float cellspacing;
    private float cellpadding;
    private bool header;
    private float contentHeight;
    private bool useAscender;
    private bool useDescender;
    private bool useBorderPadding;
    private int verticalAlignment;
    private PdfLine firstLine;
    private PdfLine lastLine;
    private int groupNumber;
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; public set; }
    private float FirstLineRealHeight { get; }
    internal bool Header { get; }
    public int Size { get; }
    public float RemainingHeight { get; }
    public float Leading { get; }
    public int Rownumber { get; }
    public int Rowspan { get; }
    public float Cellspacing { get; }
    public float Cellpadding { get; }
    public int GroupNumber { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    public PdfCell(Cell cell, int rownumber, float left, float right, float top, float cellspacing, float cellpadding);
    private void AddList(List list, float left, float right, int alignment);
    public virtual float get_Left();
    public virtual float get_Right();
    public virtual float get_Top();
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    private void AddLine(PdfLine line);
    private PdfLine RemoveLine(int index);
    private void FlushCurrentLine();
    private float get_FirstLineRealHeight();
    private float GetBorderWidthInside(int side);
    private float AddImage(Image i, float left, float right, float extraHeight, int alignment);
    public ArrayList GetLines(float top, float bottom);
    public ArrayList GetImages(float top, float bottom);
    internal void SetHeader();
    internal bool get_Header();
    internal bool MayBeRemoved();
    public int get_Size();
    private float RemainingLinesHeight();
    public float get_RemainingHeight();
    public float get_Leading();
    public int get_Rownumber();
    public int get_Rowspan();
    public float get_Cellspacing();
    public float get_Cellpadding();
    protected void ProcessActions(IElement element, PdfAction action, ArrayList allActions);
    public int get_GroupNumber();
    public void set_GroupNumber(int value);
    public Rectangle Rectangle(float top, float bottom);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public void set_UseBorderPadding(bool value);
    public bool get_UseBorderPadding();
}
public class iTextSharp.text.pdf.PdfChunk : object {
    private static float ITALIC_ANGLE;
    private static Char[] singleSpace;
    private static PdfChunk[] thisChunk;
    private static Hashtable keysAttributes;
    private static Hashtable keysNoStroke;
    protected string value;
    protected string encoding;
    protected PdfFont font;
    protected BaseFont baseFont;
    protected ISplitCharacter splitCharacter;
    protected Hashtable attributes;
    protected Hashtable noStroke;
    protected bool newlineSplit;
    protected Image image;
    protected float offsetX;
    protected float offsetY;
    protected bool changeLeading;
    internal PdfFont Font { get; }
    internal Color Color { get; }
    internal float Width { get; }
    public float TextRise { get; }
    internal Image Image { get; }
    internal float ImageOffsetX { get; internal set; }
    internal float ImageOffsetY { get; internal set; }
    unknown string Value {internal set; }
    internal string Encoding { get; }
    internal int Length { get; }
    internal int LengthUtf32 { get; }
    public bool ChangeLeading { get; }
    private static PdfChunk();
    internal PdfChunk(string str, PdfChunk other);
    internal PdfChunk(Chunk chunk, PdfAction action);
    public int GetUnicodeEquivalent(int c);
    protected int GetWord(string text, int start);
    internal PdfChunk Split(float width);
    internal PdfChunk Truncate(float width);
    internal PdfFont get_Font();
    internal Color get_Color();
    internal float get_Width();
    public bool IsNewlineSplit();
    public float GetWidthCorrected(float charSpacing, float wordSpacing);
    public float get_TextRise();
    public float TrimLastSpace();
    public float TrimFirstSpace();
    internal object GetAttribute(string name);
    internal bool IsAttribute(string name);
    internal bool IsStroked();
    internal bool IsSeparator();
    internal bool IsHorizontalSeparator();
    internal bool IsTab();
    internal void AdjustLeft(float newValue);
    internal bool IsImage();
    internal Image get_Image();
    internal float get_ImageOffsetX();
    internal void set_ImageOffsetX(float value);
    internal float get_ImageOffsetY();
    internal void set_ImageOffsetY(float value);
    internal void set_Value(string value);
    public virtual string ToString();
    internal bool IsSpecialEncoding();
    internal string get_Encoding();
    internal int get_Length();
    internal int get_LengthUtf32();
    internal bool IsExtSplitCharacter(int start, int current, int end, Char[] cc, PdfChunk[] ck);
    internal string Trim(string str);
    public bool get_ChangeLeading();
    internal float GetCharWidth(int c);
    public static bool NoPrint(int c);
}
internal class iTextSharp.text.pdf.PdfColor : PdfArray {
    internal PdfColor(int red, int green, int blue);
    internal PdfColor(Color color);
}
public class iTextSharp.text.pdf.PdfContentByte : object {
    public static int ALIGN_CENTER;
    public static int ALIGN_LEFT;
    public static int ALIGN_RIGHT;
    public static int LINE_CAP_BUTT;
    public static int LINE_CAP_ROUND;
    public static int LINE_CAP_PROJECTING_SQUARE;
    public static int LINE_JOIN_MITER;
    public static int LINE_JOIN_ROUND;
    public static int LINE_JOIN_BEVEL;
    public static int TEXT_RENDER_MODE_FILL;
    public static int TEXT_RENDER_MODE_STROKE;
    public static int TEXT_RENDER_MODE_FILL_STROKE;
    public static int TEXT_RENDER_MODE_INVISIBLE;
    public static int TEXT_RENDER_MODE_FILL_CLIP;
    public static int TEXT_RENDER_MODE_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_FILL_STROKE_CLIP;
    public static int TEXT_RENDER_MODE_CLIP;
    private static Single[] unitRect;
    protected ByteBuffer content;
    protected PdfWriter writer;
    protected PdfDocument pdf;
    protected GraphicState state;
    protected ArrayList layerDepth;
    protected ArrayList stateList;
    protected int separator;
    private int mcDepth;
    private bool inText;
    private static Hashtable abrev;
    public ByteBuffer InternalBuffer { get; }
    public float XTLM { get; }
    public float YTLM { get; }
    public float CharacterSpacing { get; }
    public float WordSpacing { get; }
    public float HorizontalScaling { get; }
    public float Leading { get; }
    internal int Size { get; }
    public PdfOutline RootOutline { get; }
    public PdfWriter PdfWriter { get; }
    public PdfDocument PdfDocument { get; }
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    private static PdfContentByte();
    public PdfContentByte(PdfWriter wr);
    public virtual string ToString();
    public ByteBuffer get_InternalBuffer();
    public Byte[] ToPdf(PdfWriter writer);
    public void Add(PdfContentByte other);
    public float get_XTLM();
    public float get_YTLM();
    public float get_CharacterSpacing();
    public float get_WordSpacing();
    public float get_HorizontalScaling();
    public float get_Leading();
    public void SetLeading(float v);
    public void SetFlatness(float value);
    public void SetLineCap(int value);
    public void SetLineDash(float value);
    public void SetLineDash(float unitsOn, float phase);
    public void SetLineDash(float unitsOn, float unitsOff, float phase);
    public void SetLineDash(Single[] array, float phase);
    public void SetLineJoin(int value);
    public void SetLineWidth(float value);
    public void SetMiterLimit(float value);
    public void Clip();
    public void EoClip();
    public virtual void SetGrayFill(float value);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float value);
    public virtual void ResetGrayStroke();
    private void HelperRGB(float red, float green, float blue);
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    private void HelperCMYK(float cyan, float magenta, float yellow, float black);
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public void MoveTo(float x, float y);
    public void LineTo(float x, float y);
    public void CurveTo(float x1, float y1, float x2, float y2, float x3, float y3);
    public void CurveTo(float x2, float y2, float x3, float y3);
    public void CurveFromTo(float x1, float y1, float x3, float y3);
    public void Circle(float x, float y, float r);
    public void Rectangle(float x, float y, float w, float h);
    private bool CompareColors(Color c1, Color c2);
    public void VariableRectangle(Rectangle rect);
    public void Rectangle(Rectangle rectangle);
    public void ClosePath();
    public void NewPath();
    public void Stroke();
    public void ClosePathStroke();
    public void Fill();
    public void EoFill();
    public void FillStroke();
    public void ClosePathFillStroke();
    public void EoFillStroke();
    public void ClosePathEoFillStroke();
    public virtual void AddImage(Image image);
    public virtual void AddImage(Image image, bool inlineImage);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public void Reset();
    public void Reset(bool validateContent);
    public void BeginText();
    public void EndText();
    public void SaveState();
    public void RestoreState();
    public void SetCharacterSpacing(float value);
    public void SetWordSpacing(float value);
    public void SetHorizontalScaling(float value);
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public void SetTextRenderingMode(int value);
    public void SetTextRise(float value);
    private void ShowText2(string text);
    public void ShowText(string text);
    public static PdfTextArray GetKernArray(string text, BaseFont font);
    public void ShowTextKerned(string text);
    public void NewlineShowText(string text);
    public void NewlineShowText(float wordSpacing, float charSpacing, string text);
    public void SetTextMatrix(float a, float b, float c, float d, float x, float y);
    public void SetTextMatrix(float x, float y);
    public void MoveText(float x, float y);
    public void MoveTextWithLeading(float x, float y);
    public void NewlineText();
    internal int get_Size();
    internal static Byte[] EscapeString(Byte[] b);
    internal static void EscapeString(Byte[] b, ByteBuffer content);
    public void AddOutline(PdfOutline outline, string name);
    public PdfOutline get_RootOutline();
    public float GetEffectiveStringWidth(string text, bool kerned);
    public void ShowTextAligned(int alignment, string text, float x, float y, float rotation);
    private void ShowTextAligned(int alignment, string text, float x, float y, float rotation, bool kerned);
    public void ShowTextAlignedKerned(int alignment, string text, float x, float y, float rotation);
    public void ConcatCTM(float a, float b, float c, float d, float e, float f);
    public static ArrayList BezierArc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public void Arc(float x1, float y1, float x2, float y2, float startAng, float extent);
    public void Ellipse(float x1, float y1, float x2, float y2);
    public PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep);
    public PdfPatternPainter CreatePattern(float width, float height);
    public PdfPatternPainter CreatePattern(float width, float height, float xstep, float ystep, Color color);
    public PdfPatternPainter CreatePattern(float width, float height, Color color);
    public PdfTemplate CreateTemplate(float width, float height);
    internal PdfTemplate CreateTemplate(float width, float height, PdfName forcedName);
    public PdfAppearance CreateAppearance(float width, float height);
    internal PdfAppearance CreateAppearance(float width, float height, PdfName forcedName);
    public void AddPSXObject(PdfPSXObject psobject);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    internal void AddTemplateReference(PdfIndirectReference template, PdfName name, float a, float b, float c, float d, float e, float f);
    public void AddTemplate(PdfTemplate template, float x, float y);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(Color value);
    public virtual void SetColorFill(Color value);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p);
    internal void OutputColorNumbers(Color color, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p, Color color);
    public virtual void SetPatternFill(PdfPatternPainter p, Color color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, Color color);
    public virtual void SetPatternStroke(PdfPatternPainter p, Color color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    public virtual void PaintShading(PdfShading shading);
    public virtual void PaintShading(PdfShadingPattern shading);
    public virtual void SetShadingFill(PdfShadingPattern shading);
    public virtual void SetShadingStroke(PdfShadingPattern shading);
    protected virtual void CheckWriter();
    public void ShowText(PdfTextArray text);
    public PdfWriter get_PdfWriter();
    public PdfDocument get_PdfDocument();
    public void LocalGoto(string name, float llx, float lly, float urx, float ury);
    public bool LocalDestination(string name, PdfDestination destination);
    public virtual PdfContentByte get_Duplicate();
    public void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    public void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    public void RoundRectangle(float x, float y, float w, float h, float r);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public void SetLiteral(string s);
    public void SetLiteral(char c);
    public void SetLiteral(float n);
    internal void CheckNoPattern(PdfTemplate t);
    public void DrawRadioField(float llx, float lly, float urx, float ury, bool on);
    public void DrawTextField(float llx, float lly, float urx, float ury);
    public void DrawButton(float llx, float lly, float urx, float ury, string text, BaseFont bf, float size);
    internal virtual PageResources get_PageResources();
    public void SetGState(PdfGState gstate);
    public void BeginLayer(IPdfOCG layer);
    private void BeginLayer2(IPdfOCG layer);
    public void EndLayer();
    internal virtual void AddAnnotation(PdfAnnotation annot);
    public virtual void SetDefaultColorspace(PdfName name, PdfObject obj);
    public void Transform(Matrix tx);
    public void BeginMarkedContentSequence(PdfStructureElement struc);
    public void EndMarkedContentSequence();
    public void BeginMarkedContentSequence(PdfName tag, PdfDictionary property, bool inline);
    public void BeginMarkedContentSequence(PdfName tag);
    public void SanityCheck();
}
public class iTextSharp.text.pdf.PdfContentParser : object {
    public static int COMMAND_TYPE;
    private PRTokeniser tokeniser;
    public PRTokeniser Tokeniser { get; public set; }
    public PdfContentParser(PRTokeniser tokeniser);
    public ArrayList Parse(ArrayList ls);
    public PRTokeniser GetTokeniser();
    public void set_Tokeniser(PRTokeniser value);
    public PRTokeniser get_Tokeniser();
    public PdfDictionary ReadDictionary();
    public PdfArray ReadArray();
    public PdfObject ReadPRObject();
    public bool NextValidToken();
}
public class iTextSharp.text.pdf.PdfContents : PdfStream {
    internal static Byte[] SAVESTATE;
    internal static Byte[] RESTORESTATE;
    internal static Byte[] ROTATE90;
    internal static Byte[] ROTATE180;
    internal static Byte[] ROTATE270;
    internal static Byte[] ROTATEFINAL;
    internal PdfContents(PdfContentByte under, PdfContentByte content, PdfContentByte text, PdfContentByte secondContent, Rectangle page);
    private static PdfContents();
}
public class iTextSharp.text.pdf.PdfCopy : PdfWriter {
    protected Hashtable indirects;
    protected Hashtable indirectMap;
    protected int currentObjectNum;
    protected PdfReader reader;
    protected PdfIndirectReference acroForm;
    protected Int32[] namePtr;
    private bool rotateContents;
    protected internal PdfArray fieldArray;
    protected internal Hashtable fieldTemplates;
    public bool RotateContents { get; public set; }
    public PdfCopy(Document document, Stream os);
    public void set_RotateContents(bool value);
    public bool get_RotateContents();
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
    protected PdfDictionary CopyDictionary(PdfDictionary inp);
    protected PdfStream CopyStream(PRStream inp);
    protected PdfArray CopyArray(PdfArray inp);
    protected PdfObject CopyObject(PdfObject inp);
    protected int SetFromIPage(PdfImportedPage iPage);
    protected void SetFromReader(PdfReader reader);
    public void AddPage(PdfImportedPage iPage);
    public void AddPage(Rectangle rect, int rotation);
    public void CopyAcroForm(PdfReader reader);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    private void AddFieldResources(PdfDictionary catalog);
    public virtual void Close();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public virtual void FreeReader(PdfReader reader);
    public PageStamp CreatePageStamp(PdfImportedPage iPage);
}
public class iTextSharp.text.pdf.PdfCopyFields : object {
    private PdfCopyFieldsImp fc;
    unknown ArrayList Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyFields(Stream os);
    public PdfCopyFields(Stream os, char pdfVersion);
    public void AddDocument(PdfReader reader);
    public void AddDocument(PdfReader reader, ArrayList pagesToKeep);
    public void AddDocument(PdfReader reader, string ranges);
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void Close();
    public void Open();
    public void AddJavaScript(string js);
    public void set_Outlines(ArrayList value);
    public PdfWriter get_Writer();
    public bool get_FullCompression();
    public void SetFullCompression();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void AddViewerPreference(PdfName key, PdfObject value);
    public sealed virtual void set_ViewerPreferences(int value);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
internal class iTextSharp.text.pdf.PdfCopyFieldsImp : PdfWriter {
    private static PdfName iTextTag;
    private static object zero;
    internal ArrayList readers;
    internal Hashtable readers2intrefs;
    internal Hashtable pages2intrefs;
    internal Hashtable visited;
    internal ArrayList fields;
    internal RandomAccessFileOrArray file;
    internal Hashtable fieldTree;
    internal ArrayList pageRefs;
    internal ArrayList pageDics;
    internal PdfDictionary resources;
    internal PdfDictionary form;
    private bool closing;
    internal Document nd;
    private Hashtable tabOrder;
    private ArrayList calculationOrder;
    private ArrayList calculationOrderRefs;
    private bool hasSignature;
    protected internal static Hashtable widgetKeys;
    protected internal static Hashtable fieldKeys;
    internal PdfCopyFieldsImp(Stream os);
    internal PdfCopyFieldsImp(Stream os, char pdfVersion);
    private static PdfCopyFieldsImp();
    internal void AddDocument(PdfReader reader, ArrayList pagesToKeep);
    internal void AddDocument(PdfReader reader);
    private static string GetCOName(PdfReader reader, PRIndirectReference refi);
    protected internal void UpdateCalculationOrder(PdfReader reader);
    internal void Propagate(PdfObject obj, PdfIndirectReference refo, bool restricted);
    private void AdjustTabOrder(PdfArray annots, PdfIndirectReference ind, PdfNumber nn);
    protected PdfArray BranchForm(Hashtable level, PdfIndirectReference parent, string fname);
    protected void CreateAcroForms();
    public virtual void Close();
    protected void CloseIt();
    internal void AddPageOffsetToField(Hashtable fd, int pageOffset);
    internal void CreateWidgets(ArrayList list, Item item);
    internal void MergeField(string name, Item item);
    internal void MergeWithMaster(Hashtable fd);
    internal virtual void MergeFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    protected PdfIndirectReference GetNewReference(PRIndirectReference refi);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    protected internal bool SetVisited(PRIndirectReference refi);
    protected internal bool IsVisited(PRIndirectReference refi);
    protected internal bool IsVisited(PdfReader reader, int number, int generation);
    protected internal bool IsPage(PRIndirectReference refi);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public void OpenDoc();
}
public class iTextSharp.text.pdf.PdfCopyForms : object {
    private PdfCopyFormsImp fc;
    unknown ArrayList Outlines {public set; }
    public PdfWriter Writer { get; }
    public bool FullCompression { get; }
    unknown int ViewerPreferences {public set; }
    public PdfCopyForms(Stream os);
    public void AddDocument(PdfReader reader);
    public void AddDocument(PdfReader reader, ArrayList pagesToKeep);
    public void AddDocument(PdfReader reader, string ranges);
    public void CopyDocumentFields(PdfReader reader);
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void Close();
    public void Open();
    public void AddJavaScript(string js);
    public void set_Outlines(ArrayList value);
    public PdfWriter get_Writer();
    public bool get_FullCompression();
    public void SetFullCompression();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void AddViewerPreference(PdfName key, PdfObject value);
    public sealed virtual void set_ViewerPreferences(int value);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
}
internal class iTextSharp.text.pdf.PdfCopyFormsImp : PdfCopyFieldsImp {
    internal PdfCopyFormsImp(Stream os);
    public void CopyDocumentFields(PdfReader reader);
    internal virtual void MergeFields();
}
public class iTextSharp.text.pdf.PdfDashPattern : PdfArray {
    private float dash;
    private float gap;
    private float phase;
    public PdfDashPattern(float dash);
    public PdfDashPattern(float dash, float gap);
    public PdfDashPattern(float dash, float gap, float phase);
    public void Add(float n);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfDate : PdfString {
    public PdfDate(DateTime d);
    private static string SetLength(int i, int length);
    public string GetW3CDate();
    public static string GetW3CDate(string d);
    public static DateTime Decode(string date);
}
public class iTextSharp.text.pdf.PdfDestination : PdfArray {
    public static int XYZ;
    public static int FIT;
    public static int FITH;
    public static int FITV;
    public static int FITR;
    public static int FITB;
    public static int FITBH;
    public static int FITBV;
    private bool status;
    public PdfDestination(int type);
    public PdfDestination(int type, float parameter);
    public PdfDestination(int type, float left, float top, float zoom);
    public PdfDestination(int type, float left, float bottom, float right, float top);
    public bool HasPage();
    public bool AddPage(PdfIndirectReference page);
}
public class iTextSharp.text.pdf.PdfDeveloperExtension : object {
    public static PdfDeveloperExtension ADOBE_1_7_EXTENSIONLEVEL3;
    protected PdfName prefix;
    protected PdfName baseversion;
    protected int extensionLevel;
    public PdfName Prefix { get; }
    public PdfName Baseversion { get; }
    public int ExtensionLevel { get; }
    public PdfDeveloperExtension(PdfName prefix, PdfName baseversion, int extensionLevel);
    private static PdfDeveloperExtension();
    public PdfName get_Prefix();
    public PdfName get_Baseversion();
    public int get_ExtensionLevel();
    public PdfDictionary GetDeveloperExtensions();
}
public class iTextSharp.text.pdf.PdfDictionary : PdfObject {
    public static PdfName FONT;
    public static PdfName OUTLINES;
    public static PdfName PAGE;
    public static PdfName PAGES;
    public static PdfName CATALOG;
    private PdfName dictionaryType;
    protected internal Hashtable hashMap;
    public ICollection Keys { get; }
    public int Size { get; }
    public PdfDictionary(PdfName type);
    private static PdfDictionary();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public void Put(PdfName key, PdfObject value);
    public void PutEx(PdfName key, PdfObject value);
    public void Remove(PdfName key);
    public PdfObject Get(PdfName key);
    public bool IsFont();
    public bool IsPage();
    public bool IsPages();
    public bool IsCatalog();
    public bool IsOutlineTree();
    public void Merge(PdfDictionary other);
    public void MergeDifferent(PdfDictionary other);
    public ICollection get_Keys();
    public int get_Size();
    public bool Contains(PdfName key);
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual string ToString();
    public PdfObject GetDirectObject(PdfName key);
    public PdfDictionary GetAsDict(PdfName key);
    public PdfArray GetAsArray(PdfName key);
    public PdfStream GetAsStream(PdfName key);
    public PdfString GetAsString(PdfName key);
    public PdfNumber GetAsNumber(PdfName key);
    public PdfName GetAsName(PdfName key);
    public PdfBoolean GetAsBoolean(PdfName key);
    public PdfIndirectReference GetAsIndirectObject(PdfName key);
}
public class iTextSharp.text.pdf.PdfDocument : Document {
    internal static string hangingPunctuation;
    protected internal PdfWriter writer;
    protected internal PdfContentByte text;
    protected internal PdfContentByte graphics;
    protected internal float leading;
    protected internal float currentHeight;
    protected bool isSectionTitle;
    protected int leadingCount;
    protected internal int alignment;
    protected internal PdfAction anchorAction;
    protected internal int textEmptySize;
    protected Byte[] xmpMetadata;
    protected float nextMarginLeft;
    protected float nextMarginRight;
    protected float nextMarginTop;
    protected float nextMarginBottom;
    protected internal bool firstPageEvent;
    protected internal PdfLine line;
    protected internal ArrayList lines;
    protected internal int lastElementType;
    protected internal Indentation indentation;
    protected internal PdfInfo info;
    protected internal PdfOutline rootOutline;
    protected internal PdfOutline currentOutline;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected internal PdfPageLabels pageLabels;
    protected internal OrderedTree localDestinations;
    private int jsCounter;
    protected internal Hashtable documentLevelJS;
    protected internal Hashtable documentFileAttachment;
    protected internal string openActionName;
    protected internal PdfAction openActionAction;
    protected internal PdfDictionary additionalActions;
    protected internal PdfCollection collection;
    internal PdfAnnotationsImp annotationsImp;
    protected int markPoint;
    protected Rectangle nextPageSize;
    protected Hashtable thisBoxSize;
    protected Hashtable boxSize;
    protected internal bool pageEmpty;
    protected int duration;
    protected PdfTransition transition;
    protected PdfDictionary pageAA;
    protected internal PdfIndirectReference thumb;
    protected internal PageResources pageResources;
    protected internal bool strictImageSequence;
    protected internal float imageEnd;
    protected internal Image imageWait;
    public float Leading { get; public set; }
    unknown Byte[] XmpMetadata {public set; }
    unknown int PageCount {public set; }
    unknown HeaderFooter Header {public set; }
    unknown HeaderFooter Footer {public set; }
    protected internal float IndentLeft { get; }
    protected internal float IndentRight { get; }
    protected internal float IndentTop { get; }
    protected internal float IndentBottom { get; }
    internal PdfInfo Info { get; }
    public PdfOutline RootOutline { get; }
    unknown int ViewerPreferences {internal set; }
    unknown PdfPageLabels PageLabels {internal set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {internal set; }
    unknown Rectangle CropBoxSize {internal set; }
    unknown bool PageEmpty {internal set; }
    unknown int Duration {internal set; }
    unknown PdfTransition Transition {internal set; }
    unknown Image Thumbnail {internal set; }
    internal PageResources PageResources { get; }
    internal bool StrictImageSequence { get; internal set; }
    internal void AddWriter(PdfWriter writer);
    public float get_Leading();
    public void set_Leading(float value);
    public virtual bool Add(IElement element);
    public virtual void Open();
    public virtual void Close();
    public void set_XmpMetadata(Byte[] value);
    public virtual bool NewPage();
    public virtual bool SetPageSize(Rectangle pageSize);
    public virtual bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    public virtual bool SetMarginMirroring(bool MarginMirroring);
    public virtual bool SetMarginMirroringTopBottom(bool MarginMirroringTopBottom);
    public virtual void set_PageCount(int value);
    public virtual void ResetPageCount();
    public virtual void set_Header(HeaderFooter value);
    public virtual void ResetHeader();
    public virtual void set_Footer(HeaderFooter value);
    public virtual void ResetFooter();
    protected internal void InitPage();
    protected internal void NewLine();
    protected internal void CarriageReturn();
    public float GetVerticalPosition(bool ensureNewLine);
    protected internal void EnsureNewLine();
    protected internal float FlushLines();
    internal void WriteLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object[] currentValues, float ratio);
    protected internal float get_IndentLeft();
    protected internal float get_IndentRight();
    protected internal float get_IndentTop();
    protected internal float get_IndentBottom();
    protected internal void AddSpacing(float extraspace, float oldleading, Font f);
    internal PdfInfo get_Info();
    internal PdfCatalog GetCatalog(PdfIndirectReference pages);
    internal void AddOutline(PdfOutline outline, string name);
    public PdfOutline get_RootOutline();
    internal void CalculateOutlineCount();
    internal void TraverseOutlineCount(PdfOutline outline);
    internal void WriteOutlines();
    internal void OutlineTree(PdfOutline outline);
    internal void set_ViewerPreferences(int value);
    internal void AddViewerPreference(PdfName key, PdfObject value);
    internal void set_PageLabels(PdfPageLabels value);
    internal void LocalGoto(string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, string name, float llx, float lly, float urx, float ury);
    internal void RemoteGoto(string filename, int page, float llx, float lly, float urx, float ury);
    internal void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    internal PdfAction GetLocalGotoAction(string name);
    internal bool LocalDestination(string name, PdfDestination destination);
    internal void AddJavaScript(PdfAction js);
    internal void AddJavaScript(string name, PdfAction js);
    internal Hashtable GetDocumentLevelJS();
    internal void AddFileAttachment(string description, PdfFileSpecification fs);
    internal Hashtable GetDocumentFileAttachment();
    internal void SetOpenAction(string name);
    internal void SetOpenAction(PdfAction action);
    internal void AddAdditionalAction(PdfName actionType, PdfAction action);
    public void set_Collection(PdfCollection value);
    public PdfAcroForm get_AcroForm();
    internal void set_SigFlags(int value);
    internal void AddCalculationOrder(PdfFormField formField);
    internal void AddAnnotation(PdfAnnotation annot);
    internal int GetMarkPoint();
    internal void IncMarkPoint();
    internal void set_CropBoxSize(Rectangle value);
    internal void SetBoxSize(string boxName, Rectangle size);
    protected internal void SetNewPageSizeAndMargins();
    internal Rectangle GetBoxSize(string boxName);
    internal void set_PageEmpty(bool value);
    internal void set_Duration(int value);
    internal void set_Transition(PdfTransition value);
    internal void SetPageAction(PdfName actionType, PdfAction action);
    internal void set_Thumbnail(Image value);
    internal PageResources get_PageResources();
    internal void set_StrictImageSequence(bool value);
    internal bool get_StrictImageSequence();
    public void ClearTextWrap();
    protected internal void Add(Image image);
    internal void AddPTable(PdfPTable ptable);
    internal bool FitsPage(PdfPTable table, float margin);
    private void AddPdfTable(Table t);
    protected internal void AnalyzeRow(ArrayList rows, RenderingContext ctx);
    protected internal bool MayBeRemoved(ArrayList row);
    protected internal void ConsumeRowspan(ArrayList row, RenderingContext ctx);
    protected internal ArrayList ExtractRows(ArrayList cells, RenderingContext ctx);
    protected internal void RenderCells(RenderingContext ctx, ArrayList cells, bool hasToFit);
    internal float GetBottom(Table table);
    protected internal void DoFooter();
    protected internal void DoHeader();
}
public class iTextSharp.text.pdf.PdfEFStream : PdfStream {
    public PdfEFStream(Stream inp, PdfWriter writer);
    public PdfEFStream(Byte[] fileStore);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PdfEncodings : object {
    protected static int CIDNONE;
    protected static int CIDRANGE;
    protected static int CIDCHAR;
    internal static Char[] winansiByteToChar;
    internal static Char[] pdfEncodingByteToChar;
    internal static IntHashtable winansi;
    internal static IntHashtable pdfEncoding;
    internal static Hashtable extraEncodings;
    internal static Hashtable cmaps;
    public static Byte[][] CRLF_CID_NEWLINE;
    private static PdfEncodings();
    public static Byte[] ConvertToBytes(string text, string encoding);
    public static Byte[] ConvertToBytes(char char1, string encoding);
    public static string ConvertToString(Byte[] bytes, string encoding);
    public static bool IsPdfDocEncoding(string text);
    public static void ClearCmap(string name);
    public static void LoadCmap(string name, Byte[][] newline);
    public static string ConvertCmap(string name, Byte[] seq);
    public static string ConvertCmap(string name, Byte[] seq, int start, int length);
    internal static string DecodeSequence(Byte[] seq, int start, int length, Char[][] planes);
    internal static Char[][] ReadCmap(string name, Byte[][] newline);
    internal static void ReadCmap(string name, ArrayList planes);
    internal static void EncodeStream(Stream inp, ArrayList planes);
    internal static void BreakLong(long n, int size, Byte[] seqs);
    internal static void EncodeSequence(int size, Byte[] seqs, char cid, ArrayList planes);
    public static void AddExtraEncoding(string name, IExtraEncoding enc);
}
public class iTextSharp.text.pdf.PdfEncryption : object {
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int AES_128;
    private static Byte[] pad;
    private static Byte[] salt;
    internal static Byte[] metadataPad;
    internal Byte[] key;
    internal int keySize;
    internal Byte[] mkey;
    internal Byte[] extra;
    internal MD5 md5;
    internal Byte[] ownerKey;
    internal Byte[] userKey;
    protected PdfPublicKeySecurityHandler publicKeyHandler;
    internal int permissions;
    internal Byte[] documentID;
    internal static long seq;
    private int revision;
    private ARCFOUREncryption rc4;
    private int keyLength;
    private bool encryptMetadata;
    private bool embeddedFilesOnly;
    private int cryptoMode;
    public PdfObject FileID { get; }
    public PdfEncryption(PdfEncryption enc);
    private static PdfEncryption();
    public void SetCryptoMode(int mode, int kl);
    public int GetCryptoMode();
    public bool IsMetadataEncrypted();
    public bool IsEmbeddedFilesOnly();
    private Byte[] PadPassword(Byte[] userPassword);
    private Byte[] ComputeOwnerKey(Byte[] userPad, Byte[] ownerPad);
    private void SetupGlobalEncryptionKey(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, int permissions);
    private void SetupUserKey();
    public void SetupAllKeys(Byte[] userPassword, Byte[] ownerPassword, int permissions);
    public static Byte[] CreateDocumentId();
    public void SetupByUserPassword(Byte[] documentID, Byte[] userPassword, Byte[] ownerKey, int permissions);
    private void SetupByUserPad(Byte[] documentID, Byte[] userPad, Byte[] ownerKey, int permissions);
    public void SetupByOwnerPassword(Byte[] documentID, Byte[] ownerPassword, Byte[] userKey, Byte[] ownerKey, int permissions);
    private void SetupByOwnerPad(Byte[] documentID, Byte[] ownerPad, Byte[] userKey, Byte[] ownerKey, int permissions);
    public void SetupByEncryptionKey(Byte[] key, int keylength);
    public void SetHashKey(int number, int generation);
    public static PdfObject CreateInfoId(Byte[] id);
    public PdfDictionary GetEncryptionDictionary();
    public PdfObject get_FileID();
    public OutputStreamEncryption GetEncryptionStream(Stream os);
    public int CalculateStreamSize(int n);
    public Byte[] EncryptByteArray(Byte[] b);
    public StandardDecryption GetDecryptor();
    public Byte[] DecryptByteArray(Byte[] b);
    public void AddRecipient(X509Certificate cert, int permission);
    public Byte[] ComputeUserPassword(Byte[] ownerPassword);
}
public class iTextSharp.text.pdf.PdfEncryptor : object {
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public static void Encrypt(PdfReader reader, Stream os, Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits, Hashtable newInfo);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions);
    public static void Encrypt(PdfReader reader, Stream os, bool strength, string userPassword, string ownerPassword, int permissions, Hashtable newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions, Hashtable newInfo);
    public static void Encrypt(PdfReader reader, Stream os, int type, string userPassword, string ownerPassword, int permissions);
    public static string GetPermissionsVerbose(int permissions);
    public static bool IsPrintingAllowed(int permissions);
    public static bool IsModifyContentsAllowed(int permissions);
    public static bool IsCopyAllowed(int permissions);
    public static bool IsModifyAnnotationsAllowed(int permissions);
    public static bool IsFillInAllowed(int permissions);
    public static bool IsScreenReadersAllowed(int permissions);
    public static bool IsAssemblyAllowed(int permissions);
    public static bool IsDegradedPrintingAllowed(int permissions);
}
public class iTextSharp.text.pdf.PdfException : DocumentException {
    public PdfException(string message);
}
public class iTextSharp.text.pdf.PdfFileSpecification : PdfDictionary {
    protected PdfWriter writer;
    protected PdfIndirectReference refi;
    public PdfIndirectReference Reference { get; }
    unknown Byte[] MultiByteFileName {public set; }
    unknown bool Volatile {public set; }
    public static PdfFileSpecification Url(PdfWriter writer, string url);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, int compressionLevel);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, bool compress, string mimeType, PdfDictionary fileParameter);
    public static PdfFileSpecification FileEmbedded(PdfWriter writer, string filePath, string fileDisplay, Byte[] fileStore, string mimeType, PdfDictionary fileParameter, int compressionLevel);
    public static PdfFileSpecification FileExtern(PdfWriter writer, string filePath);
    public PdfIndirectReference get_Reference();
    public void set_MultiByteFileName(Byte[] value);
    public void SetUnicodeFileName(string filename, bool unicode);
    public void set_Volatile(bool value);
    public void AddDescription(string description, bool unicode);
    public void AddCollectionItem(PdfCollectionItem ci);
}
public class iTextSharp.text.pdf.PdfFont : object {
    private BaseFont font;
    private float size;
    protected Image image;
    protected float hScale;
    internal float Size { get; }
    internal BaseFont Font { get; }
    unknown Image Image {internal set; }
    internal static PdfFont DefaultFont { get; }
    unknown float HorizontalScaling {internal set; }
    internal PdfFont(BaseFont bf, float size);
    public sealed virtual int CompareTo(object obj);
    internal float get_Size();
    internal float Width();
    internal float Width(int character);
    internal float Width(string s);
    internal BaseFont get_Font();
    internal void set_Image(Image value);
    internal static PdfFont get_DefaultFont();
    internal void set_HorizontalScaling(float value);
}
public class iTextSharp.text.pdf.PdfFormField : PdfAnnotation {
    public static int FF_READ_ONLY;
    public static int FF_REQUIRED;
    public static int FF_NO_EXPORT;
    public static int FF_NO_TOGGLE_TO_OFF;
    public static int FF_RADIO;
    public static int FF_PUSHBUTTON;
    public static int FF_MULTILINE;
    public static int FF_PASSWORD;
    public static int FF_COMBO;
    public static int FF_EDIT;
    public static int FF_FILESELECT;
    public static int FF_MULTISELECT;
    public static int FF_DONOTSPELLCHECK;
    public static int FF_DONOTSCROLL;
    public static int FF_COMB;
    public static int FF_RADIOSINUNISON;
    public static int Q_LEFT;
    public static int Q_CENTER;
    public static int Q_RIGHT;
    public static int MK_NO_ICON;
    public static int MK_NO_CAPTION;
    public static int MK_CAPTION_BELOW;
    public static int MK_CAPTION_ABOVE;
    public static int MK_CAPTION_RIGHT;
    public static int MK_CAPTION_LEFT;
    public static int MK_CAPTION_OVERLAID;
    public static bool MULTILINE;
    public static bool SINGLELINE;
    public static bool PLAINTEXT;
    public static bool PASSWORD;
    public static PdfName IF_SCALE_ALWAYS;
    public static PdfName IF_SCALE_BIGGER;
    public static PdfName IF_SCALE_SMALLER;
    public static PdfName IF_SCALE_NEVER;
    public static PdfName IF_SCALE_ANAMORPHIC;
    public static PdfName IF_SCALE_PROPORTIONAL;
    public static PdfName[] mergeTarget;
    internal PdfFormField parent;
    internal ArrayList kids;
    unknown int Button {public set; }
    public PdfFormField Parent { get; }
    public ArrayList Kids { get; }
    unknown string ValueAsString {public set; }
    unknown string ValueAsName {public set; }
    unknown PdfSignature ValueAsSig {public set; }
    unknown string DefaultValueAsString {public set; }
    unknown string DefaultValueAsName {public set; }
    unknown string FieldName {public set; }
    unknown string UserName {public set; }
    unknown string MappingName {public set; }
    unknown int Quadding {public set; }
    public PdfFormField(PdfWriter writer, float llx, float lly, float urx, float ury, PdfAction action);
    internal PdfFormField(PdfWriter writer);
    private static PdfFormField();
    public void SetWidget(Rectangle rect, PdfName highlight);
    public static PdfFormField CreateEmpty(PdfWriter writer);
    public void set_Button(int value);
    protected static PdfFormField CreateButton(PdfWriter writer, int flags);
    public static PdfFormField CreatePushButton(PdfWriter writer);
    public static PdfFormField CreateCheckBox(PdfWriter writer);
    public static PdfFormField CreateRadioButton(PdfWriter writer, bool noToggleToOff);
    public static PdfFormField CreateTextField(PdfWriter writer, bool multiline, bool password, int maxLen);
    protected static PdfFormField CreateChoice(PdfWriter writer, int flags, PdfArray options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[] options, int topIndex);
    public static PdfFormField CreateList(PdfWriter writer, String[0...,0...] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[] options, int topIndex);
    public static PdfFormField CreateCombo(PdfWriter writer, bool edit, String[0...,0...] options, int topIndex);
    protected static PdfArray ProcessOptions(String[] options);
    protected static PdfArray ProcessOptions(String[0...,0...] options);
    public static PdfFormField CreateSignature(PdfWriter writer);
    public PdfFormField get_Parent();
    public void AddKid(PdfFormField field);
    public ArrayList get_Kids();
    public int SetFieldFlags(int flags);
    public void set_ValueAsString(string value);
    public void set_ValueAsName(string value);
    public void set_ValueAsSig(PdfSignature value);
    public void set_DefaultValueAsString(string value);
    public void set_DefaultValueAsName(string value);
    public void set_FieldName(string value);
    public void set_UserName(string value);
    public void set_MappingName(string value);
    public void set_Quadding(int value);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source, PdfStamperImp writer);
    internal static void MergeResources(PdfDictionary result, PdfDictionary source);
    public virtual void SetUsed();
}
public class iTextSharp.text.pdf.PdfFormXObject : PdfStream {
    public static PdfNumber ZERO;
    public static PdfNumber ONE;
    public static PdfLiteral MATRIX;
    internal PdfFormXObject(PdfTemplate template, int compressionLevel);
    private static PdfFormXObject();
}
public class iTextSharp.text.pdf.PdfFunction : object {
    protected PdfWriter writer;
    protected PdfIndirectReference reference;
    protected PdfDictionary dictionary;
    internal PdfIndirectReference Reference { get; }
    protected PdfFunction(PdfWriter writer);
    internal PdfIndirectReference get_Reference();
    public static PdfFunction Type0(PdfWriter writer, Single[] domain, Single[] range, Int32[] size, int bitsPerSample, int order, Single[] encode, Single[] decode, Byte[] stream);
    public static PdfFunction Type2(PdfWriter writer, Single[] domain, Single[] range, Single[] c0, Single[] c1, float n);
    public static PdfFunction Type3(PdfWriter writer, Single[] domain, Single[] range, PdfFunction[] functions, Single[] bounds, Single[] encode);
    public static PdfFunction Type4(PdfWriter writer, Single[] domain, Single[] range, string postscript);
}
public class iTextSharp.text.pdf.PdfGState : PdfDictionary {
    public static PdfName BM_NORMAL;
    public static PdfName BM_COMPATIBLE;
    public static PdfName BM_MULTIPLY;
    public static PdfName BM_SCREEN;
    public static PdfName BM_OVERLAY;
    public static PdfName BM_DARKEN;
    public static PdfName BM_LIGHTEN;
    public static PdfName BM_COLORDODGE;
    public static PdfName BM_COLORBURN;
    public static PdfName BM_HARDLIGHT;
    public static PdfName BM_SOFTLIGHT;
    public static PdfName BM_DIFFERENCE;
    public static PdfName BM_EXCLUSION;
    unknown bool OverPrintStroking {public set; }
    unknown bool OverPrintNonStroking {public set; }
    unknown int OverPrintMode {public set; }
    unknown float StrokeOpacity {public set; }
    unknown float FillOpacity {public set; }
    unknown bool AlphaIsShape {public set; }
    unknown bool TextKnockout {public set; }
    unknown PdfName BlendMode {public set; }
    private static PdfGState();
    public void set_OverPrintStroking(bool value);
    public void set_OverPrintNonStroking(bool value);
    public void set_OverPrintMode(int value);
    public void set_StrokeOpacity(float value);
    public void set_FillOpacity(float value);
    public void set_AlphaIsShape(bool value);
    public void set_TextKnockout(bool value);
    public void set_BlendMode(PdfName value);
}
public class iTextSharp.text.pdf.PdfICCBased : PdfStream {
    public PdfICCBased(ICC_Profile profile);
    public PdfICCBased(ICC_Profile profile, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfImage : PdfStream {
    internal static int TRANSFERSIZE;
    protected PdfName name;
    public PdfName Name { get; }
    public PdfImage(Image image, string name, PdfIndirectReference maskRef);
    public PdfName get_Name();
    internal static void TransferBytes(Stream inp, Stream outp, int len);
    protected void ImportAll(PdfImage dup);
}
public class iTextSharp.text.pdf.PdfImportedPage : PdfTemplate {
    internal PdfReaderInstance readerInstance;
    internal int pageNumber;
    public PdfImportedPage FromReader { get; }
    public int PageNumber { get; }
    public PdfContentByte Duplicate { get; }
    internal PdfObject Resources { get; }
    unknown PdfTransparencyGroup Group {public set; }
    internal PdfReaderInstance PdfReaderInstance { get; }
    internal PdfImportedPage(PdfReaderInstance readerInstance, PdfWriter writer, int pageNumber);
    public PdfImportedPage get_FromReader();
    public int get_PageNumber();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void AddTemplate(PdfTemplate template, float a, float b, float c, float d, float e, float f);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    internal virtual PdfObject get_Resources();
    public virtual void SetFontAndSize(BaseFont bf, float size);
    public virtual void set_Group(PdfTransparencyGroup value);
    internal void ThrowError();
    internal PdfReaderInstance get_PdfReaderInstance();
}
public class iTextSharp.text.pdf.PdfIndirectObject : object {
    protected int number;
    protected int generation;
    internal static Byte[] STARTOBJ;
    internal static Byte[] ENDOBJ;
    internal static int SIZEOBJ;
    internal PdfObject objecti;
    internal PdfWriter writer;
    public PdfIndirectReference IndirectReference { get; }
    internal PdfIndirectObject(int number, PdfObject objecti, PdfWriter writer);
    internal PdfIndirectObject(PdfIndirectReference refi, PdfObject objecti, PdfWriter writer);
    internal PdfIndirectObject(int number, int generation, PdfObject objecti, PdfWriter writer);
    private static PdfIndirectObject();
    public PdfIndirectReference get_IndirectReference();
    internal void WriteTo(Stream os);
}
public class iTextSharp.text.pdf.PdfIndirectReference : PdfObject {
    protected int number;
    protected int generation;
    public int Number { get; }
    public int Generation { get; }
    internal PdfIndirectReference(int type, int number, int generation);
    internal PdfIndirectReference(int type, int number);
    public int get_Number();
    public int get_Generation();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfLayer : PdfDictionary {
    protected PdfIndirectReference refi;
    protected ArrayList children;
    protected PdfLayer parent;
    protected string title;
    private bool on;
    private bool onPanel;
    internal string Title { get; }
    public PdfLayer Parent { get; }
    public ArrayList Children { get; }
    public PdfIndirectReference Ref { get; public set; }
    unknown string Name {public set; }
    public PdfObject PdfObject { get; }
    public bool On { get; public set; }
    private PdfDictionary Usage { get; }
    unknown bool Export {public set; }
    unknown bool View {public set; }
    public bool OnPanel { get; public set; }
    internal PdfLayer(string title);
    public PdfLayer(string name, PdfWriter writer);
    public static PdfLayer CreateTitle(string title, PdfWriter writer);
    internal string get_Title();
    public void AddChild(PdfLayer child);
    public PdfLayer get_Parent();
    public ArrayList get_Children();
    public sealed virtual PdfIndirectReference get_Ref();
    public void set_Ref(PdfIndirectReference value);
    public void set_Name(string value);
    public sealed virtual PdfObject get_PdfObject();
    public bool get_On();
    public void set_On(bool value);
    private PdfDictionary get_Usage();
    public void SetCreatorInfo(string creator, string subtype);
    public void SetLanguage(string lang, bool preferred);
    public void set_Export(bool value);
    public void SetZoom(float min, float max);
    public void SetPrint(string subtype, bool printstate);
    public void set_View(bool value);
    public bool get_OnPanel();
    public void set_OnPanel(bool value);
}
public class iTextSharp.text.pdf.PdfLayerMembership : PdfDictionary {
    public static PdfName ALLON;
    public static PdfName ANYON;
    public static PdfName ANYOFF;
    public static PdfName ALLOFF;
    internal PdfIndirectReference refi;
    internal PdfArray members;
    internal Hashtable layers;
    public PdfIndirectReference Ref { get; }
    public ICollection Layers { get; }
    unknown PdfName VisibilityPolicy {public set; }
    public PdfObject PdfObject { get; }
    public PdfLayerMembership(PdfWriter writer);
    private static PdfLayerMembership();
    public sealed virtual PdfIndirectReference get_Ref();
    public void AddMember(PdfLayer layer);
    public ICollection get_Layers();
    public void set_VisibilityPolicy(PdfName value);
    public sealed virtual PdfObject get_PdfObject();
}
public class iTextSharp.text.pdf.PdfLine : object {
    protected internal ArrayList line;
    protected internal float left;
    protected internal float width;
    protected internal int alignment;
    protected internal float height;
    protected internal Chunk listSymbol;
    protected internal float symbolIndent;
    protected internal bool newlineSplit;
    protected internal float originalWidth;
    protected internal bool isRTL;
    public int Size { get; }
    internal float Height { get; }
    internal float IndentLeft { get; }
    internal float WidthLeft { get; }
    internal int NumberOfSpaces { get; }
    unknown ListItem ListItem {public set; }
    public Chunk ListSymbol { get; }
    public float ListIndent { get; }
    public bool NewlineSplit { get; }
    public int LastStrokeChunk { get; }
    public float OriginalWidth { get; }
    internal bool RTL { get; }
    public float Ascender { get; }
    public float Descender { get; }
    internal PdfLine(float left, float right, int alignment, float height);
    internal PdfLine(float left, float originalWidth, float remainingWidth, int alignment, bool newlineSplit, ArrayList line, bool isRTL);
    internal PdfChunk Add(PdfChunk chunk);
    private void AddToLine(PdfChunk chunk);
    public int get_Size();
    public IEnumerator GetEnumerator();
    internal float get_Height();
    internal float get_IndentLeft();
    public bool HasToBeJustified();
    public void ResetAlignment();
    internal void SetExtraIndent(float extra);
    internal float get_WidthLeft();
    internal int get_NumberOfSpaces();
    public void set_ListItem(ListItem value);
    public Chunk get_ListSymbol();
    public float get_ListIndent();
    public virtual string ToString();
    public int GetLineLengthUtf32();
    public bool get_NewlineSplit();
    public int get_LastStrokeChunk();
    public PdfChunk GetChunk(int idx);
    public float get_OriginalWidth();
    internal Single[] GetMaxSize();
    internal bool get_RTL();
    internal int GetSeparatorCount();
    public float GetWidthCorrected(float charSpacing, float wordSpacing);
    public float get_Ascender();
    public float get_Descender();
}
public class iTextSharp.text.pdf.PdfLiteral : PdfObject {
    private int position;
    public int Position { get; }
    public int PosLength { get; }
    public PdfLiteral(string text);
    public PdfLiteral(Byte[] b);
    public PdfLiteral(int type, string text);
    public PdfLiteral(int type, Byte[] b);
    public PdfLiteral(int size);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public int get_Position();
    public int get_PosLength();
}
public class iTextSharp.text.pdf.PdfMediaClipData : PdfDictionary {
    internal PdfMediaClipData(string file, PdfFileSpecification fs, string mimeType);
}
public class iTextSharp.text.pdf.PdfName : PdfObject {
    public static PdfName _3D;
    public static PdfName A;
    public static PdfName AA;
    public static PdfName ABSOLUTECOLORIMETRIC;
    public static PdfName AC;
    public static PdfName ACROFORM;
    public static PdfName ACTION;
    public static PdfName ACTIVATION;
    public static PdfName ADBE;
    public static PdfName ACTUALTEXT;
    public static PdfName ADBE_PKCS7_DETACHED;
    public static PdfName ADBE_PKCS7_S4;
    public static PdfName ADBE_PKCS7_S5;
    public static PdfName ADBE_PKCS7_SHA1;
    public static PdfName ADBE_X509_RSA_SHA1;
    public static PdfName ADOBE_PPKLITE;
    public static PdfName ADOBE_PPKMS;
    public static PdfName AESV2;
    public static PdfName AIS;
    public static PdfName ALLPAGES;
    public static PdfName ALT;
    public static PdfName ALTERNATE;
    public static PdfName ANIMATION;
    public static PdfName ANNOT;
    public static PdfName ANNOTS;
    public static PdfName ANTIALIAS;
    public static PdfName AP;
    public static PdfName APPDEFAULT;
    public static PdfName ART;
    public static PdfName ARTBOX;
    public static PdfName ASCENT;
    public static PdfName AS;
    public static PdfName ASCII85DECODE;
    public static PdfName ASCIIHEXDECODE;
    public static PdfName ASSET;
    public static PdfName ASSETS;
    public static PdfName AUTHEVENT;
    public static PdfName AUTHOR;
    public static PdfName B;
    public static PdfName BACKGROUND;
    public static PdfName BASEENCODING;
    public static PdfName BASEFONT;
    public static PdfName BASEVERSION;
    public static PdfName BBOX;
    public static PdfName BC;
    public static PdfName BG;
    public static PdfName BIBENTRY;
    public static PdfName BIGFIVE;
    public static PdfName BINDING;
    public static PdfName BINDINGMATERIALNAME;
    public static PdfName BITSPERCOMPONENT;
    public static PdfName BITSPERSAMPLE;
    public static PdfName BL;
    public static PdfName BLACKIS1;
    public static PdfName BLACKPOINT;
    public static PdfName BLOCKQUOTE;
    public static PdfName BLEEDBOX;
    public static PdfName BLINDS;
    public static PdfName BM;
    public static PdfName BORDER;
    public static PdfName BOUNDS;
    public static PdfName BOX;
    public static PdfName BS;
    public static PdfName BTN;
    public static PdfName BYTERANGE;
    public static PdfName C;
    public static PdfName C0;
    public static PdfName C1;
    public static PdfName CA;
    public static PdfName ca_;
    public static PdfName CALGRAY;
    public static PdfName CALRGB;
    public static PdfName CAPHEIGHT;
    public static PdfName CAPTION;
    public static PdfName CATALOG;
    public static PdfName CATEGORY;
    public static PdfName CCITTFAXDECODE;
    public static PdfName CENTER;
    public static PdfName CENTERWINDOW;
    public static PdfName CERT;
    public static PdfName CF;
    public static PdfName CFM;
    public static PdfName CH;
    public static PdfName CHARPROCS;
    public static PdfName CI;
    public static PdfName CIDFONTTYPE0;
    public static PdfName CIDFONTTYPE2;
    public static PdfName CIDSET;
    public static PdfName CIDSYSTEMINFO;
    public static PdfName CIDTOGIDMAP;
    public static PdfName CIRCLE;
    public static PdfName CMD;
    public static PdfName CO;
    public static PdfName CODE;
    public static PdfName COLORS;
    public static PdfName COLORSPACE;
    public static PdfName COLLECTION;
    public static PdfName COLLECTIONFIELD;
    public static PdfName COLLECTIONITEM;
    public static PdfName COLLECTIONSCHEMA;
    public static PdfName COLLECTIONSORT;
    public static PdfName COLLECTIONSUBITEM;
    public static PdfName COLUMNS;
    public static PdfName CONDITION;
    public static PdfName CONFIGURATION;
    public static PdfName CONFIGURATIONS;
    public static PdfName CONTACTINFO;
    public static PdfName CONTENT;
    public static PdfName CONTENTS;
    public static PdfName COORDS;
    public static PdfName COUNT;
    public static PdfName COURIER;
    public static PdfName COURIER_BOLD;
    public static PdfName COURIER_OBLIQUE;
    public static PdfName COURIER_BOLDOBLIQUE;
    public static PdfName CREATIONDATE;
    public static PdfName CREATOR;
    public static PdfName CREATORINFO;
    public static PdfName CROPBOX;
    public static PdfName CRYPT;
    public static PdfName CS;
    public static PdfName CUEPOINT;
    public static PdfName CUEPOINTS;
    public static PdfName D;
    public static PdfName DA;
    public static PdfName DATA;
    public static PdfName DC;
    public static PdfName DCTDECODE;
    public static PdfName DEACTIVATION;
    public static PdfName DECODE;
    public static PdfName DECODEPARMS;
    public static PdfName DEFAULT;
    public static PdfName DEFAULTCRYPTFILTER;
    public static PdfName DEFAULTCMYK;
    public static PdfName DEFAULTGRAY;
    public static PdfName DEFAULTRGB;
    public static PdfName DESC;
    public static PdfName DESCENDANTFONTS;
    public static PdfName DESCENT;
    public static PdfName DEST;
    public static PdfName DESTOUTPUTPROFILE;
    public static PdfName DESTS;
    public static PdfName DEVICEGRAY;
    public static PdfName DEVICERGB;
    public static PdfName DEVICECMYK;
    public static PdfName DI;
    public static PdfName DIFFERENCES;
    public static PdfName DISSOLVE;
    public static PdfName DIRECTION;
    public static PdfName DISPLAYDOCTITLE;
    public static PdfName DIV;
    public static PdfName DM;
    public static PdfName DOCMDP;
    public static PdfName DOCOPEN;
    public static PdfName DOCUMENT;
    public static PdfName DOMAIN;
    public static PdfName DP;
    public static PdfName DR;
    public static PdfName DS;
    public static PdfName DUR;
    public static PdfName DUPLEX;
    public static PdfName DUPLEXFLIPSHORTEDGE;
    public static PdfName DUPLEXFLIPLONGEDGE;
    public static PdfName DV;
    public static PdfName DW;
    public static PdfName E;
    public static PdfName EARLYCHANGE;
    public static PdfName EF;
    public static PdfName EFF;
    public static PdfName EFOPEN;
    public static PdfName EMBEDDED;
    public static PdfName EMBEDDEDFILE;
    public static PdfName EMBEDDEDFILES;
    public static PdfName ENCODE;
    public static PdfName ENCODEDBYTEALIGN;
    public static PdfName ENCODING;
    public static PdfName ENCRYPT;
    public static PdfName ENCRYPTMETADATA;
    public static PdfName ENDOFBLOCK;
    public static PdfName ENDOFLINE;
    public static PdfName EXTEND;
    public static PdfName EXTENSIONS;
    public static PdfName EXTENSIONLEVEL;
    public static PdfName EXTGSTATE;
    public static PdfName EXPORT;
    public static PdfName EXPORTSTATE;
    public static PdfName EVENT;
    public static PdfName F;
    public static PdfName FAR;
    public static PdfName FB;
    public static PdfName FDECODEPARMS;
    public static PdfName FDF;
    public static PdfName FF;
    public static PdfName FFILTER;
    public static PdfName FIELDS;
    public static PdfName FIGURE;
    public static PdfName FILEATTACHMENT;
    public static PdfName FILESPEC;
    public static PdfName FILTER;
    public static PdfName FIRST;
    public static PdfName FIRSTCHAR;
    public static PdfName FIRSTPAGE;
    public static PdfName FIT;
    public static PdfName FITH;
    public static PdfName FITV;
    public static PdfName FITR;
    public static PdfName FITB;
    public static PdfName FITBH;
    public static PdfName FITBV;
    public static PdfName FITWINDOW;
    public static PdfName FLAGS;
    public static PdfName FLASH;
    public static PdfName FLASHVARS;
    public static PdfName FLATEDECODE;
    public static PdfName FO;
    public static PdfName FONT;
    public static PdfName FONTBBOX;
    public static PdfName FONTDESCRIPTOR;
    public static PdfName FONTFILE;
    public static PdfName FONTFILE2;
    public static PdfName FONTFILE3;
    public static PdfName FONTMATRIX;
    public static PdfName FONTNAME;
    public static PdfName FOREGROUND;
    public static PdfName FORM;
    public static PdfName FORMTYPE;
    public static PdfName FORMULA;
    public static PdfName FREETEXT;
    public static PdfName FRM;
    public static PdfName FS;
    public static PdfName FT;
    public static PdfName FULLSCREEN;
    public static PdfName FUNCTION;
    public static PdfName FUNCTIONS;
    public static PdfName FUNCTIONTYPE;
    public static PdfName GAMMA;
    public static PdfName GBK;
    public static PdfName GLITTER;
    public static PdfName GOTO;
    public static PdfName GOTOE;
    public static PdfName GOTOR;
    public static PdfName GROUP;
    public static PdfName GTS_PDFA1;
    public static PdfName GTS_PDFX;
    public static PdfName GTS_PDFXVERSION;
    public static PdfName H;
    public static PdfName H1;
    public static PdfName H2;
    public static PdfName H3;
    public static PdfName H4;
    public static PdfName H5;
    public static PdfName H6;
    public static PdfName HALIGN;
    public static PdfName HEIGHT;
    public static PdfName HELV;
    public static PdfName HELVETICA;
    public static PdfName HELVETICA_BOLD;
    public static PdfName HELVETICA_OBLIQUE;
    public static PdfName HELVETICA_BOLDOBLIQUE;
    public static PdfName HID;
    public static PdfName HIDE;
    public static PdfName HIDEMENUBAR;
    public static PdfName HIDETOOLBAR;
    public static PdfName HIDEWINDOWUI;
    public static PdfName HIGHLIGHT;
    public static PdfName HOFFSET;
    public static PdfName I;
    public static PdfName ICCBASED;
    public static PdfName ID;
    public static PdfName IDENTITY;
    public static PdfName IF;
    public static PdfName IMAGE;
    public static PdfName IMAGEB;
    public static PdfName IMAGEC;
    public static PdfName IMAGEI;
    public static PdfName IMAGEMASK;
    public static PdfName INDEX;
    public static PdfName INDEXED;
    public static PdfName INFO;
    public static PdfName INK;
    public static PdfName INKLIST;
    public static PdfName INSTANCES;
    public static PdfName IMPORTDATA;
    public static PdfName INTENT;
    public static PdfName INTERPOLATE;
    public static PdfName ISMAP;
    public static PdfName IRT;
    public static PdfName ITALICANGLE;
    public static PdfName ITXT;
    public static PdfName IX;
    public static PdfName JAVASCRIPT;
    public static PdfName JBIG2DECODE;
    public static PdfName JBIG2GLOBALS;
    public static PdfName JPXDECODE;
    public static PdfName JS;
    public static PdfName K;
    public static PdfName KEYWORDS;
    public static PdfName KIDS;
    public static PdfName L;
    public static PdfName L2R;
    public static PdfName LANG;
    public static PdfName LANGUAGE;
    public static PdfName LAST;
    public static PdfName LASTCHAR;
    public static PdfName LASTPAGE;
    public static PdfName LAUNCH;
    public static PdfName LBL;
    public static PdfName LBODY;
    public static PdfName LENGTH;
    public static PdfName LENGTH1;
    public static PdfName LI;
    public static PdfName LIMITS;
    public static PdfName LINE;
    public static PdfName LINEAR;
    public static PdfName LINK;
    public static PdfName LISTMODE;
    public static PdfName LOCATION;
    public static PdfName LOCK;
    public static PdfName LOCKED;
    public static PdfName LZWDECODE;
    public static PdfName M;
    public static PdfName MATERIAL;
    public static PdfName MATRIX;
    public static PdfName MAC_EXPERT_ENCODING;
    public static PdfName MAC_ROMAN_ENCODING;
    public static PdfName MARKED;
    public static PdfName MARKINFO;
    public static PdfName MASK;
    public static PdfName MAX_LOWER_CASE;
    public static PdfName MAX_CAMEL_CASE;
    public static PdfName MAXLEN;
    public static PdfName MEDIABOX;
    public static PdfName MCID;
    public static PdfName MCR;
    public static PdfName METADATA;
    public static PdfName MIN_LOWER_CASE;
    public static PdfName MIN_CAMEL_CASE;
    public static PdfName MK;
    public static PdfName MMTYPE1;
    public static PdfName MODDATE;
    public static PdfName N;
    public static PdfName N0;
    public static PdfName N1;
    public static PdfName N2;
    public static PdfName N3;
    public static PdfName N4;
    public static PdfName NAME;
    public static PdfName NAMED;
    public static PdfName NAMES;
    public static PdfName NAVIGATION;
    public static PdfName NAVIGATIONPANE;
    public static PdfName NEAR;
    public static PdfName NEEDAPPEARANCES;
    public static PdfName NEWWINDOW;
    public static PdfName NEXT;
    public static PdfName NEXTPAGE;
    public static PdfName NM;
    public static PdfName NONE;
    public static PdfName NONFULLSCREENPAGEMODE;
    public static PdfName NONSTRUCT;
    public static PdfName NOTE;
    public static PdfName NUMCOPIES;
    public static PdfName NUMS;
    public static PdfName O;
    public static PdfName OBJ;
    public static PdfName OBJR;
    public static PdfName OBJSTM;
    public static PdfName OC;
    public static PdfName OCG;
    public static PdfName OCGS;
    public static PdfName OCMD;
    public static PdfName OCPROPERTIES;
    public static PdfName Off_;
    public static PdfName OFF;
    public static PdfName ON;
    public static PdfName ONECOLUMN;
    public static PdfName OPEN;
    public static PdfName OPENACTION;
    public static PdfName OP;
    public static PdfName op_;
    public static PdfName OPM;
    public static PdfName OPT;
    public static PdfName ORDER;
    public static PdfName ORDERING;
    public static PdfName OSCILLATING;
    public static PdfName OUTLINES;
    public static PdfName OUTPUTCONDITION;
    public static PdfName OUTPUTCONDITIONIDENTIFIER;
    public static PdfName OUTPUTINTENT;
    public static PdfName OUTPUTINTENTS;
    public static PdfName P;
    public static PdfName PAGE;
    public static PdfName PAGELABELS;
    public static PdfName PAGELAYOUT;
    public static PdfName PAGEMODE;
    public static PdfName PAGES;
    public static PdfName PAINTTYPE;
    public static PdfName PANOSE;
    public static PdfName PARAMS;
    public static PdfName PARENT;
    public static PdfName PARENTTREE;
    public static PdfName PARENTTREENEXTKEY;
    public static PdfName PART;
    public static PdfName PASSCONTEXTCLICK;
    public static PdfName PATTERN;
    public static PdfName PATTERNTYPE;
    public static PdfName PC;
    public static PdfName PDF;
    public static PdfName PDFDOCENCODING;
    public static PdfName PERCEPTUAL;
    public static PdfName PERMS;
    public static PdfName PG;
    public static PdfName PI;
    public static PdfName PICKTRAYBYPDFSIZE;
    public static PdfName PLAYCOUNT;
    public static PdfName PO;
    public static PdfName POPUP;
    public static PdfName POSITION;
    public static PdfName PREDICTOR;
    public static PdfName PREFERRED;
    public static PdfName PRESENTATION;
    public static PdfName PRESERVERB;
    public static PdfName PREV;
    public static PdfName PREVPAGE;
    public static PdfName PRINT;
    public static PdfName PRINTAREA;
    public static PdfName PRINTCLIP;
    public static PdfName PRINTPAGERANGE;
    public static PdfName PRINTSCALING;
    public static PdfName PRINTSTATE;
    public static PdfName PRIVATE;
    public static PdfName PROCSET;
    public static PdfName PRODUCER;
    public static PdfName PROPERTIES;
    public static PdfName PS;
    public static PdfName PUBSEC;
    public static PdfName PV;
    public static PdfName Q;
    public static PdfName QUADPOINTS;
    public static PdfName QUOTE;
    public static PdfName R;
    public static PdfName R2L;
    public static PdfName RANGE;
    public static PdfName RC;
    public static PdfName RBGROUPS;
    public static PdfName REASON;
    public static PdfName RECIPIENTS;
    public static PdfName RECT;
    public static PdfName REFERENCE;
    public static PdfName REGISTRY;
    public static PdfName REGISTRYNAME;
    public static PdfName RELATIVECOLORIMETRIC;
    public static PdfName RENDITION;
    public static PdfName RESETFORM;
    public static PdfName RESOURCES;
    public static PdfName RI;
    public static PdfName RICHMEDIA;
    public static PdfName RICHMEDIAACTIVATION;
    public static PdfName RICHMEDIAANIMATION;
    public static PdfName RICHMEDIACOMMAND;
    public static PdfName RICHMEDIACONFIGURATION;
    public static PdfName RICHMEDIACONTENT;
    public static PdfName RICHMEDIADEACTIVATION;
    public static PdfName RICHMEDIAEXECUTE;
    public static PdfName RICHMEDIAINSTANCE;
    public static PdfName RICHMEDIAPARAMS;
    public static PdfName RICHMEDIAPOSITION;
    public static PdfName RICHMEDIAPRESENTATION;
    public static PdfName RICHMEDIASETTINGS;
    public static PdfName RICHMEDIAWINDOW;
    public static PdfName ROLEMAP;
    public static PdfName ROOT;
    public static PdfName ROTATE;
    public static PdfName ROWS;
    public static PdfName RUBY;
    public static PdfName RUNLENGTHDECODE;
    public static PdfName RV;
    public static PdfName S;
    public static PdfName SATURATION;
    public static PdfName SCHEMA;
    public static PdfName SCREEN;
    public static PdfName SCRIPTS;
    public static PdfName SECT;
    public static PdfName SEPARATION;
    public static PdfName SETOCGSTATE;
    public static PdfName SETTINGS;
    public static PdfName SHADING;
    public static PdfName SHADINGTYPE;
    public static PdfName SHIFT_JIS;
    public static PdfName SIG;
    public static PdfName SIGFLAGS;
    public static PdfName SIGREF;
    public static PdfName SIMPLEX;
    public static PdfName SINGLEPAGE;
    public static PdfName SIZE;
    public static PdfName SMASK;
    public static PdfName SORT;
    public static PdfName SOUND;
    public static PdfName SPAN;
    public static PdfName SPEED;
    public static PdfName SPLIT;
    public static PdfName SQUARE;
    public static PdfName SQUIGGLY;
    public static PdfName ST;
    public static PdfName STAMP;
    public static PdfName STANDARD;
    public static PdfName STATE;
    public static PdfName STDCF;
    public static PdfName STEMV;
    public static PdfName STMF;
    public static PdfName STRF;
    public static PdfName STRIKEOUT;
    public static PdfName STRUCTPARENT;
    public static PdfName STRUCTPARENTS;
    public static PdfName STRUCTTREEROOT;
    public static PdfName STYLE;
    public static PdfName SUBFILTER;
    public static PdfName SUBJECT;
    public static PdfName SUBMITFORM;
    public static PdfName SUBTYPE;
    public static PdfName SUPPLEMENT;
    public static PdfName SV;
    public static PdfName SW;
    public static PdfName SYMBOL;
    public static PdfName T;
    public static PdfName TA;
    public static PdfName TABLE;
    public static PdfName TABS;
    public static PdfName TBODY;
    public static PdfName TD;
    public static PdfName TEXT;
    public static PdfName TFOOT;
    public static PdfName TH;
    public static PdfName THEAD;
    public static PdfName THUMB;
    public static PdfName THREADS;
    public static PdfName TI;
    public static PdfName TIME;
    public static PdfName TILINGTYPE;
    public static PdfName TIMES_ROMAN;
    public static PdfName TIMES_BOLD;
    public static PdfName TIMES_ITALIC;
    public static PdfName TIMES_BOLDITALIC;
    public static PdfName TITLE;
    public static PdfName TK;
    public static PdfName TM;
    public static PdfName TOC;
    public static PdfName TOCI;
    public static PdfName TOGGLE;
    public static PdfName TOOLBAR;
    public static PdfName TOUNICODE;
    public static PdfName TP;
    public static PdfName TABLEROW;
    public static PdfName TRANS;
    public static PdfName TRANSFORMPARAMS;
    public static PdfName TRANSFORMMETHOD;
    public static PdfName TRANSPARENCY;
    public static PdfName TRANSPARENT;
    public static PdfName TRAPPED;
    public static PdfName TRIMBOX;
    public static PdfName TRUETYPE;
    public static PdfName TU;
    public static PdfName TWOCOLUMNLEFT;
    public static PdfName TWOCOLUMNRIGHT;
    public static PdfName TWOPAGELEFT;
    public static PdfName TWOPAGERIGHT;
    public static PdfName TX;
    public static PdfName TYPE;
    public static PdfName TYPE0;
    public static PdfName TYPE1;
    public static PdfName TYPE3;
    public static PdfName U;
    public static PdfName UF;
    public static PdfName UHC;
    public static PdfName UNDERLINE;
    public static PdfName UR;
    public static PdfName UR3;
    public static PdfName URI;
    public static PdfName URL;
    public static PdfName USAGE;
    public static PdfName USEATTACHMENTS;
    public static PdfName USENONE;
    public static PdfName USEOC;
    public static PdfName USEOUTLINES;
    public static PdfName USER;
    public static PdfName USERPROPERTIES;
    public static PdfName USERUNIT;
    public static PdfName USETHUMBS;
    public static PdfName V;
    public static PdfName V2;
    public static PdfName VALIGN;
    public static PdfName VERISIGN_PPKVS;
    public static PdfName VERSION;
    public static PdfName VIDEO;
    public static PdfName VIEW;
    public static PdfName VIEWS;
    public static PdfName VIEWAREA;
    public static PdfName VIEWCLIP;
    public static PdfName VIEWERPREFERENCES;
    public static PdfName VIEWSTATE;
    public static PdfName VISIBLEPAGES;
    public static PdfName VOFFSET;
    public static PdfName W;
    public static PdfName W2;
    public static PdfName WARICHU;
    public static PdfName WC;
    public static PdfName WIDGET;
    public static PdfName WIDTH;
    public static PdfName WIDTHS;
    public static PdfName WIN;
    public static PdfName WIN_ANSI_ENCODING;
    public static PdfName WINDOW;
    public static PdfName WINDOWED;
    public static PdfName WIPE;
    public static PdfName WHITEPOINT;
    public static PdfName WP;
    public static PdfName WS;
    public static PdfName X;
    public static PdfName XA;
    public static PdfName XD;
    public static PdfName XFA;
    public static PdfName XML;
    public static PdfName XOBJECT;
    public static PdfName XSTEP;
    public static PdfName XREF;
    public static PdfName XREFSTM;
    public static PdfName XYZ;
    public static PdfName YSTEP;
    public static PdfName ZADB;
    public static PdfName ZAPFDINGBATS;
    public static PdfName ZOOM;
    public static Hashtable staticNames;
    private int hash;
    private static PdfName();
    public PdfName(string name);
    public PdfName(string name, bool lengthCheck);
    public PdfName(Byte[] bytes);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Byte[] EncodeName(string name);
    public static string DecodeName(string name);
}
public class iTextSharp.text.pdf.PdfNameTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Hashtable items, PdfWriter writer);
    private static void IterateItems(PdfDictionary dic, Hashtable items);
    public static Hashtable ReadTree(PdfDictionary dic);
}
public class iTextSharp.text.pdf.PdfNull : PdfObject {
    public static PdfNull PDFNULL;
    private static PdfNull();
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfNumber : PdfObject {
    private double value;
    public int IntValue { get; }
    public double DoubleValue { get; }
    public float FloatValue { get; }
    public PdfNumber(string content);
    public PdfNumber(int value);
    public PdfNumber(double value);
    public PdfNumber(float value);
    public int get_IntValue();
    public double get_DoubleValue();
    public float get_FloatValue();
    public void Increment();
}
public class iTextSharp.text.pdf.PdfNumberTree : object {
    private static int leafSize;
    public static PdfDictionary WriteTree(Hashtable items, PdfWriter writer);
    private static void IterateItems(PdfDictionary dic, Hashtable items);
    public static Hashtable ReadTree(PdfDictionary dic);
}
public abstract class iTextSharp.text.pdf.PdfObject : object {
    public static int BOOLEAN;
    public static int NUMBER;
    public static int STRING;
    public static int NAME;
    public static int ARRAY;
    public static int DICTIONARY;
    public static int STREAM;
    public static int NULL;
    public static int INDIRECT;
    public static string NOTHING;
    public static string TEXT_PDFDOCENCODING;
    public static string TEXT_UNICODE;
    protected Byte[] bytes;
    protected int type;
    protected PRIndirectReference indRef;
    public int Length { get; }
    unknown string Content {protected set; }
    public int Type { get; }
    public PRIndirectReference IndRef { get; public set; }
    protected PdfObject(int type);
    protected PdfObject(int type, string content);
    protected PdfObject(int type, Byte[] bytes);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual Byte[] GetBytes();
    public bool CanBeInObjStm();
    public virtual string ToString();
    public int get_Length();
    protected void set_Content(string value);
    public int get_Type();
    public bool IsNull();
    public bool IsBoolean();
    public bool IsNumber();
    public bool IsString();
    public bool IsName();
    public bool IsArray();
    public bool IsDictionary();
    public bool IsStream();
    public bool IsIndirect();
    public PRIndirectReference get_IndRef();
    public void set_IndRef(PRIndirectReference value);
}
public class iTextSharp.text.pdf.PdfOCProperties : PdfDictionary {
}
public class iTextSharp.text.pdf.PdfOutline : PdfDictionary {
    private PdfIndirectReference reference;
    private int count;
    private PdfOutline parent;
    private PdfDestination destination;
    private PdfAction action;
    protected ArrayList kids;
    protected PdfWriter writer;
    private string tag;
    private bool open;
    private Color color;
    private int style;
    public PdfIndirectReference IndirectReference { get; public set; }
    public PdfOutline Parent { get; }
    public PdfDestination PdfDestination { get; }
    internal int Count { get; internal set; }
    public int Level { get; }
    public ArrayList Kids { get; public set; }
    public string Tag { get; public set; }
    public string Title { get; public set; }
    public bool Open { get; public set; }
    public Color Color { get; public set; }
    public int Style { get; public set; }
    internal PdfOutline(PdfWriter writer);
    public PdfOutline(PdfOutline parent, PdfAction action, string title);
    public PdfOutline(PdfOutline parent, PdfAction action, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, string title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title);
    public PdfOutline(PdfOutline parent, PdfAction action, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, PdfString title, bool open);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfAction action, Paragraph title, bool open);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title);
    public PdfOutline(PdfOutline parent, PdfDestination destination, Paragraph title, bool open);
    internal void InitOutline(PdfOutline parent, string title, bool open);
    public PdfIndirectReference get_IndirectReference();
    public void set_IndirectReference(PdfIndirectReference value);
    public PdfOutline get_Parent();
    public bool SetDestinationPage(PdfIndirectReference pageReference);
    public PdfDestination get_PdfDestination();
    internal int get_Count();
    internal void set_Count(int value);
    public int get_Level();
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public void AddKid(PdfOutline outline);
    public ArrayList get_Kids();
    public void set_Kids(ArrayList value);
    public string get_Tag();
    public void set_Tag(string value);
    public string get_Title();
    public void set_Title(string value);
    public void set_Open(bool value);
    public bool get_Open();
    public Color get_Color();
    public void set_Color(Color value);
    public int get_Style();
    public void set_Style(int value);
}
public class iTextSharp.text.pdf.PdfPage : PdfDictionary {
    private static String[] boxStrings;
    private static PdfName[] boxNames;
    public static PdfNumber PORTRAIT;
    public static PdfNumber LANDSCAPE;
    public static PdfNumber INVERTEDPORTRAIT;
    public static PdfNumber SEASCAPE;
    private PdfRectangle mediaBox;
    internal PdfRectangle MediaBox { get; }
    internal PdfPage(PdfRectangle mediaBox, Hashtable boxSize, PdfDictionary resources, int rotate);
    internal PdfPage(PdfRectangle mediaBox, Hashtable boxSize, PdfDictionary resources);
    private static PdfPage();
    public bool IsParent();
    internal void Add(PdfIndirectReference contents);
    internal PdfRectangle RotateMediaBox();
    internal PdfRectangle get_MediaBox();
}
public class iTextSharp.text.pdf.PdfPageEventHelper : object {
    public virtual void OnOpenDocument(PdfWriter writer, Document document);
    public virtual void OnStartPage(PdfWriter writer, Document document);
    public virtual void OnEndPage(PdfWriter writer, Document document);
    public virtual void OnCloseDocument(PdfWriter writer, Document document);
    public virtual void OnParagraph(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnParagraphEnd(PdfWriter writer, Document document, float paragraphPosition);
    public virtual void OnChapter(PdfWriter writer, Document document, float paragraphPosition, Paragraph title);
    public virtual void OnChapterEnd(PdfWriter writer, Document document, float position);
    public virtual void OnSection(PdfWriter writer, Document document, float paragraphPosition, int depth, Paragraph title);
    public virtual void OnSectionEnd(PdfWriter writer, Document document, float position);
    public virtual void OnGenericTag(PdfWriter writer, Document document, Rectangle rect, string text);
}
public class iTextSharp.text.pdf.PdfPageLabels : object {
    public static int DECIMAL_ARABIC_NUMERALS;
    public static int UPPERCASE_ROMAN_NUMERALS;
    public static int LOWERCASE_ROMAN_NUMERALS;
    public static int UPPERCASE_LETTERS;
    public static int LOWERCASE_LETTERS;
    public static int EMPTY;
    internal static PdfName[] numberingStyle;
    internal Hashtable map;
    private static PdfPageLabels();
    public void AddPageLabel(int page, int numberStyle, string text, int firstPage);
    public void AddPageLabel(int page, int numberStyle, string text);
    public void AddPageLabel(int page, int numberStyle);
    public void AddPageLabel(PdfPageLabelFormat format);
    public void RemovePageLabel(int page);
    internal PdfDictionary GetDictionary(PdfWriter writer);
    public static String[] GetPageLabels(PdfReader reader);
    public static PdfPageLabelFormat[] GetPageLabelFormats(PdfReader reader);
}
public class iTextSharp.text.pdf.PdfPages : object {
    private ArrayList pages;
    private ArrayList parents;
    private int leafSize;
    private PdfWriter writer;
    private PdfIndirectReference topParent;
    internal PdfIndirectReference TopParent { get; }
    internal PdfPages(PdfWriter writer);
    internal void AddPage(PdfDictionary page);
    internal PdfIndirectReference AddPageRef(PdfIndirectReference pageRef);
    internal PdfIndirectReference WritePageTree();
    internal PdfIndirectReference get_TopParent();
    internal void SetLinearMode(PdfIndirectReference topParent);
    internal void AddPage(PdfIndirectReference page);
    internal int ReorderPages(Int32[] order);
}
public class iTextSharp.text.pdf.PdfPattern : PdfStream {
    internal PdfPattern(PdfPatternPainter painter);
    internal PdfPattern(PdfPatternPainter painter, int compressionLevel);
}
public class iTextSharp.text.pdf.PdfPatternPainter : PdfTemplate {
    internal float xstep;
    internal float ystep;
    internal bool stencil;
    internal Color defaultColor;
    public float XStep { get; public set; }
    public float YStep { get; public set; }
    public PdfContentByte Duplicate { get; }
    public Color DefaultColor { get; }
    internal PdfPatternPainter(PdfWriter wr);
    internal PdfPatternPainter(PdfWriter wr, Color defaultColor);
    public float get_XStep();
    public void set_XStep(float value);
    public float get_YStep();
    public void set_YStep(float value);
    public bool IsStencil();
    public void SetPatternMatrix(float a, float b, float c, float d, float e, float f);
    internal PdfPattern GetPattern();
    internal PdfPattern GetPattern(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public Color get_DefaultColor();
    public virtual void SetGrayFill(float gray);
    public virtual void ResetGrayFill();
    public virtual void SetGrayStroke(float gray);
    public virtual void ResetGrayStroke();
    public virtual void SetRGBColorFillF(float red, float green, float blue);
    public virtual void ResetRGBColorFill();
    public virtual void SetRGBColorStrokeF(float red, float green, float blue);
    public virtual void ResetRGBColorStroke();
    public virtual void SetCMYKColorFillF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorFill();
    public virtual void SetCMYKColorStrokeF(float cyan, float magenta, float yellow, float black);
    public virtual void ResetCMYKColorStroke();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f);
    public virtual void SetCMYKColorFill(int cyan, int magenta, int yellow, int black);
    public virtual void SetCMYKColorStroke(int cyan, int magenta, int yellow, int black);
    public virtual void SetRGBColorFill(int red, int green, int blue);
    public virtual void SetRGBColorStroke(int red, int green, int blue);
    public virtual void SetColorStroke(Color color);
    public virtual void SetColorFill(Color color);
    public virtual void SetColorFill(PdfSpotColor sp, float tint);
    public virtual void SetColorStroke(PdfSpotColor sp, float tint);
    public virtual void SetPatternFill(PdfPatternPainter p);
    public virtual void SetPatternFill(PdfPatternPainter p, Color color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p, Color color, float tint);
    public virtual void SetPatternStroke(PdfPatternPainter p);
    internal void CheckNoColor();
}
public class iTextSharp.text.pdf.PdfPCell : Rectangle {
    private ColumnText column;
    private int verticalAlignment;
    private float paddingLeft;
    private float paddingRight;
    private float paddingTop;
    private float paddingBottom;
    private float fixedHeight;
    private bool noWrap;
    private PdfPTable table;
    private float minimumHeight;
    private int colspan;
    private int rowspan;
    private Image image;
    private IPdfPCellEvent cellEvent;
    private bool useDescender;
    private bool useBorderPadding;
    protected Phrase phrase;
    private int rotation;
    public Phrase Phrase { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float EffectivePaddingLeft { get; }
    public float PaddingLeft { get; public set; }
    public float EffectivePaddingRight { get; }
    public float PaddingRight { get; public set; }
    public float EffectivePaddingTop { get; }
    public float PaddingTop { get; public set; }
    public float EffectivePaddingBottom { get; }
    public float PaddingBottom { get; public set; }
    unknown float Padding {public set; }
    public bool UseBorderPadding { get; public set; }
    public float Leading { get; }
    public float MultipliedLeading { get; }
    public float Indent { get; public set; }
    public float ExtraParagraphSpace { get; public set; }
    public float FixedHeight { get; public set; }
    public bool NoWrap { get; public set; }
    public PdfPTable Table { get; public set; }
    public float MinimumHeight { get; public set; }
    public int Colspan { get; public set; }
    public int Rowspan { get; public set; }
    public float FollowingIndent { get; public set; }
    public float RightIndent { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public Image Image { get; public set; }
    public IPdfPCellEvent CellEvent { get; public set; }
    public int ArabicOptions { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public ColumnText Column { get; public set; }
    public ArrayList CompositeElements { get; }
    public int Rotation { get; public set; }
    public PdfPCell(Phrase phrase);
    public PdfPCell(Image image);
    public PdfPCell(Image image, bool fit);
    public PdfPCell(PdfPTable table);
    public PdfPCell(PdfPTable table, PdfPCell style);
    public PdfPCell(PdfPCell cell);
    public void AddElement(IElement element);
    public Phrase get_Phrase();
    public void set_Phrase(Phrase value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public int get_VerticalAlignment();
    public void set_VerticalAlignment(int value);
    public float get_EffectivePaddingLeft();
    public float get_PaddingLeft();
    public void set_PaddingLeft(float value);
    public float get_EffectivePaddingRight();
    public float get_PaddingRight();
    public void set_PaddingRight(float value);
    public float get_EffectivePaddingTop();
    public float get_PaddingTop();
    public void set_PaddingTop(float value);
    public float get_EffectivePaddingBottom();
    public float get_PaddingBottom();
    public void set_PaddingBottom(float value);
    public void set_Padding(float value);
    public void set_UseBorderPadding(bool value);
    public bool get_UseBorderPadding();
    public void SetLeading(float fixedLeading, float multipliedLeading);
    public float get_Leading();
    public float get_MultipliedLeading();
    public float get_Indent();
    public void set_Indent(float value);
    public float get_ExtraParagraphSpace();
    public void set_ExtraParagraphSpace(float value);
    public float get_FixedHeight();
    public void set_FixedHeight(float value);
    public bool HasFixedHeight();
    public void set_NoWrap(bool value);
    public bool get_NoWrap();
    public PdfPTable get_Table();
    public void set_Table(PdfPTable value);
    public float get_MinimumHeight();
    public void set_MinimumHeight(float value);
    public bool HasMinimumHeight();
    public int get_Colspan();
    public void set_Colspan(int value);
    public int get_Rowspan();
    public void set_Rowspan(int value);
    public float get_FollowingIndent();
    public void set_FollowingIndent(float value);
    public float get_RightIndent();
    public void set_RightIndent(float value);
    public float get_SpaceCharRatio();
    public void set_SpaceCharRatio(float value);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public Image get_Image();
    public void set_Image(Image value);
    public IPdfPCellEvent get_CellEvent();
    public void set_CellEvent(IPdfPCellEvent value);
    public int get_ArabicOptions();
    public void set_ArabicOptions(int value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public ColumnText get_Column();
    public void set_Column(ColumnText value);
    public ArrayList get_CompositeElements();
    public void set_Rotation(int value);
    public int get_Rotation();
    internal void ConsumeHeight(float height);
    public float GetMaxHeight();
}
public class iTextSharp.text.pdf.PdfPKCS7 : object {
    private static string ID_PKCS7_DATA;
    private static string ID_PKCS7_SIGNED_DATA;
    private static string ID_RSA;
    private static string ID_DSA;
    private static string ID_CONTENT_TYPE;
    private static string ID_MESSAGE_DIGEST;
    private static string ID_SIGNING_TIME;
    private static string ID_ADBE_REVOCATION;
    private Byte[] sigAttr;
    private Byte[] digestAttr;
    private int version;
    private int signerversion;
    private Hashtable digestalgos;
    private ArrayList certs;
    private ArrayList crls;
    private ArrayList signCerts;
    private X509Certificate signCert;
    private Byte[] digest;
    private IDigest messageDigest;
    private string digestAlgorithm;
    private string digestEncryptionAlgorithm;
    private ISigner sig;
    private ICipherParameters privKey;
    private Byte[] RSAdata;
    private bool verified;
    private bool verifyResult;
    private Byte[] externalDigest;
    private Byte[] externalRSAdata;
    private string reason;
    private string location;
    private DateTime signDate;
    private string signName;
    private TimeStampToken timeStampToken;
    private static Hashtable digestNames;
    private static Hashtable algorithmNames;
    private static Hashtable allowedDigests;
    private BasicOcspResp basicResp;
    public TimeStampToken TimeStampToken { get; }
    public DateTime TimeStampDate { get; }
    public BasicOcspResp Ocsp { get; }
    public X509Certificate[] Certificates { get; }
    public X509Certificate[] SignCertificateChain { get; }
    public ArrayList CRLs { get; }
    public X509Certificate SigningCertificate { get; }
    public int Version { get; }
    public int SigningInfoVersion { get; }
    public string Reason { get; public set; }
    public string Location { get; public set; }
    public DateTime SignDate { get; public set; }
    public string SignName { get; public set; }
    private static PdfPKCS7();
    public PdfPKCS7(Byte[] contentsKey, Byte[] certsKey);
    public PdfPKCS7(Byte[] contentsKey);
    public PdfPKCS7(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList, string hashAlgorithm, bool hasRSAdata);
    public static string GetDigest(string oid);
    public static string GetAlgorithm(string oid);
    public TimeStampToken get_TimeStampToken();
    public DateTime get_TimeStampDate();
    public BasicOcspResp get_Ocsp();
    private void FindOcsp(Asn1Sequence seq);
    public void Update(Byte[] buf, int off, int len);
    public bool Verify();
    public bool VerifyTimestampImprint();
    public X509Certificate[] get_Certificates();
    public X509Certificate[] get_SignCertificateChain();
    private void CalcSignCertificateChain();
    public ArrayList get_CRLs();
    public X509Certificate get_SigningCertificate();
    public int get_Version();
    public int get_SigningInfoVersion();
    public string GetDigestAlgorithm();
    public string GetHashAlgorithm();
    internal IDigest GetHashClass();
    public static string VerifyCertificate(X509Certificate cert, Object[] crls, DateTime calendar);
    public static Object[] VerifyCertificates(X509Certificate[] certs, ArrayList keystore, Object[] crls, DateTime calendar);
    public static bool VerifyOcspCertificates(BasicOcspResp ocsp, ArrayList keystore);
    public static bool VerifyTimestampCertificates(TimeStampToken ts, ArrayList keystore);
    public static string GetOCSPURL(X509Certificate certificate);
    public bool IsRevocationValid();
    private static Asn1Object GetExtensionValue(X509Certificate cert, string oid);
    private static string GetStringFromGeneralName(Asn1Object names);
    private static Asn1Object GetIssuer(Byte[] enc);
    private static Asn1Object GetSubject(Byte[] enc);
    public static X509Name GetIssuerFields(X509Certificate cert);
    public static X509Name GetSubjectFields(X509Certificate cert);
    public Byte[] GetEncodedPKCS1();
    public void SetExternalDigest(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    public Byte[] GetEncodedPKCS7();
    public Byte[] GetEncodedPKCS7(Byte[] secondDigest, DateTime signingTime);
    public Byte[] GetEncodedPKCS7(Byte[] secondDigest, DateTime signingTime, ITSAClient tsaClient, Byte[] ocsp);
    private Asn1EncodableVector BuildUnauthenticatedAttributes(Byte[] timeStampToken);
    public Byte[] GetAuthenticatedAttributeBytes(Byte[] secondDigest, DateTime signingTime, Byte[] ocsp);
    private DerSet GetAuthenticatedAttributeSet(Byte[] secondDigest, DateTime signingTime, Byte[] ocsp);
    public string get_Reason();
    public void set_Reason(string value);
    public string get_Location();
    public void set_Location(string value);
    public DateTime get_SignDate();
    public void set_SignDate(DateTime value);
    public string get_SignName();
    public void set_SignName(string value);
}
public class iTextSharp.text.pdf.PdfPRow : object {
    public static float BOTTOM_LIMIT;
    public static float RIGHT_LIMIT;
    protected PdfPCell[] cells;
    protected Single[] widths;
    protected Single[] extraHeights;
    protected float maxHeight;
    protected bool calculated;
    private Int32[] canvasesPos;
    public float MaxHeights { get; public set; }
    public PdfPRow(PdfPCell[] cells);
    public PdfPRow(PdfPRow row);
    public bool SetWidths(Single[] widths);
    public void InitExtraHeights();
    public void SetExtraHeight(int cell, float height);
    public float CalculateHeights();
    public void WriteBorderAndBackground(float xPos, float yPos, float currentMaxHeight, PdfPCell cell, PdfContentByte[] canvases);
    protected void SaveAndRotateCanvases(PdfContentByte[] canvases, float a, float b, float c, float d, float e, float f);
    protected void RestoreCanvases(PdfContentByte[] canvases);
    public static float SetColumn(ColumnText ct, float left, float bottom, float right, float top);
    public void WriteCells(int colStart, int colEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public bool IsCalculated();
    public float get_MaxHeights();
    public void set_MaxHeights(float value);
    internal Single[] GetEventWidth(float xPos);
    public PdfPRow SplitRow(PdfPTable table, int rowIndex, float new_height);
    public PdfPCell[] GetCells();
}
public class iTextSharp.text.pdf.PdfPSXObject : PdfTemplate {
    public PdfContentByte Duplicate { get; }
    public PdfPSXObject(PdfWriter wr);
    internal virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
}
public class iTextSharp.text.pdf.PdfPTable : object {
    public static int BASECANVAS;
    public static int BACKGROUNDCANVAS;
    public static int LINECANVAS;
    public static int TEXTCANVAS;
    protected ArrayList rows;
    protected float totalHeight;
    protected PdfPCell[] currentRow;
    protected int currentRowIdx;
    protected PdfPCell defaultCell;
    protected float totalWidth;
    protected Single[] relativeWidths;
    protected Single[] absoluteWidths;
    protected IPdfPTableEvent tableEvent;
    protected int headerRows;
    protected float widthPercentage;
    private int horizontalAlignment;
    private bool skipFirstHeader;
    private bool skipLastFooter;
    protected bool isColspan;
    protected int runDirection;
    private bool lockedWidth;
    private bool splitRows;
    protected float spacingBefore;
    protected float spacingAfter;
    private bool extendLastRow;
    private bool headersInEvent;
    private bool splitLate;
    private bool keepTogether;
    protected bool complete;
    private int footerRows;
    protected bool rowCompleted;
    public float TotalWidth { get; public set; }
    public PdfPCell DefaultCell { get; }
    public int Size { get; }
    public float TotalHeight { get; }
    public float HeaderHeight { get; }
    public float FooterHeight { get; }
    public int NumberOfColumns { get; }
    public int HeaderRows { get; public set; }
    public int FooterRows { get; public set; }
    public ArrayList Chunks { get; }
    public int Type { get; }
    public float WidthPercentage { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public ArrayList Rows { get; }
    public IPdfPTableEvent TableEvent { get; public set; }
    public Single[] AbsoluteWidths { get; }
    public bool SkipFirstHeader { get; public set; }
    public bool SkipLastFooter { get; public set; }
    public int RunDirection { get; public set; }
    public bool LockedWidth { get; public set; }
    public bool SplitRows { get; public set; }
    public float SpacingBefore { get; public set; }
    public float SpacingAfter { get; public set; }
    public bool ExtendLastRow { get; public set; }
    public bool HeadersInEvent { get; public set; }
    public bool SplitLate { get; public set; }
    public bool KeepTogether { get; public set; }
    public bool ElementComplete { get; public set; }
    public PdfPTable(Single[] relativeWidths);
    public PdfPTable(int numColumns);
    public PdfPTable(PdfPTable table);
    public static PdfPTable ShallowCopy(PdfPTable table);
    protected internal void CopyFormat(PdfPTable sourceTable);
    public void SetWidths(Single[] relativeWidths);
    public void SetWidths(Int32[] relativeWidths);
    protected internal void CalculateWidths();
    public void SetTotalWidth(Single[] columnWidth);
    public void SetWidthPercentage(Single[] columnWidth, Rectangle pageSize);
    public float get_TotalWidth();
    public void set_TotalWidth(float value);
    public float CalculateHeights(bool firsttime);
    public void CalculateHeightsFast();
    public PdfPCell get_DefaultCell();
    public void AddCell(PdfPCell cell);
    private void SkipColsWithRowspanAbove();
    internal bool RowSpanAbove(int currRow, int currCol);
    public void AddCell(string text);
    public void AddCell(PdfPTable table);
    public void AddCell(Image image);
    public void AddCell(Phrase phrase);
    public float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte[] canvases);
    public float WriteSelectedRows(int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public float WriteSelectedRows(int colStart, int colEnd, int rowStart, int rowEnd, float xPos, float yPos, PdfContentByte canvas);
    public static PdfContentByte[] BeginWritingRows(PdfContentByte canvas);
    public static void EndWritingRows(PdfContentByte[] canvases);
    public int get_Size();
    public float get_TotalHeight();
    public float GetRowHeight(int idx);
    public float GetRowHeight(int idx, bool firsttime);
    public float GetRowspanHeight(int rowIndex, int cellIndex);
    public float get_HeaderHeight();
    public float get_FooterHeight();
    public bool DeleteRow(int rowNumber);
    public bool DeleteLastRow();
    public void DeleteBodyRows();
    public int get_NumberOfColumns();
    public int get_HeaderRows();
    public void set_HeaderRows(int value);
    public int get_FooterRows();
    public void set_FooterRows(int value);
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual int get_Type();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public sealed virtual bool Process(IElementListener listener);
    public float get_WidthPercentage();
    public void set_WidthPercentage(float value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public PdfPRow GetRow(int idx);
    public ArrayList get_Rows();
    public ArrayList GetRows(int start, int end);
    protected PdfPRow AdjustCellsInRow(int start, int end);
    public IPdfPTableEvent get_TableEvent();
    public void set_TableEvent(IPdfPTableEvent value);
    public Single[] get_AbsoluteWidths();
    internal Single[][] GetEventWidths(float xPos, int firstRow, int lastRow, bool includeHeaders);
    public bool get_SkipFirstHeader();
    public void set_SkipFirstHeader(bool value);
    public bool get_SkipLastFooter();
    public void set_SkipLastFooter(bool value);
    public int get_RunDirection();
    public void set_RunDirection(int value);
    public bool get_LockedWidth();
    public void set_LockedWidth(bool value);
    public bool get_SplitRows();
    public void set_SplitRows(bool value);
    public float get_SpacingBefore();
    public void set_SpacingBefore(float value);
    public float get_SpacingAfter();
    public void set_SpacingAfter(float value);
    public bool get_ExtendLastRow();
    public void set_ExtendLastRow(bool value);
    public bool get_HeadersInEvent();
    public void set_HeadersInEvent(bool value);
    public bool get_SplitLate();
    public void set_SplitLate(bool value);
    public void set_KeepTogether(bool value);
    public bool get_KeepTogether();
    public void CompleteRow();
    public sealed virtual void FlushContent();
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
}
public class iTextSharp.text.pdf.PdfPublicKeyRecipient : object {
    private X509Certificate certificate;
    private int permission;
    protected Byte[] cms;
    public X509Certificate Certificate { get; }
    public int Permission { get; }
    protected internal Byte[] Cms { get; protected internal set; }
    public PdfPublicKeyRecipient(X509Certificate certificate, int permission);
    public X509Certificate get_Certificate();
    public int get_Permission();
    protected internal void set_Cms(Byte[] value);
    protected internal Byte[] get_Cms();
}
public class iTextSharp.text.pdf.PdfPublicKeySecurityHandler : object {
    private static int SEED_LENGTH;
    private ArrayList recipients;
    private Byte[] seed;
    public void AddRecipient(PdfPublicKeyRecipient recipient);
    protected internal Byte[] GetSeed();
    public int GetRecipientsSize();
    public Byte[] GetEncodedRecipient(int index);
    public PdfArray GetEncodedRecipients();
    private Asn1Object CreateDERForRecipient(Byte[] inp, X509Certificate cert);
    private KeyTransRecipientInfo ComputeRecipientInfo(X509Certificate x509certificate, Byte[] abyte0);
}
public class iTextSharp.text.pdf.PdfReader : object {
    private static PdfName[] pageInhCandidates;
    private static Byte[] endstream;
    private static Byte[] endobj;
    protected internal PRTokeniser tokens;
    protected internal Int32[] xref;
    protected internal Hashtable objStmMark;
    protected internal IntHashtable objStmToOffset;
    protected internal bool newXrefType;
    private ArrayList xrefObj;
    private PdfDictionary rootPages;
    protected internal PdfDictionary trailer;
    protected internal PdfDictionary catalog;
    protected internal PageRefs pageRefs;
    protected internal PRAcroForm acroForm;
    protected internal bool acroFormParsed;
    protected internal bool encrypted;
    protected internal bool rebuilt;
    protected internal int freeXref;
    protected internal bool tampered;
    protected internal int lastXref;
    protected internal int eofPos;
    protected internal char pdfVersion;
    protected internal PdfEncryption decrypt;
    protected internal Byte[] password;
    protected ICipherParameters certificateKey;
    protected X509Certificate certificate;
    private bool ownerPasswordUsed;
    protected internal ArrayList strings;
    protected internal bool sharedStreams;
    protected internal bool consolidateNamedDestinations;
    protected internal int rValue;
    protected internal int pValue;
    private int objNum;
    private int objGen;
    private int fileLength;
    private bool hybridXref;
    private int lastXrefPartial;
    private bool partial;
    private PRIndirectReference cryptoRef;
    private PdfViewerPreferencesImp viewerPreferences;
    private bool encryptionError;
    private bool appendable;
    private int readDepth;
    public RandomAccessFileOrArray SafeFile { get; }
    public int NumberOfPages { get; }
    public PdfDictionary Catalog { get; }
    public PRAcroForm AcroForm { get; }
    public Hashtable Info { get; }
    public bool Tampered { get; public set; }
    public Byte[] Metadata { get; }
    public int LastXref { get; }
    public int XrefSize { get; }
    public int EofPos { get; }
    public char PdfVersion { get; }
    public int Permissions { get; }
    public PdfDictionary Trailer { get; }
    internal PdfEncryption Decrypt { get; }
    public AcroFields AcroFields { get; }
    public string JavaScript { get; }
    unknown int ViewerPreferences {public set; }
    public int SimpleViewerPreferences { get; }
    public bool Appendable { get; public set; }
    public int FileLength { get; }
    public bool IsOpenedWithFullPermissions { get; }
    public PdfReader(string filename);
    public PdfReader(string filename, Byte[] ownerPassword);
    public PdfReader(Byte[] pdfIn);
    public PdfReader(Byte[] pdfIn, Byte[] ownerPassword);
    public PdfReader(string filename, X509Certificate certificate, ICipherParameters certificateKey);
    public PdfReader(Uri url);
    public PdfReader(Uri url, Byte[] ownerPassword);
    public PdfReader(Stream isp, Byte[] ownerPassword);
    public PdfReader(Stream isp);
    public PdfReader(RandomAccessFileOrArray raf, Byte[] ownerPassword);
    public PdfReader(PdfReader reader);
    private static PdfReader();
    public RandomAccessFileOrArray get_SafeFile();
    protected internal PdfReaderInstance GetPdfReaderInstance(PdfWriter writer);
    public int get_NumberOfPages();
    public PdfDictionary get_Catalog();
    public PRAcroForm get_AcroForm();
    public int GetPageRotation(int index);
    internal int GetPageRotation(PdfDictionary page);
    public Rectangle GetPageSizeWithRotation(int index);
    public Rectangle GetPageSizeWithRotation(PdfDictionary page);
    public Rectangle GetPageSize(int index);
    public Rectangle GetPageSize(PdfDictionary page);
    public Rectangle GetCropBox(int index);
    public Rectangle GetBoxSize(int index, string boxName);
    public Hashtable get_Info();
    public static Rectangle GetNormalizedRectangle(PdfArray box);
    protected internal virtual void ReadPdf();
    protected internal void ReadPdfPartial();
    private bool EqualsArray(Byte[] ar1, Byte[] ar2, int size);
    private void ReadDecryptedDocObj();
    public static PdfObject GetPdfObjectRelease(PdfObject obj);
    public static PdfObject GetPdfObject(PdfObject obj);
    public static PdfObject GetPdfObjectRelease(PdfObject obj, PdfObject parent);
    public static PdfObject GetPdfObject(PdfObject obj, PdfObject parent);
    public PdfObject GetPdfObjectRelease(int idx);
    public PdfObject GetPdfObject(int idx);
    public void ResetLastXrefPartial();
    public void ReleaseLastXrefPartial();
    public static void ReleaseLastXrefPartial(PdfObject obj);
    private void SetXrefPartialObject(int idx, PdfObject obj);
    public PRIndirectReference AddPdfObject(PdfObject obj);
    protected internal void ReadPages();
    protected internal void ReadDocObjPartial();
    protected internal PdfObject ReadSingleObject(int k);
    protected internal PdfObject ReadOneObjStm(PRStream stream, int idx);
    public double DumpPerc();
    protected internal void ReadDocObj();
    private void CheckPRStreamLength(PRStream stream);
    protected internal void ReadObjStm(PRStream stream, IntHashtable map);
    public static PdfObject KillIndirect(PdfObject obj);
    private void EnsureXrefSize(int size);
    protected internal void ReadXref();
    protected internal PdfDictionary ReadXrefSection();
    protected internal bool ReadXRefStream(int ptr);
    protected internal void RebuildXref();
    protected internal PdfDictionary ReadDictionary();
    protected internal PdfArray ReadArray();
    protected internal PdfObject ReadPRObject();
    public static Byte[] FlateDecode(Byte[] inp);
    public static Byte[] DecodePredictor(Byte[] inp, PdfObject dicPar);
    public static Byte[] FlateDecode(Byte[] inp, bool strict);
    public static Byte[] ASCIIHexDecode(Byte[] inp);
    public static Byte[] ASCII85Decode(Byte[] inp);
    public static Byte[] LZWDecode(Byte[] inp);
    public bool IsRebuilt();
    public PdfDictionary GetPageN(int pageNum);
    public PdfDictionary GetPageNRelease(int pageNum);
    public void ReleasePage(int pageNum);
    public void ResetReleasePage();
    public PRIndirectReference GetPageOrigRef(int pageNum);
    public Byte[] GetPageContent(int pageNum, RandomAccessFileOrArray file);
    public Byte[] GetPageContent(int pageNum);
    protected internal void KillXref(PdfObject obj);
    public void SetPageContent(int pageNum, Byte[] content);
    public void SetPageContent(int pageNum, Byte[] content, int compressionLevel);
    public static Byte[] GetStreamBytes(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytes(PRStream stream);
    public static Byte[] GetStreamBytesRaw(PRStream stream, RandomAccessFileOrArray file);
    public static Byte[] GetStreamBytesRaw(PRStream stream);
    public void EliminateSharedStreams();
    public bool get_Tampered();
    public void set_Tampered(bool value);
    public Byte[] get_Metadata();
    public int get_LastXref();
    public int get_XrefSize();
    public int get_EofPos();
    public char get_PdfVersion();
    public bool IsEncrypted();
    public int get_Permissions();
    public bool Is128Key();
    public PdfDictionary get_Trailer();
    internal PdfEncryption get_Decrypt();
    internal static bool Equalsn(Byte[] a1, Byte[] a2);
    internal static bool ExistsName(PdfDictionary dic, PdfName key, PdfName value);
    internal static string GetFontName(PdfDictionary dic);
    internal static string GetSubsetPrefix(PdfDictionary dic);
    public int ShuffleSubsetNames();
    public int CreateFakeFontSubsets();
    private static PdfArray GetNameArray(PdfObject obj);
    public Hashtable GetNamedDestination();
    public Hashtable GetNamedDestination(bool keepNames);
    public Hashtable GetNamedDestinationFromNames();
    public Hashtable GetNamedDestinationFromNames(bool keepNames);
    public Hashtable GetNamedDestinationFromStrings();
    private bool ReplaceNamedDestination(PdfObject obj, Hashtable names);
    public void RemoveFields();
    public void RemoveAnnotations();
    public ArrayList GetLinks(int page);
    private void IterateBookmarks(PdfObject outlineRef, Hashtable names);
    public void ConsolidateNamedDestinations();
    protected internal static PdfDictionary DuplicatePdfDictionary(PdfDictionary original, PdfDictionary copy, PdfReader newReader);
    protected internal static PdfObject DuplicatePdfObject(PdfObject original, PdfReader newReader);
    public void Close();
    protected internal void RemoveUnusedNode(PdfObject obj, Boolean[] hits);
    public int RemoveUnusedObjects();
    public AcroFields get_AcroFields();
    public string GetJavaScript(RandomAccessFileOrArray file);
    public string get_JavaScript();
    public void SelectPages(string ranges);
    public void SelectPages(ArrayList pagesToKeep);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    internal virtual void SetViewerPreferences(PdfViewerPreferencesImp vp);
    public virtual int get_SimpleViewerPreferences();
    public void set_Appendable(bool value);
    public bool get_Appendable();
    public bool IsNewXrefType();
    public int get_FileLength();
    public bool IsHybridXref();
    internal PdfIndirectReference GetCryptoRef();
    public void RemoveUsageRights();
    public int GetCertificationLevel();
    public bool get_IsOpenedWithFullPermissions();
    public int GetCryptoMode();
    public bool IsMetadataEncrypted();
    public Byte[] ComputeUserPassword();
}
public class iTextSharp.text.pdf.PdfReaderInstance : object {
    internal static PdfLiteral IDENTITYMATRIX;
    internal static PdfNumber ONE;
    internal Int32[] myXref;
    internal PdfReader reader;
    internal RandomAccessFileOrArray file;
    internal Hashtable importedPages;
    internal PdfWriter writer;
    internal Hashtable visited;
    internal ArrayList nextRound;
    internal PdfReader Reader { get; }
    internal RandomAccessFileOrArray ReaderFile { get; }
    internal PdfReaderInstance(PdfReader reader, PdfWriter writer);
    private static PdfReaderInstance();
    internal PdfReader get_Reader();
    internal PdfImportedPage GetImportedPage(int pageNumber);
    internal int GetNewObjectNumber(int number, int generation);
    internal RandomAccessFileOrArray get_ReaderFile();
    internal PdfObject GetResources(int pageNumber);
    internal PdfStream GetFormXObject(int pageNumber, int compressionLevel);
    internal void WriteAllVisited();
    internal void WriteAllPages();
}
public class iTextSharp.text.pdf.PdfRectangle : PdfArray {
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    public Rectangle Rectangle { get; }
    public float Left { get; }
    public float Right { get; }
    public float Top { get; }
    public float Bottom { get; }
    public float Width { get; }
    public float Height { get; }
    public PdfRectangle Rotate { get; }
    public PdfRectangle(float llx, float lly, float urx, float ury, int rotation);
    public PdfRectangle(float llx, float lly, float urx, float ury);
    public PdfRectangle(float urx, float ury, int rotation);
    public PdfRectangle(float urx, float ury);
    public PdfRectangle(Rectangle rectangle, int rotation);
    public PdfRectangle(Rectangle rectangle);
    public Rectangle get_Rectangle();
    public virtual bool Add(PdfObject obj);
    public virtual bool Add(Single[] values);
    public virtual bool Add(Int32[] values);
    public virtual void AddFirst(PdfObject obj);
    public float get_Left();
    public float get_Right();
    public float get_Top();
    public float get_Bottom();
    public float GetLeft(int margin);
    public float GetRight(int margin);
    public float GetTop(int margin);
    public float GetBottom(int margin);
    public float get_Width();
    public float get_Height();
    public PdfRectangle get_Rotate();
}
public class iTextSharp.text.pdf.PdfRendition : PdfDictionary {
    public PdfRendition(string file, PdfFileSpecification fs, string mimeType);
}
internal class iTextSharp.text.pdf.PdfResources : PdfDictionary {
    internal void Add(PdfName key, PdfDictionary resource);
}
public class iTextSharp.text.pdf.PdfShading : object {
    protected PdfDictionary shading;
    protected PdfWriter writer;
    protected int shadingType;
    protected ColorDetails colorDetails;
    protected PdfName shadingName;
    protected PdfIndirectReference shadingReference;
    protected Single[] bBox;
    protected bool antiAlias;
    private Color cspace;
    public Color ColorSpace { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    internal PdfWriter Writer { get; }
    internal ColorDetails ColorDetails { get; }
    public Single[] BBox { get; public set; }
    public bool AntiAlias { get; public set; }
    protected PdfShading(PdfWriter writer);
    protected void SetColorSpace(Color color);
    public Color get_ColorSpace();
    public static void ThrowColorSpaceError();
    public static void CheckCompatibleColors(Color c1, Color c2);
    public static Single[] GetColorArray(Color color);
    public static PdfShading Type1(PdfWriter writer, Color colorSpace, Single[] domain, Single[] tMatrix, PdfFunction function);
    public static PdfShading Type2(PdfWriter writer, Color colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading Type3(PdfWriter writer, Color colorSpace, Single[] coords, Single[] domain, PdfFunction function, Boolean[] extend);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, Color startColor, Color endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleAxial(PdfWriter writer, float x0, float y0, float x1, float y1, Color startColor, Color endColor);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, Color startColor, Color endColor, bool extendStart, bool extendEnd);
    public static PdfShading SimpleRadial(PdfWriter writer, float x0, float y0, float r0, float x1, float y1, float r1, Color startColor, Color endColor);
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    internal void AddToBody();
    internal PdfWriter get_Writer();
    internal ColorDetails get_ColorDetails();
    public Single[] get_BBox();
    public void set_BBox(Single[] value);
    public void set_AntiAlias(bool value);
    public bool get_AntiAlias();
}
public class iTextSharp.text.pdf.PdfShadingPattern : PdfDictionary {
    protected PdfShading shading;
    protected PdfWriter writer;
    protected Single[] matrix;
    protected PdfName patternName;
    protected PdfIndirectReference patternReference;
    internal PdfName PatternName { get; }
    internal PdfName ShadingName { get; }
    internal PdfIndirectReference PatternReference { get; }
    internal PdfIndirectReference ShadingReference { get; }
    unknown int Name {internal set; }
    public Single[] Matrix { get; public set; }
    public PdfShading Shading { get; }
    internal ColorDetails ColorDetails { get; }
    public PdfShadingPattern(PdfShading shading);
    internal PdfName get_PatternName();
    internal PdfName get_ShadingName();
    internal PdfIndirectReference get_PatternReference();
    internal PdfIndirectReference get_ShadingReference();
    internal void set_Name(int value);
    internal void AddToBody();
    public Single[] get_Matrix();
    public void set_Matrix(Single[] value);
    public PdfShading get_Shading();
    internal ColorDetails get_ColorDetails();
}
public abstract class iTextSharp.text.pdf.PdfSigGenericPKCS : PdfSignature {
    protected string hashAlgorithm;
    protected PdfPKCS7 pkcs;
    protected string name;
    private Byte[] externalDigest;
    private Byte[] externalRSAdata;
    private string digestEncryptionAlgorithm;
    public string Name { get; }
    public PdfPKCS7 Signer { get; }
    public Byte[] SignerContents { get; }
    public PdfSigGenericPKCS(PdfName filter, PdfName subFilter);
    public void SetSignInfo(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList);
    public void SetExternalDigest(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    public string get_Name();
    public PdfPKCS7 get_Signer();
    public Byte[] get_SignerContents();
}
public class iTextSharp.text.pdf.PdfSignature : PdfDictionary {
    unknown Int32[] ByteRange {public set; }
    unknown Byte[] Contents {public set; }
    unknown Byte[] Cert {public set; }
    unknown string Name {public set; }
    unknown PdfDate Date {public set; }
    unknown string Location {public set; }
    unknown string Reason {public set; }
    unknown string Contact {public set; }
    public PdfSignature(PdfName filter, PdfName subFilter);
    public void set_ByteRange(Int32[] value);
    public void set_Contents(Byte[] value);
    public void set_Cert(Byte[] value);
    public void set_Name(string value);
    public void set_Date(PdfDate value);
    public void set_Location(string value);
    public void set_Reason(string value);
    public void set_Contact(string value);
}
public class iTextSharp.text.pdf.PdfSignatureAppearance : object {
    public static int NOT_CERTIFIED;
    public static int CERTIFIED_NO_CHANGES_ALLOWED;
    public static int CERTIFIED_FORM_FILLING;
    public static int CERTIFIED_FORM_FILLING_AND_ANNOTATIONS;
    private static float TOP_SECTION;
    private static float MARGIN;
    public static string questionMark;
    public static PdfName SELF_SIGNED;
    public static PdfName VERISIGN_SIGNED;
    public static PdfName WINCER_SIGNED;
    private Rectangle rect;
    private Rectangle pageRect;
    private PdfTemplate[] app;
    private PdfTemplate frm;
    private PdfStamperImp writer;
    private string layer2Text;
    private string reason;
    private string location;
    private DateTime signDate;
    private int page;
    private string fieldName;
    private ICipherParameters privKey;
    private X509Certificate[] certChain;
    private Object[] crlList;
    private PdfName filter;
    private bool newField;
    private ByteBuffer sigout;
    private Stream originalout;
    private string tempFile;
    private PdfDictionary cryptoDictionary;
    private PdfStamper stamper;
    private bool preClosed;
    private PdfSigGenericPKCS sigStandard;
    private Int32[] range;
    private FileStream raf;
    private Byte[] bout;
    private int boutLen;
    private Byte[] externalDigest;
    private Byte[] externalRSAdata;
    private string digestEncryptionAlgorithm;
    private Hashtable exclusionLocations;
    private SignatureRender render;
    private Image signatureGraphic;
    private string contact;
    private Font layer2Font;
    private string layer4Text;
    private bool acro6Layers;
    private int runDirection;
    private ISignatureEvent signatureEvent;
    private Image image;
    private float imageScale;
    private int certificationLevel;
    public SignatureRender Render { get; public set; }
    public Image SignatureGraphic { get; public set; }
    public string Layer2Text { get; public set; }
    public string Layer4Text { get; public set; }
    public Rectangle Rect { get; }
    public string Reason { get; public set; }
    public string Location { get; public set; }
    public ICipherParameters PrivKey { get; }
    public X509Certificate[] CertChain { get; }
    public Object[] CrlList { get; }
    public PdfName Filter { get; }
    public int Page { get; }
    public string FieldName { get; }
    public Rectangle PageRect { get; }
    public DateTime SignDate { get; public set; }
    internal ByteBuffer Sigout { get; internal set; }
    internal Stream Originalout { get; internal set; }
    public string TempFile { get; }
    public Stream RangeStream { get; }
    public PdfDictionary CryptoDictionary { get; public set; }
    public PdfStamper Stamper { get; }
    public PdfSigGenericPKCS SigStandard { get; }
    public string Contact { get; public set; }
    public Font Layer2Font { get; public set; }
    public bool Acro6Layers { get; public set; }
    public int RunDirection { get; public set; }
    public ISignatureEvent SignatureEvent { get; public set; }
    public Image Image { get; public set; }
    public float ImageScale { get; public set; }
    public int CertificationLevel { get; public set; }
    internal PdfSignatureAppearance(PdfStamperImp writer);
    private static PdfSignatureAppearance();
    public SignatureRender get_Render();
    public void set_Render(SignatureRender value);
    public Image get_SignatureGraphic();
    public void set_SignatureGraphic(Image value);
    public string get_Layer2Text();
    public void set_Layer2Text(string value);
    public string get_Layer4Text();
    public void set_Layer4Text(string value);
    public Rectangle get_Rect();
    public bool IsInvisible();
    public void SetCrypto(ICipherParameters privKey, X509Certificate[] certChain, Object[] crlList, PdfName filter);
    public void SetVisibleSignature(Rectangle pageRect, int page, string fieldName);
    public void SetVisibleSignature(string fieldName);
    public PdfTemplate GetLayer(int layer);
    public PdfTemplate GetTopLayer();
    public PdfTemplate GetAppearance();
    public static float FitText(Font font, string text, Rectangle rect, float maxFontSize, int runDirection);
    public void SetExternalDigest(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    public string get_Reason();
    public void set_Reason(string value);
    public string get_Location();
    public void set_Location(string value);
    public ICipherParameters get_PrivKey();
    public X509Certificate[] get_CertChain();
    public Object[] get_CrlList();
    public PdfName get_Filter();
    public bool IsNewField();
    public int get_Page();
    public string get_FieldName();
    public Rectangle get_PageRect();
    public DateTime get_SignDate();
    public void set_SignDate(DateTime value);
    internal ByteBuffer get_Sigout();
    internal void set_Sigout(ByteBuffer value);
    internal Stream get_Originalout();
    internal void set_Originalout(Stream value);
    public string get_TempFile();
    internal void SetTempFile(string tempFile);
    public string GetNewSigName();
    public void PreClose();
    public void PreClose(Hashtable exclusionSizes);
    public void Close(PdfDictionary update);
    private void AddDocMDP(PdfDictionary crypto);
    public Stream get_RangeStream();
    public PdfDictionary get_CryptoDictionary();
    public void set_CryptoDictionary(PdfDictionary value);
    public PdfStamper get_Stamper();
    internal void SetStamper(PdfStamper stamper);
    public bool IsPreClosed();
    public PdfSigGenericPKCS get_SigStandard();
    public string get_Contact();
    public void set_Contact(string value);
    public Font get_Layer2Font();
    public void set_Layer2Font(Font value);
    public bool get_Acro6Layers();
    public void set_Acro6Layers(bool value);
    public void set_RunDirection(int value);
    public int get_RunDirection();
    public ISignatureEvent get_SignatureEvent();
    public void set_SignatureEvent(ISignatureEvent value);
    public Image GetImage();
    public Image get_Image();
    public void set_Image(Image value);
    public float get_ImageScale();
    public void set_ImageScale(float value);
    public int get_CertificationLevel();
    public void set_CertificationLevel(int value);
}
public class iTextSharp.text.pdf.PdfSmartCopy : PdfCopy {
    private Hashtable streamMap;
    public PdfSmartCopy(Document document, Stream os);
    protected virtual PdfIndirectReference CopyIndirect(PRIndirectReference inp);
}
public class iTextSharp.text.pdf.PdfSpotColor : object {
    protected float tint;
    public PdfName name;
    public Color altcs;
    public float Tint { get; }
    public Color AlternativeCS { get; }
    public PdfSpotColor(string name, float tint, Color altcs);
    public float get_Tint();
    public Color get_AlternativeCS();
    protected internal PdfObject GetSpotObject(PdfWriter writer);
}
public class iTextSharp.text.pdf.PdfStamper : object {
    protected PdfStamperImp stamper;
    private Hashtable moreInfo;
    private bool hasSignature;
    private PdfSignatureAppearance sigApp;
    public Hashtable MoreInfo { get; public set; }
    public PdfSignatureAppearance SignatureAppearance { get; }
    public bool RotateContents { get; public set; }
    public PdfWriter Writer { get; }
    public PdfReader Reader { get; }
    public AcroFields AcroFields { get; }
    unknown bool FormFlattening {public set; }
    unknown bool FreeTextFlattening {public set; }
    unknown ArrayList Outlines {public set; }
    unknown string JavaScript {public set; }
    unknown int ViewerPreferences {public set; }
    unknown Byte[] XmpMetadata {public set; }
    public bool FullCompression { get; }
    public PdfStamper(PdfReader reader, Stream os);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion);
    public PdfStamper(PdfReader reader, Stream os, char pdfVersion, bool append);
    public void set_MoreInfo(Hashtable value);
    public Hashtable get_MoreInfo();
    public void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    public void InsertPage(int pageNumber, Rectangle mediabox);
    public PdfSignatureAppearance get_SignatureAppearance();
    public void Close();
    public PdfContentByte GetUnderContent(int pageNum);
    public PdfContentByte GetOverContent(int pageNum);
    public void set_RotateContents(bool value);
    public bool get_RotateContents();
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public PdfWriter get_Writer();
    public PdfReader get_Reader();
    public AcroFields get_AcroFields();
    public void set_FormFlattening(bool value);
    public void set_FreeTextFlattening(bool value);
    public void AddAnnotation(PdfAnnotation annot, int page);
    public PdfFormField AddSignature(string name, int page, float llx, float lly, float urx, float ury);
    public void AddComments(FdfReader fdf);
    public void set_Outlines(ArrayList value);
    public void SetThumbnail(Image image, int page);
    public bool PartialFormFlattening(string name);
    public void set_JavaScript(string value);
    public void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public void AddFileAttachment(string description, PdfFileSpecification fs);
    public void MakePackage(PdfName initialView);
    public void MakePackage(PdfCollection collection);
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public void set_XmpMetadata(Byte[] value);
    public bool get_FullCompression();
    public void SetFullCompression();
    public void SetPageAction(PdfName actionType, PdfAction action, int page);
    public void SetDuration(int seconds, int page);
    public void SetTransition(PdfTransition transition, int page);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile, bool append);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion);
    public static PdfStamper CreateSignature(PdfReader reader, Stream os, char pdfVersion, string tempFile);
    public Hashtable GetPdfLayers();
}
public class iTextSharp.text.pdf.PdfStamperImp : PdfWriter {
    internal Hashtable readers2intrefs;
    internal Hashtable readers2file;
    internal RandomAccessFileOrArray file;
    internal PdfReader reader;
    internal IntHashtable myXref;
    internal Hashtable pagesToContent;
    internal bool closed;
    private bool rotateContents;
    protected AcroFields acroFields;
    protected bool flat;
    protected bool flatFreeText;
    protected Int32[] namePtr;
    protected Hashtable partialFlattening;
    protected bool useVp;
    protected PdfViewerPreferencesImp viewerPreferences;
    protected Hashtable fieldTemplates;
    protected bool fieldsAdded;
    protected int sigFlags;
    protected internal bool append;
    protected IntHashtable marked;
    protected int initialXrefSize;
    protected PdfAction openAction;
    internal bool RotateContents { get; internal set; }
    internal bool ContentWritten { get; }
    internal AcroFields AcroFields { get; }
    unknown bool FormFlattening {internal set; }
    unknown bool FreeTextFlattening {internal set; }
    unknown int ViewerPreferences {public set; }
    unknown int SigFlags {public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    internal PdfStamperImp(PdfReader reader, Stream os, char pdfVersion, bool append);
    internal void Close(Hashtable moreInfo);
    internal void ApplyRotation(PdfDictionary pageN, ByteBuffer out_p);
    internal void AlterContents();
    internal void AlterResources(PageStamp ps);
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    public void RegisterReader(PdfReader reader, bool openFile);
    public void UnRegisterReader(PdfReader reader);
    internal static void FindAllObjects(PdfReader reader, PdfObject obj, IntHashtable hits);
    public void AddComments(FdfReader fdf);
    internal PageStamp GetPageStamp(int pageNum);
    internal PdfContentByte GetUnderContent(int pageNum);
    internal PdfContentByte GetOverContent(int pageNum);
    internal void CorrectAcroFieldPages(int page);
    private static void MoveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, string name);
    internal void ReplacePage(PdfReader r, int pageImported, int pageReplaced);
    internal void InsertPage(int pageNumber, Rectangle mediabox);
    internal void set_RotateContents(bool value);
    internal bool get_RotateContents();
    internal bool get_ContentWritten();
    internal AcroFields get_AcroFields();
    internal void set_FormFlattening(bool value);
    internal void set_FreeTextFlattening(bool value);
    internal bool PartialFormFlattening(string name);
    internal void FlatFields();
    internal void EliminateAcroformObjects();
    internal void SweepKids(PdfObject obj);
    private void FlatFreeTextFields();
    public virtual PdfIndirectReference GetPageReference(int page);
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal void AddDocumentField(PdfIndirectReference ref_p);
    internal void AddFieldResources();
    internal void ExpandFields(PdfFormField field, ArrayList allAnnots);
    internal void AddAnnotation(PdfAnnotation annot, PdfDictionary pageN);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    private void OutlineTravel(PRIndirectReference outline);
    internal void DeleteOutlines();
    internal void SetJavaScript();
    private void AddFileAttachments();
    internal void MakePackage(PdfCollection collection);
    internal void SetOutlines();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_SigFlags(int value);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    internal void SetPageAction(PdfName actionType, PdfAction action, int page);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    internal void SetDuration(int seconds, int page);
    internal void SetTransition(PdfTransition transition, int page);
    protected internal void MarkUsed(PdfObject obj);
    protected internal void MarkUsed(int num);
    internal bool IsAppend();
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetOpenAction(string name);
    public virtual void set_Thumbnail(Image value);
    internal void SetThumbnail(Image image, int page);
    protected void ReadOCProperties();
    private void AddOrder(PdfLayer parent, PdfArray arr, Hashtable ocgmap);
    public Hashtable GetPdfLayers();
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
}
public class iTextSharp.text.pdf.PdfStream : PdfDictionary {
    public static int DEFAULT_COMPRESSION;
    public static int NO_COMPRESSION;
    public static int BEST_SPEED;
    public static int BEST_COMPRESSION;
    protected bool compressed;
    protected int compressionLevel;
    protected MemoryStream streamBytes;
    protected Stream inputStream;
    protected PdfIndirectReference iref;
    protected int inputStreamLength;
    protected PdfWriter writer;
    protected int rawLength;
    internal static Byte[] STARTSTREAM;
    internal static Byte[] ENDSTREAM;
    internal static int SIZESTREAM;
    public int RawLength { get; }
    public PdfStream(Byte[] bytes);
    public PdfStream(Stream inputStream, PdfWriter writer);
    private static PdfStream();
    public void WriteLength();
    public int get_RawLength();
    public void FlateCompress();
    public void FlateCompress(int compressionLevel);
    protected virtual void SuperToPdf(PdfWriter writer, Stream os);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public void WriteContent(Stream os);
    public virtual string ToString();
}
public class iTextSharp.text.pdf.PdfString : PdfObject {
    protected string value;
    protected string originalValue;
    protected string encoding;
    protected int objNum;
    protected int objGen;
    protected bool hexWriting;
    public string Encoding { get; }
    public PdfString(string value);
    public PdfString(string value, string encoding);
    public PdfString(Byte[] bytes);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public virtual string ToString();
    public string get_Encoding();
    public string ToUnicodeString();
    internal void SetObjNum(int objNum, int objGen);
    internal void Decrypt(PdfReader reader);
    public virtual Byte[] GetBytes();
    public Byte[] GetOriginalBytes();
    public PdfString SetHexWriting(bool hexWriting);
    public bool IsHexWriting();
}
public class iTextSharp.text.pdf.PdfStructureElement : PdfDictionary {
    private PdfStructureElement parent;
    private PdfStructureTreeRoot top;
    private PdfIndirectReference reference;
    public PdfDictionary Parent { get; }
    public PdfIndirectReference Reference { get; }
    public PdfStructureElement(PdfStructureElement parent, PdfName structureType);
    public PdfStructureElement(PdfStructureTreeRoot parent, PdfName structureType);
    private void Init(PdfDictionary parent, PdfName structureType);
    public PdfDictionary get_Parent();
    internal void SetPageMark(int page, int mark);
    public PdfIndirectReference get_Reference();
}
public class iTextSharp.text.pdf.PdfStructureTreeRoot : PdfDictionary {
    private Hashtable parentTree;
    private PdfIndirectReference reference;
    private PdfWriter writer;
    public PdfWriter Writer { get; }
    public PdfIndirectReference Reference { get; }
    internal PdfStructureTreeRoot(PdfWriter writer);
    public void MapRole(PdfName used, PdfName standard);
    public PdfWriter get_Writer();
    public PdfIndirectReference get_Reference();
    internal void SetPageMark(int page, PdfIndirectReference struc);
    private void NodeProcess(PdfDictionary struc, PdfIndirectReference reference);
    internal void BuildTree();
}
public class iTextSharp.text.pdf.PdfTable : Rectangle {
    private int columns;
    private ArrayList headercells;
    private ArrayList cells;
    protected Table table;
    protected Single[] positions;
    internal int Rows { get; }
    public int Type { get; }
    internal ArrayList HeaderCells { get; }
    internal ArrayList Cells { get; }
    internal int Columns { get; }
    internal float Cellpadding { get; }
    internal float Cellspacing { get; }
    public float Offset { get; }
    internal PdfTable(Table table, float left, float right, float top);
    internal void UpdateRowAdditions();
    private void UpdateRowAdditionsInternal();
    internal int get_Rows();
    public virtual int get_Type();
    internal ArrayList get_HeaderCells();
    internal bool HasHeader();
    internal ArrayList get_Cells();
    internal int get_Columns();
    internal float get_Cellpadding();
    internal float get_Cellspacing();
    public bool HasToFitPageTable();
    public bool HasToFitPageCells();
    public float get_Offset();
}
public class iTextSharp.text.pdf.PdfTemplate : PdfContentByte {
    public static int TYPE_TEMPLATE;
    public static int TYPE_IMPORTED;
    public static int TYPE_PATTERN;
    protected int type;
    protected PdfIndirectReference thisReference;
    protected PageResources pageResources;
    protected Rectangle bBox;
    protected PdfArray matrix;
    protected PdfTransparencyGroup group;
    protected IPdfOCG layer;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public Rectangle BoundingBox { get; public set; }
    public IPdfOCG Layer { get; public set; }
    internal PdfArray Matrix { get; }
    public PdfIndirectReference IndirectReference { get; }
    internal PdfObject Resources { get; }
    public PdfContentByte Duplicate { get; }
    public int Type { get; }
    internal PageResources PageResources { get; }
    public PdfTransparencyGroup Group { get; public set; }
    internal PdfTemplate(PdfWriter wr);
    public static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height);
    internal static PdfTemplate CreateTemplate(PdfWriter writer, float width, float height, PdfName forcedName);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public Rectangle get_BoundingBox();
    public void set_BoundingBox(Rectangle value);
    public IPdfOCG get_Layer();
    public void set_Layer(IPdfOCG value);
    public void SetMatrix(float a, float b, float c, float d, float e, float f);
    internal PdfArray get_Matrix();
    public PdfIndirectReference get_IndirectReference();
    public void BeginVariableText();
    public void EndVariableText();
    internal virtual PdfObject get_Resources();
    internal virtual PdfStream GetFormXObject(int compressionLevel);
    public virtual PdfContentByte get_Duplicate();
    public int get_Type();
    internal virtual PageResources get_PageResources();
    public virtual PdfTransparencyGroup get_Group();
    public virtual void set_Group(PdfTransparencyGroup value);
}
public class iTextSharp.text.pdf.PdfTextArray : object {
    private ArrayList arrayList;
    private string lastStr;
    private float lastNum;
    internal ArrayList ArrayList { get; }
    public PdfTextArray(string str);
    public void Add(PdfNumber number);
    public void Add(float number);
    public void Add(string str);
    internal ArrayList get_ArrayList();
    private void ReplaceLast(object obj);
}
public class iTextSharp.text.pdf.PdfTransition : object {
    public static int SPLITVOUT;
    public static int SPLITHOUT;
    public static int SPLITVIN;
    public static int SPLITHIN;
    public static int BLINDV;
    public static int BLINDH;
    public static int INBOX;
    public static int OUTBOX;
    public static int LRWIPE;
    public static int RLWIPE;
    public static int BTWIPE;
    public static int TBWIPE;
    public static int DISSOLVE;
    public static int LRGLITTER;
    public static int TBGLITTER;
    public static int DGLITTER;
    protected int duration;
    protected int type;
    public int Duration { get; }
    public int Type { get; }
    public PdfDictionary TransitionDictionary { get; }
    public PdfTransition(int type);
    public PdfTransition(int type, int duration);
    public int get_Duration();
    public int get_Type();
    public PdfDictionary get_TransitionDictionary();
}
public class iTextSharp.text.pdf.PdfTransparencyGroup : PdfDictionary {
    unknown bool Isolated {public set; }
    unknown bool Knockout {public set; }
    public void set_Isolated(bool value);
    public void set_Knockout(bool value);
}
public class iTextSharp.text.pdf.PdfWriter : DocWriter {
    public static int GENERATION_MAX;
    public static char VERSION_1_2;
    public static char VERSION_1_3;
    public static char VERSION_1_4;
    public static char VERSION_1_5;
    public static char VERSION_1_6;
    public static char VERSION_1_7;
    public static int PageLayoutSinglePage;
    public static int PageLayoutOneColumn;
    public static int PageLayoutTwoColumnLeft;
    public static int PageLayoutTwoColumnRight;
    public static int PageLayoutTwoPageLeft;
    public static int PageLayoutTwoPageRight;
    public static int PageModeUseNone;
    public static int PageModeUseOutlines;
    public static int PageModeUseThumbs;
    public static int PageModeFullScreen;
    public static int PageModeUseOC;
    public static int PageModeUseAttachments;
    public static int HideToolbar;
    public static int HideMenubar;
    public static int HideWindowUI;
    public static int FitWindow;
    public static int CenterWindow;
    public static int DisplayDocTitle;
    public static int NonFullScreenPageModeUseNone;
    public static int NonFullScreenPageModeUseOutlines;
    public static int NonFullScreenPageModeUseThumbs;
    public static int NonFullScreenPageModeUseOC;
    public static int DirectionL2R;
    public static int DirectionR2L;
    public static int PrintScalingNone;
    public static int SIGNATURE_EXISTS;
    public static int SIGNATURE_APPEND_ONLY;
    public static int PDFXNONE;
    public static int PDFX1A2001;
    public static int PDFX32002;
    public static int PDFA1A;
    public static int PDFA1B;
    public static int STANDARD_ENCRYPTION_40;
    public static int STANDARD_ENCRYPTION_128;
    public static int ENCRYPTION_AES_128;
    internal static int ENCRYPTION_MASK;
    public static int DO_NOT_ENCRYPT_METADATA;
    public static int EMBEDDED_FILES_ONLY;
    public static int ALLOW_PRINTING;
    public static int ALLOW_MODIFY_CONTENTS;
    public static int ALLOW_COPY;
    public static int ALLOW_MODIFY_ANNOTATIONS;
    public static int ALLOW_FILL_IN;
    public static int ALLOW_SCREENREADERS;
    public static int ALLOW_ASSEMBLY;
    public static int ALLOW_DEGRADED_PRINTING;
    public static int AllowPrinting;
    public static int AllowModifyContents;
    public static int AllowCopy;
    public static int AllowModifyAnnotations;
    public static int AllowFillIn;
    public static int AllowScreenReaders;
    public static int AllowAssembly;
    public static int AllowDegradedPrinting;
    public static bool STRENGTH40BITS;
    public static bool STRENGTH128BITS;
    public static float SPACE_CHAR_RATIO_DEFAULT;
    public static float NO_SPACE_CHAR_RATIO;
    public static int RUN_DIRECTION_DEFAULT;
    public static int RUN_DIRECTION_NO_BIDI;
    public static int RUN_DIRECTION_LTR;
    public static int RUN_DIRECTION_RTL;
    protected internal PdfDocument pdf;
    protected PdfContentByte directContent;
    protected PdfContentByte directContentUnder;
    protected internal PdfBody body;
    protected internal PdfDictionary extraCatalog;
    protected PdfPages root;
    protected ArrayList pageReferences;
    protected int currentPageNumber;
    protected PdfName tabs;
    private IPdfPageEvent pageEvent;
    protected int prevxref;
    protected ArrayList newBookmarks;
    public static PdfName PDF_VERSION_1_2;
    public static PdfName PDF_VERSION_1_3;
    public static PdfName PDF_VERSION_1_4;
    public static PdfName PDF_VERSION_1_5;
    public static PdfName PDF_VERSION_1_6;
    public static PdfName PDF_VERSION_1_7;
    protected PdfVersionImp pdf_version;
    public static PdfName DOCUMENT_CLOSE;
    public static PdfName WILL_SAVE;
    public static PdfName DID_SAVE;
    public static PdfName WILL_PRINT;
    public static PdfName DID_PRINT;
    protected Byte[] xmpMetadata;
    private PdfXConformanceImp pdfxConformance;
    protected PdfEncryption crypto;
    protected bool fullCompression;
    protected internal int compressionLevel;
    protected Hashtable documentFonts;
    protected int fontNumber;
    protected Hashtable formXObjects;
    protected int formXObjectsCounter;
    protected Hashtable importedPages;
    protected PdfReaderInstance currentPdfReaderInstance;
    protected Hashtable documentColors;
    protected int colorNumber;
    protected Hashtable documentPatterns;
    protected int patternNumber;
    protected Hashtable documentShadingPatterns;
    protected Hashtable documentShadings;
    protected Hashtable documentExtGState;
    protected Hashtable documentProperties;
    protected bool tagged;
    protected PdfStructureTreeRoot structureTreeRoot;
    protected Hashtable documentOCG;
    protected ArrayList documentOCGorder;
    protected PdfOCProperties vOCProperties;
    protected PdfArray OCGRadioGroup;
    protected PdfArray OCGLocked;
    public static PdfName PAGE_OPEN;
    public static PdfName PAGE_CLOSE;
    protected PdfDictionary group;
    private float spaceCharRatio;
    protected int runDirection;
    protected float userunit;
    protected PdfDictionary defaultColorspace;
    protected Hashtable documentSpotPatterns;
    protected ColorDetails patternColorspaceRGB;
    protected ColorDetails patternColorspaceGRAY;
    protected ColorDetails patternColorspaceCMYK;
    protected PdfDictionary imageDictionary;
    private Hashtable images;
    protected Hashtable JBIG2Globals;
    private bool userProperties;
    private bool rgbTransparencyBlending;
    internal PdfDocument PdfDocument { get; }
    public PdfDictionary Info { get; }
    public PdfContentByte DirectContent { get; }
    public PdfContentByte DirectContentUnder { get; }
    public PdfIndirectReference PdfIndirectReference { get; }
    internal int IndirectReferenceNumber { get; }
    internal OutputStreamCounter Os { get; }
    public PdfDictionary ExtraCatalog { get; }
    public int PageNumber { get; }
    internal PdfIndirectReference CurrentPage { get; }
    public int CurrentPageNumber { get; }
    public PdfName Tabs { get; public set; }
    public IPdfPageEvent PageEvent { get; public set; }
    public PdfOutline RootOutline { get; }
    unknown ArrayList Outlines {public set; }
    unknown char PdfVersion {public set; }
    unknown int ViewerPreferences {public set; }
    unknown PdfPageLabels PageLabels {public set; }
    unknown PdfCollection Collection {public set; }
    public PdfAcroForm AcroForm { get; }
    unknown int SigFlags {public set; }
    public Byte[] XmpMetadata { get; public set; }
    unknown Byte[] PageXmpMetadata {public set; }
    public int PDFXConformance { get; public set; }
    internal PdfEncryption Encryption { get; }
    public bool FullCompression { get; }
    public int CompressionLevel { get; public set; }
    public int CurrentDocumentSize { get; }
    public PdfStructureTreeRoot StructureTreeRoot { get; }
    public PdfOCProperties OCProperties { get; }
    public Rectangle PageSize { get; }
    unknown Rectangle CropBoxSize {public set; }
    unknown bool PageEmpty {public set; }
    unknown int Duration {public set; }
    unknown PdfTransition Transition {public set; }
    unknown Image Thumbnail {public set; }
    public PdfDictionary Group { get; public set; }
    public float SpaceCharRatio { get; public set; }
    public int RunDirection { get; public set; }
    public float Userunit { get; public set; }
    public PdfDictionary DefaultColorspace { get; }
    public bool StrictImageSequence { get; public set; }
    public bool UserProperties { get; public set; }
    public bool RgbTransparencyBlending { get; public set; }
    protected PdfWriter(PdfDocument document, Stream os);
    private static PdfWriter();
    public static PdfWriter GetInstance(Document document, Stream os);
    public static PdfWriter GetInstance(Document document, Stream os, IDocListener listener);
    internal PdfDocument get_PdfDocument();
    public PdfDictionary get_Info();
    public float GetVerticalPosition(bool ensureNewLine);
    public virtual PdfContentByte get_DirectContent();
    public virtual PdfContentByte get_DirectContentUnder();
    internal void ResetContent();
    internal void AddLocalDestinations(OrderedTree dest);
    public PdfIndirectObject AddToBody(PdfObject objecta);
    public PdfIndirectObject AddToBody(PdfObject objecta, bool inObjStm);
    public PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa);
    public PdfIndirectObject AddToBody(PdfObject objecta, PdfIndirectReference refa, bool inObjStm);
    public PdfIndirectObject AddToBody(PdfObject objecta, int refNumber);
    public PdfIndirectObject AddToBody(PdfObject objecta, int refNumber, bool inObjStm);
    public PdfIndirectReference get_PdfIndirectReference();
    internal int get_IndirectReferenceNumber();
    internal OutputStreamCounter get_Os();
    protected virtual PdfDictionary GetCatalog(PdfIndirectReference rootObj);
    public PdfDictionary get_ExtraCatalog();
    public void SetLinearPageMode();
    public int ReorderPages(Int32[] order);
    public virtual PdfIndirectReference GetPageReference(int page);
    public int get_PageNumber();
    internal virtual PdfIndirectReference get_CurrentPage();
    public virtual int get_CurrentPageNumber();
    public PdfName get_Tabs();
    public void set_Tabs(PdfName value);
    internal virtual PdfIndirectReference Add(PdfPage page, PdfContents contents);
    public IPdfPageEvent get_PageEvent();
    public void set_PageEvent(IPdfPageEvent value);
    public virtual void Open();
    public virtual void Close();
    protected void AddSharedObjectsToBody();
    public PdfOutline get_RootOutline();
    public void set_Outlines(ArrayList value);
    protected internal void WriteOutlines(PdfDictionary catalog, bool namedAsNames);
    public virtual void set_PdfVersion(char value);
    public sealed virtual void SetAtLeastPdfVersion(char version);
    public sealed virtual void SetPdfVersion(PdfName version);
    public sealed virtual void AddDeveloperExtension(PdfDeveloperExtension de);
    internal PdfVersionImp GetPdfVersion();
    public virtual void set_ViewerPreferences(int value);
    public virtual void AddViewerPreference(PdfName key, PdfObject value);
    public virtual void set_PageLabels(PdfPageLabels value);
    public virtual void AddJavaScript(PdfAction js);
    public virtual void AddJavaScript(string code, bool unicode);
    public virtual void AddJavaScript(string code);
    public void AddJavaScript(string name, PdfAction js);
    public void AddJavaScript(string name, string code, bool unicode);
    public void AddJavaScript(string name, string code);
    public virtual void AddFileAttachment(string description, Byte[] fileStore, string file, string fileDisplay);
    public virtual void AddFileAttachment(string description, PdfFileSpecification fs);
    public void AddFileAttachment(PdfFileSpecification fs);
    public virtual void SetOpenAction(string name);
    public virtual void SetOpenAction(PdfAction action);
    public virtual void SetAdditionalAction(PdfName actionType, PdfAction action);
    public void set_Collection(PdfCollection value);
    public sealed virtual PdfAcroForm get_AcroForm();
    public virtual void AddAnnotation(PdfAnnotation annot);
    internal virtual void AddAnnotation(PdfAnnotation annot, int page);
    public virtual void AddCalculationOrder(PdfFormField annot);
    public virtual void set_SigFlags(int value);
    public void set_XmpMetadata(Byte[] value);
    public Byte[] get_XmpMetadata();
    public void set_PageXmpMetadata(Byte[] value);
    public void CreateXmpMetadata();
    private Byte[] CreateXmpMetadataBytes();
    public sealed virtual void set_PDFXConformance(int value);
    public sealed virtual int get_PDFXConformance();
    public sealed virtual bool IsPdfX();
    public void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, ICC_Profile colorProfile);
    public void SetOutputIntents(string outputConditionIdentifier, string outputCondition, string registryName, string info, Byte[] destOutputProfile);
    public bool SetOutputIntents(PdfReader reader, bool checkExistence);
    private static string GetNameString(PdfDictionary dic, PdfName key);
    internal PdfEncryption get_Encryption();
    public sealed virtual void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, int encryptionType);
    public sealed virtual void SetEncryption(X509Certificate[] certs, Int32[] permissions, int encryptionType);
    public void SetEncryption(Byte[] userPassword, Byte[] ownerPassword, int permissions, bool strength128Bits);
    public void SetEncryption(bool strength, string userPassword, string ownerPassword, int permissions);
    public void SetEncryption(int encryptionType, string userPassword, string ownerPassword, int permissions);
    public bool get_FullCompression();
    public void SetFullCompression();
    public void set_CompressionLevel(int value);
    public int get_CompressionLevel();
    internal FontDetails AddSimple(BaseFont bf);
    internal void EliminateFontSubset(PdfDictionary fonts);
    internal PdfName AddDirectTemplateSimple(PdfTemplate template, PdfName forcedName);
    public void ReleaseTemplate(PdfTemplate tp);
    public virtual PdfImportedPage GetImportedPage(PdfReader reader, int pageNumber);
    public virtual void FreeReader(PdfReader reader);
    public int get_CurrentDocumentSize();
    protected internal virtual int GetNewObjectNumber(PdfReader reader, int number, int generation);
    internal virtual RandomAccessFileOrArray GetReaderFile(PdfReader reader);
    internal PdfName GetColorspaceName();
    internal ColorDetails AddSimple(PdfSpotColor spc);
    internal PdfName AddSimplePattern(PdfPatternPainter painter);
    internal void AddSimpleShadingPattern(PdfShadingPattern shading);
    internal void AddSimpleShading(PdfShading shading);
    internal PdfObject[] AddSimpleExtGState(PdfDictionary gstate);
    internal PdfObject[] AddSimpleProperty(object prop, PdfIndirectReference refi);
    internal bool PropertyExists(object prop);
    public void SetTagged();
    public bool IsTagged();
    public PdfStructureTreeRoot get_StructureTreeRoot();
    public PdfOCProperties get_OCProperties();
    public void AddOCGRadioGroup(ArrayList group);
    public void LockLayer(PdfLayer layer);
    private static void GetOCGOrder(PdfArray order, PdfLayer layer);
    private void AddASEvent(PdfName eventa, PdfName category);
    protected void FillOCProperties(bool erase);
    internal void RegisterLayer(IPdfOCG layer);
    public Rectangle get_PageSize();
    public virtual void set_CropBoxSize(Rectangle value);
    public void SetBoxSize(string boxName, Rectangle size);
    public Rectangle GetBoxSize(string boxName);
    public void set_PageEmpty(bool value);
    public virtual void SetPageAction(PdfName actionType, PdfAction action);
    public virtual void set_Duration(int value);
    public virtual void set_Transition(PdfTransition value);
    public virtual void set_Thumbnail(Image value);
    public PdfDictionary get_Group();
    public void set_Group(PdfDictionary value);
    public virtual void set_SpaceCharRatio(float value);
    public virtual float get_SpaceCharRatio();
    public virtual void set_RunDirection(int value);
    public virtual int get_RunDirection();
    public float get_Userunit();
    public void set_Userunit(float value);
    public PdfDictionary get_DefaultColorspace();
    public void SetDefaultColorspace(PdfName key, PdfObject cs);
    internal ColorDetails AddSimplePatternColorspace(Color color);
    public void set_StrictImageSequence(bool value);
    public bool get_StrictImageSequence();
    public void ClearTextWrap();
    public PdfName AddDirectImageSimple(Image image);
    public PdfName AddDirectImageSimple(Image image, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference Add(PdfImage pdfImage, PdfIndirectReference fixedRef);
    internal virtual PdfIndirectReference GetImageReference(PdfName name);
    protected virtual PdfIndirectReference Add(PdfICCBased icc);
    protected internal PdfIndirectReference GetReferenceJBIG2Globals(Byte[] content);
    public bool FitsPage(Table table, float margin);
    public bool FitsPage(Table table);
    public void set_UserProperties(bool value);
    public bool get_UserProperties();
    public bool get_RgbTransparencyBlending();
    public void set_RgbTransparencyBlending(bool value);
}
public class iTextSharp.text.pdf.PdfXConformanceException : Exception {
    public PdfXConformanceException(string s);
}
public class iTextSharp.text.pdf.Pfm2afm : object {
    private RandomAccessFileOrArray inp;
    private StreamWriter outp;
    private Encoding encoding;
    private short vers;
    private int h_len;
    private string copyright;
    private short type;
    private short points;
    private short verres;
    private short horres;
    private short ascent;
    private short intleading;
    private short extleading;
    private byte italic;
    private byte uline;
    private byte overs;
    private short weight;
    private byte charset;
    private short pixwidth;
    private short pixheight;
    private byte kind;
    private short avgwidth;
    private short maxwidth;
    private int firstchar;
    private int lastchar;
    private byte defchar;
    private byte brkchar;
    private short widthby;
    private int device;
    private int face;
    private int bits;
    private int bitoff;
    private short extlen;
    private int psext;
    private int chartab;
    private int res1;
    private int kernpairs;
    private int res2;
    private int fontname;
    private short capheight;
    private short xheight;
    private short ascender;
    private short descender;
    private bool isMono;
    private Int32[] Win2PSStd;
    private Int32[] WinClass;
    private String[] WinChars;
    private Pfm2afm(RandomAccessFileOrArray inp, Stream outp);
    public static void Convert(RandomAccessFileOrArray inp, Stream outp);
    private string ReadString(int n);
    private string ReadString();
    private void Outval(int n);
    private void Outchar(int code, int width, string name);
    private void Openpfm();
    private void Putheader();
    private void Putchartab();
    private void Putkerntab();
    private void Puttrailer();
}
public class iTextSharp.text.pdf.PRAcroForm : PdfDictionary {
    internal ArrayList fields;
    internal ArrayList stack;
    internal Hashtable fieldByName;
    internal PdfReader reader;
    public int Size { get; }
    public ArrayList Fields { get; }
    public PRAcroForm(PdfReader reader);
    public int get_Size();
    public ArrayList get_Fields();
    public FieldInformation GetField(string name);
    public PRIndirectReference GetRefByName(string name);
    public void ReadAcroForm(PdfDictionary root);
    protected void IterateFields(PdfArray fieldlist, PRIndirectReference fieldDict, string title);
    protected PdfDictionary MergeAttrib(PdfDictionary parent, PdfDictionary child);
    protected void PushAttrib(PdfDictionary dict);
}
public class iTextSharp.text.pdf.PRIndirectReference : PdfIndirectReference {
    protected PdfReader reader;
    public PdfReader Reader { get; }
    internal PRIndirectReference(PdfReader reader, int number, int generation);
    internal PRIndirectReference(PdfReader reader, int number);
    public virtual void ToPdf(PdfWriter writer, Stream os);
    public PdfReader get_Reader();
    public void SetNumber(int number, int generation);
}
public class iTextSharp.text.pdf.PRStream : PdfStream {
    protected PdfReader reader;
    protected int offset;
    protected int length;
    protected int objNum;
    protected int objGen;
    public int Length { get; public set; }
    public int Offset { get; }
    public PdfReader Reader { get; }
    public int ObjNum { get; public set; }
    public int ObjGen { get; public set; }
    public PRStream(PRStream stream, PdfDictionary newDic);
    public PRStream(PRStream stream, PdfDictionary newDic, PdfReader reader);
    public PRStream(PdfReader reader, int offset);
    public PRStream(PdfReader reader, Byte[] conts);
    public PRStream(PdfReader reader, Byte[] conts, int compressionLevel);
    public void SetData(Byte[] data, bool compress);
    public void SetData(Byte[] data, bool compress, int compressionLevel);
    public void SetData(Byte[] data);
    public void set_Length(int value);
    public int get_Length();
    public int get_Offset();
    public PdfReader get_Reader();
    public Byte[] GetBytes();
    public int get_ObjNum();
    public void set_ObjNum(int value);
    public int get_ObjGen();
    public void set_ObjGen(int value);
    public virtual void ToPdf(PdfWriter writer, Stream os);
}
public class iTextSharp.text.pdf.PRTokeniser : object {
    public static int TK_NUMBER;
    public static int TK_STRING;
    public static int TK_NAME;
    public static int TK_COMMENT;
    public static int TK_START_ARRAY;
    public static int TK_END_ARRAY;
    public static int TK_START_DIC;
    public static int TK_END_DIC;
    public static int TK_REF;
    public static int TK_OTHER;
    internal static string EMPTY;
    protected RandomAccessFileOrArray file;
    protected int type;
    protected string stringValue;
    protected int reference;
    protected int generation;
    protected bool hexString;
    public int FilePointer { get; }
    public int Length { get; }
    public RandomAccessFileOrArray SafeFile { get; }
    public RandomAccessFileOrArray File { get; }
    public int TokenType { get; }
    public string StringValue { get; }
    public int Reference { get; }
    public int Generation { get; }
    public int Startxref { get; }
    public int IntValue { get; }
    public PRTokeniser(string filename);
    public PRTokeniser(Byte[] pdfIn);
    public PRTokeniser(RandomAccessFileOrArray file);
    public void Seek(int pos);
    public int get_FilePointer();
    public void Close();
    public int get_Length();
    public int Read();
    public RandomAccessFileOrArray get_SafeFile();
    public RandomAccessFileOrArray get_File();
    public string ReadString(int size);
    public static bool IsWhitespace(int ch);
    public static bool IsDelimiter(int ch);
    public int get_TokenType();
    public string get_StringValue();
    public int get_Reference();
    public int get_Generation();
    public void BackOnePosition(int ch);
    public void ThrowError(string error);
    public char CheckPdfHeader();
    public void CheckFdfHeader();
    public int get_Startxref();
    public static int GetHex(int v);
    public void NextValidToken();
    public bool NextToken();
    public int get_IntValue();
    public bool ReadLineSegment(Byte[] input);
    public static Int32[] CheckObjectStart(Byte[] line);
    public bool IsHexString();
}
public class iTextSharp.text.pdf.PushbuttonField : BaseField {
    public static int LAYOUT_LABEL_ONLY;
    public static int LAYOUT_ICON_ONLY;
    public static int LAYOUT_ICON_TOP_LABEL_BOTTOM;
    public static int LAYOUT_LABEL_TOP_ICON_BOTTOM;
    public static int LAYOUT_ICON_LEFT_LABEL_RIGHT;
    public static int LAYOUT_LABEL_LEFT_ICON_RIGHT;
    public static int LAYOUT_LABEL_OVER_ICON;
    public static int SCALE_ICON_ALWAYS;
    public static int SCALE_ICON_NEVER;
    public static int SCALE_ICON_IS_TOO_BIG;
    public static int SCALE_ICON_IS_TOO_SMALL;
    private int layout;
    private Image image;
    private PdfTemplate template;
    private int scaleIcon;
    private bool proportionalIcon;
    private float iconVerticalAdjustment;
    private float iconHorizontalAdjustment;
    private bool iconFitToBounds;
    private PdfTemplate tp;
    private PRIndirectReference iconReference;
    public int Layout { get; public set; }
    public Image Image { get; public set; }
    public PdfTemplate Template { get; public set; }
    public int ScaleIcon { get; public set; }
    public bool ProportionalIcon { get; public set; }
    public float IconVerticalAdjustment { get; public set; }
    public float IconHorizontalAdjustment { get; public set; }
    public PdfFormField Field { get; }
    public bool IconFitToBounds { get; public set; }
    public PRIndirectReference IconReference { get; public set; }
    public PushbuttonField(PdfWriter writer, Rectangle box, string fieldName);
    public void set_Layout(int value);
    public int get_Layout();
    public Image get_Image();
    public void set_Image(Image value);
    public void set_Template(PdfTemplate value);
    public PdfTemplate get_Template();
    public void set_ScaleIcon(int value);
    public int get_ScaleIcon();
    public bool get_ProportionalIcon();
    public void set_ProportionalIcon(bool value);
    public float get_IconVerticalAdjustment();
    public void set_IconVerticalAdjustment(float value);
    public float get_IconHorizontalAdjustment();
    public void set_IconHorizontalAdjustment(float value);
    private float CalculateFontSize(float w, float h);
    public PdfAppearance GetAppearance();
    public PdfFormField get_Field();
    public bool get_IconFitToBounds();
    public void set_IconFitToBounds(bool value);
    public PRIndirectReference get_IconReference();
    public void set_IconReference(PRIndirectReference value);
}
public class iTextSharp.text.pdf.RadioCheckField : BaseField {
    public static int TYPE_CHECK;
    public static int TYPE_CIRCLE;
    public static int TYPE_CROSS;
    public static int TYPE_DIAMOND;
    public static int TYPE_SQUARE;
    public static int TYPE_STAR;
    private static String[] typeChars;
    private int checkType;
    private string onValue;
    private bool vchecked;
    public int CheckType { get; public set; }
    public string OnValue { get; public set; }
    public bool Checked { get; public set; }
    public PdfFormField RadioField { get; }
    public PdfFormField CheckField { get; }
    public RadioCheckField(PdfWriter writer, Rectangle box, string fieldName, string onValue);
    private static RadioCheckField();
    public int get_CheckType();
    public void set_CheckType(int value);
    public string get_OnValue();
    public void set_OnValue(string value);
    public bool get_Checked();
    public void set_Checked(bool value);
    public PdfAppearance GetAppearance(bool isRadio, bool on);
    public PdfAppearance GetAppearanceRadioCircle(bool on);
    public PdfFormField GetRadioGroup(bool noToggleToOff, bool radiosInUnison);
    public PdfFormField get_RadioField();
    public PdfFormField get_CheckField();
    protected PdfFormField GetField(bool isRadio);
}
public class iTextSharp.text.pdf.RandomAccessFileOrArray : object {
    internal FileStream rf;
    internal string filename;
    internal Byte[] arrayIn;
    internal int arrayInPtr;
    internal byte back;
    internal bool isBack;
    private int startOffset;
    public int Length { get; }
    public int FilePointer { get; }
    public int StartOffset { get; public set; }
    public RandomAccessFileOrArray(string filename);
    public RandomAccessFileOrArray(string filename, bool forceRead);
    public RandomAccessFileOrArray(Uri url);
    public RandomAccessFileOrArray(Stream isp);
    public RandomAccessFileOrArray(Byte[] arrayIn);
    public RandomAccessFileOrArray(RandomAccessFileOrArray file);
    public static Byte[] InputStreamToArray(Stream isp);
    public void PushBack(byte b);
    public int Read();
    public int Read(Byte[] b, int off, int len);
    public int Read(Byte[] b);
    public void ReadFully(Byte[] b);
    public void ReadFully(Byte[] b, int off, int len);
    public long Skip(long n);
    public int SkipBytes(int n);
    public void ReOpen();
    protected void InsureOpen();
    public bool IsOpen();
    public void Close();
    public int get_Length();
    public void Seek(int pos);
    public void Seek(long pos);
    public int get_FilePointer();
    public bool ReadBoolean();
    public byte ReadByte();
    public int ReadUnsignedByte();
    public short ReadShort();
    public short ReadShortLE();
    public int ReadUnsignedShort();
    public int ReadUnsignedShortLE();
    public char ReadChar();
    public char ReadCharLE();
    public int ReadInt();
    public int ReadIntLE();
    public long ReadUnsignedInt();
    public long ReadUnsignedIntLE();
    public long ReadLong();
    public long ReadLongLE();
    public float ReadFloat();
    public float ReadFloatLE();
    public double ReadDouble();
    public double ReadDoubleLE();
    public string ReadLine();
    public int get_StartOffset();
    public void set_StartOffset(int value);
}
public class iTextSharp.text.pdf.SequenceList : object {
    protected static int COMMA;
    protected static int MINUS;
    protected static int NOT;
    protected static int TEXT;
    protected static int NUMBER;
    protected static int END;
    protected static char EOT;
    private static int FIRST;
    private static int DIGIT;
    private static int OTHER;
    private static int DIGIT2;
    private static string NOT_OTHER;
    protected Char[] text;
    protected int ptr;
    protected int number;
    protected string other;
    protected int low;
    protected int high;
    protected bool odd;
    protected bool even;
    protected bool inverse;
    protected int Type { get; }
    protected SequenceList(string range);
    protected char NextChar();
    protected void PutBack();
    protected int get_Type();
    private void OtherProc();
    protected bool GetAttributes();
    public static ArrayList Expand(string ranges, int maxNumber);
}
public class iTextSharp.text.pdf.ShadingColor : ExtendedColor {
    private PdfShadingPattern shadingPattern;
    public PdfShadingPattern PdfShadingPattern { get; }
    public ShadingColor(PdfShadingPattern shadingPattern);
    public PdfShadingPattern get_PdfShadingPattern();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.SimpleBookmark : object {
    private ArrayList topList;
    private Stack attr;
    private static ArrayList BookmarkDepth(PdfReader reader, PdfDictionary outline, IntHashtable pages);
    private static void MapGotoBookmark(Hashtable map, PdfObject dest, IntHashtable pages);
    private static string MakeBookmarkParam(PdfArray dest, IntHashtable pages);
    private static int GetNumber(PdfIndirectReference indirect);
    public static ArrayList GetBookmark(PdfReader reader);
    public static void EliminatePages(ArrayList list, Int32[] pageRange);
    public static void ShiftPageNumbers(ArrayList list, int pageShift, Int32[] pageRange);
    internal static void CreateOutlineAction(PdfDictionary outline, Hashtable map, PdfWriter writer, bool namedAsNames);
    public static Object[] IterateOutlines(PdfWriter writer, PdfIndirectReference parent, ArrayList kids, bool namedAsNames);
    public static void ExportToXMLNode(ArrayList list, TextWriter outp, int indent, bool onlyASCII);
    public static void ExportToXML(ArrayList list, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(ArrayList list, TextWriter wrt, string encoding, bool onlyASCII);
    public static ArrayList ImportFromXML(Stream inp);
    public static ArrayList ImportFromXML(TextReader inp);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, Hashtable h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SimpleNamedDestination : object {
    private Hashtable xmlNames;
    private Hashtable xmlLast;
    public static Hashtable GetNamedDestination(PdfReader reader, bool fromNames);
    public static void ExportToXML(Hashtable names, Stream outp, string encoding, bool onlyASCII);
    public static void ExportToXML(Hashtable names, TextWriter wrt, string encoding, bool onlyASCII);
    public static Hashtable ImportFromXML(Stream inp);
    public static Hashtable ImportFromXML(TextReader inp);
    internal static PdfArray CreateDestinationArray(string value, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsNames(Hashtable names, PdfWriter writer);
    public static PdfDictionary OutputNamedDestinationAsStrings(Hashtable names, PdfWriter writer);
    public static string EscapeBinaryString(string s);
    public static string UnEscapeBinaryString(string s);
    public sealed virtual void EndDocument();
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void StartElement(string tag, Hashtable h);
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.pdf.SpotColor : ExtendedColor {
    private PdfSpotColor spot;
    private float tint;
    public PdfSpotColor PdfSpotColor { get; }
    public float Tint { get; }
    public SpotColor(PdfSpotColor spot, float tint);
    public SpotColor(PdfSpotColor spot);
    public PdfSpotColor get_PdfSpotColor();
    public float get_Tint();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class iTextSharp.text.pdf.StampContent : PdfContentByte {
    internal PageStamp ps;
    internal PageResources pageResources;
    public PdfContentByte Duplicate { get; }
    internal PageResources PageResources { get; }
    internal StampContent(PdfStamperImp stamper, PageStamp ps);
    public virtual void SetAction(PdfAction action, float llx, float lly, float urx, float ury);
    public virtual PdfContentByte get_Duplicate();
    internal virtual PageResources get_PageResources();
    internal virtual void AddAnnotation(PdfAnnotation annot);
}
public class iTextSharp.text.pdf.TextField : BaseField {
    private string defaultText;
    private String[] choices;
    private String[] choiceExports;
    private int choiceSelection;
    private int topFirst;
    private float extraMarginLeft;
    private float extraMarginTop;
    private ArrayList substitutionFonts;
    private BaseFont extensionFont;
    public string DefaultText { get; public set; }
    public String[] Choices { get; public set; }
    public String[] ChoiceExports { get; public set; }
    public int ChoiceSelection { get; public set; }
    internal int TopFirst { get; }
    public ArrayList SubstitutionFonts { get; public set; }
    public BaseFont ExtensionFont { get; public set; }
    public TextField(PdfWriter writer, Rectangle box, string fieldName);
    private static bool CheckRTL(string text);
    private static void ChangeFontSize(Phrase p, float size);
    private Phrase ComposePhrase(string text, BaseFont ufont, Color color, float fontSize);
    public static string RemoveCRLF(string text);
    public static string ObfuscatePassword(string text);
    public PdfAppearance GetAppearance();
    internal PdfAppearance GetListAppearance();
    public PdfFormField GetTextField();
    public PdfFormField GetComboField();
    public PdfFormField GetListField();
    protected PdfFormField GetChoiceField(bool isList);
    public string get_DefaultText();
    public void set_DefaultText(string value);
    public String[] get_Choices();
    public void set_Choices(String[] value);
    public String[] get_ChoiceExports();
    public void set_ChoiceExports(String[] value);
    public int get_ChoiceSelection();
    public void set_ChoiceSelection(int value);
    internal int get_TopFirst();
    public void SetExtraMargin(float extraMarginLeft, float extraMarginTop);
    public void set_SubstitutionFonts(ArrayList value);
    public ArrayList get_SubstitutionFonts();
    public void set_ExtensionFont(BaseFont value);
    public BaseFont get_ExtensionFont();
}
internal class iTextSharp.text.pdf.TrueTypeFont : BaseFont {
    internal static String[] codePages;
    protected bool justNames;
    protected Hashtable tables;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool cff;
    protected int cffOffset;
    protected int cffLength;
    protected int directoryOffset;
    protected string ttcIndex;
    protected string style;
    protected FontHeader head;
    protected HorizontalHeader hhea;
    protected WindowsMetrics os_2;
    protected Int32[] GlyphWidths;
    protected Int32[][] bboxes;
    protected Hashtable cmap10;
    protected Hashtable cmap31;
    protected Hashtable cmapExt;
    protected IntHashtable kerning;
    protected string fontName;
    protected String[][] fullName;
    protected String[][] allNameEntries;
    protected String[][] familyName;
    protected double italicAngle;
    protected bool isFixedPitch;
    protected int underlinePosition;
    protected int underlineThickness;
    internal string BaseFont { get; }
    public string PostscriptFontName { get; public set; }
    public String[] CodePagesSupported { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal TrueTypeFont(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool justNames, bool forceRead);
    private static TrueTypeFont();
    protected static string GetTTCName(string name);
    internal void FillTables();
    internal string get_BaseFont();
    internal String[][] GetNames(int id);
    internal String[][] GetAllNames();
    internal void CheckCff();
    internal void Process(Byte[] ttfAfm, bool preload);
    protected string ReadStandardString(int length);
    protected string ReadUnicodeString(int length);
    protected void ReadGlyphWidths();
    protected int GetGlyphWidth(int glyph);
    private void ReadBbox();
    internal void ReadCMaps();
    internal Hashtable ReadFormat12();
    internal Hashtable ReadFormat0();
    internal Hashtable ReadFormat4();
    internal Hashtable ReadFormat6();
    internal void ReadKerning();
    public virtual int GetKerning(int char1, int char2);
    internal virtual int GetRawWidth(int c, string name);
    protected PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream, string subsetPrefix, PdfIndirectReference cidset);
    protected PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, string subsetPrefix, int firstChar, int lastChar, Byte[] shortTag);
    protected Byte[] GetFullFont();
    protected static Int32[] CompactRanges(ArrayList ranges);
    protected void AddRangeUni(Hashtable longTag, bool includeMetrics, bool subsetp);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    protected internal Byte[] ReadCffFont();
    public virtual PdfStream GetFullFontStream();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[] get_CodePagesSupported();
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
internal class iTextSharp.text.pdf.TrueTypeFontSubSet : object {
    internal static String[] tableNamesSimple;
    internal static String[] tableNamesCmap;
    internal static String[] tableNamesExtra;
    internal static Int32[] entrySelectors;
    internal static int TABLE_CHECKSUM;
    internal static int TABLE_OFFSET;
    internal static int TABLE_LENGTH;
    internal static int HEAD_LOCA_FORMAT_OFFSET;
    internal static int ARG_1_AND_2_ARE_WORDS;
    internal static int WE_HAVE_A_SCALE;
    internal static int MORE_COMPONENTS;
    internal static int WE_HAVE_AN_X_AND_Y_SCALE;
    internal static int WE_HAVE_A_TWO_BY_TWO;
    protected Hashtable tableDirectory;
    protected RandomAccessFileOrArray rf;
    protected string fileName;
    protected bool includeCmap;
    protected bool includeExtras;
    protected bool locaShortTable;
    protected Int32[] locaTable;
    protected Hashtable glyphsUsed;
    protected ArrayList glyphsInList;
    protected int tableGlyphOffset;
    protected Int32[] newLocaTable;
    protected Byte[] newLocaTableOut;
    protected Byte[] newGlyfTable;
    protected int glyfTableRealSize;
    protected int locaTableRealSize;
    protected Byte[] outFont;
    protected int fontPtr;
    protected int directoryOffset;
    internal TrueTypeFontSubSet(string fileName, RandomAccessFileOrArray rf, Hashtable glyphsUsed, int directoryOffset, bool includeCmap, bool includeExtras);
    private static TrueTypeFontSubSet();
    internal Byte[] Process();
    protected void AssembleFont();
    protected void CreateTableDirectory();
    protected void ReadLoca();
    protected void CreateNewGlyphTables();
    protected void LocaTobytes();
    protected void FlatGlyphs();
    protected void CheckGlyphComposite(int glyph);
    protected string ReadStandardString(int length);
    protected void WriteFontShort(int n);
    protected void WriteFontInt(int n);
    protected void WriteFontString(string s);
    protected int CalculateChecksum(Byte[] b);
}
internal class iTextSharp.text.pdf.TrueTypeFontUnicode : TrueTypeFont {
    private bool vertical;
    private static Byte[] rotbits;
    internal TrueTypeFontUnicode(string ttFile, string enc, bool emb, Byte[] ttfAfm, bool forceRead);
    private static TrueTypeFontUnicode();
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    private PdfStream GetToUnicode(Object[] metrics);
    internal static string ToHex(int n);
    private PdfDictionary GetCIDFontType2(PdfIndirectReference fontDescriptor, string subsetPrefix, Object[] metrics);
    private PdfDictionary GetFontBaseType(PdfIndirectReference descendant, string subsetPrefix, PdfIndirectReference toUnicode);
    public sealed virtual int Compare(object o1, object o2);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual PdfStream GetFullFontStream();
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual Int32[] GetMetricsTT(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
    public virtual Int32[] GetCharBBox(int c);
}
public class iTextSharp.text.pdf.TSAClientBouncyCastle : object {
    protected string tsaURL;
    protected string tsaUsername;
    protected string tsaPassword;
    protected int tokSzEstimate;
    public TSAClientBouncyCastle(string url);
    public TSAClientBouncyCastle(string url, string username, string password);
    public TSAClientBouncyCastle(string url, string username, string password, int tokSzEstimate);
    public sealed virtual int GetTokenSizeEstimate();
    public sealed virtual Byte[] GetTimeStampToken(PdfPKCS7 caller, Byte[] imprint);
    protected internal Byte[] GetTimeStampToken(Byte[] imprint);
    protected internal virtual Byte[] GetTSAResponse(Byte[] requestBytes);
}
internal class iTextSharp.text.pdf.Type1Font : BaseFont {
    protected Byte[] pfb;
    private string FontName;
    private string FullName;
    private string FamilyName;
    private string Weight;
    private float ItalicAngle;
    private bool IsFixedPitch;
    private string CharacterSet;
    private int llx;
    private int lly;
    private int urx;
    private int ury;
    private int UnderlinePosition;
    private int UnderlineThickness;
    private string EncodingScheme;
    private int CapHeight;
    private int XHeight;
    private int Ascender;
    private int Descender;
    private int StdHW;
    private int StdVW;
    private Hashtable CharMetrics;
    private Hashtable KernPairs;
    private string fileName;
    private bool builtinFont;
    private static Int32[] PFB_TYPES;
    public string PostscriptFontName { get; public set; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public String[][] FamilyFontName { get; }
    internal Type1Font(string afmFile, string enc, bool emb, Byte[] ttfAfm, Byte[] pfb, bool forceRead);
    private static Type1Font();
    internal virtual int GetRawWidth(int c, string name);
    public virtual int GetKerning(int char1, int char2);
    public void Process(RandomAccessFileOrArray rf);
    public virtual PdfStream GetFullFontStream();
    public PdfDictionary GetFontDescriptor(PdfIndirectReference fontStream);
    private PdfDictionary GetFontBaseType(PdfIndirectReference fontDescriptor, int firstChar, int lastChar, Byte[] shortTag);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piref, Object[] parms);
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual String[][] get_FamilyFontName();
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
}
public class iTextSharp.text.pdf.Type3Font : BaseFont {
    private Boolean[] usedSlot;
    private IntHashtable widths3;
    private Hashtable char2glyph;
    private PdfWriter writer;
    private float llx;
    private float lly;
    private float urx;
    private float ury;
    private PageResources pageResources;
    private bool colorized;
    public String[][] FamilyFontName { get; }
    public String[][] FullFontName { get; }
    public String[][] AllNameEntries { get; }
    public string PostscriptFontName { get; public set; }
    public Type3Font(PdfWriter writer, Char[] chars, bool colorized);
    public Type3Font(PdfWriter writer, bool colorized);
    public PdfContentByte DefineGlyph(char c, float wx, float llx, float lly, float urx, float ury);
    public virtual String[][] get_FamilyFontName();
    public virtual float GetFontDescriptor(int key, float fontSize);
    public virtual String[][] get_FullFontName();
    public virtual String[][] get_AllNameEntries();
    public virtual int GetKerning(int char1, int char2);
    public virtual string get_PostscriptFontName();
    public virtual void set_PostscriptFontName(string value);
    protected virtual Int32[] GetRawCharBBox(int c, string name);
    internal virtual int GetRawWidth(int c, string name);
    public virtual bool HasKernPairs();
    public virtual bool SetKerning(int char1, int char2, int kern);
    internal virtual void WriteFont(PdfWriter writer, PdfIndirectReference piRef, Object[] oParams);
    public virtual PdfStream GetFullFontStream();
    internal virtual Byte[] ConvertToBytes(string text);
    internal virtual Byte[] ConvertToBytes(int char1);
    public virtual int GetWidth(int char1);
    public virtual int GetWidth(string text);
    public virtual Int32[] GetCharBBox(int c);
    public virtual bool CharExists(int c);
    public virtual bool SetCharAdvance(int c, int advance);
}
public class iTextSharp.text.pdf.Type3Glyph : PdfContentByte {
    private PageResources pageResources;
    private bool colorized;
    internal PageResources PageResources { get; }
    internal Type3Glyph(PdfWriter writer, PageResources pageResources, float wx, float llx, float lly, float urx, float ury, bool colorized);
    internal virtual PageResources get_PageResources();
    public virtual void AddImage(Image image, float a, float b, float c, float d, float e, float f, bool inlineImage);
    public PdfContentByte GetDuplicate();
}
public class iTextSharp.text.pdf.VerticalText : object {
    public static int NO_MORE_TEXT;
    public static int NO_MORE_COLUMN;
    protected ArrayList chunks;
    protected PdfContentByte text;
    protected int alignment;
    protected int currentChunkMarker;
    protected PdfChunk currentStandbyChunk;
    protected string splittedChunkText;
    protected float leading;
    protected float startX;
    protected float startY;
    protected int maxLines;
    protected float height;
    public float Leading { get; public set; }
    public float OriginX { get; }
    public float OriginY { get; }
    public int MaxLines { get; public set; }
    public float Height { get; public set; }
    public int Alignment { get; public set; }
    public VerticalText(PdfContentByte text);
    private static VerticalText();
    public void AddText(Phrase phrase);
    public void AddText(Chunk chunk);
    public void SetVerticalLayout(float startX, float startY, float height, int maxLines, float leading);
    public float get_Leading();
    public void set_Leading(float value);
    protected PdfLine CreateLine(float width);
    protected void ShortenChunkArray();
    public int Go();
    public int Go(bool simulate);
    internal void WriteLine(PdfLine line, PdfContentByte text, PdfContentByte graphics);
    public void SetOrigin(float startX, float startY);
    public float get_OriginX();
    public float get_OriginY();
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public float get_Height();
    public void set_Height(float value);
    public int get_Alignment();
    public void set_Alignment(int value);
}
public class iTextSharp.text.pdf.XfaForm : object {
    public static string XFA_DATA_SCHEMA;
    private Xml2SomTemplate templateSom;
    private XmlNode templateNode;
    private Xml2SomDatasets datasetsSom;
    private AcroFieldsSearch acroFieldsSom;
    private PdfReader reader;
    private bool xfaPresent;
    private XmlDocument domDocument;
    private bool changed;
    private XmlNode datasetsNode;
    public bool XfaPresent { get; public set; }
    public XmlDocument DomDocument { get; public set; }
    public PdfReader Reader { get; public set; }
    public bool Changed { get; public set; }
    public Xml2SomTemplate TemplateSom { get; public set; }
    public Xml2SomDatasets DatasetsSom { get; public set; }
    public AcroFieldsSearch AcroFieldsSom { get; public set; }
    public XmlNode DatasetsNode { get; }
    public XfaForm(PdfReader reader);
    public static PdfObject GetXfaObject(PdfReader reader);
    private void ExtractNodes();
    public static void SetXfa(XfaForm form, PdfReader reader, PdfWriter writer);
    public void SetXfa(PdfWriter writer);
    public static Byte[] SerializeDoc(XmlNode n);
    public bool get_XfaPresent();
    public void set_XfaPresent(bool value);
    public XmlDocument get_DomDocument();
    public void set_DomDocument(XmlDocument value);
    public string FindFieldName(string name, AcroFields af);
    public string FindDatasetsName(string name);
    public XmlNode FindDatasetsNode(string name);
    public static string GetNodeText(XmlNode n);
    private static string GetNodeText(XmlNode n, string name);
    public void SetNodeText(XmlNode n, string text);
    public void set_Reader(PdfReader value);
    public PdfReader get_Reader();
    public bool get_Changed();
    public void set_Changed(bool value);
    public Xml2SomTemplate get_TemplateSom();
    public void set_TemplateSom(Xml2SomTemplate value);
    public Xml2SomDatasets get_DatasetsSom();
    public void set_DatasetsSom(Xml2SomDatasets value);
    public AcroFieldsSearch get_AcroFieldsSom();
    public void set_AcroFieldsSom(AcroFieldsSearch value);
    public XmlNode get_DatasetsNode();
}
public class iTextSharp.text.pdf.XfdfReader : object {
    private bool foundRoot;
    private Stackr fieldNames;
    private Stackr fieldValues;
    internal Hashtable fields;
    protected Hashtable listFields;
    internal string fileSpec;
    public Hashtable Fields { get; }
    public string FileSpec { get; }
    public XfdfReader(string filename);
    public XfdfReader(Byte[] xfdfIn);
    public Hashtable get_Fields();
    public string GetField(string name);
    public string GetFieldValue(string name);
    public ArrayList GetListValues(string name);
    public string get_FileSpec();
    public sealed virtual void StartElement(string tag, Hashtable h);
    public sealed virtual void EndElement(string tag);
    public sealed virtual void StartDocument();
    public sealed virtual void EndDocument();
    public sealed virtual void Text(string str);
}
public class iTextSharp.text.Phrase : ArrayList {
    protected float leading;
    protected Font font;
    protected IHyphenationEvent hyphenation;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public float Leading { get; public set; }
    public Font Font { get; public set; }
    public string Content { get; }
    public IHyphenationEvent Hyphenation { get; public set; }
    public Phrase(Phrase phrase);
    public Phrase(float leading);
    public Phrase(Chunk chunk);
    public Phrase(float leading, Chunk chunk);
    public Phrase(string str);
    public Phrase(string str, Font font);
    public Phrase(float leading, string str);
    public Phrase(float leading, string str, Font font);
    private Phrase(bool dummy);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    public virtual void Add(int index, object o);
    public virtual bool Add(object o);
    public bool AddAll(ICollection collection);
    protected bool AddChunk(Chunk chunk);
    public void AddSpecial(object obj);
    public bool IsEmpty();
    public bool HasLeading();
    public virtual float get_Leading();
    public virtual void set_Leading(float value);
    public Font get_Font();
    public void set_Font(Font value);
    public string get_Content();
    public static bool IsTag(string tag);
    public virtual string ToString();
    public void set_Hyphenation(IHyphenationEvent value);
    public IHyphenationEvent get_Hyphenation();
    public static Phrase GetInstance(string str);
    public static Phrase GetInstance(int leading, string str);
    public static Phrase GetInstance(int leading, string str, Font font);
}
public class iTextSharp.text.Rectangle : Element {
    public static int UNDEFINED;
    public static int TOP_BORDER;
    public static int BOTTOM_BORDER;
    public static int LEFT_BORDER;
    public static int RIGHT_BORDER;
    public static int NO_BORDER;
    public static int BOX;
    protected float llx;
    protected float lly;
    protected float urx;
    protected float ury;
    protected int border;
    protected float borderWidth;
    protected Color borderColor;
    protected Color borderColorLeft;
    protected Color borderColorRight;
    protected Color borderColorTop;
    protected Color borderColorBottom;
    protected float borderWidthLeft;
    protected float borderWidthRight;
    protected float borderWidthTop;
    protected float borderWidthBottom;
    protected bool useVariableBorders;
    protected Color backgroundColor;
    protected int rotation;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public float Top { get; public set; }
    public int Border { get; public set; }
    public float GrayFill { get; public set; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public Color BorderColorBottom { get; public set; }
    public Color BorderColorTop { get; public set; }
    public Color BorderColorLeft { get; public set; }
    public Color BorderColorRight { get; public set; }
    public float Width { get; public set; }
    public float Height { get; }
    public float BorderWidth { get; public set; }
    public Color BorderColor { get; public set; }
    public Color BackgroundColor { get; public set; }
    public int Rotation { get; }
    public float BorderWidthLeft { get; public set; }
    public float BorderWidthRight { get; public set; }
    public float BorderWidthTop { get; public set; }
    public float BorderWidthBottom { get; public set; }
    public bool UseVariableBorders { get; public set; }
    public Rectangle(float llx, float lly, float urx, float ury);
    public Rectangle(float urx, float ury);
    public Rectangle(Rectangle rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public virtual bool IsNestable();
    public virtual void Normalize();
    public Rectangle GetRectangle(float top, float bottom);
    public Rectangle Rotate();
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual int get_Border();
    public virtual void set_Border(int value);
    public virtual float get_GrayFill();
    public virtual void set_GrayFill(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual Color get_BorderColorBottom();
    public virtual void set_BorderColorBottom(Color value);
    public virtual Color get_BorderColorTop();
    public virtual void set_BorderColorTop(Color value);
    public virtual Color get_BorderColorLeft();
    public virtual void set_BorderColorLeft(Color value);
    public virtual Color get_BorderColorRight();
    public virtual void set_BorderColorRight(Color value);
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public virtual float GetBottom(float margin);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public float get_Height();
    public bool HasBorders();
    public bool HasBorder(int type);
    public virtual float get_BorderWidth();
    public virtual void set_BorderWidth(float value);
    public virtual Color get_BorderColor();
    public virtual void set_BorderColor(Color value);
    public virtual Color get_BackgroundColor();
    public virtual void set_BackgroundColor(Color value);
    public int get_Rotation();
    public virtual float get_BorderWidthLeft();
    public virtual void set_BorderWidthLeft(float value);
    public virtual float get_BorderWidthRight();
    public virtual void set_BorderWidthRight(float value);
    public virtual float get_BorderWidthTop();
    public virtual void set_BorderWidthTop(float value);
    public virtual float get_BorderWidthBottom();
    public virtual void set_BorderWidthBottom(float value);
    private void UpdateBorderBasedOnWidth(float width, int side);
    private float GetVariableBorderWidth(float variableWidthValue, int side);
    public virtual bool get_UseVariableBorders();
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
}
public class iTextSharp.text.RectangleReadOnly : Rectangle {
    unknown float Top {public set; }
    unknown int Border {public set; }
    unknown float GrayFill {public set; }
    unknown float Left {public set; }
    unknown float Right {public set; }
    unknown float Bottom {public set; }
    unknown Color BorderColorBottom {public set; }
    unknown Color BorderColorTop {public set; }
    unknown Color BorderColorLeft {public set; }
    unknown Color BorderColorRight {public set; }
    unknown float BorderWidth {public set; }
    unknown Color BorderColor {public set; }
    unknown Color BackgroundColor {public set; }
    unknown float BorderWidthLeft {public set; }
    unknown float BorderWidthRight {public set; }
    unknown float BorderWidthTop {public set; }
    unknown float BorderWidthBottom {public set; }
    unknown bool UseVariableBorders {public set; }
    public RectangleReadOnly(float llx, float lly, float urx, float ury);
    public RectangleReadOnly(float urx, float ury);
    public RectangleReadOnly(Rectangle rect);
    public virtual void CloneNonPositionParameters(Rectangle rect);
    private void ThrowReadOnlyError();
    public virtual void SoftCloneNonPositionParameters(Rectangle rect);
    public virtual void Normalize();
    public virtual void set_Top(float value);
    public virtual void EnableBorderSide(int side);
    public virtual void DisableBorderSide(int side);
    public virtual void set_Border(int value);
    public virtual void set_GrayFill(float value);
    public virtual void set_Left(float value);
    public virtual void set_Right(float value);
    public virtual void set_Bottom(float value);
    public virtual void set_BorderColorBottom(Color value);
    public virtual void set_BorderColorTop(Color value);
    public virtual void set_BorderColorLeft(Color value);
    public virtual void set_BorderColorRight(Color value);
    public virtual void set_BorderWidth(float value);
    public virtual void set_BorderColor(Color value);
    public virtual void set_BackgroundColor(Color value);
    public virtual void set_BorderWidthLeft(float value);
    public virtual void set_BorderWidthRight(float value);
    public virtual void set_BorderWidthTop(float value);
    public virtual void set_BorderWidthBottom(float value);
    public virtual void set_UseVariableBorders(bool value);
    public virtual string ToString();
}
public class iTextSharp.text.RomanList : List {
    public RomanList(int symbolIndent);
    public RomanList(bool romanlower, int symbolIndent);
    public virtual bool Add(object o);
}
public class iTextSharp.text.Row : object {
    public static int NULL;
    public static int CELL;
    public static int TABLE;
    protected int columns;
    protected int currentColumn;
    protected Boolean[] reserved;
    protected Object[] cells;
    protected int horizontalAlignment;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public int Columns { get; }
    public int HorizontalAlignment { get; public set; }
    internal Row(int columns);
    private static Row();
    public sealed virtual bool Process(IElementListener listener);
    public sealed virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public sealed virtual bool IsNestable();
    internal void DeleteColumn(int column);
    internal int AddElement(object element);
    internal int AddElement(object element, int column);
    internal void SetElement(object aElement, int column);
    internal bool Reserve(int column);
    internal bool Reserve(int column, int size);
    internal bool IsReserved(int column);
    private int GetElementID(int column);
    private int GetObjectID(object element);
    public object GetCell(int column);
    public bool IsEmpty();
    public int get_Columns();
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public virtual string ToString();
}
public class iTextSharp.text.rtf.direct.RtfDirectContent : RtfAddableElement {
    public static RtfDirectContent DIRECT_SOFT_LINEBREAK;
    private string directContent;
    public RtfDirectContent(string directContent);
    private static RtfDirectContent();
    public virtual void WriteContent(Stream outp);
}
public interface iTextSharp.text.rtf.document.output.IRtfDataCache {
    public abstract virtual Stream GetOutputStream();
    public abstract virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfByteArrayBuffer : Stream {
    private ArrayList arrays;
    private Byte[] buffer;
    private int pos;
    private int size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RtfByteArrayBuffer(int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] src, int off, int len);
    private void WriteLoop(Byte[] src, int off, int len);
    public long Write(Stream inp);
    public void Append(Byte[] a);
    public void Append(Byte[][] a);
    public Byte[][] ToArrayArray();
    public Byte[] ToArray();
    public void WriteTo(Stream outp);
    public virtual void WriteByte(byte value);
    public virtual string ToString();
    public void Reset();
    public long Size();
    private void FlushBuffer();
    private void FlushBuffer(int reqSize);
}
public class iTextSharp.text.rtf.document.output.RtfDataCache : object {
    public static int CACHE_MEMORY_EFFICIENT;
    public static int CACHE_MEMORY;
    public static int CACHE_DISK;
}
public class iTextSharp.text.rtf.document.output.RtfDiskCache : object {
    private BufferedStream data;
    private string tempFile;
    public sealed virtual Stream GetOutputStream();
    public sealed virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfEfficientMemoryCache : object {
    private RtfByteArrayBuffer bab;
    public virtual Stream GetOutputStream();
    public virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfMemoryCache : object {
    private MemoryStream data;
    public sealed virtual Stream GetOutputStream();
    public sealed virtual void WriteTo(Stream target);
}
public class iTextSharp.text.rtf.document.output.RtfNilOutputStream : Stream {
    private long size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] src, int off, int len);
    public virtual void WriteByte(byte value);
    public long GetSize();
}
public class iTextSharp.text.rtf.document.RtfCodePage : RtfElement {
    private static Byte[] ANSI;
    private static Byte[] ANSI_CODEPAGE;
    public RtfCodePage(RtfDocument doc);
    private static RtfCodePage();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.document.RtfDocument : RtfElement {
    private IRtfDataCache data;
    private RtfMapper mapper;
    private RtfDocumentHeader documentHeader;
    private ArrayList previousRandomInts;
    private bool autogenerateTOCEntries;
    private RtfDocumentSettings documentSettings;
    private IRtfBasicElement lastElementWritten;
    private static Byte[] RTF_DOCUMENT;
    private static Byte[] FSC_LINE;
    private static Byte[] FSC_PAR;
    private static Byte[] FSC_TAB;
    private static Byte[] FSC_PAGE_PAR;
    private static Byte[] FSC_NEWPAGE;
    private static Byte[] FSC_BACKSLASH;
    private static Byte[] FSC_HEX_PREFIX;
    private static Byte[] FSC_UNI_PREFIX;
    private static Random random;
    private static RtfDocument();
    public virtual void WriteContent(Stream outp);
    public void WriteDocument(Stream outs);
    public void Open();
    public void Add(IRtfBasicElement element);
    public RtfMapper GetMapper();
    public int GetRandomInt();
    public RtfDocumentHeader GetDocumentHeader();
    public void FilterSpecialChar(Stream outp, string str, bool useHex, bool softLineBreaks);
    private static bool SubMatch(string str, int soff, Byte[] m);
    public void SetAutogenerateTOCEntries(bool autogenerate);
    public bool GetAutogenerateTOCEntries();
    public RtfDocumentSettings GetDocumentSettings();
    public IRtfBasicElement GetLastElementWritten();
    public void OutputDebugLinebreak(Stream result);
}
public class iTextSharp.text.rtf.document.RtfDocumentHeader : RtfElement {
    private static Byte[] TITLE_PAGE;
    private static Byte[] FACING_PAGES;
    private RtfCodePage codePage;
    private RtfColorList colorList;
    private RtfFontList fontList;
    private RtfListTable listTable;
    private RtfStylesheetList stylesheetList;
    private RtfGenerator generator;
    private RtfInfoGroup infoGroup;
    private RtfProtectionSetting protectionSetting;
    private RtfPageSetting pageSetting;
    private HeaderFooter header;
    private HeaderFooter footer;
    protected internal RtfDocumentHeader(RtfDocument doc);
    private static RtfDocumentHeader();
    protected internal void Init();
    public virtual void WriteContent(Stream result);
    public void WriteSectionDefinition(Stream result);
    public int GetFontNumber(RtfFont font);
    public int GetColorNumber(RtfColor color);
    public int GetListNumber(RtfList list);
    public RtfParagraphStyle GetRtfParagraphStyle(string styleName);
    public void FreeListNumber(RtfList list);
    public RtfPageSetting GetPageSetting();
    public void AddInfoElement(RtfInfoElement rtfInfoElement);
    public void SetHeader(HeaderFooter header);
    public void SetFooter(HeaderFooter footer);
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    private RtfHeaderFooterGroup ConvertHeaderFooter(HeaderFooter hf, int type);
    public RtfListTable GetListTable();
}
public class iTextSharp.text.rtf.document.RtfDocumentSettings : object {
    private RtfDocument document;
    private bool outputTableRowDefinitionAfter;
    private bool outputDebugLineBreaks;
    private bool alwaysGenerateSoftLinebreaks;
    private bool alwaysUseUnicode;
    private int dataCacheStyle;
    private bool writeImageScalingInformation;
    private bool imagePDFConformance;
    private int protectionLevel;
    private string protectionHash;
    private bool readOnlyRecommended;
    private bool imageWrittenAsBinary;
    public RtfDocumentSettings(RtfDocument document);
    public bool IsOutputDebugLineBreaks();
    public void SetOutputDebugLineBreaks(bool outputDebugLineBreaks);
    public bool IsOutputTableRowDefinitionAfter();
    public void SetOutputTableRowDefinitionAfter(bool outputTableRowDefinitionAfter);
    public bool IsAlwaysGenerateSoftLinebreaks();
    public void SetAlwaysGenerateSoftLinebreaks(bool alwaysGenerateSoftLinebreaks);
    public bool IsAlwaysUseUnicode();
    public void SetAlwaysUseUnicode(bool alwaysUseUnicode);
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    public void SetDataCacheStyle(int dataCacheStyle);
    public int GetDataCacheStyle();
    public bool IsImagePDFConformance();
    public void SetImagePDFConformance(bool imagePDFConformance);
    public bool IsWriteImageScalingInformation();
    public void SetWriteImageScalingInformation(bool writeImageScalingInformation);
    public void SetOptionsForMSWord2000And97();
    public void SetOptionsForMSWordForMac();
    public void SetOptionsForMSWordXP();
    public void SetOptionsForOpenOfficeOrg();
    public bool SetProtection(int level, string pwd);
    public bool UnprotectDocument(string pwd);
    public bool SetProtectionLevel(int level);
    public void SetPasswordHash(string pwd);
    private int ConvertProtectionLevel();
    public int GetProtectionLevelRaw();
    public int GetProtectionLevel();
    public Byte[] GetProtectionLevelBytes();
    public bool SetNewPassword(string oldPwd, string newPwd);
    public void SetReadOnlyRecommended(bool value);
    public bool GetReadOnlyRecommended();
    public bool IsDocumentProtected();
    public Byte[] GetProtectionHashBytes();
    public void SetImageWrittenAsBinary(bool imageWrittenAsBinary);
    public bool IsImageWrittenAsBinary();
}
public class iTextSharp.text.rtf.document.RtfGenerator : RtfElement {
    private static Byte[] GENERATOR;
    public RtfGenerator(RtfDocument doc);
    private static RtfGenerator();
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.document.RtfInfoElement : RtfElement {
    private static Byte[] INFO_AUTHOR;
    private static Byte[] INFO_SUBJECT;
    private static Byte[] INFO_KEYWORDS;
    private static Byte[] INFO_TITLE;
    private static Byte[] INFO_PRODUCER;
    private static Byte[] INFO_CREATION_DATE;
    private int infoType;
    private string content;
    public RtfInfoElement(RtfDocument doc, Meta meta);
    private static RtfInfoElement();
    public virtual void WriteContent(Stream result);
    private string ConvertDate(string date);
}
public class iTextSharp.text.rtf.document.RtfInfoGroup : RtfElement {
    private static Byte[] INFO_GROUP;
    private static Byte[] INFO_PASSWORD;
    private ArrayList infoElements;
    public RtfInfoGroup(RtfDocument doc);
    private static RtfInfoGroup();
    public void Add(RtfInfoElement infoElement);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.document.RtfPageSetting : RtfElement {
    private static Byte[] PAGE_WIDTH;
    private static Byte[] PAGE_HEIGHT;
    private static Byte[] MARGIN_LEFT;
    private static Byte[] MARGIN_RIGHT;
    private static Byte[] MARGIN_TOP;
    private static Byte[] MARGIN_BOTTOM;
    private static Byte[] LANDSCAPE;
    private static Byte[] SECTION_PAGE_WIDTH;
    private static Byte[] SECTION_PAGE_HEIGHT;
    private static Byte[] SECTION_MARGIN_LEFT;
    private static Byte[] SECTION_MARGIN_RIGHT;
    private static Byte[] SECTION_MARGIN_TOP;
    private static Byte[] SECTION_MARGIN_BOTTOM;
    private int pageWidth;
    private int pageHeight;
    private int marginLeft;
    private int marginRight;
    private int marginTop;
    private int marginBottom;
    private bool landscape;
    public RtfPageSetting(RtfDocument doc);
    private static RtfPageSetting();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
    public void WriteSectionDefinition(Stream result);
    public int GetMarginBottom();
    public void SetMarginBottom(int marginBottom);
    public int GetMarginLeft();
    public void SetMarginLeft(int marginLeft);
    public int GetMarginRight();
    public void SetMarginRight(int marginRight);
    public int GetMarginTop();
    public void SetMarginTop(int marginTop);
    public int GetPageHeight();
    public void SetPageHeight(int pageHeight);
    public int GetPageWidth();
    public void SetPageWidth(int pageWidth);
    public void SetPageSize(Rectangle pageSize);
    private bool GuessFormat(Rectangle pageSize, bool rotate);
    private static bool RectEquals(Rectangle rect1, Rectangle rect2);
}
public class iTextSharp.text.rtf.document.RtfProtection : object {
    public static int LEVEL_NONE;
    public static int LEVEL_REVPROT;
    public static int LEVEL_ANNOTPROT;
    public static int LEVEL_FORMPROT;
    public static int LEVEL_READPROT;
    public static int STYLELOCK;
    public static int STYLELOCKENFORCED;
    public static int STYLELOCKBACKCOMP;
    public static int AUTOFMTOVERRIDE;
    private static Int32[] initialCodeArray;
    private static Int32[][] encryptionMatrix;
    private static RtfProtection();
    public static string GenerateHash(string pwd);
}
public class iTextSharp.text.rtf.document.RtfProtectionSetting : RtfElement {
    private static Byte[] FORMPROT;
    private static Byte[] REVPROT;
    private static Byte[] ANNOTPROT;
    private static Byte[] READPROT;
    private static Byte[] PROTLEVEL;
    private static Byte[] ENFORCEPROT;
    private static Byte[] READONLYRECOMMENDED;
    public RtfProtectionSetting(RtfDocument doc);
    private static RtfProtectionSetting();
    public virtual void WriteContent(Stream result);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.field.RtfAnchor : RtfField {
    private static Byte[] HYPERLINK;
    private string url;
    private RtfPhrase content;
    public RtfAnchor(RtfDocument doc, Anchor anchor);
    private static RtfAnchor();
    protected virtual void WriteFieldInstContent(Stream result);
    protected virtual void WriteFieldResultContent(Stream outp);
}
public abstract class iTextSharp.text.rtf.field.RtfField : Chunk {
    public static double TWIPS_FACTOR;
    public static Byte[] OPEN_GROUP;
    public static Byte[] CLOSE_GROUP;
    public static Byte[] DELIMITER;
    public static Byte[] COMMA_DELIMITER;
    private static Byte[] FIELD;
    private static Byte[] FIELD_DIRTY;
    private static Byte[] FIELD_PRIVATE;
    private static Byte[] FIELD_LOCKED;
    private static Byte[] FIELD_EDIT;
    private static Byte[] FIELD_ALT;
    private static Byte[] FIELD_INSTRUCTIONS;
    private static Byte[] FIELD_RESULT;
    private bool fieldDirty;
    private bool fieldEdit;
    private bool fieldLocked;
    private bool fieldPrivate;
    private bool fieldAlt;
    private bool inTable;
    private bool inHeader;
    protected RtfDocument document;
    private RtfFont font;
    unknown Font Font {public set; }
    protected RtfField(RtfDocument doc);
    protected RtfField(RtfDocument doc, Font font);
    private static RtfField();
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    private void WriteFieldBegin(Stream result);
    private void WriteFieldInstBegin(Stream result);
    protected abstract virtual void WriteFieldInstContent(Stream oupt);
    private void WriteFieldInstEnd(Stream result);
    private void WriteFieldResultBegin(Stream result);
    protected abstract virtual void WriteFieldResultContent(Stream oupt);
    private void WriteFieldResultEnd(Stream result);
    private void WriteFieldEnd(Stream result);
    public virtual void WriteContent(Stream result);
    public bool IsFieldAlt();
    public void SetFieldAlt(bool fieldAlt);
    public bool IsFieldDirty();
    public void SetFieldDirty(bool fieldDirty);
    public bool IsFieldEdit();
    public void SetFieldEdit(bool fieldEdit);
    public bool IsFieldLocked();
    public void SetFieldLocked(bool fieldLocked);
    public bool IsFieldPrivate();
    public void SetFieldPrivate(bool fieldPrivate);
    public sealed virtual void SetInTable(bool inTable);
    public bool IsInTable();
    public sealed virtual void SetInHeader(bool inHeader);
    public bool IsInHeader();
    public virtual bool IsEmpty();
    public virtual void set_Font(Font value);
}
public class iTextSharp.text.rtf.field.RtfPageNumber : RtfField {
    private static Byte[] PAGE_NUMBER;
    public RtfPageNumber(Font font);
    public RtfPageNumber(RtfDocument doc);
    public RtfPageNumber(RtfDocument doc, Font font);
    private static RtfPageNumber();
    protected virtual void WriteFieldInstContent(Stream oupt);
    protected virtual void WriteFieldResultContent(Stream oupt);
}
public class iTextSharp.text.rtf.field.RtfTableOfContents : RtfField {
    private static string FIELD_INST;
    private string defaultText;
    public RtfTableOfContents(string defaultText);
    protected virtual void WriteFieldInstContent(Stream outp);
    protected virtual void WriteFieldResultContent(Stream outp);
}
public class iTextSharp.text.rtf.field.RtfTOCEntry : RtfField {
    private static Byte[] TEXT_HIDDEN_ON;
    private static Byte[] TEXT_HIDDEN_OFF;
    private static Byte[] TOC_ENTRY_PAGE_NUMBER;
    private static Byte[] TOC_ENTRY_NO_PAGE_NUMBER;
    private string entry;
    private bool showPageNumber;
    public RtfTOCEntry(string entry);
    private static RtfTOCEntry();
    public virtual void WriteContent(Stream result);
    public void SetShowPageNumber(bool showPageNumber);
    protected virtual void WriteFieldInstContent(Stream outp);
    protected virtual void WriteFieldResultContent(Stream outp);
}
public class iTextSharp.text.rtf.field.RtfTotalPageNumber : RtfField {
    private static Byte[] ARABIC_TOTAL_PAGES;
    public RtfTotalPageNumber(Font font);
    public RtfTotalPageNumber(RtfDocument doc);
    public RtfTotalPageNumber(RtfDocument doc, Font font);
    private static RtfTotalPageNumber();
    protected virtual void WriteFieldInstContent(Stream outp);
    protected virtual void WriteFieldResultContent(Stream outp);
}
public class iTextSharp.text.rtf.graphic.RtfImage : RtfElement {
    private static int PIXEL_TWIPS_FACTOR;
    private static Byte[] PICTURE_GROUP;
    private static Byte[] PICTURE;
    private static Byte[] PICTURE_JPEG;
    private static Byte[] PICTURE_PNG;
    private static Byte[] PICTURE_WMF;
    private static Byte[] PICTURE_WIDTH;
    private static Byte[] PICTURE_HEIGHT;
    private static Byte[] PICTURE_SCALED_WIDTH;
    private static Byte[] PICTURE_SCALED_HEIGHT;
    private static Byte[] PICTURE_SCALE_X;
    private static Byte[] PICTURE_SCALE_Y;
    private static Byte[] PICTURE_BINARY_DATA;
    private int imageType;
    private Byte[][] imageData;
    private int alignment;
    private float width;
    private float height;
    private float plainWidth;
    private float plainHeight;
    private bool topLevelElement;
    public static Byte[] byte2charLUT;
    public RtfImage(RtfDocument doc, Image image);
    private static RtfImage();
    private Byte[][] GetImageData(Image image);
    private void WriteImageDataHexEncoded(Stream bab);
    private int ImageDataSize();
    public virtual void WriteContent(Stream result);
    public void SetAlignment(int alignment);
    public void SetTopLevelElement(bool topLevelElement);
}
public class iTextSharp.text.rtf.graphic.RtfShape : RtfAddableElement {
    public static int SHAPE_FREEFORM;
    public static int SHAPE_RECTANGLE;
    public static int SHAPE_ROUND_RECTANGLE;
    public static int SHAPE_ELLIPSE;
    public static int SHAPE_DIAMOND;
    public static int SHAPE_TRIANGLE_ISOSCELES;
    public static int SHAPE_TRIANGLE_RIGHT;
    public static int SHAPE_PARALLELOGRAM;
    public static int SHAPE_TRAPEZOID;
    public static int SHAPE_HEXAGON;
    public static int SHAPE_OCTAGON;
    public static int SHAPE_STAR;
    public static int SHAPE_ARROW;
    public static int SHAPE_ARROR_THICK;
    public static int SHAPE_HOME_PLATE;
    public static int SHAPE_CUBE;
    public static int SHAPE_BALLOON;
    public static int SHAPE_SEAL;
    public static int SHAPE_ARC;
    public static int SHAPE_LINE;
    public static int SHAPE_CAN;
    public static int SHAPE_DONUT;
    public static int SHAPE_PICTURE_FRAME;
    public static int SHAPE_WRAP_NONE;
    public static int SHAPE_WRAP_TOP_BOTTOM;
    public static int SHAPE_WRAP_BOTH;
    public static int SHAPE_WRAP_LEFT;
    public static int SHAPE_WRAP_RIGHT;
    public static int SHAPE_WRAP_LARGEST;
    public static int SHAPE_WRAP_TIGHT_BOTH;
    public static int SHAPE_WRAP_TIGHT_LEFT;
    public static int SHAPE_WRAP_TIGHT_RIGHT;
    public static int SHAPE_WRAP_TIGHT_LARGEST;
    public static int SHAPE_WRAP_THROUGH;
    private int shapeNr;
    private int type;
    private RtfShapePosition position;
    private Hashtable properties;
    private int wrapping;
    private string shapeText;
    public RtfShape(int type, RtfShapePosition position);
    public void SetProperty(RtfShapeProperty property);
    public void SetShapeText(string shapeText);
    public void SetWrapping(int wrapping);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.graphic.RtfShapePosition : RtfAddableElement {
    public static int POSITION_X_RELATIVE_PAGE;
    public static int POSITION_X_RELATIVE_MARGIN;
    public static int POSITION_X_RELATIVE_COLUMN;
    public static int POSITION_Y_RELATIVE_PAGE;
    public static int POSITION_Y_RELATIVE_MARGIN;
    public static int POSITION_Y_RELATIVE_PARAGRAPH;
    private int top;
    private int left;
    private int right;
    private int bottom;
    private int zOrder;
    private int xRelativePos;
    private int yRelativePos;
    private bool ignoreXRelative;
    private bool ignoreYRelative;
    private bool shapeBelowText;
    public RtfShapePosition(int top, int left, int right, int bottom);
    public bool IsShapeBelowText();
    public void SetShapeBelowText(bool shapeBelowText);
    public void SetXRelativePos(int relativePos);
    public void SetYRelativePos(int relativePos);
    public void SetZOrder(int order);
    protected internal void SetIgnoreXRelative(bool ignoreXRelative);
    protected internal void SetIgnoreYRelative(bool ignoreYRelative);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.graphic.RtfShapeProperty : RtfAddableElement {
    public static string PROPERTY_IMAGE;
    public static string PROPERTY_VERTICIES;
    public static string PROPERTY_GEO_TOP;
    public static string PROPERTY_GEO_LEFT;
    public static string PROPERTY_GEO_RIGHT;
    public static string PROPERTY_GEO_BOTTOM;
    public static string PROPERTY_LAYOUT_IN_CELL;
    public static string PROPERTY_FLIP_V;
    public static string PROPERTY_FLIP_H;
    public static string PROPERTY_FILL_COLOR;
    public static string PROPERTY_LINE_COLOR;
    public static string PROPERTY_ADJUST_VALUE;
    private static int PROPERTY_TYPE_LONG;
    private static int PROPERTY_TYPE_BOOLEAN;
    private static int PROPERTY_TYPE_DOUBLE;
    private static int PROPERTY_TYPE_COLOR;
    private static int PROPERTY_TYPE_ARRAY;
    private static int PROPERTY_TYPE_IMAGE;
    private int type;
    private string name;
    private object value;
    private RtfShapeProperty(string name, object value);
    public RtfShapeProperty(string name, long value);
    public RtfShapeProperty(string name, double value);
    public RtfShapeProperty(string name, bool value);
    public RtfShapeProperty(string name, Color value);
    public RtfShapeProperty(string name, Int32[] value);
    public RtfShapeProperty(string name, Point[] value);
    public RtfShapeProperty(string name, Image value);
    public string GetName();
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.headerfooter.RtfHeaderFooter : HeaderFooter {
    public static int TYPE_HEADER;
    public static int TYPE_FOOTER;
    public static int DISPLAY_FIRST_PAGE;
    public static int DISPLAY_ALL_PAGES;
    public static int DISPLAY_LEFT_PAGES;
    public static int DISPLAY_RIGHT_PAGES;
    private static Byte[] HEADER_ALL;
    private static Byte[] HEADER_FIRST;
    private static Byte[] HEADER_LEFT;
    private static Byte[] HEADER_RIGHT;
    private static Byte[] FOOTER_ALL;
    private static Byte[] FOOTER_FIRST;
    private static Byte[] FOOTER_LEFT;
    private static Byte[] FOOTER_RIGHT;
    private RtfDocument document;
    private Object[] content;
    private int type;
    private int displayAt;
    protected internal RtfHeaderFooter(RtfDocument doc, HeaderFooter headerFooter, int type, int displayAt);
    protected internal RtfHeaderFooter(RtfDocument doc, RtfHeaderFooter headerFooter, int displayAt);
    protected internal RtfHeaderFooter(RtfDocument doc, HeaderFooter headerFooter);
    public RtfHeaderFooter(IElement element);
    public RtfHeaderFooter(IElement[] elements);
    private static RtfHeaderFooter();
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream result);
    public void SetDisplayAt(int displayAt);
    public void SetType(int type);
    private Object[] GetContent();
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetInHeader(bool inHeader);
    public void SetAlignment(int alignment);
}
public class iTextSharp.text.rtf.headerfooter.RtfHeaderFooterGroup : HeaderFooter {
    private static int MODE_NONE;
    private static int MODE_SINGLE;
    private static int MODE_MULTIPLE;
    private int mode;
    private int type;
    private RtfHeaderFooter headerAll;
    private RtfHeaderFooter headerFirst;
    private RtfHeaderFooter headerLeft;
    private RtfHeaderFooter headerRight;
    private RtfDocument document;
    public RtfHeaderFooterGroup(RtfDocument doc, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, RtfHeaderFooterGroup headerFooter, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, RtfHeaderFooter headerFooter, int type);
    public RtfHeaderFooterGroup(RtfDocument doc, HeaderFooter headerFooter, int type);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public virtual void WriteContent(Stream result);
    public void SetHeaderFooter(RtfHeaderFooter headerFooter, int displayAt);
    public void SetHeaderFooter(HeaderFooter headerFooter, int displayAt);
    public void SetHasTitlePage();
    public void SetHasFacingPages();
    public bool HasTitlePage();
    public bool HasFacingPages();
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetInHeader(bool inHeader);
    public void SetType(int type);
    protected int GetMode();
    protected RtfHeaderFooter GetHeaderAll();
    protected RtfHeaderFooter GetHeaderFirst();
    protected RtfHeaderFooter GetHeaderLeft();
    protected RtfHeaderFooter GetHeaderRight();
}
public interface iTextSharp.text.rtf.IEventListener {
}
public interface iTextSharp.text.rtf.IRtfBasicElement {
    public abstract virtual void WriteContent(Stream outp);
    public abstract virtual void SetRtfDocument(RtfDocument doc);
    public abstract virtual void SetInTable(bool inTable);
    public abstract virtual void SetInHeader(bool inHeader);
}
public interface iTextSharp.text.rtf.IRtfExtendedElement {
    public abstract virtual void WriteDefinition(Stream outp);
}
public class iTextSharp.text.rtf.list.RtfList : RtfElement {
    public static int LIST_TYPE_NORMAL;
    public static int LIST_TYPE_SIMPLE;
    public static int LIST_TYPE_HYBRID;
    public static Byte[] LIST_NUMBER;
    private static Byte[] LIST;
    public static Byte[] LIST_ID;
    private static Byte[] LIST_TEMPLATE_ID;
    private static Byte[] LIST_SIMPLE;
    private static Byte[] LIST_HYBRID;
    private static Byte[] LIST_RESTARTHDN;
    private static Byte[] LIST_NAME;
    private static Byte[] LIST_STYLEID;
    private static Byte[] LIST_STYLENAME;
    public static Byte[] LIST_LEVEL_NUMBER;
    public static Byte[] LIST_TEXT;
    public static Byte[] LIST_NUMBER_END;
    public static Byte[] TAB;
    private ArrayList items;
    private RtfList parentList;
    private int listID;
    private int listType;
    private string name;
    private int listNumber;
    private ArrayList listLevels;
    public RtfList(RtfDocument doc);
    public RtfList(RtfDocument doc, List list);
    private static RtfList();
    public void SetDocument(RtfDocument doc);
    public sealed virtual void WriteDefinition(Stream result);
    public virtual void WriteContent(Stream result);
    protected void WriteListTextBlock(Stream result, int itemNr, RtfListLevel listLevel);
    protected void WriteListNumbers(Stream result);
    protected void CreateDefaultLevels();
    public int GetListNumber();
    public void SetListNumber(int listNumber);
    public virtual void SetInTable(bool inTable);
    public virtual void SetInHeader(bool inHeader);
    protected internal void CorrectIndentation();
    public void SetID(int id);
    public int GetID();
    public int GetListType();
    public void SetListType(int listType);
    public RtfList GetParentList();
    public void SetParentList(RtfList parentList);
    public string GetName();
    public void SetName(string name);
    public RtfListLevel GetListLevel(int index);
}
public class iTextSharp.text.rtf.list.RtfListItem : RtfParagraph {
    private RtfListLevel parentList;
    private bool containsInnerList;
    private int level;
    public RtfListItem(RtfDocument doc, ListItem listItem);
    public virtual void WriteContent(Stream result);
    public bool WriteDefinition(Stream outp);
    public void InheritListSettings(int listNumber, int listLevel);
    protected internal void CorrectIndentation();
    public void SetParent(RtfListLevel parentList);
    public RtfListLevel GetParent();
    public bool IsContainsInnerList();
    public int GetLevel();
    public void SetLevel(int level);
}
public class iTextSharp.text.rtf.list.RtfListLevel : RtfElement {
    public static int LIST_TYPE_NUMBERED;
    public static int LIST_TYPE_UPPER_LETTERS;
    public static int LIST_TYPE_LOWER_LETTERS;
    public static int LIST_TYPE_UPPER_ROMAN;
    public static int LIST_TYPE_LOWER_ROMAN;
    public static int LIST_TYPE_UNKNOWN;
    public static int LIST_TYPE_BASE;
    public static int LIST_TYPE_ARABIC;
    public static int LIST_TYPE_UPPERCASE_ROMAN_NUMERAL;
    public static int LIST_TYPE_LOWERCASE_ROMAN_NUMERAL;
    public static int LIST_TYPE_UPPERCASE_LETTER;
    public static int LIST_TYPE_LOWERCASE_LETTER;
    public static int LIST_TYPE_ORDINAL_NUMBER;
    public static int LIST_TYPE_CARDINAL_TEXT_NUMBER;
    public static int LIST_TYPE_ORDINAL_TEXT_NUMBER;
    public static int LIST_TYPE_ARABIC_LEADING_ZERO;
    public static int LIST_TYPE_BULLET;
    public static int LIST_TYPE_NO_NUMBER;
    public static int LIST_LEVEL_FOLLOW_TAB;
    public static int LIST_LEVEL_FOLLOW_SPACE;
    public static int LIST_LEVEL_FOLLOW_NOTHING;
    private static Byte[] LIST_LEVEL;
    private static Byte[] LIST_LEVEL_TEMPLATE_ID;
    private static Byte[] LIST_LEVEL_TYPE;
    private static Byte[] LIST_LEVEL_TYPE_NEW;
    private static Byte[] LIST_LEVEL_ALIGNMENT;
    private static Byte[] LIST_LEVEL_ALIGNMENT_NEW;
    private static Byte[] LIST_LEVEL_START_AT;
    private static Byte[] LIST_LEVEL_TEXT;
    private static Byte[] LIST_LEVEL_STYLE_NUMBERED_BEGIN;
    private static Byte[] LIST_LEVEL_STYLE_NUMBERED_END;
    private static Byte[] LIST_LEVEL_STYLE_BULLETED_BEGIN;
    private static Byte[] LIST_LEVEL_STYLE_BULLETED_END;
    private static Byte[] LIST_LEVEL_NUMBERS_BEGIN;
    private static Byte[] LIST_LEVEL_FOLOW;
    private static Byte[] LIST_LEVEL_SPACE;
    private static Byte[] LIST_LEVEL_INDENT;
    private static Byte[] LIST_LEVEL_LEGAL;
    private static Byte[] LIST_LEVEL_NO_RESTART;
    private static Byte[] LIST_LEVEL_NUMBERS_NUMBERED;
    private static Byte[] LIST_LEVEL_NUMBERS_END;
    private static Byte[] LIST_LEVEL_FIRST_INDENT;
    private static Byte[] LIST_LEVEL_SYMBOL_INDENT;
    private static Byte[] LIST_LEVEL_TENTATIVE;
    private static Byte[] LIST_LEVEL_PICTURE;
    private int listType;
    private string bulletCharacter;
    private Chunk bulletChunk;
    private int listStartAt;
    private int listLevel;
    private int firstIndent;
    private int leftIndent;
    private int rightIndent;
    private int symbolIndent;
    private bool isTentative;
    private bool isLegal;
    private int listNoRestart;
    private int levelFollowValue;
    private int alignment;
    private int levelPicture;
    private int levelTextNumber;
    private RtfFont fontNumber;
    private RtfFont fontBullet;
    private int templateID;
    private RtfListLevel listLevelParent;
    private RtfList parent;
    public RtfListLevel(RtfDocument doc);
    public RtfListLevel(RtfDocument doc, RtfList parent);
    public RtfListLevel(RtfListLevel ll);
    private static RtfListLevel();
    public int GetListNoRestart();
    public void SetListNoRestart(int listNoRestart);
    public int GetAlignment();
    public void SetAlignment(int alignment);
    public sealed virtual void WriteDefinition(Stream result);
    public virtual void WriteContent(Stream result);
    protected void WriteListNumbers(Stream result);
    public void WriteIndentation(Stream result);
    public void WriteListBeginning(Stream result);
    protected internal void CorrectIndentation();
    public int GetListLevel();
    public void SetListLevel(int listLevel);
    public string GetBulletCharacter();
    public int GetListStartAt();
    public void SetListStartAt(int listStartAt);
    public int GetFirstIndent();
    public void SetFirstIndent(int firstIndent);
    public int GetLeftIndent();
    public void SetLeftIndent(int leftIndent);
    public int GetRightIndent();
    public void SetRightIndent(int rightIndent);
    public int GetSymbolIndent();
    public void SetSymbolIndent(int symbolIndent);
    public RtfList GetParent();
    public void SetParent(RtfList parent);
    public void SetBulletCharacter(string bulletCharacter);
    public void SetBulletChunk(Chunk bulletCharacter);
    public int GetListType();
    public void SetListType(int listType);
    public void SetBulletFont(Font f);
    public RtfFont GetFontNumber();
    public void SetFontNumber(RtfFont fontNumber);
    public RtfFont GetFontBullet();
    public void SetFontBullet(RtfFont fontBullet);
    public bool IsTentative();
    public void SetTentative(bool isTentative);
    public bool IsLegal();
    public void SetLegal(bool isLegal);
    public int GetLevelFollowValue();
    public void SetLevelFollowValue(int levelFollowValue);
    public int GetLevelTextNumber();
    public void SetLevelTextNumber(int levelTextNumber);
    public RtfListLevel GetListLevelParent();
    public void SetListLevelParent(RtfListLevel listLevelParent);
}
public class iTextSharp.text.rtf.list.RtfListTable : RtfElement {
    private static Byte[] LIST_TABLE;
    private static Byte[] LIST_OVERRIDE_TABLE;
    private static Byte[] LIST_OVERRIDE;
    private static Byte[] LIST_OVERRIDE_COUNT;
    private ArrayList lists;
    private ArrayList picturelists;
    public RtfListTable(RtfDocument doc);
    private static RtfListTable();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
    public int GetListNumber(RtfList list);
    public void FreeListNumber(RtfList list);
}
public class iTextSharp.text.rtf.list.RtfPictureList : RtfElement {
    private static Byte[] LIST_LEVEL_PICTURE;
    public RtfPictureList(RtfDocument doc);
    private static RtfPictureList();
    public virtual void WriteContent(Stream outp);
    public sealed virtual void WriteDefinition(Stream result);
}
public interface iTextSharp.text.rtf.parser.ctrlwords.IRtfCtrlWordListener {
    public abstract virtual RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordData : object {
    public string prefix;
    public string suffix;
    public string ctrlWord;
    public bool hasParam;
    public string param;
    public bool isNeg;
    public bool newGroup;
    public bool modified;
    public int ctrlWordType;
    public string specialHandler;
    public int IntValue();
    public long LongValue();
    public virtual string ToString();
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordHandler : object {
    private static bool debug;
    protected RtfParser rtfParser;
    protected string ctrlWord;
    protected int defaultParameterValue;
    protected bool passDefaultParameterValue;
    protected int ctrlWordType;
    protected string specialHandler;
    protected float rtfVersionSupported;
    protected RtfCtrlWordData ctrlWordData;
    protected string groupPrefix;
    protected string ctrlWordPrefix;
    protected string ctrlWordSuffix;
    public RtfCtrlWordHandler(RtfParser rtfParser, string ctrlWord, int defaultParameterValue, bool passDefaultParameterValue, int ctrlWordType, string prefix, string suffix, string specialHandler);
    private static RtfCtrlWordHandler();
    public bool HandleControlword(RtfCtrlWordData ctrlWordDataIn);
    protected bool BeforeControlWord();
    protected bool OnControlWord();
    protected bool AfterControlWord();
    private void PrintDebug(string txt);
}
internal class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordMap : object {
    private Hashtable ctrlWords;
    public RtfCtrlWordMap(RtfParser rtfParser);
    public RtfCtrlWordHandler GetCtrlWordHandler(string ctrlWord);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordMgr : object {
    public static bool debug;
    public static bool debugFound;
    public static bool debugNotFound;
    private PushbackStream reader;
    private RtfParser rtfParser;
    private RtfCtrlWordMap ctrlWordMap;
    private ArrayList listeners;
    public RtfCtrlWordMgr(RtfParser rtfParser, PushbackStream reader);
    private static RtfCtrlWordMgr();
    public int HandleKeyword(RtfCtrlWordData ctrlWordData, int groupLevel);
    private int DispatchKeyword(RtfCtrlWordData ctrlWordData, int groupLevel);
    public void AddRtfCtrlWordListener(IRtfCtrlWordListener listener);
    public void RemoveRtfCtrlWordListener(IRtfCtrlWordListener listener);
    private bool BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    private bool OnCtrlWord(RtfCtrlWordData ctrlWordData);
    private bool AfterCtrlWord(RtfCtrlWordData ctrlWordData);
}
public class iTextSharp.text.rtf.parser.ctrlwords.RtfCtrlWordType : object {
    public static int UNIDENTIFIED;
    public static int DESTINATION;
    public static int DESTINATION_EX;
    public static int FLAG;
    public static int VALUE;
    public static int TOGGLE;
    public static int SYMBOL;
}
public interface iTextSharp.text.rtf.parser.destinations.IRtfDestinationListener {
    public abstract virtual RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual int BeforeCharacter(int ch);
    public abstract virtual int OnCharacter(int ch);
    public abstract virtual int AfterCharacter(int ch);
    public abstract virtual bool OnOpenGroup();
    public abstract virtual bool OnCloseGroup();
}
public abstract class iTextSharp.text.rtf.parser.destinations.RtfDestination : object {
    protected RtfParser rtfParser;
    protected bool modified;
    protected RtfCtrlWordData lastCtrlWord;
    private static ArrayList listeners;
    public RtfDestination(RtfParser parser);
    private static RtfDestination();
    public virtual void SetParser(RtfParser parser);
    public abstract virtual bool CloseDestination();
    public abstract virtual bool HandleOpeningSubGroup();
    public abstract virtual bool HandleCloseGroup();
    public abstract virtual bool HandleOpenGroup();
    public abstract virtual bool HandleCharacter(int ch);
    public abstract virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public abstract virtual void SetToDefaults();
    public bool IsModified();
    public bool AddListener(IRtfDestinationListener listener);
    public bool RemoveListener(IRtfDestinationListener listener);
    protected RtfCtrlWordData BeforeCtrlWord(RtfCtrlWordData ctrlWordData);
    protected RtfCtrlWordData OnCtrlWord(RtfCtrlWordData ctrlWordData);
    protected RtfCtrlWordData AfterCtrlWord(RtfCtrlWordData ctrlWordData);
    protected int BeforeCharacter(int ch);
    protected int OnCharacter(int ch);
    protected int AfterCharacter(int ch);
    protected bool OnOpenGroup();
    protected bool OnCloseGroup();
    public virtual int GetNewTokeniserState();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationColorTable : RtfDestination {
    private RtfImportMgr importHeader;
    private int colorNr;
    private int red;
    private int green;
    private int blue;
    private int ctint;
    private int cshade;
    private int themeColor;
    private Hashtable colorMap;
    public RtfDestinationColorTable(RtfParser parser);
    public virtual void SetParser(RtfParser parser);
    public virtual bool HandleOpeningSubGroup();
    public virtual bool CloseDestination();
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual void SetToDefaults();
    private void ProcessColor();
    private void SetRed(int value);
    private void SetGreen(int value);
    private void SetBlue(int value);
    private void SetTint(int value);
    private void SetShade(int value);
    private void SetThemeColor(int value);
    public Color GetColor(string key);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationDocument : RtfDestination {
    private RtfDocument rtfDoc;
    private Document doc;
    private StringBuilder buffer;
    private int conversionType;
    private int tableLevel;
    private static ArrayList IMPORT_IGNORED_CTRLWORDS;
    private static ArrayList CONVERT_IGNORED_CTRLWORDS;
    private Paragraph iTextParagraph;
    public RtfDestinationDocument(RtfParser parser);
    private static RtfDestinationDocument();
    public virtual void SetParser(RtfParser parser);
    public virtual bool CloseDestination();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual bool HandleCloseGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    private void WriteBuffer();
    private void WriteText(string value);
    public virtual void SetToDefaults();
    public sealed virtual void AfterPropertyChange(string propertyName);
    public sealed virtual void BeforePropertyChange(string propertyName);
    private void AddParagraphToDocument();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationFontTable : RtfDestination {
    private static string CHARSET_DEFAULT;
    private static int SETTING_NORMAL;
    private static int SETTING_ALTERNATE;
    private static int SETTING_FONTNAME;
    private static int SETTING_PANOSE;
    private static int SETTING_FONT_EMBED;
    private static int SETTING_FONT_FILE;
    private RtfImportMgr importHeader;
    private string themeFont;
    private string fontNr;
    private string fontFamily;
    private string charset;
    private int fprq;
    private string panose;
    private string fontName;
    private string falt;
    private int fbias;
    private string cpg;
    private string trueType;
    private int state;
    private Hashtable fontMap;
    public RtfDestinationFontTable(RtfParser parser);
    public virtual void SetParser(RtfParser parser);
    private void Init(bool importFonts);
    public virtual bool HandleOpeningSubGroup();
    public virtual bool CloseDestination();
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public void SetCodePage(string value);
    public void SetTrueType(string value);
    public void SetPitch(string value);
    public void SetBias(string value);
    public void SetThemeFont(string themeFont);
    public void SetFontName(string fontName);
    public void SetFontFamily(string fontFamily);
    public void SetFontNumber(string fontNr);
    public void SetFontAlternate(string fontAlternate);
    public void SetCharset(string charset);
    public virtual void SetToDefaults();
    private void ProcessFont();
    private Font Createfont(string fontName);
    public Font GetFont(string key);
    private void ImportSystemFonts();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationInfo : RtfDestination {
    private string elementName;
    private string text;
    public RtfDestinationInfo(RtfParser parser, string elementname);
    public virtual void SetParser(RtfParser parser);
    public void SetElementName(string value);
    public virtual bool HandleOpeningSubGroup();
    public virtual bool CloseDestination();
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationListTable : RtfDestination {
    private RtfImportMgr importHeader;
    private RtfList newList;
    private int currentLevel;
    private RtfListLevel currentListLevel;
    private int currentListMappingNumber;
    private int currentSubGroupCount;
    public RtfDestinationListTable(RtfParser parser);
    public virtual void SetParser(RtfParser parser);
    public virtual bool HandleOpeningSubGroup();
    public virtual bool CloseDestination();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationMgr : object {
    public static string DESTINATION_NULL;
    public static string DESTINATION_DOCUMENT;
    private static RtfDestinationMgr instance;
    private static Hashtable destinations;
    private static Hashtable destinationObjects;
    private static bool ignoreUnknownDestinations;
    private static RtfParser rtfParser;
    private static RtfDestinationMgr();
    public static void SetParser(RtfParser parser);
    public static RtfDestinationMgr GetInstance();
    public static RtfDestinationMgr GetInstance(RtfParser parser);
    public static RtfDestination GetDestination(string destination);
    public static bool AddDestination(string destination, Object[] args);
    public static bool AddListener(string destination, IRtfDestinationListener listener);
    public static bool RemoveListener(string destination, IRtfDestinationListener listener);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationNull : RtfDestination {
    private static RtfDestinationNull instance;
    private RtfDestinationNull(RtfParser parser);
    private static RtfDestinationNull();
    public static RtfDestinationNull GetInstance();
    public virtual bool HandleOpeningSubGroup();
    public virtual void SetToDefaults();
    public virtual bool CloseDestination();
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public static string GetName();
    public virtual int GetNewTokeniserState();
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationShppict : RtfDestination {
    public static int ORIGINAL_NONE;
    public static int ORIGINAL_GIF;
    public static int ORIGINAL_TIFF;
    public static int ORIGINAL_PS;
    public static int FORMAT_HEXADECIMAL;
    public static int FORMAT_BINARY;
    private static int NORMAL;
    private static int BLIPUID;
    private static int PIXEL_TWIPS_FACTOR;
    private ByteBuffer data;
    private StringBuilder hexChars;
    private StringBuilder buffer;
    private int pictureType;
    private long width;
    private long height;
    private long desiredWidth;
    private long desiredHeight;
    private int scaleX;
    private int scaleY;
    private int cropTop;
    private int cropBottom;
    private int cropLeft;
    private int cropRight;
    private int dataFormat;
    private long binaryLength;
    private MemoryStream dataOS;
    public RtfDestinationShppict(RtfParser parser);
    public virtual bool CloseDestination();
    public virtual bool HandleCloseGroup();
    private bool AddImage();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleOpeningSubGroup();
    public virtual bool HandleCharacter(int ch);
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual void SetToDefaults();
    private void WriteBuffer();
    private void WriteText(string value);
}
public class iTextSharp.text.rtf.parser.destinations.RtfDestinationStylesheetTable : RtfDestination {
    private string styleName;
    private string elementName;
    private int styleNr;
    private int styleType;
    private int alignment;
    private int justificationPercentage;
    private int firstLineIndent;
    private int leftIndent;
    private int rightIndent;
    private int adustRightIndent;
    private int mirrorIndent;
    private int overrideWidowControl;
    private int AutoSpaceBetweenDBCEnglish;
    private int AutoSpaceBetweenDBCNumbers;
    private int noCharacterWrapping;
    private int noWordWrapping;
    private int noOverflowPeriodComma;
    private RtfImportMgr importHeader;
    private string type;
    public RtfDestinationStylesheetTable(RtfParser parser, string type);
    public virtual void SetParser(RtfParser parser);
    public void SetType(string value);
    public void SetElementName(string value);
    public virtual bool HandleOpeningSubGroup();
    public virtual bool CloseDestination();
    public virtual bool HandleControlWord(RtfCtrlWordData ctrlWordData);
    public virtual bool HandleCloseGroup();
    public virtual bool HandleOpenGroup();
    public virtual bool HandleCharacter(int ch);
    public void CreateNewStyle();
    public int SetJustificationPercentage(int percent);
    public int GetJustificationPercentage();
    public int SetAlignment(int alignment);
    public int GetAlignment();
    public int GetFirstLineIndent();
    public void SetFirstLineIndent(int firstLineIndent);
    public int GetIndent();
    public void SetIndent(int indent);
    public int GetAdustRightIndent();
    public void SetAdustRightIndent(int adustRightIndent);
    public int GetLeftIndent();
    public void SetLeftIndent(int leftIndent);
    public int GetMirrorIndent();
    public void SetMirrorIndent(int mirrorIndent);
    public int GetRightIndent();
    public void SetRightIndent(int rightIndent);
    public int GetOverrideWidowControl();
    public void SetOverrideWidowControl(int overrideWidowControl);
    public int GetAutoSpaceBetweenDBCEnglish();
    public void SetAutoSpaceBetweenDBCEnglish(int autoSpaceBetweenDBCEnglish);
    public int GetAutoSpaceBetweenDBCNumbers();
    public void SetAutoSpaceBetweenDBCNumbers(int autoSpaceBetweenDBCNumbers);
    public int GetNoCharacterWrapping();
    public void SetNoCharacterWrapping(int noCharacterWrapping);
    public int GetNoOverflowPeriodComma();
    public void SetNoOverflowPeriodComma(int noOverflowPeriodComma);
    public int GetNoWordWrapping();
    public void SetNoWordWrapping(int noWordWrapping);
    public int GetStyleNr();
    public void SetStyleNr(int styleNr);
    public int GetStyleType();
    public void SetStyleType(int styleType);
    public virtual void SetToDefaults();
}
public class iTextSharp.text.rtf.parser.enumerations.RtfColorThemes : object {
    public static int THEME_UNDEFINED;
    public static int THEME_MAINDARKONE;
    public static int THEME_MAINDARKTWO;
    public static int THEME_MAINLIGHTONE;
    public static int THEME_MAINLIGHTTWO;
    public static int THEME_ACCENTONE;
    public static int THEME_ACCENTTWO;
    public static int THEME_ACCENTTHREE;
    public static int THEME_ACCENTFOUR;
    public static int THEME_ACCENTFIVE;
    public static int THEME_ACCENTSIX;
    public static int THEME_HYPERLINK;
    public static int THEME_FOLLOWEDHYPERLINK;
    public static int THEME_BACKGROUNDONE;
    public static int THEME_TEXTONE;
    public static int THEME_BACKGROUNDTWO;
    public static int THEME_TEXTTWO;
    public static int THEME_MAX;
}
public class iTextSharp.text.rtf.parser.exceptions.RtfParserException : Exception {
    public RtfParserException(Exception ex);
    public RtfParserException(string message);
}
public class iTextSharp.text.rtf.parser.exceptions.RtfUnknownCtrlWordException : RtfParserException {
}
public interface iTextSharp.text.rtf.parser.properties.IRtfPropertyListener {
    public abstract virtual void BeforePropertyChange(string propertyName);
    public abstract virtual void AfterPropertyChange(string propertyName);
}
public class iTextSharp.text.rtf.parser.properties.RtfCtrlWordPropertyType : object {
    public static int UNIDENTIFIED;
    public static int PROPERTY;
    public static int CHARACTER;
    public static int SPECIAL;
    public static int DESTINATION;
}
public class iTextSharp.text.rtf.parser.properties.RtfProperty : object {
    public static int OFF;
    public static int ON;
    public static string COLOR;
    public static string CHARACTER;
    public static string PARAGRAPH;
    public static string SECTION;
    public static string DOCUMENT;
    public static string COLOR_FG;
    public static string COLOR_BG;
    public static string CHARACTER_BOLD;
    public static string CHARACTER_UNDERLINE;
    public static string CHARACTER_ITALIC;
    public static string CHARACTER_SIZE;
    public static string CHARACTER_FONT;
    public static string CHARACTER_STYLE;
    public static int JUSTIFY_LEFT;
    public static int JUSTIFY_RIGHT;
    public static int JUSTIFY_CENTER;
    public static int JUSTIFY_FULL;
    public static string PARAGRAPH_INDENT_LEFT;
    public static string PARAGRAPH_INDENT_RIGHT;
    public static string PARAGRAPH_INDENT_FIRST_LINE;
    public static string PARAGRAPH_JUSTIFICATION;
    public static string PARAGRAPH_BORDER;
    public static string PARAGRAPH_BORDER_CELL;
    public static int PARAGRAPH_BORDER_NIL;
    public static int PARAGRAPH_BORDER_BOTTOM;
    public static int PARAGRAPH_BORDER_TOP;
    public static int PARAGRAPH_BORDER_LEFT;
    public static int PARAGRAPH_BORDER_RIGHT;
    public static int PARAGRAPH_BORDER_DIAGONAL_UL_LR;
    public static int PARAGRAPH_BORDER_DIAGONAL_UR_LL;
    public static int PARAGRAPH_BORDER_TABLE_HORIZONTAL;
    public static int PARAGRAPH_BORDER_TABLE_VERTICAL;
    public static int PGN_DECIMAL;
    public static int PGN_ROMAN_NUMERAL_UPPERCASE;
    public static int PGN_ROMAN_NUMERAL_LOWERCASE;
    public static int PGN_LETTER_UPPERCASE;
    public static int PGN_LETTER_LOWERCASE;
    public static int SBK_NONE;
    public static int SBK_COLUMN;
    public static int SBK_EVEN;
    public static int SBK_ODD;
    public static int SBK_PAGE;
    public static string SECTION_NUMBER_OF_COLUMNS;
    public static string SECTION_BREAK_TYPE;
    public static string SECTION_PAGE_NUMBER_POSITION_X;
    public static string SECTION_PAGE_NUMBER_POSITION_Y;
    public static string SECTION_PAGE_NUMBER_FORMAT;
    public static string PAGE_PORTRAIT;
    public static string PAGE_LANDSCAPE;
    public static string DOCUMENT_PAGE_WIDTH_TWIPS;
    public static string DOCUMENT_PAGE_HEIGHT_TWIPS;
    public static string DOCUMENT_MARGIN_LEFT_TWIPS;
    public static string DOCUMENT_MARGIN_TOP_TWIPS;
    public static string DOCUMENT_MARGIN_RIGHT_TWIPS;
    public static string DOCUMENT_MARGIN_BOTTOM_TWIPS;
    public static string DOCUMENT_PAGE_NUMBER_START;
    public static string DOCUMENT_ENABLE_FACING_PAGES;
    public static string DOCUMENT_PAGE_ORIENTATION;
    public static string DOCUMENT_DEFAULT_FONT_NUMER;
    protected Hashtable properties;
    private bool modifiedCharacter;
    private bool modifiedParagraph;
    private bool modifiedSection;
    private bool modifiedDocument;
    private ArrayList listeners;
    public void SetToDefault();
    public void SetToDefault(string propertyGroup);
    public bool ToggleProperty(RtfCtrlWordData ctrlWordData);
    public bool SetProperty(RtfCtrlWordData ctrlWordData);
    private bool SetProperty(string propertyName, object propertyValueNew);
    private bool SetProperty(string propertyName, int propertyValueNew);
    private bool AddToProperty(string propertyName, int propertyValue);
    private bool SetProperty(string propertyName, long propertyValueNew);
    private bool AddToProperty(string propertyName, long propertyValue);
    private bool RemoveProperty(string propertyName);
    public object GetProperty(string propertyName);
    public Hashtable GetProperties(string propertyGroup);
    public bool IsModified();
    public void SetModified(string propertyName, bool modified);
    public bool IsModifiedCharacter();
    public void SetModifiedCharacter(bool modifiedCharacter);
    public bool IsModifiedParagraph();
    public void SetModifiedParagraph(bool modifiedParagraph);
    public bool IsModifiedSection();
    public void SetModifiedSection(bool modifiedSection);
    public bool IsModifiedDocument();
    public void SetModifiedDocument(bool modifiedDocument);
    public void AddRtfPropertyListener(IRtfPropertyListener listener);
    public void RemoveRtfPropertyListener(IRtfPropertyListener listener);
    public void BeforeChange(string propertyName);
    public void AfterChange(string propertyName);
}
public class iTextSharp.text.rtf.parser.PushbackStream : Stream {
    private int buf;
    private Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PushbackStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class iTextSharp.text.rtf.parser.RtfImportMappings : object {
    private Hashtable fontMappings;
    private Hashtable colorMappings;
    private Hashtable listMappings;
    private Hashtable stylesheetListMappings;
    public void AddFont(string fontNr, string fontName);
    public void AddColor(string colorNr, Color color);
    public void AddList(string listNr, string list);
    public void AddStylesheetList(string stylesheetListNr, string list);
    public Hashtable GetFontMappings();
    public Hashtable GetColorMappings();
    public Hashtable GetListMappings();
    public Hashtable GetStylesheetListMappings();
}
public class iTextSharp.text.rtf.parser.RtfImportMgr : object {
    private Hashtable importFontMapping;
    private Hashtable importColorMapping;
    private Hashtable importStylesheetListMapping;
    private Hashtable importListMapping;
    private RtfDocument rtfDoc;
    private Document doc;
    public RtfImportMgr(RtfDocument rtfDoc, Document doc);
    public bool ImportFont(string fontNr, string fontName);
    public bool ImportFont(string fontNr, string fontName, int charset);
    public bool ImportFont(string fontNr, string fontName, string fontFamily, int charset);
    public string MapFontNr(string fontNr);
    public void ImportColor(string colorNr, Color color);
    public string MapColorNr(string colorNr);
    public void ImportList(string origListNr, string newListNr);
    public string MapListNr(string listNr);
    public bool ImportStylesheetList(string listNr, List listIn);
    public string MapStylesheetListNr(string listNr);
}
public class iTextSharp.text.rtf.parser.RtfParser : object {
    public static int PARSER_IN_HEADER;
    public static int PARSER_IN_CHARSET;
    public static int PARSER_IN_DEFFONT;
    public static int PARSER_IN_FONT_TABLE;
    public static int PARSER_IN_FONT_TABLE_INFO;
    public static int PARSER_IN_FILE_TABLE;
    public static int PARSER_IN_COLOR_TABLE;
    public static int PARSER_IN_STYLESHEET;
    public static int PARSER_IN_LIST_TABLE;
    public static int PARSER_IN_LISTOVERRIDE_TABLE;
    public static int PARSER_IN_REV_TABLE;
    public static int PARSER_IN_RSID_TABLE;
    public static int PARSER_IN_GENERATOR;
    public static int PARSER_IN_PARAGRAPH_TABLE;
    public static int PARSER_IN_OLDCPROPS;
    public static int PARSER_IN_OLDPPROPS;
    public static int PARSER_IN_OLDTPROPS;
    public static int PARSER_IN_OLDSPROPS;
    public static int PARSER_IN_PROT_USER_TABLE;
    public static int PARSER_IN_LATENTSTYLES;
    public static int PARSER_IN_PARAGRAPH_GROUP_PROPERTIES;
    public static int PARSER_IN_DOCUMENT;
    public static int PARSER_IN_INFO_GROUP;
    public static int PARSER_IN_UPR;
    public static int PARSER_IN_SHPPICT;
    public static int PARSER_IN_PICT;
    public static int PARSER_IN_PICPROP;
    public static int PARSER_IN_BLIPUID;
    public static int PARSER_STARTSTOP;
    public static int PARSER_ERROR;
    public static int PARSER_ERROR_EOF;
    public static int PARSER_IN_UNKNOWN;
    public static int TYPE_UNIDENTIFIED;
    public static int TYPE_IMPORT_FULL;
    public static int TYPE_IMPORT_FRAGMENT;
    public static int TYPE_CONVERT;
    public static int TYPE_IMPORT_INTO_ELEMENT;
    public static int DESTINATION_NORMAL;
    public static int DESTINATION_SKIP;
    public static int TOKENISER_NORMAL;
    public static int TOKENISER_SKIP_BYTES;
    public static int TOKENISER_SKIP_GROUP;
    public static int TOKENISER_BINARY;
    public static int TOKENISER_HEX;
    public static int TOKENISER_IGNORE_RESULT;
    public static int TOKENISER_STATE_IN_ERROR;
    public static int TOKENISER_STATE_IN_UNKOWN;
    public static int errOK;
    public static int errStackUnderflow;
    public static int errStackOverflow;
    public static int errUnmatchedBrace;
    public static int errInvalidHex;
    public static int errBadTable;
    public static int errAssertion;
    public static int errEndOfFile;
    public static int errCtrlWordNotFound;
    private static bool debugParser;
    private string logFile;
    private bool logging;
    private bool logAppend;
    private IElement elem;
    private Document document;
    private RtfDocument rtfDoc;
    private RtfCtrlWordMgr rtfKeywordMgr;
    private RtfImportMgr importMgr;
    private RtfDestinationMgr destinationMgr;
    private Stack stackState;
    private RtfParserState currentState;
    private PushbackStream pbReader;
    private int conversionType;
    private int groupLevel;
    private int docGroupLevel;
    private long binByteCount;
    private long binSkipByteCount;
    private int skipGroupLevel;
    private long byteCount;
    private long ctrlWordCount;
    private long openGroupCount;
    private long closeGroupCount;
    private long characterCount;
    private long ctrlWordHandledCount;
    private long ctrlWordNotHandledCount;
    private long ctrlWordSkippedCount;
    private long groupSkippedCount;
    private long startTime;
    private long endTime;
    private DateTime startDate;
    private DateTime endDate;
    private RtfCtrlWordData lastCtrlWordParam;
    private ArrayList listeners;
    public RtfParser(Document doc);
    private static RtfParser();
    public void ImportRtfDocument(Stream readerIn, RtfDocument rtfDoc);
    public void ImportRtfDocumentIntoElement(IElement elem, Stream readerIn, RtfDocument rtfDoc);
    public void ConvertRtfDocument(Stream readerIn, Document doc);
    public void ImportRtfFragment(Stream readerIn, RtfDocument rtfDoc, RtfImportMappings importMappings);
    public void AddListener(IEventListener listener);
    public void RemoveListener(IEventListener listener);
    private void Init(int type, RtfDocument rtfDoc, Stream readerIn, Document doc, IElement elem);
    protected void Init_stats();
    private PushbackStream Init_Reader(Stream readerIn);
    private void HandleImportMappings(RtfImportMappings importMappings);
    public int HandleOpenGroup();
    public static void OutputDebug(object doc, int groupLevel, string str);
    public int HandleCloseGroup();
    public int HandleCtrlWord(RtfCtrlWordData ctrlWordData);
    public int HandleCharacter(int nextChar);
    public RtfParserState GetState();
    public int GetParserState();
    public int SetParserState(int newState);
    public int GetConversionType();
    public RtfDocument GetRtfDocument();
    public Document GetDocument();
    public RtfImportMgr GetImportManager();
    public bool SetCurrentDestination(string destination);
    public RtfDestination GetCurrentDestination();
    public RtfDestination GetDestination(string destination);
    public bool IsNewGroup();
    public bool SetNewGroup(bool value);
    public void Tokenise();
    private int ParseChar(int nextChar);
    private int ParseCtrlWord(PushbackStream reader);
    public int SetTokeniserState(int value);
    public int GetTokeniserState();
    public int GetLevel();
    public void SetTokeniserStateNormal();
    public void SetTokeniserStateSkipGroup();
    public void SetTokeniserSkipBytes(long numberOfBytesToSkip);
    public void SetTokeniserStateBinary(int binaryCount);
    public void SetTokeniserStateBinary(long binaryCount);
    public bool IsConvert();
    public bool IsImport();
    public bool IsImportFull();
    public bool IsImportFragment();
    public bool GetExtendedDestination();
    public bool SetExtendedDestination(bool value);
    public string GetLogFile();
    public void SetLogFile(string logFile);
    public void SetLogFile(string logFile, bool logAppend);
    public bool IsLogging();
    public void SetLogging(bool logging);
    public bool IsLogAppend();
    public void SetLogAppend(bool logAppend);
}
public class iTextSharp.text.rtf.parser.RtfParserState : object {
    public int parserState;
    public int tokeniserState;
    public object groupHandler;
    public StringBuilder text;
    public Stack ctrlWordHandlers;
    public object ctrlWordHandler;
    public RtfDestination destination;
    public bool isExtendedDestination;
    public bool newGroup;
    public RtfProperty properties;
    public RtfParserState(RtfParserState orig);
}
public abstract class iTextSharp.text.rtf.RtfAddableElement : Chunk {
    protected RtfDocument doc;
    protected bool inTable;
    protected bool inHeader;
    public abstract virtual void WriteContent(Stream outp);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetInHeader(bool inHeader);
    public Byte[] IntToByteArray(int i);
    public virtual bool IsEmpty();
}
public abstract class iTextSharp.text.rtf.RtfElement : object {
    public static double TWIPS_FACTOR;
    public static Byte[] OPEN_GROUP;
    public static Byte[] CLOSE_GROUP;
    public static Byte[] DELIMITER;
    public static Byte[] COMMA_DELIMITER;
    protected RtfDocument document;
    protected bool inTable;
    protected bool inHeader;
    public RtfElement(RtfDocument doc);
    private static RtfElement();
    public Byte[] IntToByteArray(int i);
    public abstract virtual void WriteContent(Stream outp);
    public virtual void SetRtfDocument(RtfDocument doc);
    public virtual bool IsInTable();
    public virtual void SetInTable(bool inTable);
    public virtual void SetInHeader(bool inHeader);
}
public class iTextSharp.text.rtf.RtfMapper : object {
    private RtfDocument rtfDoc;
    public RtfMapper(RtfDocument doc);
    public IRtfBasicElement[] MapElement(IElement element);
}
public class iTextSharp.text.rtf.RtfWriter2 : DocWriter {
    private RtfDocument rtfDoc;
    unknown HeaderFooter Header {public set; }
    unknown HeaderFooter Footer {public set; }
    unknown int PageCount {public set; }
    protected RtfWriter2(Document doc, Stream os);
    public static RtfWriter2 GetInstance(Document doc, Stream os);
    public virtual void set_Header(HeaderFooter value);
    public virtual void ResetHeader();
    public virtual void set_Footer(HeaderFooter value);
    public virtual void ResetFooter();
    public virtual void set_PageCount(int value);
    public virtual void ResetPageCount();
    public virtual void Open();
    public virtual void Close();
    public virtual bool Add(IElement element);
    public virtual bool NewPage();
    public virtual bool SetMargins(float left, float right, float top, float bottom);
    public virtual bool SetPageSize(Rectangle rect);
    public void SetAutogenerateTOCEntries(bool autogenerate);
    public RtfDocumentSettings GetDocumentSettings();
    public void ImportRtfDocument(Stream documentSource);
    public void ImportRtfDocument(Stream documentSource, IEventListener[] events);
    public void ImportRtfFragment(Stream documentSource, RtfImportMappings mappings);
    public void ImportRtfFragment(Stream documentSource, RtfImportMappings mappings, IEventListener[] events);
    public void ImportRtfDocumentIntoElement(IElement elem, FileStream documentSource);
    public void ImportRtfDocumentIntoElement(IElement elem, FileStream documentSource, IEventListener[] events);
}
public class iTextSharp.text.rtf.style.RtfColor : RtfElement {
    private static byte COLON;
    private static Byte[] COLOR_RED;
    private static Byte[] COLOR_GREEN;
    private static Byte[] COLOR_BLUE;
    private static Byte[] COLOR_NUMBER;
    private int colorNumber;
    private int red;
    private int green;
    private int blue;
    protected internal RtfColor(RtfDocument doc, int red, int green, int blue, int colorNumber);
    public RtfColor(RtfDocument doc, RtfColor col);
    public RtfColor(RtfDocument doc, Color col);
    public RtfColor(RtfDocument doc, int red, int green, int blue);
    private static RtfColor();
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
    public void WriteBegin(Stream result);
    public void WriteEnd(Stream result);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int GetBlue();
    public int GetGreen();
    public int GetRed();
    public int GetColorNumber();
    public virtual void SetRtfDocument(RtfDocument doc);
}
public class iTextSharp.text.rtf.style.RtfColorList : RtfElement {
    private static Byte[] COLOR_TABLE;
    private ArrayList colorList;
    public RtfColorList(RtfDocument doc);
    private static RtfColorList();
    public int GetColorNumber(RtfColor color);
    public virtual void WriteContent(Stream outp);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.style.RtfFont : Font {
    public static int STYLE_NONE;
    public static int STYLE_BOLD;
    public static int STYLE_ITALIC;
    public static int STYLE_UNDERLINE;
    public static int STYLE_STRIKETHROUGH;
    public static int STYLE_DOUBLE_STRIKETHROUGH;
    public static int STYLE_SHADOW;
    public static int STYLE_OUTLINE;
    public static int STYLE_EMBOSSED;
    public static int STYLE_ENGRAVED;
    public static int STYLE_HIDDEN;
    private static Byte[] FONT_FAMILY;
    private static Byte[] FONT_CHARSET;
    public static Byte[] FONT_SIZE;
    private static Byte[] FONT_BOLD;
    private static Byte[] FONT_ITALIC;
    private static Byte[] FONT_UNDERLINE;
    private static Byte[] FONT_STRIKETHROUGH;
    private static Byte[] FONT_DOUBLE_STRIKETHROUGH;
    private static Byte[] FONT_SHADOW;
    private static Byte[] FONT_OUTLINE;
    private static Byte[] FONT_EMBOSSED;
    private static Byte[] FONT_ENGRAVED;
    private static Byte[] FONT_HIDDEN;
    private string fontName;
    private int fontSize;
    private int fontStyle;
    private int fontNumber;
    private RtfColor color;
    private int charset;
    protected RtfDocument document;
    public string Familyname { get; }
    unknown float Size {public set; }
    unknown Color Color {public set; }
    public RtfFont(string fontName);
    public RtfFont(string fontName, float size);
    public RtfFont(string fontName, float size, int style);
    public RtfFont(string fontName, float size, int style, Color color);
    public RtfFont(string fontName, float size, int style, Color color, int charset);
    protected internal RtfFont(RtfDocument doc, int fontNumber);
    public RtfFont(RtfDocument doc, Font font);
    private static RtfFont();
    public virtual void WriteDefinition(Stream result);
    public virtual void WriteBegin(Stream result);
    public virtual void WriteEnd(Stream result);
    public virtual void WriteContent(Stream outp);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string GetFontName();
    public virtual void SetFontName(string fontName);
    public virtual string get_Familyname();
    public virtual void SetFamily(string family);
    private void SetToDefaultFamily(string familyname);
    public int GetFontSize();
    public virtual void set_Size(float value);
    public int GetFontStyle();
    public virtual void SetStyle(int style);
    public virtual void SetStyle(string style);
    public int GetCharset();
    public void SetCharset(int charset);
    public int GetFontNumber();
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetInHeader(bool inHeader);
    public virtual void set_Color(Color value);
    public virtual void SetColor(int red, int green, int blue);
    protected Byte[] IntToByteArray(int i);
    public virtual Font Difference(Font font);
    public virtual bool IsStandardFont();
    public virtual int CompareTo(object obj);
}
public class iTextSharp.text.rtf.style.RtfFontList : RtfElement {
    private static Byte[] DEFAULT_FONT;
    private static Byte[] FONT_TABLE;
    public static Byte[] FONT_NUMBER;
    private ArrayList fontList;
    public RtfFontList(RtfDocument doc);
    private static RtfFontList();
    public virtual void WriteContent(Stream outp);
    public int GetFontNumber(RtfFont font);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.style.RtfParagraphStyle : RtfFont {
    private static int MODIFIED_NONE;
    private static int MODIFIED_ALIGNMENT;
    private static int MODIFIED_INDENT_LEFT;
    private static int MODIFIED_INDENT_RIGHT;
    private static int MODIFIED_SPACING_BEFORE;
    private static int MODIFIED_SPACING_AFTER;
    private static int MODIFIED_FONT_NAME;
    private static int MODIFIED_FONT_SIZE;
    private static int MODIFIED_FONT_STYLE;
    private static int MODIFIED_FONT_COLOR;
    private static int MODIFIED_LINE_LEADING;
    private static int MODIFIED_KEEP_TOGETHER;
    private static int MODIFIED_KEEP_TOGETHER_WITH_NEXT;
    public static Byte[] ALIGN_LEFT;
    public static Byte[] ALIGN_RIGHT;
    public static Byte[] ALIGN_CENTER;
    public static Byte[] ALIGN_JUSTIFY;
    public static Byte[] FIRST_LINE_INDENT;
    public static Byte[] INDENT_LEFT;
    public static Byte[] INDENT_RIGHT;
    public static Byte[] KEEP_TOGETHER;
    public static Byte[] KEEP_TOGETHER_WITH_NEXT;
    public static Byte[] SPACING_AFTER;
    public static Byte[] SPACING_BEFORE;
    public static RtfParagraphStyle STYLE_NORMAL;
    public static RtfParagraphStyle STYLE_HEADING_1;
    public static RtfParagraphStyle STYLE_HEADING_2;
    public static RtfParagraphStyle STYLE_HEADING_3;
    private int alignment;
    private int firstLineIndent;
    private int indentLeft;
    private int indentRight;
    private int spacingBefore;
    private int spacingAfter;
    private int lineLeading;
    private bool keepTogether;
    private bool keepTogetherWithNext;
    private string styleName;
    private string basedOnName;
    private RtfParagraphStyle baseStyle;
    private int modified;
    private int styleNumber;
    unknown float Size {public set; }
    private static RtfParagraphStyle();
    public RtfParagraphStyle(string styleName, string fontName, int fontSize, int fontStyle, Color fontColor);
    public RtfParagraphStyle(string styleName, string basedOnName);
    public RtfParagraphStyle(RtfDocument doc, RtfParagraphStyle style);
    public string GetStyleName();
    public string GetBasedOnName();
    public int GetAlignment();
    public void SetAlignment(int alignment);
    public int GetFirstLineIndent();
    public void SetFirstLineIndent(int firstLineIndent);
    public int GetIndentLeft();
    public void SetIndentLeft(int indentLeft);
    public int GetIndentRight();
    public void SetIndentRight(int indentRight);
    public int GetSpacingBefore();
    public void SetSpacingBefore(int spacingBefore);
    public int GetSpacingAfter();
    public void SetSpacingAfter(int spacingAfter);
    public virtual void SetFontName(string fontName);
    public virtual void set_Size(float value);
    public virtual void SetStyle(int fontStyle);
    public void SetColor(Color color);
    public int GetLineLeading();
    public void SetLineLeading(int lineLeading);
    public bool GetKeepTogether();
    public void SetKeepTogether(bool keepTogether);
    public bool GetKeepTogetherWithNext();
    public void SetKeepTogetherWithNext(bool keepTogetherWithNext);
    public void HandleInheritance();
    private void WriteParagraphSettings(Stream result);
    public virtual void WriteDefinition(Stream result);
    public virtual void WriteBegin(Stream result);
    public virtual void WriteEnd(Stream result);
    public virtual void WriteContent(Stream outp);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private int GetStyleNumber();
    protected internal void SetStyleNumber(int styleNumber);
}
public class iTextSharp.text.rtf.style.RtfStylesheetList : RtfElement {
    private Hashtable styleMap;
    private bool defaultsLoaded;
    public RtfStylesheetList(RtfDocument doc);
    public virtual void WriteContent(Stream outp);
    public void RegisterParagraphStyle(RtfParagraphStyle rtfParagraphStyle);
    private void RegisterDefaultStyles();
    public RtfParagraphStyle GetRtfParagraphStyle(string styleName);
    public virtual void WriteDefinition(Stream result);
}
public class iTextSharp.text.rtf.style.RtfStyleTypes : object {
    public static int PARAGRAPH;
    public static int CHARACTER;
    public static int SECTION;
    public static int TABLE;
    public static int TABLE_STYLE_DEFINITION;
}
public class iTextSharp.text.rtf.table.RtfBorder : RtfElement {
    protected internal static int ROW_BORDER;
    protected internal static int CELL_BORDER;
    protected internal static int NO_BORDER;
    protected internal static int LEFT_BORDER;
    protected internal static int TOP_BORDER;
    protected internal static int RIGHT_BORDER;
    protected internal static int BOTTOM_BORDER;
    protected internal static int BOX_BORDER;
    protected internal static int VERTICAL_BORDER;
    protected internal static int HORIZONTAL_BORDER;
    public static int BORDER_NONE;
    public static int BORDER_SINGLE;
    public static int BORDER_DOUBLE_THICK;
    public static int BORDER_SHADOWED;
    public static int BORDER_DOTTED;
    public static int BORDER_DASHED;
    public static int BORDER_HAIRLINE;
    public static int BORDER_DOUBLE;
    public static int BORDER_DOT_DASH;
    public static int BORDER_DOT_DOT_DASH;
    public static int BORDER_TRIPLE;
    public static int BORDER_THICK_THIN;
    public static int BORDER_THIN_THICK;
    public static int BORDER_THIN_THICK_THIN;
    public static int BORDER_THICK_THIN_MED;
    public static int BORDER_THIN_THICK_MED;
    public static int BORDER_THIN_THICK_THIN_MED;
    public static int BORDER_THICK_THIN_LARGE;
    public static int BORDER_THIN_THICK_LARGE;
    public static int BORDER_THIN_THICK_THIN_LARGE;
    public static int BORDER_WAVY;
    public static int BORDER_DOUBLE_WAVY;
    public static int BORDER_STRIPED;
    public static int BORDER_EMBOSS;
    public static int BORDER_ENGRAVE;
    protected internal static Byte[] ROW_BORDER_LEFT;
    protected internal static Byte[] ROW_BORDER_TOP;
    protected internal static Byte[] ROW_BORDER_RIGHT;
    protected internal static Byte[] ROW_BORDER_BOTTOM;
    protected internal static Byte[] ROW_BORDER_HORIZONTAL;
    protected internal static Byte[] ROW_BORDER_VERTICAL;
    protected internal static Byte[] CELL_BORDER_LEFT;
    protected internal static Byte[] CELL_BORDER_TOP;
    protected internal static Byte[] CELL_BORDER_RIGHT;
    protected internal static Byte[] CELL_BORDER_BOTTOM;
    protected internal static Byte[] BORDER_WIDTH;
    protected internal static Byte[] BORDER_COLOR_NUMBER;
    protected internal static Byte[] BORDER_STYLE_SINGLE;
    protected internal static Byte[] BORDER_STYLE_DOUBLE_THICK;
    protected internal static Byte[] BORDER_STYLE_SHADOWED;
    protected internal static Byte[] BORDER_STYLE_DOTTED;
    protected internal static Byte[] BORDER_STYLE_DASHED;
    protected internal static Byte[] BORDER_STYLE_HAIRLINE;
    protected internal static Byte[] BORDER_STYLE_DOUBLE;
    protected internal static Byte[] BORDER_STYLE_DOT_DASH;
    protected internal static Byte[] BORDER_STYLE_DOT_DOT_DASH;
    protected internal static Byte[] BORDER_STYLE_TRIPLE;
    protected internal static Byte[] BORDER_STYLE_THICK_THIN;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK_THIN;
    protected internal static Byte[] BORDER_STYLE_THICK_THIN_MED;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK_MED;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK_THIN_MED;
    protected internal static Byte[] BORDER_STYLE_THICK_THIN_LARGE;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK_LARGE;
    protected internal static Byte[] BORDER_STYLE_THIN_THICK_THIN_LARGE;
    protected internal static Byte[] BORDER_STYLE_WAVY;
    protected internal static Byte[] BORDER_STYLE_DOUBLE_WAVY;
    protected internal static Byte[] BORDER_STYLE_STRIPED;
    protected internal static Byte[] BORDER_STYLE_EMBOSS;
    protected internal static Byte[] BORDER_STYLE_ENGRAVE;
    private int borderType;
    private int borderPosition;
    private int borderStyle;
    private int borderWidth;
    private RtfColor borderColor;
    protected internal RtfBorder(RtfDocument doc, int borderType, RtfBorder border);
    protected internal RtfBorder(RtfDocument doc, int borderType, int borderPosition, int borderStyle, float borderWidth, Color borderColor);
    private static RtfBorder();
    public virtual void WriteContent(Stream result);
    private Byte[] WriteBorderStyle();
    protected RtfColor GetBorderColor();
    protected int GetBorderPosition();
    protected int GetBorderStyle();
    protected int GetBorderType();
    protected int GetBorderWidth();
}
public class iTextSharp.text.rtf.table.RtfBorderGroup : RtfElement {
    private int borderType;
    private Hashtable borders;
    public RtfBorderGroup(int bordersToAdd, int borderStyle, float borderWidth, Color borderColor);
    protected internal RtfBorderGroup(RtfDocument doc, int borderType, RtfBorderGroup borderGroup);
    protected internal RtfBorderGroup(RtfDocument doc, int borderType, int bordersToUse, float borderWidth, Color borderColor);
    private void SetBorder(int borderPosition, int borderStyle, float borderWidth, Color borderColor);
    public void AddBorder(int bordersToAdd, int borderStyle, float borderWidth, Color borderColor);
    public void RemoveBorder(int bordersToRemove);
    public virtual void WriteContent(Stream result);
    protected internal Hashtable GetBorders();
}
public class iTextSharp.text.rtf.table.RtfCell : Cell {
    private static int MERGE_NONE;
    private static int MERGE_VERT_PARENT;
    private static int MERGE_VERT_CHILD;
    private RtfRow parentRow;
    private ArrayList content;
    private int cellRight;
    private int cellWidth;
    private RtfBorderGroup borders;
    private RtfColor backgroundColor;
    private int cellPadding;
    private int mergeType;
    private RtfDocument document;
    private bool inHeader;
    private bool deleted;
    private float cellPaddingLeft;
    private float cellPaddingTop;
    private float cellPaddingBottom;
    private float cellPaddingRight;
    public RtfCell(string content);
    public RtfCell(IElement element);
    protected internal RtfCell(bool deleted);
    protected internal RtfCell(RtfDocument doc, RtfRow row, Cell cell);
    protected internal RtfCell(RtfDocument doc, RtfRow row, PdfPCell cell);
    private void ImportCell(Cell cell);
    private void ImportCell(PdfPCell cell);
    public virtual void WriteDefinition(Stream result);
    public virtual void WriteContent(Stream result);
    protected internal void SetCellRight(int cellRight);
    protected internal int GetCellRight();
    protected internal void SetCellWidth(int cellWidth);
    protected internal int GetCellWidth();
    protected internal int GetCellpadding();
    protected internal RtfBorderGroup GetBorders();
    public void SetBorders(RtfBorderGroup borderGroup);
    protected internal RtfColor GetRtfBackgroundColor();
    protected internal void SetCellMergeChild(RtfCell mergeParent);
    public sealed virtual void SetRtfDocument(RtfDocument doc);
    public sealed virtual void SetInTable(bool inTable);
    public sealed virtual void SetInHeader(bool inHeader);
    public bool IsInHeader();
    private Byte[] IntToByteArray(int i);
    public bool IsDeleted();
}
public class iTextSharp.text.rtf.table.RtfRow : RtfElement {
    private static Byte[] ROW_BEGIN;
    private static Byte[] ROW_WIDTH_STYLE;
    private static Byte[] ROW_WIDTH;
    private static Byte[] ROW_KEEP_TOGETHER;
    private static Byte[] ROW_HEADER_ROW;
    private static Byte[] ROW_ALIGN_LEFT;
    private static Byte[] ROW_ALIGN_RIGHT;
    private static Byte[] ROW_ALIGN_CENTER;
    private static Byte[] ROW_ALIGN_JUSTIFIED;
    private static Byte[] ROW_GRAPH;
    private static Byte[] ROW_CELL_SPACING_LEFT;
    private static Byte[] ROW_CELL_SPACING_TOP;
    private static Byte[] ROW_CELL_SPACING_RIGHT;
    private static Byte[] ROW_CELL_SPACING_BOTTOM;
    private static Byte[] ROW_CELL_SPACING_LEFT_STYLE;
    private static Byte[] ROW_CELL_SPACING_TOP_STYLE;
    private static Byte[] ROW_CELL_SPACING_RIGHT_STYLE;
    private static Byte[] ROW_CELL_SPACING_BOTTOM_STYLE;
    private static Byte[] ROW_CELL_PADDING_LEFT;
    private static Byte[] ROW_CELL_PADDING_RIGHT;
    private static Byte[] ROW_CELL_PADDING_LEFT_STYLE;
    private static Byte[] ROW_CELL_PADDING_RIGHT_STYLE;
    private static Byte[] ROW_END;
    private RtfTable parentTable;
    private ArrayList cells;
    private int width;
    private int rowNumber;
    protected internal RtfRow(RtfDocument doc, RtfTable rtfTable, Row row, int rowNumber);
    protected internal RtfRow(RtfDocument doc, RtfTable rtfTable, PdfPRow row, int rowNumber);
    private static RtfRow();
    private void ImportRow(Row row);
    private void ImportRow(PdfPRow row);
    protected internal void HandleCellSpanning();
    protected internal void CleanRow();
    private void WriteRowDefinition(Stream result);
    public virtual void WriteContent(Stream result);
    protected internal RtfTable GetParentTable();
    protected internal ArrayList GetCells();
}
public class iTextSharp.text.rtf.table.RtfTable : RtfElement {
    private ArrayList rows;
    private float tableWidthPercent;
    private Single[] proportionalWidths;
    private float cellPadding;
    private float cellSpacing;
    private RtfBorderGroup borders;
    private int alignment;
    private bool cellsFitToPage;
    private bool tableFitToPage;
    private int headerRows;
    private int offset;
    public RtfTable(RtfDocument doc, Table table);
    public RtfTable(RtfDocument doc, PdfPTable table);
    private void ImportTable(Table table);
    private void ImportTable(PdfPTable table);
    public virtual void WriteContent(Stream result);
    protected internal int GetAlignment();
    protected internal RtfBorderGroup GetBorders();
    protected internal float GetCellPadding();
    protected internal float GetCellSpacing();
    protected internal Single[] GetProportionalWidths();
    protected internal float GetTableWidthPercent();
    protected internal ArrayList GetRows();
    protected internal bool GetCellsFitToPage();
    protected internal bool GetTableFitToPage();
    protected internal int GetHeaderRows();
}
public class iTextSharp.text.rtf.text.RtfAnnotation : RtfElement {
    private static Byte[] ANNOTATION_ID;
    private static Byte[] ANNOTATION_AUTHOR;
    private static Byte[] ANNOTATION;
    private string title;
    private string content;
    public RtfAnnotation(RtfDocument doc, Annotation annotation);
    private static RtfAnnotation();
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.text.RtfChapter : RtfSection {
    public RtfChapter(RtfDocument doc, Chapter chapter);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.text.RtfChunk : RtfElement {
    private static Byte[] FONT_SUBSCRIPT;
    private static Byte[] FONT_SUPERSCRIPT;
    private static Byte[] FONT_END_SUPER_SUBSCRIPT;
    private static Byte[] BACKGROUND_COLOR;
    private RtfFont font;
    private string content;
    private bool softLineBreaks;
    private float superSubScript;
    private RtfColor background;
    public RtfChunk(RtfDocument doc, Chunk chunk);
    private static RtfChunk();
    public virtual void WriteContent(Stream result);
    public virtual void SetRtfDocument(RtfDocument doc);
    public void SetSoftLineBreaks(bool softLineBreaks);
    public bool GetSoftLineBreaks();
}
public class iTextSharp.text.rtf.text.RtfNewPage : RtfElement {
    public static Byte[] NEW_PAGE;
    public RtfNewPage(RtfDocument doc);
    private static RtfNewPage();
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.text.RtfParagraph : RtfPhrase {
    public static Byte[] PARAGRAPH;
    protected RtfParagraphStyle paragraphStyle;
    public RtfParagraph(RtfDocument doc, Paragraph paragraph);
    private static RtfParagraph();
    public void SetKeepTogetherWithNext(bool keepTogetherWithNext);
    public virtual void WriteContent(Stream result);
    public int GetIndentLeft();
    public void SetIndentLeft(int indentLeft);
    public int GetIndentRight();
    public void SetIndentRight(int indentRight);
}
public class iTextSharp.text.rtf.text.RtfPhrase : RtfElement {
    public static Byte[] PARAGRAPH_DEFAULTS;
    public static Byte[] PLAIN;
    public static Byte[] IN_TABLE;
    public static Byte[] LINE_SPACING;
    protected ArrayList chunks;
    private int lineLeading;
    protected internal RtfPhrase(RtfDocument doc);
    public RtfPhrase(RtfDocument doc, Phrase phrase);
    private static RtfPhrase();
    public virtual void WriteContent(Stream result);
    public virtual void SetInTable(bool inTable);
    public virtual void SetInHeader(bool inHeader);
    public virtual void SetRtfDocument(RtfDocument doc);
}
public class iTextSharp.text.rtf.text.RtfSection : RtfElement {
    protected RtfParagraph title;
    protected ArrayList items;
    public RtfSection(RtfDocument doc, Section section);
    public virtual void WriteContent(Stream result);
    public virtual void SetInTable(bool inTable);
    public virtual void SetInHeader(bool inHeader);
    private void UpdateIndentation(float indentLeft, float indentRight, float indentContent);
}
public class iTextSharp.text.rtf.text.RtfTab : RtfAddableElement {
    public static int TAB_LEFT_ALIGN;
    public static int TAB_CENTER_ALIGN;
    public static int TAB_RIGHT_ALIGN;
    public static int TAB_DECIMAL_ALIGN;
    private int position;
    private int type;
    public RtfTab(float position, int type);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.rtf.text.RtfTabGroup : RtfAddableElement {
    private ArrayList tabs;
    public RtfTabGroup(ArrayList tabs);
    public void Add(RtfTab tab);
    public virtual void WriteContent(Stream result);
}
public class iTextSharp.text.Section : ArrayList {
    public static int NUMBERSTYLE_DOTTED;
    public static int NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT;
    protected Paragraph title;
    protected int numberDepth;
    protected int numberStyle;
    protected float indentationLeft;
    protected float indentationRight;
    protected float indentation;
    protected int subsections;
    protected internal ArrayList numbers;
    protected bool complete;
    protected bool addedCompletely;
    protected bool notAddedYet;
    protected bool bookmarkOpen;
    protected bool triggerNewPage;
    protected string bookmarkTitle;
    public int Type { get; }
    public ArrayList Chunks { get; }
    public Paragraph Title { get; public set; }
    public int NumberStyle { get; public set; }
    public int NumberDepth { get; public set; }
    public float IndentationLeft { get; public set; }
    public float IndentationRight { get; public set; }
    public float Indentation { get; public set; }
    public int Depth { get; }
    public bool BookmarkOpen { get; public set; }
    unknown string BookmarkTitle {public set; }
    public bool TriggerNewPage { get; public set; }
    public bool NotAddedYet { get; public set; }
    protected bool AddedCompletely { get; protected set; }
    public bool ElementComplete { get; public set; }
    protected internal Section(Paragraph title, int numberDepth);
    private void SetNumbers(int number, ArrayList numbers);
    public sealed virtual bool Process(IElementListener listener);
    public virtual int get_Type();
    public sealed virtual ArrayList get_Chunks();
    public sealed virtual bool IsContent();
    public virtual bool IsNestable();
    public void Add(int index, object o);
    public sealed virtual bool Add(object o);
    public bool AddAll(ICollection collection);
    public virtual Section AddSection(float indentation, Paragraph title, int numberDepth);
    public virtual Section AddSection(float indentation, Paragraph title);
    public virtual Section AddSection(Paragraph title, int numberDepth);
    public MarkedSection AddMarkedSection();
    public virtual Section AddSection(Paragraph title);
    public virtual Section AddSection(float indentation, string title, int numberDepth);
    public virtual Section AddSection(string title, int numberDepth);
    public virtual Section AddSection(float indentation, string title);
    public virtual Section AddSection(string title);
    public void Set(Properties attributes);
    public Paragraph get_Title();
    public void set_Title(Paragraph value);
    public void set_NumberStyle(int value);
    public int get_NumberStyle();
    public static Paragraph ConstructTitle(Paragraph title, ArrayList numbers, int numberDepth, int numberStyle);
    public bool IsChapter();
    public bool IsSection();
    public int get_NumberDepth();
    public void set_NumberDepth(int value);
    public float get_IndentationLeft();
    public void set_IndentationLeft(float value);
    public float get_IndentationRight();
    public void set_IndentationRight(float value);
    public float get_Indentation();
    public void set_Indentation(float value);
    public int get_Depth();
    public static bool IsTitle(string tag);
    public static bool IsTag(string tag);
    public bool get_BookmarkOpen();
    public void set_BookmarkOpen(bool value);
    public Paragraph GetBookmarkTitle();
    public void set_BookmarkTitle(string value);
    public virtual string ToString();
    public virtual bool get_TriggerNewPage();
    public virtual void set_TriggerNewPage(bool value);
    public void SetChapterNumber(int number);
    public bool get_NotAddedYet();
    public void set_NotAddedYet(bool value);
    protected bool get_AddedCompletely();
    protected void set_AddedCompletely(bool value);
    public sealed virtual void FlushContent();
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
    public void NewPage();
}
public class iTextSharp.text.SimpleCell : Rectangle {
    public static bool ROW;
    public static bool CELL;
    private ArrayList content;
    private float width;
    private float widthpercentage;
    private float spacing_left;
    private float spacing_right;
    private float spacing_top;
    private float spacing_bottom;
    private float padding_left;
    private float padding_right;
    private float padding_top;
    private float padding_bottom;
    private int colspan;
    private int horizontalAlignment;
    private int verticalAlignment;
    private bool cellgroup;
    protected bool useAscender;
    protected bool useDescender;
    protected bool useBorderPadding;
    unknown float Padding {public set; }
    public int Colspan { get; public set; }
    public float Padding_bottom { get; public set; }
    public float Padding_left { get; public set; }
    public float Padding_right { get; public set; }
    public float Padding_top { get; public set; }
    unknown float Spacing {public set; }
    public float Spacing_top { get; public set; }
    public float Spacing_bottom { get; public set; }
    public float Spacing_left { get; public set; }
    public float Spacing_right { get; public set; }
    public bool Cellgroup { get; public set; }
    public int HorizontalAlignment { get; public set; }
    public int VerticalAlignment { get; public set; }
    public float Width { get; public set; }
    public float Widthpercentage { get; public set; }
    public bool UseAscender { get; public set; }
    public bool UseDescender { get; public set; }
    public bool UseBorderPadding { get; public set; }
    internal ArrayList Content { get; }
    public int Type { get; }
    public SimpleCell(bool row);
    public void AddElement(IElement element);
    public Cell CreateCell(SimpleCell rowAttributes);
    public PdfPCell CreatePdfPCell(SimpleCell rowAttributes);
    public sealed virtual void CellLayout(PdfPCell cell, Rectangle position, PdfContentByte[] canvases);
    public void set_Padding(float value);
    public int get_Colspan();
    public void set_Colspan(int value);
    public float get_Padding_bottom();
    public void set_Padding_bottom(float value);
    public float get_Padding_left();
    public void set_Padding_left(float value);
    public float get_Padding_right();
    public void set_Padding_right(float value);
    public float get_Padding_top();
    public void set_Padding_top(float value);
    public void set_Spacing(float value);
    public float get_Spacing_top();
    public void set_Spacing_top(float value);
    public float get_Spacing_bottom();
    public void set_Spacing_bottom(float value);
    public float get_Spacing_left();
    public void set_Spacing_left(float value);
    public float get_Spacing_right();
    public void set_Spacing_right(float value);
    public bool get_Cellgroup();
    public void set_Cellgroup(bool value);
    public int get_HorizontalAlignment();
    public void set_HorizontalAlignment(int value);
    public int get_VerticalAlignment();
    public void set_VerticalAlignment(int value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Widthpercentage();
    public void set_Widthpercentage(float value);
    public bool get_UseAscender();
    public void set_UseAscender(bool value);
    public bool get_UseDescender();
    public void set_UseDescender(bool value);
    public bool get_UseBorderPadding();
    public void set_UseBorderPadding(bool value);
    internal ArrayList get_Content();
    public sealed virtual bool Add(object o);
    public virtual int get_Type();
}
public class iTextSharp.text.SimpleTable : Rectangle {
    private ArrayList content;
    private float width;
    private float widthpercentage;
    private float cellspacing;
    private float cellpadding;
    private int alignment;
    public float Cellpadding { get; public set; }
    public float Cellspacing { get; public set; }
    public int Alignment { get; public set; }
    public float Width { get; public set; }
    public float Widthpercentage { get; public set; }
    public int Type { get; }
    public void AddElement(SimpleCell element);
    public Table CreateTable();
    public PdfPTable CreatePdfPTable();
    public sealed virtual void TableLayout(PdfPTable table, Single[][] widths, Single[] heights, int headerRows, int rowStart, PdfContentByte[] canvases);
    public float get_Cellpadding();
    public void set_Cellpadding(float value);
    public float get_Cellspacing();
    public void set_Cellspacing(float value);
    public int get_Alignment();
    public void set_Alignment(int value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public float get_Widthpercentage();
    public void set_Widthpercentage(float value);
    public virtual int get_Type();
    public virtual bool IsNestable();
    public sealed virtual bool Add(object o);
}
public class iTextSharp.text.SpecialSymbol : object {
    public static int Index(string str);
    public static Chunk Get(char c, Font font);
    public static char GetCorrespondingSymbol(char c);
}
public class iTextSharp.text.Table : Rectangle {
    private int columns;
    private Point curPosition;
    private ArrayList rows;
    private Cell defaultCell;
    private int lastHeaderRow;
    private int alignment;
    private float cellpadding;
    private float cellspacing;
    private float width;
    private bool locked;
    private Single[] widths;
    private bool mTableInserted;
    protected internal bool autoFillEmptyCells;
    private bool tableFitsPage;
    private bool cellsFitPage;
    private float offset;
    protected bool convert2pdfptable;
    protected bool notAddedYet;
    protected bool complete;
    public Cell DefaultLayout { get; public set; }
    public Cell DefaultCell { get; public set; }
    unknown bool AutoFillEmptyCells {public set; }
    public bool TableFitsPage { get; public set; }
    public bool CellsFitPage { get; public set; }
    public float Offset { get; public set; }
    public int Type { get; }
    unknown int DefaultCellBorder {public set; }
    unknown float DefaultCellBorderWidth {public set; }
    unknown Color DefaultCellBorderColor {public set; }
    unknown Color DefaultCellBackgroundColor {public set; }
    unknown float DefaultCellGrayFill {public set; }
    unknown int DefaultHorizontalAlignment {public set; }
    unknown int DefaultVerticalAlignment {public set; }
    unknown int DefaultRowspan {public set; }
    unknown int DefaultColspan {public set; }
    public int LastHeaderRow { get; public set; }
    unknown float Padding {public set; }
    unknown float Spacing {public set; }
    unknown Single[] Widths {public set; }
    public int Columns { get; }
    public int Size { get; }
    public Single[] ProportionalWidths { get; }
    public int Alignment { get; public set; }
    public float Cellpadding { get; public set; }
    public float Cellspacing { get; public set; }
    public float Width { get; public set; }
    public Dimension Dimension { get; }
    unknown Point CurrentLocationToNextValidPosition {private set; }
    public int NextRow { get; }
    public int NextColumn { get; }
    public float Bottom { get; public set; }
    public float Left { get; public set; }
    public float Right { get; public set; }
    public float Top { get; public set; }
    public bool Convert2pdfptable { get; public set; }
    public bool Locked { get; public set; }
    public bool NotAddedYet { get; public set; }
    public bool ElementComplete { get; public set; }
    public Table(int columns);
    public Table(int columns, int rows);
    public virtual bool Process(IElementListener listener);
    public void set_DefaultLayout(Cell value);
    public Cell get_DefaultLayout();
    public void set_DefaultCell(Cell value);
    public Cell get_DefaultCell();
    public void set_AutoFillEmptyCells(bool value);
    public void set_TableFitsPage(bool value);
    public bool get_TableFitsPage();
    public void set_CellsFitPage(bool value);
    public bool get_CellsFitPage();
    public float get_Offset();
    public void set_Offset(float value);
    public virtual int get_Type();
    public virtual bool IsNestable();
    public void AddCell(Cell aCell, int row, int column);
    public void AddCell(Cell aCell, object aLocation);
    public void AddCell(Cell cell);
    public void AddCell(Phrase content);
    public void AddCell(Phrase content, Point location);
    public void AddCell(string content);
    public void AddCell(string content, Point location);
    public void InsertTable(Table aTable);
    public void InsertTable(Table aTable, int row, int column);
    public void InsertTable(Table aTable, Point p);
    public void Complete();
    public void set_DefaultCellBorder(int value);
    public void set_DefaultCellBorderWidth(float value);
    public void set_DefaultCellBorderColor(Color value);
    public void set_DefaultCellBackgroundColor(Color value);
    public void set_DefaultCellGrayFill(float value);
    public void set_DefaultHorizontalAlignment(int value);
    public void set_DefaultVerticalAlignment(int value);
    public void set_DefaultRowspan(int value);
    public void set_DefaultColspan(int value);
    private void AssumeTableDefaults(Cell aCell);
    public void DeleteColumn(int column);
    public bool DeleteRow(int row);
    public void DeleteAllRows();
    public bool DeleteLastRow();
    public int EndHeaders();
    public void set_LastHeaderRow(int value);
    public int get_LastHeaderRow();
    public void SetAlignment(string alignment);
    public void set_Padding(float value);
    public void set_Spacing(float value);
    public void set_Widths(Single[] value);
    public void SetWidths(Int32[] widths);
    public int get_Columns();
    public int get_Size();
    public Single[] get_ProportionalWidths();
    public IEnumerator GetEnumerator();
    public int get_Alignment();
    public void set_Alignment(int value);
    public float get_Cellpadding();
    public void set_Cellpadding(float value);
    public float get_Cellspacing();
    public void set_Cellspacing(float value);
    public virtual float get_Width();
    public virtual void set_Width(float value);
    public Dimension get_Dimension();
    public object GetElement(int row, int column);
    private void MergeInsertedTables();
    private void FillEmptyMatrixCells();
    private bool IsValidLocation(Cell aCell, Point aLocation);
    private void PlaceCell(ArrayList someRows, Cell aCell, Point aPosition);
    public void AddColumns(int aColumns);
    public Single[] GetWidths(float left, float totalWidth);
    private void set_CurrentLocationToNextValidPosition(Point value);
    private void ErrorDimensions();
    public int get_NextRow();
    public int get_NextColumn();
    public virtual float get_Bottom();
    public virtual void set_Bottom(float value);
    public virtual float get_Left();
    public virtual void set_Left(float value);
    public virtual float get_Right();
    public virtual void set_Right(float value);
    public virtual float get_Top();
    public virtual void set_Top(float value);
    public virtual float GetBottom(float margin);
    public virtual float GetLeft(float margin);
    public virtual float GetRight(float margin);
    public virtual float GetTop(float margin);
    public PdfPTable CreatePdfPTable();
    public bool get_Convert2pdfptable();
    public void set_Convert2pdfptable(bool value);
    public bool get_Locked();
    public void set_Locked(bool value);
    public bool get_NotAddedYet();
    public void set_NotAddedYet(bool value);
    public sealed virtual void FlushContent();
    public sealed virtual bool get_ElementComplete();
    public sealed virtual void set_ElementComplete(bool value);
}
public class iTextSharp.text.Utilities : object {
    private static Byte[] skipBuffer;
    private static Utilities();
    public static ICollection GetKeySet(Properties table);
    public static Object[][] AddToArray(Object[][] original, Object[] item);
    public static bool CheckTrueOrFalse(Properties attributes, string key);
    public static Uri ToURL(string filename);
    public static string UnEscapeURL(string src);
    public static void Skip(Stream istr, int size);
    public static float MillimetersToPoints(float value);
    public static float MillimetersToInches(float value);
    public static float PointsToMillimeters(float value);
    public static float PointsToInches(float value);
    public static float InchesToMillimeters(float value);
    public static float InchesToPoints(float value);
    public static bool IsSurrogateHigh(char c);
    public static bool IsSurrogateLow(char c);
    public static bool IsSurrogatePair(string text, int idx);
    public static bool IsSurrogatePair(Char[] text, int idx);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(Char[] text, int idx);
    public static int ConvertToUtf32(string text, int idx);
    public static string ConvertFromUtf32(int codePoint);
}
public class iTextSharp.text.xml.ITextHandler : ParserBase {
    protected IDocListener document;
    protected Stack stack;
    protected int chapters;
    protected Chunk currentChunk;
    protected bool ignore;
    protected bool controlOpenClose;
    private float topMargin;
    private float rightMargin;
    private float leftMargin;
    private float bottomMargin;
    protected Hashtable myTags;
    private BaseFont bf;
    public BaseFont DefaultFont { get; public set; }
    public ITextHandler(IDocListener document);
    public ITextHandler(IDocListener document, HtmlTagMap myTags);
    public ITextHandler(IDocListener document, HtmlTagMap myTags, BaseFont bf);
    public ITextHandler(IDocListener document, Hashtable myTags);
    public void SetControlOpenClose(bool controlOpenClose);
    public virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public void HandleStartingTags(string name, Properties attributes);
    protected internal void AddImage(Image img);
    public void IgnorableWhitespace(Char[] ch, int start, int length);
    public virtual void Characters(string content, int start, int length);
    public void set_DefaultFont(BaseFont value);
    public BaseFont get_DefaultFont();
    public virtual void EndElement(string uri, string lname, string name);
    public void HandleEndingTags(string name);
    private bool IsNewpage(string tag);
    private bool IsNewline(string tag);
    protected bool IsDocumentRoot(string tag);
}
public class iTextSharp.text.xml.ITextmyHandler : ITextHandler {
    public ITextmyHandler(IDocListener document, Hashtable myTags);
    public virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public virtual void EndElement(string uri, string lname, string name);
}
public abstract class iTextSharp.text.xml.ParserBase : object {
    public void Parse(XmlDocument xDoc);
    public void Parse(XmlTextReader reader);
    public void Parse(string url);
    public abstract virtual void StartElement(string uri, string lname, string name, Hashtable attrs);
    public abstract virtual void EndElement(string uri, string lname, string name);
    public abstract virtual void Characters(string content, int start, int length);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToSymbol : object {
    public static Hashtable map;
    private static EntitiesToSymbol();
    public static Chunk Get(string e, Font font);
    public static char GetCorrespondingSymbol(string name);
}
public class iTextSharp.text.xml.simpleparser.EntitiesToUnicode : object {
    public static Hashtable map;
    private static EntitiesToUnicode();
    public static char DecodeEntity(string name);
    public static string DecodeString(string s);
}
public class iTextSharp.text.xml.simpleparser.IanaEncodings : object {
    private static Hashtable map;
    private static IanaEncodings();
    public static int GetEncodingNumber(string name);
    public static Encoding GetEncodingEncoding(string name);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler {
    public abstract virtual void StartElement(string tag, Hashtable h);
    public abstract virtual void EndElement(string tag);
    public abstract virtual void StartDocument();
    public abstract virtual void EndDocument();
    public abstract virtual void Text(string str);
}
public interface iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment {
    public abstract virtual void Comment(string text);
}
public class iTextSharp.text.xml.simpleparser.SimpleXMLParser : object {
    private static int UNKNOWN;
    private static int TEXT;
    private static int TAG_ENCOUNTERED;
    private static int EXAMIN_TAG;
    private static int TAG_EXAMINED;
    private static int IN_CLOSETAG;
    private static int SINGLE_TAG;
    private static int CDATA;
    private static int COMMENT;
    private static int PI;
    private static int ENTITY;
    private static int QUOTE;
    private static int ATTRIBUTE_KEY;
    private static int ATTRIBUTE_EQUAL;
    private static int ATTRIBUTE_VALUE;
    internal Stack stack;
    internal int character;
    internal int previousCharacter;
    internal int lines;
    internal int columns;
    internal bool eol;
    internal bool nowhite;
    internal int state;
    internal bool html;
    internal StringBuilder text;
    internal StringBuilder entity;
    internal string tag;
    internal Hashtable attributes;
    internal ISimpleXMLDocHandler doc;
    internal ISimpleXMLDocHandlerComment comment;
    internal int nested;
    internal int quoteCharacter;
    internal string attributekey;
    internal string attributevalue;
    private SimpleXMLParser(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, bool html);
    private void Go(TextReader reader);
    private int RestoreState();
    private void SaveState(int s);
    private void Flush();
    private void InitTag();
    private void DoTag();
    private void ProcessTag(bool start);
    private void ThrowException(string s);
    public static void Parse(ISimpleXMLDocHandler doc, ISimpleXMLDocHandlerComment comment, TextReader r, bool html);
    public static void Parse(ISimpleXMLDocHandler doc, Stream inp);
    private static string GetDeclaredEncoding(string decl);
    public static void Parse(ISimpleXMLDocHandler doc, TextReader r);
    public static string EscapeXML(string s, bool onlyASCII);
    private static string GetEncodingName(Byte[] b4);
}
public class iTextSharp.text.xml.TagMap : Hashtable {
    public TagMap(string tagfile);
    public TagMap(XmlDocument xTagfile);
    protected void Init(XmlDocument xTagfile);
    protected void Init(string tagfile);
}
public class iTextSharp.text.xml.XmlParser : object {
    protected ITextHandler parser;
    public virtual void Go(IDocListener document, XmlDocument xDoc);
    public virtual void Go(IDocListener document, string file);
    public virtual void Go(IDocListener document, XmlTextReader reader);
    public virtual void Go(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public virtual void Go(IDocListener document, XmlTextReader reader, string tagmap);
    public virtual void Go(IDocListener document, string file, string tagmap);
    public virtual void Go(IDocListener document, string file, Hashtable tagmap);
    public virtual void Go(IDocListener document, XmlTextReader reader, Hashtable tagmap);
    public static void Parse(IDocListener document, XmlDocument xDoc);
    public static void Parse(IDocListener document, string file);
    public static void Parse(IDocListener document, XmlTextReader reader);
    public static void Parse(IDocListener document, XmlDocument xDoc, XmlDocument xTagmap);
    public static void Parse(IDocListener document, string file, string tagmap);
    public static void Parse(IDocListener document, string file, Hashtable tagmap);
    public static void Parse(IDocListener document, XmlTextReader reader, string tagmap);
    public static void Parse(IDocListener document, XmlTextReader reader, Hashtable tagmap);
}
public class iTextSharp.text.xml.XmlPeer : object {
    protected string tagname;
    protected string customTagname;
    protected Properties attributeAliases;
    protected Properties attributeValues;
    protected string defaultContent;
    public string Tag { get; }
    public string Alias { get; }
    unknown string Content {public set; }
    public Properties DefaultValues { get; }
    public XmlPeer(string name, string alias);
    public string get_Tag();
    public string get_Alias();
    public virtual Properties GetAttributes(Hashtable attrs);
    public virtual void AddAlias(string name, string alias);
    public void AddValue(string name, string value);
    public void set_Content(string value);
    public string GetName(string name);
    public Properties get_DefaultValues();
}
public class iTextSharp.text.xml.xmp.DublinCoreSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string CONTRIBUTOR;
    public static string COVERAGE;
    public static string CREATOR;
    public static string DATE;
    public static string DESCRIPTION;
    public static string FORMAT;
    public static string IDENTIFIER;
    public static string LANGUAGE;
    public static string PUBLISHER;
    public static string RELATION;
    public static string RIGHTS;
    public static string SOURCE;
    public static string SUBJECT;
    public static string TITLE;
    public static string TYPE;
    public void AddTitle(string title);
    public void AddDescription(string desc);
    public void AddSubject(string subject);
    public void addSubject(String[] subject);
    public void AddAuthor(string author);
    public void AddAuthor(String[] author);
    public void AddPublisher(string publisher);
    public void AddPublisher(String[] publisher);
}
public class iTextSharp.text.xml.xmp.EncodingNoPreamble : Encoding {
    private Encoding encoding;
    private static Byte[] emptyPreamble;
    public string BodyName { get; }
    public int CodePage { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public EncodingNoPreamble(Encoding encoding);
    private static EncodingNoPreamble();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual Byte[] GetPreamble();
}
public class iTextSharp.text.xml.xmp.LangAlt : Properties {
    public static string DEFAULT;
    public LangAlt(string defaultValue);
    public void AddLanguage(string language, string value);
    protected internal void Process(StringBuilder buf, string lang);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.PdfA1Schema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string PART;
    public static string CONFORMANCE;
    public void AddPart(string part);
    public void AddConformance(string conformance);
}
public class iTextSharp.text.xml.xmp.PdfSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string KEYWORDS;
    public static string VERSION;
    public static string PRODUCER;
    public void AddKeywords(string keywords);
    public void AddProducer(string producer);
    public void AddVersion(string version);
}
public class iTextSharp.text.xml.xmp.XmpArray : ArrayList {
    public static string UNORDERED;
    public static string ORDERED;
    public static string ALTERNATIVE;
    protected string type;
    public XmpArray(string type);
    public virtual string ToString();
}
public class iTextSharp.text.xml.xmp.XmpBasicSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string ADVISORY;
    public static string BASEURL;
    public static string CREATEDATE;
    public static string CREATORTOOL;
    public static string IDENTIFIER;
    public static string METADATADATE;
    public static string MODIFYDATE;
    public static string NICKNAME;
    public static string THUMBNAILS;
    public void AddCreatorTool(string creator);
    public void AddCreateDate(string date);
    public void AddModDate(string date);
    public void AddMetaDataDate(string date);
    public void AddIdentifiers(String[] id);
    public void AddNickname(string name);
}
public class iTextSharp.text.xml.xmp.XmpMMSchema : XmpSchema {
    public static string DEFAULT_XPATH_ID;
    public static string DEFAULT_XPATH_URI;
    public static string DERIVEDFROM;
    public static string DOCUMENTID;
    public static string HISTORY;
    public static string MANAGEDFROM;
    public static string MANAGER;
    public static string MANAGETO;
    public static string MANAGEUI;
    public static string MANAGERVARIANT;
    public static string RENDITIONCLASS;
    public static string RENDITIONPARAMS;
    public static string VERSIONID;
    public static string VERSIONS;
}
public class iTextSharp.text.xml.xmp.XmpReader : object {
    private XmlDocument domDocument;
    public XmpReader(Byte[] bytes);
    public bool Replace(string namespaceURI, string localName, string value);
    public bool Add(string parent, string namespaceURI, string localName, string value);
    public bool SetNodeText(XmlDocument domDocument, XmlNode n, string value);
    public Byte[] SerializeDoc();
}
[DefaultMemberAttribute("Item")]
public abstract class iTextSharp.text.xml.xmp.XmpSchema : Properties {
    protected string xmlns;
    public string Xmlns { get; }
    unknown string Item {public set; }
    public XmpSchema(string xmlns);
    public virtual string ToString();
    protected void Process(StringBuilder buf, object p);
    public string get_Xmlns();
    public void AddProperty(string key, string value);
    public virtual void set_Item(string key, string value);
    public void SetProperty(string key, XmpArray value);
    public void SetProperty(string key, LangAlt value);
    public static string Escape(string content);
}
public class iTextSharp.text.xml.xmp.XmpWriter : object {
    public static string UTF8;
    public static string UTF16;
    public static string UTF16BE;
    public static string UTF16LE;
    public static string EXTRASPACE;
    public static string XPACKET_PI_BEGIN;
    public static string XPACKET_PI_END_W;
    public static string XPACKET_PI_END_R;
    protected int extraSpace;
    protected StreamWriter writer;
    protected string about;
    protected char end;
    unknown string About {public set; }
    public XmpWriter(Stream os, string utfEncoding, int extraSpace);
    public XmpWriter(Stream os);
    public XmpWriter(Stream os, PdfDictionary info, int PdfXConformance);
    public XmpWriter(Stream os, Hashtable info);
    public void SetReadOnly();
    public void set_About(string value);
    public void AddRdfDescription(string xmlns, string content);
    public void AddRdfDescription(XmpSchema s);
    public void Close();
}
public class iTextSharp.text.ZapfDingbatsList : List {
    protected int zn;
    public int CharNumber { get; public set; }
    public ZapfDingbatsList(int zn);
    public ZapfDingbatsList(int zn, int symbolIndent);
    public void set_CharNumber(int value);
    public int get_CharNumber();
    public virtual bool Add(object o);
}
public class iTextSharp.text.ZapfDingbatsNumberList : List {
    protected int type;
    public int NumberType { get; public set; }
    public ZapfDingbatsNumberList(int type);
    public ZapfDingbatsNumberList(int type, int symbolIndent);
    public int get_NumberType();
    public void set_NumberType(int value);
    public virtual bool Add(object o);
}
public class Org.BouncyCastle.Apache.Bzip2.BZip2Constants : object {
    public static int baseBlockSize;
    public static int MAX_ALPHA_SIZE;
    public static int MAX_CODE_LEN;
    public static int RUNA;
    public static int RUNB;
    public static int N_GROUPS;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MAX_SELECTORS;
    public static int NUM_OVERSHOOT_BYTES;
    public static Int32[] rNums;
    private static BZip2Constants();
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2InputStream : Stream {
    private static int START_BLOCK_STATE;
    private static int RAND_PART_A_STATE;
    private static int RAND_PART_B_STATE;
    private static int RAND_PART_C_STATE;
    private static int NO_RAND_PART_A_STATE;
    private static int NO_RAND_PART_B_STATE;
    private static int NO_RAND_PART_C_STATE;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Int32[] tt;
    private Char[] ll8;
    private Int32[] unzftab;
    private Int32[][] limit;
    private Int32[][] basev;
    private Int32[][] perm;
    private Int32[] minLens;
    private Stream bsStream;
    private bool streamEnd;
    private int currentChar;
    private int currentState;
    private int storedBlockCRC;
    private int storedCombinedCRC;
    private int computedBlockCRC;
    private int computedCombinedCRC;
    private int i2;
    private int count;
    private int chPrev;
    private int ch2;
    private int i;
    private int tPos;
    private int rNToGo;
    private int rTPos;
    private int j2;
    private char z;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2InputStream(Stream zStream);
    private static void Cadvise();
    private static void BadBGLengths();
    private static void BitStreamEOF();
    private static void CompressedStreamEOF();
    private void MakeMaps();
    internal static Int32[][] InitIntArray(int n1, int n2);
    internal static Char[][] InitCharArray(int n1, int n2);
    public virtual int ReadByte();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void Complete();
    private static void BlockOverrun();
    private static void BadBlockHeader();
    private static void CrcError();
    private void BsFinishedWithStream();
    private void BsSetStream(Stream f);
    private int BsR(int n);
    private char BsGetUChar();
    private int BsGetint();
    private int BsGetIntVS(int numBits);
    private int BsGetInt32();
    private void HbCreateDecodeTables(Int32[] limit, Int32[] basev, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
    private void RecvDecodingTables();
    private void GetAndMoveToFrontDecode();
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
    private void SetDecompressStructureSizes(int newSize100k);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream : Stream {
    protected static int SETMASK;
    protected static int CLEARMASK;
    protected static int GREATER_ICOST;
    protected static int LESSER_ICOST;
    protected static int SMALL_THRESH;
    protected static int DEPTH_THRESH;
    protected static int QSORT_STACK_SIZE;
    private bool finished;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bytesOut;
    private int bsBuff;
    private int bsLive;
    private CRC mCrc;
    private Boolean[] inUse;
    private int nInUse;
    private Char[] seqToUnseq;
    private Char[] unseqToSeq;
    private Char[] selector;
    private Char[] selectorMtf;
    private Char[] block;
    private Int32[] quadrant;
    private Int32[] zptr;
    private Int16[] szptr;
    private Int32[] ftab;
    private int nMTF;
    private Int32[] mtfFreq;
    private int workFactor;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private int nBlocksRandomised;
    private int currentChar;
    private int runLength;
    private bool closed;
    private int blockCRC;
    private int combinedCRC;
    private int allowableBlockSize;
    private Stream bsStream;
    private Int32[] incs;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CBZip2OutputStream(Stream inStream);
    public CBZip2OutputStream(Stream inStream, int inBlockSize);
    private static void Panic();
    private void MakeMaps();
    protected static void HbMakeCodeLengths(Char[] len, Int32[] freq, int alphaSize, int maxLen);
    public virtual void WriteByte(byte bv);
    private void WriteRun();
    protected void Finalize();
    public virtual void Close();
    public void Finish();
    public virtual void Flush();
    private void Initialize();
    private void InitBlock();
    private void EndBlock();
    private void EndCompression();
    private void HbAssignCodes(Int32[] code, Char[] length, int minLen, int maxLen, int alphaSize);
    private void BsSetStream(Stream f);
    private void BsFinishedWithStream();
    private void BsW(int n, int v);
    private void BsPutUChar(int c);
    private void BsPutint(int u);
    private void BsPutIntVS(int numBits, int c);
    private void SendMTFValues();
    private void MoveToFrontCodeAndSend();
    private void SimpleSort(int lo, int hi, int d);
    private void Vswap(int p1, int p2, int n);
    private char Med3(char a, char b, char c);
    private void QSort3(int loSt, int hiSt, int dSt);
    private void MainSort();
    private void RandomiseBlock();
    private void DoReversibleTransformation();
    private bool FullGtU(int i1, int i2);
    private void AllocateCompressStructures();
    private void GenerateMTFValues();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class Org.BouncyCastle.Apache.Bzip2.CRC : object {
    public static Int32[] crc32Table;
    internal int globalCrc;
    private static CRC();
    internal void InitialiseCRC();
    internal int GetFinalCRC();
    internal int GetGlobalCRC();
    internal void SetGlobalCRC(int newCrc);
    internal void UpdateCRC(int inCh);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Encodable : object {
    public static string Der;
    public static string Ber;
    public Byte[] GetEncoded();
    public Byte[] GetEncoded(string encoding);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Asn1EncodableVector : object {
    private ArrayList v;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1EncodableVector(Asn1Encodable[] v);
    public static Asn1EncodableVector FromEnumerable(IEnumerable e);
    public void Add(Asn1Encodable[] objs);
    public Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable Get(int index);
    public int get_Size();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Generator : object {
    private Stream _out;
    protected Stream Out { get; }
    protected Asn1Generator(Stream outStream);
    protected Stream get_Out();
    public abstract virtual void AddObject(Asn1Encodable obj);
    public abstract virtual Stream GetRawOutputStream();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    private int limit;
    public Asn1InputStream(Stream inputStream);
    public Asn1InputStream(Stream inputStream, int limit);
    public Asn1InputStream(Byte[] input);
    internal Asn1EncodableVector BuildEncodableVector();
    internal virtual Asn1EncodableVector BuildDerEncodableVector(DefiniteLengthInputStream dIn);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
    public Asn1Object ReadObject();
    internal static int ReadTagNumber(Stream s, int tag);
    internal static int ReadLength(Stream s, int limit);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, Byte[] bytes);
}
public abstract class Org.BouncyCastle.Asn1.Asn1Null : Asn1Object {
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
    internal abstract virtual void Encode(DerOutputStream derOut);
    protected abstract virtual bool Asn1Equals(Asn1Object asn1Object);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(Asn1Object obj);
    internal int CallAsn1GetHashCode();
}
[ObsoleteAttribute("Will be removed")]
public class Org.BouncyCastle.Asn1.Asn1ObjectParser : object {
}
public abstract class Org.BouncyCastle.Asn1.Asn1OctetString : Asn1Object {
    internal Byte[] str;
    public Asn1OctetStringParser Parser { get; }
    internal Asn1OctetString(Byte[] str);
    internal Asn1OctetString(Asn1Encodable obj);
    public static Asn1OctetString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Asn1OctetString GetInstance(object obj);
    public sealed virtual Stream GetOctetStream();
    public Asn1OctetStringParser get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1OctetStringParser {
    public abstract virtual Stream GetOctetStream();
}
public class Org.BouncyCastle.Asn1.Asn1OutputStream : DerOutputStream {
    public Asn1OutputStream(Stream os);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    private ArrayList seq;
    public Asn1SequenceParser Parser { get; }
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    protected internal Asn1Sequence(int capacity);
    public static Asn1Sequence GetInstance(object obj);
    public static Asn1Sequence GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1SequenceParser get_Parser();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected internal void AddObject(Asn1Encodable obj);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SequenceParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Asn1.Asn1Set : Asn1Object {
    private ArrayList _set;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1SetParser Parser { get; }
    protected internal Asn1Set(int capacity);
    public static Asn1Set GetInstance(object obj);
    public static Asn1Set GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    public Asn1SetParser get_Parser();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    private bool LessThanOrEqual(Byte[] a, Byte[] b);
    protected internal void Sort();
    protected internal void AddObject(Asn1Encodable obj);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1SetParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public class Org.BouncyCastle.Asn1.Asn1StreamParser : object {
    private Stream _in;
    private int _limit;
    public Asn1StreamParser(Stream inStream);
    public Asn1StreamParser(Stream inStream, int limit);
    public Asn1StreamParser(Byte[] encoding);
    public virtual IAsn1Convertible ReadObject();
    private void Set00Check(bool enabled);
    internal Asn1EncodableVector ReadVector();
}
public abstract class Org.BouncyCastle.Asn1.Asn1TaggedObject : Asn1Object {
    internal int tagNo;
    internal bool explicitly;
    internal Asn1Encodable obj;
    public int TagNo { get; }
    protected Asn1TaggedObject(int tagNo, Asn1Encodable obj);
    protected Asn1TaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public static Asn1TaggedObject GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Asn1TaggedObject GetInstance(object obj);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public sealed virtual int get_TagNo();
    public bool IsExplicit();
    public bool IsEmpty();
    public Asn1Object GetObject();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    public virtual string ToString();
}
public interface Org.BouncyCastle.Asn1.Asn1TaggedObjectParser {
    public int TagNo { get; }
    public abstract virtual int get_TagNo();
    public abstract virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int External;
    public static int Enumerated;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int T61String;
    public static int VideotexString;
    public static int IA5String;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int BmpString;
    public static int Utf8String;
    public static int Constructed;
    public static int Application;
    public static int Tagged;
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecific : DerApplicationSpecific {
    public BerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
}
public class Org.BouncyCastle.Asn1.BerApplicationSpecificParser : object {
    private int tag;
    private Asn1StreamParser parser;
    internal BerApplicationSpecificParser(int tag, Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected BerGenerator(Stream outStream);
    public BerGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
    private void WriteHdr(int tag);
    protected void WriteBerHeader(int tag);
    protected void WriteBerBody(Stream contentStream);
    protected void WriteBerEnd();
}
public class Org.BouncyCastle.Asn1.BerNull : DerNull {
    public static BerNull Instance;
    private BerNull(int dummy);
    private static BerNull();
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerOctetString : DerOctetString {
    private static int MaxLength;
    private IEnumerable octs;
    public BerOctetString(Byte[] str);
    public BerOctetString(IEnumerable octets);
    public BerOctetString(Asn1Object obj);
    public BerOctetString(Asn1Encodable obj);
    private static Byte[] ToBytes(IEnumerable octs);
    public virtual Byte[] GetOctets();
    public sealed virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    private ArrayList GenerateOcts();
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerOctetStringGenerator : BerGenerator {
    public BerOctetStringGenerator(Stream outStream);
    public BerOctetStringGenerator(Stream outStream, int tagNo, bool isExplicit);
    public Stream GetOctetOutputStream();
    public Stream GetOctetOutputStream(int bufSize);
    public Stream GetOctetOutputStream(Byte[] buf);
}
public class Org.BouncyCastle.Asn1.BerOctetStringParser : object {
    private Asn1StreamParser _parser;
    internal BerOctetStringParser(Asn1StreamParser parser);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerOutputStream : DerOutputStream {
    public BerOutputStream(Stream os);
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
}
public class Org.BouncyCastle.Asn1.BerSequence : DerSequence {
    public static BerSequence Empty;
    public BerSequence(Asn1Encodable obj);
    public BerSequence(Asn1Encodable[] v);
    public BerSequence(Asn1EncodableVector v);
    private static BerSequence();
    public static BerSequence FromVector(Asn1EncodableVector v);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerSequenceGenerator : BerGenerator {
    public BerSequenceGenerator(Stream outStream);
    public BerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal BerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerSet : DerSet {
    public static BerSet Empty;
    public BerSet(Asn1Encodable obj);
    public BerSet(Asn1EncodableVector v);
    internal BerSet(Asn1EncodableVector v, bool needsSorting);
    private static BerSet();
    public static BerSet FromVector(Asn1EncodableVector v);
    internal static BerSet FromVector(Asn1EncodableVector v, bool needsSorting);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerSetGenerator : BerGenerator {
    public BerSetGenerator(Stream outStream);
    public BerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
}
public class Org.BouncyCastle.Asn1.BerSetParser : object {
    private Asn1StreamParser _parser;
    internal BerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.BerTaggedObject : DerTaggedObject {
    public BerTaggedObject(int tagNo, Asn1Encodable obj);
    public BerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public BerTaggedObject(int tagNo);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.BerTaggedObjectParser : object {
    private int _baseTag;
    private int _tagNumber;
    private Stream _contentStream;
    private bool _indefiniteLength;
    public bool IsConstructed { get; }
    public int TagNo { get; }
    internal BerTaggedObjectParser(int baseTag, int tagNumber, Stream contentStream);
    public bool get_IsConstructed();
    public sealed virtual int get_TagNo();
    public sealed virtual IAsn1Convertible GetObjectParser(int tag, bool isExplicit);
    private Asn1EncodableVector rLoadVector(Stream inStream);
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo : DerBitString {
    public static int BadAlg;
    public static int BadMessageCheck;
    public static int BadRequest;
    public static int BadTime;
    public static int BadCertId;
    public static int BadDataFormat;
    public static int WrongAuthority;
    public static int IncorrectData;
    public static int MissingTimeStamp;
    public static int BadPop;
    public static int TimeNotAvailable;
    public static int UnacceptedPolicy;
    public static int UnacceptedExtension;
    public static int AddInfoNotAvailable;
    public static int SystemFailure;
    public PkiFailureInfo(int info);
    public PkiFailureInfo(DerBitString info);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cmp.PkiFreeText : Asn1Encodable {
    internal Asn1Sequence strings;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public DerUtf8String Item { get; }
    public PkiFreeText(Asn1Sequence seq);
    public PkiFreeText(DerUtf8String p);
    public static PkiFreeText GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiFreeText GetInstance(object obj);
    public int get_Size();
    public int get_Count();
    public DerUtf8String get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public DerUtf8String GetStringAt(int index);
    public virtual Asn1Object ToAsn1Object();
}
public enum Org.BouncyCastle.Asn1.Cmp.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
}
public class Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo : Asn1Encodable {
    private DerInteger status;
    private PkiFreeText statusString;
    private DerBitString failInfo;
    public BigInteger Status { get; }
    public PkiFreeText StatusString { get; }
    public DerBitString FailInfo { get; }
    public PkiStatusInfo(Asn1Sequence seq);
    public PkiStatusInfo(int status);
    public PkiStatusInfo(int status, PkiFreeText statusString);
    public PkiStatusInfo(int status, PkiFreeText statusString, PkiFailureInfo failInfo);
    public static PkiStatusInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static PkiStatusInfo GetInstance(object obj);
    public BigInteger get_Status();
    public PkiFreeText get_StatusString();
    public DerBitString get_FailInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Attribute : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    public Attribute(Asn1Sequence seq);
    public Attribute(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static Attribute GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Asn1.Cms.AttributeTable : object {
    private Hashtable attributes;
    public Attribute Item { get; }
    public AttributeTable(Hashtable attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    private void AddAttribute(Attribute a);
    public Attribute get_Item(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[oid]' syntax instead")]
public Attribute Get(DerObjectIdentifier oid);
    public Asn1EncodableVector GetAll(DerObjectIdentifier oid);
    public Hashtable ToHashtable();
    public Asn1EncodableVector ToAsn1EncodableVector();
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private AlgorithmIdentifier macAlgorithm;
    private AlgorithmIdentifier digestAlgorithm;
    private ContentInfo encapsulatedContentInfo;
    private Asn1Set authAttrs;
    private Asn1OctetString mac;
    private Asn1Set unauthAttrs;
    public DerInteger Version { get; }
    public AuthenticatedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, AlgorithmIdentifier macAlgorithm, AlgorithmIdentifier digestAlgorithm, ContentInfo encapsulatedContent, Asn1Set authAttrs, Asn1OctetString mac, Asn1Set unauthAttrs);
    private AuthenticatedData(Asn1Sequence seq);
    public static AuthenticatedData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AuthenticatedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1Set GetRecipientInfos();
    public AlgorithmIdentifier GetMacAlgorithm();
    public ContentInfo GetEncapsulatedContentInfo();
    public Asn1Set GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1Set GetUnauthAttrs();
    public virtual Asn1Object ToAsn1Object();
    public static int CalculateVersion(OriginatorInfo origInfo);
}
public class Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser : object {
    private Asn1SequenceParser seq;
    private DerInteger version;
    private IAsn1Convertible nextObject;
    private bool originatorInfoCalled;
    public DerInteger Version { get; }
    public AuthenticatedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public AlgorithmIdentifier GetMacAlgorithm();
    public ContentInfoParser GetEnapsulatedContentInfo();
    public Asn1SetParser GetAuthAttrs();
    public Asn1OctetString GetMac();
    public Asn1SetParser GetUnauthAttrs();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsAttributes : object {
    public static DerObjectIdentifier ContentType;
    public static DerObjectIdentifier MessageDigest;
    public static DerObjectIdentifier SigningTime;
    public static DerObjectIdentifier CounterSignature;
    private static CmsAttributes();
}
public abstract class Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers : object {
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier CompressedData;
    private static CmsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedData : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier compressionAlgorithm;
    private ContentInfo encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public ContentInfo EncapContentInfo { get; }
    public CompressedData(AlgorithmIdentifier compressionAlgorithm, ContentInfo encapContentInfo);
    public CompressedData(Asn1Sequence seq);
    public static CompressedData GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static CompressedData GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfo get_EncapContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.CompressedDataParser : object {
    private DerInteger _version;
    private AlgorithmIdentifier _compressionAlgorithm;
    private ContentInfoParser _encapContentInfo;
    public DerInteger Version { get; }
    public AlgorithmIdentifier CompressionAlgorithmIdentifier { get; }
    public CompressedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_CompressionAlgorithmIdentifier();
    public ContentInfoParser GetEncapContentInfo();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.ContentInfoParser : object {
    private DerObjectIdentifier contentType;
    private Asn1TaggedObjectParser content;
    public DerObjectIdentifier ContentType { get; }
    public ContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public IAsn1Convertible GetContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private AlgorithmIdentifier contentEncryptionAlgorithm;
    private Asn1OctetString encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedContent { get; }
    public EncryptedContentInfo(DerObjectIdentifier contentType, AlgorithmIdentifier contentEncryptionAlgorithm, Asn1OctetString encryptedContent);
    public EncryptedContentInfo(Asn1Sequence seq);
    public static EncryptedContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedContent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser : object {
    private DerObjectIdentifier _contentType;
    private AlgorithmIdentifier _contentEncryptionAlgorithm;
    private Asn1TaggedObjectParser _encryptedContent;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
    public EncryptedContentInfoParser(Asn1SequenceParser seq);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    public IAsn1Convertible GetEncryptedContent(int tag);
}
public class Org.BouncyCastle.Asn1.Cms.EncryptedData : Asn1Encodable {
    private DerInteger version;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EncryptedData(EncryptedContentInfo encInfo);
    public EncryptedData(EncryptedContentInfo encInfo, Asn1Set unprotectedAttrs);
    private EncryptedData(Asn1Sequence seq);
    public static EncryptedData GetInstance(object obj);
    public virtual DerInteger get_Version();
    public virtual EncryptedContentInfo get_EncryptedContentInfo();
    public virtual Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedData : Asn1Encodable {
    private DerInteger version;
    private OriginatorInfo originatorInfo;
    private Asn1Set recipientInfos;
    private EncryptedContentInfo encryptedContentInfo;
    private Asn1Set unprotectedAttrs;
    public DerInteger Version { get; }
    public OriginatorInfo OriginatorInfo { get; }
    public Asn1Set RecipientInfos { get; }
    public EncryptedContentInfo EncryptedContentInfo { get; }
    public Asn1Set UnprotectedAttrs { get; }
    public EnvelopedData(OriginatorInfo originatorInfo, Asn1Set recipientInfos, EncryptedContentInfo encryptedContentInfo, Asn1Set unprotectedAttrs);
    public EnvelopedData(Asn1Sequence seq);
    public static EnvelopedData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static EnvelopedData GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorInfo get_OriginatorInfo();
    public Asn1Set get_RecipientInfos();
    public EncryptedContentInfo get_EncryptedContentInfo();
    public Asn1Set get_UnprotectedAttrs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private IAsn1Convertible _nextObject;
    private bool _originatorInfoCalled;
    public DerInteger Version { get; }
    public EnvelopedDataParser(Asn1SequenceParser seq);
    public DerInteger get_Version();
    public OriginatorInfo GetOriginatorInfo();
    public Asn1SetParser GetRecipientInfos();
    public EncryptedContentInfoParser GetEncryptedContentInfo();
    public Asn1SetParser GetUnprotectedAttrs();
}
public class Org.BouncyCastle.Asn1.Cms.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger serialNumber;
    public X509Name Name { get; }
    public DerInteger SerialNumber { get; }
    public IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger serialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger serialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekIdentifier : Asn1Encodable {
    private Asn1OctetString keyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString KeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute Other { get; }
    public KekIdentifier(Byte[] keyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public KekIdentifier(Asn1Sequence seq);
    public static KekIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekIdentifier GetInstance(object obj);
    public Asn1OctetString get_KeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_Other();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KekRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private KekIdentifier kekID;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public KekIdentifier KekID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KekRecipientInfo(KekIdentifier kekID, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KekRecipientInfo(Asn1Sequence seq);
    public static KekRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KekRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public KekIdentifier get_KekID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier : Asn1Encodable {
    private static RecipientKeyIdentifier rKeyID;
    private IssuerAndSerialNumber issuerSerial;
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public RecipientKeyIdentifier RKeyID { get; }
    public KeyAgreeRecipientIdentifier(IssuerAndSerialNumber issuerSerial);
    private KeyAgreeRecipientIdentifier(Asn1Sequence seq);
    public static KeyAgreeRecipientIdentifier GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static KeyAgreeRecipientIdentifier GetInstance(object obj);
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public RecipientKeyIdentifier get_RKeyID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private OriginatorIdentifierOrKey originator;
    private Asn1OctetString ukm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1Sequence recipientEncryptedKeys;
    public DerInteger Version { get; }
    public OriginatorIdentifierOrKey Originator { get; }
    public Asn1OctetString UserKeyingMaterial { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1Sequence RecipientEncryptedKeys { get; }
    public KeyAgreeRecipientInfo(OriginatorIdentifierOrKey originator, Asn1OctetString ukm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1Sequence recipientEncryptedKeys);
    public KeyAgreeRecipientInfo(Asn1Sequence seq);
    public static KeyAgreeRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static KeyAgreeRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public OriginatorIdentifierOrKey get_Originator();
    public Asn1OctetString get_UserKeyingMaterial();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1Sequence get_RecipientEncryptedKeys();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private RecipientIdentifier rid;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public RecipientIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public KeyTransRecipientInfo(RecipientIdentifier rid, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public KeyTransRecipientInfo(Asn1Sequence seq);
    public static KeyTransRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public RecipientIdentifier get_RecipientIdentifier();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey : Asn1Encodable {
    private Asn1Encodable id;
    public Asn1Encodable ID { get; }
    public OriginatorPublicKey OriginatorKey { get; }
    public OriginatorIdentifierOrKey(IssuerAndSerialNumber id);
    public OriginatorIdentifierOrKey(Asn1OctetString id);
    public OriginatorIdentifierOrKey(OriginatorPublicKey id);
    public OriginatorIdentifierOrKey(Asn1Object id);
    public static OriginatorIdentifierOrKey GetInstance(Asn1TaggedObject o, bool explicitly);
    public static OriginatorIdentifierOrKey GetInstance(object o);
    public Asn1Encodable get_ID();
    public OriginatorPublicKey get_OriginatorKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorInfo : Asn1Encodable {
    private Asn1Set certs;
    private Asn1Set crls;
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public OriginatorInfo(Asn1Set certs, Asn1Set crls);
    public OriginatorInfo(Asn1Sequence seq);
    public static OriginatorInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorInfo GetInstance(object obj);
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey : Asn1Encodable {
    private AlgorithmIdentifier algorithm;
    private DerBitString publicKey;
    public AlgorithmIdentifier Algorithm { get; }
    public DerBitString PublicKey { get; }
    public OriginatorPublicKey(AlgorithmIdentifier algorithm, Byte[] publicKey);
    public OriginatorPublicKey(Asn1Sequence seq);
    public static OriginatorPublicKey GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OriginatorPublicKey GetInstance(object obj);
    public AlgorithmIdentifier get_Algorithm();
    public DerBitString get_PublicKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute : Asn1Encodable {
    private DerObjectIdentifier keyAttrId;
    private Asn1Encodable keyAttr;
    public DerObjectIdentifier KeyAttrId { get; }
    public Asn1Encodable KeyAttr { get; }
    public OtherKeyAttribute(Asn1Sequence seq);
    public OtherKeyAttribute(DerObjectIdentifier keyAttrId, Asn1Encodable keyAttr);
    public static OtherKeyAttribute GetInstance(object obj);
    public DerObjectIdentifier get_KeyAttrId();
    public Asn1Encodable get_KeyAttr();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo : Asn1Encodable {
    private DerObjectIdentifier oriType;
    private Asn1Encodable oriValue;
    public DerObjectIdentifier OriType { get; }
    public Asn1Encodable OriValue { get; }
    public OtherRecipientInfo(DerObjectIdentifier oriType, Asn1Encodable oriValue);
    public OtherRecipientInfo(Asn1Sequence seq);
    public static OtherRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OtherRecipientInfo GetInstance(object obj);
    public DerObjectIdentifier get_OriType();
    public Asn1Encodable get_OriValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo : Asn1Encodable {
    private DerInteger version;
    private AlgorithmIdentifier keyDerivationAlgorithm;
    private AlgorithmIdentifier keyEncryptionAlgorithm;
    private Asn1OctetString encryptedKey;
    public DerInteger Version { get; }
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Asn1OctetString EncryptedKey { get; }
    public PasswordRecipientInfo(AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(AlgorithmIdentifier keyDerivationAlgorithm, AlgorithmIdentifier keyEncryptionAlgorithm, Asn1OctetString encryptedKey);
    public PasswordRecipientInfo(Asn1Sequence seq);
    public static PasswordRecipientInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static PasswordRecipientInfo GetInstance(object obj);
    public DerInteger get_Version();
    public AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey : Asn1Encodable {
    private KeyAgreeRecipientIdentifier identifier;
    private Asn1OctetString encryptedKey;
    public KeyAgreeRecipientIdentifier Identifier { get; }
    public Asn1OctetString EncryptedKey { get; }
    private RecipientEncryptedKey(Asn1Sequence seq);
    public RecipientEncryptedKey(KeyAgreeRecipientIdentifier id, Asn1OctetString encryptedKey);
    public static RecipientEncryptedKey GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static RecipientEncryptedKey GetInstance(object obj);
    public KeyAgreeRecipientIdentifier get_Identifier();
    public Asn1OctetString get_EncryptedKey();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public RecipientIdentifier(IssuerAndSerialNumber id);
    public RecipientIdentifier(Asn1OctetString id);
    public RecipientIdentifier(Asn1Object id);
    public static RecipientIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientInfo : Asn1Encodable {
    internal Asn1Encodable info;
    public DerInteger Version { get; }
    public bool IsTagged { get; }
    public Asn1Encodable Info { get; }
    public RecipientInfo(KeyTransRecipientInfo info);
    public RecipientInfo(KeyAgreeRecipientInfo info);
    public RecipientInfo(KekRecipientInfo info);
    public RecipientInfo(PasswordRecipientInfo info);
    public RecipientInfo(OtherRecipientInfo info);
    public RecipientInfo(Asn1Object info);
    public static RecipientInfo GetInstance(object o);
    public DerInteger get_Version();
    public bool get_IsTagged();
    public Asn1Encodable get_Info();
    private KekRecipientInfo GetKekInfo(Asn1TaggedObject o);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier : Asn1Encodable {
    private Asn1OctetString subjectKeyIdentifier;
    private DerGeneralizedTime date;
    private OtherKeyAttribute other;
    public Asn1OctetString SubjectKeyIdentifier { get; }
    public DerGeneralizedTime Date { get; }
    public OtherKeyAttribute OtherKeyAttribute { get; }
    public RecipientKeyIdentifier(Asn1OctetString subjectKeyIdentifier, DerGeneralizedTime date, OtherKeyAttribute other);
    public RecipientKeyIdentifier(Asn1Sequence seq);
    public static RecipientKeyIdentifier GetInstance(Asn1TaggedObject ato, bool explicitly);
    public static RecipientKeyIdentifier GetInstance(object obj);
    public Asn1OctetString get_SubjectKeyIdentifier();
    public DerGeneralizedTime get_Date();
    public OtherKeyAttribute get_OtherKeyAttribute();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedData : Asn1Encodable {
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    private bool certsBer;
    private bool crlsBer;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo EncapContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set CRLs { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(Asn1Set digestAlgorithms, ContentInfo contentInfo, Asn1Set certificates, Asn1Set crls, Asn1Set signerInfos);
    private SignedData(Asn1Sequence seq);
    public static SignedData GetInstance(object obj);
    private DerInteger CalculateVersion(DerObjectIdentifier contentOid, Asn1Set certs, Asn1Set crls, Asn1Set signerInfs);
    private bool CheckForVersion3(Asn1Set signerInfs);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_EncapContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_CRLs();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignedDataParser : object {
    private Asn1SequenceParser _seq;
    private DerInteger _version;
    private object _nextObject;
    private bool _certsCalled;
    private bool _crlsCalled;
    public DerInteger Version { get; }
    public SignedDataParser(Asn1SequenceParser seq);
    public static SignedDataParser GetInstance(object o);
    public DerInteger get_Version();
    public Asn1SetParser GetDigestAlgorithms();
    public ContentInfoParser GetEncapContentInfo();
    public Asn1SetParser GetCertificates();
    public Asn1SetParser GetCrls();
    public Asn1SetParser GetSignerInfos();
}
public class Org.BouncyCastle.Asn1.Cms.SignerIdentifier : Asn1Encodable {
    private Asn1Encodable id;
    public bool IsTagged { get; }
    public Asn1Encodable ID { get; }
    public SignerIdentifier(IssuerAndSerialNumber id);
    public SignerIdentifier(Asn1OctetString id);
    public SignerIdentifier(Asn1Object id);
    public static SignerIdentifier GetInstance(object o);
    public bool get_IsTagged();
    public Asn1Encodable get_ID();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private SignerIdentifier sid;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public SignerIdentifier SignerID { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(SignerIdentifier sid, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public SignerIdentifier get_SignerID();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Cms.Time : Asn1Encodable {
    private Asn1Object time;
    public string TimeString { get; }
    public DateTime Date { get; }
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string get_TimeString();
    public DateTime get_Date();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.ConstructedOctetStream : BaseInputStream {
    private Asn1StreamParser _parser;
    private bool _first;
    private Stream _currentStream;
    internal ConstructedOctetStream(Asn1StreamParser parser);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
public abstract class Org.BouncyCastle.Asn1.CryptoPro.CryptoProObjectIdentifiers : object {
    public static string GostID;
    public static DerObjectIdentifier GostR3411;
    public static DerObjectIdentifier GostR28147Cbc;
    public static DerObjectIdentifier GostR3410x94;
    public static DerObjectIdentifier GostR3410x2001;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x94;
    public static DerObjectIdentifier GostR3411x94WithGostR3410x2001;
    public static DerObjectIdentifier GostR3411x94CryptoProParamSet;
    public static DerObjectIdentifier GostR3410x94CryptoProA;
    public static DerObjectIdentifier GostR3410x94CryptoProB;
    public static DerObjectIdentifier GostR3410x94CryptoProC;
    public static DerObjectIdentifier GostR3410x94CryptoProD;
    public static DerObjectIdentifier GostR3410x94CryptoProXchA;
    public static DerObjectIdentifier GostR3410x94CryptoProXchB;
    public static DerObjectIdentifier GostR3410x94CryptoProXchC;
    public static DerObjectIdentifier GostR3410x2001CryptoProA;
    public static DerObjectIdentifier GostR3410x2001CryptoProB;
    public static DerObjectIdentifier GostR3410x2001CryptoProC;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchA;
    public static DerObjectIdentifier GostR3410x2001CryptoProXchB;
    public static DerObjectIdentifier GostElSgDH3410Default;
    public static DerObjectIdentifier GostElSgDH3410x1;
    private static CryptoProObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves : object {
    internal static Hashtable objIds;
    internal static Hashtable parameters;
    internal static Hashtable names;
    public static IEnumerable Names { get; }
    private static ECGost3410NamedCurves();
    public static ECDomainParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static ECDomainParameters GetByName(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.ECGost3410ParamSetParameters : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger a;
    internal DerInteger b;
    internal DerInteger x;
    internal DerInteger y;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public ECGost3410ParamSetParameters(BigInteger a, BigInteger b, BigInteger p, BigInteger q, int x, BigInteger y);
    public ECGost3410ParamSetParameters(Asn1Sequence seq);
    public static ECGost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ECGost3410ParamSetParameters GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters : Asn1Encodable {
    private Asn1OctetString iv;
    private DerObjectIdentifier paramSet;
    private Gost28147Parameters(Asn1Sequence seq);
    public static Gost28147Parameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost28147Parameters GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters : object {
    private static Hashtable objIds;
    private static Hashtable parameters;
    private static Gost3410ParamSetParameters cryptoProA;
    private static Gost3410ParamSetParameters cryptoProB;
    private static Gost3410ParamSetParameters cryptoProXchA;
    public static IEnumerable Names { get; }
    private static Gost3410NamedParameters();
    public static Gost3410ParamSetParameters GetByOid(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static Gost3410ParamSetParameters GetByName(string name);
    public static DerObjectIdentifier GetOid(string name);
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters : Asn1Encodable {
    private int keySize;
    private DerInteger p;
    private DerInteger q;
    private DerInteger a;
    public int KeySize { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ParamSetParameters(int keySize, BigInteger p, BigInteger q, BigInteger a);
    private Gost3410ParamSetParameters(Asn1Sequence seq);
    public static Gost3410ParamSetParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410ParamSetParameters GetInstance(object obj);
    public int get_KeySize();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.CryptoPro.Gost3410PublicKeyAlgParameters : Asn1Encodable {
    private DerObjectIdentifier publicKeyParamSet;
    private DerObjectIdentifier digestParamSet;
    private DerObjectIdentifier encryptionParamSet;
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public DerObjectIdentifier DigestParamSet { get; }
    public DerObjectIdentifier EncryptionParamSet { get; }
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet);
    public Gost3410PublicKeyAlgParameters(DerObjectIdentifier publicKeyParamSet, DerObjectIdentifier digestParamSet, DerObjectIdentifier encryptionParamSet);
    public Gost3410PublicKeyAlgParameters(Asn1Sequence seq);
    public static Gost3410PublicKeyAlgParameters GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Gost3410PublicKeyAlgParameters GetInstance(object obj);
    public DerObjectIdentifier get_PublicKeyParamSet();
    public DerObjectIdentifier get_DigestParamSet();
    public DerObjectIdentifier get_EncryptionParamSet();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.DefiniteLengthInputStream : LimitedInputStream {
    private static Byte[] EmptyBytes;
    private int _originalLength;
    private int _remaining;
    internal DefiniteLengthInputStream(Stream inStream, int length);
    private static DefiniteLengthInputStream();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    internal Byte[] ToArray();
}
public class Org.BouncyCastle.Asn1.DerApplicationSpecific : Asn1Object {
    private bool isConstructed;
    private int tag;
    private Byte[] octets;
    public int ApplicationTag { get; }
    internal DerApplicationSpecific(bool isConstructed, int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Byte[] octets);
    public DerApplicationSpecific(int tag, Asn1Encodable obj);
    public DerApplicationSpecific(bool isExplicit, int tag, Asn1Encodable obj);
    public DerApplicationSpecific(int tagNo, Asn1EncodableVector vec);
    private int GetLengthOfLength(Byte[] data);
    public bool IsConstructed();
    public Byte[] GetContents();
    public int get_ApplicationTag();
    public Asn1Object GetObject();
    public Asn1Object GetObject(int derTagNo);
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    private Byte[] ReplaceTagNumber(int newTag, Byte[] input);
}
public class Org.BouncyCastle.Asn1.DerBitString : DerStringBase {
    private static Char[] table;
    private Byte[] data;
    private int padBits;
    public int PadBits { get; }
    public int IntValue { get; }
    internal DerBitString(byte data, int padBits);
    public DerBitString(Byte[] data, int padBits);
    public DerBitString(Byte[] data);
    public DerBitString(Asn1Encodable obj);
    private static DerBitString();
    internal static int GetPadBits(int bitString);
    internal static Byte[] GetBytes(int bitString);
    public static DerBitString GetInstance(object obj);
    public static DerBitString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public Byte[] GetBytes();
    public int get_PadBits();
    public int get_IntValue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string GetString();
}
public class Org.BouncyCastle.Asn1.DerBmpString : DerStringBase {
    private string str;
    public DerBmpString(Byte[] str);
    public DerBmpString(string str);
    public static DerBmpString GetInstance(object obj);
    public static DerBmpString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerBoolean : Asn1Object {
    private byte value;
    public static DerBoolean False;
    public static DerBoolean True;
    public bool IsTrue { get; }
    public DerBoolean(Byte[] value);
    private DerBoolean(bool value);
    private static DerBoolean();
    public static DerBoolean GetInstance(object obj);
    public static DerBoolean GetInstance(bool value);
    public static DerBoolean GetInstance(Asn1TaggedObject obj, bool explicitly);
    public bool get_IsTrue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerEnumerated : Asn1Object {
    private Byte[] bytes;
    public BigInteger Value { get; }
    public DerEnumerated(int value);
    public DerEnumerated(BigInteger value);
    public DerEnumerated(Byte[] bytes);
    public static DerEnumerated GetInstance(object obj);
    public static DerEnumerated GetInstance(Asn1TaggedObject obj, bool explicitly);
    public BigInteger get_Value();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerGeneralizedTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    private bool HasFractionalSeconds { get; }
    public DerGeneralizedTime(string time);
    public DerGeneralizedTime(DateTime time);
    internal DerGeneralizedTime(Byte[] bytes);
    public static DerGeneralizedTime GetInstance(object obj);
    public static DerGeneralizedTime GetInstance(Asn1TaggedObject obj, bool explicitly);
    public string get_TimeString();
    public string GetTime();
    private string CalculateGmtOffset();
    private static string Convert(int time);
    public DateTime ToDateTime();
    private string FString(int count);
    private DateTime ParseDateString(string dateStr, string formatStr, bool makeUniversal);
    private bool get_HasFractionalSeconds();
    private Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerGeneralString : DerStringBase {
    private string str;
    public DerGeneralString(Byte[] str);
    public DerGeneralString(string str);
    public static DerGeneralString GetInstance(object obj);
    public static DerGeneralString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public abstract class Org.BouncyCastle.Asn1.DerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected DerGenerator(Stream outStream);
    protected DerGenerator(Stream outStream, int tagNo, bool isExplicit);
    private static void WriteLength(Stream outStr, int length);
    internal static void WriteDerEncoded(Stream outStream, int tag, Byte[] bytes);
    internal void WriteDerEncoded(int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStr, int tag, Stream inStr);
}
public class Org.BouncyCastle.Asn1.DerIA5String : DerStringBase {
    private string str;
    public DerIA5String(Byte[] str);
    public DerIA5String(string str);
    public DerIA5String(string str, bool validate);
    public static DerIA5String GetInstance(object obj);
    public static DerIA5String GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsIA5String(string str);
}
public class Org.BouncyCastle.Asn1.DerInteger : Asn1Object {
    private Byte[] bytes;
    public BigInteger Value { get; }
    public BigInteger PositiveValue { get; }
    public DerInteger(int value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    public static DerInteger GetInstance(object obj);
    public static DerInteger GetInstance(Asn1TaggedObject obj, bool explicitly);
    public BigInteger get_Value();
    public BigInteger get_PositiveValue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerNull : Asn1Null {
    public static DerNull Instance;
    private Byte[] zeroBytes;
    protected internal DerNull(int dummy);
    private static DerNull();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerNumericString : DerStringBase {
    private string str;
    public DerNumericString(Byte[] str);
    public DerNumericString(string str);
    public DerNumericString(string str, bool validate);
    public static DerNumericString GetInstance(object obj);
    public static DerNumericString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsNumericString(string str);
}
public class Org.BouncyCastle.Asn1.DerObjectIdentifier : Asn1Object {
    private static Regex OidRegex;
    private string identifier;
    public string Id { get; }
    public DerObjectIdentifier(string identifier);
    internal DerObjectIdentifier(Byte[] bytes);
    private static DerObjectIdentifier();
    public static DerObjectIdentifier GetInstance(object obj);
    public static DerObjectIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public string get_Id();
    private void WriteField(Stream outputStream, long fieldValue);
    private void WriteField(Stream outputStream, BigInteger fieldValue);
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    private static string MakeOidStringFromBytes(Byte[] bytes);
}
public class Org.BouncyCastle.Asn1.DerOctetString : Asn1OctetString {
    public DerOctetString(Byte[] str);
    public DerOctetString(Asn1Encodable obj);
    internal virtual void Encode(DerOutputStream derOut);
    internal static void Encode(DerOutputStream derOut, Byte[] bytes, int offset, int length);
}
public class Org.BouncyCastle.Asn1.DerOctetStringParser : object {
    private DefiniteLengthInputStream stream;
    internal DerOctetStringParser(DefiniteLengthInputStream stream);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerOutputStream : FilterStream {
    public DerOutputStream(Stream os);
    private void WriteLength(int length);
    internal void WriteEncoded(int tag, Byte[] bytes);
    internal void WriteEncoded(int tag, Byte[] bytes, int offset, int length);
    internal void WriteTag(int flags, int tagNo);
    internal void WriteEncoded(int flags, int tagNo, Byte[] bytes);
    protected void WriteNull();
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
    public virtual void WriteObject(Asn1Encodable obj);
}
public class Org.BouncyCastle.Asn1.DerPrintableString : DerStringBase {
    private string str;
    public DerPrintableString(Byte[] str);
    public DerPrintableString(string str);
    public DerPrintableString(string str, bool validate);
    public static DerPrintableString GetInstance(object obj);
    public static DerPrintableString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public static bool IsPrintableString(string str);
}
public class Org.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable obj);
    public DerSequence(Asn1Encodable[] v);
    public DerSequence(Asn1EncodableVector v);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector v);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerSequenceGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSequenceGenerator(Stream outStream);
    public DerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSequenceParser : object {
    private Asn1StreamParser _parser;
    internal DerSequenceParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.DerSet : Asn1Set {
    public static DerSet Empty;
    public DerSet(Asn1Encodable obj);
    public DerSet(Asn1Encodable[] v);
    public DerSet(Asn1EncodableVector v);
    internal DerSet(Asn1EncodableVector v, bool needsSorting);
    private static DerSet();
    public static DerSet FromVector(Asn1EncodableVector v);
    internal static DerSet FromVector(Asn1EncodableVector v, bool needsSorting);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerSetGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSetGenerator(Stream outStream);
    public DerSetGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
public class Org.BouncyCastle.Asn1.DerSetParser : object {
    private Asn1StreamParser _parser;
    internal DerSetParser(Asn1StreamParser parser);
    public sealed virtual IAsn1Convertible ReadObject();
    public sealed virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.DerStringBase : Asn1Object {
    public abstract virtual string GetString();
    public virtual string ToString();
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerT61String : DerStringBase {
    private string str;
    public DerT61String(Byte[] str);
    public DerT61String(string str);
    public static DerT61String GetInstance(object obj);
    public static DerT61String GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    internal virtual void Encode(DerOutputStream derOut);
    public Byte[] GetOctets();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerTaggedObject : Asn1TaggedObject {
    public DerTaggedObject(int tagNo, Asn1Encodable obj);
    public DerTaggedObject(bool explicitly, int tagNo, Asn1Encodable obj);
    public DerTaggedObject(int tagNo);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerUniversalString : DerStringBase {
    private static Char[] table;
    private Byte[] str;
    public DerUniversalString(Byte[] str);
    private static DerUniversalString();
    public static DerUniversalString GetInstance(object obj);
    public static DerUniversalString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
public class Org.BouncyCastle.Asn1.DerUnknownTag : Asn1Object {
    private bool isConstructed;
    private int tag;
    private Byte[] data;
    public bool IsConstructed { get; }
    public int Tag { get; }
    public DerUnknownTag(int tag, Byte[] data);
    public DerUnknownTag(bool isConstructed, int tag, Byte[] data);
    public bool get_IsConstructed();
    public int get_Tag();
    public Byte[] GetData();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public class Org.BouncyCastle.Asn1.DerUtcTime : Asn1Object {
    private string time;
    public string TimeString { get; }
    [ObsoleteAttribute("Use 'AdjustedTimeString' property instead")]
public string AdjustedTime { get; }
    public string AdjustedTimeString { get; }
    public DerUtcTime(string time);
    public DerUtcTime(DateTime time);
    internal DerUtcTime(Byte[] bytes);
    public static DerUtcTime GetInstance(object obj);
    public static DerUtcTime GetInstance(Asn1TaggedObject obj, bool explicitly);
    public DateTime ToDateTime();
    public DateTime ToAdjustedDateTime();
    private DateTime ParseDateString(string dateStr, string formatStr);
    public string get_TimeString();
    public string get_AdjustedTime();
    public string get_AdjustedTimeString();
    private Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.DerUtf8String : DerStringBase {
    private string str;
    internal DerUtf8String(Byte[] str);
    public DerUtf8String(string str);
    public static DerUtf8String GetInstance(object obj);
    public static DerUtf8String GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    internal virtual void Encode(DerOutputStream derOut);
}
public class Org.BouncyCastle.Asn1.DerVisibleString : DerStringBase {
    private string str;
    public DerVisibleString(Byte[] str);
    public DerVisibleString(string str);
    public static DerVisibleString GetInstance(object obj);
    public static DerVisibleString GetInstance(Asn1TaggedObject obj, bool explicitly);
    public virtual string GetString();
    public Byte[] GetOctets();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
public abstract class Org.BouncyCastle.Asn1.Eac.EacObjectIdentifiers : object {
    public static DerObjectIdentifier bsi_de;
    public static DerObjectIdentifier id_PK;
    public static DerObjectIdentifier id_PK_DH;
    public static DerObjectIdentifier id_PK_ECDH;
    public static DerObjectIdentifier id_CA;
    public static DerObjectIdentifier id_CA_DH;
    public static DerObjectIdentifier id_CA_DH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_CA_ECDH;
    public static DerObjectIdentifier id_CA_ECDH_3DES_CBC_CBC;
    public static DerObjectIdentifier id_TA;
    public static DerObjectIdentifier id_TA_RSA;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_v1_5_SHA_256;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_1;
    public static DerObjectIdentifier id_TA_RSA_PSS_SHA_256;
    public static DerObjectIdentifier id_TA_ECDSA;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_1;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_224;
    public static DerObjectIdentifier id_TA_ECDSA_SHA_256;
    private static EacObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Esf.CertificateValues : Asn1Encodable {
    private Asn1Sequence certificates;
    private CertificateValues(Asn1Sequence seq);
    public CertificateValues(X509CertificateStructure[] certificates);
    public CertificateValues(IEnumerable certificates);
    public static CertificateValues GetInstance(object obj);
    public X509CertificateStructure[] GetCertificates();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIdentifier : object {
    public static DerObjectIdentifier ProofOfOrigin;
    public static DerObjectIdentifier ProofOfReceipt;
    public static DerObjectIdentifier ProofOfDelivery;
    public static DerObjectIdentifier ProofOfSender;
    public static DerObjectIdentifier ProofOfApproval;
    public static DerObjectIdentifier ProofOfCreation;
    private static CommitmentTypeIdentifier();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeId;
    private Asn1Sequence commitmentTypeQualifier;
    public DerObjectIdentifier CommitmentTypeID { get; }
    public Asn1Sequence CommitmentTypeQualifier { get; }
    public CommitmentTypeIndication(Asn1Sequence seq);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId);
    public CommitmentTypeIndication(DerObjectIdentifier commitmentTypeId, Asn1Sequence commitmentTypeQualifier);
    public static CommitmentTypeIndication GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeID();
    public Asn1Sequence get_CommitmentTypeQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier : Asn1Encodable {
    private DerObjectIdentifier commitmentTypeIdentifier;
    private Asn1Object qualifier;
    public DerObjectIdentifier CommitmentTypeIdentifier { get; }
    public Asn1Object Qualifier { get; }
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier);
    public CommitmentTypeQualifier(DerObjectIdentifier commitmentTypeIdentifier, Asn1Encodable qualifier);
    public CommitmentTypeQualifier(Asn1Sequence seq);
    public static CommitmentTypeQualifier GetInstance(object obj);
    public DerObjectIdentifier get_CommitmentTypeIdentifier();
    public Asn1Object get_Qualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs : Asn1Encodable {
    private Asn1Sequence otherCertIDs;
    private CompleteCertificateRefs(Asn1Sequence seq);
    public CompleteCertificateRefs(OtherCertID[] otherCertIDs);
    public CompleteCertificateRefs(IEnumerable otherCertIDs);
    public static CompleteCertificateRefs GetInstance(object obj);
    public OtherCertID[] GetOtherCertIDs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs : Asn1Encodable {
    private Asn1Sequence crlOcspRefs;
    private CompleteRevocationRefs(Asn1Sequence seq);
    public CompleteRevocationRefs(CrlOcspRef[] crlOcspRefs);
    public CompleteRevocationRefs(IEnumerable crlOcspRefs);
    public static CompleteRevocationRefs GetInstance(object obj);
    public CrlOcspRef[] GetCrlOcspRefs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlIdentifier : Asn1Encodable {
    private X509Name crlIssuer;
    private DerUtcTime crlIssuedTime;
    private DerInteger crlNumber;
    public X509Name CrlIssuer { get; }
    public DateTime CrlIssuedTime { get; }
    public BigInteger CrlNumber { get; }
    private CrlIdentifier(Asn1Sequence seq);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime);
    public CrlIdentifier(X509Name crlIssuer, DateTime crlIssuedTime, BigInteger crlNumber);
    public static CrlIdentifier GetInstance(object obj);
    public X509Name get_CrlIssuer();
    public DateTime get_CrlIssuedTime();
    public BigInteger get_CrlNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlListID : Asn1Encodable {
    private Asn1Sequence crls;
    private CrlListID(Asn1Sequence seq);
    public CrlListID(CrlValidatedID[] crls);
    public CrlListID(IEnumerable crls);
    public static CrlListID GetInstance(object obj);
    public CrlValidatedID[] GetCrls();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlOcspRef : Asn1Encodable {
    private CrlListID crlids;
    private OcspListID ocspids;
    private OtherRevRefs otherRev;
    public CrlListID CrlIDs { get; }
    public OcspListID OcspIDs { get; }
    public OtherRevRefs OtherRev { get; }
    private CrlOcspRef(Asn1Sequence seq);
    public CrlOcspRef(CrlListID crlids, OcspListID ocspids, OtherRevRefs otherRev);
    public static CrlOcspRef GetInstance(object obj);
    public CrlListID get_CrlIDs();
    public OcspListID get_OcspIDs();
    public OtherRevRefs get_OtherRev();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.CrlValidatedID : Asn1Encodable {
    private OtherHash crlHash;
    private CrlIdentifier crlIdentifier;
    public OtherHash CrlHash { get; }
    public CrlIdentifier CrlIdentifier { get; }
    private CrlValidatedID(Asn1Sequence seq);
    public CrlValidatedID(OtherHash crlHash);
    public CrlValidatedID(OtherHash crlHash, CrlIdentifier crlIdentifier);
    public static CrlValidatedID GetInstance(object obj);
    public OtherHash get_CrlHash();
    public CrlIdentifier get_CrlIdentifier();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Esf.EsfAttributes : object {
    public static DerObjectIdentifier SigPolicyId;
    public static DerObjectIdentifier CommitmentType;
    public static DerObjectIdentifier SignerLocation;
    public static DerObjectIdentifier SignerAttr;
    public static DerObjectIdentifier OtherSigCert;
    public static DerObjectIdentifier ContentTimestamp;
    public static DerObjectIdentifier CertificateRefs;
    public static DerObjectIdentifier RevocationRefs;
    public static DerObjectIdentifier CertValues;
    public static DerObjectIdentifier RevocationValues;
    public static DerObjectIdentifier EscTimeStamp;
    public static DerObjectIdentifier CertCrlTimestamp;
    public static DerObjectIdentifier ArchiveTimestamp;
    private static EsfAttributes();
}
public class Org.BouncyCastle.Asn1.Esf.OcspIdentifier : Asn1Encodable {
    private ResponderID ocspResponderID;
    private DerGeneralizedTime producedAt;
    public ResponderID OcspResponderID { get; }
    public DateTime ProducedAt { get; }
    private OcspIdentifier(Asn1Sequence seq);
    public OcspIdentifier(ResponderID ocspResponderID, DateTime producedAt);
    public static OcspIdentifier GetInstance(object obj);
    public ResponderID get_OcspResponderID();
    public DateTime get_ProducedAt();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspListID : Asn1Encodable {
    private Asn1Sequence ocspResponses;
    private OcspListID(Asn1Sequence seq);
    public OcspListID(OcspResponsesID[] ocspResponses);
    public OcspListID(IEnumerable ocspResponses);
    public static OcspListID GetInstance(object obj);
    public OcspResponsesID[] GetOcspResponses();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OcspResponsesID : Asn1Encodable {
    private OcspIdentifier ocspIdentifier;
    private OtherHash ocspRepHash;
    public OcspIdentifier OcspIdentifier { get; }
    public OtherHash OcspRepHash { get; }
    private OcspResponsesID(Asn1Sequence seq);
    public OcspResponsesID(OcspIdentifier ocspIdentifier);
    public OcspResponsesID(OcspIdentifier ocspIdentifier, OtherHash ocspRepHash);
    public static OcspResponsesID GetInstance(object obj);
    public OcspIdentifier get_OcspIdentifier();
    public OtherHash get_OcspRepHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherCertID : Asn1Encodable {
    private OtherHash otherCertHash;
    private IssuerSerial issuerSerial;
    public OtherHash OtherCertHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private OtherCertID(Asn1Sequence seq);
    public OtherCertID(OtherHash otherCertHash);
    public OtherCertID(OtherHash otherCertHash, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object obj);
    public OtherHash get_OtherCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHash : Asn1Encodable {
    private Asn1OctetString sha1Hash;
    private OtherHashAlgAndValue otherHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public OtherHash(Byte[] sha1Hash);
    public OtherHash(Asn1OctetString sha1Hash);
    public OtherHash(OtherHashAlgAndValue otherHash);
    public static OtherHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString hashValue;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private OtherHashAlgAndValue(Asn1Sequence seq);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Byte[] hashValue);
    public OtherHashAlgAndValue(AlgorithmIdentifier hashAlgorithm, Asn1OctetString hashValue);
    public static OtherHashAlgAndValue GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevRefs : Asn1Encodable {
    private DerObjectIdentifier otherRevRefType;
    private Asn1Object otherRevRefs;
    public DerObjectIdentifier OtherRevRefType { get; }
    public Asn1Object OtherRevRefsObject { get; }
    private OtherRevRefs(Asn1Sequence seq);
    public OtherRevRefs(DerObjectIdentifier otherRevRefType, Asn1Encodable otherRevRefs);
    public static OtherRevRefs GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevRefType();
    public Asn1Object get_OtherRevRefsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherRevVals : Asn1Encodable {
    private DerObjectIdentifier otherRevValType;
    private Asn1Object otherRevVals;
    public DerObjectIdentifier OtherRevValType { get; }
    public Asn1Object OtherRevValsObject { get; }
    private OtherRevVals(Asn1Sequence seq);
    public OtherRevVals(DerObjectIdentifier otherRevValType, Asn1Encodable otherRevVals);
    public static OtherRevVals GetInstance(object obj);
    public DerObjectIdentifier get_OtherRevValType();
    public Asn1Object get_OtherRevValsObject();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID[] certs);
    public OtherSigningCertificate(OtherCertID[] certs, PolicyInformation[] policies);
    public OtherSigningCertificate(IEnumerable certs);
    public OtherSigningCertificate(IEnumerable certs, IEnumerable policies);
    public static OtherSigningCertificate GetInstance(object obj);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.RevocationValues : Asn1Encodable {
    private Asn1Sequence crlVals;
    private Asn1Sequence ocspVals;
    private OtherRevVals otherRevVals;
    private RevocationValues(Asn1Sequence seq);
    public RevocationValues(CertificateList[] crlVals, BasicOcspResponse[] ocspVals, OtherRevVals otherRevVals);
    public RevocationValues(IEnumerable crlVals, IEnumerable ocspVals, OtherRevVals otherRevVals);
    public static RevocationValues GetInstance(object obj);
    public CertificateList[] GetCrlVals();
    public BasicOcspResponse[] GetOcspVals();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyId : Asn1Encodable {
    private DerObjectIdentifier sigPolicyIdentifier;
    private OtherHashAlgAndValue sigPolicyHash;
    private Asn1Sequence sigPolicyQualifiers;
    public DerObjectIdentifier SigPolicyIdentifier { get; }
    public OtherHashAlgAndValue SigPolicyHash { get; }
    private SignaturePolicyId(Asn1Sequence seq);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, SigPolicyQualifierInfo[] sigPolicyQualifiers);
    public SignaturePolicyId(DerObjectIdentifier sigPolicyIdentifier, OtherHashAlgAndValue sigPolicyHash, IEnumerable sigPolicyQualifiers);
    public static SignaturePolicyId GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyIdentifier();
    public OtherHashAlgAndValue get_SigPolicyHash();
    public SigPolicyQualifierInfo[] GetSigPolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier : Asn1Encodable {
    private SignaturePolicyId sigPolicy;
    public SignaturePolicyId SignaturePolicyId { get; }
    public SignaturePolicyIdentifier(SignaturePolicyId signaturePolicyId);
    public static SignaturePolicyIdentifier GetInstance(object obj);
    public SignaturePolicyId get_SignaturePolicyId();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerAttribute : Asn1Encodable {
    private Asn1Sequence claimedAttributes;
    private AttributeCertificate certifiedAttributes;
    public Asn1Sequence ClaimedAttributes { get; }
    public AttributeCertificate CertifiedAttributes { get; }
    private SignerAttribute(object obj);
    public SignerAttribute(Asn1Sequence claimedAttributes);
    public SignerAttribute(AttributeCertificate certifiedAttributes);
    public static SignerAttribute GetInstance(object obj);
    public virtual Asn1Sequence get_ClaimedAttributes();
    public virtual AttributeCertificate get_CertifiedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SignerLocation : Asn1Encodable {
    private DerUtf8String countryName;
    private DerUtf8String localityName;
    private Asn1Sequence postalAddress;
    public DerUtf8String CountryName { get; }
    public DerUtf8String LocalityName { get; }
    public Asn1Sequence PostalAddress { get; }
    public SignerLocation(Asn1Sequence seq);
    public SignerLocation(DerUtf8String countryName, DerUtf8String localityName, Asn1Sequence postalAddress);
    public static SignerLocation GetInstance(object obj);
    public DerUtf8String get_CountryName();
    public DerUtf8String get_LocalityName();
    public Asn1Sequence get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo : Asn1Encodable {
    private DerObjectIdentifier sigPolicyQualifierId;
    private Asn1Object sigQualifier;
    public DerObjectIdentifier SigPolicyQualifierId { get; }
    public Asn1Object SigQualifier { get; }
    private SigPolicyQualifierInfo(Asn1Sequence seq);
    public SigPolicyQualifierInfo(DerObjectIdentifier sigPolicyQualifierId, Asn1Encodable sigQualifier);
    public static SigPolicyQualifierInfo GetInstance(object obj);
    public DerObjectIdentifier get_SigPolicyQualifierId();
    public Asn1Object get_SigQualifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentHints : Asn1Encodable {
    private DerUtf8String contentDescription;
    private DerObjectIdentifier contentType;
    public DerObjectIdentifier ContentType { get; }
    public DerUtf8String ContentDescription { get; }
    private ContentHints(Asn1Sequence seq);
    public ContentHints(DerObjectIdentifier contentType);
    public ContentHints(DerObjectIdentifier contentType, DerUtf8String contentDescription);
    public static ContentHints GetInstance(object o);
    public DerObjectIdentifier get_ContentType();
    public DerUtf8String get_ContentDescription();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.ContentIdentifier : Asn1Encodable {
    private Asn1OctetString value;
    public Asn1OctetString Value { get; }
    public ContentIdentifier(Asn1OctetString value);
    public ContentIdentifier(Byte[] value);
    public static ContentIdentifier GetInstance(object o);
    public Asn1OctetString get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertID : Asn1Encodable {
    private Asn1OctetString certHash;
    private IssuerSerial issuerSerial;
    public IssuerSerial IssuerSerial { get; }
    public EssCertID(Asn1Sequence seq);
    public EssCertID(Byte[] hash);
    public EssCertID(Byte[] hash, IssuerSerial issuerSerial);
    public static EssCertID GetInstance(object o);
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.EssCertIDv2 : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certHash;
    private IssuerSerial issuerSerial;
    private static AlgorithmIdentifier DefaultAlgID;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIDv2(Asn1Sequence seq);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash);
    public EssCertIDv2(AlgorithmIdentifier algId, Byte[] certHash, IssuerSerial issuerSerial);
    private static EssCertIDv2();
    public static EssCertIDv2 GetInstance(object o);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherCertID : Asn1Encodable {
    private Asn1Encodable otherCertHash;
    private IssuerSerial issuerSerial;
    public AlgorithmIdentifier AlgorithmHash { get; }
    public IssuerSerial IssuerSerial { get; }
    public OtherCertID(Asn1Sequence seq);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest);
    public OtherCertID(AlgorithmIdentifier algId, Byte[] digest, IssuerSerial issuerSerial);
    public static OtherCertID GetInstance(object o);
    public AlgorithmIdentifier get_AlgorithmHash();
    public Byte[] GetCertHash();
    public IssuerSerial get_IssuerSerial();
    public virtual Asn1Object ToAsn1Object();
}
[ObsoleteAttribute("Use version in Asn1.Esf instead")]
public class Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public OtherSigningCertificate(Asn1Sequence seq);
    public OtherSigningCertificate(OtherCertID otherCertID);
    public static OtherSigningCertificate GetInstance(object o);
    public OtherCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificate : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    public SigningCertificate(Asn1Sequence seq);
    public SigningCertificate(EssCertID essCertID);
    public static SigningCertificate GetInstance(object o);
    public EssCertID[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ess.SigningCertificateV2 : Asn1Encodable {
    private Asn1Sequence certs;
    private Asn1Sequence policies;
    private SigningCertificateV2(Asn1Sequence seq);
    public SigningCertificateV2(EssCertIDv2[] certs);
    public SigningCertificateV2(EssCertIDv2[] certs, PolicyInformation[] policies);
    public static SigningCertificateV2 GetInstance(object o);
    public EssCertIDv2[] GetCerts();
    public PolicyInformation[] GetPolicies();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers : object {
    public static DerObjectIdentifier Gnu;
    public static DerObjectIdentifier GnuPG;
    public static DerObjectIdentifier Notation;
    public static DerObjectIdentifier PkaAddress;
    public static DerObjectIdentifier GnuRadar;
    public static DerObjectIdentifier DigestAlgorithm;
    public static DerObjectIdentifier Tiger192;
    public static DerObjectIdentifier EncryptionAlgorithm;
    public static DerObjectIdentifier Serpent;
    public static DerObjectIdentifier Serpent128Ecb;
    public static DerObjectIdentifier Serpent128Cbc;
    public static DerObjectIdentifier Serpent128Ofb;
    public static DerObjectIdentifier Serpent128Cfb;
    public static DerObjectIdentifier Serpent192Ecb;
    public static DerObjectIdentifier Serpent192Cbc;
    public static DerObjectIdentifier Serpent192Ofb;
    public static DerObjectIdentifier Serpent192Cfb;
    public static DerObjectIdentifier Serpent256Ecb;
    public static DerObjectIdentifier Serpent256Cbc;
    public static DerObjectIdentifier Serpent256Ofb;
    public static DerObjectIdentifier Serpent256Cfb;
    public static DerObjectIdentifier Crc;
    public static DerObjectIdentifier Crc32;
    private static GnuObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Iana.IanaObjectIdentifiers : object {
    public static DerObjectIdentifier IsakmpOakley;
    public static DerObjectIdentifier HmacMD5;
    public static DerObjectIdentifier HmacSha1;
    public static DerObjectIdentifier HmacTiger;
    public static DerObjectIdentifier HmacRipeMD160;
    private static IanaObjectIdentifiers();
}
public interface Org.BouncyCastle.Asn1.IAsn1ApplicationSpecificParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
public interface Org.BouncyCastle.Asn1.IAsn1Choice {
}
public interface Org.BouncyCastle.Asn1.IAsn1Convertible {
    public abstract virtual Asn1Object ToAsn1Object();
}
public interface Org.BouncyCastle.Asn1.IAsn1String {
    public abstract virtual string GetString();
}
public class Org.BouncyCastle.Asn1.Icao.DataGroupHash : Asn1Encodable {
    private DerInteger dataGroupNumber;
    private Asn1OctetString dataGroupHashValue;
    public int DataGroupNumber { get; }
    public Asn1OctetString DataGroupHashValue { get; }
    private DataGroupHash(Asn1Sequence seq);
    public DataGroupHash(int dataGroupNumber, Asn1OctetString dataGroupHashValue);
    public static DataGroupHash GetInstance(object obj);
    public int get_DataGroupNumber();
    public Asn1OctetString get_DataGroupHashValue();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Icao.IcaoObjectIdentifiers : object {
    public static string IdIcao;
    public static DerObjectIdentifier IdIcaoMrtd;
    public static DerObjectIdentifier IdIcaoMrtdSecurity;
    public static DerObjectIdentifier IdIcaoLdsSecurityObject;
    private static IcaoObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Icao.LdsSecurityObject : Asn1Encodable {
    public static int UBDataGroups;
    internal DerInteger version;
    internal AlgorithmIdentifier digestAlgorithmIdentifier;
    internal DataGroupHash[] datagroupHash;
    public AlgorithmIdentifier DigestAlgorithmIdentifier { get; }
    public LdsSecurityObject(Asn1Sequence seq);
    public LdsSecurityObject(AlgorithmIdentifier digestAlgorithmIdentifier, DataGroupHash[] datagroupHash);
    public static LdsSecurityObject GetInstance(object obj);
    private void CheckDatagroupHashSeqSize(int size);
    public AlgorithmIdentifier get_DigestAlgorithmIdentifier();
    public DataGroupHash[] GetDatagroupHash();
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.Asn1.IndefiniteLengthInputStream : LimitedInputStream {
    private int _b1;
    private int _b2;
    private bool _eofReached;
    private bool _eofOn00;
    internal IndefiniteLengthInputStream(Stream inStream);
    internal void SetEofOn00(bool eofOn00);
    private bool CheckForEof();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
}
public abstract class Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers : object {
    public static DerObjectIdentifier IdIsisMtt;
    public static DerObjectIdentifier IdIsisMttCP;
    public static DerObjectIdentifier IdIsisMttCPAccredited;
    public static DerObjectIdentifier IdIsisMttAT;
    public static DerObjectIdentifier IdIsisMttATDateOfCertGen;
    public static DerObjectIdentifier IdIsisMttATProcuration;
    public static DerObjectIdentifier IdIsisMttATAdmission;
    public static DerObjectIdentifier IdIsisMttATMonetaryLimit;
    public static DerObjectIdentifier IdIsisMttATDeclarationOfMajority;
    public static DerObjectIdentifier IdIsisMttATIccsn;
    public static DerObjectIdentifier IdIsisMttATPKReference;
    public static DerObjectIdentifier IdIsisMttATRestriction;
    public static DerObjectIdentifier IdIsisMttATRetrieveIfAllowed;
    public static DerObjectIdentifier IdIsisMttATRequestedCertificate;
    public static DerObjectIdentifier IdIsisMttATNamingAuthorities;
    public static DerObjectIdentifier IdIsisMttATCertInDirSince;
    public static DerObjectIdentifier IdIsisMttATCertHash;
    public static DerObjectIdentifier IdIsisMttATNameAtBirth;
    public static DerObjectIdentifier IdIsisMttATAdditionalInformation;
    public static DerObjectIdentifier IdIsisMttATLiabilityLimitationFlag;
    private static IsisMttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] certificateHash;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    private CertHash(Asn1Sequence seq);
    public CertHash(AlgorithmIdentifier hashAlgorithm, Byte[] certificateHash);
    public static CertHash GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] get_CertificateHash();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate : Asn1Encodable {
    private X509CertificateStructure cert;
    private Byte[] publicKeyCert;
    private Byte[] attributeCert;
    public Choice Type { get; }
    private RequestedCertificate(Asn1TaggedObject tagged);
    public RequestedCertificate(X509CertificateStructure certificate);
    public RequestedCertificate(Choice type, Byte[] certificateOctets);
    public static RequestedCertificate GetInstance(object obj);
    public static RequestedCertificate GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Choice get_Type();
    public Byte[] GetCertificateBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax : Asn1Encodable {
    private DirectoryString information;
    public DirectoryString Information { get; }
    private AdditionalInformationSyntax(DirectoryString information);
    public AdditionalInformationSyntax(string information);
    public static AdditionalInformationSyntax GetInstance(object obj);
    public virtual DirectoryString get_Information();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions : Asn1Encodable {
    private GeneralName admissionAuthority;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionInfos;
    public GeneralName AdmissionAuthority { get; }
    public NamingAuthority NamingAuthority { get; }
    private Admissions(Asn1Sequence seq);
    public Admissions(GeneralName admissionAuthority, NamingAuthority namingAuthority, ProfessionInfo[] professionInfos);
    public static Admissions GetInstance(object obj);
    public virtual GeneralName get_AdmissionAuthority();
    public virtual NamingAuthority get_NamingAuthority();
    public ProfessionInfo[] GetProfessionInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax : Asn1Encodable {
    private GeneralName admissionAuthority;
    private Asn1Sequence contentsOfAdmissions;
    public GeneralName AdmissionAuthority { get; }
    private AdmissionSyntax(Asn1Sequence seq);
    public AdmissionSyntax(GeneralName admissionAuthority, Asn1Sequence contentsOfAdmissions);
    public static AdmissionSyntax GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual GeneralName get_AdmissionAuthority();
    public virtual Admissions[] GetContentsOfAdmissions();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority : Asn1Encodable {
    private Asn1TaggedObject declaration;
    public Choice Type { get; }
    public int NotYoungerThan { get; }
    public Asn1Sequence FullAgeAtCountry { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DeclarationOfMajority(int notYoungerThan);
    public DeclarationOfMajority(bool fullAge, string country);
    public DeclarationOfMajority(DerGeneralizedTime dateOfBirth);
    private DeclarationOfMajority(Asn1TaggedObject o);
    public static DeclarationOfMajority GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public Choice get_Type();
    public virtual int get_NotYoungerThan();
    public virtual Asn1Sequence get_FullAgeAtCountry();
    public virtual DerGeneralizedTime get_DateOfBirth();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit : Asn1Encodable {
    private DerPrintableString currency;
    private DerInteger amount;
    private DerInteger exponent;
    public string Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryLimit(Asn1Sequence seq);
    public MonetaryLimit(string currency, int amount, int exponent);
    public static MonetaryLimit GetInstance(object obj);
    public virtual string get_Currency();
    public virtual BigInteger get_Amount();
    public virtual BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority : Asn1Encodable {
    public static DerObjectIdentifier IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern;
    private DerObjectIdentifier namingAuthorityID;
    private string namingAuthorityUrl;
    private DirectoryString namingAuthorityText;
    public DerObjectIdentifier NamingAuthorityID { get; }
    public DirectoryString NamingAuthorityText { get; }
    public string NamingAuthorityUrl { get; }
    private NamingAuthority(Asn1Sequence seq);
    public NamingAuthority(DerObjectIdentifier namingAuthorityID, string namingAuthorityUrl, DirectoryString namingAuthorityText);
    private static NamingAuthority();
    public static NamingAuthority GetInstance(object obj);
    public static NamingAuthority GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public virtual DerObjectIdentifier get_NamingAuthorityID();
    public virtual DirectoryString get_NamingAuthorityText();
    public virtual string get_NamingAuthorityUrl();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax : Asn1Encodable {
    private string country;
    private DirectoryString typeOfSubstitution;
    private GeneralName thirdPerson;
    private IssuerSerial certRef;
    public string Country { get; }
    public DirectoryString TypeOfSubstitution { get; }
    public GeneralName ThirdPerson { get; }
    public IssuerSerial CertRef { get; }
    private ProcurationSyntax(Asn1Sequence seq);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, IssuerSerial certRef);
    public ProcurationSyntax(string country, DirectoryString typeOfSubstitution, GeneralName thirdPerson);
    public static ProcurationSyntax GetInstance(object obj);
    public virtual string get_Country();
    public virtual DirectoryString get_TypeOfSubstitution();
    public virtual GeneralName get_ThirdPerson();
    public virtual IssuerSerial get_CertRef();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo : Asn1Encodable {
    public static DerObjectIdentifier Rechtsanwltin;
    public static DerObjectIdentifier Rechtsanwalt;
    public static DerObjectIdentifier Rechtsbeistand;
    public static DerObjectIdentifier Steuerberaterin;
    public static DerObjectIdentifier Steuerberater;
    public static DerObjectIdentifier Steuerbevollmchtigte;
    public static DerObjectIdentifier Steuerbevollmchtigter;
    public static DerObjectIdentifier Notarin;
    public static DerObjectIdentifier Notar;
    public static DerObjectIdentifier Notarvertreterin;
    public static DerObjectIdentifier Notarvertreter;
    public static DerObjectIdentifier Notariatsverwalterin;
    public static DerObjectIdentifier Notariatsverwalter;
    public static DerObjectIdentifier Wirtschaftsprferin;
    public static DerObjectIdentifier Wirtschaftsprfer;
    public static DerObjectIdentifier VereidigteBuchprferin;
    public static DerObjectIdentifier VereidigterBuchprfer;
    public static DerObjectIdentifier Patentanwltin;
    public static DerObjectIdentifier Patentanwalt;
    private NamingAuthority namingAuthority;
    private Asn1Sequence professionItems;
    private Asn1Sequence professionOids;
    private string registrationNumber;
    private Asn1OctetString addProfessionInfo;
    public Asn1OctetString AddProfessionInfo { get; }
    public NamingAuthority NamingAuthority { get; }
    public string RegistrationNumber { get; }
    private ProfessionInfo(Asn1Sequence seq);
    public ProfessionInfo(NamingAuthority namingAuthority, DirectoryString[] professionItems, DerObjectIdentifier[] professionOids, string registrationNumber, Asn1OctetString addProfessionInfo);
    private static ProfessionInfo();
    public static ProfessionInfo GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public virtual Asn1OctetString get_AddProfessionInfo();
    public virtual NamingAuthority get_NamingAuthority();
    public virtual DirectoryString[] GetProfessionItems();
    public virtual DerObjectIdentifier[] GetProfessionOids();
    public virtual string get_RegistrationNumber();
}
public class Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction : Asn1Encodable {
    private DirectoryString restriction;
    public DirectoryString RestrictionString { get; }
    private Restriction(DirectoryString restriction);
    public Restriction(string restriction);
    public static Restriction GetInstance(object obj);
    public virtual DirectoryString get_RestrictionString();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Kisa.KisaObjectIdentifiers : object {
    public static DerObjectIdentifier IdSeedCbc;
    public static DerObjectIdentifier IdNpkiAppCmsSeedWrap;
    private static KisaObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.LazyAsn1InputStream : Asn1InputStream {
    public LazyAsn1InputStream(Byte[] input);
    public LazyAsn1InputStream(Stream inputStream);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    internal virtual DerSet CreateDerSet(DefiniteLengthInputStream dIn);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSequence : DerSequence {
    private Byte[] encoded;
    private bool parsed;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSequence(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(DerOutputStream derOut);
}
[DefaultMemberAttribute("Item")]
internal class Org.BouncyCastle.Asn1.LazyDerSet : DerSet {
    private Byte[] encoded;
    private bool parsed;
    public Asn1Encodable Item { get; }
    public int Count { get; }
    internal LazyDerSet(Byte[] encoded);
    private void Parse();
    public virtual Asn1Encodable get_Item(int index);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    internal virtual void Encode(DerOutputStream derOut);
}
internal abstract class Org.BouncyCastle.Asn1.LimitedInputStream : BaseInputStream {
    protected Stream _in;
    internal LimitedInputStream(Stream inStream);
    protected virtual void SetParentEofDetect(bool on);
}
public abstract class Org.BouncyCastle.Asn1.Microsoft.MicrosoftObjectIdentifiers : object {
    public static DerObjectIdentifier Microsoft;
    public static DerObjectIdentifier MicrosoftCertTemplateV1;
    public static DerObjectIdentifier MicrosoftCAVersion;
    public static DerObjectIdentifier MicrosoftPrevCACertHash;
    public static DerObjectIdentifier MicrosoftCertTemplateV2;
    public static DerObjectIdentifier MicrosoftAppPolicies;
    private static MicrosoftObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters : Asn1Encodable {
    private DerInteger keyLength;
    private Asn1OctetString iv;
    public int KeyLength { get; }
    public Cast5CbcParameters(Byte[] iv, int keyLength);
    private Cast5CbcParameters(Asn1Sequence seq);
    public static Cast5CbcParameters GetInstance(object o);
    public Byte[] GetIV();
    public int get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Misc.IdeaCbcPar : Asn1Encodable {
    internal Asn1OctetString iv;
    public IdeaCbcPar(Byte[] iv);
    private IdeaCbcPar(Asn1Sequence seq);
    public static IdeaCbcPar GetInstance(object o);
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Misc.MiscObjectIdentifiers : object {
    internal static string Verisign;
    public static DerObjectIdentifier Netscape;
    public static DerObjectIdentifier NetscapeCertType;
    public static DerObjectIdentifier NetscapeBaseUrl;
    public static DerObjectIdentifier NetscapeRevocationUrl;
    public static DerObjectIdentifier NetscapeCARevocationUrl;
    public static DerObjectIdentifier NetscapeRenewalUrl;
    public static DerObjectIdentifier NetscapeCAPolicyUrl;
    public static DerObjectIdentifier NetscapeSslServerName;
    public static DerObjectIdentifier NetscapeCertComment;
    public static DerObjectIdentifier VerisignCzagExtension;
    public static DerObjectIdentifier VerisignDnbDunsNumber;
    public static string Novell;
    public static DerObjectIdentifier NovellSecurityAttribs;
    public static string Entrust;
    public static DerObjectIdentifier EntrustVersionExtension;
    private static MiscObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeCertType : DerBitString {
    public static int SslClient;
    public static int SslServer;
    public static int Smime;
    public static int ObjectSigning;
    public static int Reserved;
    public static int SslCA;
    public static int SmimeCA;
    public static int ObjectSigningCA;
    public NetscapeCertType(int usage);
    public NetscapeCertType(DerBitString usage);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.NetscapeRevocationUrl : DerIA5String {
    public NetscapeRevocationUrl(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Misc.VerisignCzagExtension : DerIA5String {
    public VerisignCzagExtension(DerIA5String str);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge : Asn1Encodable {
    private Asn1Sequence pkacSeq;
    private SubjectPublicKeyInfo spki;
    private DerIA5String challenge;
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerIA5String Challenge { get; }
    public PublicKeyAndChallenge(Asn1Sequence seq);
    public static PublicKeyAndChallenge GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerIA5String get_Challenge();
}
public class Org.BouncyCastle.Asn1.Nist.NistNamedCurves : object {
    private static Hashtable objIds;
    private static Hashtable names;
    public static IEnumerable Names { get; }
    private static NistNamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers : object {
    public static DerObjectIdentifier NistAlgorithm;
    public static DerObjectIdentifier IdSha256;
    public static DerObjectIdentifier IdSha384;
    public static DerObjectIdentifier IdSha512;
    public static DerObjectIdentifier IdSha224;
    public static DerObjectIdentifier Aes;
    public static DerObjectIdentifier IdAes128Ecb;
    public static DerObjectIdentifier IdAes128Cbc;
    public static DerObjectIdentifier IdAes128Ofb;
    public static DerObjectIdentifier IdAes128Cfb;
    public static DerObjectIdentifier IdAes128Wrap;
    public static DerObjectIdentifier IdAes192Ecb;
    public static DerObjectIdentifier IdAes192Cbc;
    public static DerObjectIdentifier IdAes192Ofb;
    public static DerObjectIdentifier IdAes192Cfb;
    public static DerObjectIdentifier IdAes192Wrap;
    public static DerObjectIdentifier IdAes256Ecb;
    public static DerObjectIdentifier IdAes256Cbc;
    public static DerObjectIdentifier IdAes256Ofb;
    public static DerObjectIdentifier IdAes256Cfb;
    public static DerObjectIdentifier IdAes256Wrap;
    public static DerObjectIdentifier IdDsaWithSha2;
    public static DerObjectIdentifier DsaWithSha224;
    public static DerObjectIdentifier DsaWithSha256;
    public static DerObjectIdentifier DsaWithSha384;
    public static DerObjectIdentifier DsaWithSha512;
    private static NistObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers : object {
    public static DerObjectIdentifier IdCamellia128Cbc;
    public static DerObjectIdentifier IdCamellia192Cbc;
    public static DerObjectIdentifier IdCamellia256Cbc;
    public static DerObjectIdentifier IdCamellia128Wrap;
    public static DerObjectIdentifier IdCamellia192Wrap;
    public static DerObjectIdentifier IdCamellia256Wrap;
    private static NttObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse : Asn1Encodable {
    private ResponseData tbsResponseData;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signature;
    private Asn1Sequence certs;
    public ResponseData TbsResponseData { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public Asn1Sequence Certs { get; }
    public BasicOcspResponse(ResponseData tbsResponseData, AlgorithmIdentifier signatureAlgorithm, DerBitString signature, Asn1Sequence certs);
    private BasicOcspResponse(Asn1Sequence seq);
    public static BasicOcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicOcspResponse GetInstance(object obj);
    [ObsoleteAttribute("Use TbsResponseData property instead")]
public ResponseData GetTbsResponseData();
    public ResponseData get_TbsResponseData();
    [ObsoleteAttribute("Use SignatureAlgorithm property instead")]
public AlgorithmIdentifier GetSignatureAlgorithm();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    [ObsoleteAttribute("Use Signature property instead")]
public DerBitString GetSignature();
    public DerBitString get_Signature();
    [ObsoleteAttribute("Use Certs property instead")]
public Asn1Sequence GetCerts();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertID : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString issuerNameHash;
    private Asn1OctetString issuerKeyHash;
    private DerInteger serialNumber;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString IssuerNameHash { get; }
    public Asn1OctetString IssuerKeyHash { get; }
    public DerInteger SerialNumber { get; }
    public CertID(AlgorithmIdentifier hashAlgorithm, Asn1OctetString issuerNameHash, Asn1OctetString issuerKeyHash, DerInteger serialNumber);
    private CertID(Asn1Sequence seq);
    public static CertID GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertID GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_IssuerNameHash();
    public Asn1OctetString get_IssuerKeyHash();
    public DerInteger get_SerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CertStatus : Asn1Encodable {
    private int tagNo;
    private Asn1Encodable value;
    public int TagNo { get; }
    public Asn1Encodable Status { get; }
    public CertStatus(RevokedInfo info);
    public CertStatus(int tagNo, Asn1Encodable value);
    public CertStatus(Asn1TaggedObject choice);
    public static CertStatus GetInstance(object obj);
    public int get_TagNo();
    public Asn1Encodable get_Status();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.CrlID : Asn1Encodable {
    private DerIA5String crlUrl;
    private DerInteger crlNum;
    private DerGeneralizedTime crlTime;
    public DerIA5String CrlUrl { get; }
    public DerInteger CrlNum { get; }
    public DerGeneralizedTime CrlTime { get; }
    public CrlID(Asn1Sequence seq);
    public DerIA5String get_CrlUrl();
    public DerInteger get_CrlNum();
    public DerGeneralizedTime get_CrlTime();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Ocsp.OcspObjectIdentifiers : object {
    internal static string PkixOcspId;
    public static DerObjectIdentifier PkixOcsp;
    public static DerObjectIdentifier PkixOcspBasic;
    public static DerObjectIdentifier PkixOcspNonce;
    public static DerObjectIdentifier PkixOcspCrl;
    public static DerObjectIdentifier PkixOcspResponse;
    public static DerObjectIdentifier PkixOcspNocheck;
    public static DerObjectIdentifier PkixOcspArchiveCutoff;
    public static DerObjectIdentifier PkixOcspServiceLocator;
    private static OcspObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspRequest : Asn1Encodable {
    private TbsRequest tbsRequest;
    private Signature optionalSignature;
    public TbsRequest TbsRequest { get; }
    public Signature OptionalSignature { get; }
    public OcspRequest(TbsRequest tbsRequest, Signature optionalSignature);
    private OcspRequest(Asn1Sequence seq);
    public static OcspRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspRequest GetInstance(object obj);
    public TbsRequest get_TbsRequest();
    public Signature get_OptionalSignature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponse : Asn1Encodable {
    private OcspResponseStatus responseStatus;
    private ResponseBytes responseBytes;
    public OcspResponseStatus ResponseStatus { get; }
    public ResponseBytes ResponseBytes { get; }
    public OcspResponse(OcspResponseStatus responseStatus, ResponseBytes responseBytes);
    private OcspResponse(Asn1Sequence seq);
    public static OcspResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static OcspResponse GetInstance(object obj);
    public OcspResponseStatus get_ResponseStatus();
    public ResponseBytes get_ResponseBytes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus : DerEnumerated {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SignatureRequired;
    public static int Unauthorized;
    public OcspResponseStatus(int value);
    public OcspResponseStatus(DerEnumerated value);
}
public class Org.BouncyCastle.Asn1.Ocsp.Request : Asn1Encodable {
    private CertID reqCert;
    private X509Extensions singleRequestExtensions;
    public CertID ReqCert { get; }
    public X509Extensions SingleRequestExtensions { get; }
    public Request(CertID reqCert, X509Extensions singleRequestExtensions);
    private Request(Asn1Sequence seq);
    public static Request GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Request GetInstance(object obj);
    public CertID get_ReqCert();
    public X509Extensions get_SingleRequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponderID : Asn1Encodable {
    private Asn1Encodable id;
    public ResponderID(Asn1OctetString id);
    public ResponderID(X509Name id);
    public static ResponderID GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseBytes : Asn1Encodable {
    private DerObjectIdentifier responseType;
    private Asn1OctetString response;
    public DerObjectIdentifier ResponseType { get; }
    public Asn1OctetString Response { get; }
    public ResponseBytes(DerObjectIdentifier responseType, Asn1OctetString response);
    private ResponseBytes(Asn1Sequence seq);
    public static ResponseBytes GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseBytes GetInstance(object obj);
    public DerObjectIdentifier get_ResponseType();
    public Asn1OctetString get_Response();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ResponseData : Asn1Encodable {
    private static DerInteger V1;
    private bool versionPresent;
    private DerInteger version;
    private ResponderID responderID;
    private DerGeneralizedTime producedAt;
    private Asn1Sequence responses;
    private X509Extensions responseExtensions;
    public DerInteger Version { get; }
    public ResponderID ResponderID { get; }
    public DerGeneralizedTime ProducedAt { get; }
    public Asn1Sequence Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public ResponseData(DerInteger version, ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    public ResponseData(ResponderID responderID, DerGeneralizedTime producedAt, Asn1Sequence responses, X509Extensions responseExtensions);
    private ResponseData(Asn1Sequence seq);
    private static ResponseData();
    public static ResponseData GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ResponseData GetInstance(object obj);
    public DerInteger get_Version();
    public ResponderID get_ResponderID();
    public DerGeneralizedTime get_ProducedAt();
    public Asn1Sequence get_Responses();
    public X509Extensions get_ResponseExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.RevokedInfo : Asn1Encodable {
    private DerGeneralizedTime revocationTime;
    private CrlReason revocationReason;
    public DerGeneralizedTime RevocationTime { get; }
    public CrlReason RevocationReason { get; }
    public RevokedInfo(DerGeneralizedTime revocationTime);
    public RevokedInfo(DerGeneralizedTime revocationTime, CrlReason revocationReason);
    private RevokedInfo(Asn1Sequence seq);
    public static RevokedInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RevokedInfo GetInstance(object obj);
    public DerGeneralizedTime get_RevocationTime();
    public CrlReason get_RevocationReason();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.ServiceLocator : Asn1Encodable {
    private X509Name issuer;
    private Asn1Object locator;
    public X509Name Issuer { get; }
    public Asn1Object Locator { get; }
    public ServiceLocator(X509Name issuer);
    public ServiceLocator(X509Name issuer, Asn1Object locator);
    private ServiceLocator(Asn1Sequence seq);
    public static ServiceLocator GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ServiceLocator GetInstance(object obj);
    public X509Name get_Issuer();
    public Asn1Object get_Locator();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.Signature : Asn1Encodable {
    internal AlgorithmIdentifier signatureAlgorithm;
    internal DerBitString signatureValue;
    internal Asn1Sequence certs;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public Asn1Sequence Certs { get; }
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    public Signature(AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue, Asn1Sequence certs);
    private Signature(Asn1Sequence seq);
    public static Signature GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Signature GetInstance(object obj);
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public Asn1Sequence get_Certs();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.SingleResponse : Asn1Encodable {
    private CertID certID;
    private CertStatus certStatus;
    private DerGeneralizedTime thisUpdate;
    private DerGeneralizedTime nextUpdate;
    private X509Extensions singleExtensions;
    public CertID CertId { get; }
    public CertStatus CertStatus { get; }
    public DerGeneralizedTime ThisUpdate { get; }
    public DerGeneralizedTime NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResponse(CertID certID, CertStatus certStatus, DerGeneralizedTime thisUpdate, DerGeneralizedTime nextUpdate, X509Extensions singleExtensions);
    public SingleResponse(Asn1Sequence seq);
    public static SingleResponse GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SingleResponse GetInstance(object obj);
    public CertID get_CertId();
    public CertStatus get_CertStatus();
    public DerGeneralizedTime get_ThisUpdate();
    public DerGeneralizedTime get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Ocsp.TbsRequest : Asn1Encodable {
    private static DerInteger V1;
    private DerInteger version;
    private GeneralName requestorName;
    private Asn1Sequence requestList;
    private X509Extensions requestExtensions;
    private bool versionSet;
    public DerInteger Version { get; }
    public GeneralName RequestorName { get; }
    public Asn1Sequence RequestList { get; }
    public X509Extensions RequestExtensions { get; }
    public TbsRequest(GeneralName requestorName, Asn1Sequence requestList, X509Extensions requestExtensions);
    private TbsRequest(Asn1Sequence seq);
    private static TbsRequest();
    public static TbsRequest GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsRequest GetInstance(object obj);
    public DerInteger get_Version();
    public GeneralName get_RequestorName();
    public Asn1Sequence get_RequestList();
    public X509Extensions get_RequestExtensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.OidTokenizer : object {
    private string oid;
    private int index;
    public bool HasMoreTokens { get; }
    public OidTokenizer(string oid);
    public bool get_HasMoreTokens();
    public string NextToken();
}
public class Org.BouncyCastle.Asn1.Oiw.ElGamalParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public ElGamalParameter(BigInteger p, BigInteger g);
    public ElGamalParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Oiw.OiwObjectIdentifiers : object {
    public static DerObjectIdentifier MD4WithRsa;
    public static DerObjectIdentifier MD5WithRsa;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier DesEcb;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesOfb;
    public static DerObjectIdentifier DesCfb;
    public static DerObjectIdentifier DesEde;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier DsaWithSha1;
    public static DerObjectIdentifier Sha1WithRsa;
    public static DerObjectIdentifier ElGamalAlgorithm;
    private static OiwObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.AttributePkcs : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributePkcs(Asn1Sequence seq);
    public AttributePkcs(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributePkcs GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.AuthenticatedSafe : Asn1Encodable {
    private ContentInfo[] info;
    public AuthenticatedSafe(Asn1Sequence seq);
    public AuthenticatedSafe(ContentInfo[] info);
    public ContentInfo[] GetContentInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertBag : Asn1Encodable {
    private Asn1Sequence seq;
    private DerObjectIdentifier certID;
    private Asn1Object certValue;
    public DerObjectIdentifier CertID { get; }
    public Asn1Object CertValue { get; }
    public CertBag(Asn1Sequence seq);
    public CertBag(DerObjectIdentifier certID, Asn1Object certValue);
    public DerObjectIdentifier get_CertID();
    public Asn1Object get_CertValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequest : Asn1Encodable {
    protected CertificationRequestInfo reqInfo;
    protected AlgorithmIdentifier sigAlgId;
    protected DerBitString sigBits;
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public CertificationRequest(CertificationRequestInfo requestInfo, AlgorithmIdentifier algorithm, DerBitString signature);
    public CertificationRequest(Asn1Sequence seq);
    public static CertificationRequest GetInstance(object obj);
    public CertificationRequestInfo GetCertificationRequestInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo : Asn1Encodable {
    internal DerInteger version;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPKInfo;
    internal Asn1Set attributes;
    public DerInteger Version { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public Asn1Set Attributes { get; }
    public CertificationRequestInfo(X509Name subject, SubjectPublicKeyInfo pkInfo, Asn1Set attributes);
    private CertificationRequestInfo(Asn1Sequence seq);
    public static CertificationRequestInfo GetInstance(object obj);
    public DerInteger get_Version();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.ContentInfo : Asn1Encodable {
    private DerObjectIdentifier contentType;
    private Asn1Encodable content;
    public DerObjectIdentifier ContentType { get; }
    public Asn1Encodable Content { get; }
    private ContentInfo(Asn1Sequence seq);
    public ContentInfo(DerObjectIdentifier contentType, Asn1Encodable content);
    public static ContentInfo GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public Asn1Encodable get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.DHParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger g;
    internal DerInteger l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger L { get; }
    public DHParameter(BigInteger p, BigInteger g, int l);
    public DHParameter(Asn1Sequence seq);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_L();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedData : Asn1Encodable {
    private Asn1Sequence data;
    public DerObjectIdentifier ContentType { get; }
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    public Asn1OctetString Content { get; }
    private EncryptedData(Asn1Sequence seq);
    public EncryptedData(DerObjectIdentifier contentType, AlgorithmIdentifier encryptionAlgorithm, Asn1Encodable content);
    public static EncryptedData GetInstance(object obj);
    public DerObjectIdentifier get_ContentType();
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Asn1OctetString get_Content();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algId;
    private Asn1OctetString data;
    public AlgorithmIdentifier EncryptionAlgorithm { get; }
    private EncryptedPrivateKeyInfo(Asn1Sequence seq);
    public EncryptedPrivateKeyInfo(AlgorithmIdentifier algId, Byte[] encoding);
    public static EncryptedPrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_EncryptionAlgorithm();
    public Byte[] GetEncryptedData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.EncryptionScheme : AlgorithmIdentifier {
    private Asn1Object objectID;
    private Asn1Object obj;
    public Asn1Object Asn1Object { get; }
    internal EncryptionScheme(Asn1Sequence seq);
    public Asn1Object get_Asn1Object();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.IssuerAndSerialNumber : Asn1Encodable {
    private X509Name name;
    private DerInteger certSerialNumber;
    public X509Name Name { get; }
    public DerInteger CertificateSerialNumber { get; }
    private IssuerAndSerialNumber(Asn1Sequence seq);
    public IssuerAndSerialNumber(X509Name name, BigInteger certSerialNumber);
    public IssuerAndSerialNumber(X509Name name, DerInteger certSerialNumber);
    public static IssuerAndSerialNumber GetInstance(object obj);
    public X509Name get_Name();
    public DerInteger get_CertificateSerialNumber();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.KeyDerivationFunc : AlgorithmIdentifier {
    internal KeyDerivationFunc(Asn1Sequence seq);
    internal KeyDerivationFunc(DerObjectIdentifier id, Asn1Encodable parameters);
}
public class Org.BouncyCastle.Asn1.Pkcs.MacData : Asn1Encodable {
    internal DigestInfo digInfo;
    internal Byte[] salt;
    internal BigInteger iterationCount;
    public DigestInfo Mac { get; }
    public BigInteger IterationCount { get; }
    private MacData(Asn1Sequence seq);
    public MacData(DigestInfo digInfo, Byte[] salt, int iterationCount);
    public static MacData GetInstance(object obj);
    public DigestInfo get_Mac();
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeParameter : Asn1Encodable {
    private Asn1OctetString octStr;
    private DerInteger iterationCount;
    public BigInteger IterationCount { get; }
    private PbeParameter(Asn1Sequence seq);
    public PbeParameter(Byte[] salt, int iterationCount);
    public static PbeParameter GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.PbeS2Parameters : Asn1Encodable {
    private KeyDerivationFunc func;
    private EncryptionScheme scheme;
    public KeyDerivationFunc KeyDerivationFunc { get; }
    public EncryptionScheme EncryptionScheme { get; }
    public PbeS2Parameters(Asn1Sequence seq);
    public static PbeS2Parameters GetInstance(object obj);
    public KeyDerivationFunc get_KeyDerivationFunc();
    public EncryptionScheme get_EncryptionScheme();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pbkdf2Params : Asn1Encodable {
    private Asn1OctetString octStr;
    private DerInteger iterationCount;
    private DerInteger keyLength;
    public BigInteger IterationCount { get; }
    public BigInteger KeyLength { get; }
    public Pbkdf2Params(Asn1Sequence seq);
    public Pbkdf2Params(Byte[] salt, int iterationCount);
    public static Pbkdf2Params GetInstance(object obj);
    public Byte[] GetSalt();
    public BigInteger get_IterationCount();
    public BigInteger get_KeyLength();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pfx : Asn1Encodable {
    private ContentInfo contentInfo;
    private MacData macData;
    public ContentInfo AuthSafe { get; }
    public MacData MacData { get; }
    public Pfx(Asn1Sequence seq);
    public Pfx(ContentInfo contentInfo, MacData macData);
    public ContentInfo get_AuthSafe();
    public MacData get_MacData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.Pkcs12PbeParams : Asn1Encodable {
    private DerInteger iterations;
    private Asn1OctetString iv;
    public BigInteger Iterations { get; }
    public Pkcs12PbeParams(Byte[] salt, int iterations);
    private Pkcs12PbeParams(Asn1Sequence seq);
    public static Pkcs12PbeParams GetInstance(object obj);
    public BigInteger get_Iterations();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers : object {
    public static string Pkcs1;
    public static string Pkcs3;
    public static string Pkcs5;
    public static string EncryptionAlgorithm;
    public static string DigestAlgorithm;
    public static string Pkcs7;
    public static string Pkcs9;
    public static string CertTypes;
    public static string CrlTypes;
    public static string IdCT;
    public static string IdCti;
    public static string IdAA;
    public static string IdSpq;
    public static string Pkcs12;
    public static string BagTypes;
    public static string Pkcs12PbeIds;
    public static DerObjectIdentifier RsaEncryption;
    public static DerObjectIdentifier MD2WithRsaEncryption;
    public static DerObjectIdentifier MD4WithRsaEncryption;
    public static DerObjectIdentifier MD5WithRsaEncryption;
    public static DerObjectIdentifier Sha1WithRsaEncryption;
    public static DerObjectIdentifier SrsaOaepEncryptionSet;
    public static DerObjectIdentifier IdRsaesOaep;
    public static DerObjectIdentifier IdMgf1;
    public static DerObjectIdentifier IdPSpecified;
    public static DerObjectIdentifier IdRsassaPss;
    public static DerObjectIdentifier Sha256WithRsaEncryption;
    public static DerObjectIdentifier Sha384WithRsaEncryption;
    public static DerObjectIdentifier Sha512WithRsaEncryption;
    public static DerObjectIdentifier Sha224WithRsaEncryption;
    public static DerObjectIdentifier DhKeyAgreement;
    public static DerObjectIdentifier PbeWithMD2AndDesCbc;
    public static DerObjectIdentifier PbeWithMD2AndRC2Cbc;
    public static DerObjectIdentifier PbeWithMD5AndDesCbc;
    public static DerObjectIdentifier PbeWithMD5AndRC2Cbc;
    public static DerObjectIdentifier PbeWithSha1AndDesCbc;
    public static DerObjectIdentifier PbeWithSha1AndRC2Cbc;
    public static DerObjectIdentifier IdPbeS2;
    public static DerObjectIdentifier IdPbkdf2;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    public static DerObjectIdentifier MD2;
    public static DerObjectIdentifier MD4;
    public static DerObjectIdentifier MD5;
    public static DerObjectIdentifier IdHmacWithSha1;
    public static DerObjectIdentifier IdHmacWithSha224;
    public static DerObjectIdentifier IdHmacWithSha256;
    public static DerObjectIdentifier IdHmacWithSha384;
    public static DerObjectIdentifier IdHmacWithSha512;
    public static DerObjectIdentifier Data;
    public static DerObjectIdentifier SignedData;
    public static DerObjectIdentifier EnvelopedData;
    public static DerObjectIdentifier SignedAndEnvelopedData;
    public static DerObjectIdentifier DigestedData;
    public static DerObjectIdentifier EncryptedData;
    public static DerObjectIdentifier Pkcs9AtEmailAddress;
    public static DerObjectIdentifier Pkcs9AtUnstructuredName;
    public static DerObjectIdentifier Pkcs9AtContentType;
    public static DerObjectIdentifier Pkcs9AtMessageDigest;
    public static DerObjectIdentifier Pkcs9AtSigningTime;
    public static DerObjectIdentifier Pkcs9AtCounterSignature;
    public static DerObjectIdentifier Pkcs9AtChallengePassword;
    public static DerObjectIdentifier Pkcs9AtUnstructuredAddress;
    public static DerObjectIdentifier Pkcs9AtExtendedCertificateAttributes;
    public static DerObjectIdentifier Pkcs9AtSigningDescription;
    public static DerObjectIdentifier Pkcs9AtExtensionRequest;
    public static DerObjectIdentifier Pkcs9AtSmimeCapabilities;
    public static DerObjectIdentifier Pkcs9AtFriendlyName;
    public static DerObjectIdentifier Pkcs9AtLocalKeyID;
    [ObsoleteAttribute("Use X509Certificate instead")]
public static DerObjectIdentifier X509CertType;
    public static DerObjectIdentifier X509Certificate;
    public static DerObjectIdentifier SdsiCertificate;
    public static DerObjectIdentifier X509Crl;
    public static DerObjectIdentifier IdAlgPwriKek;
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier IdAAReceiptRequest;
    public static DerObjectIdentifier IdCTAuthData;
    public static DerObjectIdentifier IdCTTstInfo;
    public static DerObjectIdentifier IdCTCompressedData;
    public static DerObjectIdentifier IdCtiEtsProofOfOrigin;
    public static DerObjectIdentifier IdCtiEtsProofOfReceipt;
    public static DerObjectIdentifier IdCtiEtsProofOfDelivery;
    public static DerObjectIdentifier IdCtiEtsProofOfSender;
    public static DerObjectIdentifier IdCtiEtsProofOfApproval;
    public static DerObjectIdentifier IdCtiEtsProofOfCreation;
    public static DerObjectIdentifier IdAAContentHint;
    public static DerObjectIdentifier IdAAEncrypKeyPref;
    public static DerObjectIdentifier IdAASigningCertificate;
    public static DerObjectIdentifier IdAASigningCertificateV2;
    public static DerObjectIdentifier IdAAContentIdentifier;
    public static DerObjectIdentifier IdAASignatureTimeStampToken;
    public static DerObjectIdentifier IdAAEtsSigPolicyID;
    public static DerObjectIdentifier IdAAEtsCommitmentType;
    public static DerObjectIdentifier IdAAEtsSignerLocation;
    public static DerObjectIdentifier IdAAEtsSignerAttr;
    public static DerObjectIdentifier IdAAEtsOtherSigCert;
    public static DerObjectIdentifier IdAAEtsContentTimestamp;
    public static DerObjectIdentifier IdAAEtsCertificateRefs;
    public static DerObjectIdentifier IdAAEtsRevocationRefs;
    public static DerObjectIdentifier IdAAEtsCertValues;
    public static DerObjectIdentifier IdAAEtsRevocationValues;
    public static DerObjectIdentifier IdAAEtsEscTimeStamp;
    public static DerObjectIdentifier IdAAEtsCertCrlTimestamp;
    public static DerObjectIdentifier IdAAEtsArchiveTimestamp;
    [ObsoleteAttribute("Use 'IdAAEtsSigPolicyID' instead")]
public static DerObjectIdentifier IdAASigPolicyID;
    [ObsoleteAttribute("Use 'IdAAEtsCommitmentType' instead")]
public static DerObjectIdentifier IdAACommitmentType;
    [ObsoleteAttribute("Use 'IdAAEtsSignerLocation' instead")]
public static DerObjectIdentifier IdAASignerLocation;
    [ObsoleteAttribute("Use 'IdAAEtsOtherSigCert' instead")]
public static DerObjectIdentifier IdAAOtherSigCert;
    public static DerObjectIdentifier IdSpqEtsUri;
    public static DerObjectIdentifier IdSpqEtsUNotice;
    public static DerObjectIdentifier KeyBag;
    public static DerObjectIdentifier Pkcs8ShroudedKeyBag;
    public static DerObjectIdentifier CertBag;
    public static DerObjectIdentifier CrlBag;
    public static DerObjectIdentifier SecretBag;
    public static DerObjectIdentifier SafeContentsBag;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd40BitRC4;
    public static DerObjectIdentifier PbeWithShaAnd3KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd2KeyTripleDesCbc;
    public static DerObjectIdentifier PbeWithShaAnd128BitRC2Cbc;
    public static DerObjectIdentifier PbewithShaAnd40BitRC2Cbc;
    public static DerObjectIdentifier IdAlgCms3DesWrap;
    public static DerObjectIdentifier IdAlgCmsRC2Wrap;
    private static PkcsObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo : Asn1Encodable {
    private Asn1Object privKey;
    private AlgorithmIdentifier algID;
    private Asn1Set attributes;
    public AlgorithmIdentifier AlgorithmID { get; }
    public Asn1Object PrivateKey { get; }
    public Asn1Set Attributes { get; }
    public PrivateKeyInfo(AlgorithmIdentifier algID, Asn1Object privateKey);
    public PrivateKeyInfo(AlgorithmIdentifier algID, Asn1Object privateKey, Asn1Set attributes);
    private PrivateKeyInfo(Asn1Sequence seq);
    public static PrivateKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object get_PrivateKey();
    public Asn1Set get_Attributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RC2CbcParameter : Asn1Encodable {
    internal DerInteger version;
    internal Asn1OctetString iv;
    public BigInteger RC2ParameterVersion { get; }
    public RC2CbcParameter(Byte[] iv);
    public RC2CbcParameter(int parameterVersion, Byte[] iv);
    private RC2CbcParameter(Asn1Sequence seq);
    public static RC2CbcParameter GetInstance(object obj);
    public BigInteger get_RC2ParameterVersion();
    public Byte[] GetIV();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private AlgorithmIdentifier pSourceAlgorithm;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static AlgorithmIdentifier DefaultPSourceAlgorithm;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public AlgorithmIdentifier PSourceAlgorithm { get; }
    public RsaesOaepParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, AlgorithmIdentifier pSourceAlgorithm);
    public RsaesOaepParameters(Asn1Sequence seq);
    private static RsaesOaepParameters();
    public static RsaesOaepParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public AlgorithmIdentifier get_PSourceAlgorithm();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    private BigInteger privateExponent;
    private BigInteger prime1;
    private BigInteger prime2;
    private BigInteger exponent1;
    private BigInteger exponent2;
    private BigInteger coefficient;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger Prime1 { get; }
    public BigInteger Prime2 { get; }
    public BigInteger Exponent1 { get; }
    public BigInteger Exponent2 { get; }
    public BigInteger Coefficient { get; }
    public RsaPrivateKeyStructure(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger prime1, BigInteger prime2, BigInteger exponent1, BigInteger exponent2, BigInteger coefficient);
    public RsaPrivateKeyStructure(Asn1Sequence seq);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public BigInteger get_PrivateExponent();
    public BigInteger get_Prime1();
    public BigInteger get_Prime2();
    public BigInteger get_Exponent1();
    public BigInteger get_Exponent2();
    public BigInteger get_Coefficient();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private AlgorithmIdentifier maskGenAlgorithm;
    private DerInteger saltLength;
    private DerInteger trailerField;
    public static AlgorithmIdentifier DefaultHashAlgorithm;
    public static AlgorithmIdentifier DefaultMaskGenFunction;
    public static DerInteger DefaultSaltLength;
    public static DerInteger DefaultTrailerField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public AlgorithmIdentifier MaskGenAlgorithm { get; }
    public DerInteger SaltLength { get; }
    public DerInteger TrailerField { get; }
    public RsassaPssParameters(AlgorithmIdentifier hashAlgorithm, AlgorithmIdentifier maskGenAlgorithm, DerInteger saltLength, DerInteger trailerField);
    public RsassaPssParameters(Asn1Sequence seq);
    private static RsassaPssParameters();
    public static RsassaPssParameters GetInstance(object obj);
    public AlgorithmIdentifier get_HashAlgorithm();
    public AlgorithmIdentifier get_MaskGenAlgorithm();
    public DerInteger get_SaltLength();
    public DerInteger get_TrailerField();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SafeBag : Asn1Encodable {
    private DerObjectIdentifier bagID;
    private Asn1Object bagValue;
    private Asn1Set bagAttributes;
    public DerObjectIdentifier BagID { get; }
    public Asn1Object BagValue { get; }
    public Asn1Set BagAttributes { get; }
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj);
    public SafeBag(DerObjectIdentifier oid, Asn1Object obj, Asn1Set bagAttributes);
    public SafeBag(Asn1Sequence seq);
    public DerObjectIdentifier get_BagID();
    public Asn1Object get_BagValue();
    public Asn1Set get_BagAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignedData : Asn1Encodable {
    private DerInteger version;
    private Asn1Set digestAlgorithms;
    private ContentInfo contentInfo;
    private Asn1Set certificates;
    private Asn1Set crls;
    private Asn1Set signerInfos;
    public DerInteger Version { get; }
    public Asn1Set DigestAlgorithms { get; }
    public ContentInfo ContentInfo { get; }
    public Asn1Set Certificates { get; }
    public Asn1Set Crls { get; }
    public Asn1Set SignerInfos { get; }
    public SignedData(DerInteger _version, Asn1Set _digestAlgorithms, ContentInfo _contentInfo, Asn1Set _certificates, Asn1Set _crls, Asn1Set _signerInfos);
    private SignedData(Asn1Sequence seq);
    public static SignedData GetInstance(object obj);
    public DerInteger get_Version();
    public Asn1Set get_DigestAlgorithms();
    public ContentInfo get_ContentInfo();
    public Asn1Set get_Certificates();
    public Asn1Set get_Crls();
    public Asn1Set get_SignerInfos();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Pkcs.SignerInfo : Asn1Encodable {
    private DerInteger version;
    private IssuerAndSerialNumber issuerAndSerialNumber;
    private AlgorithmIdentifier digAlgorithm;
    private Asn1Set authenticatedAttributes;
    private AlgorithmIdentifier digEncryptionAlgorithm;
    private Asn1OctetString encryptedDigest;
    private Asn1Set unauthenticatedAttributes;
    public DerInteger Version { get; }
    public IssuerAndSerialNumber IssuerAndSerialNumber { get; }
    public Asn1Set AuthenticatedAttributes { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public Asn1OctetString EncryptedDigest { get; }
    public AlgorithmIdentifier DigestEncryptionAlgorithm { get; }
    public Asn1Set UnauthenticatedAttributes { get; }
    public SignerInfo(DerInteger version, IssuerAndSerialNumber issuerAndSerialNumber, AlgorithmIdentifier digAlgorithm, Asn1Set authenticatedAttributes, AlgorithmIdentifier digEncryptionAlgorithm, Asn1OctetString encryptedDigest, Asn1Set unauthenticatedAttributes);
    public SignerInfo(Asn1Sequence seq);
    public static SignerInfo GetInstance(object obj);
    public DerInteger get_Version();
    public IssuerAndSerialNumber get_IssuerAndSerialNumber();
    public Asn1Set get_AuthenticatedAttributes();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public Asn1OctetString get_EncryptedDigest();
    public AlgorithmIdentifier get_DigestEncryptionAlgorithm();
    public Asn1Set get_UnauthenticatedAttributes();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure : Asn1Encodable {
    private Asn1Sequence seq;
    public ECPrivateKeyStructure(Asn1Sequence seq);
    public ECPrivateKeyStructure(BigInteger key);
    public BigInteger GetKey();
    public DerBitString GetPublicKey();
    public Asn1Object GetParameters();
    private Asn1Object GetObjectInTag(int tagNo);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Sec.SecNamedCurves : object {
    private static Hashtable objIds;
    private static Hashtable curves;
    private static Hashtable names;
    public static IEnumerable Names { get; }
    private static SecNamedCurves();
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public abstract class Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers : object {
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier SecT163k1;
    public static DerObjectIdentifier SecT163r1;
    public static DerObjectIdentifier SecT239k1;
    public static DerObjectIdentifier SecT113r1;
    public static DerObjectIdentifier SecT113r2;
    public static DerObjectIdentifier SecP112r1;
    public static DerObjectIdentifier SecP112r2;
    public static DerObjectIdentifier SecP160r1;
    public static DerObjectIdentifier SecP160k1;
    public static DerObjectIdentifier SecP256k1;
    public static DerObjectIdentifier SecT163r2;
    public static DerObjectIdentifier SecT283k1;
    public static DerObjectIdentifier SecT283r1;
    public static DerObjectIdentifier SecT131r1;
    public static DerObjectIdentifier SecT131r2;
    public static DerObjectIdentifier SecT193r1;
    public static DerObjectIdentifier SecT193r2;
    public static DerObjectIdentifier SecT233k1;
    public static DerObjectIdentifier SecT233r1;
    public static DerObjectIdentifier SecP128r1;
    public static DerObjectIdentifier SecP128r2;
    public static DerObjectIdentifier SecP160r2;
    public static DerObjectIdentifier SecP192k1;
    public static DerObjectIdentifier SecP224k1;
    public static DerObjectIdentifier SecP224r1;
    public static DerObjectIdentifier SecP384r1;
    public static DerObjectIdentifier SecP521r1;
    public static DerObjectIdentifier SecT409k1;
    public static DerObjectIdentifier SecT409r1;
    public static DerObjectIdentifier SecT571k1;
    public static DerObjectIdentifier SecT571r1;
    public static DerObjectIdentifier SecP192r1;
    public static DerObjectIdentifier SecP256r1;
    private static SecObjectIdentifiers();
}
public abstract class Org.BouncyCastle.Asn1.Smime.SmimeAttributes : object {
    public static DerObjectIdentifier SmimeCapabilities;
    public static DerObjectIdentifier EncrypKeyPref;
    private static SmimeAttributes();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilities : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private Asn1Sequence capabilities;
    public SmimeCapabilities(Asn1Sequence seq);
    private static SmimeCapabilities();
    public static SmimeCapabilities GetInstance(object obj);
    public ArrayList GetCapabilities(DerObjectIdentifier capability);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilitiesAttribute : AttributeX509 {
    public SmimeCapabilitiesAttribute(SmimeCapabilityVector capabilities);
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapability : Asn1Encodable {
    public static DerObjectIdentifier PreferSignedData;
    public static DerObjectIdentifier CannotDecryptAny;
    public static DerObjectIdentifier SmimeCapabilitiesVersions;
    public static DerObjectIdentifier DesCbc;
    public static DerObjectIdentifier DesEde3Cbc;
    public static DerObjectIdentifier RC2Cbc;
    private DerObjectIdentifier capabilityID;
    private Asn1Object parameters;
    public DerObjectIdentifier CapabilityID { get; }
    public Asn1Object Parameters { get; }
    public SmimeCapability(Asn1Sequence seq);
    public SmimeCapability(DerObjectIdentifier capabilityID, Asn1Encodable parameters);
    private static SmimeCapability();
    public static SmimeCapability GetInstance(object obj);
    public DerObjectIdentifier get_CapabilityID();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector : object {
    private Asn1EncodableVector capabilities;
    public void AddCapability(DerObjectIdentifier capability);
    public void AddCapability(DerObjectIdentifier capability, int value);
    public void AddCapability(DerObjectIdentifier capability, Asn1Encodable parameters);
    public Asn1EncodableVector ToAsn1EncodableVector();
}
public class Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute : AttributeX509 {
    public SmimeEncryptionKeyPreferenceAttribute(IssuerAndSerialNumber issAndSer);
    public SmimeEncryptionKeyPreferenceAttribute(RecipientKeyIdentifier rKeyID);
    public SmimeEncryptionKeyPreferenceAttribute(Asn1OctetString sKeyID);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves : object {
    private static Hashtable objIds;
    private static Hashtable curves;
    private static Hashtable names;
    public static IEnumerable Names { get; }
    private static TeleTrusTNamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
    public static DerObjectIdentifier GetOid(short curvesize, bool twisted);
}
public class Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTObjectIdentifiers : object {
    public static DerObjectIdentifier TeleTrusTAlgorithm;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD128;
    public static DerObjectIdentifier RipeMD256;
    public static DerObjectIdentifier TeleTrusTRsaSignatureAlgorithm;
    public static DerObjectIdentifier RsaSignatureWithRipeMD160;
    public static DerObjectIdentifier RsaSignatureWithRipeMD128;
    public static DerObjectIdentifier RsaSignatureWithRipeMD256;
    public static DerObjectIdentifier ECSign;
    public static DerObjectIdentifier ECSignWithSha1;
    public static DerObjectIdentifier ECSignWithRipeMD160;
    public static DerObjectIdentifier EccBrainpool;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier VersionOne;
    public static DerObjectIdentifier BrainpoolP160R1;
    public static DerObjectIdentifier BrainpoolP160T1;
    public static DerObjectIdentifier BrainpoolP192R1;
    public static DerObjectIdentifier BrainpoolP192T1;
    public static DerObjectIdentifier BrainpoolP224R1;
    public static DerObjectIdentifier BrainpoolP224T1;
    public static DerObjectIdentifier BrainpoolP256R1;
    public static DerObjectIdentifier BrainpoolP256T1;
    public static DerObjectIdentifier BrainpoolP320R1;
    public static DerObjectIdentifier BrainpoolP320T1;
    public static DerObjectIdentifier BrainpoolP384R1;
    public static DerObjectIdentifier BrainpoolP384T1;
    public static DerObjectIdentifier BrainpoolP512R1;
    public static DerObjectIdentifier BrainpoolP512T1;
    private static TeleTrusTObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.Tsp.Accuracy : Asn1Encodable {
    protected static int MinMillis;
    protected static int MaxMillis;
    protected static int MinMicros;
    protected static int MaxMicros;
    private DerInteger seconds;
    private DerInteger millis;
    private DerInteger micros;
    public DerInteger Seconds { get; }
    public DerInteger Millis { get; }
    public DerInteger Micros { get; }
    public Accuracy(DerInteger seconds, DerInteger millis, DerInteger micros);
    private Accuracy(Asn1Sequence seq);
    public static Accuracy GetInstance(object o);
    public DerInteger get_Seconds();
    public DerInteger get_Millis();
    public DerInteger get_Micros();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.MessageImprint : Asn1Encodable {
    private AlgorithmIdentifier hashAlgorithm;
    private Byte[] hashedMessage;
    public AlgorithmIdentifier HashAlgorithm { get; }
    private MessageImprint(Asn1Sequence seq);
    public MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    public static MessageImprint GetInstance(object o);
    public AlgorithmIdentifier get_HashAlgorithm();
    public Byte[] GetHashedMessage();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampReq : Asn1Encodable {
    private DerInteger version;
    private MessageImprint messageImprint;
    private DerObjectIdentifier tsaPolicy;
    private DerInteger nonce;
    private DerBoolean certReq;
    private X509Extensions extensions;
    public DerInteger Version { get; }
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier ReqPolicy { get; }
    public DerInteger Nonce { get; }
    public DerBoolean CertReq { get; }
    public X509Extensions Extensions { get; }
    private TimeStampReq(Asn1Sequence seq);
    public TimeStampReq(MessageImprint messageImprint, DerObjectIdentifier tsaPolicy, DerInteger nonce, DerBoolean certReq, X509Extensions extensions);
    public static TimeStampReq GetInstance(object o);
    public DerInteger get_Version();
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_ReqPolicy();
    public DerInteger get_Nonce();
    public DerBoolean get_CertReq();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TimeStampResp : Asn1Encodable {
    private PkiStatusInfo pkiStatusInfo;
    private ContentInfo timeStampToken;
    public PkiStatusInfo Status { get; }
    public ContentInfo TimeStampToken { get; }
    private TimeStampResp(Asn1Sequence seq);
    public TimeStampResp(PkiStatusInfo pkiStatusInfo, ContentInfo timeStampToken);
    public static TimeStampResp GetInstance(object o);
    public PkiStatusInfo get_Status();
    public ContentInfo get_TimeStampToken();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Tsp.TstInfo : Asn1Encodable {
    private DerInteger version;
    private DerObjectIdentifier tsaPolicyId;
    private MessageImprint messageImprint;
    private DerInteger serialNumber;
    private DerGeneralizedTime genTime;
    private Accuracy accuracy;
    private DerBoolean ordering;
    private DerInteger nonce;
    private GeneralName tsa;
    private X509Extensions extensions;
    public MessageImprint MessageImprint { get; }
    public DerObjectIdentifier Policy { get; }
    public DerInteger SerialNumber { get; }
    public Accuracy Accuracy { get; }
    public DerGeneralizedTime GenTime { get; }
    public DerBoolean Ordering { get; }
    public DerInteger Nonce { get; }
    public GeneralName Tsa { get; }
    public X509Extensions Extensions { get; }
    private TstInfo(Asn1Sequence seq);
    public TstInfo(DerObjectIdentifier tsaPolicyId, MessageImprint messageImprint, DerInteger serialNumber, DerGeneralizedTime genTime, Accuracy accuracy, DerBoolean ordering, DerInteger nonce, GeneralName tsa, X509Extensions extensions);
    public static TstInfo GetInstance(object o);
    public MessageImprint get_MessageImprint();
    public DerObjectIdentifier get_Policy();
    public DerInteger get_SerialNumber();
    public Accuracy get_Accuracy();
    public DerGeneralizedTime get_GenTime();
    public DerBoolean get_Ordering();
    public DerInteger get_Nonce();
    public GeneralName get_Tsa();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.Utilities.Asn1Dump : object {
    private static string Tab;
    private static int SampleSize;
    private static string NewLine;
    private static Asn1Dump();
    private static string AsString(string indent, bool verbose, Asn1Object obj);
    private static string outputApplicationSpecific(string type, string indent, bool verbose, DerApplicationSpecific app);
    [ObsoleteAttribute("Use version accepting Asn1Encodable")]
public static string DumpAsString(object obj);
    public static string DumpAsString(Asn1Encodable obj);
    public static string DumpAsString(Asn1Encodable obj, bool verbose);
    private static string dumpBinaryDataAsString(string indent, Byte[] bytes);
    private static string calculateAscString(Byte[] bytes, int off, int len);
}
public class Org.BouncyCastle.Asn1.Utilities.Dump : object {
    public static void Main(String[] args);
}
public class Org.BouncyCastle.Asn1.Utilities.FilterStream : Stream {
    private Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class Org.BouncyCastle.Asn1.X500.DirectoryString : Asn1Encodable {
    private DerStringBase str;
    private DirectoryString(DerStringBase str);
    public DirectoryString(string str);
    public static DirectoryString GetInstance(object obj);
    public static DirectoryString GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public sealed virtual string GetString();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AccessDescription : Asn1Encodable {
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    private DerObjectIdentifier accessMethod;
    private GeneralName accessLocation;
    public DerObjectIdentifier AccessMethod { get; }
    public GeneralName AccessLocation { get; }
    private AccessDescription(Asn1Sequence seq);
    public AccessDescription(DerObjectIdentifier oid, GeneralName location);
    private static AccessDescription();
    public static AccessDescription GetInstance(object obj);
    public DerObjectIdentifier get_AccessMethod();
    public GeneralName get_AccessLocation();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier : Asn1Encodable {
    private DerObjectIdentifier objectID;
    private Asn1Encodable parameters;
    public DerObjectIdentifier ObjectID { get; }
    public Asn1Encodable Parameters { get; }
    public AlgorithmIdentifier(DerObjectIdentifier objectID);
    public AlgorithmIdentifier(string objectID);
    public AlgorithmIdentifier(DerObjectIdentifier objectID, Asn1Encodable parameters);
    internal AlgorithmIdentifier(Asn1Sequence seq);
    public static AlgorithmIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AlgorithmIdentifier GetInstance(object obj);
    public virtual DerObjectIdentifier get_ObjectID();
    public Asn1Encodable get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertIssuer : Asn1Encodable {
    internal Asn1Encodable obj;
    internal Asn1Object choiceObj;
    public Asn1Encodable Issuer { get; }
    public AttCertIssuer(GeneralNames names);
    public AttCertIssuer(V2Form v2Form);
    public static AttCertIssuer GetInstance(object obj);
    public static AttCertIssuer GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public Asn1Encodable get_Issuer();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod : Asn1Encodable {
    private DerGeneralizedTime notBeforeTime;
    private DerGeneralizedTime notAfterTime;
    public DerGeneralizedTime NotBeforeTime { get; }
    public DerGeneralizedTime NotAfterTime { get; }
    private AttCertValidityPeriod(Asn1Sequence seq);
    public AttCertValidityPeriod(DerGeneralizedTime notBeforeTime, DerGeneralizedTime notAfterTime);
    public static AttCertValidityPeriod GetInstance(object obj);
    public static AttCertValidityPeriod GetInstance(Asn1TaggedObject obj, bool explicitly);
    public DerGeneralizedTime get_NotBeforeTime();
    public DerGeneralizedTime get_NotAfterTime();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificate : Asn1Encodable {
    private AttributeCertificateInfo acinfo;
    private AlgorithmIdentifier signatureAlgorithm;
    private DerBitString signatureValue;
    public AttributeCertificateInfo ACInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString SignatureValue { get; }
    public AttributeCertificate(AttributeCertificateInfo acinfo, AlgorithmIdentifier signatureAlgorithm, DerBitString signatureValue);
    private AttributeCertificate(Asn1Sequence seq);
    public static AttributeCertificate GetInstance(object obj);
    public AttributeCertificateInfo get_ACInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_SignatureValue();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo : Asn1Encodable {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal AttCertValidityPeriod attrCertValidityPeriod;
    internal Asn1Sequence attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    public DerInteger Version { get; }
    public Holder Holder { get; }
    public AttCertIssuer Issuer { get; }
    public AlgorithmIdentifier Signature { get; }
    public DerInteger SerialNumber { get; }
    public AttCertValidityPeriod AttrCertValidityPeriod { get; }
    public Asn1Sequence Attributes { get; }
    public DerBitString IssuerUniqueID { get; }
    public X509Extensions Extensions { get; }
    private AttributeCertificateInfo(Asn1Sequence seq);
    public static AttributeCertificateInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public static AttributeCertificateInfo GetInstance(object obj);
    public DerInteger get_Version();
    public Holder get_Holder();
    public AttCertIssuer get_Issuer();
    public AlgorithmIdentifier get_Signature();
    public DerInteger get_SerialNumber();
    public AttCertValidityPeriod get_AttrCertValidityPeriod();
    public Asn1Sequence get_Attributes();
    public DerBitString get_IssuerUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AttributeTable : object {
    private Hashtable attributes;
    public AttributeTable(Hashtable attrs);
    public AttributeTable(Asn1EncodableVector v);
    public AttributeTable(Asn1Set s);
    public AttributeX509 Get(DerObjectIdentifier oid);
    public Hashtable ToHashtable();
}
public class Org.BouncyCastle.Asn1.X509.AttributeX509 : Asn1Encodable {
    private DerObjectIdentifier attrType;
    private Asn1Set attrValues;
    public DerObjectIdentifier AttrType { get; }
    public Asn1Set AttrValues { get; }
    private AttributeX509(Asn1Sequence seq);
    public AttributeX509(DerObjectIdentifier attrType, Asn1Set attrValues);
    public static AttributeX509 GetInstance(object obj);
    public DerObjectIdentifier get_AttrType();
    public Asn1Set get_AttrValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess : Asn1Encodable {
    private AccessDescription[] descriptions;
    private AuthorityInformationAccess(Asn1Sequence seq);
    [ObsoleteAttribute("Use version taking an AccessDescription instead")]
public AuthorityInformationAccess(DerObjectIdentifier oid, GeneralName location);
    public AuthorityInformationAccess(AccessDescription description);
    public static AuthorityInformationAccess GetInstance(object obj);
    public AccessDescription[] GetAccessDescriptions();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier : Asn1Encodable {
    internal Asn1OctetString keyidentifier;
    internal GeneralNames certissuer;
    internal DerInteger certserno;
    public GeneralNames AuthorityCertIssuer { get; }
    public BigInteger AuthorityCertSerialNumber { get; }
    protected internal AuthorityKeyIdentifier(Asn1Sequence seq);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki);
    public AuthorityKeyIdentifier(SubjectPublicKeyInfo spki, GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(GeneralNames name, BigInteger serialNumber);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier);
    public AuthorityKeyIdentifier(Byte[] keyIdentifier, GeneralNames name, BigInteger serialNumber);
    public static AuthorityKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static AuthorityKeyIdentifier GetInstance(object obj);
    public Byte[] GetKeyIdentifier();
    public GeneralNames get_AuthorityCertIssuer();
    public BigInteger get_AuthorityCertSerialNumber();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.BasicConstraints : Asn1Encodable {
    private DerBoolean cA;
    private DerInteger pathLenConstraint;
    public BigInteger PathLenConstraint { get; }
    private BasicConstraints(Asn1Sequence seq);
    public BasicConstraints(bool cA);
    public BasicConstraints(int pathLenConstraint);
    public static BasicConstraints GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static BasicConstraints GetInstance(object obj);
    public bool IsCA();
    public BigInteger get_PathLenConstraint();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CertificateList : Asn1Encodable {
    private TbsCertificateList tbsCertList;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateList TbsCertList { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public int Version { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    private CertificateList(Asn1Sequence seq);
    public static CertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CertificateList GetInstance(object obj);
    public TbsCertificateList get_TbsCertList();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public int get_Version();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CertificatePair : Asn1Encodable {
    private X509CertificateStructure forward;
    private X509CertificateStructure reverse;
    public X509CertificateStructure Forward { get; }
    public X509CertificateStructure Reverse { get; }
    private CertificatePair(Asn1Sequence seq);
    public CertificatePair(X509CertificateStructure forward, X509CertificateStructure reverse);
    public static CertificatePair GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public X509CertificateStructure get_Forward();
    public X509CertificateStructure get_Reverse();
}
public class Org.BouncyCastle.Asn1.X509.CertPolicyID : DerObjectIdentifier {
    public CertPolicyID(string id);
}
public class Org.BouncyCastle.Asn1.X509.CrlDistPoint : Asn1Encodable {
    internal Asn1Sequence seq;
    private CrlDistPoint(Asn1Sequence seq);
    public CrlDistPoint(DistributionPoint[] points);
    public static CrlDistPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static CrlDistPoint GetInstance(object obj);
    public DistributionPoint[] GetDistributionPoints();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlEntry : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger userCertificate;
    internal Time revocationDate;
    internal X509Extensions crlEntryExtensions;
    public DerInteger UserCertificate { get; }
    public Time RevocationDate { get; }
    public X509Extensions Extensions { get; }
    public CrlEntry(Asn1Sequence seq);
    public DerInteger get_UserCertificate();
    public Time get_RevocationDate();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.CrlNumber : DerInteger {
    public BigInteger Number { get; }
    public CrlNumber(BigInteger number);
    public BigInteger get_Number();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.CrlReason : DerEnumerated {
    public static int Unspecified;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int RemoveFromCrl;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    private static String[] ReasonString;
    public CrlReason(int reason);
    public CrlReason(DerEnumerated reason);
    private static CrlReason();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.DigestInfo : Asn1Encodable {
    private Byte[] digest;
    private AlgorithmIdentifier algID;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DigestInfo(AlgorithmIdentifier algID, Byte[] digest);
    private DigestInfo(Asn1Sequence seq);
    public static DigestInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DigestInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Byte[] GetDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.DisplayText : Asn1Encodable {
    public static int ContentTypeIA5String;
    public static int ContentTypeBmpString;
    public static int ContentTypeUtf8String;
    public static int ContentTypeVisibleString;
    public static int DisplayTextMaximumSize;
    internal int contentType;
    internal IAsn1String contents;
    public DisplayText(int type, string text);
    public DisplayText(string text);
    public DisplayText(IAsn1String contents);
    public static DisplayText GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public string GetString();
}
public class Org.BouncyCastle.Asn1.X509.DistributionPoint : Asn1Encodable {
    internal DistributionPointName distributionPoint;
    internal ReasonFlags reasons;
    internal GeneralNames cRLIssuer;
    public DistributionPointName DistributionPointName { get; }
    public ReasonFlags Reasons { get; }
    public GeneralNames CrlIssuer { get; }
    private DistributionPoint(Asn1Sequence seq);
    public DistributionPoint(DistributionPointName distributionPointName, ReasonFlags reasons, GeneralNames crlIssuer);
    public static DistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPoint GetInstance(object obj);
    public DistributionPointName get_DistributionPointName();
    public ReasonFlags get_Reasons();
    public GeneralNames get_CrlIssuer();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DistributionPointName : Asn1Encodable {
    public static int FullName;
    public static int NameRelativeToCrlIssuer;
    internal Asn1Encodable name;
    internal int type;
    public int PointType { get; }
    public Asn1Encodable Name { get; }
    public DistributionPointName(int type, Asn1Encodable name);
    public DistributionPointName(GeneralNames name);
    public DistributionPointName(Asn1TaggedObject obj);
    public static DistributionPointName GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DistributionPointName GetInstance(object obj);
    public int get_PointType();
    public Asn1Encodable get_Name();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.DsaParameter : Asn1Encodable {
    internal DerInteger p;
    internal DerInteger q;
    internal DerInteger g;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaParameter(BigInteger p, BigInteger q, BigInteger g);
    private DsaParameter(Asn1Sequence seq);
    public static DsaParameter GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static DsaParameter GetInstance(object obj);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage : Asn1Encodable {
    internal Hashtable usageTable;
    internal Asn1Sequence seq;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private ExtendedKeyUsage(Asn1Sequence seq);
    public ExtendedKeyUsage(KeyPurposeID[] usages);
    public ExtendedKeyUsage(ArrayList usages);
    public static ExtendedKeyUsage GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static ExtendedKeyUsage GetInstance(object obj);
    public bool HasKeyPurposeId(KeyPurposeID keyPurposeId);
    public ArrayList GetUsages();
    public int get_Size();
    public int get_Count();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralName : Asn1Encodable {
    public static int OtherName;
    public static int Rfc822Name;
    public static int DnsName;
    public static int X400Address;
    public static int DirectoryName;
    public static int EdiPartyName;
    public static int UniformResourceIdentifier;
    public static int IPAddress;
    public static int RegisteredID;
    internal Asn1Encodable obj;
    internal int tag;
    public int TagNo { get; }
    public Asn1Encodable Name { get; }
    public GeneralName(X509Name directoryName);
    public GeneralName(Asn1Object name, int tag);
    public GeneralName(int tag, Asn1Encodable name);
    public GeneralName(int tag, string name);
    public static GeneralName GetInstance(object obj);
    public static GeneralName GetInstance(Asn1TaggedObject tagObj, bool explicitly);
    public int get_TagNo();
    public Asn1Encodable get_Name();
    public virtual string ToString();
    private Byte[] toGeneralNameEncoding(string ip);
    private void parseIPv4Mask(string mask, Byte[] addr, int offset);
    private void parseIPv4(string ip, Byte[] addr, int offset);
    private Int32[] parseMask(string mask);
    private void copyInts(Int32[] parsedIp, Byte[] addr, int offSet);
    private Int32[] parseIPv6(string ip);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.GeneralNames : Asn1Encodable {
    private GeneralName[] names;
    public GeneralNames(GeneralName name);
    private GeneralNames(Asn1Sequence seq);
    public static GeneralNames GetInstance(object obj);
    public static GeneralNames GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralName[] GetNames();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.GeneralSubtree : Asn1Encodable {
    private GeneralName baseName;
    private DerInteger minimum;
    private DerInteger maximum;
    public GeneralName Base { get; }
    public BigInteger Minimum { get; }
    public BigInteger Maximum { get; }
    private GeneralSubtree(Asn1Sequence seq);
    public GeneralSubtree(GeneralName baseName, BigInteger minimum, BigInteger maximum);
    public GeneralSubtree(GeneralName baseName);
    public static GeneralSubtree GetInstance(Asn1TaggedObject o, bool isExplicit);
    public static GeneralSubtree GetInstance(object obj);
    public GeneralName get_Base();
    public BigInteger get_Minimum();
    public BigInteger get_Maximum();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Holder : Asn1Encodable {
    internal IssuerSerial baseCertificateID;
    internal GeneralNames entityName;
    internal ObjectDigestInfo objectDigestInfo;
    private int version;
    public int Version { get; }
    public IssuerSerial BaseCertificateID { get; }
    public GeneralNames EntityName { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public Holder(Asn1TaggedObject tagObj);
    private Holder(Asn1Sequence seq);
    public Holder(IssuerSerial baseCertificateID);
    public Holder(IssuerSerial baseCertificateID, int version);
    public Holder(GeneralNames entityName);
    public Holder(GeneralNames entityName, int version);
    public Holder(ObjectDigestInfo objectDigestInfo);
    public static Holder GetInstance(object obj);
    public int get_Version();
    public IssuerSerial get_BaseCertificateID();
    public GeneralNames get_EntityName();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IetfAttrSyntax : Asn1Encodable {
    public static int ValueOctets;
    public static int ValueOid;
    public static int ValueUtf8;
    internal GeneralNames policyAuthority;
    internal Asn1EncodableVector values;
    internal int valueChoice;
    public GeneralNames PolicyAuthority { get; }
    public int ValueType { get; }
    public IetfAttrSyntax(Asn1Sequence seq);
    public GeneralNames get_PolicyAuthority();
    public int get_ValueType();
    public Object[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuerSerial : Asn1Encodable {
    internal GeneralNames issuer;
    internal DerInteger serial;
    internal DerBitString issuerUid;
    public GeneralNames Issuer { get; }
    public DerInteger Serial { get; }
    public DerBitString IssuerUid { get; }
    private IssuerSerial(Asn1Sequence seq);
    public IssuerSerial(GeneralNames issuer, DerInteger serial);
    public static IssuerSerial GetInstance(object obj);
    public static IssuerSerial GetInstance(Asn1TaggedObject obj, bool explicitly);
    public GeneralNames get_Issuer();
    public DerInteger get_Serial();
    public DerBitString get_IssuerUid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint : Asn1Encodable {
    private DistributionPointName _distributionPoint;
    private bool _onlyContainsUserCerts;
    private bool _onlyContainsCACerts;
    private ReasonFlags _onlySomeReasons;
    private bool _indirectCRL;
    private bool _onlyContainsAttributeCerts;
    private Asn1Sequence seq;
    public bool OnlyContainsUserCerts { get; }
    public bool OnlyContainsCACerts { get; }
    public bool IsIndirectCrl { get; }
    public bool OnlyContainsAttributeCerts { get; }
    public DistributionPointName DistributionPoint { get; }
    public ReasonFlags OnlySomeReasons { get; }
    public IssuingDistributionPoint(DistributionPointName distributionPoint, bool onlyContainsUserCerts, bool onlyContainsCACerts, ReasonFlags onlySomeReasons, bool indirectCRL, bool onlyContainsAttributeCerts);
    private IssuingDistributionPoint(Asn1Sequence seq);
    public static IssuingDistributionPoint GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static IssuingDistributionPoint GetInstance(object obj);
    public bool get_OnlyContainsUserCerts();
    public bool get_OnlyContainsCACerts();
    public bool get_IsIndirectCrl();
    public bool get_OnlyContainsAttributeCerts();
    public DistributionPointName get_DistributionPoint();
    public ReasonFlags get_OnlySomeReasons();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
    private void appendObject(StringBuilder buf, string sep, string name, string val);
}
public class Org.BouncyCastle.Asn1.X509.KeyPurposeID : DerObjectIdentifier {
    private static string IdKP;
    public static KeyPurposeID AnyExtendedKeyUsage;
    public static KeyPurposeID IdKPServerAuth;
    public static KeyPurposeID IdKPClientAuth;
    public static KeyPurposeID IdKPCodeSigning;
    public static KeyPurposeID IdKPEmailProtection;
    public static KeyPurposeID IdKPIpsecEndSystem;
    public static KeyPurposeID IdKPIpsecTunnel;
    public static KeyPurposeID IdKPIpsecUser;
    public static KeyPurposeID IdKPTimeStamping;
    public static KeyPurposeID IdKPOcspSigning;
    public static KeyPurposeID IdKPSmartCardLogon;
    private KeyPurposeID(string id);
    private static KeyPurposeID();
}
public class Org.BouncyCastle.Asn1.X509.KeyUsage : DerBitString {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    public KeyUsage(int usage);
    private KeyUsage(DerBitString usage);
    public static KeyUsage GetInstance(object obj);
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.NameConstraints : Asn1Encodable {
    private Asn1Sequence permitted;
    private Asn1Sequence excluded;
    public Asn1Sequence PermittedSubtrees { get; }
    public Asn1Sequence ExcludedSubtrees { get; }
    public NameConstraints(Asn1Sequence seq);
    public NameConstraints(ArrayList permitted, ArrayList excluded);
    public static NameConstraints GetInstance(object obj);
    private DerSequence createSequence(ArrayList subtree);
    public Asn1Sequence get_PermittedSubtrees();
    public Asn1Sequence get_ExcludedSubtrees();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.NoticeReference : Asn1Encodable {
    internal DisplayText organization;
    internal Asn1Sequence noticeNumbers;
    public NoticeReference(string orgName, ArrayList numbers);
    public NoticeReference(string orgName, Asn1Sequence numbers);
    public NoticeReference(int displayTextType, string orgName, Asn1Sequence numbers);
    private NoticeReference(Asn1Sequence seq);
    public static NoticeReference GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ObjectDigestInfo : Asn1Encodable {
    public static int PublicKey;
    public static int PublicKeyCert;
    public static int OtherObjectDigest;
    internal DerEnumerated digestedObjectType;
    internal DerObjectIdentifier otherObjectTypeID;
    internal AlgorithmIdentifier digestAlgorithm;
    internal DerBitString objectDigest;
    public DerEnumerated DigestedObjectType { get; }
    public DerObjectIdentifier OtherObjectTypeID { get; }
    public AlgorithmIdentifier DigestAlgorithm { get; }
    public DerBitString ObjectDigest { get; }
    public ObjectDigestInfo(int digestedObjectType, string otherObjectTypeID, AlgorithmIdentifier digestAlgorithm, Byte[] objectDigest);
    private ObjectDigestInfo(Asn1Sequence seq);
    public static ObjectDigestInfo GetInstance(object obj);
    public static ObjectDigestInfo GetInstance(Asn1TaggedObject obj, bool isExplicit);
    public DerEnumerated get_DigestedObjectType();
    public DerObjectIdentifier get_OtherObjectTypeID();
    public AlgorithmIdentifier get_DigestAlgorithm();
    public DerBitString get_ObjectDigest();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyInformation : Asn1Encodable {
    private DerObjectIdentifier policyIdentifier;
    private Asn1Sequence policyQualifiers;
    public DerObjectIdentifier PolicyIdentifier { get; }
    public Asn1Sequence PolicyQualifiers { get; }
    private PolicyInformation(Asn1Sequence seq);
    public PolicyInformation(DerObjectIdentifier policyIdentifier);
    public PolicyInformation(DerObjectIdentifier policyIdentifier, Asn1Sequence policyQualifiers);
    public static PolicyInformation GetInstance(object obj);
    public DerObjectIdentifier get_PolicyIdentifier();
    public Asn1Sequence get_PolicyQualifiers();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyMappings : Asn1Encodable {
    private Asn1Sequence seq;
    public PolicyMappings(Asn1Sequence seq);
    public PolicyMappings(Hashtable mappings);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierID : DerObjectIdentifier {
    private static string IdQt;
    public static PolicyQualifierID IdQtCps;
    public static PolicyQualifierID IdQtUnotice;
    private PolicyQualifierID(string id);
    private static PolicyQualifierID();
}
public class Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo : Asn1Encodable {
    internal DerObjectIdentifier policyQualifierId;
    internal Asn1Encodable qualifier;
    public PolicyQualifierInfo(DerObjectIdentifier policyQualifierId, Asn1Encodable qualifier);
    public PolicyQualifierInfo(string cps);
    private PolicyQualifierInfo(Asn1Sequence seq);
    public static PolicyQualifierInfo GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod : Asn1Encodable {
    private DerGeneralizedTime _notBefore;
    private DerGeneralizedTime _notAfter;
    public DerGeneralizedTime NotBefore { get; }
    public DerGeneralizedTime NotAfter { get; }
    private PrivateKeyUsagePeriod(Asn1Sequence seq);
    public static PrivateKeyUsagePeriod GetInstance(object obj);
    public DerGeneralizedTime get_NotBefore();
    public DerGeneralizedTime get_NotAfter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.BiometricData : Asn1Encodable {
    private TypeOfBiometricData typeOfBiometricData;
    private AlgorithmIdentifier hashAlgorithm;
    private Asn1OctetString biometricDataHash;
    private DerIA5String sourceDataUri;
    public TypeOfBiometricData TypeOfBiometricData { get; }
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Asn1OctetString BiometricDataHash { get; }
    public DerIA5String SourceDataUri { get; }
    private BiometricData(Asn1Sequence seq);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash, DerIA5String sourceDataUri);
    public BiometricData(TypeOfBiometricData typeOfBiometricData, AlgorithmIdentifier hashAlgorithm, Asn1OctetString biometricDataHash);
    public static BiometricData GetInstance(object obj);
    public TypeOfBiometricData get_TypeOfBiometricData();
    public AlgorithmIdentifier get_HashAlgorithm();
    public Asn1OctetString get_BiometricDataHash();
    public DerIA5String get_SourceDataUri();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X509.Qualified.EtsiQCObjectIdentifiers : object {
    public static DerObjectIdentifier IdEtsiQcs;
    public static DerObjectIdentifier IdEtsiQcsQcCompliance;
    public static DerObjectIdentifier IdEtsiQcsLimitValue;
    public static DerObjectIdentifier IdEtsiQcsRetentionPeriod;
    public static DerObjectIdentifier IdEtsiQcsQcSscd;
    private static EtsiQCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode : Asn1Encodable {
    internal static int AlphabeticMaxSize;
    internal static int NumericMinSize;
    internal static int NumericMaxSize;
    internal Asn1Encodable obj;
    public bool IsAlphabetic { get; }
    public string Alphabetic { get; }
    public int Numeric { get; }
    public Iso4217CurrencyCode(int numeric);
    public Iso4217CurrencyCode(string alphabetic);
    public static Iso4217CurrencyCode GetInstance(object obj);
    public bool get_IsAlphabetic();
    public string get_Alphabetic();
    public int get_Numeric();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue : Asn1Encodable {
    internal Iso4217CurrencyCode currency;
    internal DerInteger amount;
    internal DerInteger exponent;
    public Iso4217CurrencyCode Currency { get; }
    public BigInteger Amount { get; }
    public BigInteger Exponent { get; }
    private MonetaryValue(Asn1Sequence seq);
    public MonetaryValue(Iso4217CurrencyCode currency, int amount, int exponent);
    public static MonetaryValue GetInstance(object obj);
    public Iso4217CurrencyCode get_Currency();
    public BigInteger get_Amount();
    public BigInteger get_Exponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.QCStatement : Asn1Encodable {
    private DerObjectIdentifier qcStatementId;
    private Asn1Encodable qcStatementInfo;
    public DerObjectIdentifier StatementId { get; }
    public Asn1Encodable StatementInfo { get; }
    private QCStatement(Asn1Sequence seq);
    public QCStatement(DerObjectIdentifier qcStatementId);
    public QCStatement(DerObjectIdentifier qcStatementId, Asn1Encodable qcStatementInfo);
    public static QCStatement GetInstance(object obj);
    public DerObjectIdentifier get_StatementId();
    public Asn1Encodable get_StatementInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.Rfc3739QCObjectIdentifiers : object {
    public static DerObjectIdentifier IdQcs;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV1;
    public static DerObjectIdentifier IdQcsPkixQCSyntaxV2;
    private static Rfc3739QCObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation : Asn1Encodable {
    private DerObjectIdentifier semanticsIdentifier;
    private GeneralName[] nameRegistrationAuthorities;
    public DerObjectIdentifier SemanticsIdentifier { get; }
    public SemanticsInformation(Asn1Sequence seq);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier, GeneralName[] generalNames);
    public SemanticsInformation(DerObjectIdentifier semanticsIdentifier);
    public SemanticsInformation(GeneralName[] generalNames);
    public static SemanticsInformation GetInstance(object obj);
    public DerObjectIdentifier get_SemanticsIdentifier();
    public GeneralName[] GetNameRegistrationAuthorities();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData : Asn1Encodable {
    public static int Picture;
    public static int HandwrittenSignature;
    internal Asn1Encodable obj;
    public bool IsPredefined { get; }
    public int PredefinedBiometricType { get; }
    public DerObjectIdentifier BiometricDataOid { get; }
    public TypeOfBiometricData(int predefinedBiometricType);
    public TypeOfBiometricData(DerObjectIdentifier biometricDataOid);
    public static TypeOfBiometricData GetInstance(object obj);
    public bool get_IsPredefined();
    public int get_PredefinedBiometricType();
    public DerObjectIdentifier get_BiometricDataOid();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.ReasonFlags : DerBitString {
    public static int Unused;
    public static int KeyCompromise;
    public static int CACompromise;
    public static int AffiliationChanged;
    public static int Superseded;
    public static int CessationOfOperation;
    public static int CertificateHold;
    public static int PrivilegeWithdrawn;
    public static int AACompromise;
    public ReasonFlags(int reasons);
    public ReasonFlags(DerBitString reasons);
}
public class Org.BouncyCastle.Asn1.X509.RoleSyntax : Asn1Encodable {
    private GeneralNames roleAuthority;
    private GeneralName roleName;
    public GeneralNames RoleAuthority { get; }
    public GeneralName RoleName { get; }
    public RoleSyntax(GeneralNames roleAuthority, GeneralName roleName);
    public RoleSyntax(GeneralName roleName);
    public RoleSyntax(string roleName);
    private RoleSyntax(Asn1Sequence seq);
    public static RoleSyntax GetInstance(object obj);
    public GeneralNames get_RoleAuthority();
    public GeneralName get_RoleName();
    public string GetRoleNameAsString();
    public String[] GetRoleAuthorityAsString();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure : Asn1Encodable {
    private BigInteger modulus;
    private BigInteger publicExponent;
    public BigInteger Modulus { get; }
    public BigInteger PublicExponent { get; }
    public RsaPublicKeyStructure(BigInteger modulus, BigInteger publicExponent);
    private RsaPublicKeyStructure(Asn1Sequence seq);
    public static RsaPublicKeyStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static RsaPublicKeyStructure GetInstance(object obj);
    public BigInteger get_Modulus();
    public BigInteger get_PublicExponent();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym : Asn1Encodable {
    private DirectoryString pseudonym;
    private DirectoryString surname;
    private Asn1Sequence givenName;
    public DirectoryString Pseudonym { get; }
    public DirectoryString Surname { get; }
    public NameOrPseudonym(DirectoryString pseudonym);
    private NameOrPseudonym(Asn1Sequence seq);
    public NameOrPseudonym(string pseudonym);
    public NameOrPseudonym(DirectoryString surname, Asn1Sequence givenName);
    public static NameOrPseudonym GetInstance(object obj);
    public DirectoryString get_Pseudonym();
    public DirectoryString get_Surname();
    public DirectoryString[] GetGivenName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.PersonalData : Asn1Encodable {
    private NameOrPseudonym nameOrPseudonym;
    private BigInteger nameDistinguisher;
    private DerGeneralizedTime dateOfBirth;
    private DirectoryString placeOfBirth;
    private string gender;
    private DirectoryString postalAddress;
    public NameOrPseudonym NameOrPseudonym { get; }
    public BigInteger NameDistinguisher { get; }
    public DerGeneralizedTime DateOfBirth { get; }
    public DirectoryString PlaceOfBirth { get; }
    public string Gender { get; }
    public DirectoryString PostalAddress { get; }
    private PersonalData(Asn1Sequence seq);
    public PersonalData(NameOrPseudonym nameOrPseudonym, BigInteger nameDistinguisher, DerGeneralizedTime dateOfBirth, DirectoryString placeOfBirth, string gender, DirectoryString postalAddress);
    public static PersonalData GetInstance(object obj);
    public NameOrPseudonym get_NameOrPseudonym();
    public BigInteger get_NameDistinguisher();
    public DerGeneralizedTime get_DateOfBirth();
    public DirectoryString get_PlaceOfBirth();
    public string get_Gender();
    public DirectoryString get_PostalAddress();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers : object {
    public static DerObjectIdentifier IdSigI;
    public static DerObjectIdentifier IdSigIKP;
    public static DerObjectIdentifier IdSigICP;
    public static DerObjectIdentifier IdSigION;
    public static DerObjectIdentifier IdSigIKPDirectoryService;
    public static DerObjectIdentifier IdSigIONPersonalData;
    public static DerObjectIdentifier IdSigICPSigConform;
    private static SigIObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes : Asn1Encodable {
    private ArrayList attributes;
    public IEnumerable Attributes { get; }
    private SubjectDirectoryAttributes(Asn1Sequence seq);
    public SubjectDirectoryAttributes(ArrayList attributes);
    public static SubjectDirectoryAttributes GetInstance(object obj);
    public virtual Asn1Object ToAsn1Object();
    public IEnumerable get_Attributes();
}
public class Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier : Asn1Encodable {
    private Byte[] keyIdentifier;
    public SubjectKeyIdentifier(Byte[] keyID);
    public SubjectKeyIdentifier(Asn1OctetString keyID);
    public SubjectKeyIdentifier(SubjectPublicKeyInfo spki);
    public static SubjectKeyIdentifier GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectKeyIdentifier GetInstance(object obj);
    public Byte[] GetKeyIdentifier();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo : Asn1Encodable {
    private AlgorithmIdentifier algID;
    private DerBitString keyData;
    public AlgorithmIdentifier AlgorithmID { get; }
    public DerBitString PublicKeyData { get; }
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Asn1Encodable publicKey);
    public SubjectPublicKeyInfo(AlgorithmIdentifier algID, Byte[] publicKey);
    private SubjectPublicKeyInfo(Asn1Sequence seq);
    public static SubjectPublicKeyInfo GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static SubjectPublicKeyInfo GetInstance(object obj);
    public AlgorithmIdentifier get_AlgorithmID();
    public Asn1Object GetPublicKey();
    public DerBitString get_PublicKeyData();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Target : Asn1Encodable {
    private GeneralName targetName;
    private GeneralName targetGroup;
    public GeneralName TargetGroup { get; }
    public GeneralName TargetName { get; }
    private Target(Asn1TaggedObject tagObj);
    public Target(Choice type, GeneralName name);
    public static Target GetInstance(object obj);
    public virtual GeneralName get_TargetGroup();
    public virtual GeneralName get_TargetName();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TargetInformation : Asn1Encodable {
    private Asn1Sequence targets;
    private TargetInformation(Asn1Sequence targets);
    public TargetInformation(Targets targets);
    public TargetInformation(Target[] targets);
    public static TargetInformation GetInstance(object obj);
    public virtual Targets[] GetTargetsObjects();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Targets : Asn1Encodable {
    private Asn1Sequence targets;
    private Targets(Asn1Sequence targets);
    public Targets(Target[] targets);
    public static Targets GetInstance(object obj);
    public virtual Target[] GetTargets();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateList : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time thisUpdate;
    internal Time nextUpdate;
    internal Asn1Sequence revokedCertificates;
    internal X509Extensions crlExtensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time ThisUpdate { get; }
    public Time NextUpdate { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateList(Asn1Sequence seq);
    public static TbsCertificateList GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateList GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_ThisUpdate();
    public Time get_NextUpdate();
    public CrlEntry[] GetRevokedCertificates();
    public IEnumerable GetRevokedCertificateEnumeration();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.TbsCertificateStructure : Asn1Encodable {
    internal Asn1Sequence seq;
    internal DerInteger version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal DerBitString issuerUniqueID;
    internal DerBitString subjectUniqueID;
    internal X509Extensions extensions;
    public int Version { get; }
    public DerInteger VersionNumber { get; }
    public DerInteger SerialNumber { get; }
    public AlgorithmIdentifier Signature { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Extensions Extensions { get; }
    internal TbsCertificateStructure(Asn1Sequence seq);
    public static TbsCertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static TbsCertificateStructure GetInstance(object obj);
    public int get_Version();
    public DerInteger get_VersionNumber();
    public DerInteger get_SerialNumber();
    public AlgorithmIdentifier get_Signature();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public DerBitString get_IssuerUniqueID();
    public DerBitString get_SubjectUniqueID();
    public X509Extensions get_Extensions();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.Time : Asn1Encodable {
    internal Asn1Object time;
    public Time(Asn1Object time);
    public Time(DateTime date);
    public static Time GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static Time GetInstance(object obj);
    public string GetTime();
    public DateTime ToDateTime();
    public virtual Asn1Object ToAsn1Object();
    public virtual string ToString();
}
public class Org.BouncyCastle.Asn1.X509.UserNotice : Asn1Encodable {
    internal NoticeReference noticeRef;
    internal DisplayText explicitText;
    public UserNotice(NoticeReference noticeRef, DisplayText explicitText);
    public UserNotice(NoticeReference noticeRef, string str);
    public UserNotice(Asn1Sequence seq);
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(Time startDate);
    public void SetStartDate(DerUtcTime startDate);
    public void SetEndDate(Time endDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetSubject(X509Name subject);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator : object {
    internal DerInteger version;
    internal Holder holder;
    internal AttCertIssuer issuer;
    internal AlgorithmIdentifier signature;
    internal DerInteger serialNumber;
    internal Asn1EncodableVector attributes;
    internal DerBitString issuerUniqueID;
    internal X509Extensions extensions;
    internal DerGeneralizedTime startDate;
    internal DerGeneralizedTime endDate;
    public void SetHolder(Holder holder);
    public void AddAttribute(string oid, Asn1Encodable value);
    public void AddAttribute(AttributeX509 attribute);
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(AttCertIssuer issuer);
    public void SetStartDate(DerGeneralizedTime startDate);
    public void SetEndDate(DerGeneralizedTime endDate);
    public void SetIssuerUniqueID(DerBitString issuerUniqueID);
    public void SetExtensions(X509Extensions extensions);
    public AttributeCertificateInfo GenerateAttributeCertificateInfo();
}
public class Org.BouncyCastle.Asn1.X509.V2Form : Asn1Encodable {
    internal GeneralNames issuerName;
    internal IssuerSerial baseCertificateID;
    internal ObjectDigestInfo objectDigestInfo;
    public GeneralNames IssuerName { get; }
    public IssuerSerial BaseCertificateID { get; }
    public ObjectDigestInfo ObjectDigestInfo { get; }
    public V2Form(GeneralNames issuerName);
    private V2Form(Asn1Sequence seq);
    public static V2Form GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static V2Form GetInstance(object obj);
    public GeneralNames get_IssuerName();
    public IssuerSerial get_BaseCertificateID();
    public ObjectDigestInfo get_ObjectDigestInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator : object {
    private DerInteger version;
    private AlgorithmIdentifier signature;
    private X509Name issuer;
    private Time thisUpdate;
    private Time nextUpdate;
    private X509Extensions extensions;
    private ArrayList crlEntries;
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetThisUpdate(DerUtcTime thisUpdate);
    public void SetNextUpdate(DerUtcTime nextUpdate);
    public void SetThisUpdate(Time thisUpdate);
    public void SetNextUpdate(Time nextUpdate);
    public void AddCrlEntry(Asn1Sequence crlEntry);
    public void AddCrlEntry(DerInteger userCertificate, DerUtcTime revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, int reason, DerGeneralizedTime invalidityDate);
    public void AddCrlEntry(DerInteger userCertificate, Time revocationDate, X509Extensions extensions);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateList GenerateTbsCertList();
}
public class Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator : object {
    internal DerTaggedObject version;
    internal DerInteger serialNumber;
    internal AlgorithmIdentifier signature;
    internal X509Name issuer;
    internal Time startDate;
    internal Time endDate;
    internal X509Name subject;
    internal SubjectPublicKeyInfo subjectPublicKeyInfo;
    internal X509Extensions extensions;
    private bool altNamePresentAndCritical;
    private DerBitString issuerUniqueID;
    private DerBitString subjectUniqueID;
    public void SetSerialNumber(DerInteger serialNumber);
    public void SetSignature(AlgorithmIdentifier signature);
    public void SetIssuer(X509Name issuer);
    public void SetStartDate(DerUtcTime startDate);
    public void SetStartDate(Time startDate);
    public void SetEndDate(DerUtcTime endDate);
    public void SetEndDate(Time endDate);
    public void SetSubject(X509Name subject);
    public void SetIssuerUniqueID(DerBitString uniqueID);
    public void SetSubjectUniqueID(DerBitString uniqueID);
    public void SetSubjectPublicKeyInfo(SubjectPublicKeyInfo pubKeyInfo);
    public void SetExtensions(X509Extensions extensions);
    public TbsCertificateStructure GenerateTbsCertificate();
}
public class Org.BouncyCastle.Asn1.X509.X509Attributes : object {
    public static DerObjectIdentifier RoleSyntax;
    private static X509Attributes();
}
public class Org.BouncyCastle.Asn1.X509.X509CertificateStructure : Asn1Encodable {
    private TbsCertificateStructure tbsCert;
    private AlgorithmIdentifier sigAlgID;
    private DerBitString sig;
    public TbsCertificateStructure TbsCertificate { get; }
    public int Version { get; }
    public DerInteger SerialNumber { get; }
    public X509Name Issuer { get; }
    public Time StartDate { get; }
    public Time EndDate { get; }
    public X509Name Subject { get; }
    public SubjectPublicKeyInfo SubjectPublicKeyInfo { get; }
    public AlgorithmIdentifier SignatureAlgorithm { get; }
    public DerBitString Signature { get; }
    public X509CertificateStructure(TbsCertificateStructure tbsCert, AlgorithmIdentifier sigAlgID, DerBitString sig);
    private X509CertificateStructure(Asn1Sequence seq);
    public static X509CertificateStructure GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509CertificateStructure GetInstance(object obj);
    public TbsCertificateStructure get_TbsCertificate();
    public int get_Version();
    public DerInteger get_SerialNumber();
    public X509Name get_Issuer();
    public Time get_StartDate();
    public Time get_EndDate();
    public X509Name get_Subject();
    public SubjectPublicKeyInfo get_SubjectPublicKeyInfo();
    public AlgorithmIdentifier get_SignatureAlgorithm();
    public DerBitString get_Signature();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter : X509NameEntryConverter {
    public virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509Extension : object {
    internal bool critical;
    internal Asn1OctetString value;
    public bool IsCritical { get; }
    public Asn1OctetString Value { get; }
    public X509Extension(DerBoolean critical, Asn1OctetString value);
    public X509Extension(bool critical, Asn1OctetString value);
    public bool get_IsCritical();
    public Asn1OctetString get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Asn1Object ConvertValueToObject(X509Extension ext);
}
public class Org.BouncyCastle.Asn1.X509.X509Extensions : Asn1Encodable {
    public static DerObjectIdentifier SubjectDirectoryAttributes;
    public static DerObjectIdentifier SubjectKeyIdentifier;
    public static DerObjectIdentifier KeyUsage;
    public static DerObjectIdentifier PrivateKeyUsagePeriod;
    public static DerObjectIdentifier SubjectAlternativeName;
    public static DerObjectIdentifier IssuerAlternativeName;
    public static DerObjectIdentifier BasicConstraints;
    public static DerObjectIdentifier CrlNumber;
    public static DerObjectIdentifier ReasonCode;
    public static DerObjectIdentifier InstructionCode;
    public static DerObjectIdentifier InvalidityDate;
    public static DerObjectIdentifier DeltaCrlIndicator;
    public static DerObjectIdentifier IssuingDistributionPoint;
    public static DerObjectIdentifier CertificateIssuer;
    public static DerObjectIdentifier NameConstraints;
    public static DerObjectIdentifier CrlDistributionPoints;
    public static DerObjectIdentifier CertificatePolicies;
    public static DerObjectIdentifier PolicyMappings;
    public static DerObjectIdentifier AuthorityKeyIdentifier;
    public static DerObjectIdentifier PolicyConstraints;
    public static DerObjectIdentifier ExtendedKeyUsage;
    public static DerObjectIdentifier FreshestCrl;
    public static DerObjectIdentifier InhibitAnyPolicy;
    public static DerObjectIdentifier AuthorityInfoAccess;
    public static DerObjectIdentifier SubjectInfoAccess;
    public static DerObjectIdentifier LogoType;
    public static DerObjectIdentifier BiometricInfo;
    public static DerObjectIdentifier QCStatements;
    public static DerObjectIdentifier AuditIdentity;
    public static DerObjectIdentifier NoRevAvail;
    public static DerObjectIdentifier TargetInformation;
    private Hashtable extensions;
    private ArrayList ordering;
    public IEnumerable ExtensionOids { get; }
    private X509Extensions(Asn1Sequence seq);
    public X509Extensions(Hashtable extensions);
    public X509Extensions(ArrayList ordering, Hashtable extensions);
    public X509Extensions(ArrayList oids, ArrayList values);
    private static X509Extensions();
    public static X509Extensions GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Extensions GetInstance(object obj);
    [ObsoleteAttribute("Use ExtensionOids IEnumerable property")]
public IEnumerator Oids();
    public IEnumerable get_ExtensionOids();
    public X509Extension GetExtension(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    public bool Equivalent(X509Extensions other);
}
public class Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator : object {
    private Hashtable extensions;
    private ArrayList extOrdering;
    public bool IsEmpty { get; }
    public void Reset();
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extValue);
    public bool get_IsEmpty();
    public X509Extensions Generate();
}
public class Org.BouncyCastle.Asn1.X509.X509Name : Asn1Encodable {
    public static DerObjectIdentifier C;
    public static DerObjectIdentifier O;
    public static DerObjectIdentifier OU;
    public static DerObjectIdentifier T;
    public static DerObjectIdentifier CN;
    public static DerObjectIdentifier Street;
    public static DerObjectIdentifier SerialNumber;
    public static DerObjectIdentifier L;
    public static DerObjectIdentifier ST;
    public static DerObjectIdentifier Surname;
    public static DerObjectIdentifier GivenName;
    public static DerObjectIdentifier Initials;
    public static DerObjectIdentifier Generation;
    public static DerObjectIdentifier UniqueIdentifier;
    public static DerObjectIdentifier BusinessCategory;
    public static DerObjectIdentifier PostalCode;
    public static DerObjectIdentifier DnQualifier;
    public static DerObjectIdentifier Pseudonym;
    public static DerObjectIdentifier DateOfBirth;
    public static DerObjectIdentifier PlaceOfBirth;
    public static DerObjectIdentifier Gender;
    public static DerObjectIdentifier CountryOfCitizenship;
    public static DerObjectIdentifier CountryOfResidence;
    public static DerObjectIdentifier NameAtBirth;
    public static DerObjectIdentifier PostalAddress;
    public static DerObjectIdentifier TelephoneNumber;
    public static DerObjectIdentifier Name;
    public static DerObjectIdentifier EmailAddress;
    public static DerObjectIdentifier UnstructuredName;
    public static DerObjectIdentifier UnstructuredAddress;
    public static DerObjectIdentifier E;
    public static DerObjectIdentifier DC;
    public static DerObjectIdentifier UID;
    private static Boolean[] defaultReverse;
    public static Hashtable DefaultSymbols;
    public static Hashtable RFC2253Symbols;
    public static Hashtable RFC1779Symbols;
    public static Hashtable DefaultLookup;
    [ObsoleteAttribute("Use 'DefaultSymbols' instead")]
public static Hashtable OIDLookup;
    [ObsoleteAttribute("Use 'DefaultLookup' instead")]
public static Hashtable SymbolLookup;
    private ArrayList ordering;
    private X509NameEntryConverter converter;
    private ArrayList values;
    private ArrayList added;
    private Asn1Sequence seq;
    public static bool DefaultReverse { get; public set; }
    private static X509Name();
    protected X509Name(Asn1Sequence seq);
    public X509Name(ArrayList ordering, Hashtable attributes);
    public X509Name(ArrayList ordering, Hashtable attributes, X509NameEntryConverter converter);
    public X509Name(ArrayList oids, ArrayList values);
    public X509Name(ArrayList oids, ArrayList values, X509NameEntryConverter converter);
    public X509Name(string dirName);
    public X509Name(string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, string dirName);
    public X509Name(bool reverse, string dirName, X509NameEntryConverter converter);
    public X509Name(bool reverse, Hashtable lookUp, string dirName);
    public X509Name(bool reverse, IDictionary lookUp, string dirName, X509NameEntryConverter converter);
    public static bool get_DefaultReverse();
    public static void set_DefaultReverse(bool value);
    public static X509Name GetInstance(Asn1TaggedObject obj, bool explicitly);
    public static X509Name GetInstance(object obj);
    private DerObjectIdentifier DecodeOid(string name, IDictionary lookUp);
    public ArrayList GetOids();
    public ArrayList GetValues();
    public ArrayList GetValues(DerObjectIdentifier oid);
    public virtual Asn1Object ToAsn1Object();
    [ObsoleteAttribute("Use 'Equivalent(X509Name, int)' instead")]
public bool Equals(X509Name other, bool inOrder);
    public bool Equivalent(X509Name other, bool inOrder);
    [ObsoleteAttribute("Use 'Equivalent(X509Name)' instead")]
public bool Equals(X509Name other);
    public bool Equivalent(X509Name other);
    private static bool equivalentStrings(string s1, string s2);
    private static string canonicalize(string s);
    private static Asn1Object decodeObject(string v);
    private static string stripInternalSpaces(string str);
    private void AppendValue(StringBuilder buf, Hashtable oidSymbols, DerObjectIdentifier oid, string val);
    public string ToString(bool reverse, Hashtable oidSymbols);
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509NameEntryConverter : object {
    protected Asn1Object ConvertHexEncoded(string hexString, int offset);
    protected bool CanBePrintable(string str);
    public abstract virtual Asn1Object GetConvertedValue(DerObjectIdentifier oid, string value);
}
public class Org.BouncyCastle.Asn1.X509.X509NameTokenizer : object {
    private string value;
    private int index;
    private char separator;
    private StringBuilder buffer;
    public X509NameTokenizer(string oid);
    public X509NameTokenizer(string oid, char separator);
    public bool HasMoreTokens();
    public string NextToken();
}
public abstract class Org.BouncyCastle.Asn1.X509.X509ObjectIdentifiers : object {
    internal static string ID;
    public static DerObjectIdentifier CommonName;
    public static DerObjectIdentifier CountryName;
    public static DerObjectIdentifier LocalityName;
    public static DerObjectIdentifier StateOrProvinceName;
    public static DerObjectIdentifier Organization;
    public static DerObjectIdentifier OrganizationalUnitName;
    public static DerObjectIdentifier id_at_telephoneNumber;
    public static DerObjectIdentifier id_at_name;
    public static DerObjectIdentifier IdSha1;
    public static DerObjectIdentifier RipeMD160;
    public static DerObjectIdentifier RipeMD160WithRsaEncryption;
    public static DerObjectIdentifier IdEARsa;
    public static DerObjectIdentifier IdPkix;
    public static DerObjectIdentifier IdPE;
    public static DerObjectIdentifier IdAD;
    public static DerObjectIdentifier IdADCAIssuers;
    public static DerObjectIdentifier IdADOcsp;
    public static DerObjectIdentifier OcspAccessMethod;
    public static DerObjectIdentifier CrlAccessMethod;
    private static X509ObjectIdentifiers();
}
public class Org.BouncyCastle.Asn1.X9.KeySpecificInfo : Asn1Encodable {
    private DerObjectIdentifier algorithm;
    private Asn1OctetString counter;
    public DerObjectIdentifier Algorithm { get; }
    public Asn1OctetString Counter { get; }
    public KeySpecificInfo(DerObjectIdentifier algorithm, Asn1OctetString counter);
    public KeySpecificInfo(Asn1Sequence seq);
    public DerObjectIdentifier get_Algorithm();
    public Asn1OctetString get_Counter();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.OtherInfo : Asn1Encodable {
    private KeySpecificInfo keyInfo;
    private Asn1OctetString partyAInfo;
    private Asn1OctetString suppPubInfo;
    public KeySpecificInfo KeyInfo { get; }
    public Asn1OctetString PartyAInfo { get; }
    public Asn1OctetString SuppPubInfo { get; }
    public OtherInfo(KeySpecificInfo keyInfo, Asn1OctetString partyAInfo, Asn1OctetString suppPubInfo);
    public OtherInfo(Asn1Sequence seq);
    public KeySpecificInfo get_KeyInfo();
    public Asn1OctetString get_PartyAInfo();
    public Asn1OctetString get_SuppPubInfo();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X962NamedCurves : object {
    private static Hashtable objIds;
    private static Hashtable curves;
    private static Hashtable names;
    public static IEnumerable Names { get; }
    private static X962NamedCurves();
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
    public static IEnumerable get_Names();
}
public class Org.BouncyCastle.Asn1.X9.X962Parameters : Asn1Encodable {
    private Asn1Object _params;
    public bool IsNamedCurve { get; }
    public Asn1Object Parameters { get; }
    public X962Parameters(X9ECParameters ecParameters);
    public X962Parameters(DerObjectIdentifier namedCurve);
    public X962Parameters(Asn1Object obj);
    public bool get_IsNamedCurve();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9Curve : Asn1Encodable {
    private ECCurve curve;
    private Byte[] seed;
    private DerObjectIdentifier fieldIdentifier;
    public ECCurve Curve { get; }
    public X9Curve(ECCurve curve);
    public X9Curve(ECCurve curve, Byte[] seed);
    public X9Curve(X9FieldID fieldID, Asn1Sequence seq);
    public ECCurve get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9ECParameters : Asn1Encodable {
    private X9FieldID fieldID;
    private ECCurve curve;
    private ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private Byte[] seed;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public X9ECParameters(Asn1Sequence seq);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ECParametersHolder : object {
    private X9ECParameters parameters;
    public X9ECParameters Parameters { get; }
    public X9ECParameters get_Parameters();
    protected abstract virtual X9ECParameters CreateParameters();
}
public class Org.BouncyCastle.Asn1.X9.X9ECPoint : Asn1Encodable {
    private ECPoint p;
    public ECPoint Point { get; }
    public X9ECPoint(ECPoint p);
    public X9ECPoint(ECCurve c, Asn1OctetString s);
    public ECPoint get_Point();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldElement : Asn1Encodable {
    private ECFieldElement f;
    public ECFieldElement Value { get; }
    public X9FieldElement(ECFieldElement f);
    public X9FieldElement(BigInteger p, Asn1OctetString s);
    public X9FieldElement(int m, int k1, int k2, int k3, Asn1OctetString s);
    public ECFieldElement get_Value();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9FieldID : Asn1Encodable {
    private DerObjectIdentifier id;
    private Asn1Object parameters;
    public DerObjectIdentifier Identifier { get; }
    public Asn1Object Parameters { get; }
    public X9FieldID(BigInteger primeP);
    public X9FieldID(int m, int k1, int k2, int k3);
    internal X9FieldID(Asn1Sequence seq);
    public DerObjectIdentifier get_Identifier();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.Asn1.X9.X9IntegerConverter : object {
    public static int GetByteLength(ECFieldElement fe);
    public static int GetByteLength(ECCurve c);
    public static Byte[] IntegerToBytes(BigInteger s, int qLength);
}
public abstract class Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers : object {
    internal static string AnsiX962;
    internal static string IdFieldType;
    public static string IdECSigType;
    public static string IdPublicKeyType;
    public static DerObjectIdentifier PrimeField;
    public static DerObjectIdentifier CharacteristicTwoField;
    public static DerObjectIdentifier GNBasis;
    public static DerObjectIdentifier TPBasis;
    public static DerObjectIdentifier PPBasis;
    public static DerObjectIdentifier ECDsaWithSha1;
    public static DerObjectIdentifier IdECPublicKey;
    public static DerObjectIdentifier ECDsaWithSha2;
    public static DerObjectIdentifier ECDsaWithSha224;
    public static DerObjectIdentifier ECDsaWithSha256;
    public static DerObjectIdentifier ECDsaWithSha384;
    public static DerObjectIdentifier ECDsaWithSha512;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier CTwoCurve;
    public static DerObjectIdentifier C2Pnb163v1;
    public static DerObjectIdentifier C2Pnb163v2;
    public static DerObjectIdentifier C2Pnb163v3;
    public static DerObjectIdentifier C2Pnb176w1;
    public static DerObjectIdentifier C2Tnb191v1;
    public static DerObjectIdentifier C2Tnb191v2;
    public static DerObjectIdentifier C2Tnb191v3;
    public static DerObjectIdentifier C2Onb191v4;
    public static DerObjectIdentifier C2Onb191v5;
    public static DerObjectIdentifier C2Pnb208w1;
    public static DerObjectIdentifier C2Tnb239v1;
    public static DerObjectIdentifier C2Tnb239v2;
    public static DerObjectIdentifier C2Tnb239v3;
    public static DerObjectIdentifier C2Onb239v4;
    public static DerObjectIdentifier C2Onb239v5;
    public static DerObjectIdentifier C2Pnb272w1;
    public static DerObjectIdentifier C2Pnb304w1;
    public static DerObjectIdentifier C2Tnb359v1;
    public static DerObjectIdentifier C2Pnb368w1;
    public static DerObjectIdentifier C2Tnb431r1;
    public static DerObjectIdentifier PrimeCurve;
    public static DerObjectIdentifier Prime192v1;
    public static DerObjectIdentifier Prime192v2;
    public static DerObjectIdentifier Prime192v3;
    public static DerObjectIdentifier Prime239v1;
    public static DerObjectIdentifier Prime239v2;
    public static DerObjectIdentifier Prime239v3;
    public static DerObjectIdentifier Prime256v1;
    public static DerObjectIdentifier DHPublicNumber;
    public static DerObjectIdentifier IdDsa;
    public static DerObjectIdentifier IdDsaWithSha1;
    public static DerObjectIdentifier X9x63Scheme;
    public static DerObjectIdentifier DHSinglePassStdDHSha1KdfScheme;
    public static DerObjectIdentifier DHSinglePassCofactorDHSha1KdfScheme;
    public static DerObjectIdentifier MqvSinglePassSha1KdfScheme;
    public static DerObjectIdentifier X9x42Schemes;
    public static DerObjectIdentifier DHStatic;
    public static DerObjectIdentifier DHEphem;
    public static DerObjectIdentifier DHOneFlow;
    public static DerObjectIdentifier DHHybrid1;
    public static DerObjectIdentifier DHHybrid2;
    public static DerObjectIdentifier DHHybridOneFlow;
    public static DerObjectIdentifier Mqv2;
    public static DerObjectIdentifier Mqv1;
    private static X9ObjectIdentifiers();
}
public class Org.BouncyCastle.Bcpg.ArmoredInputStream : BaseInputStream {
    private static Byte[] decodingTable;
    private Stream input;
    private bool start;
    private Int32[] outBuf;
    private int bufPtr;
    private Crc24 crc;
    private bool crcFound;
    private bool hasHeaders;
    private string header;
    private bool newLineFound;
    private bool clearText;
    private bool restart;
    private ArrayList headerList;
    private int lastC;
    private bool isEndOfStream;
    private static ArmoredInputStream();
    public ArmoredInputStream(Stream input);
    public ArmoredInputStream(Stream input, bool hasHeaders);
    private int Decode(int in0, int in1, int in2, int in3, Int32[] result);
    private bool ParseHeaders();
    public bool IsClearText();
    public bool IsEndOfStream();
    public string GetArmorHeaderLine();
    public String[] GetArmorHeaders();
    private int ReadIgnoreSpace();
    private int ReadIgnoreWhitespace();
    private int ReadByteClearText();
    private int ReadClearText(Byte[] buffer, int offset, int count);
    private int DoReadByte();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class Org.BouncyCastle.Bcpg.ArmoredOutputStream : BaseOutputStream {
    private static Byte[] encodingTable;
    private Stream outStream;
    private Int32[] buf;
    private int bufPtr;
    private Crc24 crc;
    private int chunkCount;
    private int lastb;
    private bool start;
    private bool clearText;
    private bool newLine;
    private string type;
    private static string nl;
    private static string headerStart;
    private static string headerTail;
    private static string footerStart;
    private static string footerTail;
    private static string version;
    private IDictionary headers;
    public ArmoredOutputStream(Stream outStream);
    public ArmoredOutputStream(Stream outStream, IDictionary headers);
    private static ArmoredOutputStream();
    private static void Encode(Stream outStream, Int32[] data, int len);
    public void SetHeader(string name, string v);
    public void ResetHeaders();
    public void BeginClearText(HashAlgorithmTag hashAlgorithm);
    public void EndClearText();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    private void WriteHeaderEntry(string name, string v);
    private void DoWrite(string s);
}
public class Org.BouncyCastle.Bcpg.Attr.ImageAttrib : UserAttributeSubpacket {
    private static Byte[] Zeroes;
    private int hdrLength;
    private int _version;
    private int _encoding;
    private Byte[] imageData;
    public int Version { get; }
    public int Encoding { get; }
    public ImageAttrib(Byte[] data);
    public ImageAttrib(Format imageType, Byte[] imageData);
    private static ImageAttrib();
    private static Byte[] ToByteArray(Format imageType, Byte[] imageData);
    public int get_Version();
    public int get_Encoding();
    public Byte[] GetImageData();
}
public class Org.BouncyCastle.Bcpg.BcpgInputStream : BaseInputStream {
    private Stream m_in;
    private bool next;
    private int nextB;
    private BcpgInputStream(Stream inputStream);
    internal static BcpgInputStream Wrap(Stream inStr);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public Byte[] ReadAll();
    public void ReadFully(Byte[] buffer, int off, int len);
    public void ReadFully(Byte[] buffer);
    public PacketTag NextPacketTag();
    public Packet ReadPacket();
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.BcpgObject : object {
    public virtual Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.BcpgOutputStream : BaseOutputStream {
    private static int BufferSizePower;
    private Stream outStr;
    private Byte[] partialBuffer;
    private int partialBufferLength;
    private int partialPower;
    private int partialOffset;
    public BcpgOutputStream(Stream outStr);
    public BcpgOutputStream(Stream outStr, PacketTag tag);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length, bool oldFormat);
    public BcpgOutputStream(Stream outStr, PacketTag tag, long length);
    public BcpgOutputStream(Stream outStr, PacketTag tag, Byte[] buffer);
    internal static BcpgOutputStream Wrap(Stream outStr);
    private void WriteNewPacketLength(long bodyLen);
    private void WriteHeader(PacketTag tag, bool oldPackets, bool partial, long bodyLen);
    private void PartialFlush(bool isLast);
    private void WritePartial(byte b);
    private void WritePartial(Byte[] buffer, int off, int len);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal virtual void WriteShort(short n);
    internal virtual void WriteInt(int n);
    internal virtual void WriteLong(long n);
    public void WritePacket(ContainedPacket p);
    internal void WritePacket(PacketTag tag, Byte[] body, bool oldFormat);
    public void WriteObject(BcpgObject bcpgObject);
    public void WriteObjects(BcpgObject[] v);
    public virtual void Flush();
    public void Finish();
    public virtual void Close();
}
public class Org.BouncyCastle.Bcpg.CompressedDataPacket : InputStreamPacket {
    private CompressionAlgorithmTag algorithm;
    public CompressionAlgorithmTag Algorithm { get; }
    internal CompressedDataPacket(BcpgInputStream bcpgIn);
    public CompressionAlgorithmTag get_Algorithm();
}
public enum Org.BouncyCastle.Bcpg.CompressionAlgorithmTag : Enum {
    public int value__;
    public static CompressionAlgorithmTag Uncompressed;
    public static CompressionAlgorithmTag Zip;
    public static CompressionAlgorithmTag ZLib;
    public static CompressionAlgorithmTag BZip2;
}
public abstract class Org.BouncyCastle.Bcpg.ContainedPacket : Packet {
    public Byte[] GetEncoded();
    public abstract virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Crc24 : object {
    private static int Crc24Init;
    private static int Crc24Poly;
    private int crc;
    public int Value { get; }
    public void Update(int b);
    [ObsoleteAttribute("Use 'Value' property instead")]
public int GetValue();
    public int get_Value();
    public void Reset();
}
public class Org.BouncyCastle.Bcpg.DsaPublicBcpgKey : BcpgObject {
    private MPInteger p;
    private MPInteger q;
    private MPInteger g;
    private MPInteger y;
    public string Format { get; }
    public BigInteger G { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger Y { get; }
    public DsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public DsaPublicBcpgKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_G();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Bcpg.DsaSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public DsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public DsaSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey : BcpgObject {
    internal MPInteger p;
    internal MPInteger g;
    internal MPInteger y;
    public string Format { get; }
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Y { get; }
    public ElGamalPublicBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalPublicBcpgKey(BigInteger p, BigInteger g, BigInteger y);
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Y();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey : BcpgObject {
    internal MPInteger x;
    public string Format { get; }
    public BigInteger X { get; }
    public ElGamalSecretBcpgKey(BcpgInputStream bcpgIn);
    public ElGamalSecretBcpgKey(BigInteger x);
    public sealed virtual string get_Format();
    public BigInteger get_X();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ExperimentalPacket : ContainedPacket {
    private PacketTag tag;
    private Byte[] contents;
    public PacketTag Tag { get; }
    internal ExperimentalPacket(PacketTag tag, BcpgInputStream bcpgIn);
    public PacketTag get_Tag();
    public Byte[] GetContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public enum Org.BouncyCastle.Bcpg.HashAlgorithmTag : Enum {
    public int value__;
    public static HashAlgorithmTag MD5;
    public static HashAlgorithmTag Sha1;
    public static HashAlgorithmTag RipeMD160;
    public static HashAlgorithmTag DoubleSha;
    public static HashAlgorithmTag MD2;
    public static HashAlgorithmTag Tiger192;
    public static HashAlgorithmTag Haval5pass160;
    public static HashAlgorithmTag Sha256;
    public static HashAlgorithmTag Sha384;
    public static HashAlgorithmTag Sha512;
    public static HashAlgorithmTag Sha224;
}
public interface Org.BouncyCastle.Bcpg.IBcpgKey {
    public string Format { get; }
    public abstract virtual string get_Format();
}
public class Org.BouncyCastle.Bcpg.InputStreamPacket : Packet {
    private BcpgInputStream bcpgIn;
    public InputStreamPacket(BcpgInputStream bcpgIn);
    public BcpgInputStream GetInputStream();
}
public class Org.BouncyCastle.Bcpg.LiteralDataPacket : InputStreamPacket {
    private int format;
    private string fileName;
    private long modDate;
    public int Format { get; }
    public long ModificationTime { get; }
    public string FileName { get; }
    internal LiteralDataPacket(BcpgInputStream bcpgIn);
    public int get_Format();
    public long get_ModificationTime();
    public string get_FileName();
    public Byte[] GetRawFileName();
}
public class Org.BouncyCastle.Bcpg.MarkerPacket : ContainedPacket {
    private Byte[] marker;
    public MarkerPacket(BcpgInputStream bcpgIn);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.ModDetectionCodePacket : ContainedPacket {
    private Byte[] digest;
    internal ModDetectionCodePacket(BcpgInputStream bcpgIn);
    public ModDetectionCodePacket(Byte[] digest);
    public Byte[] GetDigest();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.MPInteger : BcpgObject {
    private BigInteger val;
    public BigInteger Value { get; }
    public MPInteger(BcpgInputStream bcpgIn);
    public MPInteger(BigInteger val);
    public BigInteger get_Value();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    internal static void Encode(BcpgOutputStream bcpgOut, BigInteger val);
}
public class Org.BouncyCastle.Bcpg.OnePassSignaturePacket : ContainedPacket {
    private int version;
    private int sigType;
    private HashAlgorithmTag hashAlgorithm;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private long keyId;
    private int nested;
    public int SignatureType { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long KeyId { get; }
    internal OnePassSignaturePacket(BcpgInputStream bcpgIn);
    public OnePassSignaturePacket(int sigType, HashAlgorithmTag hashAlgorithm, PublicKeyAlgorithmTag keyAlgorithm, long keyId, bool isNested);
    public int get_SignatureType();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public long get_KeyId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public interface Org.BouncyCastle.Bcpg.OpenPgp.IStreamGenerator {
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData : PgpObject {
    private CompressedDataPacket data;
    public CompressionAlgorithmTag Algorithm { get; }
    public PgpCompressedData(BcpgInputStream bcpgInput);
    public CompressionAlgorithmTag get_Algorithm();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator : object {
    private CompressionAlgorithmTag algorithm;
    private int compression;
    private Stream dOut;
    private BcpgOutputStream pkOut;
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm);
    public PgpCompressedDataGenerator(CompressionAlgorithmTag algorithm, int compression);
    public Stream Open(Stream outStr);
    public Stream Open(Stream outStr, Byte[] buffer);
    private void doOpen();
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException : PgpException {
    public PgpDataValidationException(string message);
    public PgpDataValidationException(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData : object {
    internal InputStreamPacket encData;
    internal Stream encStream;
    internal TruncatedStream truncStream;
    internal PgpEncryptedData(InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public bool IsIntegrityProtected();
    public bool Verify();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator : object {
    private BcpgOutputStream pOut;
    private CipherStream cOut;
    private IBufferedCipher c;
    private bool withIntegrityPacket;
    private bool oldFormat;
    private DigestStream digestOut;
    private ArrayList methods;
    private SymmetricKeyAlgorithmTag defAlgorithm;
    private SecureRandom rand;
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, bool withIntegrityPacket, SecureRandom rand);
    public PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag encAlgorithm, SecureRandom rand, bool oldFormat);
    public void AddMethod(Char[] passPhrase);
    public void AddMethod(PgpPublicKey key);
    private void AddCheckSum(Byte[] sessionInfo);
    private Byte[] CreateSessionInfo(SymmetricKeyAlgorithmTag algorithm, KeyParameter key);
    private Stream Open(Stream outStr, long length, Byte[] buffer);
    public Stream Open(Stream outStr, long length);
    public Stream Open(Stream outStr, Byte[] buffer);
    public sealed virtual void Close();
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList : PgpObject {
    private ArrayList list;
    private InputStreamPacket data;
    public PgpEncryptedData Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpEncryptedDataList(BcpgInputStream bcpgInput);
    public PgpEncryptedData get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public object Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
    public IEnumerable GetEncryptedDataObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpException : Exception {
    [ObsoleteAttribute("Use InnerException property")]
public Exception UnderlyingException { get; }
    public PgpException(string message);
    public PgpException(string message, Exception exception);
    public Exception get_UnderlyingException();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpExperimental : PgpObject {
    private ExperimentalPacket p;
    public PgpExperimental(BcpgInputStream bcpgIn);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags : object {
    public static int CanCertify;
    public static int CanSign;
    public static int CanEncryptCommunications;
    public static int CanEncryptStorage;
    public static int MaybeSplit;
    public static int MaybeShared;
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair : object {
    private PgpPublicKey pub;
    private PgpPrivateKey priv;
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public PgpPrivateKey PrivateKey { get; }
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricCipherKeyPair keyPair, DateTime time);
    public PgpKeyPair(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time);
    public PgpKeyPair(PgpPublicKey pub, PgpPrivateKey priv);
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public PgpPrivateKey get_PrivateKey();
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRing : PgpObject {
    internal static TrustPacket ReadOptionalTrustPacket(BcpgInputStream bcpgInput);
    internal static ArrayList ReadSignaturesAndTrust(BcpgInputStream bcpgInput);
    internal static void ReadUserIDs(BcpgInputStream bcpgInput, ArrayList& ids, ArrayList& idTrusts, ArrayList& idSigs);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator : object {
    private ArrayList keys;
    private string id;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private int certificationLevel;
    private Char[] passPhrase;
    private bool useSha1;
    private PgpKeyPair masterKey;
    private PgpSignatureSubpacketVector hashedPacketVector;
    private PgpSignatureSubpacketVector unhashedPacketVector;
    private SecureRandom rand;
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpKeyRingGenerator(int certificationLevel, PgpKeyPair masterKey, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public void AddSubKey(PgpKeyPair keyPair);
    public void AddSubKey(PgpKeyPair keyPair, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public PgpSecretKeyRing GenerateSecretKeyRing();
    public PgpPublicKeyRing GeneratePublicKeyRing();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException : PgpException {
    public PgpKeyValidationException(string message);
    public PgpKeyValidationException(string message, Exception exception);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData : PgpObject {
    public static char Binary;
    public static char Text;
    public static char Utf8;
    public static string Console;
    private LiteralDataPacket data;
    public int Format { get; }
    public string FileName { get; }
    public DateTime ModificationTime { get; }
    public PgpLiteralData(BcpgInputStream bcpgInput);
    public int get_Format();
    public string get_FileName();
    public Byte[] GetRawFileName();
    public DateTime get_ModificationTime();
    public Stream GetInputStream();
    public Stream GetDataStream();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator : object {
    public static char Binary;
    public static char Text;
    public static string Console;
    private BcpgOutputStream pkOut;
    private bool oldFormat;
    public PgpLiteralDataGenerator(bool oldFormat);
    private void WriteHeader(BcpgOutputStream outStr, char format, string name, long modificationTime);
    public Stream Open(Stream outStr, char format, string name, long length, DateTime modificationTime);
    public Stream Open(Stream outStr, char format, string name, DateTime modificationTime, Byte[] buffer);
    public Stream Open(Stream outStr, char format, FileInfo file);
    public sealed virtual void Close();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker : PgpObject {
    private MarkerPacket p;
    public PgpMarker(BcpgInputStream bcpgIn);
}
public abstract class Org.BouncyCastle.Bcpg.OpenPgp.PgpObject : object {
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory : object {
    private BcpgInputStream bcpgIn;
    public PgpObjectFactory(Stream inputStream);
    public PgpObjectFactory(Byte[] bytes);
    public PgpObject NextPgpObject();
    [ObsoleteAttribute("Use NextPgpObject() instead")]
public object NextObject();
    public IList AllPgpObjects();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature : object {
    private OnePassSignaturePacket sigPack;
    private int signatureType;
    private ISigner sig;
    private byte lastb;
    public long KeyId { get; }
    public int SignatureType { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    internal PgpOnePassSignature(BcpgInputStream bcpgInput);
    internal PgpOnePassSignature(OnePassSignaturePacket sigPack);
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify(PgpSignature pgpSig);
    public long get_KeyId();
    public int get_SignatureType();
    public HashAlgorithmTag get_HashAlgorithm();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList : PgpObject {
    private PgpOnePassSignature[] sigs;
    public PgpOnePassSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpOnePassSignatureList(PgpOnePassSignature[] sigs);
    public PgpOnePassSignatureList(PgpOnePassSignature sig);
    public PgpOnePassSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpOnePassSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData : PgpEncryptedData {
    private SymmetricKeyEncSessionPacket keyData;
    internal PgpPbeEncryptedData(SymmetricKeyEncSessionPacket keyData, InputStreamPacket encData);
    public virtual Stream GetInputStream();
    public Stream GetDataStream(Char[] passPhrase);
    private IBufferedCipher CreateStreamCipher(SymmetricKeyAlgorithmTag keyAlgorithm);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey : object {
    private long keyId;
    private AsymmetricKeyParameter privateKey;
    public long KeyId { get; }
    public AsymmetricKeyParameter Key { get; }
    public PgpPrivateKey(AsymmetricKeyParameter privateKey, long keyId);
    public long get_KeyId();
    public AsymmetricKeyParameter get_Key();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey : object {
    private static Int32[] MasterKeyCertificationTypes;
    private long keyId;
    private Byte[] fingerprint;
    private int keyStrength;
    internal PublicKeyPacket publicPk;
    internal TrustPacket trustPk;
    internal ArrayList keySigs;
    internal ArrayList ids;
    internal ArrayList idTrusts;
    internal ArrayList idSigs;
    internal ArrayList subSigs;
    public int Version { get; }
    public DateTime CreationTime { get; }
    public int ValidDays { get; }
    public long KeyId { get; }
    public bool IsEncryptionKey { get; }
    public bool IsMasterKey { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int BitStrength { get; }
    public PgpPublicKey(PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, DateTime time);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, ArrayList sigs);
    internal PgpPublicKey(PgpPublicKey key, TrustPacket trust, ArrayList subSigs);
    internal PgpPublicKey(PgpPublicKey pubKey);
    internal PgpPublicKey(PublicKeyPacket publicPk, TrustPacket trustPk, ArrayList keySigs, ArrayList ids, ArrayList idTrusts, ArrayList idSigs);
    internal PgpPublicKey(PublicKeyPacket publicPk, ArrayList ids, ArrayList idSigs);
    private static PgpPublicKey();
    private void Init();
    public int get_Version();
    public DateTime get_CreationTime();
    public int get_ValidDays();
    public Byte[] GetTrustData();
    public long GetValidSeconds();
    private long GetExpirationTimeFromSig(bool selfSigned, int signatureType);
    public long get_KeyId();
    public Byte[] GetFingerprint();
    public bool get_IsEncryptionKey();
    public bool get_IsMasterKey();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_BitStrength();
    public AsymmetricKeyParameter GetKey();
    public IEnumerable GetUserIds();
    public IEnumerable GetUserAttributes();
    public IEnumerable GetSignaturesForId(string id);
    public IEnumerable GetSignaturesForUserAttribute(PgpUserAttributeSubpacketVector userAttributes);
    public IEnumerable GetSignaturesOfType(int signatureType);
    public IEnumerable GetSignatures();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public bool IsRevoked();
    public static PgpPublicKey AddCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey AddCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, string id, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpUserAttributeSubpacketVector userAttributes, PgpSignature certification);
    private static PgpPublicKey RemoveCert(PgpPublicKey key, object id, PgpSignature certification);
    public static PgpPublicKey AddCertification(PgpPublicKey key, PgpSignature certification);
    public static PgpPublicKey RemoveCertification(PgpPublicKey key, PgpSignature certification);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData : PgpEncryptedData {
    private PublicKeyEncSessionPacket keyData;
    public long KeyId { get; }
    internal PgpPublicKeyEncryptedData(PublicKeyEncSessionPacket keyData, InputStreamPacket encData);
    private static IBufferedCipher GetKeyCipher(PublicKeyAlgorithmTag algorithm);
    private bool ConfirmCheckSum(Byte[] sessionInfo);
    public long get_KeyId();
    public SymmetricKeyAlgorithmTag GetSymmetricAlgorithm(PgpPrivateKey privKey);
    public Stream GetDataStream(PgpPrivateKey privKey);
    private Byte[] fetchSymmetricKeyData(PgpPrivateKey privKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing : PgpKeyRing {
    private ArrayList keys;
    public PgpPublicKeyRing(Byte[] encoding);
    internal PgpPublicKeyRing(ArrayList pubKeys);
    public PgpPublicKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public PgpPublicKey GetPublicKey(long keyId);
    public IEnumerable GetPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRing InsertPublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
    public static PgpPublicKeyRing RemovePublicKey(PgpPublicKeyRing pubRing, PgpPublicKey pubKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle : object {
    private IDictionary pubRings;
    private ArrayList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpPublicKeyRingBundle(IDictionary pubRings, ArrayList order);
    public PgpPublicKeyRingBundle(Byte[] encoding);
    public PgpPublicKeyRingBundle(Stream inputStream);
    public PgpPublicKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpPublicKey GetPublicKey(long keyId);
    public PgpPublicKeyRing GetPublicKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpPublicKeyRingBundle AddPublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
    public static PgpPublicKeyRingBundle RemovePublicKeyRing(PgpPublicKeyRingBundle bundle, PgpPublicKeyRing publicKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey : object {
    private SecretKeyPacket secret;
    private PgpPublicKey pub;
    public bool IsSigningKey { get; }
    public bool IsMasterKey { get; }
    public SymmetricKeyAlgorithmTag KeyEncryptionAlgorithm { get; }
    public long KeyId { get; }
    public PgpPublicKey PublicKey { get; }
    public IEnumerable UserIds { get; }
    public IEnumerable UserAttributes { get; }
    internal PgpSecretKey(SecretKeyPacket secret, PgpPublicKey pub);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, SecureRandom rand);
    internal PgpSecretKey(PgpPrivateKey privKey, PgpPublicKey pubKey, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, SecureRandom rand, bool isMasterKey);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PgpKeyPair keyPair, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    public PgpSecretKey(int certificationLevel, PublicKeyAlgorithmTag algorithm, AsymmetricKeyParameter pubKey, AsymmetricKeyParameter privKey, DateTime time, string id, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, bool useSha1, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets, SecureRandom rand);
    private static PgpPublicKey certifiedPublicKey(int certificationLevel, PgpKeyPair keyPair, string id, PgpSignatureSubpacketVector hashedPackets, PgpSignatureSubpacketVector unhashedPackets);
    public bool get_IsSigningKey();
    public bool get_IsMasterKey();
    public SymmetricKeyAlgorithmTag get_KeyEncryptionAlgorithm();
    public long get_KeyId();
    public PgpPublicKey get_PublicKey();
    public IEnumerable get_UserIds();
    public IEnumerable get_UserAttributes();
    private Byte[] ExtractKeyData(Char[] passPhrase);
    public PgpPrivateKey ExtractPrivateKey(Char[] passPhrase);
    private static Byte[] Checksum(bool useSha1, Byte[] bytes, int length);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKey CopyWithNewPassword(PgpSecretKey key, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKey ReplacePublicKey(PgpSecretKey secretKey, PgpPublicKey publicKey);
    private static Byte[] EncryptKeyData(Byte[] rawKeyData, SymmetricKeyAlgorithmTag encAlgorithm, Char[] passPhrase, SecureRandom random, S2k& s2k, Byte[]& iv);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing : PgpKeyRing {
    private IList keys;
    private IList extraPubKeys;
    internal PgpSecretKeyRing(IList keys);
    private PgpSecretKeyRing(IList keys, IList extraPubKeys);
    public PgpSecretKeyRing(Byte[] encoding);
    public PgpSecretKeyRing(Stream inputStream);
    public PgpPublicKey GetPublicKey();
    public PgpSecretKey GetSecretKey();
    public IEnumerable GetSecretKeys();
    public PgpSecretKey GetSecretKey(long keyId);
    public IEnumerable GetExtraPublicKeys();
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRing ReplacePublicKeys(PgpSecretKeyRing secretRing, PgpPublicKeyRing publicRing);
    public static PgpSecretKeyRing CopyWithNewPassword(PgpSecretKeyRing ring, Char[] oldPassPhrase, Char[] newPassPhrase, SymmetricKeyAlgorithmTag newEncAlgorithm, SecureRandom rand);
    public static PgpSecretKeyRing InsertSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
    public static PgpSecretKeyRing RemoveSecretKey(PgpSecretKeyRing secRing, PgpSecretKey secKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle : object {
    private IDictionary secretRings;
    private ArrayList order;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    private PgpSecretKeyRingBundle(IDictionary secretRings, ArrayList order);
    public PgpSecretKeyRingBundle(Byte[] encoding);
    public PgpSecretKeyRingBundle(Stream inputStream);
    public PgpSecretKeyRingBundle(IEnumerable e);
    public int get_Size();
    public int get_Count();
    public IEnumerable GetKeyRings();
    public IEnumerable GetKeyRings(string userId);
    public IEnumerable GetKeyRings(string userId, bool matchPartial);
    public IEnumerable GetKeyRings(string userId, bool matchPartial, bool ignoreCase);
    public PgpSecretKey GetSecretKey(long keyId);
    public PgpSecretKeyRing GetSecretKeyRing(long keyId);
    public bool Contains(long keyID);
    public Byte[] GetEncoded();
    public void Encode(Stream outStr);
    public static PgpSecretKeyRingBundle AddSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
    public static PgpSecretKeyRingBundle RemoveSecretKeyRing(PgpSecretKeyRingBundle bundle, PgpSecretKeyRing secretKeyRing);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature : object {
    public static int BinaryDocument;
    public static int CanonicalTextDocument;
    public static int StandAlone;
    public static int DefaultCertification;
    public static int NoCertification;
    public static int CasualCertification;
    public static int PositiveCertification;
    public static int SubkeyBinding;
    public static int PrimaryKeyBinding;
    public static int DirectKey;
    public static int KeyRevocation;
    public static int SubkeyRevocation;
    public static int CertificationRevocation;
    public static int Timestamp;
    private SignaturePacket sigPck;
    private int signatureType;
    private TrustPacket trustPck;
    private ISigner sig;
    private byte lastb;
    public int Version { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public DateTime CreationTime { get; }
    public bool HasSubpackets { get; }
    internal PgpSignature(BcpgInputStream bcpgInput);
    internal PgpSignature(SignaturePacket sigPacket);
    internal PgpSignature(SignaturePacket sigPacket, TrustPacket trustPacket);
    private void GetSig();
    public int get_Version();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public void InitVerify(PgpPublicKey pubKey);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    public void Update(Byte[] bytes);
    public void Update(Byte[] bytes, int off, int length);
    public bool Verify();
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
    public bool VerifyCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey key);
    public bool VerifyCertification(string id, PgpPublicKey key);
    public bool VerifyCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public bool VerifyCertification(PgpPublicKey pubKey);
    public int get_SignatureType();
    public long get_KeyId();
    [ObsoleteAttribute("Use 'CreationTime' property instead")]
public DateTime GetCreationTime();
    public DateTime get_CreationTime();
    public Byte[] GetSignatureTrailer();
    public bool get_HasSubpackets();
    public PgpSignatureSubpacketVector GetHashedSubPackets();
    public PgpSignatureSubpacketVector GetUnhashedSubPackets();
    private PgpSignatureSubpacketVector createSubpacketVector(SignatureSubpacket[] pcks);
    public Byte[] GetSignature();
    public Byte[] GetEncoded();
    public void Encode(Stream outStream);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator : object {
    private static SignatureSubpacket[] EmptySignatureSubpackets;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    private SignatureSubpacket[] unhashed;
    private SignatureSubpacket[] hashed;
    public PgpSignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    private static PgpSignatureGenerator();
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public void SetHashedSubpackets(PgpSignatureSubpacketVector hashedPackets);
    public void SetUnhashedSubpackets(PgpSignatureSubpacketVector unhashedPackets);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
    public PgpSignature GenerateCertification(string id, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey masterKey, PgpPublicKey pubKey);
    public PgpSignature GenerateCertification(PgpPublicKey pubKey);
    private Byte[] GetEncodedPublicKey(PgpPublicKey pubKey);
    private bool packetPresent(SignatureSubpacket[] packets, SignatureSubpacketTag type);
    private SignatureSubpacket[] insertSubpacket(SignatureSubpacket[] packets, SignatureSubpacket subpacket);
    private void UpdateWithIdData(int header, Byte[] idBytes);
    private void UpdateWithPublicKey(PgpPublicKey key);
}
[DefaultMemberAttribute("Item")]
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList : PgpObject {
    private PgpSignature[] sigs;
    public PgpSignature Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public PgpSignatureList(PgpSignature[] sigs);
    public PgpSignatureList(PgpSignature sig);
    public PgpSignature get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public PgpSignature Get(int index);
    public int get_Size();
    public int get_Count();
    public bool get_IsEmpty();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator : object {
    private ArrayList list;
    public void SetRevocable(bool isCritical, bool isRevocable);
    public void SetExportable(bool isCritical, bool isExportable);
    public void SetTrust(bool isCritical, int depth, int trustAmount);
    public void SetKeyExpirationTime(bool isCritical, long seconds);
    public void SetSignatureExpirationTime(bool isCritical, long seconds);
    public void SetSignatureCreationTime(bool isCritical, DateTime date);
    public void SetPreferredHashAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredSymmetricAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetPreferredCompressionAlgorithms(bool isCritical, Int32[] algorithms);
    public void SetKeyFlags(bool isCritical, int flags);
    public void SetSignerUserId(bool isCritical, string userId);
    public void SetEmbeddedSignature(bool isCritical, PgpSignature pgpSignature);
    public void SetPrimaryUserId(bool isCritical, bool isPrimaryUserId);
    public void SetNotationData(bool isCritical, bool isHumanReadable, string notationName, string notationValue);
    public PgpSignatureSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector : object {
    private SignatureSubpacket[] packets;
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    internal PgpSignatureSubpacketVector(SignatureSubpacket[] packets);
    public SignatureSubpacket GetSubpacket(SignatureSubpacketTag type);
    public bool HasSubpacket(SignatureSubpacketTag type);
    public SignatureSubpacket[] GetSubpackets(SignatureSubpacketTag type);
    public NotationData[] GetNotationDataOccurences();
    public long GetIssuerKeyId();
    public bool HasSignatureCreationTime();
    public DateTime GetSignatureCreationTime();
    public long GetSignatureExpirationTime();
    public long GetKeyExpirationTime();
    public Int32[] GetPreferredHashAlgorithms();
    public Int32[] GetPreferredSymmetricAlgorithms();
    public Int32[] GetPreferredCompressionAlgorithms();
    public int GetKeyFlags();
    public string GetSignerUserId();
    public bool IsPrimaryUserId();
    public SignatureSubpacketTag[] GetCriticalTags();
    public int get_Size();
    public int get_Count();
    internal SignatureSubpacket[] ToSubpacketArray();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector : object {
    private UserAttributeSubpacket[] packets;
    internal PgpUserAttributeSubpacketVector(UserAttributeSubpacket[] packets);
    public UserAttributeSubpacket GetSubpacket(UserAttributeSubpacketTag type);
    public ImageAttrib GetImageAttribute();
    internal UserAttributeSubpacket[] ToSubpacketArray();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVectorGenerator : object {
    private ArrayList list;
    public virtual void SetImageAttribute(Format imageType, Byte[] imageData);
    public virtual PgpUserAttributeSubpacketVector Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities : object {
    private static int ReadAhead;
    public static MPInteger[] DsaSigToMpi(Byte[] encoding);
    public static MPInteger[] RsaSigToMpi(Byte[] encoding);
    public static string GetDigestName(HashAlgorithmTag hashAlgorithm);
    public static string GetSignatureName(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public static string GetSymmetricCipherName(SymmetricKeyAlgorithmTag algorithm);
    public static int GetKeySize(SymmetricKeyAlgorithmTag algorithm);
    public static KeyParameter MakeKey(SymmetricKeyAlgorithmTag algorithm, Byte[] keyBytes);
    public static KeyParameter MakeRandomKey(SymmetricKeyAlgorithmTag algorithm, SecureRandom random);
    public static KeyParameter MakeKeyFromPassPhrase(SymmetricKeyAlgorithmTag algorithm, S2k s2k, Char[] passPhrase);
    public static void WriteFileToLiteralData(Stream outputStream, char fileType, FileInfo file);
    public static void WriteFileToLiteralData(Stream outputStream, char fileType, FileInfo file, Byte[] buffer);
    private static bool IsPossiblyBase64(int ch);
    public static Stream GetDecoderStream(Stream inputStream);
}
public class Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator : object {
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private PgpPrivateKey privKey;
    private ISigner sig;
    private IDigest dig;
    private int signatureType;
    private byte lastb;
    public PgpV3SignatureGenerator(PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm);
    public void InitSign(int sigType, PgpPrivateKey key);
    public void InitSign(int sigType, PgpPrivateKey key, SecureRandom random);
    public void Update(byte b);
    private void doCanonicalUpdateByte(byte b);
    private void doUpdateCRLF();
    private void doUpdateByte(byte b);
    public void Update(Byte[] b);
    public void Update(Byte[] b, int off, int len);
    public PgpOnePassSignature GenerateOnePassVersion(bool isNested);
    public PgpSignature Generate();
}
public class Org.BouncyCastle.Bcpg.OpenPgp.WrappedGeneratorStream : FilterStream {
    private IStreamGenerator gen;
    public WrappedGeneratorStream(IStreamGenerator gen, Stream str);
    public virtual void Close();
}
public abstract class Org.BouncyCastle.Bcpg.OutputStreamPacket : object {
    private BcpgOutputStream bcpgOut;
    internal OutputStreamPacket(BcpgOutputStream bcpgOut);
    public abstract virtual BcpgOutputStream Open();
    public abstract virtual void Close();
}
public class Org.BouncyCastle.Bcpg.Packet : object {
}
public enum Org.BouncyCastle.Bcpg.PacketTag : Enum {
    public int value__;
    public static PacketTag Reserved;
    public static PacketTag PublicKeyEncryptedSession;
    public static PacketTag Signature;
    public static PacketTag SymmetricKeyEncryptedSessionKey;
    public static PacketTag OnePassSignature;
    public static PacketTag SecretKey;
    public static PacketTag PublicKey;
    public static PacketTag SecretSubkey;
    public static PacketTag CompressedData;
    public static PacketTag SymmetricKeyEncrypted;
    public static PacketTag Marker;
    public static PacketTag LiteralData;
    public static PacketTag Trust;
    public static PacketTag UserId;
    public static PacketTag PublicSubkey;
    public static PacketTag UserAttribute;
    public static PacketTag SymmetricEncryptedIntegrityProtected;
    public static PacketTag ModificationDetectionCode;
    public static PacketTag Experimental1;
    public static PacketTag Experimental2;
    public static PacketTag Experimental3;
    public static PacketTag Experimental4;
}
public enum Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag : Enum {
    public int value__;
    public static PublicKeyAlgorithmTag RsaGeneral;
    public static PublicKeyAlgorithmTag RsaEncrypt;
    public static PublicKeyAlgorithmTag RsaSign;
    public static PublicKeyAlgorithmTag ElGamalEncrypt;
    public static PublicKeyAlgorithmTag Dsa;
    public static PublicKeyAlgorithmTag EC;
    public static PublicKeyAlgorithmTag ECDsa;
    public static PublicKeyAlgorithmTag ElGamalGeneral;
    public static PublicKeyAlgorithmTag DiffieHellman;
    public static PublicKeyAlgorithmTag Experimental_1;
    public static PublicKeyAlgorithmTag Experimental_2;
    public static PublicKeyAlgorithmTag Experimental_3;
    public static PublicKeyAlgorithmTag Experimental_4;
    public static PublicKeyAlgorithmTag Experimental_5;
    public static PublicKeyAlgorithmTag Experimental_6;
    public static PublicKeyAlgorithmTag Experimental_7;
    public static PublicKeyAlgorithmTag Experimental_8;
    public static PublicKeyAlgorithmTag Experimental_9;
    public static PublicKeyAlgorithmTag Experimental_10;
    public static PublicKeyAlgorithmTag Experimental_11;
}
public class Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket : ContainedPacket {
    private int version;
    private long keyId;
    private PublicKeyAlgorithmTag algorithm;
    private BigInteger[] data;
    public int Version { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    internal PublicKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public PublicKeyEncSessionPacket(long keyId, PublicKeyAlgorithmTag algorithm, BigInteger[] data);
    public int get_Version();
    public long get_KeyId();
    public PublicKeyAlgorithmTag get_Algorithm();
    public BigInteger[] GetEncSessionKey();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicKeyPacket : ContainedPacket {
    private int version;
    private long time;
    private int validDays;
    private PublicKeyAlgorithmTag algorithm;
    private IBcpgKey key;
    public int Version { get; }
    public PublicKeyAlgorithmTag Algorithm { get; }
    public int ValidDays { get; }
    public IBcpgKey Key { get; }
    internal PublicKeyPacket(BcpgInputStream bcpgIn);
    public PublicKeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public int get_Version();
    public PublicKeyAlgorithmTag get_Algorithm();
    public int get_ValidDays();
    public DateTime GetTime();
    public IBcpgKey get_Key();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.PublicSubkeyPacket : PublicKeyPacket {
    internal PublicSubkeyPacket(BcpgInputStream bcpgIn);
    public PublicSubkeyPacket(PublicKeyAlgorithmTag algorithm, DateTime time, IBcpgKey key);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RsaPublicBcpgKey : BcpgObject {
    private MPInteger n;
    private MPInteger e;
    public BigInteger PublicExponent { get; }
    public BigInteger Modulus { get; }
    public string Format { get; }
    public RsaPublicBcpgKey(BcpgInputStream bcpgIn);
    public RsaPublicBcpgKey(BigInteger n, BigInteger e);
    public BigInteger get_PublicExponent();
    public BigInteger get_Modulus();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.RsaSecretBcpgKey : BcpgObject {
    private MPInteger d;
    private MPInteger p;
    private MPInteger q;
    private MPInteger u;
    private BigInteger expP;
    private BigInteger expQ;
    private BigInteger crt;
    public BigInteger Modulus { get; }
    public BigInteger PrivateExponent { get; }
    public BigInteger PrimeP { get; }
    public BigInteger PrimeQ { get; }
    public BigInteger PrimeExponentP { get; }
    public BigInteger PrimeExponentQ { get; }
    public BigInteger CrtCoefficient { get; }
    public string Format { get; }
    public RsaSecretBcpgKey(BcpgInputStream bcpgIn);
    public RsaSecretBcpgKey(BigInteger d, BigInteger p, BigInteger q);
    public BigInteger get_Modulus();
    public BigInteger get_PrivateExponent();
    public BigInteger get_PrimeP();
    public BigInteger get_PrimeQ();
    public BigInteger get_PrimeExponentP();
    public BigInteger get_PrimeExponentQ();
    public BigInteger get_CrtCoefficient();
    public sealed virtual string get_Format();
    public virtual Byte[] GetEncoded();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.S2k : BcpgObject {
    private static int ExpBias;
    public static int Simple;
    public static int Salted;
    public static int SaltedAndIterated;
    public static int GnuDummyS2K;
    internal int type;
    internal HashAlgorithmTag algorithm;
    internal Byte[] iv;
    internal int itCount;
    internal int protectionMode;
    public int Type { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long IterationCount { get; }
    public int ProtectionMode { get; }
    internal S2k(Stream inStr);
    public S2k(HashAlgorithmTag algorithm);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv);
    public S2k(HashAlgorithmTag algorithm, Byte[] iv, int itCount);
    public int get_Type();
    public HashAlgorithmTag get_HashAlgorithm();
    public Byte[] GetIV();
    [ObsoleteAttribute("Use 'IterationCount' property instead")]
public long GetIterationCount();
    public long get_IterationCount();
    public int get_ProtectionMode();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretKeyPacket : ContainedPacket {
    public static int UsageNone;
    public static int UsageChecksum;
    public static int UsageSha1;
    private PublicKeyPacket pubKeyPacket;
    private Byte[] secKeyData;
    private int s2kUsage;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] iv;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public int S2kUsage { get; }
    public S2k S2k { get; }
    public PublicKeyPacket PublicKeyPacket { get; }
    internal SecretKeyPacket(BcpgInputStream bcpgIn);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretKeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public int get_S2kUsage();
    public Byte[] GetIV();
    public S2k get_S2k();
    public PublicKeyPacket get_PublicKeyPacket();
    public Byte[] GetSecretKeyData();
    public Byte[] GetEncodedContents();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.SecretSubkeyPacket : SecretKeyPacket {
    internal SecretSubkeyPacket(BcpgInputStream bcpgIn);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public SecretSubkeyPacket(PublicKeyPacket pubKeyPacket, SymmetricKeyAlgorithmTag encAlgorithm, int s2kUsage, S2k s2k, Byte[] iv, Byte[] secKeyData);
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature : SignatureSubpacket {
    public EmbeddedSignature(bool critical, Byte[] data);
}
public class Org.BouncyCastle.Bcpg.Sig.Exportable : SignatureSubpacket {
    public Exportable(bool critical, Byte[] data);
    public Exportable(bool critical, bool isExportable);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsExportable();
}
public class Org.BouncyCastle.Bcpg.Sig.IssuerKeyId : SignatureSubpacket {
    public long KeyId { get; }
    public IssuerKeyId(bool critical, Byte[] data);
    public IssuerKeyId(bool critical, long keyId);
    protected static Byte[] KeyIdToBytes(long keyId);
    public long get_KeyId();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public KeyExpirationTime(bool critical, Byte[] data);
    public KeyExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.KeyFlags : SignatureSubpacket {
    public static int CertifyOther;
    public static int SignData;
    public static int EncryptComms;
    public static int EncryptStorage;
    public static int Split;
    public static int Authentication;
    public static int Shared;
    public int Flags { get; }
    public KeyFlags(bool critical, Byte[] data);
    public KeyFlags(bool critical, int flags);
    private static Byte[] IntToByteArray(int v);
    public int get_Flags();
}
public class Org.BouncyCastle.Bcpg.Sig.NotationData : SignatureSubpacket {
    public static int HeaderFlagLength;
    public static int HeaderNameLength;
    public static int HeaderValueLength;
    public bool IsHumanReadable { get; }
    public NotationData(bool critical, Byte[] data);
    public NotationData(bool critical, bool humanReadable, string notationName, string notationValue);
    private static Byte[] createData(bool humanReadable, string notationName, string notationValue);
    public bool get_IsHumanReadable();
    public string GetNotationName();
    public string GetNotationValue();
    public Byte[] GetNotationValueBytes();
}
public class Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms : SignatureSubpacket {
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Byte[] data);
    public PreferredAlgorithms(SignatureSubpacketTag type, bool critical, Int32[] preferences);
    private static Byte[] IntToByteArray(Int32[] v);
    public Int32[] GetPreferences();
}
public class Org.BouncyCastle.Bcpg.Sig.PrimaryUserId : SignatureSubpacket {
    public PrimaryUserId(bool critical, Byte[] data);
    public PrimaryUserId(bool critical, bool isPrimaryUserId);
    private static Byte[] BooleanToByteArray(bool val);
    public bool IsPrimaryUserId();
}
public class Org.BouncyCastle.Bcpg.Sig.Revocable : SignatureSubpacket {
    public Revocable(bool critical, Byte[] data);
    public Revocable(bool critical, bool isRevocable);
    private static Byte[] BooleanToByteArray(bool value);
    public bool IsRevocable();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime : SignatureSubpacket {
    public SignatureCreationTime(bool critical, Byte[] data);
    public SignatureCreationTime(bool critical, DateTime date);
    protected static Byte[] TimeToBytes(DateTime time);
    public DateTime GetTime();
}
public class Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime : SignatureSubpacket {
    public long Time { get; }
    public SignatureExpirationTime(bool critical, Byte[] data);
    public SignatureExpirationTime(bool critical, long seconds);
    protected static Byte[] TimeToBytes(long t);
    public long get_Time();
}
public class Org.BouncyCastle.Bcpg.Sig.SignerUserId : SignatureSubpacket {
    public SignerUserId(bool critical, Byte[] data);
    public SignerUserId(bool critical, string userId);
    private static Byte[] UserIdToBytes(string id);
    public string GetId();
}
public class Org.BouncyCastle.Bcpg.Sig.TrustSignature : SignatureSubpacket {
    public int Depth { get; }
    public int TrustAmount { get; }
    public TrustSignature(bool critical, Byte[] data);
    public TrustSignature(bool critical, int depth, int trustAmount);
    private static Byte[] IntToByteArray(int v1, int v2);
    public int get_Depth();
    public int get_TrustAmount();
}
public class Org.BouncyCastle.Bcpg.SignaturePacket : ContainedPacket {
    private int version;
    private int signatureType;
    private long creationTime;
    private long keyId;
    private PublicKeyAlgorithmTag keyAlgorithm;
    private HashAlgorithmTag hashAlgorithm;
    private MPInteger[] signature;
    private Byte[] fingerprint;
    private SignatureSubpacket[] hashedData;
    private SignatureSubpacket[] unhashedData;
    private Byte[] signatureEncoding;
    public int Version { get; }
    public int SignatureType { get; }
    public long KeyId { get; }
    public PublicKeyAlgorithmTag KeyAlgorithm { get; }
    public HashAlgorithmTag HashAlgorithm { get; }
    public long CreationTime { get; }
    internal SignaturePacket(BcpgInputStream bcpgIn);
    public SignaturePacket(int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, long creationTime, Byte[] fingerprint, MPInteger[] signature);
    public SignaturePacket(int version, int signatureType, long keyId, PublicKeyAlgorithmTag keyAlgorithm, HashAlgorithmTag hashAlgorithm, SignatureSubpacket[] hashedData, SignatureSubpacket[] unhashedData, Byte[] fingerprint, MPInteger[] signature);
    public int get_Version();
    public int get_SignatureType();
    public long get_KeyId();
    public Byte[] GetSignatureTrailer();
    public PublicKeyAlgorithmTag get_KeyAlgorithm();
    public HashAlgorithmTag get_HashAlgorithm();
    public MPInteger[] GetSignature();
    public Byte[] GetSignatureBytes();
    public SignatureSubpacket[] GetHashedSubPackets();
    public SignatureSubpacket[] GetUnhashedSubPackets();
    public long get_CreationTime();
    public virtual void Encode(BcpgOutputStream bcpgOut);
    private static void EncodeLengthAndData(BcpgOutputStream pOut, Byte[] data);
    private static Byte[] GetEncodedSubpackets(SignatureSubpacket[] ps);
    private void setCreationTime();
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacket : object {
    private SignatureSubpacketTag type;
    private bool critical;
    internal Byte[] data;
    public SignatureSubpacketTag SubpacketType { get; }
    protected internal SignatureSubpacket(SignatureSubpacketTag type, bool critical, Byte[] data);
    public SignatureSubpacketTag get_SubpacketType();
    public bool IsCritical();
    public Byte[] GetData();
    public void Encode(Stream os);
}
public class Org.BouncyCastle.Bcpg.SignatureSubpacketsParser : object {
    private Stream input;
    public SignatureSubpacketsParser(Stream input);
    public SignatureSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.SignatureSubpacketTag : Enum {
    public int value__;
    public static SignatureSubpacketTag CreationTime;
    public static SignatureSubpacketTag ExpireTime;
    public static SignatureSubpacketTag Exportable;
    public static SignatureSubpacketTag TrustSig;
    public static SignatureSubpacketTag RegExp;
    public static SignatureSubpacketTag Revocable;
    public static SignatureSubpacketTag KeyExpireTime;
    public static SignatureSubpacketTag Placeholder;
    public static SignatureSubpacketTag PreferredSymmetricAlgorithms;
    public static SignatureSubpacketTag RevocationKey;
    public static SignatureSubpacketTag IssuerKeyId;
    public static SignatureSubpacketTag NotationData;
    public static SignatureSubpacketTag PreferredHashAlgorithms;
    public static SignatureSubpacketTag PreferredCompressionAlgorithms;
    public static SignatureSubpacketTag KeyServerPreferences;
    public static SignatureSubpacketTag PreferredKeyServer;
    public static SignatureSubpacketTag PrimaryUserId;
    public static SignatureSubpacketTag PolicyUrl;
    public static SignatureSubpacketTag KeyFlags;
    public static SignatureSubpacketTag SignerUserId;
    public static SignatureSubpacketTag RevocationReason;
    public static SignatureSubpacketTag Features;
    public static SignatureSubpacketTag SignatureTarget;
    public static SignatureSubpacketTag EmbeddedSignature;
}
public class Org.BouncyCastle.Bcpg.SymmetricEncDataPacket : InputStreamPacket {
    public SymmetricEncDataPacket(BcpgInputStream bcpgIn);
}
public class Org.BouncyCastle.Bcpg.SymmetricEncIntegrityPacket : InputStreamPacket {
    internal int version;
    internal SymmetricEncIntegrityPacket(BcpgInputStream bcpgIn);
}
public enum Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag : Enum {
    public int value__;
    public static SymmetricKeyAlgorithmTag Null;
    public static SymmetricKeyAlgorithmTag Idea;
    public static SymmetricKeyAlgorithmTag TripleDes;
    public static SymmetricKeyAlgorithmTag Cast5;
    public static SymmetricKeyAlgorithmTag Blowfish;
    public static SymmetricKeyAlgorithmTag Safer;
    public static SymmetricKeyAlgorithmTag Des;
    public static SymmetricKeyAlgorithmTag Aes128;
    public static SymmetricKeyAlgorithmTag Aes192;
    public static SymmetricKeyAlgorithmTag Aes256;
    public static SymmetricKeyAlgorithmTag Twofish;
}
public class Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket : ContainedPacket {
    private int version;
    private SymmetricKeyAlgorithmTag encAlgorithm;
    private S2k s2k;
    private Byte[] secKeyData;
    public SymmetricKeyAlgorithmTag EncAlgorithm { get; }
    public S2k S2k { get; }
    public int Version { get; }
    public SymmetricKeyEncSessionPacket(BcpgInputStream bcpgIn);
    public SymmetricKeyEncSessionPacket(SymmetricKeyAlgorithmTag encAlgorithm, S2k s2k, Byte[] secKeyData);
    public SymmetricKeyAlgorithmTag get_EncAlgorithm();
    public S2k get_S2k();
    public Byte[] GetSecKeyData();
    public int get_Version();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.TrustPacket : ContainedPacket {
    private Byte[] levelAndTrustAmount;
    public TrustPacket(BcpgInputStream bcpgIn);
    public TrustPacket(int trustCode);
    public Byte[] GetLevelAndTrustAmount();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributePacket : ContainedPacket {
    private UserAttributeSubpacket[] subpackets;
    public UserAttributePacket(BcpgInputStream bcpgIn);
    public UserAttributePacket(UserAttributeSubpacket[] subpackets);
    public UserAttributeSubpacket[] GetSubpackets();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacket : object {
    private UserAttributeSubpacketTag type;
    private Byte[] data;
    public UserAttributeSubpacketTag SubpacketType { get; }
    internal UserAttributeSubpacket(UserAttributeSubpacketTag type, Byte[] data);
    public UserAttributeSubpacketTag get_SubpacketType();
    public Byte[] GetData();
    public void Encode(Stream os);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser : object {
    private Stream input;
    public UserAttributeSubpacketsParser(Stream input);
    public UserAttributeSubpacket ReadPacket();
}
public enum Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag : Enum {
    public int value__;
    public static UserAttributeSubpacketTag ImageAttribute;
}
public class Org.BouncyCastle.Bcpg.UserIdPacket : ContainedPacket {
    private Byte[] idData;
    public UserIdPacket(BcpgInputStream bcpgIn);
    public UserIdPacket(string id);
    public string GetId();
    public virtual void Encode(BcpgOutputStream bcpgOut);
}
internal class Org.BouncyCastle.Cms.BaseDigestCalculator : object {
    private Byte[] digest;
    internal BaseDigestCalculator(Byte[] digest);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.CmsAttributeTableGenerationException : CmsException {
    public CmsAttributeTableGenerationException(string name);
    public CmsAttributeTableGenerationException(string name, Exception e);
}
public interface Org.BouncyCastle.Cms.CmsAttributeTableGenerator {
    public abstract virtual AttributeTable GetAttributes(IDictionary parameters);
}
public enum Org.BouncyCastle.Cms.CmsAttributeTableParameter : Enum {
    public int value__;
    public static CmsAttributeTableParameter ContentType;
    public static CmsAttributeTableParameter Digest;
    public static CmsAttributeTableParameter Signature;
    public static CmsAttributeTableParameter DigestAlgorithmIdentifier;
}
public class Org.BouncyCastle.Cms.CmsCompressedData : object {
    internal ContentInfo contentInfo;
    public ContentInfo ContentInfo { get; }
    public CmsCompressedData(Byte[] compressedData);
    public CmsCompressedData(Stream compressedDataStream);
    public CmsCompressedData(ContentInfo contentInfo);
    public Byte[] GetContent();
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataGenerator : object {
    public static string ZLib;
    public CmsCompressedData Generate(CmsProcessable content, string compressionOid);
}
public class Org.BouncyCastle.Cms.CmsCompressedDataParser : CmsContentInfoParser {
    public CmsCompressedDataParser(Byte[] compressedData);
    public CmsCompressedDataParser(Stream compressedData);
    public CmsTypedStream GetContent();
}
public class Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator : object {
    public static string ZLib;
    public Stream Open(Stream outStream, string compressionOID);
    public Stream Open(Stream outStream, string contentOID, string compressionOID);
}
public class Org.BouncyCastle.Cms.CmsContentInfoParser : object {
    protected ContentInfoParser contentInfo;
    protected Stream data;
    protected CmsContentInfoParser(Stream data);
    public void Close();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedData : object {
    internal RecipientInformationStore recipientInfoStore;
    internal ContentInfo contentInfo;
    private AlgorithmIdentifier encAlg;
    private Asn1Set unprotectedAttributes;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public ContentInfo ContentInfo { get; }
    public CmsEnvelopedData(Byte[] envelopedData);
    public CmsEnvelopedData(Stream envelopedData);
    public CmsEnvelopedData(ContentInfo contentInfo);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public RecipientInformationStore GetRecipientInfos();
    public ContentInfo get_ContentInfo();
    public AttributeTable GetUnprotectedAttributes();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator : CmsEnvelopedGenerator {
    public CmsEnvelopedDataGenerator(SecureRandom rand);
    private CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, CipherKeyGenerator keyGen);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid);
    public CmsEnvelopedData Generate(CmsProcessable content, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataParser : CmsContentInfoParser {
    internal RecipientInformationStore recipientInfoStore;
    internal EnvelopedDataParser envelopedData;
    private AlgorithmIdentifier _encAlg;
    private AttributeTable _unprotectedAttributes;
    private bool _attrNotRead;
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public CmsEnvelopedDataParser(Byte[] envelopedData);
    public CmsEnvelopedDataParser(Stream envelopedData);
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public RecipientInformationStore GetRecipientInfos();
    public AttributeTable GetUnprotectedAttributes();
}
public class Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator : CmsEnvelopedGenerator {
    private object _originatorInfo;
    private object _unprotectedAttributes;
    private int _bufferSize;
    private bool _berEncodeRecipientSet;
    private DerInteger Version { get; }
    public CmsEnvelopedDataStreamGenerator(SecureRandom rand);
    public void SetBufferSize(int bufferSize);
    public void SetBerEncodeRecipients(bool berEncodeRecipientSet);
    private DerInteger get_Version();
    private Stream Open(Stream outStream, string encryptionOid, CipherKeyGenerator keyGen);
    private Stream Open(Stream outStream, AlgorithmIdentifier encAlgID, ICipherParameters cipherParameters, Asn1EncodableVector recipientInfos);
    public Stream Open(Stream outStream, string encryptionOid);
    public Stream Open(Stream outStream, string encryptionOid, int keySize);
}
public class Org.BouncyCastle.Cms.CmsEnvelopedGenerator : object {
    public static string IdeaCbc;
    public static string Cast5Cbc;
    internal static Int16[] rc2Table;
    internal static Int16[] rc2Ekb;
    public static string DesEde3Cbc;
    public static string RC2Cbc;
    public static string Aes128Cbc;
    public static string Aes192Cbc;
    public static string Aes256Cbc;
    public static string Camellia128Cbc;
    public static string Camellia192Cbc;
    public static string Camellia256Cbc;
    public static string SeedCbc;
    public static string DesEde3Wrap;
    public static string Aes128Wrap;
    public static string Aes192Wrap;
    public static string Aes256Wrap;
    public static string Camellia128Wrap;
    public static string Camellia192Wrap;
    public static string Camellia256Wrap;
    public static string SeedWrap;
    public static string ECDHSha1Kdf;
    internal static CmsEnvelopedHelper Helper;
    internal IList recipientInfs;
    internal SecureRandom rand;
    public CmsEnvelopedGenerator(SecureRandom rand);
    private static CmsEnvelopedGenerator();
    public void AddKeyTransRecipient(X509Certificate cert);
    public void AddKeyTransRecipient(AsymmetricKeyParameter pubKey, Byte[] subKeyId);
    public void AddKekRecipient(string keyAlgorithm, KeyParameter key, Byte[] keyIdentifier);
    public void AddPasswordRecipient(CmsPbeKey pbeKey, string kekAlgorithmOid);
    public void AddKeyAgreementRecipient(string agreementAlgorithm, AsymmetricKeyParameter senderPrivateKey, AsymmetricKeyParameter senderPublicKey, X509Certificate recipientCert, string cekWrapAlgorithm);
    protected internal virtual AlgorithmIdentifier GetAlgorithmIdentifier(string encryptionOid, KeyParameter encKey, Asn1Encodable asn1Params, ICipherParameters& cipherParameters);
    protected internal virtual Asn1Encodable GenerateAsn1Parameters(string encryptionOid, Byte[] encKeyBytes);
}
internal class Org.BouncyCastle.Cms.CmsEnvelopedHelper : object {
    internal static CmsEnvelopedHelper Instance;
    private static IDictionary KeySizes;
    private static IDictionary BaseCipherNames;
    private static CmsEnvelopedHelper();
    private string GetAsymmetricEncryptionAlgName(string encryptionAlgOid);
    internal IBufferedCipher CreateAsymmetricCipher(string encryptionOid);
    internal IWrapper CreateWrapper(string encryptionOid);
    internal string GetRfc3211WrapperName(string oid);
    internal int GetKeySize(string oid);
}
public class Org.BouncyCastle.Cms.CmsException : Exception {
    public CmsException(string name);
    public CmsException(string name, Exception e);
}
public abstract class Org.BouncyCastle.Cms.CmsPbeKey : object {
    private string password;
    private Byte[] salt;
    private int iterationCount;
    public string Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public string Algorithm { get; }
    public string Format { get; }
    public CmsPbeKey(string password, Byte[] salt, int iterationCount);
    public CmsPbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    public string get_Password();
    public Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property instead")]
public Byte[] GetSalt();
    public int get_IterationCount();
    public string get_Algorithm();
    public string get_Format();
    public Byte[] GetEncoded();
    internal abstract virtual KeyParameter GetEncoded(string algorithmOid);
}
public interface Org.BouncyCastle.Cms.CmsProcessable {
    public abstract virtual Stream Read();
    public abstract virtual void Write(Stream outStream);
    public abstract virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableByteArray : object {
    private Byte[] bytes;
    public CmsProcessableByteArray(Byte[] bytes);
    public virtual Stream Read();
    public virtual void Write(Stream zOut);
    public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsProcessableFile : object {
    private static int DefaultBufSize;
    private FileInfo _file;
    private int _bufSize;
    public CmsProcessableFile(FileInfo file);
    public CmsProcessableFile(FileInfo file, int bufSize);
    public virtual Stream Read();
    public virtual void Write(Stream zOut);
    public virtual object GetContent();
}
public class Org.BouncyCastle.Cms.CmsSignedData : object {
    private static CmsSignedHelper Helper;
    private CmsProcessable signedContent;
    private SignedData signedData;
    private ContentInfo contentInfo;
    private SignerInformationStore signerInfoStore;
    private IX509Store attrCertStore;
    private IX509Store certificateStore;
    private IX509Store crlStore;
    private IDictionary hashes;
    public int Version { get; }
    [ObsoleteAttribute("Use 'SignedContentType' property instead.")]
public string SignedContentTypeOid { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsProcessable SignedContent { get; }
    public ContentInfo ContentInfo { get; }
    private CmsSignedData(CmsSignedData c);
    public CmsSignedData(Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Byte[] sigBlock);
    public CmsSignedData(IDictionary hashes, Byte[] sigBlock);
    public CmsSignedData(CmsProcessable signedContent, Stream sigData);
    public CmsSignedData(Stream sigData);
    public CmsSignedData(CmsProcessable signedContent, ContentInfo sigData);
    public CmsSignedData(IDictionary hashes, ContentInfo sigData);
    public CmsSignedData(ContentInfo sigData);
    private static CmsSignedData();
    public int get_Version();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public string get_SignedContentTypeOid();
    public DerObjectIdentifier get_SignedContentType();
    public CmsProcessable get_SignedContent();
    public ContentInfo get_ContentInfo();
    public Byte[] GetEncoded();
    public static CmsSignedData ReplaceSigners(CmsSignedData signedData, SignerInformationStore signerInformationStore);
    public static CmsSignedData ReplaceCertificatesAndCrls(CmsSignedData signedData, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts);
}
public class Org.BouncyCastle.Cms.CmsSignedDataGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private ArrayList signerInfs;
    public CmsSignedDataGenerator(SecureRandom rand);
    private static CmsSignedDataGenerator();
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOID, CmsAttributeTableGenerator signedAttrGen, CmsAttributeTableGenerator unsignedAttrGen);
    public CmsSignedData Generate(CmsProcessable content);
    public CmsSignedData Generate(string signedContentType, CmsProcessable content, bool encapsulate);
    public CmsSignedData Generate(CmsProcessable content, bool encapsulate);
    public SignerInformationStore GenerateCounterSigners(SignerInformation signer);
}
public class Org.BouncyCastle.Cms.CmsSignedDataParser : CmsContentInfoParser {
    private static CmsSignedHelper Helper;
    private SignedDataParser _signedData;
    private DerObjectIdentifier _signedContentType;
    private CmsTypedStream _signedContent;
    private IDictionary _digests;
    private ISet _digestOids;
    private SignerInformationStore _signerInfoStore;
    private Asn1Set _certSet;
    private Asn1Set _crlSet;
    private bool _isCertCrlParsed;
    private IX509Store _attributeStore;
    private IX509Store _certificateStore;
    private IX509Store _crlStore;
    public int Version { get; }
    public ISet DigestOids { get; }
    public DerObjectIdentifier SignedContentType { get; }
    public CmsSignedDataParser(Byte[] sigBlock);
    public CmsSignedDataParser(CmsTypedStream signedContent, Byte[] sigBlock);
    public CmsSignedDataParser(Stream sigData);
    public CmsSignedDataParser(CmsTypedStream signedContent, Stream sigData);
    private static CmsSignedDataParser();
    public int get_Version();
    public ISet get_DigestOids();
    public SignerInformationStore GetSignerInfos();
    public IX509Store GetAttributeCertificates(string type);
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    private void PopulateCertCrlSets();
    public DerObjectIdentifier get_SignedContentType();
    public CmsTypedStream GetSignedContent();
    public static Stream ReplaceSigners(Stream original, SignerInformationStore signerInformationStore, Stream outStr);
    public static Stream ReplaceCertificatesAndCrls(Stream original, IX509Store x509Certs, IX509Store x509Crls, IX509Store x509AttrCerts, Stream outStr);
    private static Asn1Set GetAsn1Set(Asn1SetParser asn1SetParser);
}
public class Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator : CmsSignedGenerator {
    private static CmsSignedHelper Helper;
    private ArrayList _signerInfs;
    private ISet _messageDigestOids;
    private Hashtable _messageDigests;
    private Hashtable _messageHashes;
    private bool _messageDigestsLocked;
    private int _bufferSize;
    public CmsSignedDataStreamGenerator(SecureRandom rand);
    private static CmsSignedDataStreamGenerator();
    public void SetBufferSize(int bufferSize);
    public void AddDigests(String[] digestOids);
    public void AddDigests(IEnumerable digestOids);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, X509Certificate cert, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void AddSigner(AsymmetricKeyParameter privateKey, Byte[] subjectKeyID, string digestOid, CmsAttributeTableGenerator signedAttrGenerator, CmsAttributeTableGenerator unsignedAttrGenerator);
    internal virtual void AddSignerCallback(SignerInformation si);
    public Stream Open(Stream outStream);
    public Stream Open(Stream outStream, bool encapsulate);
    public Stream Open(Stream outStream, bool encapsulate, Stream dataOutputStream);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate);
    public Stream Open(Stream outStream, string signedContentType, bool encapsulate, Stream dataOutputStream);
    private void RegisterDigestOid(string digestOid);
    private void ConfigureDigest(string digestOid);
    private DerInteger CalculateVersion(string contentOid);
    private bool CheckForVersion3(IList signerInfos);
}
public class Org.BouncyCastle.Cms.CmsSignedGenerator : object {
    public static string Data;
    public static string DigestSha1;
    public static string DigestSha224;
    public static string DigestSha256;
    public static string DigestSha384;
    public static string DigestSha512;
    public static string DigestMD5;
    public static string DigestGost3411;
    public static string DigestRipeMD128;
    public static string DigestRipeMD160;
    public static string DigestRipeMD256;
    public static string EncryptionRsa;
    public static string EncryptionDsa;
    public static string EncryptionECDsa;
    public static string EncryptionRsaPss;
    public static string EncryptionGost3410;
    public static string EncryptionECGost3410;
    private static string EncryptionECDsaWithSha1;
    private static string EncryptionECDsaWithSha224;
    private static string EncryptionECDsaWithSha256;
    private static string EncryptionECDsaWithSha384;
    private static string EncryptionECDsaWithSha512;
    private static ISet noParams;
    private static Hashtable ecAlgorithms;
    internal ArrayList _certs;
    internal ArrayList _crls;
    internal ArrayList _signers;
    internal IDictionary _digests;
    protected SecureRandom rand;
    private static CmsSignedGenerator();
    protected CmsSignedGenerator(SecureRandom rand);
    protected string GetEncOid(AsymmetricKeyParameter key, string digestOID);
    internal static AlgorithmIdentifier GetEncAlgorithmIdentifier(string encOid);
    protected internal virtual IDictionary GetBaseParameters(DerObjectIdentifier contentType, AlgorithmIdentifier digAlgId, Byte[] hash);
    protected internal virtual Asn1Set GetAttributeSet(AttributeTable attr);
    public void AddCertificates(IX509Store certStore);
    public void AddCrls(IX509Store crlStore);
    public void AddAttributeCertificates(IX509Store store);
    public void AddSigners(SignerInformationStore signerStore);
    public IDictionary GetGeneratedDigests();
    internal virtual void AddSignerCallback(SignerInformation si);
}
internal class Org.BouncyCastle.Cms.CmsSignedHelper : object {
    internal static CmsSignedHelper Instance;
    private static Hashtable encryptionAlgs;
    private static Hashtable digestAlgs;
    private static Hashtable digestAliases;
    private static CmsSignedHelper();
    private static void AddEntries(DerObjectIdentifier oid, string digest, string encryption);
    internal string GetDigestAlgName(string digestAlgOid);
    internal String[] GetDigestAliases(string algName);
    internal string GetEncryptionAlgName(string encryptionAlgOid);
    internal IDigest GetDigestInstance(string algorithm);
    internal ISigner GetSignatureInstance(string algorithm);
    internal IX509Store CreateAttributeStore(string type, Asn1Set certSet);
    internal IX509Store CreateCertificateStore(string type, Asn1Set certSet);
    internal IX509Store CreateCrlStore(string type, Asn1Set crlSet);
    private void AddCertsFromSet(IList certs, Asn1Set certSet);
    private void AddCrlsFromSet(IList crls, Asn1Set crlSet);
    internal AlgorithmIdentifier FixAlgID(AlgorithmIdentifier algId);
    private bool anyCertHasTypeOther();
    private bool anyCertHasV1Attribute();
    private bool anyCertHasV2Attribute();
    private bool anyCrlHasTypeOther();
}
public class Org.BouncyCastle.Cms.CmsTypedStream : object {
    private static int BufferSize;
    private string _oid;
    private Stream _in;
    public string ContentType { get; }
    public Stream ContentStream { get; }
    public CmsTypedStream(Stream inStream);
    public CmsTypedStream(string oid, Stream inStream);
    public CmsTypedStream(string oid, Stream inStream, int bufSize);
    public string get_ContentType();
    public Stream get_ContentStream();
    public void Drain();
}
internal class Org.BouncyCastle.Cms.CmsUtilities : object {
    internal static int MaximumMemory { get; }
    internal static int get_MaximumMemory();
    internal static ContentInfo ReadContentInfo(Byte[] input);
    internal static ContentInfo ReadContentInfo(Stream input);
    private static ContentInfo ReadContentInfo(Asn1InputStream aIn);
    public static Byte[] StreamToByteArray(Stream inStream);
    public static IList GetCertificatesFromStore(IX509Store certStore);
    public static IList GetCrlsFromStore(IX509Store crlStore);
    public static Asn1Set CreateBerSetFromList(IList berObjects);
    public static Asn1Set CreateDerSetFromList(IList derObjects);
}
internal class Org.BouncyCastle.Cms.CounterSignatureDigestCalculator : object {
    private string alg;
    private Byte[] data;
    internal CounterSignatureDigestCalculator(string alg, Byte[] data);
    public sealed virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator : object {
    private Hashtable table;
    public DefaultSignedAttributeTableGenerator(AttributeTable attributeTable);
    protected virtual Hashtable createStandardAttributeTable(IDictionary parameters);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
internal interface Org.BouncyCastle.Cms.IDigestCalculator {
    public abstract virtual Byte[] GetDigest();
}
public class Org.BouncyCastle.Cms.KekRecipientInformation : RecipientInformation {
    private KekRecipientInfo _info;
    public KekRecipientInformation(KekRecipientInfo info, AlgorithmIdentifier encAlg, Stream data);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.KeyAgreeRecipientInformation : RecipientInformation {
    private KeyAgreeRecipientInfo _info;
    private Asn1OctetString _encryptedKey;
    public KeyAgreeRecipientInformation(KeyAgreeRecipientInfo info, AlgorithmIdentifier encAlg, Stream data);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.KeyTransRecipientInformation : RecipientInformation {
    private KeyTransRecipientInfo _info;
    public KeyTransRecipientInformation(KeyTransRecipientInfo info, AlgorithmIdentifier encAlg, Stream data);
    private string GetExchangeEncryptionAlgorithmName(DerObjectIdentifier oid);
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.PasswordRecipientInformation : RecipientInformation {
    private PasswordRecipientInfo _info;
    public AlgorithmIdentifier KeyDerivationAlgorithm { get; }
    public PasswordRecipientInformation(PasswordRecipientInfo info, AlgorithmIdentifier encAlg, Stream data);
    public virtual AlgorithmIdentifier get_KeyDerivationAlgorithm();
    public virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey : CmsPbeKey {
    public Pkcs5Scheme2PbeKey(string password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey : CmsPbeKey {
    public Pkcs5Scheme2Utf8PbeKey(string password, Byte[] salt, int iterationCount);
    public Pkcs5Scheme2Utf8PbeKey(string password, AlgorithmIdentifier keyDerivationAlgorithm);
    internal virtual KeyParameter GetEncoded(string algorithmOid);
}
public class Org.BouncyCastle.Cms.RecipientID : X509CertStoreSelector {
    private Byte[] keyIdentifier;
    public Byte[] KeyIdentifier { get; public set; }
    public Byte[] get_KeyIdentifier();
    public void set_KeyIdentifier(Byte[] value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Org.BouncyCastle.Cms.RecipientInformation : object {
    internal RecipientID _rid;
    internal AlgorithmIdentifier _encAlg;
    internal AlgorithmIdentifier _keyEncAlg;
    internal Stream _data;
    public RecipientID RecipientID { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithmID { get; }
    public string KeyEncryptionAlgOid { get; }
    public Asn1Object KeyEncryptionAlgParams { get; }
    internal RecipientInformation(AlgorithmIdentifier encAlg, AlgorithmIdentifier keyEncAlg, Stream data);
    public RecipientID get_RecipientID();
    public AlgorithmIdentifier get_KeyEncryptionAlgorithmID();
    public string get_KeyEncryptionAlgOid();
    public Asn1Object get_KeyEncryptionAlgParams();
    internal CmsTypedStream GetContentFromSessionKey(KeyParameter sKey);
    public Byte[] GetContent(ICipherParameters key);
    public abstract virtual CmsTypedStream GetContentStream(ICipherParameters key);
}
public class Org.BouncyCastle.Cms.RecipientInformationStore : object {
    private ArrayList all;
    private Hashtable table;
    public int Count { get; }
    public RecipientInformationStore(ICollection recipientInfos);
    public RecipientInformation GetFirstRecipient(RecipientID selector);
    public int get_Count();
    public ICollection GetRecipients();
    public ICollection GetRecipients(RecipientID selector);
}
public class Org.BouncyCastle.Cms.SignerID : X509CertStoreSelector {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Org.BouncyCastle.Cms.SignerInformation : object {
    private static CmsSignedHelper Helper;
    private SignerID sid;
    private SignerInfo info;
    private AlgorithmIdentifier digestAlgorithm;
    private AlgorithmIdentifier encryptionAlgorithm;
    private Asn1Set signedAttributes;
    private Asn1Set unsignedAttributes;
    private CmsProcessable content;
    private Byte[] signature;
    private DerObjectIdentifier contentType;
    private IDigestCalculator digestCalculator;
    private Byte[] resultDigest;
    public SignerID SignerID { get; }
    public int Version { get; }
    public AlgorithmIdentifier DigestAlgorithmID { get; }
    public string DigestAlgOid { get; }
    public Asn1Object DigestAlgParams { get; }
    public AlgorithmIdentifier EncryptionAlgorithmID { get; }
    public string EncryptionAlgOid { get; }
    public Asn1Object EncryptionAlgParams { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    internal SignerInformation(SignerInfo info, DerObjectIdentifier contentType, CmsProcessable content, IDigestCalculator digestCalculator);
    private static SignerInformation();
    public SignerID get_SignerID();
    public int get_Version();
    public AlgorithmIdentifier get_DigestAlgorithmID();
    public string get_DigestAlgOid();
    public Asn1Object get_DigestAlgParams();
    public Byte[] GetContentDigest();
    public AlgorithmIdentifier get_EncryptionAlgorithmID();
    public string get_EncryptionAlgOid();
    public Asn1Object get_EncryptionAlgParams();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public Byte[] GetSignature();
    public SignerInformationStore GetCounterSignatures();
    public Byte[] GetEncodedSignedAttributes();
    private bool DoVerify(AsymmetricKeyParameter key, AttributeTable signedAttrTable);
    private bool IsNull(Asn1Encodable o);
    private DigestInfo DerDecode(Byte[] encoding);
    private bool VerifyDigest(Byte[] digest, AsymmetricKeyParameter key, Byte[] signature);
    public bool Verify(AsymmetricKeyParameter pubKey);
    public bool Verify(X509Certificate cert);
    public SignerInfo ToSignerInfo();
    public static SignerInformation ReplaceUnsignedAttributes(SignerInformation signerInformation, AttributeTable unsignedAttributes);
    public static SignerInformation AddCounterSigners(SignerInformation signerInformation, SignerInformationStore counterSigners);
}
public class Org.BouncyCastle.Cms.SignerInformationStore : object {
    private ArrayList all;
    private Hashtable table;
    public int Count { get; }
    public SignerInformationStore(ICollection signerInfos);
    public SignerInformation GetFirstSigner(SignerID selector);
    public int get_Count();
    public ICollection GetSigners();
    public ICollection GetSigners(SignerID selector);
}
public class Org.BouncyCastle.Cms.SimpleAttributeTableGenerator : object {
    private AttributeTable attributes;
    public SimpleAttributeTableGenerator(AttributeTable attributes);
    public virtual AttributeTable GetAttributes(IDictionary parameters);
}
public class Org.BouncyCastle.Crypto.Agreement.DHAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    private BigInteger privateValue;
    private SecureRandom random;
    public void Init(ICipherParameters parameters);
    public BigInteger CalculateMessage();
    public BigInteger CalculateAgreement(DHPublicKeyParameters pub, BigInteger message);
}
public class Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement : object {
    private DHPrivateKeyParameters key;
    private DHParameters dhParams;
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement : object {
    private ECPrivateKeyParameters key;
    public sealed virtual void Init(ICipherParameters parameters);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement : object {
    private ECPrivateKeyParameters key;
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.ECDHWithKdfBasicAgreement : ECDHBasicAgreement {
    private static Hashtable algorithms;
    private string algorithm;
    private IDerivationFunction kdf;
    private static ECDHWithKdfBasicAgreement();
    public ECDHWithKdfBasicAgreement(string algorithm, IDerivationFunction kdf);
    public virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKdfParameters : object {
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] extraInfo;
    public DerObjectIdentifier Algorithm { get; }
    public int KeySize { get; }
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z);
    public DHKdfParameters(DerObjectIdentifier algorithm, int keySize, Byte[] z, Byte[] extraInfo);
    public DerObjectIdentifier get_Algorithm();
    public int get_KeySize();
    public Byte[] GetZ();
    public Byte[] GetExtraInfo();
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator : object {
    private IDigest digest;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    private Byte[] partyAInfo;
    public IDigest Digest { get; }
    public DHKekGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
    private Byte[] integerToBytes(int keySize);
}
public class Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator : object {
    private IDerivationFunction kdf;
    private DerObjectIdentifier algorithm;
    private int keySize;
    private Byte[] z;
    public IDigest Digest { get; }
    public ECDHKekGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters param);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] outBytes, int outOff, int len);
    private Byte[] integerToBytes(int keySize);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger privA;
    protected BigInteger pubA;
    protected BigInteger B;
    protected BigInteger x;
    protected BigInteger u;
    protected BigInteger S;
    protected IDigest digest;
    protected SecureRandom random;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateClientCredentials(Byte[] salt, Byte[] identity, Byte[] password);
    public virtual BigInteger CalculateSecret(BigInteger serverB);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server : object {
    protected BigInteger N;
    protected BigInteger g;
    protected BigInteger v;
    protected SecureRandom random;
    protected IDigest digest;
    protected BigInteger A;
    protected BigInteger privB;
    protected BigInteger pubB;
    protected BigInteger u;
    protected BigInteger S;
    public virtual void Init(BigInteger N, BigInteger g, BigInteger v, IDigest digest, SecureRandom random);
    public virtual BigInteger GenerateServerCredentials();
    public virtual BigInteger CalculateSecret(BigInteger clientA);
    protected virtual BigInteger SelectPrivateValue();
    private BigInteger CalculateS();
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities : object {
    public static BigInteger CalculateK(IDigest digest, BigInteger N, BigInteger g);
    public static BigInteger CalculateU(IDigest digest, BigInteger N, BigInteger A, BigInteger B);
    public static BigInteger CalculateX(IDigest digest, BigInteger N, Byte[] salt, Byte[] identity, Byte[] password);
    public static BigInteger GeneratePrivateValue(IDigest digest, BigInteger N, BigInteger g, SecureRandom random);
    public static BigInteger ValidatePublicValue(BigInteger N, BigInteger val);
    private static BigInteger HashPaddedPair(IDigest digest, BigInteger N, BigInteger n1, BigInteger n2);
    private static Byte[] GetPadded(BigInteger n, int length);
}
public class Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator : object {
    protected BigInteger N;
    protected BigInteger g;
    protected IDigest digest;
    public virtual void Init(BigInteger N, BigInteger g, IDigest digest);
    public virtual BigInteger GenerateVerifier(Byte[] salt, Byte[] identity, Byte[] password);
}
public class Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair : object {
    private AsymmetricKeyParameter publicParameter;
    private AsymmetricKeyParameter privateParameter;
    public AsymmetricKeyParameter Public { get; }
    public AsymmetricKeyParameter Private { get; }
    public AsymmetricCipherKeyPair(AsymmetricKeyParameter publicParameter, AsymmetricKeyParameter privateParameter);
    public AsymmetricKeyParameter get_Public();
    public AsymmetricKeyParameter get_Private();
}
public class Org.BouncyCastle.Crypto.AsymmetricKeyParameter : object {
    private bool privateKey;
    public bool IsPrivate { get; }
    public AsymmetricKeyParameter(bool privateKey);
    public bool get_IsPrivate();
    public virtual bool Equals(object obj);
    protected bool Equals(AsymmetricKeyParameter other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.BufferedAeadBlockCipher : BufferedCipherBase {
    private IAeadBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedAeadBlockCipher(IAeadBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher : BufferedCipherBase {
    private IAsymmetricBlockCipher cipher;
    private Byte[] buffer;
    private int bufOff;
    public string AlgorithmName { get; }
    public BufferedAsymmetricBlockCipher(IAsymmetricBlockCipher cipher);
    internal int GetBufferPosition();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedBlockCipher : BufferedCipherBase {
    internal Byte[] buf;
    internal int bufOff;
    internal bool forEncryption;
    internal IBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public abstract class Org.BouncyCastle.Crypto.BufferedCipherBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    private static BufferedCipherBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedIesCipher : BufferedCipherBase {
    private IesEngine engine;
    private bool forEncryption;
    private MemoryStream buffer;
    public string AlgorithmName { get; }
    public BufferedIesCipher(IesEngine engine);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.BufferedStreamCipher : BufferedCipherBase {
    private IStreamCipher cipher;
    public string AlgorithmName { get; }
    public BufferedStreamCipher(IStreamCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetOutputSize(int inputLen);
    public virtual int GetUpdateOutputSize(int inputLen);
    public virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.CipherKeyGenerator : object {
    protected internal SecureRandom random;
    protected internal int strength;
    private bool uninitialised;
    private int defaultStrength;
    public int DefaultStrength { get; }
    internal CipherKeyGenerator(int defaultStrength);
    public int get_DefaultStrength();
    public void Init(KeyGenerationParameters parameters);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    public Byte[] GenerateKey();
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception exception);
}
public abstract class Org.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.Gost3411Digest : object {
    private static int DIGEST_LENGTH;
    private Byte[] H;
    private Byte[] L;
    private Byte[] M;
    private Byte[] Sum;
    private Byte[][] C;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    private IBlockCipher cipher;
    private Byte[] K;
    private Byte[] a;
    internal Int16[] wS;
    internal Int16[] w_S;
    internal Byte[] S;
    internal Byte[] U;
    internal Byte[] V;
    internal Byte[] W;
    private static Byte[] C2;
    public string AlgorithmName { get; }
    public Gost3411Digest(Gost3411Digest t);
    private static Gost3411Digest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private Byte[] P(Byte[] input);
    private Byte[] A(Byte[] input);
    private void E(Byte[] key, Byte[] s, int sOff, Byte[] input, int inOff);
    private void fw(Byte[] input);
    private void processBlock(Byte[] input, int inOff);
    private void finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void sumByteArray(Byte[] input);
    private static void LongToBytes(long r, Byte[] output, int outOff);
    private static void cpyBytesToShort(Byte[] S, Int16[] wS);
    private static void cpyShortToBytes(Int16[] wS, Byte[] S);
    public sealed virtual int GetByteLength();
}
public abstract class Org.BouncyCastle.Crypto.Digests.LongDigest : object {
    private int MyByteLength;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount1;
    private long byteCount2;
    internal long H1;
    internal long H2;
    internal long H3;
    internal long H4;
    internal long H5;
    internal long H6;
    internal long H7;
    internal long H8;
    private Int64[] W;
    private int wOff;
    internal static Int64[] K;
    public string AlgorithmName { get; }
    internal LongDigest(LongDigest t);
    private static LongDigest();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    internal static void UnpackWord(long word, Byte[] outBytes, int outOff);
    private void AdjustByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static long Ch(long x, long y, long z);
    private static long Maj(long x, long y, long z);
    private static long Sum0(long x);
    private static long Sum1(long x);
    private static long Sigma0(long x);
    private static long Sigma1(long x);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Digests.MD2Digest : object {
    private static int DigestLength;
    private static int BYTE_LENGTH;
    private Byte[] X;
    private int xOff;
    private Byte[] M;
    private int mOff;
    private Byte[] C;
    private int COff;
    private static Byte[] S;
    public string AlgorithmName { get; }
    public MD2Digest(MD2Digest t);
    private static MD2Digest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    internal void ProcessChecksum(Byte[] m);
    internal void ProcessBlock(Byte[] m);
}
public class Org.BouncyCastle.Crypto.Digests.MD4Digest : GeneralDigest {
    private static int DigestLength;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public MD4Digest(MD4Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RotateLeft(int x, int n);
    private int F(int u, int v, int w);
    private int G(int u, int v, int w);
    private int H(int u, int v, int w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.MD5Digest : GeneralDigest {
    private static int DigestLength;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private static int S41;
    private static int S42;
    private static int S43;
    private static int S44;
    public string AlgorithmName { get; }
    public MD5Digest(MD5Digest t);
    private static MD5Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RotateLeft(int x, int n);
    private int F(int u, int v, int w);
    private int G(int u, int v, int w);
    private int H(int u, int v, int w);
    private int K(int u, int v, int w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD128Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD128Digest(RipeMD128Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD256Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD256Digest(RipeMD256Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F1(int a, int b, int c, int d, int x, int s);
    private int F2(int a, int b, int c, int d, int x, int s);
    private int F3(int a, int b, int c, int d, int x, int s);
    private int F4(int a, int b, int c, int d, int x, int s);
    private int FF1(int a, int b, int c, int d, int x, int s);
    private int FF2(int a, int b, int c, int d, int x, int s);
    private int FF3(int a, int b, int c, int d, int x, int s);
    private int FF4(int a, int b, int c, int d, int x, int s);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.RipeMD320Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private int H8;
    private int H9;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD320Digest(RipeMD320Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.Sha1Digest : GeneralDigest {
    private static int DigestLength;
    private static int Y1;
    private static int Y2;
    private static int Y3;
    private static int Y4;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public Sha1Digest(Sha1Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    private static void UnpackWord(int word, Byte[] outBytes, int outOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static int F(int u, int v, int w);
    private static int H(int u, int v, int w);
    private static int G(int u, int v, int w);
    internal virtual void ProcessBlock();
}
public class Org.BouncyCastle.Crypto.Digests.Sha224Digest : GeneralDigest {
    private static int DigestLength;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private int H5;
    private int H6;
    private int H7;
    private int H8;
    private Int32[] X;
    private int xOff;
    internal static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha224Digest(Sha224Digest t);
    private static Sha224Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static int Ch(int x, int y, int z);
    private static int Maj(int x, int y, int z);
    private static int Sum0(int x);
    private static int Sum1(int x);
    private static int Theta0(int x);
    private static int Theta1(int x);
}
public class Org.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    private void UnpackWord(UInt32 word, Byte[] outBytes, int outOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
}
public class Org.BouncyCastle.Crypto.Digests.Sha384Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha384Digest(Sha384Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.Sha512Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha512Digest(Sha512Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.ShortenedDigest : object {
    private IDigest baseDigest;
    private int length;
    public string AlgorithmName { get; }
    public ShortenedDigest(IDigest baseDigest, int length);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Digests.TigerDigest : object {
    private static int MyByteLength;
    private static int DigestLength;
    private static Int64[] t1;
    private static Int64[] t2;
    private static Int64[] t3;
    private static Int64[] t4;
    private long a;
    private long b;
    private long c;
    private long byteCount;
    private Byte[] Buffer;
    private int bOff;
    private Int64[] x;
    private int xOff;
    public string AlgorithmName { get; }
    public TigerDigest(TigerDigest t);
    private static TigerDigest();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int GetByteLength();
    private void ProcessWord(Byte[] b, int off);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void RoundABC(long x, long mul);
    private void RoundBCA(long x, long mul);
    private void RoundCAB(long x, long mul);
    private void KeySchedule();
    private void ProcessBlock();
    private void UnpackWord(long r, Byte[] output, int outOff);
    private void ProcessLength(long bitLength);
    private void Finish();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest : object {
    private static int BYTE_LENGTH;
    private static int DIGEST_LENGTH_BYTES;
    private static int ROUNDS;
    private static int REDUCTION_POLYNOMIAL;
    private static int BITCOUNT_ARRAY_SIZE;
    private static Int32[] SBOX;
    private static Int64[] C0;
    private static Int64[] C1;
    private static Int64[] C2;
    private static Int64[] C3;
    private static Int64[] C4;
    private static Int64[] C5;
    private static Int64[] C6;
    private static Int64[] C7;
    private Int64[] _rc;
    private static Int16[] EIGHT;
    private Byte[] _buffer;
    private int _bufferPos;
    private Int16[] _bitCount;
    private Int64[] _hash;
    private Int64[] _K;
    private Int64[] _L;
    private Int64[] _block;
    private Int64[] _state;
    public string AlgorithmName { get; }
    private static WhirlpoolDigest();
    public WhirlpoolDigest(WhirlpoolDigest originalDigest);
    private static long packIntoLong(int b7, int b6, int b5, int b4, int b3, int b2, int b1, int b0);
    private static int maskWithReductionPolynomial(int input);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetDigestSize();
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void processFilledBuffer();
    private static long bytesToLongFromBuffer(Byte[] buffer, int startPos);
    private static void convertLongToByteArray(long inputLong, Byte[] outputArray, int offSet);
    private void processBlock();
    public sealed virtual void Update(byte input);
    private void increment();
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    private void finish();
    private Byte[] copyBitLength();
    public sealed virtual int GetByteLength();
}
public class Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding : object {
    private static Byte[] shadows;
    private static Byte[] inverse;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private int bitSize;
    private int padBits;
    public string AlgorithmName { get; }
    public ISO9796d1Encoding(IAsymmetricBlockCipher cipher);
    private static ISO9796d1Encoding();
    public sealed virtual string get_AlgorithmName();
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public void SetPadBits(int padBits);
    public int GetPadBits();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Encodings.OaepEncoding : object {
    private Byte[] defHash;
    private IDigest hash;
    private IDigest mgf1Hash;
    private IAsymmetricBlockCipher engine;
    private SecureRandom random;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public OaepEncoding(IAsymmetricBlockCipher cipher);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, Byte[] encodingParams);
    public OaepEncoding(IAsymmetricBlockCipher cipher, IDigest hash, IDigest mgf1Hash, Byte[] encodingParams);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] encodeBlock(Byte[] inBytes, int inOff, int inLen);
    private Byte[] decodeBlock(Byte[] inBytes, int inOff, int inLen);
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] maskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding : object {
    public static string StrictLengthEnabledProperty;
    private static int HeaderLength;
    private static Boolean[] strictLengthEnabled;
    private SecureRandom random;
    private IAsymmetricBlockCipher engine;
    private bool forEncryption;
    private bool forPrivateKey;
    private bool useStrictLength;
    public static bool StrictLengthEnabled { get; public set; }
    public string AlgorithmName { get; }
    private static Pkcs1Encoding();
    public Pkcs1Encoding(IAsymmetricBlockCipher cipher);
    public static bool get_StrictLengthEnabled();
    public static void set_StrictLengthEnabled(bool value);
    public IAsymmetricBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.AesEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] Tinv0;
    private int ROUNDS;
    private UInt32[0...,0...] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesEngine();
    private UInt32 Shift(UInt32 r, int shift);
    private UInt32 FFmulX(UInt32 x);
    private UInt32 Inv_Mcol(UInt32 x);
    private UInt32 SubWord(UInt32 x);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(UInt32[0...,0...] KW);
    private void DecryptBlock(UInt32[0...,0...] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesFastEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] T1;
    private static UInt32[] T2;
    private static UInt32[] T3;
    private static UInt32[] Tinv0;
    private static UInt32[] Tinv1;
    private static UInt32[] Tinv2;
    private static UInt32[] Tinv3;
    private int ROUNDS;
    private UInt32[0...,0...] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesFastEngine();
    private UInt32 Shift(UInt32 r, int shift);
    private UInt32 FFmulX(UInt32 x);
    private UInt32 Inv_Mcol(UInt32 x);
    private UInt32 SubWord(UInt32 x);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(UInt32[0...,0...] KW);
    private void DecryptBlock(UInt32[0...,0...] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesLightEngine : object {
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static int BLOCK_SIZE;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private int ROUNDS;
    private UInt32[0...,0...] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesLightEngine();
    private UInt32 Shift(UInt32 r, int shift);
    private UInt32 FFmulX(UInt32 x);
    private UInt32 Mcol(UInt32 x);
    private UInt32 Inv_Mcol(UInt32 x);
    private UInt32 SubWord(UInt32 x);
    private UInt32[0...,0...] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(UInt32[0...,0...] KW);
    private void DecryptBlock(UInt32[0...,0...] KW);
}
public class Org.BouncyCastle.Crypto.Engines.AesWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.BlowfishEngine : object {
    private static int BLOCK_SIZE;
    private static UInt32[] KP;
    private static UInt32[] KS0;
    private static UInt32[] KS1;
    private static UInt32[] KS2;
    private static UInt32[] KS3;
    private static int ROUNDS;
    private static int SBOX_SK;
    private static int P_SZ;
    private UInt32[] S0;
    private UInt32[] S1;
    private UInt32[] S2;
    private UInt32[] S3;
    private UInt32[] P;
    private bool encrypting;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static BlowfishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private UInt32 F(UInt32 x);
    private void ProcessTable(UInt32 xl, UInt32 xr, UInt32[] table);
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyIs128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static UInt32[] SBOX1_1110;
    private static UInt32[] SBOX4_4404;
    private static UInt32[] SBOX2_0222;
    private static UInt32[] SBOX3_3033;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private static void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private static void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine : object {
    private static int BLOCK_SIZE;
    private bool initialised;
    private bool _keyis128;
    private UInt32[] subkey;
    private UInt32[] kw;
    private UInt32[] ke;
    private UInt32[] state;
    private static UInt32[] SIGMA;
    private static Byte[] SBOX1;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static CamelliaLightEngine();
    private static UInt32 rightRotate(UInt32 x, int s);
    private static UInt32 leftRotate(UInt32 x, int s);
    private static void roldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldq(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void roldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static void decroldqo32(int rot, UInt32[] ki, int ioff, UInt32[] ko, int ooff);
    private static UInt32 bytes2uint(Byte[] src, int offset);
    private static void uint2bytes(UInt32 word, Byte[] dst, int offset);
    private byte lRot8(byte v, int rot);
    private UInt32 sbox2(int x);
    private UInt32 sbox3(int x);
    private UInt32 sbox4(int x);
    private void camelliaF2(UInt32[] s, UInt32[] skey, int keyoff);
    private void camelliaFLs(UInt32[] s, UInt32[] fkey, int keyoff);
    private void setKey(bool forEncryption, Byte[] key);
    private int processBlock128(Byte[] input, int inOff, Byte[] output, int outOff);
    private int processBlock192or256(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.Cast5Engine : object {
    private static int BLOCK_SIZE;
    internal static UInt32[] S1;
    internal static UInt32[] S2;
    internal static UInt32[] S3;
    internal static UInt32[] S4;
    internal static UInt32[] S5;
    internal static UInt32[] S6;
    internal static UInt32[] S7;
    internal static UInt32[] S8;
    internal static int MAX_ROUNDS;
    internal static int RED_ROUNDS;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private bool _encrypting;
    private Byte[] _workingKey;
    private int _rounds;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Cast5Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal static UInt32 F1(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F2(UInt32 D, UInt32 Kmi, int Kri);
    internal static UInt32 F3(UInt32 D, UInt32 Kmi, int Kri);
    internal void CAST_Encipher(UInt32 L0, UInt32 R0, UInt32[] result);
    internal void CAST_Decipher(UInt32 L16, UInt32 R16, UInt32[] result);
    internal static void Bits32ToInts(UInt32 inData, Int32[] b, int offset);
    internal static UInt32 IntsTo32bits(Int32[] b, int i);
}
public class Org.BouncyCastle.Crypto.Engines.Cast6Engine : Cast5Engine {
    private static int ROUNDS;
    private static int BLOCK_SIZE;
    private Int32[] _Kr;
    private UInt32[] _Km;
    private Int32[] _Tr;
    private UInt32[] _Tm;
    private UInt32[] _workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Reset();
    public virtual int GetBlockSize();
    internal virtual void SetKey(Byte[] key);
    internal virtual int EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    internal virtual int DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void CAST_Encipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
    private void CAST_Decipher(UInt32 A, UInt32 B, UInt32 C, UInt32 D, UInt32[] result);
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeEngine : DesEngine {
    private Int32[] workingKey1;
    private Int32[] workingKey2;
    private Int32[] workingKey3;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine : object {
    private CbcBlockCipher engine;
    private KeyParameter param;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static DesEdeWrapEngine();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
}
public class Org.BouncyCastle.Crypto.Engines.DesEngine : object {
    internal static int BLOCK_SIZE;
    private Int32[] workingKey;
    private static Int16[] bytebit;
    private static Int32[] bigbyte;
    private static Byte[] pc1;
    private static Byte[] totrot;
    private static Byte[] pc2;
    private static UInt32[] SP1;
    private static UInt32[] SP2;
    private static UInt32[] SP3;
    private static UInt32[] SP4;
    private static UInt32[] SP5;
    private static UInt32[] SP6;
    private static UInt32[] SP7;
    private static UInt32[] SP8;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static DesEngine();
    public virtual Int32[] GetWorkingKey();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    protected static Int32[] GenerateWorkingKey(bool encrypting, Byte[] key);
    internal static void DesFunc(Int32[] wKey, Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.ElGamalEngine : object {
    private ElGamalKeyParameters key;
    private SecureRandom random;
    private bool forEncryption;
    private int bitSize;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.Engines.Gost28147Engine : object {
    private static int BlockSize;
    private Int32[] workingKey;
    private bool forEncryption;
    private Byte[] S;
    private static Byte[] ESbox_Test;
    private static Byte[] ESbox_A;
    private static Byte[] ESbox_B;
    private static Byte[] ESbox_C;
    private static Byte[] ESbox_D;
    private static Byte[] DSbox_Test;
    private static Byte[] DSbox_A;
    private static Hashtable sBoxes;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static Gost28147Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private Int32[] generateWorkingKey(bool forEncryption, Byte[] userKey);
    private int Gost28147_mainStep(int n1, int key);
    private void Gost28147Func(Int32[] workingKey, Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private static int bytesToint(Byte[] inBytes, int inOff);
    private static void intTobytes(int num, Byte[] outBytes, int outOff);
    public static Byte[] GetSBox(string sBoxName);
}
public class Org.BouncyCastle.Crypto.Engines.HC128Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private static UInt32 F1(UInt32 x);
    private static UInt32 F2(UInt32 x);
    private UInt32 G1(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G2(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 RotateLeft(UInt32 x, int bits);
    private static UInt32 RotateRight(UInt32 x, int bits);
    private UInt32 H1(UInt32 x);
    private UInt32 H2(UInt32 x);
    private static UInt32 Mod1024(UInt32 x);
    private static UInt32 Mod512(UInt32 x);
    private static UInt32 Dim(UInt32 x, UInt32 y);
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.HC256Engine : object {
    private UInt32[] p;
    private UInt32[] q;
    private UInt32 cnt;
    private Byte[] key;
    private Byte[] iv;
    private bool initialised;
    private Byte[] buf;
    private int idx;
    public string AlgorithmName { get; }
    private UInt32 Step();
    private void Init();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte GetByte();
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual byte ReturnByte(byte input);
    private static UInt32 RotateRight(UInt32 x, int bits);
}
public class Org.BouncyCastle.Crypto.Engines.IesEngine : object {
    private IBasicAgreement agree;
    private IDerivationFunction kdf;
    private IMac mac;
    private BufferedBlockCipher cipher;
    private Byte[] macBuf;
    private bool forEncryption;
    private ICipherParameters privParam;
    private ICipherParameters pubParam;
    private IesParameters param;
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac);
    public IesEngine(IBasicAgreement agree, IDerivationFunction kdf, IMac mac, BufferedBlockCipher cipher);
    public void Init(bool forEncryption, ICipherParameters privParameters, ICipherParameters pubParameters, ICipherParameters iesParameters);
    private Byte[] DecryptBlock(Byte[] in_enc, int inOff, int inLen, Byte[] z);
    private Byte[] EncryptBlock(Byte[] input, int inOff, int inLen, Byte[] z);
    private Byte[] GenerateKdfBytes(KdfParameters kParam, int length);
    public Byte[] ProcessBlock(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.IsaacEngine : object {
    private static int sizeL;
    private static int stateArraySize;
    private UInt32[] engineState;
    private UInt32[] results;
    private UInt32 a;
    private UInt32 b;
    private UInt32 c;
    private int index;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private bool initialised;
    public string AlgorithmName { get; }
    private static IsaacEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Reset();
    private void setKey(Byte[] keyBytes);
    private void isaac();
    private void mix(UInt32[] x);
    private UInt32 byteToIntLittle(Byte[] x, int offset);
    private Byte[] intToByteLittle(UInt32 x);
    private Byte[] intToByteLittle(UInt32[] x);
}
public class Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine : object {
    private bool forEncryption;
    private NaccacheSternKeyParameters key;
    private ArrayList[] lookup;
    private bool debug;
    public string AlgorithmName { get; }
    unknown bool Debug {public set; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public void set_Debug(bool value);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBytes, int inOff, int length);
    public Byte[] Encrypt(BigInteger plain);
    public Byte[] AddCryptedBlocks(Byte[] block1, Byte[] block2);
    public Byte[] ProcessData(Byte[] data);
    private static BigInteger chineseRemainder(ArrayList congruences, ArrayList primes);
}
public class Org.BouncyCastle.Crypto.Engines.NoekeonEngine : object {
    private static int GenericSize;
    private static UInt32[] nullVector;
    private static UInt32[] roundConstants;
    private UInt32[] state;
    private UInt32[] subKeys;
    private UInt32[] decryptKeys;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static NoekeonEngine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int decryptBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void gamma(UInt32[] a);
    private void theta(UInt32[] a, UInt32[] k);
    private void pi1(UInt32[] a);
    private void pi2(UInt32[] a);
    private UInt32 rotl(UInt32 x, int y);
}
public class Org.BouncyCastle.Crypto.Engines.NullEngine : object {
    private static int BlockSize;
    private bool initialised;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Engines.RC2Engine : object {
    private static int BLOCK_SIZE;
    private static Byte[] piTable;
    private Int32[] workingKey;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC2Engine();
    private Int32[] GenerateWorkingKey(Byte[] key, int bits);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual void Reset();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int RotateWordLeft(int x, int y);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC2WrapEngine : object {
    private CbcBlockCipher engine;
    private ICipherParameters parameters;
    private ParametersWithIV paramPlusIV;
    private Byte[] iv;
    private bool forWrapping;
    private SecureRandom sr;
    private static Byte[] IV2;
    private IDigest sha1;
    private Byte[] digest;
    public string AlgorithmName { get; }
    private static RC2WrapEngine();
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
    private Byte[] CalculateCmsKeyChecksum(Byte[] key);
    private bool CheckCmsKeyChecksum(Byte[] key, Byte[] checksum);
}
public class Org.BouncyCastle.Crypto.Engines.RC4Engine : object {
    private static int STATE_LENGTH;
    private Byte[] engineState;
    private int x;
    private int y;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    private static RC4Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] keyBytes);
}
public class Org.BouncyCastle.Crypto.Engines.RC532Engine : object {
    private int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC532Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC564Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private int _noRounds;
    private Int64[] _S;
    private static long P64;
    private static long Q64;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC564Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private long RotateLeft(long x, long y);
    private long RotateRight(long x, long y);
    private long BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(long word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.RC6Engine : object {
    private static int wordSize;
    private static int bytesPerWord;
    private static int _noRounds;
    private Int32[] _S;
    private static int P32;
    private static int Q32;
    private static int LGW;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static RC6Engine();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void SetKey(Byte[] key);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int RotateLeft(int x, int y);
    private int RotateRight(int x, int y);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine : object {
    private CbcBlockCipher engine;
    private ParametersWithIV param;
    private bool forWrapping;
    private SecureRandom rand;
    public string AlgorithmName { get; }
    public Rfc3211WrapEngine(IBlockCipher engine);
    public sealed virtual void Init(bool forWrapping, ICipherParameters param);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] inBytes, int inOff, int inLen);
    public sealed virtual Byte[] Unwrap(Byte[] inBytes, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine : object {
    private IBlockCipher engine;
    private KeyParameter param;
    private bool forWrapping;
    private Byte[] iv;
    public string AlgorithmName { get; }
    public Rfc3394WrapEngine(IBlockCipher engine);
    public sealed virtual void Init(bool forWrapping, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] Wrap(Byte[] input, int inOff, int inLen);
    public sealed virtual Byte[] Unwrap(Byte[] input, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RijndaelEngine : object {
    private static int MAXROUNDS;
    private static int MAXKC;
    private static Byte[] Logtable;
    private static Byte[] Alogtable;
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static Byte[][] shifts0;
    private static Byte[][] shifts1;
    private int BC;
    private long BC_MASK;
    private int ROUNDS;
    private int blockBits;
    private Int64[][] workingKey;
    private long A0;
    private long A1;
    private long A2;
    private long A3;
    private bool forEncryption;
    private Byte[] shifts0SC;
    private Byte[] shifts1SC;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public RijndaelEngine(int blockBits);
    private static RijndaelEngine();
    private byte Mul0x2(int b);
    private byte Mul0x3(int b);
    private byte Mul0x9(int b);
    private byte Mul0xb(int b);
    private byte Mul0xd(int b);
    private byte Mul0xe(int b);
    private void KeyAddition(Int64[] rk);
    private long Shift(long r, int shift);
    private void ShiftRow(Byte[] shiftsSC);
    private long ApplyS(long r, Byte[] box);
    private void Substitution(Byte[] box);
    private void MixColumn();
    private void InvMixColumn();
    private Int64[][] GenerateWorkingKey(Byte[] key);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(Int64[][] rk);
    private void DecryptBlock(Int64[][] rk);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine : object {
    private RsaCoreEngine core;
    private RsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine : object {
    private RsaCoreEngine core;
    private RsaKeyParameters key;
    private BigInteger blindingFactor;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters param);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
    private BigInteger BlindMessage(BigInteger msg);
    private BigInteger UnblindMessage(BigInteger blindedMsg);
}
internal class Org.BouncyCastle.Crypto.Engines.RsaCoreEngine : object {
    private RsaKeyParameters key;
    private bool forEncryption;
    private int bitSize;
    public void Init(bool forEncryption, ICipherParameters parameters);
    public int GetInputBlockSize();
    public int GetOutputBlockSize();
    public BigInteger ConvertInput(Byte[] inBuf, int inOff, int inLen);
    public Byte[] ConvertOutput(BigInteger result);
    public BigInteger ProcessBlock(BigInteger input);
}
public class Org.BouncyCastle.Crypto.Engines.RsaEngine : object {
    private RsaCoreEngine core;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int GetInputBlockSize();
    public sealed virtual int GetOutputBlockSize();
    public sealed virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public class Org.BouncyCastle.Crypto.Engines.Salsa20Engine : object {
    private static int stateSize;
    private static Byte[] sigma;
    private static Byte[] tau;
    private int index;
    private Int32[] engineState;
    private Int32[] x;
    private Byte[] keyStream;
    private Byte[] workingKey;
    private Byte[] workingIV;
    private bool initialised;
    private int cW0;
    private int cW1;
    private int cW2;
    public string AlgorithmName { get; }
    private static Salsa20Engine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] keyBytes, Byte[] ivBytes);
    private void salsa20WordToByte(Int32[] input, Byte[] output);
    private Byte[] intToByteLittle(int x, Byte[] bs, int off);
    private int rotl(int x, int y);
    private int byteToIntLittle(Byte[] x, int offset);
    private void resetCounter();
    private bool limitExceeded();
    private bool limitExceeded(int len);
}
public class Org.BouncyCastle.Crypto.Engines.SeedEngine : object {
    private static int BlockSize;
    private static UInt32[] SS0;
    private static UInt32[] SS1;
    private static UInt32[] SS2;
    private static UInt32[] SS3;
    private static UInt32[] KC;
    private Int32[] wKey;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SeedEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public sealed virtual void Reset();
    private Int32[] createWorkingKey(Byte[] inKey);
    private int extractW1(long lVal);
    private int extractW0(long lVal);
    private long rotateLeft8(long x);
    private long rotateRight8(long x);
    private long bytesToLong(Byte[] src, int srcOff);
    private void longToBytes(Byte[] dest, int destOff, long value);
    private int G(int x);
    private long F(int ki0, int ki1, long r);
    private int phaseCalc1(int r0, int ki0, int r1, int ki1);
    private int phaseCalc2(int r0, int ki0, int r1, int ki1);
}
public class Org.BouncyCastle.Crypto.Engines.SeedWrapEngine : Rfc3394WrapEngine {
}
public class Org.BouncyCastle.Crypto.Engines.SerpentEngine : object {
    private static int BLOCK_SIZE;
    private static int ROUNDS;
    private static int PHI;
    private bool encrypting;
    private Int32[] wKey;
    private int X0;
    private int X1;
    private int X2;
    private int X3;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SerpentEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private Int32[] MakeWorkingKey(Byte[] key);
    private int RotateLeft(int x, int bits);
    private int RotateRight(int x, int bits);
    private int BytesToWord(Byte[] src, int srcOff);
    private void WordToBytes(int word, Byte[] dst, int dstOff);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void Sb0(int a, int b, int c, int d);
    private void Ib0(int a, int b, int c, int d);
    private void Sb1(int a, int b, int c, int d);
    private void Ib1(int a, int b, int c, int d);
    private void Sb2(int a, int b, int c, int d);
    private void Ib2(int a, int b, int c, int d);
    private void Sb3(int a, int b, int c, int d);
    private void Ib3(int a, int b, int c, int d);
    private void Sb4(int a, int b, int c, int d);
    private void Ib4(int a, int b, int c, int d);
    private void Sb5(int a, int b, int c, int d);
    private void Ib5(int a, int b, int c, int d);
    private void Sb6(int a, int b, int c, int d);
    private void Ib6(int a, int b, int c, int d);
    private void Sb7(int a, int b, int c, int d);
    private void Ib7(int a, int b, int c, int d);
    private void LT();
    private void InverseLT();
}
public class Org.BouncyCastle.Crypto.Engines.SkipjackEngine : object {
    private static int BLOCK_SIZE;
    private static Int16[] ftable;
    private Int32[] key0;
    private Int32[] key1;
    private Int32[] key2;
    private Int32[] key3;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static SkipjackEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int G(int k, int w);
    public int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int H(int k, int w);
    public int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TeaEngine : object {
    private static int rounds;
    private static int block_size;
    private static UInt32 delta;
    private static UInt32 d_sum;
    private UInt32 _a;
    private UInt32 _b;
    private UInt32 _c;
    private UInt32 _d;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Engines.TwofishEngine : object {
    private static int P_00;
    private static int P_01;
    private static int P_02;
    private static int P_03;
    private static int P_04;
    private static int P_10;
    private static int P_11;
    private static int P_12;
    private static int P_13;
    private static int P_14;
    private static int P_20;
    private static int P_21;
    private static int P_22;
    private static int P_23;
    private static int P_24;
    private static int P_30;
    private static int P_31;
    private static int P_32;
    private static int P_33;
    private static int P_34;
    private static int GF256_FDBK;
    private static int GF256_FDBK_2;
    private static int GF256_FDBK_4;
    private static int RS_GF_FDBK;
    private static int ROUNDS;
    private static int MAX_ROUNDS;
    private static int BLOCK_SIZE;
    private static int MAX_KEY_BITS;
    private static int INPUT_WHITEN;
    private static int OUTPUT_WHITEN;
    private static int ROUND_SUBKEYS;
    private static int TOTAL_SUBKEYS;
    private static int SK_STEP;
    private static int SK_BUMP;
    private static int SK_ROTL;
    private static Byte[0...,0...] P;
    private bool encrypting;
    private Int32[] gMDS0;
    private Int32[] gMDS1;
    private Int32[] gMDS2;
    private Int32[] gMDS3;
    private Int32[] gSubKeys;
    private Int32[] gSBox;
    private int k64Cnt;
    private Byte[] workingKey;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static TwofishEngine();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual int GetBlockSize();
    private void SetKey(Byte[] key);
    private void EncryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private void DecryptBlock(Byte[] src, int srcIndex, Byte[] dst, int dstIndex);
    private int F32(int x, Int32[] k32);
    private int RS_MDS_Encode(int k0, int k1);
    private int RS_rem(int x);
    private int LFSR1(int x);
    private int LFSR2(int x);
    private int Mx_X(int x);
    private int Mx_Y(int x);
    private int M_b0(int x);
    private int M_b1(int x);
    private int M_b2(int x);
    private int M_b3(int x);
    private int Fe32_0(int x);
    private int Fe32_3(int x);
    private int BytesTo32Bits(Byte[] b, int p);
    private void Bits32ToBytes(int inData, Byte[] b, int offset);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcEngine : object {
    protected byte n;
    protected Byte[] P;
    protected byte s;
    protected Byte[] workingIV;
    protected Byte[] workingKey;
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    public virtual void Reset();
    public virtual byte ReturnByte(byte input);
}
public class Org.BouncyCastle.Crypto.Engines.VmpcKsa3Engine : VmpcEngine {
    public string AlgorithmName { get; }
    public virtual string get_AlgorithmName();
    protected virtual void InitKey(Byte[] keyBytes, Byte[] ivBytes);
}
public class Org.BouncyCastle.Crypto.Engines.XteaEngine : object {
    private static int rounds;
    private static int block_size;
    private static int delta;
    private UInt32[] _S;
    private UInt32[] _sum0;
    private UInt32[] _sum1;
    private bool _initialised;
    private bool _forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual int ProcessBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    private void setKey(Byte[] key);
    private int encryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
    private int decryptBlock(Byte[] inBytes, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator : object {
    private int counterStart;
    private IDigest digest;
    private Byte[] shared;
    private Byte[] iv;
    public IDigest Digest { get; }
    protected BaseKdfBytesGenerator(int counterStart, IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator : DesKeyGenerator {
    internal DesEdeKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DesKeyGenerator : CipherKeyGenerator {
    internal DesKeyGenerator(int defaultStrength);
    protected virtual void engineInit(KeyGenerationParameters parameters);
    protected virtual Byte[] engineGenerateKey();
}
public class Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
internal class Org.BouncyCastle.Crypto.Generators.DHKeyGeneratorHelper : object {
    internal static DHKeyGeneratorHelper Instance;
    private static DHKeyGeneratorHelper();
    internal BigInteger CalculatePrivate(DHParameters dhParams, SecureRandom random);
    internal BigInteger CalculatePublic(DHParameters dhParams, BigInteger x);
}
public class Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator : object {
    private DHKeyGenerationParameters param;
    public virtual void Init(KeyGenerationParameters parameters);
    public virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.DHParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public virtual void Init(int size, int certainty, SecureRandom random);
    public virtual DHParameters GenerateParameters();
}
internal class Org.BouncyCastle.Crypto.Generators.DHParametersHelper : object {
    private static Int32[][] primeLists;
    private static BigInteger Six;
    private static Int32[] primeProducts;
    private static BigInteger[] PrimeProducts;
    private static DHParametersHelper();
    internal static BigInteger[] GenerateSafePrimes(int size, int certainty, SecureRandom random);
    internal static BigInteger SelectGenerator(BigInteger p, BigInteger q, SecureRandom random);
}
public class Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator : object {
    private DsaKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public void Init(int size, int certainty, SecureRandom random);
    private static void Add(Byte[] a, Byte[] b, int value);
    public DsaParameters GenerateParameters();
    private static bool IsValidDsaStrength(int strength);
}
public class Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator : object {
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    private SecureRandom random;
    public ECKeyPairGenerator(string algorithm);
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private string VerifyAlgorithmName(string algorithm);
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator : object {
    private ElGamalKeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator : object {
    private int size;
    private int certainty;
    private SecureRandom random;
    public void Init(int size, int certainty, SecureRandom random);
    public ElGamalParameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator : object {
    private Gost3410KeyGenerationParameters param;
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public class Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator : object {
    private int size;
    private int typeproc;
    private SecureRandom init_random;
    public void Init(int size, int typeProcedure, SecureRandom random);
    private int procedure_A(int x0, int c, BigInteger[] pq, int size);
    private long procedure_Aa(long x0, long c, BigInteger[] pq, int size);
    private void procedure_B(int x0, int c, BigInteger[] pq);
    private void procedure_Bb(long x0, long c, BigInteger[] pq);
    private BigInteger procedure_C(BigInteger p, BigInteger q);
    public Gost3410Parameters GenerateParameters();
}
public class Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator : BaseKdfBytesGenerator {
    public Kdf1BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator : BaseKdfBytesGenerator {
    public Kdf2BytesGenerator(IDigest digest);
}
public class Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator : object {
    private IDigest digest;
    private Byte[] seed;
    private int hLen;
    public IDigest Digest { get; }
    public Mgf1BytesGenerator(IDigest digest);
    public sealed virtual void Init(IDerivationParameters parameters);
    public sealed virtual IDigest get_Digest();
    private void ItoOSP(int i, Byte[] sp);
    public sealed virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public class Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator : object {
    private static Int32[] smallPrimes;
    private NaccacheSternKeyGenerationParameters param;
    private static NaccacheSternKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
    private static BigInteger generatePrime(int bitLength, int certainty, SecureRandom rand);
    private static ArrayList permuteList(ArrayList arr, SecureRandom rand);
    private static ArrayList findFirstPrimes(int count);
}
public class Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual void Init(Byte[] password, Byte[] salt);
    private Byte[] GenerateDerivedKey(int bytesNeeded);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator : PbeParametersGenerator {
    public static int KeyMaterial;
    public static int IVMaterial;
    public static int MacMaterial;
    private IDigest digest;
    private int u;
    private int v;
    public Pkcs12ParametersGenerator(IDigest digest);
    private void Adjust(Byte[] a, int aOff, Byte[] b);
    private Byte[] GenerateDerivedKey(int idByte, int n);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator : PbeParametersGenerator {
    private IDigest digest;
    public Pkcs5S1ParametersGenerator(IDigest digest);
    private Byte[] GenerateDerivedKey();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator : PbeParametersGenerator {
    private IMac hMac;
    private void F(Byte[] P, Byte[] S, int c, Byte[] iBuf, Byte[] outBytes, int outOff);
    private void IntToOctet(Byte[] Buffer, int i);
    private Byte[] GenerateDerivedKey(int dkLen);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
}
public class Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator : object {
    private RsaKeyParameters key;
    private SecureRandom random;
    public void Init(ICipherParameters param);
    public BigInteger GenerateBlindingFactor();
}
public class Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator : object {
    private static int DefaultTests;
    private static BigInteger DefaultPublicExponent;
    private RsaKeyGenerationParameters param;
    private static RsaKeyPairGenerator();
    public sealed virtual void Init(KeyGenerationParameters parameters);
    public sealed virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IAsymmetricBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
public interface Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator {
    public abstract virtual void Init(KeyGenerationParameters parameters);
    public abstract virtual AsymmetricCipherKeyPair GenerateKeyPair();
}
public interface Org.BouncyCastle.Crypto.IBasicAgreement {
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual BigInteger CalculateAgreement(ICipherParameters pubKey);
}
public interface Org.BouncyCastle.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IBufferedCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ICipherParameters {
}
public interface Org.BouncyCastle.Crypto.IDerivationFunction {
    public IDigest Digest { get; }
    public abstract virtual void Init(IDerivationParameters parameters);
    public abstract virtual IDigest get_Digest();
    public abstract virtual int GenerateBytes(Byte[] output, int outOff, int length);
}
public interface Org.BouncyCastle.Crypto.IDerivationParameters {
}
public interface Org.BouncyCastle.Crypto.IDigest {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IDsa {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual BigInteger[] GenerateSignature(Byte[] message);
    public abstract virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public interface Org.BouncyCastle.Crypto.IMac {
    public string AlgorithmName { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.InvalidCipherTextException : CryptoException {
    public InvalidCipherTextException(string message);
    public InvalidCipherTextException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.IO.CipherStream : Stream {
    internal Stream stream;
    internal IBufferedCipher inCipher;
    internal IBufferedCipher outCipher;
    private Byte[] mInBuf;
    private int mInPos;
    private bool inStreamEnded;
    public IBufferedCipher ReadCipher { get; }
    public IBufferedCipher WriteCipher { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CipherStream(Stream stream, IBufferedCipher readCipher, IBufferedCipher writeCipher);
    public IBufferedCipher get_ReadCipher();
    public IBufferedCipher get_WriteCipher();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private bool FillInBuf();
    private Byte[] ReadAndProcessBlock();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.DigestStream : Stream {
    protected Stream stream;
    protected IDigest inDigest;
    protected IDigest outDigest;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DigestStream(Stream stream, IDigest readDigest, IDigest writeDigest);
    public virtual IDigest ReadDigest();
    public virtual IDigest WriteDigest();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.MacStream : Stream {
    protected Stream stream;
    protected IMac inMac;
    protected IMac outMac;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MacStream(Stream stream, IMac readMac, IMac writeMac);
    public virtual IMac ReadMac();
    public virtual IMac WriteMac();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public class Org.BouncyCastle.Crypto.IO.SignerStream : Stream {
    protected Stream stream;
    protected ISigner inSigner;
    protected ISigner outSigner;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SignerStream(Stream stream, ISigner readSigner, ISigner writeSigner);
    public virtual ISigner ReadSigner();
    public virtual ISigner WriteSigner();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
}
public interface Org.BouncyCastle.Crypto.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] signature);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.ISignerWithRecovery {
    public abstract virtual bool HasFullMessage();
    public abstract virtual Byte[] GetRecoveredMessage();
}
public interface Org.BouncyCastle.Crypto.IStreamCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual byte ReturnByte(byte input);
    public abstract virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.IWrapper {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forWrapping, ICipherParameters parameters);
    public abstract virtual Byte[] Wrap(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] Unwrap(Byte[] input, int inOff, int length);
}
public class Org.BouncyCastle.Crypto.KeyGenerationParameters : object {
    private SecureRandom random;
    private int strength;
    public SecureRandom Random { get; }
    public int Strength { get; }
    public KeyGenerationParameters(SecureRandom random, int strength);
    public SecureRandom get_Random();
    public int get_Strength();
}
public class Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac : object {
    private Byte[] mac;
    private Byte[] Buffer;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CbcBlockCipherMac(IBlockCipher cipher);
    public CbcBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits);
    public CbcBlockCipherMac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac : object {
    private Byte[] mac;
    private Byte[] Buffer;
    private int bufOff;
    private MacCFBBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    public string AlgorithmName { get; }
    public CfbBlockCipherMac(IBlockCipher cipher);
    public CfbBlockCipherMac(IBlockCipher cipher, IBlockCipherPadding padding);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits);
    public CfbBlockCipherMac(IBlockCipher cipher, int cfbBitSize, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.CMac : object {
    private static byte CONSTANT_128;
    private static byte CONSTANT_64;
    private Byte[] ZEROES;
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private int macSize;
    private Byte[] L;
    private Byte[] Lu;
    private Byte[] Lu2;
    public string AlgorithmName { get; }
    public CMac(IBlockCipher cipher);
    public CMac(IBlockCipher cipher, int macSizeInBits);
    public sealed virtual string get_AlgorithmName();
    private Byte[] doubleLu(Byte[] inBytes);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.Gost28147Mac : object {
    private static int blockSize;
    private static int macSize;
    private int bufOff;
    private Byte[] buf;
    private Byte[] mac;
    private bool firstStep;
    private Int32[] workingKey;
    private Byte[] S;
    public string AlgorithmName { get; }
    private static Int32[] generateWorkingKey(Byte[] userKey);
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetMacSize();
    private int gost28147_mainStep(int n1, int key);
    private void gost28147MacFunc(Int32[] workingKey, Byte[] input, int inOff, Byte[] output, int outOff);
    private static int bytesToint(Byte[] input, int inOff);
    private static void intTobytes(int num, Byte[] output, int outOff);
    private static Byte[] CM5func(Byte[] buf, int bufOff, Byte[] mac);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.HMac : object {
    private static byte IPAD;
    private static byte OPAD;
    private IDigest digest;
    private int digestSize;
    private int blockLength;
    private Byte[] inputPad;
    private Byte[] outputPad;
    public string AlgorithmName { get; }
    public HMac(IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public IDigest GetUnderlyingDigest();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac : object {
    private Byte[] mac;
    private Byte[] buf;
    private int bufOff;
    private IBlockCipher cipher;
    private IBlockCipherPadding padding;
    private int macSize;
    private KeyParameter lastKey2;
    private KeyParameter lastKey3;
    public string AlgorithmName { get; }
    public ISO9797Alg3Mac(IBlockCipher cipher);
    public ISO9797Alg3Mac(IBlockCipher cipher, IBlockCipherPadding padding);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits);
    public ISO9797Alg3Mac(IBlockCipher cipher, int macSizeInBits, IBlockCipherPadding padding);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(ICipherParameters parameters);
    public sealed virtual int GetMacSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
internal class Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public MacCFBBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    public void GetMacBlock(Byte[] mac);
}
public class Org.BouncyCastle.Crypto.Macs.VmpcMac : object {
    private byte g;
    private byte n;
    private Byte[] P;
    private byte s;
    private Byte[] T;
    private Byte[] workingIV;
    private Byte[] workingKey;
    private byte x1;
    private byte x2;
    private byte x3;
    private byte x4;
    public string AlgorithmName { get; }
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual string get_AlgorithmName();
    public virtual int GetMacSize();
    public virtual void Init(ICipherParameters parameters);
    private void initKey(Byte[] keyBytes, Byte[] ivBytes);
    public virtual void Reset();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
}
public class Org.BouncyCastle.Crypto.MaxBytesExceededException : CryptoException {
    public MaxBytesExceededException(string message);
    public MaxBytesExceededException(string message, Exception e);
}
public class Org.BouncyCastle.Crypto.Modes.CbcBlockCipher : object {
    private Byte[] IV;
    private Byte[] cbcV;
    private Byte[] cbcNextV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CbcBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.CcmBlockCipher : object {
    private static int BlockSize;
    private IBlockCipher cipher;
    private Byte[] macBlock;
    private bool forEncryption;
    private Byte[] nonce;
    private Byte[] associatedText;
    private int macSize;
    private ICipherParameters keyParam;
    private MemoryStream data;
    public string AlgorithmName { get; }
    public CcmBlockCipher(IBlockCipher cipher);
    private static CcmBlockCipher();
    public virtual IBlockCipher GetUnderlyingCipher();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int inLen, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual void Reset();
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public sealed virtual int GetOutputSize(int len);
    public Byte[] ProcessPacket(Byte[] input, int inOff, int inLen);
    private int calculateMac(Byte[] data, int dataOff, int dataLen, Byte[] macBlock);
    private bool hasAssociatedText();
}
public class Org.BouncyCastle.Crypto.Modes.CfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] cfbV;
    private Byte[] cfbOutV;
    private bool encrypting;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CfbBlockCipher(IBlockCipher cipher, int bitBlockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.CtsBlockCipher : BufferedBlockCipher {
    private int blockSize;
    public CtsBlockCipher(IBlockCipher cipher);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.EaxBlockCipher : object {
    private SicBlockCipher cipher;
    private bool forEncryption;
    private int blockSize;
    private IMac mac;
    private Byte[] nonceMac;
    private Byte[] associatedTextMac;
    private Byte[] macBlock;
    private int macSize;
    private Byte[] bufBlock;
    private int bufOff;
    public string AlgorithmName { get; }
    public EaxBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    private void calculateMac();
    public virtual void Reset();
    private void Reset(bool clearMac);
    public virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] outBytes, int outOff);
    public virtual Byte[] GetMac();
    public virtual int GetUpdateOutputSize(int len);
    public virtual int GetOutputSize(int len);
    private int process(byte b, Byte[] outBytes, int outOff);
    private bool verifyMac(Byte[] mac, int off);
}
public class Org.BouncyCastle.Crypto.Modes.GcmBlockCipher : object {
    private static int BlockSize;
    private static Byte[] Zeroes;
    private static BigInteger R;
    private IBlockCipher cipher;
    private bool forEncryption;
    private int macSize;
    private Byte[] nonce;
    private Byte[] A;
    private KeyParameter keyParam;
    private BigInteger H;
    private BigInteger initS;
    private Byte[] J0;
    private Byte[] bufBlock;
    private Byte[] macBlock;
    private BigInteger S;
    private Byte[] counter;
    private int bufOff;
    private long totalLength;
    public string AlgorithmName { get; }
    public GcmBlockCipher(IBlockCipher c);
    private static GcmBlockCipher();
    public virtual string get_AlgorithmName();
    public virtual int GetBlockSize();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual Byte[] GetMac();
    public virtual int GetOutputSize(int len);
    public virtual int GetUpdateOutputSize(int len);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int len, Byte[] output, int outOff);
    private int Process(byte input, Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void Reset(bool clearMac);
    private void gCTRBlock(Byte[] buf, int bufCount, Byte[] output, int outOff);
    private BigInteger gHASH(Byte[] b, bool nonce);
    private void gHASHBlock(Byte[] block);
    private static void inc(Byte[] block);
    private BigInteger multiply(BigInteger X, BigInteger Y);
    private Byte[] asBlock(BigInteger bi);
}
public class Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher : object {
    private static int C1;
    private static int C2;
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool firstStep;
    private int N3;
    private int N4;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public GOfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int bytesToint(Byte[] inBytes, int inOff);
    private void intTobytes(int num, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public abstract virtual int ProcessBytes(Byte[] inBytes, int inOff, int len, Byte[] outBytes, int outOff);
    public abstract virtual int DoFinal(Byte[] outBytes, int outOff);
    public abstract virtual Byte[] GetMac();
    public abstract virtual int GetUpdateOutputSize(int len);
    public abstract virtual int GetOutputSize(int len);
    public abstract virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] ofbV;
    private Byte[] ofbOutV;
    private int blockSize;
    private IBlockCipher cipher;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OfbBlockCipher(IBlockCipher cipher, int blockSize);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher : object {
    private Byte[] IV;
    private Byte[] FR;
    private Byte[] FRE;
    private IBlockCipher cipher;
    private int blockSize;
    private int count;
    private bool forEncryption;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public OpenPgpCfbBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    private byte EncryptByte(byte data, int blockOff);
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Crypto.Modes.SicBlockCipher : object {
    private IBlockCipher cipher;
    private int blockSize;
    private Byte[] IV;
    private Byte[] counter;
    private Byte[] counterOut;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public SicBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding {
    public string PaddingName { get; }
    public abstract virtual void Init(SecureRandom random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] input, int inOff);
    public abstract virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher : BufferedBlockCipher {
    private IBlockCipherPadding padding;
    public PaddedBufferedBlockCipher(IBlockCipher cipher, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
public class Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.TbcPadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public virtual void Init(SecureRandom random);
    public virtual int AddPadding(Byte[] input, int inOff);
    public virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.X923Padding : object {
    private SecureRandom random;
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding : object {
    public string PaddingName { get; }
    public sealed virtual string get_PaddingName();
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
public class Org.BouncyCastle.Crypto.Parameters.AeadParameters : object {
    private Byte[] associatedText;
    private Byte[] nonce;
    private KeyParameter key;
    private int macSize;
    public KeyParameter Key { get; }
    public int MacSize { get; }
    public AeadParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
    public virtual KeyParameter get_Key();
    public virtual int get_MacSize();
    public virtual Byte[] GetAssociatedText();
    public virtual Byte[] GetNonce();
}
public class Org.BouncyCastle.Crypto.Parameters.CcmParameters : AeadParameters {
    public CcmParameters(KeyParameter key, int macSize, Byte[] nonce, Byte[] associatedText);
}
public class Org.BouncyCastle.Crypto.Parameters.DesEdeParameters : DesParameters {
    public static int DesEdeKeyLength;
    public DesEdeParameters(Byte[] key);
    public DesEdeParameters(Byte[] key, int keyOff, int keyLen);
    private static Byte[] FixKey(Byte[] key, int keyOff, int keyLen);
    public static bool IsWeakKey(Byte[] key, int offset, int length);
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
}
public class Org.BouncyCastle.Crypto.Parameters.DesParameters : KeyParameter {
    public static int DesKeyLength;
    private static int N_DES_WEAK_KEYS;
    private static Byte[] DES_weak_keys;
    public DesParameters(Byte[] key);
    public DesParameters(Byte[] key, int keyOff, int keyLen);
    private static DesParameters();
    public static bool IsWeakKey(Byte[] key, int offset);
    public static bool IsWeakKey(Byte[] key);
    public static void SetOddParity(Byte[] bytes);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyGenerationParameters : KeyGenerationParameters {
    private DHParameters parameters;
    public DHParameters Parameters { get; }
    public DHKeyGenerationParameters(SecureRandom random, DHParameters parameters);
    public DHParameters get_Parameters();
    internal static int GetStrength(DHParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.DHKeyParameters : AsymmetricKeyParameter {
    private DHParameters parameters;
    public DHParameters Parameters { get; }
    protected DHKeyParameters(bool isPrivate, DHParameters parameters);
    public DHParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DHKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHParameters : object {
    private static int DefaultMinimumLength;
    private BigInteger p;
    private BigInteger g;
    private BigInteger q;
    private BigInteger j;
    private int m;
    private int l;
    private DHValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public BigInteger Q { get; }
    public BigInteger J { get; }
    public int M { get; }
    public int L { get; }
    public DHValidationParameters ValidationParameters { get; }
    public DHParameters(BigInteger p, BigInteger g);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, BigInteger j, DHValidationParameters validation);
    public DHParameters(BigInteger p, BigInteger g, BigInteger q, int m, int l, BigInteger j, DHValidationParameters validation);
    private static int GetDefaultMParam(int lParam);
    public BigInteger get_P();
    public BigInteger get_G();
    public BigInteger get_Q();
    public BigInteger get_J();
    public int get_M();
    public int get_L();
    public DHValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DHParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPrivateKeyParameters : DHKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DHPrivateKeyParameters(BigInteger x, DHParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters : DHKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DHPublicKeyParameters(BigInteger y, DHParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DHPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DHValidationParameters : object {
    private Byte[] seed;
    private int counter;
    public int Counter { get; }
    public DHValidationParameters(Byte[] seed, int counter);
    public Byte[] GetSeed();
    public int get_Counter();
    public virtual bool Equals(object obj);
    protected bool Equals(DHValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaKeyGenerationParameters : KeyGenerationParameters {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    public DsaKeyGenerationParameters(SecureRandom random, DsaParameters parameters);
    public DsaParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaKeyParameters : AsymmetricKeyParameter {
    private DsaParameters parameters;
    public DsaParameters Parameters { get; }
    public DsaKeyParameters(bool isPrivate, DsaParameters parameters);
    public DsaParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaParameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private DsaValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger G { get; }
    public DsaValidationParameters ValidationParameters { get; }
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g);
    public DsaParameters(BigInteger p, BigInteger q, BigInteger g, DsaValidationParameters parameters);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_G();
    public DsaValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPrivateKeyParameters : DsaKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public DsaPrivateKeyParameters(BigInteger x, DsaParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaPublicKeyParameters : DsaKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public DsaPublicKeyParameters(BigInteger y, DsaParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.DsaValidationParameters : object {
    private Byte[] seed;
    private int counter;
    public int Counter { get; }
    public DsaValidationParameters(Byte[] seed, int counter);
    public Byte[] GetSeed();
    public int get_Counter();
    public virtual bool Equals(object obj);
    protected bool Equals(DsaValidationParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECDomainParameters : object {
    internal ECCurve curve;
    internal Byte[] seed;
    internal ECPoint g;
    internal BigInteger n;
    internal BigInteger h;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public virtual bool Equals(object obj);
    protected bool Equals(ECDomainParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECKeyGenerationParameters : KeyGenerationParameters {
    private ECDomainParameters domainParams;
    private DerObjectIdentifier publicKeyParamSet;
    public ECDomainParameters DomainParameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public ECKeyGenerationParameters(ECDomainParameters domainParameters, SecureRandom random);
    public ECKeyGenerationParameters(DerObjectIdentifier publicKeyParamSet, SecureRandom random);
    public ECDomainParameters get_DomainParameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static ECDomainParameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public abstract class Org.BouncyCastle.Crypto.Parameters.ECKeyParameters : AsymmetricKeyParameter {
    private string algorithm;
    private ECDomainParameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public string AlgorithmName { get; }
    public ECDomainParameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected ECKeyParameters(string algorithm, bool isPrivate, ECDomainParameters parameters);
    protected ECKeyParameters(string algorithm, bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    public string get_AlgorithmName();
    public ECDomainParameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    public virtual bool Equals(object obj);
    protected bool Equals(ECKeyParameters other);
    public virtual int GetHashCode();
    private string VerifyAlgorithmName(string algorithm);
    private static ECDomainParameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters : ECKeyParameters {
    private BigInteger d;
    public BigInteger D { get; }
    public ECPrivateKeyParameters(BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(BigInteger d, DerObjectIdentifier publicKeyParamSet);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, ECDomainParameters parameters);
    public BigInteger get_D();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters : ECKeyParameters {
    private ECPoint q;
    public ECPoint Q { get; }
    public ECPublicKeyParameters(ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(ECPoint q, DerObjectIdentifier publicKeyParamSet);
    public ECPublicKeyParameters(string algorithm, ECPoint q, ECDomainParameters parameters);
    public ECPoint get_Q();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyGenerationParameters : KeyGenerationParameters {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    public ElGamalKeyGenerationParameters(SecureRandom random, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    internal static int GetStrength(ElGamalParameters parameters);
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalKeyParameters : AsymmetricKeyParameter {
    private ElGamalParameters parameters;
    public ElGamalParameters Parameters { get; }
    protected ElGamalKeyParameters(bool isPrivate, ElGamalParameters parameters);
    public ElGamalParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalParameters : object {
    private BigInteger p;
    private BigInteger g;
    private int l;
    public BigInteger P { get; }
    public BigInteger G { get; }
    public int L { get; }
    public ElGamalParameters(BigInteger p, BigInteger g);
    public ElGamalParameters(BigInteger p, BigInteger g, int l);
    public BigInteger get_P();
    public BigInteger get_G();
    public int get_L();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPrivateKeyParameters : ElGamalKeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public ElGamalPrivateKeyParameters(BigInteger x, ElGamalParameters parameters);
    public BigInteger get_X();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPrivateKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.ElGamalPublicKeyParameters : ElGamalKeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public ElGamalPublicKeyParameters(BigInteger y, ElGamalParameters parameters);
    public BigInteger get_Y();
    public virtual bool Equals(object obj);
    protected bool Equals(ElGamalPublicKeyParameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyGenerationParameters : KeyGenerationParameters {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    public Gost3410KeyGenerationParameters(SecureRandom random, Gost3410Parameters parameters);
    public Gost3410KeyGenerationParameters(SecureRandom random, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public abstract class Org.BouncyCastle.Crypto.Parameters.Gost3410KeyParameters : AsymmetricKeyParameter {
    private Gost3410Parameters parameters;
    private DerObjectIdentifier publicKeyParamSet;
    public Gost3410Parameters Parameters { get; }
    public DerObjectIdentifier PublicKeyParamSet { get; }
    protected Gost3410KeyParameters(bool isPrivate, Gost3410Parameters parameters);
    protected Gost3410KeyParameters(bool isPrivate, DerObjectIdentifier publicKeyParamSet);
    public Gost3410Parameters get_Parameters();
    public DerObjectIdentifier get_PublicKeyParamSet();
    private static Gost3410Parameters LookupParameters(DerObjectIdentifier publicKeyParamSet);
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410Parameters : object {
    private BigInteger p;
    private BigInteger q;
    private BigInteger a;
    private Gost3410ValidationParameters validation;
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger A { get; }
    public Gost3410ValidationParameters ValidationParameters { get; }
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a);
    public Gost3410Parameters(BigInteger p, BigInteger q, BigInteger a, Gost3410ValidationParameters validation);
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_A();
    public Gost3410ValidationParameters get_ValidationParameters();
    public virtual bool Equals(object obj);
    protected bool Equals(Gost3410Parameters other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PrivateKeyParameters : Gost3410KeyParameters {
    private BigInteger x;
    public BigInteger X { get; }
    public Gost3410PrivateKeyParameters(BigInteger x, Gost3410Parameters parameters);
    public Gost3410PrivateKeyParameters(BigInteger x, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_X();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410PublicKeyParameters : Gost3410KeyParameters {
    private BigInteger y;
    public BigInteger Y { get; }
    public Gost3410PublicKeyParameters(BigInteger y, Gost3410Parameters parameters);
    public Gost3410PublicKeyParameters(BigInteger y, DerObjectIdentifier publicKeyParamSet);
    public BigInteger get_Y();
}
public class Org.BouncyCastle.Crypto.Parameters.Gost3410ValidationParameters : object {
    private int x0;
    private int c;
    private long x0L;
    private long cL;
    public int C { get; }
    public int X0 { get; }
    public long CL { get; }
    public long X0L { get; }
    public Gost3410ValidationParameters(int x0, int c);
    public Gost3410ValidationParameters(long x0L, long cL);
    public int get_C();
    public int get_X0();
    public long get_CL();
    public long get_X0L();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.IesParameters : object {
    private Byte[] derivation;
    private Byte[] encoding;
    private int macKeySize;
    public int MacKeySize { get; }
    public IesParameters(Byte[] derivation, Byte[] encoding, int macKeySize);
    public Byte[] GetDerivationV();
    public Byte[] GetEncodingV();
    public int get_MacKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters : IesParameters {
    private int cipherKeySize;
    public int CipherKeySize { get; }
    public IesWithCipherParameters(Byte[] derivation, Byte[] encoding, int macKeySize, int cipherKeySize);
    public int get_CipherKeySize();
}
public class Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters : object {
    private Byte[] seed;
    public Iso18033KdfParameters(Byte[] seed);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.KdfParameters : object {
    private Byte[] iv;
    private Byte[] shared;
    public KdfParameters(Byte[] shared, Byte[] iv);
    public Byte[] GetSharedSecret();
    public Byte[] GetIV();
}
public class Org.BouncyCastle.Crypto.Parameters.KeyParameter : object {
    private Byte[] key;
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    public Byte[] GetKey();
}
public class Org.BouncyCastle.Crypto.Parameters.MgfParameters : object {
    private Byte[] seed;
    public MgfParameters(Byte[] seed);
    public MgfParameters(Byte[] seed, int off, int len);
    public Byte[] GetSeed();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters : KeyGenerationParameters {
    private int certainty;
    private int countSmallPrimes;
    private bool debug;
    public int Certainty { get; }
    public int CountSmallPrimes { get; }
    public bool IsDebug { get; }
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes);
    public NaccacheSternKeyGenerationParameters(SecureRandom random, int strength, int certainty, int countSmallPrimes, bool debug);
    public int get_Certainty();
    public int get_CountSmallPrimes();
    public bool get_IsDebug();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters : AsymmetricKeyParameter {
    private BigInteger g;
    private BigInteger n;
    private int lowerSigmaBound;
    public BigInteger G { get; }
    public int LowerSigmaBound { get; }
    public BigInteger Modulus { get; }
    public NaccacheSternKeyParameters(bool privateKey, BigInteger g, BigInteger n, int lowerSigmaBound);
    public BigInteger get_G();
    public int get_LowerSigmaBound();
    public BigInteger get_Modulus();
}
public class Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters : NaccacheSternKeyParameters {
    private BigInteger phiN;
    private ArrayList smallPrimes;
    public BigInteger PhiN { get; }
    public ArrayList SmallPrimes { get; }
    public NaccacheSternPrivateKeyParameters(BigInteger g, BigInteger n, int lowerSigmaBound, ArrayList smallPrimes, BigInteger phiN);
    public BigInteger get_PhiN();
    public ArrayList get_SmallPrimes();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithIV : object {
    private ICipherParameters parameters;
    private Byte[] iv;
    public ICipherParameters Parameters { get; }
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv);
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv, int ivOff, int ivLen);
    public Byte[] GetIV();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithRandom : object {
    private ICipherParameters parameters;
    private SecureRandom random;
    public SecureRandom Random { get; }
    public ICipherParameters Parameters { get; }
    public ParametersWithRandom(ICipherParameters parameters, SecureRandom random);
    public ParametersWithRandom(ICipherParameters parameters);
    [ObsoleteAttribute("Use Random property instead")]
public SecureRandom GetRandom();
    public SecureRandom get_Random();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt : object {
    private Byte[] salt;
    private ICipherParameters parameters;
    public ICipherParameters Parameters { get; }
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt);
    public ParametersWithSalt(ICipherParameters parameters, Byte[] salt, int saltOff, int saltLen);
    public Byte[] GetSalt();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.ParametersWithSBox : object {
    private ICipherParameters parameters;
    private Byte[] sBox;
    public ICipherParameters Parameters { get; }
    public ParametersWithSBox(ICipherParameters parameters, Byte[] sBox);
    public Byte[] GetSBox();
    public ICipherParameters get_Parameters();
}
public class Org.BouncyCastle.Crypto.Parameters.RC2Parameters : KeyParameter {
    private int bits;
    public int EffectiveKeyBits { get; }
    public RC2Parameters(Byte[] key);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen);
    public RC2Parameters(Byte[] key, int bits);
    public RC2Parameters(Byte[] key, int keyOff, int keyLen, int bits);
    public int get_EffectiveKeyBits();
}
public class Org.BouncyCastle.Crypto.Parameters.RC5Parameters : KeyParameter {
    private int rounds;
    public int Rounds { get; }
    public RC5Parameters(Byte[] key, int rounds);
    public int get_Rounds();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaBlindingParameters : object {
    private RsaKeyParameters publicKey;
    private BigInteger blindingFactor;
    public RsaKeyParameters PublicKey { get; }
    public BigInteger BlindingFactor { get; }
    public RsaBlindingParameters(RsaKeyParameters publicKey, BigInteger blindingFactor);
    public RsaKeyParameters get_PublicKey();
    public BigInteger get_BlindingFactor();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyGenerationParameters : KeyGenerationParameters {
    private BigInteger publicExponent;
    private int certainty;
    public BigInteger PublicExponent { get; }
    public int Certainty { get; }
    public RsaKeyGenerationParameters(BigInteger publicExponent, SecureRandom random, int strength, int certainty);
    public BigInteger get_PublicExponent();
    public int get_Certainty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters : AsymmetricKeyParameter {
    private BigInteger modulus;
    private BigInteger exponent;
    public BigInteger Modulus { get; }
    public BigInteger Exponent { get; }
    public RsaKeyParameters(bool isPrivate, BigInteger modulus, BigInteger exponent);
    public BigInteger get_Modulus();
    public BigInteger get_Exponent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Crypto.Parameters.RsaPrivateCrtKeyParameters : RsaKeyParameters {
    private BigInteger e;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dP;
    private BigInteger dQ;
    private BigInteger qInv;
    public BigInteger PublicExponent { get; }
    public BigInteger P { get; }
    public BigInteger Q { get; }
    public BigInteger DP { get; }
    public BigInteger DQ { get; }
    public BigInteger QInv { get; }
    public RsaPrivateCrtKeyParameters(BigInteger modulus, BigInteger publicExponent, BigInteger privateExponent, BigInteger p, BigInteger q, BigInteger dP, BigInteger dQ, BigInteger qInv);
    public BigInteger get_PublicExponent();
    public BigInteger get_P();
    public BigInteger get_Q();
    public BigInteger get_DP();
    public BigInteger get_DQ();
    public BigInteger get_QInv();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Crypto.PbeParametersGenerator : object {
    protected Byte[] mPassword;
    protected Byte[] mSalt;
    protected int mIterationCount;
    public Byte[] Password { get; }
    public Byte[] Salt { get; }
    public int IterationCount { get; }
    public virtual void Init(Byte[] password, Byte[] salt, int iterationCount);
    public virtual Byte[] get_Password();
    [ObsoleteAttribute("Use 'Password' property")]
public Byte[] GetPassword();
    public virtual Byte[] get_Salt();
    [ObsoleteAttribute("Use 'Salt' property")]
public Byte[] GetSalt();
    public virtual int get_IterationCount();
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize);
    [ObsoleteAttribute("Use version with 'algorithm' parameter")]
public abstract virtual ICipherParameters GenerateDerivedParameters(int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedParameters(string algorithm, int keySize, int ivSize);
    public abstract virtual ICipherParameters GenerateDerivedMacParameters(int keySize);
    public static Byte[] Pkcs5PasswordToBytes(Char[] password);
    public static Byte[] Pkcs5PasswordToBytes(string password);
    public static Byte[] Pkcs5PasswordToUtf8Bytes(Char[] password);
    public static Byte[] Pkcs5PasswordToUtf8Bytes(string password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password);
    public static Byte[] Pkcs12PasswordToBytes(Char[] password, bool wrongPkcs12Zero);
}
public class Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator : object {
    private RNGCryptoServiceProvider rndProv;
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator : object {
    private static long CYCLE_COUNT;
    private long stateCounter;
    private long seedCounter;
    private IDigest digest;
    private Byte[] state;
    private Byte[] seed;
    public DigestRandomGenerator(IDigest digest);
    public sealed virtual void AddSeedMaterial(Byte[] inSeed);
    public sealed virtual void AddSeedMaterial(long rSeed);
    public sealed virtual void NextBytes(Byte[] bytes);
    public sealed virtual void NextBytes(Byte[] bytes, int start, int len);
    private void CycleSeed();
    private void GenerateState();
    private void DigestAddCounter(long seedVal);
    private void DigestUpdate(Byte[] inSeed);
    private void DigestDoFinal(Byte[] result);
}
public interface Org.BouncyCastle.Crypto.Prng.IRandomGenerator {
    public abstract virtual void AddSeedMaterial(Byte[] seed);
    public abstract virtual void AddSeedMaterial(long seed);
    public abstract virtual void NextBytes(Byte[] bytes);
    public abstract virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator : object {
    private IRandomGenerator generator;
    private Byte[] window;
    private int windowCount;
    public ReversedWindowGenerator(IRandomGenerator generator, int windowSize);
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
    private void doNextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator : object {
    public Byte[] GenerateSeed(int numBytes, bool fast);
}
public class Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator : object {
    private byte n;
    private Byte[] P;
    private byte s;
    public virtual void AddSeedMaterial(Byte[] seed);
    public virtual void AddSeedMaterial(long seed);
    public virtual void NextBytes(Byte[] bytes);
    public virtual void NextBytes(Byte[] bytes, int start, int len);
}
public class Org.BouncyCastle.Crypto.Signers.DsaDigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private bool forSigning;
    public string AlgorithmName { get; }
    public DsaDigestSigner(IDsa signer, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(BigInteger r, BigInteger s);
    private BigInteger[] DerDecode(Byte[] encoding);
}
public class Org.BouncyCastle.Crypto.Signers.DsaSigner : object {
    private DsaKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    private BigInteger calculateE(BigInteger n, Byte[] message);
}
public class Org.BouncyCastle.Crypto.Signers.ECDsaSigner : object {
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    private BigInteger calculateE(BigInteger n, Byte[] message);
}
public class Org.BouncyCastle.Crypto.Signers.ECGost3410Signer : object {
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.ECNRSigner : object {
    private bool forSigning;
    private ECKeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.GenericSigner : object {
    private IAsymmetricBlockCipher engine;
    private IDigest digest;
    private bool forSigning;
    public string AlgorithmName { get; }
    public GenericSigner(IAsymmetricBlockCipher engine, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner : object {
    private IDigest digest;
    private IDsa dsaSigner;
    private bool forSigning;
    public string AlgorithmName { get; }
    public Gost3410DigestSigner(IDsa signer, IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Signers.Gost3410Signer : object {
    private Gost3410KeyParameters key;
    private SecureRandom random;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual BigInteger[] GenerateSignature(Byte[] message);
    public sealed virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner : object {
    public static int TrailerImplicit;
    public static int TrailerRipeMD160;
    public static int TrailerRipeMD128;
    public static int TrailerSha1;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private Byte[] standardSalt;
    private int hLen;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private int saltLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    public string AlgorithmName { get; }
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength, bool isImplicit);
    public Iso9796d2PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLength);
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public sealed virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual bool HasFullMessage();
    private void ItoOSP(int i, Byte[] sp);
    private void LtoOSP(long l, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer : object {
    public static int TrailerImplicit;
    public static int TrailerRipeMD160;
    public static int TrailerRipeMD128;
    public static int TrailerSha1;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private int trailer;
    private int keyBits;
    private Byte[] block;
    private Byte[] mBuf;
    private int messageLength;
    private bool fullMessage;
    private Byte[] recoveredMessage;
    public string AlgorithmName { get; }
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest, bool isImplicit);
    public Iso9796d2Signer(IAsymmetricBlockCipher cipher, IDigest digest);
    public sealed virtual Byte[] GetRecoveredMessage();
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private bool IsSameAs(Byte[] a, Byte[] b);
    private void ClearBlock(Byte[] block);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    public virtual bool HasFullMessage();
}
public class Org.BouncyCastle.Crypto.Signers.PssSigner : object {
    public static byte TrailerImplicit;
    private IDigest digest;
    private IAsymmetricBlockCipher cipher;
    private SecureRandom random;
    private int hLen;
    private int sLen;
    private int emBits;
    private Byte[] salt;
    private Byte[] mDash;
    private Byte[] block;
    private byte trailer;
    public string AlgorithmName { get; }
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen);
    public PssSigner(IAsymmetricBlockCipher cipher, IDigest digest, int saltLen, byte trailer);
    public sealed virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    private void ClearBlock(Byte[] block);
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public virtual void Reset();
    public virtual Byte[] GenerateSignature();
    public virtual bool VerifySignature(Byte[] signature);
    private void ItoOSP(int i, Byte[] sp);
    private Byte[] MaskGeneratorFunction1(Byte[] Z, int zOff, int zLen, int length);
}
public class Org.BouncyCastle.Crypto.Signers.RsaDigestSigner : object {
    private IAsymmetricBlockCipher rsaEngine;
    private AlgorithmIdentifier algId;
    private IDigest digest;
    private bool forSigning;
    private static Hashtable oidMap;
    public string AlgorithmName { get; }
    private static RsaDigestSigner();
    public RsaDigestSigner(IDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(Byte[] hash);
}
public class Org.BouncyCastle.Crypto.StreamBlockCipher : object {
    private IBlockCipher cipher;
    private Byte[] oneByte;
    public string AlgorithmName { get; }
    public StreamBlockCipher(IBlockCipher cipher);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual byte ReturnByte(byte input);
    public sealed virtual void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer : object {
    public sealed virtual bool IsValid(X509CertificateStructure[] certs);
}
public class Org.BouncyCastle.Crypto.Tls.ByteQueue : object {
    private static int InitBufSize;
    private Byte[] databuf;
    private int skipped;
    private int available;
    public int Available { get; }
    public static int NextTwoPow(int i);
    public void Read(Byte[] buf, int offset, int len, int skip);
    public void AddData(Byte[] data, int offset, int len);
    public void RemoveData(int i);
    public int get_Available();
}
public class Org.BouncyCastle.Crypto.Tls.Certificate : object {
    internal X509CertificateStructure[] certs;
    private Certificate(X509CertificateStructure[] certs);
    internal static Certificate Parse(Stream inStr);
    public X509CertificateStructure[] GetCerts();
}
public class Org.BouncyCastle.Crypto.Tls.CombinedHash : object {
    private IDigest md5;
    private IDigest sha1;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int GetByteLength();
    public sealed virtual int GetDigestSize();
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public interface Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer {
    public abstract virtual bool IsValid(X509CertificateStructure[] certs);
}
public class Org.BouncyCastle.Crypto.Tls.RecordStream : object {
    private TlsProtocolHandler handler;
    private Stream inStr;
    private Stream outStr;
    internal CombinedHash hash1;
    internal CombinedHash hash2;
    internal TlsCipherSuite readSuite;
    internal TlsCipherSuite writeSuite;
    internal RecordStream(TlsProtocolHandler handler, Stream inStr, Stream outStr);
    public void ReadData();
    internal Byte[] DecodeAndVerify(short type, Stream inStr, int len);
    internal void WriteMessage(short type, Byte[] message, int offset, int len);
    internal void Close();
    internal void Flush();
}
public class Org.BouncyCastle.Crypto.Tls.TlsBlockCipherCipherSuite : TlsCipherSuite {
    private IBlockCipher encryptCipher;
    private IBlockCipher decryptCipher;
    private IDigest writeDigest;
    private IDigest readDigest;
    private int cipherKeySize;
    private short keyExchange;
    private TlsMac writeMac;
    private TlsMac readMac;
    internal short KeyExchangeAlgorithm { get; }
    internal TlsBlockCipherCipherSuite(IBlockCipher encrypt, IBlockCipher decrypt, IDigest writeDigest, IDigest readDigest, int cipherKeySize, short keyExchange);
    internal virtual void Init(Byte[] ms, Byte[] cr, Byte[] sr);
    private void initCipher(bool forEncryption, IBlockCipher cipher, Byte[] key_block, int key_size, int key_offset, int iv_offset);
    internal virtual Byte[] EncodePlaintext(short type, Byte[] plaintext, int offset, int len);
    internal virtual Byte[] DecodeCiphertext(short type, Byte[] ciphertext, int offset, int len, TlsProtocolHandler handler);
    internal virtual short get_KeyExchangeAlgorithm();
}
public abstract class Org.BouncyCastle.Crypto.Tls.TlsCipherSuite : object {
    internal static short KE_RSA;
    internal static short KE_RSA_EXPORT;
    internal static short KE_DHE_DSS;
    internal static short KE_DHE_DSS_EXPORT;
    internal static short KE_DHE_RSA;
    internal static short KE_DHE_RSA_EXPORT;
    internal static short KE_DH_DSS;
    internal static short KE_DH_RSA;
    internal static short KE_DH_anon;
    internal short KeyExchangeAlgorithm { get; }
    internal abstract virtual void Init(Byte[] ms, Byte[] cr, Byte[] sr);
    internal abstract virtual Byte[] EncodePlaintext(short type, Byte[] plaintext, int offset, int len);
    internal abstract virtual Byte[] DecodeCiphertext(short type, Byte[] plaintext, int offset, int len, TlsProtocolHandler handler);
    internal abstract virtual short get_KeyExchangeAlgorithm();
}
public class Org.BouncyCastle.Crypto.Tls.TlsCipherSuiteManager : object {
    private static int TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    private static int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    private static int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    private static int TLS_RSA_WITH_AES_128_CBC_SHA;
    private static int TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    private static int TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    private static int TLS_RSA_WITH_AES_256_CBC_SHA;
    private static int TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    private static int TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    internal static void WriteCipherSuites(Stream outStr);
    internal static TlsCipherSuite GetCipherSuite(int number, TlsProtocolHandler handler);
    private static TlsCipherSuite createAesCipherSuite(int cipherKeySize, short keyExchange);
    private static TlsCipherSuite createDesEdeCipherSuite(int cipherKeySize, short keyExchange);
    private static CbcBlockCipher createAesCipher();
    private static CbcBlockCipher createDesEdeCipher();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsDssSigner : DsaDigestSigner {
}
public class Org.BouncyCastle.Crypto.Tls.TlsException : Exception {
    public TlsException(string message);
    public TlsException(string message, Exception exception);
}
public class Org.BouncyCastle.Crypto.Tls.TlsInputStream : BaseInputStream {
    private TlsProtocolHandler handler;
    internal TlsInputStream(TlsProtocolHandler handler);
    public virtual int Read(Byte[] buf, int offset, int len);
    public virtual int ReadByte();
    public virtual void Close();
}
public class Org.BouncyCastle.Crypto.Tls.TlsMac : object {
    private long seqNo;
    private HMac mac;
    internal int Size { get; }
    internal TlsMac(IDigest digest, Byte[] key_block, int offset, int len);
    internal int get_Size();
    internal Byte[] CalculateMac(short type, Byte[] message, int offset, int len);
}
public class Org.BouncyCastle.Crypto.Tls.TlsNullCipherSuite : TlsCipherSuite {
    internal short KeyExchangeAlgorithm { get; }
    internal virtual void Init(Byte[] ms, Byte[] cr, Byte[] sr);
    internal virtual Byte[] EncodePlaintext(short type, Byte[] plaintext, int offset, int len);
    internal virtual Byte[] DecodeCiphertext(short type, Byte[] plaintext, int offset, int len, TlsProtocolHandler handler);
    internal virtual short get_KeyExchangeAlgorithm();
}
public class Org.BouncyCastle.Crypto.Tls.TlsOuputStream : BaseOutputStream {
    private TlsProtocolHandler handler;
    internal TlsOuputStream(TlsProtocolHandler handler);
    public virtual void Write(Byte[] buf, int offset, int len);
    [ObsoleteAttribute("Use version that takes a 'byte' argument")]
public void WriteByte(int arg0);
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual void Flush();
}
public class Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler : object {
    private static short RL_CHANGE_CIPHER_SPEC;
    private static short RL_ALERT;
    private static short RL_HANDSHAKE;
    private static short RL_APPLICATION_DATA;
    private static short HP_HELLO_REQUEST;
    private static short HP_CLIENT_HELLO;
    private static short HP_SERVER_HELLO;
    private static short HP_CERTIFICATE;
    private static short HP_SERVER_KEY_EXCHANGE;
    private static short HP_CERTIFICATE_REQUEST;
    private static short HP_SERVER_HELLO_DONE;
    private static short HP_CERTIFICATE_VERIFY;
    private static short HP_CLIENT_KEY_EXCHANGE;
    private static short HP_FINISHED;
    private static short CS_CLIENT_HELLO_SEND;
    private static short CS_SERVER_HELLO_RECEIVED;
    private static short CS_SERVER_CERTIFICATE_RECEIVED;
    private static short CS_SERVER_KEY_EXCHANGE_RECEIVED;
    private static short CS_CERTIFICATE_REQUEST_RECEIVED;
    private static short CS_SERVER_HELLO_DONE_RECEIVED;
    private static short CS_CLIENT_KEY_EXCHANGE_SEND;
    private static short CS_CLIENT_CHANGE_CIPHER_SPEC_SEND;
    private static short CS_CLIENT_FINISHED_SEND;
    private static short CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED;
    private static short CS_DONE;
    internal static short AP_close_notify;
    internal static short AP_unexpected_message;
    internal static short AP_bad_record_mac;
    internal static short AP_decryption_failed;
    internal static short AP_record_overflow;
    internal static short AP_decompression_failure;
    internal static short AP_handshake_failure;
    internal static short AP_bad_certificate;
    internal static short AP_unsupported_certificate;
    internal static short AP_certificate_revoked;
    internal static short AP_certificate_expired;
    internal static short AP_certificate_unknown;
    internal static short AP_illegal_parameter;
    internal static short AP_unknown_ca;
    internal static short AP_access_denied;
    internal static short AP_decode_error;
    internal static short AP_decrypt_error;
    internal static short AP_export_restriction;
    internal static short AP_protocol_version;
    internal static short AP_insufficient_security;
    internal static short AP_internal_error;
    internal static short AP_user_canceled;
    internal static short AP_no_renegotiation;
    internal static short AL_warning;
    internal static short AL_fatal;
    private static Byte[] emptybuf;
    private static string TLS_ERROR_MESSAGE;
    private ByteQueue applicationDataQueue;
    private ByteQueue changeCipherSpecQueue;
    private ByteQueue alertQueue;
    private ByteQueue handshakeQueue;
    private RecordStream rs;
    private SecureRandom random;
    private AsymmetricKeyParameter serverPublicKey;
    private TlsInputStream tlsInputStream;
    private TlsOuputStream tlsOutputStream;
    private bool closed;
    private bool failedWithError;
    private bool appDataReady;
    private Byte[] clientRandom;
    private Byte[] serverRandom;
    private Byte[] ms;
    private TlsCipherSuite chosenCipherSuite;
    private BigInteger Yc;
    private Byte[] pms;
    private ICertificateVerifyer verifyer;
    private short connection_state;
    [ObsoleteAttribute("Use 'OutputStream' property instead")]
public TlsOuputStream TlsOuputStream { get; }
    public Stream OutputStream { get; }
    [ObsoleteAttribute("Use 'InputStream' property instead")]
public TlsInputStream TlsInputStream { get; }
    public Stream InputStream { get; }
    public TlsProtocolHandler(Stream inStr, Stream outStr);
    public TlsProtocolHandler(Stream inStr, Stream outStr, SecureRandom sr);
    private static TlsProtocolHandler();
    internal void ProcessData(short protocol, Byte[] buf, int offset, int len);
    private void processHandshake();
    private void processApplicationData();
    private void processAlert();
    private void processChangeCipherSpec();
    private void processDHEKeyExchange(MemoryStream inStr, ISigner signer);
    private void validateKeyUsage(X509CertificateStructure c, int keyUsageBits);
    private void sendClientCertificate();
    private void sendClientKeyExchange(Byte[] keData);
    public virtual void Connect(ICertificateVerifyer verifyer);
    internal int ReadApplicationData(Byte[] buf, int offset, int len);
    internal void WriteData(Byte[] buf, int offset, int len);
    public TlsOuputStream get_TlsOuputStream();
    public virtual Stream get_OutputStream();
    public TlsInputStream get_TlsInputStream();
    public virtual Stream get_InputStream();
    internal void FailWithError(short alertLevel, short alertDescription);
    public virtual void Close();
    internal void AssertEmpty(MemoryStream inStr);
    internal void Flush();
}
internal class Org.BouncyCastle.Crypto.Tls.TlsRsaSigner : GenericSigner {
}
public class Org.BouncyCastle.Crypto.Tls.TlsUtilities : object {
    internal static Byte[] ToByteArray(string str);
    internal static void WriteUint8(short i, Stream os);
    internal static void WriteUint8(short i, Byte[] buf, int offset);
    internal static void WriteUint16(int i, Stream os);
    internal static void WriteUint16(int i, Byte[] buf, int offset);
    internal static void WriteUint24(int i, Stream os);
    internal static void WriteUint24(int i, Byte[] buf, int offset);
    internal static void WriteUint64(long i, Stream os);
    internal static void WriteUint64(long i, Byte[] buf, int offset);
    internal static short ReadUint8(Stream inStr);
    internal static int ReadUint16(Stream inStr);
    internal static int ReadUint24(Stream inStr);
    internal static void ReadFully(Byte[] buf, Stream inStr);
    internal static void CheckVersion(Byte[] readVersion, TlsProtocolHandler handler);
    internal static void CheckVersion(Stream inStr, TlsProtocolHandler handler);
    internal static void WriteVersion(Stream os);
    private static void hmac_hash(IDigest digest, Byte[] secret, Byte[] seed, Byte[] output);
    internal static void PRF(Byte[] secret, Byte[] label, Byte[] seed, Byte[] buf);
}
internal class Org.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static UInt32 BE_To_UInt32(Byte[] bs);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static UInt32 LE_To_UInt32(Byte[] bs);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
}
public class Org.BouncyCastle.Math.BigInteger : object {
    private static long IMASK;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    private static Int32[][] primeLists;
    private static Int32[] primeProducts;
    private static ulong UIMASK;
    private static Int32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Ten;
    private static int chunk2;
    private static BigInteger radix2;
    private static BigInteger radix2E;
    private static int chunk10;
    private static BigInteger radix10;
    private static BigInteger radix10E;
    private static int chunk16;
    private static BigInteger radix16;
    private static BigInteger radix16E;
    private static Random RandomSource;
    private int sign;
    private Int32[] magnitude;
    private int nBits;
    private int nBitLength;
    private long mQuote;
    private static Byte[] rndMask;
    private static Byte[] bitCounts;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public long LongValue { get; }
    public int SignValue { get; }
    private static BigInteger();
    private BigInteger(int signum, Int32[] mag, bool checkMag);
    public BigInteger(string value);
    public BigInteger(string str, int radix);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    public BigInteger(int sign, Byte[] bytes);
    public BigInteger(int sign, Byte[] bytes, int offset, int length);
    public BigInteger(int sizeInBits, Random random);
    public BigInteger(int bitLength, int certainty, Random random);
    private static int GetByteLength(int nBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    public BigInteger Abs();
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    public BigInteger Add(BigInteger value);
    private BigInteger AddToMagnitude(Int32[] magToAdd);
    public BigInteger And(BigInteger value);
    public BigInteger AndNot(BigInteger val);
    public int get_BitCount();
    private int calcBitLength(int indx, Int32[] mag);
    public int get_BitLength();
    private static int BitLen(int w);
    private bool QuickPow2Check();
    public int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    public int CompareTo(BigInteger value);
    private Int32[] Divide(Int32[] x, Int32[] y);
    public BigInteger Divide(BigInteger val);
    public BigInteger[] DivideAndRemainder(BigInteger val);
    public virtual bool Equals(object obj);
    public BigInteger Gcd(BigInteger value);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public int get_IntValue();
    public bool IsProbablePrime(int certainty);
    private bool CheckProbablePrime(int certainty, Random random);
    internal bool RabinMillerTest(int certainty, Random random);
    public long get_LongValue();
    public BigInteger Max(BigInteger value);
    public BigInteger Min(BigInteger value);
    public BigInteger Mod(BigInteger m);
    public BigInteger ModInverse(BigInteger m);
    private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger u1Out, BigInteger u2Out);
    private static void ZeroOut(Int32[] x);
    public BigInteger ModPow(BigInteger exponent, BigInteger m);
    private static Int32[] Square(Int32[] w, Int32[] x);
    private static Int32[] Multiply(Int32[] x, Int32[] y, Int32[] z);
    private static long FastExtEuclid(long a, long b, Int64[] uOut);
    private static long FastModInverse(long v, long m);
    private long GetMQuote();
    private static void MultiplyMonty(Int32[] a, Int32[] x, Int32[] y, Int32[] m, long mQuote);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, ulong mQuote);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Negate();
    public BigInteger NextProbablePrime();
    public BigInteger Not();
    public BigInteger Pow(int exp);
    public static BigInteger ProbablePrime(int bitLength, Random random);
    private int Remainder(int m);
    private Int32[] Remainder(Int32[] x, Int32[] y);
    public BigInteger Remainder(BigInteger n);
    private Int32[] LastNBits(int n);
    private static Int32[] ShiftLeft(Int32[] mag, int n);
    public BigInteger ShiftLeft(int n);
    private static Int32[] ShiftRightInPlace(int start, Int32[] mag, int n);
    private static Int32[] ShiftRightOneInPlace(int start, Int32[] mag);
    public BigInteger ShiftRight(int n);
    public int get_SignValue();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    public BigInteger Subtract(BigInteger n);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static BigInteger createUValueOf(ulong value);
    private static BigInteger createValueOf(long value);
    public static BigInteger ValueOf(long value);
    public int GetLowestSetBit();
    public bool TestBit(int n);
    public BigInteger Or(BigInteger value);
    public BigInteger Xor(BigInteger value);
    public BigInteger SetBit(int n);
    public BigInteger ClearBit(int n);
    public BigInteger FlipBit(int n);
    private BigInteger FlipExistingBit(int n);
}
internal class Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal : object {
    private BigInteger bigInt;
    private int scale;
    public int IntValue { get; }
    public long LongValue { get; }
    public int Scale { get; }
    public SimpleBigDecimal(BigInteger bigInt, int scale);
    private SimpleBigDecimal(SimpleBigDecimal limBigDec);
    public static SimpleBigDecimal GetInstance(BigInteger val, int scale);
    private void CheckScale(SimpleBigDecimal b);
    public SimpleBigDecimal AdjustScale(int newScale);
    public SimpleBigDecimal Add(SimpleBigDecimal b);
    public SimpleBigDecimal Add(BigInteger b);
    public SimpleBigDecimal Negate();
    public SimpleBigDecimal Subtract(SimpleBigDecimal b);
    public SimpleBigDecimal Subtract(BigInteger b);
    public SimpleBigDecimal Multiply(SimpleBigDecimal b);
    public SimpleBigDecimal Multiply(BigInteger b);
    public SimpleBigDecimal Divide(SimpleBigDecimal b);
    public SimpleBigDecimal Divide(BigInteger b);
    public SimpleBigDecimal ShiftLeft(int n);
    public int CompareTo(SimpleBigDecimal val);
    public int CompareTo(BigInteger val);
    public BigInteger Floor();
    public BigInteger Round();
    public int get_IntValue();
    public long get_LongValue();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Org.BouncyCastle.Math.EC.Abc.Tnaf : object {
    public static sbyte Width;
    public static sbyte Pow2Width;
    private static BigInteger MinusOne;
    private static BigInteger MinusTwo;
    private static BigInteger MinusThree;
    private static BigInteger Four;
    public static ZTauElement[] Alpha0;
    public static SByte[][] Alpha0Tnaf;
    public static ZTauElement[] Alpha1;
    public static SByte[][] Alpha1Tnaf;
    private static Tnaf();
    public static BigInteger Norm(sbyte mu, ZTauElement lambda);
    public static SimpleBigDecimal Norm(sbyte mu, SimpleBigDecimal u, SimpleBigDecimal v);
    public static ZTauElement Round(SimpleBigDecimal lambda0, SimpleBigDecimal lambda1, sbyte mu);
    public static SimpleBigDecimal ApproximateDivisionByN(BigInteger k, BigInteger s, BigInteger vm, sbyte a, int m, int c);
    public static SByte[] TauAdicNaf(sbyte mu, ZTauElement lambda);
    public static F2mPoint Tau(F2mPoint p);
    public static sbyte GetMu(F2mCurve curve);
    public static BigInteger[] GetLucas(sbyte mu, int k, bool doV);
    public static BigInteger GetTw(sbyte mu, int w);
    public static BigInteger[] GetSi(F2mCurve curve);
    public static ZTauElement PartModReduction(BigInteger k, int m, sbyte a, BigInteger[] s, sbyte mu, sbyte c);
    public static F2mPoint MultiplyRTnaf(F2mPoint p, BigInteger k);
    public static F2mPoint MultiplyTnaf(F2mPoint p, ZTauElement lambda);
    public static F2mPoint MultiplyFromTnaf(F2mPoint p, SByte[] u);
    public static SByte[] TauAdicWNaf(sbyte mu, ZTauElement lambda, sbyte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha);
    public static F2mPoint[] GetPreComp(F2mPoint p, sbyte a);
}
internal class Org.BouncyCastle.Math.EC.Abc.ZTauElement : object {
    public BigInteger u;
    public BigInteger v;
    public ZTauElement(BigInteger u, BigInteger v);
}
public class Org.BouncyCastle.Math.EC.ECAlgorithms : object {
    public static ECPoint SumOfTwoMultiplies(ECPoint P, BigInteger a, ECPoint Q, BigInteger b);
    public static ECPoint ShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    private static ECPoint ImplShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
}
public abstract class Org.BouncyCastle.Math.EC.ECCurve : object {
    internal ECFieldElement a;
    internal ECFieldElement b;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public ECFieldElement A { get; }
    public ECFieldElement B { get; }
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement FromBigInteger(BigInteger x);
    public abstract virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    public abstract virtual ECPoint DecodePoint(Byte[] encoded);
    public abstract virtual ECPoint get_Infinity();
    public ECFieldElement get_A();
    public ECFieldElement get_B();
    public virtual bool Equals(object obj);
    protected bool Equals(ECCurve other);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Math.EC.ECCurveBase : ECCurve {
    protected internal abstract virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual ECPoint DecodePoint(Byte[] encoded);
}
public abstract class Org.BouncyCastle.Math.EC.ECFieldElement : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public abstract virtual BigInteger ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement Add(ECFieldElement b);
    public abstract virtual ECFieldElement Subtract(ECFieldElement b);
    public abstract virtual ECFieldElement Multiply(ECFieldElement b);
    public abstract virtual ECFieldElement Divide(ECFieldElement b);
    public abstract virtual ECFieldElement Negate();
    public abstract virtual ECFieldElement Square();
    public abstract virtual ECFieldElement Invert();
    public abstract virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    protected bool Equals(ECFieldElement other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Math.EC.ECPoint : object {
    internal ECCurve curve;
    internal ECFieldElement x;
    internal ECFieldElement y;
    internal bool withCompression;
    internal ECMultiplier multiplier;
    internal PreCompInfo preCompInfo;
    public ECCurve Curve { get; }
    public ECFieldElement X { get; }
    public ECFieldElement Y { get; }
    public bool IsInfinity { get; }
    public bool IsCompressed { get; }
    protected internal ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    public ECCurve get_Curve();
    public ECFieldElement get_X();
    public ECFieldElement get_Y();
    public bool get_IsInfinity();
    public bool get_IsCompressed();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void SetPreCompInfo(PreCompInfo preCompInfo);
    public abstract virtual Byte[] GetEncoded();
    public abstract virtual ECPoint Add(ECPoint b);
    public abstract virtual ECPoint Subtract(ECPoint b);
    public abstract virtual ECPoint Negate();
    public abstract virtual ECPoint Twice();
    public abstract virtual ECPoint Multiply(BigInteger b);
    internal virtual void AssertECMultiplier();
}
public abstract class Org.BouncyCastle.Math.EC.ECPointBase : ECPoint {
    protected internal bool YTilde { get; }
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal abstract virtual bool get_YTilde();
    public virtual Byte[] GetEncoded();
    public virtual ECPoint Multiply(BigInteger k);
}
public class Org.BouncyCastle.Math.EC.F2mCurve : ECCurveBase {
    private int m;
    private int k1;
    private int k2;
    private int k3;
    private BigInteger n;
    private BigInteger h;
    private F2mPoint infinity;
    private sbyte mu;
    private BigInteger[] si;
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public bool IsKoblitz { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public F2mCurve(int m, int k, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k, BigInteger a, BigInteger b, BigInteger n, BigInteger h);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b, BigInteger n, BigInteger h);
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    public bool get_IsKoblitz();
    internal sbyte GetMu();
    internal BigInteger[] GetSi();
    public virtual ECPoint CreatePoint(BigInteger X1, BigInteger Y1, bool withCompression);
    protected internal virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    private ECFieldElement solveQuadradicEquation(ECFieldElement beta);
    public virtual bool Equals(object obj);
    protected bool Equals(F2mCurve other);
    public virtual int GetHashCode();
    public int get_M();
    public bool IsTrinomial();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public BigInteger get_N();
    public BigInteger get_H();
}
public class Org.BouncyCastle.Math.EC.F2mFieldElement : ECFieldElement {
    public static int Gnb;
    public static int Tpb;
    public static int Ppb;
    private int representation;
    private int m;
    private int k1;
    private int k2;
    private int k3;
    private IntArray x;
    private int t;
    public string FieldName { get; }
    public int FieldSize { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public F2mFieldElement(int m, int k1, int k2, int k3, BigInteger x);
    public F2mFieldElement(int m, int k, BigInteger x);
    private F2mFieldElement(int m, int k1, int k2, int k3, IntArray x);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(ECFieldElement a, ECFieldElement b);
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public int get_Representation();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual bool Equals(object obj);
    protected bool Equals(F2mFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.F2mPoint : ECPointBase {
    protected internal bool YTilde { get; }
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    [ObsoleteAttribute("Use ECCurve.Infinity property")]
public F2mPoint(ECCurve curve);
    protected internal virtual bool get_YTilde();
    private static void CheckPoints(ECPoint a, ECPoint b);
    public virtual ECPoint Add(ECPoint b);
    internal F2mPoint AddSimple(F2mPoint b);
    public virtual ECPoint Subtract(ECPoint b);
    internal F2mPoint SubtractSimple(F2mPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint Negate();
}
public class Org.BouncyCastle.Math.EC.FpCurve : ECCurveBase {
    private BigInteger q;
    private FpPoint infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public FpCurve(BigInteger q, BigInteger a, BigInteger b);
    public BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    public virtual ECPoint CreatePoint(BigInteger X1, BigInteger Y1, bool withCompression);
    protected internal virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual bool Equals(object obj);
    protected bool Equals(FpCurve other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpFieldElement : ECFieldElement {
    private BigInteger q;
    private BigInteger x;
    public string FieldName { get; }
    public int FieldSize { get; }
    public BigInteger Q { get; }
    public FpFieldElement(BigInteger q, BigInteger x);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public BigInteger get_Q();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    private static BigInteger[] fastLucasSequence(BigInteger p, BigInteger P, BigInteger Q, BigInteger k);
    public virtual bool Equals(object obj);
    protected bool Equals(FpFieldElement other);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Math.EC.FpPoint : ECPointBase {
    protected internal bool YTilde { get; }
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual bool get_YTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint Subtract(ECPoint b);
    public virtual ECPoint Negate();
}
internal class Org.BouncyCastle.Math.EC.IntArray : object {
    private Int32[] m_ints;
    public int BitLength { get; }
    public int Length { get; }
    public IntArray(int intLen);
    private IntArray(Int32[] ints);
    public IntArray(BigInteger bigInt);
    public IntArray(BigInteger bigInt, int minIntLen);
    public int GetUsedLength();
    public int get_BitLength();
    private Int32[] resizedInts(int newLen);
    public BigInteger ToBigInteger();
    public void ShiftLeft();
    public IntArray ShiftLeft(int n);
    public void AddShifted(IntArray other, int shift);
    public int get_Length();
    public bool TestBit(int n);
    public void FlipBit(int n);
    public void SetBit(int n);
    public IntArray Multiply(IntArray other, int m);
    public void Reduce(int m, Int32[] redPol);
    public IntArray Square(int m);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual object Clone();
    public virtual string ToString();
}
internal interface Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier {
    public abstract virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.FpNafMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal interface Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo {
}
internal class Org.BouncyCastle.Math.EC.Multiplier.ReferenceMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WNafMultiplier : object {
    public SByte[] WindowNaf(sbyte width, BigInteger k);
    public sealed virtual ECPoint Multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo : object {
    private ECPoint[] preComp;
    private ECPoint twiceP;
    internal ECPoint[] GetPreComp();
    internal void SetPreComp(ECPoint[] preComp);
    internal ECPoint GetTwiceP();
    internal void SetTwiceP(ECPoint twiceThis);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier : object {
    public sealed virtual ECPoint Multiply(ECPoint point, BigInteger k, PreCompInfo preCompInfo);
    private F2mPoint MultiplyWTnaf(F2mPoint p, ZTauElement lambda, PreCompInfo preCompInfo, sbyte a, sbyte mu);
    private static F2mPoint MultiplyFromWTnaf(F2mPoint p, SByte[] u, PreCompInfo preCompInfo);
}
internal class Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo : object {
    private F2mPoint[] preComp;
    internal WTauNafPreCompInfo(F2mPoint[] preComp);
    internal F2mPoint[] GetPreComp();
}
public class Org.BouncyCastle.Ocsp.BasicOcspResp : X509ExtensionBase {
    private BasicOcspResponse resp;
    private ResponseData data;
    public int Version { get; }
    public RespID ResponderId { get; }
    public DateTime ProducedAt { get; }
    public SingleResp[] Responses { get; }
    public X509Extensions ResponseExtensions { get; }
    public string SignatureAlgName { get; }
    public string SignatureAlgOid { get; }
    public BasicOcspResp(BasicOcspResponse resp);
    public Byte[] GetTbsResponseData();
    public int get_Version();
    public RespID get_ResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] get_Responses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgName();
    public string get_SignatureAlgOid();
    [ObsoleteAttribute("RespData class is no longer required as all functionality is available on this class")]
public RespData GetResponseData();
    public Byte[] GetSignature();
    private ArrayList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.BasicOcspRespGenerator : object {
    private IList list;
    private X509Extensions responseExtensions;
    private RespID responderID;
    public IEnumerable SignatureAlgNames { get; }
    public BasicOcspRespGenerator(RespID responderID);
    public BasicOcspRespGenerator(AsymmetricKeyParameter publicKey);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime nextUpdate, X509Extensions singleExtensions);
    public void AddResponse(CertificateID certID, CertificateStatus certStatus, DateTime thisUpdate, DateTime nextUpdate, X509Extensions singleExtensions);
    public void SetResponseExtensions(X509Extensions responseExtensions);
    private BasicOcspResp GenerateResponse(string signatureName, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime thisUpdate);
    public BasicOcspResp Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, DateTime producedAt, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.CertificateID : object {
    public static string HashSha1;
    private CertID id;
    public string HashAlgOid { get; }
    public BigInteger SerialNumber { get; }
    public CertificateID(CertID id);
    public CertificateID(string hashAlgorithm, X509Certificate issuerCert, BigInteger number);
    public string get_HashAlgOid();
    public Byte[] GetIssuerNameHash();
    public Byte[] GetIssuerKeyHash();
    public BigInteger get_SerialNumber();
    public CertID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Org.BouncyCastle.Ocsp.CertificateStatus : object {
    public static CertificateStatus Good;
    private static CertificateStatus();
}
[ObsoleteAttribute("Use version with correct spelling 'OcspRespStatus'")]
public abstract class Org.BouncyCastle.Ocsp.OcscpRespStatus : OcspRespStatus {
}
public class Org.BouncyCastle.Ocsp.OcspException : Exception {
    public OcspException(string message);
    public OcspException(string message, Exception e);
}
public class Org.BouncyCastle.Ocsp.OcspReq : X509ExtensionBase {
    private OcspRequest req;
    public int Version { get; }
    public GeneralName RequestorName { get; }
    public X509Extensions RequestExtensions { get; }
    public string SignatureAlgOid { get; }
    public bool IsSigned { get; }
    public OcspReq(OcspRequest req);
    public OcspReq(Byte[] req);
    public OcspReq(Stream inStr);
    private OcspReq(Asn1InputStream aIn);
    public Byte[] GetTbsRequest();
    public int get_Version();
    public GeneralName get_RequestorName();
    public Req[] GetRequestList();
    public X509Extensions get_RequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
    public string get_SignatureAlgOid();
    public Byte[] GetSignature();
    private ArrayList GetCertList();
    public X509Certificate[] GetCerts();
    public IX509Store GetCertificates(string type);
    public bool get_IsSigned();
    public bool Verify(AsymmetricKeyParameter publicKey);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Ocsp.OcspReqGenerator : object {
    private IList list;
    private GeneralName requestorName;
    private X509Extensions requestExtensions;
    public IEnumerable SignatureAlgNames { get; }
    public void AddRequest(CertificateID certId);
    public void AddRequest(CertificateID certId, X509Extensions singleRequestExtensions);
    public void SetRequestorName(X509Name requestorName);
    public void SetRequestorName(GeneralName requestorName);
    public void SetRequestExtensions(X509Extensions requestExtensions);
    private OcspReq GenerateRequest(DerObjectIdentifier signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public OcspReq Generate();
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain);
    public OcspReq Generate(string signingAlgorithm, AsymmetricKeyParameter privateKey, X509Certificate[] chain, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.Ocsp.OcspResp : object {
    private OcspResponse resp;
    public int Status { get; }
    public OcspResp(OcspResponse resp);
    public OcspResp(Byte[] resp);
    public OcspResp(Stream inStr);
    private OcspResp(Asn1InputStream aIn);
    public int get_Status();
    public object GetResponseObject();
    public Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.OCSPRespGenerator : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
    public OcspResp Generate(int status, object response);
}
public abstract class Org.BouncyCastle.Ocsp.OcspRespStatus : object {
    public static int Successful;
    public static int MalformedRequest;
    public static int InternalError;
    public static int TryLater;
    public static int SigRequired;
    public static int Unauthorized;
}
internal class Org.BouncyCastle.Ocsp.OcspUtilities : object {
    private static Hashtable algorithms;
    private static Hashtable oids;
    private static ISet noParams;
    internal static IEnumerable AlgNames { get; }
    private static OcspUtilities();
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static string GetAlgorithmName(DerObjectIdentifier oid);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid);
    internal static IEnumerable get_AlgNames();
}
public class Org.BouncyCastle.Ocsp.Req : X509ExtensionBase {
    private Request req;
    public X509Extensions SingleRequestExtensions { get; }
    public Req(Request req);
    public CertificateID GetCertID();
    public X509Extensions get_SingleRequestExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespData : X509ExtensionBase {
    internal ResponseData data;
    public int Version { get; }
    public DateTime ProducedAt { get; }
    public X509Extensions ResponseExtensions { get; }
    public RespData(ResponseData data);
    public int get_Version();
    public RespID GetResponderId();
    public DateTime get_ProducedAt();
    public SingleResp[] GetResponses();
    public X509Extensions get_ResponseExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.RespID : object {
    internal ResponderID id;
    public RespID(ResponderID id);
    public RespID(X509Name name);
    public RespID(AsymmetricKeyParameter publicKey);
    public ResponderID ToAsn1Object();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Ocsp.RevokedStatus : CertificateStatus {
    internal RevokedInfo info;
    public DateTime RevocationTime { get; }
    public bool HasRevocationReason { get; }
    public int RevocationReason { get; }
    public RevokedStatus(RevokedInfo info);
    public RevokedStatus(DateTime revocationDate, int reason);
    public DateTime get_RevocationTime();
    public bool get_HasRevocationReason();
    public int get_RevocationReason();
}
public class Org.BouncyCastle.Ocsp.SingleResp : X509ExtensionBase {
    internal SingleResponse resp;
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public X509Extensions SingleExtensions { get; }
    public SingleResp(SingleResponse resp);
    public CertificateID GetCertID();
    public object GetCertStatus();
    public DateTime get_ThisUpdate();
    public DateTimeObject get_NextUpdate();
    public X509Extensions get_SingleExtensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Ocsp.UnknownStatus : CertificateStatus {
}
public interface Org.BouncyCastle.OpenSsl.IPasswordFinder {
    public abstract virtual Char[] GetPassword();
}
public class Org.BouncyCastle.OpenSsl.PemException : IOException {
    public PemException(string message);
    public PemException(string message, Exception exception);
}
public class Org.BouncyCastle.OpenSsl.PemReader : object {
    private static string BeginString;
    private TextReader reader;
    private IPasswordFinder pFinder;
    public TextReader Reader { get; }
    public PemReader(TextReader reader);
    public PemReader(TextReader reader, IPasswordFinder pFinder);
    public TextReader get_Reader();
    public object ReadObject();
    private Byte[] ReadBytes(string endMarker);
    private Byte[] ReadBytesAndFields(string endMarker, IDictionary fields);
    private AsymmetricKeyParameter ReadRsaPublicKey(string endMarker);
    private AsymmetricKeyParameter ReadPublicKey(string endMarker);
    private X509Certificate ReadCertificate(string endMarker);
    private X509Crl ReadCrl(string endMarker);
    private Pkcs10CertificationRequest ReadCertificateRequest(string endMarker);
    private IX509AttributeCertificate ReadAttributeCertificate(string endMarker);
    private ContentInfo ReadPkcs7(string endMarker);
    private AsymmetricCipherKeyPair ReadKeyPair(string type, string endMarker);
    private X9ECParameters ReadECParameters(string endMarker);
    private static X9ECParameters GetCurveParameters(string name);
    private AsymmetricCipherKeyPair ReadECPrivateKey(string endMarker);
}
internal class Org.BouncyCastle.OpenSsl.PemUtilities : object {
    internal static bool ParseDekAlgName(string dekAlgName, String& baseAlg, String& mode);
    internal static Byte[] Crypt(bool encrypt, Byte[] bytes, Char[] password, string dekAlgName, Byte[] iv);
    private static ICipherParameters GetCipherParameters(Char[] password, string baseAlg, Byte[] salt);
}
public class Org.BouncyCastle.OpenSsl.PemWriter : object {
    private static int LineLength;
    private TextWriter writer;
    public TextWriter Writer { get; }
    public PemWriter(TextWriter writer);
    public TextWriter get_Writer();
    public void WriteObject(object obj);
    public void WriteObject(object obj, string algorithm, Char[] password, SecureRandom random);
    private Byte[] EncodePrivateKey(AsymmetricKeyParameter akp, String& keyType);
    private void WritePemBlock(string type, Byte[] data, String[] fields);
    private void WriteHeader(string type);
    private void WriteFooter(string type);
    private void WriteBytes(Byte[] bytes);
}
public class Org.BouncyCastle.Pkcs.AsymmetricKeyEntry : Pkcs12Entry {
    private AsymmetricKeyParameter key;
    public AsymmetricKeyParameter Key { get; }
    public AsymmetricKeyEntry(AsymmetricKeyParameter key);
    public AsymmetricKeyEntry(AsymmetricKeyParameter key, Hashtable attributes);
    public AsymmetricKeyParameter get_Key();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkcs.EncryptedPrivateKeyInfoFactory : object {
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(DerObjectIdentifier algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, AsymmetricKeyParameter key);
    public static EncryptedPrivateKeyInfo CreateEncryptedPrivateKeyInfo(string algorithm, Char[] passPhrase, Byte[] salt, int iterationCount, PrivateKeyInfo keyInfo);
}
public class Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest : CertificationRequest {
    private static Hashtable algorithms;
    private static Hashtable exParams;
    private static Hashtable keyAlgorithms;
    private static Hashtable oids;
    private static ISet noParams;
    private static Pkcs10CertificationRequest();
    public Pkcs10CertificationRequest(Byte[] encoded);
    public Pkcs10CertificationRequest(Asn1Sequence seq);
    public Pkcs10CertificationRequest(Stream input);
    public Pkcs10CertificationRequest(string signatureAlgorithm, X509Name subject, AsymmetricKeyParameter publicKey, Asn1Set attributes, AsymmetricKeyParameter signingKey);
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    public AsymmetricKeyParameter GetPublicKey();
    public bool Verify();
    public bool Verify(AsymmetricKeyParameter publicKey);
    private void SetSignatureParameters(ISigner signature, Asn1Encodable asn1Params);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
[DefaultMemberAttribute("Item")]
public abstract class Org.BouncyCastle.Pkcs.Pkcs12Entry : object {
    private Hashtable attributes;
    public Asn1Encodable Item { get; }
    public Asn1Encodable Item { get; }
    public IEnumerable BagAttributeKeys { get; }
    protected internal Pkcs12Entry(Hashtable attributes);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(DerObjectIdentifier oid);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetBagAttribute(string oid);
    [ObsoleteAttribute("Use 'BagAttributeKeys' property")]
public IEnumerator GetBagAttributeKeys();
    public Asn1Encodable get_Item(DerObjectIdentifier oid);
    public Asn1Encodable get_Item(string oid);
    public IEnumerable get_BagAttributeKeys();
}
public class Org.BouncyCastle.Pkcs.Pkcs12Store : object {
    private static int MinIterations;
    private static int SaltSize;
    private IgnoresCaseHashtable keys;
    private Hashtable localIds;
    private IgnoresCaseHashtable certs;
    private Hashtable chainCerts;
    private Hashtable keyCerts;
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    public IEnumerable Aliases { get; }
    public int Count { get; }
    internal Pkcs12Store(DerObjectIdentifier keyAlgorithm, DerObjectIdentifier certAlgorithm);
    public Pkcs12Store(Stream input, Char[] password);
    private static SubjectKeyIdentifier CreateSubjectKeyID(AsymmetricKeyParameter pubKey);
    public void Load(Stream input, Char[] password);
    public AsymmetricKeyEntry GetKey(string alias);
    public bool IsCertificateEntry(string alias);
    public bool IsKeyEntry(string alias);
    private Hashtable GetAliasesTable();
    public IEnumerable get_Aliases();
    public bool ContainsAlias(string alias);
    public X509CertificateEntry GetCertificate(string alias);
    public string GetCertificateAlias(X509Certificate cert);
    public X509CertificateEntry[] GetCertificateChain(string alias);
    public void SetCertificateEntry(string alias, X509CertificateEntry certEntry);
    public void SetKeyEntry(string alias, AsymmetricKeyEntry keyEntry, X509CertificateEntry[] chain);
    public void DeleteEntry(string alias);
    public bool IsEntryOfType(string alias, Type entryType);
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size();
    public int get_Count();
    public void Save(Stream stream, Char[] password, SecureRandom random);
    private static Byte[] CalculatePbeMac(DerObjectIdentifier oid, Byte[] salt, int itCount, Char[] password, bool wrongPkcs12Zero, Byte[] data);
    private static Byte[] CryptPbeData(bool forEncryption, AlgorithmIdentifier algId, Char[] password, bool wrongPkcs12Zero, Byte[] data);
}
public class Org.BouncyCastle.Pkcs.Pkcs12StoreBuilder : object {
    private DerObjectIdentifier keyAlgorithm;
    private DerObjectIdentifier certAlgorithm;
    public Pkcs12Store Build();
    public Pkcs12StoreBuilder SetCertAlgorithm(DerObjectIdentifier certAlgorithm);
    public Pkcs12StoreBuilder SetKeyAlgorithm(DerObjectIdentifier keyAlgorithm);
}
public class Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory : object {
    public static PrivateKeyInfo CreatePrivateKeyInfo(AsymmetricKeyParameter key);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static PrivateKeyInfo CreatePrivateKeyInfo(Char[] passPhrase, bool wrongPkcs12Zero, EncryptedPrivateKeyInfo encInfo);
}
public class Org.BouncyCastle.Pkcs.X509CertificateEntry : Pkcs12Entry {
    private X509Certificate cert;
    public X509Certificate Certificate { get; }
    public X509CertificateEntry(X509Certificate cert);
    public X509CertificateEntry(X509Certificate cert, Hashtable attributes);
    public X509Certificate get_Certificate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.Pkix.CertStatus : object {
    public static int Unrevoked;
    public static int Undetermined;
    private int status;
    private DateTimeObject revocationDate;
    public DateTimeObject RevocationDate { get; public set; }
    public int Status { get; public set; }
    public DateTimeObject get_RevocationDate();
    public void set_RevocationDate(DateTimeObject value);
    public int get_Status();
    public void set_Status(int value);
}
public abstract class Org.BouncyCastle.Pkix.PkixAttrCertChecker : object {
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, ICollection unresolvedCritExts);
    public abstract virtual PkixAttrCertChecker Clone();
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    private PkixCertPathBuilderResult Build(IX509AttributeCertificate attrCert, X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixAttrCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters pkixParams);
}
public class Org.BouncyCastle.Pkix.PkixBuilderParameters : PkixParameters {
    private int maxPathLength;
    private ISet excludedCerts;
    public int MaxPathLength { get; public set; }
    public PkixBuilderParameters(ISet trustAnchors, IX509Selector targetConstraints);
    public static PkixBuilderParameters GetInstance(PkixParameters pkixParams);
    public virtual int get_MaxPathLength();
    public virtual void set_MaxPathLength(int value);
    public virtual ISet GetExcludedCerts();
    public virtual void SetExcludedCerts(ISet excludedCerts);
    protected virtual void SetParams(PkixParameters parameters);
    public virtual object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPath : object {
    internal static IList certPathEncodings;
    private IList certificates;
    public IEnumerable Encodings { get; }
    public IList Certificates { get; }
    private static PkixCertPath();
    public PkixCertPath(ICollection certificates);
    public PkixCertPath(Stream inStream);
    public PkixCertPath(Stream inStream, string encoding);
    private static IList SortCerts(IList certs);
    public virtual IEnumerable get_Encodings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Byte[] GetEncoded();
    public virtual Byte[] GetEncoded(string encoding);
    public virtual IList get_Certificates();
    private Asn1Object ToAsn1Object(X509Certificate cert);
    private Byte[] ToDerEncoded(Asn1Encodable obj);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilder : object {
    private Exception certPathException;
    public virtual PkixCertPathBuilderResult Build(PkixBuilderParameters pkixParams);
    protected virtual PkixCertPathBuilderResult Build(X509Certificate tbvCert, PkixBuilderParameters pkixParams, IList tbvPath);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderException : GeneralSecurityException {
    public PkixCertPathBuilderException(string message);
    public PkixCertPathBuilderException(string message, Exception exception);
}
public class Org.BouncyCastle.Pkix.PkixCertPathBuilderResult : PkixCertPathValidatorResult {
    private PkixCertPath certPath;
    public PkixCertPath CertPath { get; }
    public PkixCertPathBuilderResult(PkixCertPath certPath, TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixCertPath get_CertPath();
    public virtual string ToString();
}
public abstract class Org.BouncyCastle.Pkix.PkixCertPathChecker : object {
    public abstract virtual void Init(bool forward);
    public abstract virtual bool IsForwardCheckingSupported();
    public abstract virtual ISet GetSupportedExtensions();
    public abstract virtual void Check(X509Certificate cert, ICollection unresolvedCritExts);
    public virtual object Clone();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidator : object {
    public virtual PkixCertPathValidatorResult Validate(PkixCertPath certPath, PkixParameters paramsPkix);
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorException : GeneralSecurityException {
    private Exception cause;
    private PkixCertPath certPath;
    private int index;
    public string Message { get; }
    public PkixCertPath CertPath { get; }
    public int Index { get; }
    public PkixCertPathValidatorException(string message);
    public PkixCertPathValidatorException(string message, Exception cause);
    public PkixCertPathValidatorException(string message, Exception cause, PkixCertPath certPath, int index);
    public virtual string get_Message();
    public PkixCertPath get_CertPath();
    public int get_Index();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorResult : object {
    private TrustAnchor trustAnchor;
    private PkixPolicyNode policyTree;
    private AsymmetricKeyParameter subjectPublicKey;
    public PkixPolicyNode PolicyTree { get; }
    public TrustAnchor TrustAnchor { get; }
    public AsymmetricKeyParameter SubjectPublicKey { get; }
    public PkixCertPathValidatorResult(TrustAnchor trustAnchor, PkixPolicyNode policyTree, AsymmetricKeyParameter subjectPublicKey);
    public PkixPolicyNode get_PolicyTree();
    public TrustAnchor get_TrustAnchor();
    public AsymmetricKeyParameter get_SubjectPublicKey();
    public object Clone();
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities : object {
    internal static string ANY_POLICY;
    internal static string CRL_NUMBER;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] crlReasons;
    private static PkixCertPathValidatorUtilities();
    internal static TrustAnchor FindTrustAnchor(X509Certificate cert, ISet trustAnchors);
    internal static void AddAdditionalStoresFromAltNames(X509Certificate cert, PkixParameters pkixParams);
    internal static DateTime GetValidDate(PkixParameters paramsPKIX);
    internal static X509Name GetIssuerPrincipal(object cert);
    internal static bool IsSelfIssued(X509Certificate cert);
    internal static AlgorithmIdentifier GetAlgorithmIdentifier(AsymmetricKeyParameter key);
    internal static ICollection FindCrls(X509CrlStoreSelector crlSelect, IList crlStores);
    internal static bool IsAnyPolicy(ISet policySet);
    internal static void AddAdditionalStoreFromLocation(string location, PkixParameters pkixParams);
    private static BigInteger GetSerialNumber(object cert);
    internal static ISet GetQualifierSet(Asn1Sequence qualifiers);
    internal static PkixPolicyNode RemovePolicyNode(PkixPolicyNode validPolicyTree, IList[] policyNodes, PkixPolicyNode _node);
    private static void RemovePolicyNodeRecurse(IList[] policyNodes, PkixPolicyNode _node);
    internal static void PrepareNextCertB1(int i, IList[] policyNodes, string id_p, IDictionary m_idp, X509Certificate cert);
    internal static PkixPolicyNode PrepareNextCertB2(int i, IList[] policyNodes, string id_p, PkixPolicyNode validPolicyTree);
    internal static void GetCertStatus(DateTime validDate, X509Crl crl, object cert, CertStatus certStatus);
    internal static AsymmetricKeyParameter GetNextWorkingKey(IList certs, int index);
    internal static DateTime GetValidCertDateFromValidityModel(PkixParameters paramsPkix, PkixCertPath certPath, int index);
    internal static ICollection FindCertificates(X509CertStoreSelector certSelect, IList certStores);
    internal static void GetCrlIssuersFromDistributionPoint(DistributionPoint dp, ICollection issuerPrincipals, X509CrlStoreSelector selector, PkixParameters pkixParams);
    internal static ISet GetCompleteCrls(DistributionPoint dp, object cert, DateTime currentDate, PkixParameters paramsPKIX);
    internal static ISet GetDeltaCrls(DateTime currentDate, PkixParameters paramsPKIX, X509Crl completeCRL);
    private static bool isDeltaCrl(X509Crl crl);
    internal static ICollection FindCertificates(X509AttrCertStoreSelector certSelect, IList certStores);
    internal static void AddAdditionalStoresFromCrlDistributionPoint(CrlDistPoint crldp, PkixParameters pkixParams);
    internal static bool ProcessCertD1i(int index, IList[] policyNodes, DerObjectIdentifier pOid, ISet pq);
    internal static void ProcessCertD1ii(int index, IList[] policyNodes, DerObjectIdentifier _poid, ISet _pq);
    internal static ICollection FindIssuerCerts(X509Certificate cert, PkixBuilderParameters pkixParams);
    internal static Asn1Object GetExtensionValue(IX509Extension ext, DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidator : object {
    private ISet excludedSubtreesDN;
    private ISet excludedSubtreesDNS;
    private ISet excludedSubtreesEmail;
    private ISet excludedSubtreesURI;
    private ISet excludedSubtreesIP;
    private ISet permittedSubtreesDN;
    private ISet permittedSubtreesDNS;
    private ISet permittedSubtreesEmail;
    private ISet permittedSubtreesURI;
    private ISet permittedSubtreesIP;
    private static bool WithinDNSubtree(Asn1Sequence dns, Asn1Sequence subtree);
    public void CheckPermittedDN(Asn1Sequence dns);
    public void CheckExcludedDN(Asn1Sequence dns);
    private void CheckPermittedDN(ISet permitted, Asn1Sequence dns);
    private void CheckExcludedDN(ISet excluded, Asn1Sequence dns);
    private ISet IntersectDN(ISet permitted, ISet dns);
    private ISet UnionDN(ISet excluded, Asn1Sequence dn);
    private ISet IntersectEmail(ISet permitted, ISet emails);
    private ISet UnionEmail(ISet excluded, string email);
    private ISet IntersectIP(ISet permitted, ISet ips);
    private ISet UnionIP(ISet excluded, Byte[] ip);
    private ISet UnionIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private ISet IntersectIPRange(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[] IpWithSubnetMask(Byte[] ip, Byte[] subnetMask);
    private Byte[][] ExtractIPsAndSubnetMasks(Byte[] ipWithSubmask1, Byte[] ipWithSubmask2);
    private Byte[][] MinMaxIPs(Byte[] ip1, Byte[] subnetmask1, Byte[] ip2, Byte[] subnetmask2);
    private void CheckPermittedEmail(ISet permitted, string email);
    private void CheckExcludedEmail(ISet excluded, string email);
    private void CheckPermittedIP(ISet permitted, Byte[] ip);
    private void checkExcludedIP(ISet excluded, Byte[] ip);
    private bool IsIPConstrained(Byte[] ip, Byte[] constraint);
    private bool EmailIsConstrained(string email, string constraint);
    private bool WithinDomain(string testDomain, string domain);
    private void CheckPermittedDNS(ISet permitted, string dns);
    private void checkExcludedDNS(ISet excluded, string dns);
    private void unionEmail(string email1, string email2, ISet union);
    private void unionURI(string email1, string email2, ISet union);
    private ISet intersectDNS(ISet permitted, ISet dnss);
    protected ISet unionDNS(ISet excluded, string dns);
    private void intersectEmail(string email1, string email2, ISet intersect);
    private void checkExcludedURI(ISet excluded, string uri);
    private ISet intersectURI(ISet permitted, ISet uris);
    private ISet unionURI(ISet excluded, string uri);
    private void intersectURI(string email1, string email2, ISet intersect);
    private void CheckPermittedURI(ISet permitted, string uri);
    private bool IsUriConstrained(string uri, string constraint);
    private static string ExtractHostFromURL(string url);
    public void checkPermitted(GeneralName name);
    public void checkExcluded(GeneralName name);
    public void IntersectPermittedSubtree(Asn1Sequence permitted);
    private string ExtractNameAsString(GeneralName name);
    public void IntersectEmptyPermittedSubtree(int nameType);
    public void AddExcludedSubtree(GeneralSubtree subtree);
    private static Byte[] Max(Byte[] ip1, Byte[] ip2);
    private static Byte[] Min(Byte[] ip1, Byte[] ip2);
    private static int CompareTo(Byte[] ip1, Byte[] ip2);
    private static Byte[] Or(Byte[] ip1, Byte[] ip2);
    public int HashCode();
    private int HashCollection(ICollection coll);
    public bool Equals(object o);
    private bool CollectionsAreEqual(ICollection coll1, ICollection coll2);
    private bool Equals(object o1, object o2);
    private string StringifyIP(Byte[] ip);
    private string StringifyIPCollection(ISet ips);
    public virtual string ToString();
}
public class Org.BouncyCastle.Pkix.PkixNameConstraintValidatorException : Exception {
    public PkixNameConstraintValidatorException(string msg);
}
public class Org.BouncyCastle.Pkix.PkixParameters : object {
    public static int PkixValidityModel;
    public static int ChainValidityModel;
    private ISet trustAnchors;
    private DateTimeObject date;
    private IList certPathCheckers;
    private bool revocationEnabled;
    private ISet initialPolicies;
    private bool explicitPolicyRequired;
    private bool anyPolicyInhibited;
    private bool policyMappingInhibited;
    private bool policyQualifiersRejected;
    private IX509Selector certSelector;
    private IList stores;
    private IX509Selector selector;
    private bool additionalLocationsEnabled;
    private IList additionalStores;
    private ISet trustedACIssuers;
    private ISet necessaryACAttributes;
    private ISet prohibitedACAttributes;
    private ISet attrCertCheckers;
    private int validityModel;
    private bool useDeltas;
    public bool IsRevocationEnabled { get; public set; }
    public bool IsExplicitPolicyRequired { get; public set; }
    public bool IsAnyPolicyInhibited { get; public set; }
    public bool IsPolicyMappingInhibited { get; public set; }
    public bool IsPolicyQualifiersRejected { get; public set; }
    public DateTimeObject Date { get; public set; }
    public bool IsUseDeltasEnabled { get; public set; }
    public int ValidityModel { get; public set; }
    public bool IsAdditionalLocationsEnabled { get; }
    public PkixParameters(ISet trustAnchors);
    public virtual bool get_IsRevocationEnabled();
    public virtual void set_IsRevocationEnabled(bool value);
    public virtual bool get_IsExplicitPolicyRequired();
    public virtual void set_IsExplicitPolicyRequired(bool value);
    public virtual bool get_IsAnyPolicyInhibited();
    public virtual void set_IsAnyPolicyInhibited(bool value);
    public virtual bool get_IsPolicyMappingInhibited();
    public virtual void set_IsPolicyMappingInhibited(bool value);
    public virtual bool get_IsPolicyQualifiersRejected();
    public virtual void set_IsPolicyQualifiersRejected(bool value);
    public virtual DateTimeObject get_Date();
    public virtual void set_Date(DateTimeObject value);
    public virtual ISet GetTrustAnchors();
    public virtual void SetTrustAnchors(ISet tas);
    public virtual X509CertStoreSelector GetTargetCertConstraints();
    public virtual void SetTargetCertConstraints(IX509Selector selector);
    public virtual ISet GetInitialPolicies();
    public virtual void SetInitialPolicies(ISet initialPolicies);
    public virtual void SetCertPathCheckers(IList checkers);
    public virtual IList GetCertPathCheckers();
    public virtual void AddCertPathChecker(PkixCertPathChecker checker);
    public virtual object Clone();
    protected virtual void SetParams(PkixParameters parameters);
    public virtual bool get_IsUseDeltasEnabled();
    public virtual void set_IsUseDeltasEnabled(bool value);
    public virtual int get_ValidityModel();
    public virtual void set_ValidityModel(int value);
    public virtual void SetStores(IList stores);
    public virtual void AddStore(IX509Store store);
    public virtual void AddAdditionalStore(IX509Store store);
    public virtual IList GetAdditionalStores();
    public virtual IList GetStores();
    public virtual bool get_IsAdditionalLocationsEnabled();
    public virtual void SetAdditionalLocationsEnabled(bool enabled);
    public virtual IX509Selector GetTargetConstraints();
    public virtual void SetTargetConstraints(IX509Selector selector);
    public virtual ISet GetTrustedACIssuers();
    public virtual void SetTrustedACIssuers(ISet trustedACIssuers);
    public virtual ISet GetNecessaryACAttributes();
    public virtual void SetNecessaryACAttributes(ISet necessaryACAttributes);
    public virtual ISet GetProhibitedACAttributes();
    public virtual void SetProhibitedACAttributes(ISet prohibitedACAttributes);
    public virtual ISet GetAttrCertCheckers();
    public virtual void SetAttrCertCheckers(ISet attrCertCheckers);
}
public class Org.BouncyCastle.Pkix.PkixPolicyNode : object {
    protected IList mChildren;
    protected int mDepth;
    protected ISet mExpectedPolicies;
    protected PkixPolicyNode mParent;
    protected ISet mPolicyQualifiers;
    protected string mValidPolicy;
    protected bool mCritical;
    public int Depth { get; }
    public IEnumerable Children { get; }
    public bool IsCritical { get; public set; }
    public ISet PolicyQualifiers { get; }
    public string ValidPolicy { get; }
    public bool HasChildren { get; }
    public ISet ExpectedPolicies { get; public set; }
    public PkixPolicyNode Parent { get; public set; }
    public PkixPolicyNode(IList children, int depth, ISet expectedPolicies, PkixPolicyNode parent, ISet policyQualifiers, string validPolicy, bool critical);
    public virtual int get_Depth();
    public virtual IEnumerable get_Children();
    public virtual bool get_IsCritical();
    public virtual void set_IsCritical(bool value);
    public virtual ISet get_PolicyQualifiers();
    public virtual string get_ValidPolicy();
    public virtual bool get_HasChildren();
    public virtual ISet get_ExpectedPolicies();
    public virtual void set_ExpectedPolicies(ISet value);
    public virtual PkixPolicyNode get_Parent();
    public virtual void set_Parent(PkixPolicyNode value);
    public virtual void AddChild(PkixPolicyNode child);
    public virtual void RemoveChild(PkixPolicyNode child);
    public virtual string ToString();
    public virtual string ToString(string indent);
    public virtual object Clone();
    public virtual PkixPolicyNode Copy();
}
internal class Org.BouncyCastle.Pkix.ReasonsMask : object {
    private int _reasons;
    internal static ReasonsMask AllReasons;
    internal bool IsAllReasons { get; }
    public ReasonFlags Reasons { get; }
    internal ReasonsMask(int reasons);
    private static ReasonsMask();
    internal void AddReasons(ReasonsMask mask);
    internal bool get_IsAllReasons();
    internal ReasonsMask Intersect(ReasonsMask mask);
    internal bool HasNewReasons(ReasonsMask mask);
    public ReasonFlags get_Reasons();
}
public class Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities : object {
    internal static string ANY_POLICY;
    internal static int KEY_CERT_SIGN;
    internal static int CRL_SIGN;
    internal static String[] CrlReasons;
    private static Rfc3280CertPathUtilities();
    internal static void ProcessCrlB2(DistributionPoint dp, object cert, X509Crl crl);
    internal static void ProcessCertBC(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static void PrepareNextCertA(PkixCertPath certPath, int index);
    internal static PkixPolicyNode ProcessCertD(PkixCertPath certPath, int index, ISet acceptablePolicies, PkixPolicyNode validPolicyTree, IList[] policyNodes, int inhibitAnyPolicy);
    internal static void ProcessCrlB1(DistributionPoint dp, object cert, X509Crl crl);
    internal static ReasonsMask ProcessCrlD(X509Crl crl, DistributionPoint dp);
    internal static ISet ProcessCrlF(X509Crl crl, object cert, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, PkixParameters paramsPKIX, IList certPathCerts);
    internal static AsymmetricKeyParameter ProcessCrlG(X509Crl crl, ISet keys);
    internal static X509Crl ProcessCrlH(ISet deltaCrls, AsymmetricKeyParameter key);
    private static void CheckCrl(DistributionPoint dp, PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate defaultCRLSignCert, AsymmetricKeyParameter defaultCRLSignKey, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
    protected static void CheckCrls(PkixParameters paramsPKIX, X509Certificate cert, DateTime validDate, X509Certificate sign, AsymmetricKeyParameter workingPublicKey, IList certPathCerts);
    internal static PkixPolicyNode PrepareCertB(PkixCertPath certPath, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, int policyMapping);
    internal static ISet[] ProcessCrlA1ii(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static ISet ProcessCrlA1i(DateTime currentDate, PkixParameters paramsPKIX, X509Certificate cert, X509Crl crl);
    internal static void ProcessCertF(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree, int explicitPolicy);
    internal static void ProcessCertA(PkixCertPath certPath, PkixParameters paramsPKIX, int index, AsymmetricKeyParameter workingPublicKey, X509Name workingIssuerName, X509Certificate sign);
    internal static int PrepareNextCertI1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertI2(PkixCertPath certPath, int index, int policyMapping);
    internal static void PrepareNextCertG(PkixCertPath certPath, int index, PkixNameConstraintValidator nameConstraintValidator);
    internal static int PrepareNextCertJ(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static void PrepareNextCertK(PkixCertPath certPath, int index);
    internal static int PrepareNextCertL(PkixCertPath certPath, int index, int maxPathLength);
    internal static int PrepareNextCertM(PkixCertPath certPath, int index, int maxPathLength);
    internal static void PrepareNextCertN(PkixCertPath certPath, int index);
    internal static void PrepareNextCertO(PkixCertPath certPath, int index, ISet criticalExtensions, IList pathCheckers);
    internal static int PrepareNextCertH1(PkixCertPath certPath, int index, int explicitPolicy);
    internal static int PrepareNextCertH2(PkixCertPath certPath, int index, int policyMapping);
    internal static int PrepareNextCertH3(PkixCertPath certPath, int index, int inhibitAnyPolicy);
    internal static int WrapupCertA(int explicitPolicy, X509Certificate cert);
    internal static int WrapupCertB(PkixCertPath certPath, int index, int explicitPolicy);
    internal static void WrapupCertF(PkixCertPath certPath, int index, IList pathCheckers, ISet criticalExtensions);
    internal static PkixPolicyNode WrapupCertG(PkixCertPath certPath, PkixParameters paramsPKIX, ISet userInitialPolicySet, int index, IList[] policyNodes, PkixPolicyNode validPolicyTree, ISet acceptablePolicies);
    internal static void ProcessCrlC(X509Crl deltaCRL, X509Crl completeCRL, PkixParameters pkixParams);
    internal static void ProcessCrlI(DateTime validDate, X509Crl deltacrl, object cert, CertStatus certStatus, PkixParameters pkixParams);
    internal static void ProcessCrlJ(DateTime validDate, X509Crl completecrl, object cert, CertStatus certStatus);
    internal static PkixPolicyNode ProcessCertE(PkixCertPath certPath, int index, PkixPolicyNode validPolicyTree);
}
internal class Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities : object {
    internal static void ProcessAttrCert7(IX509AttributeCertificate attrCert, PkixCertPath certPath, PkixCertPath holderCertPath, PkixParameters pkixParams);
    internal static void CheckCrls(IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, X509Certificate issuerCert, DateTime validDate, IList certPathCerts);
    internal static void AdditionalChecks(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert5(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert4(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static void ProcessAttrCert3(X509Certificate acIssuerCert, PkixParameters pkixParams);
    internal static PkixCertPathValidatorResult ProcessAttrCert2(PkixCertPath certPath, PkixParameters pkixParams);
    internal static PkixCertPath ProcessAttrCert1(IX509AttributeCertificate attrCert, PkixParameters pkixParams);
    private static void CheckCrl(DistributionPoint dp, IX509AttributeCertificate attrCert, PkixParameters paramsPKIX, DateTime validDate, X509Certificate issuerCert, CertStatus certStatus, ReasonsMask reasonMask, IList certPathCerts);
}
public class Org.BouncyCastle.Pkix.TrustAnchor : object {
    private AsymmetricKeyParameter pubKey;
    private string caName;
    private X509Name caPrincipal;
    private X509Certificate trustedCert;
    private Byte[] ncBytes;
    private NameConstraints nc;
    public X509Certificate TrustedCert { get; }
    public X509Name CA { get; }
    public string CAName { get; }
    public AsymmetricKeyParameter CAPublicKey { get; }
    public Byte[] GetNameConstraints { get; }
    public TrustAnchor(X509Certificate trustedCert, Byte[] nameConstraints);
    public TrustAnchor(X509Name caPrincipal, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public TrustAnchor(string caName, AsymmetricKeyParameter pubKey, Byte[] nameConstraints);
    public X509Certificate get_TrustedCert();
    public X509Name get_CA();
    public string get_CAName();
    public AsymmetricKeyParameter get_CAPublicKey();
    private void setNameConstraints(Byte[] bytes);
    public Byte[] get_GetNameConstraints();
    public virtual string ToString();
}
public class Org.BouncyCastle.Security.AgreementUtilities : object {
    private static Hashtable algorithms;
    private static AgreementUtilities();
    public static IBasicAgreement GetBasicAgreement(DerObjectIdentifier oid);
    public static IBasicAgreement GetBasicAgreement(string algorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(DerObjectIdentifier oid, string wrapAlgorithm);
    public static IBasicAgreement GetBasicAgreementWithKdf(string agreeAlgorithm, string wrapAlgorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Security.Certificates.CertificateEncodingException : CertificateException {
    public CertificateEncodingException(string msg);
    public CertificateEncodingException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.Certificates.CertificateException : GeneralSecurityException {
    public CertificateException(string message);
    public CertificateException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateExpiredException : CertificateException {
    public CertificateExpiredException(string message);
    public CertificateExpiredException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException : CertificateException {
    public CertificateNotYetValidException(string message);
    public CertificateNotYetValidException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CertificateParsingException : CertificateException {
    public CertificateParsingException(string message);
    public CertificateParsingException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.Certificates.CrlException : GeneralSecurityException {
    public CrlException(string msg);
    public CrlException(string msg, Exception e);
}
public class Org.BouncyCastle.Security.CipherUtilities : object {
    private static Hashtable algorithms;
    private static Hashtable oids;
    public static ICollection Algorithms { get; }
    private static CipherUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IBufferedCipher GetCipher(DerObjectIdentifier oid);
    public static IBufferedCipher GetCipher(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    private static int GetDigitIndex(string s);
}
public class Org.BouncyCastle.Security.DigestUtilities : object {
    private static Hashtable algorithms;
    private static Hashtable oids;
    public static ICollection Algorithms { get; }
    private static DigestUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static IDigest GetDigest(DerObjectIdentifier id);
    public static IDigest GetDigest(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] DoFinal(IDigest digest);
}
public class Org.BouncyCastle.Security.DotNetUtilities : object {
    public static X509Certificate ToX509Certificate(X509CertificateStructure x509Struct);
    public static X509Certificate ToX509Certificate(X509Certificate x509Cert);
    public static X509Certificate FromX509Certificate(X509Certificate x509Cert);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSACryptoServiceProvider dsaCsp);
    public static AsymmetricCipherKeyPair GetDsaKeyPair(DSAParameters dp);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSACryptoServiceProvider dsaCsp);
    public static DsaPublicKeyParameters GetDsaPublicKey(DSAParameters dp);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSACryptoServiceProvider rsaCsp);
    public static AsymmetricCipherKeyPair GetRsaKeyPair(RSAParameters rp);
    public static RsaKeyParameters GetRsaPublicKey(RSACryptoServiceProvider rsaCsp);
    public static RsaKeyParameters GetRsaPublicKey(RSAParameters rp);
    public static AsymmetricCipherKeyPair GetKeyPair(AsymmetricAlgorithm privateKey);
}
public class Org.BouncyCastle.Security.EncryptionException : IOException {
    public EncryptionException(string message);
    public EncryptionException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneralSecurityException : Exception {
    public GeneralSecurityException(string message);
    public GeneralSecurityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.GeneratorUtilities : object {
    private static Hashtable kgAlgorithms;
    private static Hashtable kpgAlgorithms;
    private static GeneratorUtilities();
    private static void AddKgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddKpgAlgorithm(string canonicalName, Object[] aliases);
    private static void AddHMacKeyGenerator(string algorithm, Object[] aliases);
    internal static string GetCanonicalKeyGeneratorAlgorithm(string algorithm);
    internal static string GetCanonicalKeyPairGeneratorAlgorithm(string algorithm);
    public static CipherKeyGenerator GetKeyGenerator(DerObjectIdentifier oid);
    public static CipherKeyGenerator GetKeyGenerator(string algorithm);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(DerObjectIdentifier oid);
    public static IAsymmetricCipherKeyPairGenerator GetKeyPairGenerator(string algorithm);
    internal static int GetDefaultKeySize(DerObjectIdentifier oid);
    internal static int GetDefaultKeySize(string algorithm);
    private static int FindDefaultKeySize(string canonicalName);
}
public class Org.BouncyCastle.Security.InvalidKeyException : KeyException {
    public InvalidKeyException(string message);
    public InvalidKeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.InvalidParameterException : KeyException {
    public InvalidParameterException(string message);
    public InvalidParameterException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.KeyException : GeneralSecurityException {
    public KeyException(string message);
    public KeyException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.MacUtilities : object {
    private static Hashtable algorithms;
    private static MacUtilities();
    public static IMac GetMac(DerObjectIdentifier id);
    public static IMac GetMac(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
    public static Byte[] DoFinal(IMac mac);
}
[ObsoleteAttribute("Never thrown")]
public class Org.BouncyCastle.Security.NoSuchAlgorithmException : GeneralSecurityException {
    public NoSuchAlgorithmException(string message);
    public NoSuchAlgorithmException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.ParameterUtilities : object {
    private static Hashtable algorithms;
    private static ParameterUtilities();
    private static void AddAlgorithm(string canonicalName, Object[] aliases);
    public static string GetCanonicalAlgorithmName(string algorithm);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes);
    public static KeyParameter CreateKeyParameter(DerObjectIdentifier algOid, Byte[] keyBytes, int offset, int length);
    public static KeyParameter CreateKeyParameter(string algorithm, Byte[] keyBytes, int offset, int length);
    public static ICipherParameters GetCipherParameters(DerObjectIdentifier algOid, ICipherParameters key, Asn1Object asn1Params);
    public static ICipherParameters GetCipherParameters(string algorithm, ICipherParameters key, Asn1Object asn1Params);
    public static Asn1Encodable GenerateParameters(DerObjectIdentifier algID, SecureRandom random);
    public static Asn1Encodable GenerateParameters(string algorithm, SecureRandom random);
    private static Asn1OctetString CreateIVOctetString(SecureRandom random, int ivLength);
    private static Byte[] CreateIV(SecureRandom random, int ivLength);
}
public class Org.BouncyCastle.Security.PasswordException : IOException {
    public PasswordException(string message);
    public PasswordException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.PbeUtilities : object {
    private static string Pkcs5S1;
    private static string Pkcs5S2;
    private static string Pkcs12;
    private static string OpenSsl;
    private static Hashtable algorithms;
    private static Hashtable algorithmType;
    private static Hashtable oids;
    public static ICollection Algorithms { get; }
    private static PbeUtilities();
    private static PbeParametersGenerator MakePbeGenerator(string type, IDigest digest, Byte[] key, Byte[] salt, int iterationCount);
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static bool IsPkcs12(string algorithm);
    public static bool IsPkcs5Scheme1(string algorithm);
    public static bool IsPkcs5Scheme2(string algorithm);
    public static bool IsOpenSsl(string algorithm);
    public static bool IsPbeAlgorithm(string algorithm);
    public static Asn1Encodable GenerateAlgorithmParameters(DerObjectIdentifier algorithmOid, Byte[] salt, int iterationCount);
    public static Asn1Encodable GenerateAlgorithmParameters(string algorithm, Byte[] salt, int iterationCount);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(DerObjectIdentifier algorithmOid, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(AlgorithmIdentifier algID, Char[] password, bool wrongPkcs12Zero);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, Asn1Encodable pbeParameters);
    public static ICipherParameters GenerateCipherParameters(string algorithm, Char[] password, bool wrongPkcs12Zero, Asn1Encodable pbeParameters);
    public static object CreateEngine(DerObjectIdentifier algorithmOid);
    public static object CreateEngine(AlgorithmIdentifier algID);
    private static bool EndsWith(string s, string ending);
    public static object CreateEngine(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Security.PrivateKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] privateKeyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(PrivateKeyInfo keyInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, EncryptedPrivateKeyInfo encInfo);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Byte[] encryptedPrivateKeyInfoData);
    public static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Stream encryptedPrivateKeyInfoStream);
    private static AsymmetricKeyParameter DecryptKey(Char[] passPhrase, Asn1Object asn1Object);
}
public class Org.BouncyCastle.Security.PublicKeyFactory : object {
    public static AsymmetricKeyParameter CreateKey(Byte[] keyInfoData);
    public static AsymmetricKeyParameter CreateKey(Stream inStr);
    public static AsymmetricKeyParameter CreateKey(SubjectPublicKeyInfo keyInfo);
}
public class Org.BouncyCastle.Security.SecureRandom : Random {
    private static SecureRandom[] master;
    protected IRandomGenerator generator;
    private static double DoubleScale;
    private static SecureRandom Master { get; }
    public SecureRandom(Byte[] inSeed);
    public SecureRandom(IRandomGenerator generator);
    private static SecureRandom();
    private static SecureRandom get_Master();
    public static SecureRandom GetInstance(string algorithm);
    public static Byte[] GetSeed(int length);
    public virtual Byte[] GenerateSeed(int length);
    public virtual void SetSeed(Byte[] inSeed);
    public virtual void SetSeed(long seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Byte[] buffer, int start, int length);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
}
public class Org.BouncyCastle.Security.SecurityUtilityException : Exception {
    public SecurityUtilityException(string message);
    public SecurityUtilityException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignatureException : GeneralSecurityException {
    public SignatureException(string message);
    public SignatureException(string message, Exception exception);
}
public class Org.BouncyCastle.Security.SignerUtilities : object {
    internal static Hashtable algorithms;
    internal static Hashtable oids;
    public static ICollection Algorithms { get; }
    private static SignerUtilities();
    public static DerObjectIdentifier GetObjectIdentifier(string mechanism);
    public static ICollection get_Algorithms();
    public static ISigner GetSigner(DerObjectIdentifier id);
    public static ISigner GetSigner(string algorithm);
    public static string GetEncodingName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Security.WrapperUtilities : object {
    private static Hashtable algorithms;
    private static WrapperUtilities();
    public static IWrapper GetWrapper(DerObjectIdentifier oid);
    public static IWrapper GetWrapper(string algorithm);
    public static string GetAlgorithmName(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.Tsp.GenTimeAccuracy : object {
    private Accuracy accuracy;
    public int Seconds { get; }
    public int Millis { get; }
    public int Micros { get; }
    public GenTimeAccuracy(Accuracy accuracy);
    public int get_Seconds();
    public int get_Millis();
    public int get_Micros();
    private int GetTimeComponent(DerInteger time);
    public virtual string ToString();
}
public class Org.BouncyCastle.Tsp.TimeStampRequest : X509ExtensionBase {
    private TimeStampReq req;
    public int Version { get; }
    public string MessageImprintAlgOid { get; }
    public string ReqPolicy { get; }
    public BigInteger Nonce { get; }
    public bool CertReq { get; }
    internal X509Extensions Extensions { get; }
    public TimeStampRequest(TimeStampReq req);
    public TimeStampRequest(Byte[] req);
    public TimeStampRequest(Stream input);
    private TimeStampRequest(Asn1InputStream str);
    public int get_Version();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public string get_ReqPolicy();
    public BigInteger get_Nonce();
    public bool get_CertReq();
    public void Validate(IList algorithms, IList policies, IList extensions);
    public Byte[] GetEncoded();
    internal X509Extensions get_Extensions();
    protected virtual X509Extensions GetX509Extensions();
}
public class Org.BouncyCastle.Tsp.TimeStampRequestGenerator : object {
    private DerObjectIdentifier reqPolicy;
    private DerBoolean certReq;
    private Hashtable extensions;
    private ArrayList extOrdering;
    public void SetReqPolicy(string reqPolicy);
    public void SetCertReq(bool certReq);
    public void AddExtension(string oid, bool critical, Asn1Encodable value);
    public void AddExtension(string oid, bool critical, Byte[] value);
    public TimeStampRequest Generate(string digestAlgorithm, Byte[] digest);
    public TimeStampRequest Generate(string digestAlgorithmOid, Byte[] digest, BigInteger nonce);
}
public class Org.BouncyCastle.Tsp.TimeStampResponse : object {
    private TimeStampResp resp;
    private TimeStampToken timeStampToken;
    public int Status { get; }
    public TimeStampToken TimeStampToken { get; }
    public TimeStampResponse(TimeStampResp resp);
    public TimeStampResponse(Byte[] resp);
    public TimeStampResponse(Stream input);
    private static TimeStampResp readTimeStampResp(Asn1InputStream input);
    public int get_Status();
    public string GetStatusString();
    public PkiFailureInfo GetFailInfo();
    public TimeStampToken get_TimeStampToken();
    public void Validate(TimeStampRequest request);
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampResponseGenerator : object {
    private PkiStatus status;
    private Asn1EncodableVector statusStrings;
    private int failInfo;
    private TimeStampTokenGenerator tokenGenerator;
    private IList acceptedAlgorithms;
    private IList acceptedPolicies;
    private IList acceptedExtensions;
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicy);
    public TimeStampResponseGenerator(TimeStampTokenGenerator tokenGenerator, IList acceptedAlgorithms, IList acceptedPolicies, IList acceptedExtensions);
    private void addStatusString(string statusString);
    private void setFailInfoField(int field);
    private PkiStatusInfo getPkiStatusInfo();
    public TimeStampResponse Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
}
public class Org.BouncyCastle.Tsp.TimeStampToken : object {
    private CmsSignedData tsToken;
    private SignerInformation tsaSignerInfo;
    private TimeStampTokenInfo tstInfo;
    private CertID certID;
    public TimeStampTokenInfo TimeStampInfo { get; }
    public SignerID SignerID { get; }
    public AttributeTable SignedAttributes { get; }
    public AttributeTable UnsignedAttributes { get; }
    public TimeStampToken(ContentInfo contentInfo);
    public TimeStampToken(CmsSignedData signedData);
    public TimeStampTokenInfo get_TimeStampInfo();
    public SignerID get_SignerID();
    public AttributeTable get_SignedAttributes();
    public AttributeTable get_UnsignedAttributes();
    public IX509Store GetCertificates(string type);
    public IX509Store GetCrls(string type);
    public void Validate(X509Certificate cert);
    public CmsSignedData ToCmsSignedData();
    public Byte[] GetEncoded();
}
public class Org.BouncyCastle.Tsp.TimeStampTokenGenerator : object {
    private int accuracySeconds;
    private int accuracyMillis;
    private int accuracyMicros;
    private bool ordering;
    private GeneralName tsa;
    private string tsaPolicyOID;
    private AsymmetricKeyParameter key;
    private X509Certificate cert;
    private string digestOID;
    private AttributeTable signedAttr;
    private AttributeTable unsignedAttr;
    private IX509Store x509Certs;
    private IX509Store x509Crls;
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID);
    public TimeStampTokenGenerator(AsymmetricKeyParameter key, X509Certificate cert, string digestOID, string tsaPolicyOID, AttributeTable signedAttr, AttributeTable unsignedAttr);
    public void SetCertificates(IX509Store certificates);
    public void SetCrls(IX509Store crls);
    public void SetAccuracySeconds(int accuracySeconds);
    public void SetAccuracyMillis(int accuracyMillis);
    public void SetAccuracyMicros(int accuracyMicros);
    public void SetOrdering(bool ordering);
    public void SetTsa(GeneralName tsa);
    public TimeStampToken Generate(TimeStampRequest request, BigInteger serialNumber, DateTime genTime);
}
public class Org.BouncyCastle.Tsp.TimeStampTokenInfo : object {
    private TstInfo tstInfo;
    private DateTime genTime;
    public bool IsOrdered { get; }
    public Accuracy Accuracy { get; }
    public DateTime GenTime { get; }
    public GenTimeAccuracy GenTimeAccuracy { get; }
    public string Policy { get; }
    public BigInteger SerialNumber { get; }
    public GeneralName Tsa { get; }
    public BigInteger Nonce { get; }
    public string MessageImprintAlgOid { get; }
    public TstInfo TstInfo { get; }
    public TimeStampTokenInfo(TstInfo tstInfo);
    public bool get_IsOrdered();
    public Accuracy get_Accuracy();
    public DateTime get_GenTime();
    public GenTimeAccuracy get_GenTimeAccuracy();
    public string get_Policy();
    public BigInteger get_SerialNumber();
    public GeneralName get_Tsa();
    public BigInteger get_Nonce();
    public string get_MessageImprintAlgOid();
    public Byte[] GetMessageImprintDigest();
    public Byte[] GetEncoded();
    public TstInfo get_TstInfo();
}
public abstract class Org.BouncyCastle.Tsp.TspAlgorithms : object {
    public static string MD5;
    public static string Sha1;
    public static string Sha224;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string RipeMD128;
    public static string RipeMD160;
    public static string RipeMD256;
    public static string Gost3411;
    public static ArrayList Allowed;
    private static TspAlgorithms();
}
public class Org.BouncyCastle.Tsp.TspException : Exception {
    public TspException(string message);
    public TspException(string message, Exception e);
}
public class Org.BouncyCastle.Tsp.TspUtil : object {
    private static IDictionary digestLengths;
    private static IDictionary digestNames;
    private static TspUtil();
    public static void ValidateCertificate(X509Certificate cert);
    internal static string GetDigestAlgName(string digestAlgOID);
    internal static int GetDigestLength(string digestAlgOID);
}
public class Org.BouncyCastle.Tsp.TspValidationException : TspException {
    private int failureCode;
    public int FailureCode { get; }
    public TspValidationException(string message);
    public TspValidationException(string message, int failureCode);
    public int get_FailureCode();
}
public class Org.BouncyCastle.Utilities.Arrays : object {
    public static bool AreEqual(Boolean[] a, Boolean[] b);
    public static bool AreEqual(Byte[] a, Byte[] b);
    [ObsoleteAttribute("Use 'AreEqual' method instead")]
public static bool AreSame(Byte[] a, Byte[] b);
    public static bool AreEqual(Int32[] a, Int32[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    public static string ToString(Object[] a);
    public static int GetHashCode(Byte[] data);
    public static Byte[] Clone(Byte[] data);
    public static Int32[] Clone(Int32[] data);
}
public class Org.BouncyCastle.Utilities.BigIntegers : object {
    private static int MaxIterations;
    public static Byte[] AsUnsignedByteArray(BigInteger n);
    public static BigInteger CreateRandomInRange(BigInteger min, BigInteger max, SecureRandom random);
}
public class Org.BouncyCastle.Utilities.Collections.CollectionUtilities : object {
    public static bool CheckElementsAreOfType(IEnumerable e, Type t);
    public static string ToString(IEnumerable c);
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerable : object {
    public static IEnumerable Instance;
    private static EmptyEnumerable();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.EmptyEnumerator : object {
    public static IEnumerator Instance;
    public object Current { get; }
    private static EmptyEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class Org.BouncyCastle.Utilities.Collections.EnumerableProxy : object {
    private IEnumerable inner;
    public EnumerableProxy(IEnumerable inner);
    public sealed virtual IEnumerator GetEnumerator();
}
public class Org.BouncyCastle.Utilities.Collections.HashSet : object {
    private Hashtable impl;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public HashSet(ISet s);
    public sealed virtual void Add(object o);
    public sealed virtual void AddAll(IEnumerable e);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object o);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual void Remove(object o);
    public sealed virtual void RemoveAll(IEnumerable e);
    public sealed virtual object get_SyncRoot();
}
public interface Org.BouncyCastle.Utilities.Collections.ISet {
    public bool IsEmpty { get; }
    public abstract virtual void Add(object o);
    public abstract virtual void AddAll(IEnumerable e);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object o);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Remove(object o);
    public abstract virtual void RemoveAll(IEnumerable e);
}
public class Org.BouncyCastle.Utilities.Date.DateTimeObject : object {
    private DateTime dt;
    public DateTime Value { get; }
    public DateTimeObject(DateTime dt);
    public DateTime get_Value();
    public virtual string ToString();
}
public class Org.BouncyCastle.Utilities.Date.DateTimeUtilities : object {
    public static DateTime UnixEpoch;
    private static DateTimeUtilities();
    public static long DateTimeToUnixMs(DateTime dateTime);
    public static DateTime UnixMsToDateTime(long unixMs);
    public static long CurrentUnixMs();
}
public class Org.BouncyCastle.Utilities.Encoders.Base64 : object {
    public static Byte[] Encode(Byte[] data);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.Base64Encoder : object {
    protected Byte[] encodingTable;
    protected byte padding;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public sealed virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    private bool ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    private int nextI(Byte[] data, int i, int finish);
    public sealed virtual int DecodeString(string data, Stream outStream);
    private int decodeLastBlock(Stream outStream, char c1, char c2, char c3, char c4);
    private int nextI(string data, int i, int finish);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedDecoder : object {
    internal Byte[] buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedDecoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] output, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.BufferedEncoder : object {
    internal Byte[] Buffer;
    internal int bufOff;
    internal ITranslator translator;
    public BufferedEncoder(ITranslator translator, int bufferSize);
    public int ProcessByte(byte input, Byte[] outBytes, int outOff);
    public int ProcessBytes(Byte[] input, int inOff, int len, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.Hex : object {
    private static IEncoder encoder;
    private static Hex();
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.HexEncoder : object {
    private static Byte[] encodingTable;
    internal static Byte[] decodingTable;
    private static HexEncoder();
    public sealed virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    private bool ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public sealed virtual int DecodeString(string data, Stream outStream);
}
public class Org.BouncyCastle.Utilities.Encoders.HexTranslator : object {
    private static Byte[] hexTable;
    private static HexTranslator();
    public sealed virtual int GetEncodedBlockSize();
    public sealed virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public sealed virtual int GetDecodedBlockSize();
    public sealed virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public interface Org.BouncyCastle.Utilities.Encoders.IEncoder {
    public abstract virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int DecodeString(string data, Stream outStream);
}
public interface Org.BouncyCastle.Utilities.Encoders.ITranslator {
    public abstract virtual int GetEncodedBlockSize();
    public abstract virtual int Encode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
    public abstract virtual int GetDecodedBlockSize();
    public abstract virtual int Decode(Byte[] input, int inOff, int length, Byte[] outBytes, int outOff);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64 : object {
    private static IEncoder encoder;
    private static UrlBase64();
    public static Byte[] Encode(Byte[] data);
    public static int Encode(Byte[] data, Stream outStr);
    public static Byte[] Decode(Byte[] data);
    public static int Decode(Byte[] data, Stream outStr);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStr);
}
public class Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder : Base64Encoder {
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseInputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class Org.BouncyCastle.Utilities.IO.BaseOutputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer);
}
public class Org.BouncyCastle.Utilities.IO.PushbackStream : FilterStream {
    private int buf;
    public PushbackStream(Stream s);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
}
public class Org.BouncyCastle.Utilities.IO.Streams : object {
    private static int BufferSize;
    public static void Drain(Stream inStr);
    public static Byte[] ReadAll(Stream inStr);
    public static int ReadFully(Stream inStr, Byte[] buf);
    public static int ReadFully(Stream inStr, Byte[] buf, int off, int len);
    public static void PipeAll(Stream inStr, Stream outStr);
}
public class Org.BouncyCastle.Utilities.Net.IPAddress : object {
    public static bool IsValid(string address);
    public static bool IsValidWithNetMask(string address);
    public static bool IsValidIPv4(string address);
    private static bool unsafeIsValidIPv4(string address);
    public static bool IsValidIPv4WithNetmask(string address);
    public static bool IsValidIPv6WithNetmask(string address);
    private static bool IsMaskValue(string component, int size);
    public static bool IsValidIPv6(string address);
    private static bool unsafeIsValidIPv6(string address);
}
internal class Org.BouncyCastle.Utilities.Platform : object {
    internal static string NewLine;
    private static Platform();
    internal static Exception CreateNotImplementedException(string message);
    internal static string GetEnvironmentVariable(string variable);
    private static string GetNewLine();
}
public class Org.BouncyCastle.Utilities.Strings : object {
    public static string FromByteArray(Byte[] bs);
    public static Byte[] ToByteArray(string s);
    public static string FromUtf8ByteArray(Byte[] bytes);
    public static Byte[] ToUtf8ByteArray(string s);
    public static Byte[] ToUtf8ByteArray(Char[] cs);
}
internal class Org.BouncyCastle.Utilities.Zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    private static Config[] config_table;
    private static String[] z_errmsg;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfBlocks : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfCodes : object {
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private static Int32[] inflate_mask;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class Org.BouncyCastle.Utilities.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static int BMAX;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class Org.BouncyCastle.Utilities.Zlib.JZlib : object {
    private static string version_;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class Org.BouncyCastle.Utilities.Zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class Org.BouncyCastle.Utilities.Zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
public class Org.BouncyCastle.Utilities.Zlib.ZDeflaterOutputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public void Finish();
    public void End();
    public virtual void Close();
}
public class Org.BouncyCastle.Utilities.Zlib.ZInflaterInputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class Org.BouncyCastle.Utilities.Zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
public class Org.BouncyCastle.X509.AttributeCertificateHolder : object {
    internal Holder holder;
    public int DigestedObjectType { get; }
    public string DigestAlgorithm { get; }
    public string OtherObjectTypeID { get; }
    public BigInteger SerialNumber { get; }
    internal AttributeCertificateHolder(Asn1Sequence seq);
    public AttributeCertificateHolder(X509Name issuerName, BigInteger serialNumber);
    public AttributeCertificateHolder(X509Certificate cert);
    public AttributeCertificateHolder(X509Name principal);
    public AttributeCertificateHolder(int digestedObjectType, string digestAlgorithm, string otherObjectTypeID, Byte[] objectDigest);
    public int get_DigestedObjectType();
    public string get_DigestAlgorithm();
    public Byte[] GetObjectDigest();
    public string get_OtherObjectTypeID();
    private GeneralNames GenerateGeneralNames(X509Name principal);
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    private Object[] GetNames(GeneralName[] names);
    private X509Name[] GetPrincipals(GeneralNames names);
    public X509Name[] GetEntityNames();
    public X509Name[] GetIssuer();
    public BigInteger get_SerialNumber();
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.AttributeCertificateIssuer : object {
    internal Asn1Encodable form;
    public AttributeCertificateIssuer(AttCertIssuer issuer);
    public AttributeCertificateIssuer(X509Name principal);
    private Object[] GetNames();
    public X509Name[] GetPrincipals();
    private bool MatchesDN(X509Name subject, GeneralNames targets);
    public sealed virtual object Clone();
    public bool Match(X509Certificate x509Cert);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure : AuthorityKeyIdentifier {
    public AuthorityKeyIdentifierStructure(Asn1OctetString encodedValue);
    public AuthorityKeyIdentifierStructure(X509Certificate certificate);
    public AuthorityKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1Sequence FromCertificate(X509Certificate certificate);
    private static Asn1Sequence FromKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure : SubjectKeyIdentifier {
    public SubjectKeyIdentifierStructure(Asn1OctetString encodedValue);
    public SubjectKeyIdentifierStructure(AsymmetricKeyParameter pubKey);
    private static Asn1OctetString FromPublicKey(AsymmetricKeyParameter pubKey);
}
public class Org.BouncyCastle.X509.Extension.X509ExtensionUtilities : object {
    public static Asn1Object FromExtensionValue(Asn1OctetString extensionValue);
    public static ICollection GetIssuerAlternativeNames(X509Certificate cert);
    public static ICollection GetSubjectAlternativeNames(X509Certificate cert);
    private static ICollection GetAlternativeName(Asn1OctetString extVal);
}
public interface Org.BouncyCastle.X509.IX509AttributeCertificate {
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public bool IsValidNow { get; }
    public abstract virtual int get_Version();
    public abstract virtual BigInteger get_SerialNumber();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual AttributeCertificateHolder get_Holder();
    public abstract virtual AttributeCertificateIssuer get_Issuer();
    public abstract virtual X509Attribute[] GetAttributes();
    public abstract virtual X509Attribute[] GetAttributes(string oid);
    public abstract virtual Boolean[] GetIssuerUniqueID();
    public abstract virtual bool get_IsValidNow();
    public abstract virtual bool IsValid(DateTime date);
    public abstract virtual void CheckValidity();
    public abstract virtual void CheckValidity(DateTime date);
    public abstract virtual Byte[] GetSignature();
    public abstract virtual void Verify(AsymmetricKeyParameter publicKey);
    public abstract virtual Byte[] GetEncoded();
}
public interface Org.BouncyCastle.X509.IX509Extension {
    public abstract virtual ISet GetCriticalExtensionOids();
    public abstract virtual ISet GetNonCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public abstract virtual Asn1OctetString GetExtensionValue(string oid);
    public abstract virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.PemParser : object {
    private string _header1;
    private string _header2;
    private string _footer1;
    private string _footer2;
    internal PemParser(string type);
    private string ReadLine(Stream inStream);
    internal Asn1Sequence ReadPemObject(Stream inStream);
}
public class Org.BouncyCastle.X509.PrincipalUtilities : object {
    public static X509Name GetIssuerX509Principal(X509Certificate cert);
    public static X509Name GetSubjectX509Principal(X509Certificate cert);
    public static X509Name GetIssuerX509Principal(X509Crl crl);
}
public interface Org.BouncyCastle.X509.Store.IX509Selector {
    public abstract virtual bool Match(object obj);
}
public interface Org.BouncyCastle.X509.Store.IX509Store {
    public abstract virtual ICollection GetMatches(IX509Selector selector);
}
public interface Org.BouncyCastle.X509.Store.IX509StoreParameters {
}
public class Org.BouncyCastle.X509.Store.NoSuchStoreException : X509StoreException {
    public NoSuchStoreException(string message);
    public NoSuchStoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector : object {
    private IX509AttributeCertificate attributeCert;
    private DateTimeObject attributeCertificateValid;
    private AttributeCertificateHolder holder;
    private AttributeCertificateIssuer issuer;
    private BigInteger serialNumber;
    private ISet targetNames;
    private ISet targetGroups;
    public IX509AttributeCertificate AttributeCert { get; public set; }
    [ObsoleteAttribute("Use AttributeCertificateValid instead")]
public DateTimeObject AttribueCertificateValid { get; public set; }
    public DateTimeObject AttributeCertificateValid { get; public set; }
    public AttributeCertificateHolder Holder { get; public set; }
    public AttributeCertificateIssuer Issuer { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    private X509AttrCertStoreSelector(X509AttrCertStoreSelector o);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
    public IX509AttributeCertificate get_AttributeCert();
    public void set_AttributeCert(IX509AttributeCertificate value);
    public DateTimeObject get_AttribueCertificateValid();
    public void set_AttribueCertificateValid(DateTimeObject value);
    public DateTimeObject get_AttributeCertificateValid();
    public void set_AttributeCertificateValid(DateTimeObject value);
    public AttributeCertificateHolder get_Holder();
    public void set_Holder(AttributeCertificateHolder value);
    public AttributeCertificateIssuer get_Issuer();
    public void set_Issuer(AttributeCertificateIssuer value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public void AddTargetName(GeneralName name);
    public void AddTargetName(Byte[] name);
    public void SetTargetNames(IEnumerable names);
    public IEnumerable GetTargetNames();
    public void AddTargetGroup(GeneralName group);
    public void AddTargetGroup(Byte[] name);
    public void SetTargetGroups(IEnumerable names);
    public IEnumerable GetTargetGroups();
    private ISet ExtractGeneralNames(IEnumerable names);
}
public class Org.BouncyCastle.X509.Store.X509CertPairStoreSelector : object {
    private X509CertificatePair certPair;
    private X509CertStoreSelector forwardSelector;
    private X509CertStoreSelector reverseSelector;
    public X509CertificatePair CertPair { get; public set; }
    public X509CertStoreSelector ForwardSelector { get; public set; }
    public X509CertStoreSelector ReverseSelector { get; public set; }
    private X509CertPairStoreSelector(X509CertPairStoreSelector o);
    private static X509CertStoreSelector CloneSelector(X509CertStoreSelector s);
    public X509CertificatePair get_CertPair();
    public void set_CertPair(X509CertificatePair value);
    public X509CertStoreSelector get_ForwardSelector();
    public void set_ForwardSelector(X509CertStoreSelector value);
    public X509CertStoreSelector get_ReverseSelector();
    public void set_ReverseSelector(X509CertStoreSelector value);
    public sealed virtual bool Match(object obj);
    public sealed virtual object Clone();
}
public class Org.BouncyCastle.X509.Store.X509CertStoreSelector : object {
    private Byte[] authorityKeyIdentifier;
    private int basicConstraints;
    private X509Certificate certificate;
    private DateTimeObject certificateValid;
    private ISet extendedKeyUsage;
    private X509Name issuer;
    private Boolean[] keyUsage;
    private ISet policy;
    private DateTimeObject privateKeyValid;
    private BigInteger serialNumber;
    private X509Name subject;
    private Byte[] subjectKeyIdentifier;
    private SubjectPublicKeyInfo subjectPublicKey;
    private DerObjectIdentifier subjectPublicKeyAlgID;
    public Byte[] AuthorityKeyIdentifier { get; public set; }
    public int BasicConstraints { get; public set; }
    public X509Certificate Certificate { get; public set; }
    public DateTimeObject CertificateValid { get; public set; }
    public ISet ExtendedKeyUsage { get; public set; }
    public X509Name Issuer { get; public set; }
    [ObsoleteAttribute("Avoid working with X509Name objects in string form")]
public string IssuerAsString { get; }
    public Boolean[] KeyUsage { get; public set; }
    public ISet Policy { get; public set; }
    public DateTimeObject PrivateKeyValid { get; public set; }
    public BigInteger SerialNumber { get; public set; }
    public X509Name Subject { get; public set; }
    public string SubjectAsString { get; }
    public Byte[] SubjectKeyIdentifier { get; public set; }
    public SubjectPublicKeyInfo SubjectPublicKey { get; public set; }
    public DerObjectIdentifier SubjectPublicKeyAlgID { get; public set; }
    public X509CertStoreSelector(X509CertStoreSelector o);
    public virtual object Clone();
    public Byte[] get_AuthorityKeyIdentifier();
    public void set_AuthorityKeyIdentifier(Byte[] value);
    public int get_BasicConstraints();
    public void set_BasicConstraints(int value);
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public DateTimeObject get_CertificateValid();
    public void set_CertificateValid(DateTimeObject value);
    public ISet get_ExtendedKeyUsage();
    public void set_ExtendedKeyUsage(ISet value);
    public X509Name get_Issuer();
    public void set_Issuer(X509Name value);
    public string get_IssuerAsString();
    public Boolean[] get_KeyUsage();
    public void set_KeyUsage(Boolean[] value);
    public ISet get_Policy();
    public void set_Policy(ISet value);
    public DateTimeObject get_PrivateKeyValid();
    public void set_PrivateKeyValid(DateTimeObject value);
    public BigInteger get_SerialNumber();
    public void set_SerialNumber(BigInteger value);
    public X509Name get_Subject();
    public void set_Subject(X509Name value);
    public string get_SubjectAsString();
    public Byte[] get_SubjectKeyIdentifier();
    public void set_SubjectKeyIdentifier(Byte[] value);
    public SubjectPublicKeyInfo get_SubjectPublicKey();
    public void set_SubjectPublicKey(SubjectPublicKeyInfo value);
    public DerObjectIdentifier get_SubjectPublicKeyAlgID();
    public void set_SubjectPublicKeyAlgID(DerObjectIdentifier value);
    public virtual bool Match(object obj);
    internal static bool IssuersMatch(X509Name a, X509Name b);
    private static Boolean[] CopyBoolArray(Boolean[] b);
    private static ISet CopySet(ISet s);
    private static SubjectPublicKeyInfo GetSubjectPublicKey(X509Certificate c);
    private static bool MatchExtension(Byte[] b, X509Certificate c, DerObjectIdentifier oid);
}
internal class Org.BouncyCastle.X509.Store.X509CollectionStore : object {
    private ICollection _local;
    internal X509CollectionStore(ICollection collection);
    public sealed virtual ICollection GetMatches(IX509Selector selector);
}
public class Org.BouncyCastle.X509.Store.X509CollectionStoreParameters : object {
    private ArrayList collection;
    public X509CollectionStoreParameters(ICollection collection);
    public ICollection GetCollection();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.Store.X509CrlStoreSelector : object {
    private X509Certificate certificateChecking;
    private DateTimeObject dateAndTime;
    private ICollection issuers;
    private BigInteger maxCrlNumber;
    private BigInteger minCrlNumber;
    private IX509AttributeCertificate attrCertChecking;
    private bool completeCrlEnabled;
    private bool deltaCrlIndicatorEnabled;
    private Byte[] issuingDistributionPoint;
    private bool issuingDistributionPointEnabled;
    private BigInteger maxBaseCrlNumber;
    public X509Certificate CertificateChecking { get; public set; }
    public DateTimeObject DateAndTime { get; public set; }
    public ICollection Issuers { get; public set; }
    public BigInteger MaxCrlNumber { get; public set; }
    public BigInteger MinCrlNumber { get; public set; }
    public IX509AttributeCertificate AttrCertChecking { get; public set; }
    public bool CompleteCrlEnabled { get; public set; }
    public bool DeltaCrlIndicatorEnabled { get; public set; }
    public Byte[] IssuingDistributionPoint { get; public set; }
    public bool IssuingDistributionPointEnabled { get; public set; }
    public BigInteger MaxBaseCrlNumber { get; public set; }
    public X509CrlStoreSelector(X509CrlStoreSelector o);
    public virtual object Clone();
    public X509Certificate get_CertificateChecking();
    public void set_CertificateChecking(X509Certificate value);
    public DateTimeObject get_DateAndTime();
    public void set_DateAndTime(DateTimeObject value);
    public ICollection get_Issuers();
    public void set_Issuers(ICollection value);
    public BigInteger get_MaxCrlNumber();
    public void set_MaxCrlNumber(BigInteger value);
    public BigInteger get_MinCrlNumber();
    public void set_MinCrlNumber(BigInteger value);
    public IX509AttributeCertificate get_AttrCertChecking();
    public void set_AttrCertChecking(IX509AttributeCertificate value);
    public bool get_CompleteCrlEnabled();
    public void set_CompleteCrlEnabled(bool value);
    public bool get_DeltaCrlIndicatorEnabled();
    public void set_DeltaCrlIndicatorEnabled(bool value);
    public Byte[] get_IssuingDistributionPoint();
    public void set_IssuingDistributionPoint(Byte[] value);
    public bool get_IssuingDistributionPointEnabled();
    public void set_IssuingDistributionPointEnabled(bool value);
    public BigInteger get_MaxBaseCrlNumber();
    public void set_MaxBaseCrlNumber(BigInteger value);
    public virtual bool Match(object obj);
}
public class Org.BouncyCastle.X509.Store.X509StoreException : Exception {
    public X509StoreException(string message);
    public X509StoreException(string message, Exception e);
}
public class Org.BouncyCastle.X509.Store.X509StoreFactory : object {
    public static IX509Store Create(string type, IX509StoreParameters parameters);
    private static void checkCorrectType(ICollection coll, Type t);
}
public class Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory : object {
    public static SubjectPublicKeyInfo CreateSubjectPublicKeyInfo(AsymmetricKeyParameter key);
    private static void ExtractBytes(Byte[] encKey, int offset, BigInteger bI);
}
public class Org.BouncyCastle.X509.X509AttrCertParser : object {
    private static PemParser PemAttrCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509AttrCertParser();
    private IX509AttributeCertificate ReadDerCertificate(Asn1InputStream dIn);
    private IX509AttributeCertificate GetCertificate();
    private IX509AttributeCertificate ReadPemCertificate(Stream inStream);
    public IX509AttributeCertificate ReadAttrCert(Byte[] input);
    public ICollection ReadAttrCerts(Byte[] input);
    public IX509AttributeCertificate ReadAttrCert(Stream inStream);
    public ICollection ReadAttrCerts(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Attribute : Asn1Encodable {
    private AttributeX509 attr;
    public string Oid { get; }
    internal X509Attribute(Asn1Encodable at);
    public X509Attribute(string oid, Asn1Encodable value);
    public X509Attribute(string oid, Asn1EncodableVector value);
    public string get_Oid();
    public Asn1Encodable[] GetValues();
    public virtual Asn1Object ToAsn1Object();
}
public class Org.BouncyCastle.X509.X509Certificate : X509ExtensionBase {
    private X509CertificateStructure c;
    private BasicConstraints basicConstraints;
    private Boolean[] keyUsage;
    private bool hashValueSet;
    private int hashValue;
    public bool IsValidNow { get; }
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public X509Name IssuerDN { get; }
    public X509Name SubjectDN { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    public X509Certificate(X509CertificateStructure c);
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime time);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime time);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual X509Name get_IssuerDN();
    public virtual X509Name get_SubjectDN();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Byte[] GetTbsCertificate();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual DerBitString get_IssuerUniqueID();
    public virtual DerBitString get_SubjectUniqueID();
    public virtual Boolean[] GetKeyUsage();
    public virtual IList GetExtendedKeyUsage();
    public virtual int GetBasicConstraints();
    public virtual ICollection GetSubjectAlternativeNames();
    public virtual ICollection GetIssuerAlternativeNames();
    protected virtual ICollection GetAlternativeNames(string oid);
    protected virtual X509Extensions GetX509Extensions();
    public virtual AsymmetricKeyParameter GetPublicKey();
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual void Verify(AsymmetricKeyParameter key);
    protected virtual void CheckSignature(AsymmetricKeyParameter publicKey, ISigner signature);
}
public class Org.BouncyCastle.X509.X509CertificatePair : object {
    private X509Certificate forward;
    private X509Certificate reverse;
    public X509Certificate Forward { get; }
    public X509Certificate Reverse { get; }
    public X509CertificatePair(X509Certificate forward, X509Certificate reverse);
    public X509CertificatePair(CertificatePair pair);
    public Byte[] GetEncoded();
    public X509Certificate get_Forward();
    public X509Certificate get_Reverse();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509CertificateParser : object {
    private static PemParser PemCertParser;
    private Asn1Set sData;
    private int sDataObjectCount;
    private Stream currentStream;
    private static X509CertificateParser();
    private X509Certificate ReadDerCertificate(Asn1InputStream dIn);
    private X509Certificate GetCertificate();
    private X509Certificate ReadPemCertificate(Stream inStream);
    protected virtual X509Certificate CreateX509Certificate(X509CertificateStructure c);
    public X509Certificate ReadCertificate(Byte[] input);
    public ICollection ReadCertificates(Byte[] input);
    public X509Certificate ReadCertificate(Stream inStream);
    public ICollection ReadCertificates(Stream inStream);
}
public class Org.BouncyCastle.X509.X509CertPairParser : object {
    private Stream currentStream;
    private X509CertificatePair ReadDerCrossCertificatePair(Stream inStream);
    public X509CertificatePair ReadCertPair(Byte[] input);
    public ICollection ReadCertPairs(Byte[] input);
    public X509CertificatePair ReadCertPair(Stream inStream);
    public ICollection ReadCertPairs(Stream inStream);
}
public class Org.BouncyCastle.X509.X509Crl : X509ExtensionBase {
    private CertificateList c;
    private string sigAlgName;
    private Byte[] sigAlgParams;
    private bool isIndirect;
    public int Version { get; }
    public X509Name IssuerDN { get; }
    public DateTime ThisUpdate { get; }
    public DateTimeObject NextUpdate { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    protected bool IsIndirectCrl { get; }
    public X509Crl(CertificateList c);
    protected virtual X509Extensions GetX509Extensions();
    public virtual Byte[] GetEncoded();
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual int get_Version();
    public virtual X509Name get_IssuerDN();
    public virtual DateTime get_ThisUpdate();
    public virtual DateTimeObject get_NextUpdate();
    private ISet LoadCrlEntries();
    public virtual X509CrlEntry GetRevokedCertificate(BigInteger serialNumber);
    public virtual ISet GetRevokedCertificates();
    public virtual Byte[] GetTbsCertList();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsRevoked(X509Certificate cert);
    protected virtual bool get_IsIndirectCrl();
    private static string AsHexString(Byte[] bytes, int index, int count);
}
public class Org.BouncyCastle.X509.X509CrlEntry : X509ExtensionBase {
    private CrlEntry c;
    private bool isIndirect;
    private X509Name previousCertificateIssuer;
    private X509Name certificateIssuer;
    public BigInteger SerialNumber { get; }
    public DateTime RevocationDate { get; }
    public bool HasExtensions { get; }
    public X509CrlEntry(CrlEntry c);
    public X509CrlEntry(CrlEntry c, bool isIndirect, X509Name previousCertificateIssuer);
    private X509Name loadCertificateIssuer();
    public X509Name GetCertificateIssuer();
    protected virtual X509Extensions GetX509Extensions();
    public Byte[] GetEncoded();
    public BigInteger get_SerialNumber();
    public DateTime get_RevocationDate();
    public bool get_HasExtensions();
    public virtual string ToString();
}
public class Org.BouncyCastle.X509.X509CrlParser : object {
    private static PemParser PemCrlParser;
    private bool lazyAsn1;
    private Asn1Set sCrlData;
    private int sCrlDataObjectCount;
    private Stream currentCrlStream;
    public X509CrlParser(bool lazyAsn1);
    private static X509CrlParser();
    private X509Crl ReadPemCrl(Stream inStream);
    private X509Crl ReadDerCrl(Asn1InputStream dIn);
    private X509Crl GetCrl();
    protected virtual X509Crl CreateX509Crl(CertificateList c);
    public X509Crl ReadCrl(Byte[] input);
    public ICollection ReadCrls(Byte[] input);
    public X509Crl ReadCrl(Stream inStream);
    public ICollection ReadCrls(Stream inStream);
}
public abstract class Org.BouncyCastle.X509.X509ExtensionBase : object {
    protected abstract virtual X509Extensions GetX509Extensions();
    protected virtual ISet GetExtensionOids(bool critical);
    public virtual ISet GetNonCriticalExtensionOids();
    public virtual ISet GetCriticalExtensionOids();
    [ObsoleteAttribute("Use version taking a DerObjectIdentifier instead")]
public sealed virtual Asn1OctetString GetExtensionValue(string oid);
    public virtual Asn1OctetString GetExtensionValue(DerObjectIdentifier oid);
}
public class Org.BouncyCastle.X509.X509KeyUsage : Asn1Encodable {
    public static int DigitalSignature;
    public static int NonRepudiation;
    public static int KeyEncipherment;
    public static int DataEncipherment;
    public static int KeyAgreement;
    public static int KeyCertSign;
    public static int CrlSign;
    public static int EncipherOnly;
    public static int DecipherOnly;
    private int usage;
    public X509KeyUsage(int usage);
    public virtual Asn1Object ToAsn1Object();
}
internal class Org.BouncyCastle.X509.X509SignatureUtilities : object {
    private static Asn1Null derNull;
    private static X509SignatureUtilities();
    internal static void SetSignatureParameters(ISigner signature, Asn1Encodable parameters);
    internal static string GetSignatureName(AlgorithmIdentifier sigAlgId);
    private static string GetDigestAlgName(DerObjectIdentifier digestAlgOID);
}
internal class Org.BouncyCastle.X509.X509Utilities : object {
    private static Hashtable algorithms;
    private static Hashtable exParams;
    private static ISet noParams;
    private static X509Utilities();
    private static RsassaPssParameters CreatePssParams(AlgorithmIdentifier hashAlgId, int saltSize);
    internal static DerObjectIdentifier GetAlgorithmOid(string algorithmName);
    internal static AlgorithmIdentifier GetSigAlgID(DerObjectIdentifier sigOid, string algorithmName);
    internal static IEnumerable GetAlgNames();
    internal static Byte[] GetSignatureForObject(DerObjectIdentifier sigOid, string sigName, AsymmetricKeyParameter privateKey, SecureRandom random, Asn1Encodable ae);
}
public class Org.BouncyCastle.X509.X509V1CertificateGenerator : object {
    private V1TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificate : X509ExtensionBase {
    private AttributeCertificate cert;
    private DateTime notBefore;
    private DateTime notAfter;
    public int Version { get; }
    public BigInteger SerialNumber { get; }
    public AttributeCertificateHolder Holder { get; }
    public AttributeCertificateIssuer Issuer { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public bool IsValidNow { get; }
    public X509V2AttributeCertificate(Stream encIn);
    public X509V2AttributeCertificate(Byte[] encoded);
    internal X509V2AttributeCertificate(Asn1InputStream ais);
    internal X509V2AttributeCertificate(AttributeCertificate cert);
    public virtual int get_Version();
    public virtual BigInteger get_SerialNumber();
    public virtual AttributeCertificateHolder get_Holder();
    public virtual AttributeCertificateIssuer get_Issuer();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Boolean[] GetIssuerUniqueID();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime date);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime date);
    public virtual Byte[] GetSignature();
    public virtual void Verify(AsymmetricKeyParameter publicKey);
    public virtual Byte[] GetEncoded();
    protected virtual X509Extensions GetX509Extensions();
    public virtual X509Attribute[] GetAttributes();
    public virtual X509Attribute[] GetAttributes(string oid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2AttributeCertificateInfoGenerator acInfoGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetHolder(AttributeCertificateHolder holder);
    public void SetIssuer(AttributeCertificateIssuer issuer);
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddAttribute(X509Attribute attribute);
    public void SetIssuerUniqueId(Boolean[] iui);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public IX509AttributeCertificate Generate(AsymmetricKeyParameter publicKey);
    public IX509AttributeCertificate Generate(AsymmetricKeyParameter publicKey, SecureRandom random);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V2CrlGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V2TbsCertListGenerator tbsGen;
    private DerObjectIdentifier sigOID;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetIssuerDN(X509Name issuer);
    public void SetThisUpdate(DateTime date);
    public void SetNextUpdate(DateTime date);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, int reason, DateTime invalidityDate);
    public void AddCrlEntry(BigInteger userCertificate, DateTime revocationDate, X509Extensions extensions);
    public void AddCrl(X509Crl other);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public X509Crl Generate(AsymmetricKeyParameter privateKey);
    public X509Crl Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private TbsCertificateList GenerateCertList();
    private X509Crl GenerateJcaObject(TbsCertificateList tbsCrl, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class Org.BouncyCastle.X509.X509V3CertificateGenerator : object {
    private X509ExtensionsGenerator extGenerator;
    private V3TbsCertificateGenerator tbsGen;
    private DerObjectIdentifier sigOid;
    private AlgorithmIdentifier sigAlgId;
    private string signatureAlgorithm;
    public IEnumerable SignatureAlgNames { get; }
    public void Reset();
    public void SetSerialNumber(BigInteger serialNumber);
    public void SetIssuerDN(X509Name issuer);
    public void SetNotBefore(DateTime date);
    public void SetNotAfter(DateTime date);
    public void SetSubjectDN(X509Name subject);
    public void SetPublicKey(AsymmetricKeyParameter publicKey);
    public void SetSignatureAlgorithm(string signatureAlgorithm);
    public void SetSubjectUniqueID(Boolean[] uniqueID);
    public void SetIssuerUniqueID(Boolean[] uniqueID);
    private DerBitString booleanToBitString(Boolean[] id);
    public void AddExtension(string oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Asn1Encodable extensionValue);
    public void AddExtension(string oid, bool critical, Byte[] extensionValue);
    public void AddExtension(DerObjectIdentifier oid, bool critical, Byte[] extensionValue);
    public void CopyAndAddExtension(string oid, bool critical, X509Certificate cert);
    public void CopyAndAddExtension(DerObjectIdentifier oid, bool critical, X509Certificate cert);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey);
    public X509Certificate Generate(AsymmetricKeyParameter privateKey, SecureRandom random);
    private TbsCertificateStructure GenerateTbsCert();
    private X509Certificate GenerateJcaObject(TbsCertificateStructure tbsCert, Byte[] signature);
    public IEnumerable get_SignatureAlgNames();
}
public class System.Drawing.Dimension : Dimension2D {
    public int width;
    public int height;
    public double Width { get; }
    public double Height { get; }
    public Dimension Size { get; public set; }
    public Dimension(Dimension d);
    public Dimension(int width, int height);
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual void SetSize(double width, double height);
    public Dimension get_Size();
    public void set_Size(Dimension value);
    public void SetSize(int width, int height);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class System.Drawing.Dimension2D : object {
    public double Width { get; }
    public double Height { get; }
    unknown Dimension2D Size {public set; }
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual void SetSize(double width, double height);
    public void set_Size(Dimension2D value);
    public sealed virtual object Clone();
}
[DefaultMemberAttribute("Item")]
public class System.util.collections.OrderedTree : object {
    private int intCount;
    private OrderedTreeNode rbTree;
    public static OrderedTreeNode sentinelNode;
    private OrderedTreeNode lastNodeFound;
    private Random rand;
    public object Item { get; public set; }
    public OrderedTreeEnumerator Keys { get; }
    public OrderedTreeEnumerator Values { get; }
    public int Count { get; }
    private static OrderedTree();
    public object get_Item(IComparable key);
    public void set_Item(IComparable key, object value);
    public void Add(IComparable key, object data);
    private void RestoreAfterInsert(OrderedTreeNode x);
    public void RotateLeft(OrderedTreeNode x);
    public void RotateRight(OrderedTreeNode x);
    public bool ContainsKey(IComparable key);
    public object GetData(IComparable key);
    public IComparable GetMinKey();
    public IComparable GetMaxKey();
    public object GetMinValue();
    public object GetMaxValue();
    public OrderedTreeEnumerator GetEnumerator();
    public OrderedTreeEnumerator get_Keys();
    public OrderedTreeEnumerator KeyElements(bool ascending);
    public OrderedTreeEnumerator get_Values();
    public OrderedTreeEnumerator Elements();
    public OrderedTreeEnumerator Elements(bool ascending);
    public bool IsEmpty();
    public void Remove(IComparable key);
    private void Delete(OrderedTreeNode z);
    private void RestoreAfterDelete(OrderedTreeNode x);
    public void RemoveMin();
    public void RemoveMax();
    public void Clear();
    public int get_Count();
}
public class System.util.collections.OrderedTreeEnumerator : object {
    private Stack stack;
    private bool keys;
    private bool ascending;
    private OrderedTreeNode tnode;
    private bool pre;
    private IComparable ordKey;
    private object objValue;
    public IComparable Key { get; public set; }
    public object Value { get; public set; }
    public object Current { get; }
    public OrderedTreeEnumerator(OrderedTreeNode tnode, bool keys, bool ascending);
    public IComparable get_Key();
    public void set_Key(IComparable value);
    public object get_Value();
    public void set_Value(object value);
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    public bool HasMoreElements();
    public object NextElement();
    public sealed virtual bool MoveNext();
    public OrderedTreeEnumerator GetEnumerator();
}
public class System.util.collections.OrderedTreeNode : object {
    public static bool RED;
    public static bool BLACK;
    private IComparable ordKey;
    private object objData;
    private bool intColor;
    private OrderedTreeNode rbnLeft;
    private OrderedTreeNode rbnRight;
    private OrderedTreeNode rbnParent;
    public IComparable Key { get; public set; }
    public object Data { get; public set; }
    public bool Color { get; public set; }
    public OrderedTreeNode Left { get; public set; }
    public OrderedTreeNode Right { get; public set; }
    public OrderedTreeNode Parent { get; public set; }
    public IComparable get_Key();
    public void set_Key(IComparable value);
    public object get_Data();
    public void set_Data(object value);
    public bool get_Color();
    public void set_Color(bool value);
    public OrderedTreeNode get_Left();
    public void set_Left(OrderedTreeNode value);
    public OrderedTreeNode get_Right();
    public void set_Right(OrderedTreeNode value);
    public OrderedTreeNode get_Parent();
    public void set_Parent(OrderedTreeNode value);
}
public class System.util.ListIterator : object {
    private ArrayList col;
    private int cursor;
    private int lastRet;
    public ListIterator(ArrayList col);
    public bool HasNext();
    public object Next();
    public object Previous();
    public void Remove();
}
[DefaultMemberAttribute("Item")]
public class System.util.Properties : object {
    private static string whiteSpaceChars;
    private static string keyValueSeparators;
    private static string strictKeyValueSeparators;
    private Hashtable _col;
    public int Count { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public string Remove(string key);
    public IEnumerator GetEnumerator();
    public bool ContainsKey(string key);
    public virtual void Add(string key, string value);
    public void AddAll(Properties col);
    public int get_Count();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public ICollection get_Keys();
    public void Clear();
    public void Load(Stream inStream);
    private string LoadConvert(string theString);
    private bool ContinueLine(string line);
}
public class System.util.StringTokenizer : object {
    private int pos;
    private string str;
    private int len;
    private string delim;
    private bool retDelims;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool retDelims);
    public bool HasMoreTokens();
    public string NextToken(string delim);
    public string NextToken();
    public int CountTokens();
}
public class System.util.Util : object {
    public static int USR(int op1, int op2);
    public static bool EqualsIgnoreCase(string s1, string s2);
    public static int CompareToIgnoreCase(string s1, string s2);
}
internal class System.util.zlib.Adler32 : object {
    private static int BASE;
    private static int NMAX;
    internal long adler32(long adler, Byte[] buf, int index, int len);
}
public class System.util.zlib.Deflate : object {
    private static int MAX_MEM_LEVEL;
    private static int Z_DEFAULT_COMPRESSION;
    private static int MAX_WBITS;
    private static int DEF_MEM_LEVEL;
    private static int STORED;
    private static int FAST;
    private static int SLOW;
    private static int NeedMore;
    private static int BlockDone;
    private static int FinishStarted;
    private static int FinishDone;
    private static int PRESET_DICT;
    private static int Z_FILTERED;
    private static int Z_HUFFMAN_ONLY;
    private static int Z_DEFAULT_STRATEGY;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int REP_3_6;
    private static int REPZ_3_10;
    private static int REPZ_11_138;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int MAX_BITS;
    private static int D_CODES;
    private static int BL_CODES;
    private static int LENGTH_CODES;
    private static int LITERALS;
    private static int L_CODES;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    private static Config[] config_table;
    private static String[] z_errmsg;
    internal ZStream strm;
    internal int status;
    internal Byte[] pending_buf;
    internal int pending_buf_size;
    internal int pending_out;
    internal int pending;
    internal int noheader;
    internal byte data_type;
    internal byte method;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal int max_chain_length;
    internal int max_lazy_match;
    internal int level;
    internal int strategy;
    internal int good_match;
    internal int nice_match;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree l_desc;
    internal Tree d_desc;
    internal Tree bl_desc;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal Byte[] depth;
    internal int l_buf;
    internal int lit_bufsize;
    internal int last_lit;
    internal int d_buf;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal UInt32 bi_buf;
    internal int bi_valid;
    private static Deflate();
    internal void lm_init();
    internal void tr_init();
    internal void init_block();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool smaller(Int16[] tree, int n, int m, Byte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    internal void put_byte(Byte[] p, int start, int len);
    internal void put_byte(byte c);
    internal void put_short(int w);
    internal void putShortMSB(int b);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int val, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void compress_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal int deflate_stored(int flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    internal void fill_window();
    internal int deflate_fast(int flush);
    internal int deflate_slow(int flush);
    internal int longest_match(int cur_match);
    internal int deflateInit(ZStream strm, int level, int bits);
    internal int deflateInit(ZStream strm, int level);
    internal int deflateInit2(ZStream strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int deflateReset(ZStream strm);
    internal int deflateEnd();
    internal int deflateParams(ZStream strm, int _level, int _strategy);
    internal int deflateSetDictionary(ZStream strm, Byte[] dictionary, int dictLength);
    internal int deflate(ZStream strm, int flush);
}
internal class System.util.zlib.InfBlocks : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int TYPE;
    private static int LENS;
    private static int STORED;
    private static int TABLE;
    private static int BTREE;
    private static int DTREE;
    private static int CODES;
    private static int DRY;
    private static int DONE;
    private static int BAD;
    private static Int32[] inflate_mask;
    private static Int32[] border;
    internal int mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InfCodes codes;
    private int last;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int read;
    internal int write;
    internal object checkfn;
    internal long check;
    internal InfTree inftree;
    internal InfBlocks(ZStream z, object checkfn, int w);
    private static InfBlocks();
    internal void reset(ZStream z, Int64[] c);
    internal int proc(ZStream z, int r);
    internal void free(ZStream z);
    internal void set_dictionary(Byte[] d, int start, int n);
    internal int sync_point();
    internal int inflate_flush(ZStream z, int r);
}
internal class System.util.zlib.InfCodes : object {
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    private static Int32[] inflate_mask;
    private int mode;
    private int len;
    private Int32[] tree;
    private int tree_index;
    private int need;
    private int lit;
    private int get;
    private int dist;
    private byte lbits;
    private byte dbits;
    private Int32[] ltree;
    private int ltree_index;
    private Int32[] dtree;
    private int dtree_index;
    private static InfCodes();
    internal void init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, ZStream z);
    internal int proc(InfBlocks s, ZStream z, int r);
    internal void free(ZStream z);
    internal int inflate_fast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InfBlocks s, ZStream z);
}
internal class System.util.zlib.Inflate : object {
    private static int MAX_WBITS;
    private static int PRESET_DICT;
    internal static int Z_NO_FLUSH;
    internal static int Z_PARTIAL_FLUSH;
    internal static int Z_SYNC_FLUSH;
    internal static int Z_FULL_FLUSH;
    internal static int Z_FINISH;
    private static int Z_DEFLATED;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int METHOD;
    private static int FLAG;
    private static int DICT4;
    private static int DICT3;
    private static int DICT2;
    private static int DICT1;
    private static int DICT0;
    private static int BLOCKS;
    private static int CHECK4;
    private static int CHECK3;
    private static int CHECK2;
    private static int CHECK1;
    private static int DONE;
    private static int BAD;
    internal int mode;
    internal int method;
    internal Int64[] was;
    internal long need;
    internal int marker;
    internal int nowrap;
    internal int wbits;
    internal InfBlocks blocks;
    private static Byte[] mark;
    private static Inflate();
    internal int inflateReset(ZStream z);
    internal int inflateEnd(ZStream z);
    internal int inflateInit(ZStream z, int w);
    internal int inflate(ZStream z, int f);
    internal int inflateSetDictionary(ZStream z, Byte[] dictionary, int dictLength);
    internal int inflateSync(ZStream z);
    internal int inflateSyncPoint(ZStream z);
}
internal class System.util.zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    private static int fixed_bl;
    private static int fixed_bd;
    private static int BMAX;
    private static Int32[] fixed_tl;
    private static Int32[] fixed_td;
    private static Int32[] cplens;
    private static Int32[] cplext;
    private static Int32[] cpdist;
    private static Int32[] cpdext;
    private Int32[] hn;
    private Int32[] v;
    private Int32[] c;
    private Int32[] r;
    private Int32[] u;
    private Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZStream z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZStream z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZStream z);
    private void initWorkArea(int vsize);
}
public class System.util.zlib.JZlib : object {
    private static string version_;
    public static int Z_NO_COMPRESSION;
    public static int Z_BEST_SPEED;
    public static int Z_BEST_COMPRESSION;
    public static int Z_DEFAULT_COMPRESSION;
    public static int Z_FILTERED;
    public static int Z_HUFFMAN_ONLY;
    public static int Z_DEFAULT_STRATEGY;
    public static int Z_NO_FLUSH;
    public static int Z_PARTIAL_FLUSH;
    public static int Z_SYNC_FLUSH;
    public static int Z_FULL_FLUSH;
    public static int Z_FINISH;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_ERRNO;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_MEM_ERROR;
    public static int Z_BUF_ERROR;
    public static int Z_VERSION_ERROR;
    public static string version();
}
internal class System.util.zlib.StaticTree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static Int16[] static_ltree;
    internal static Int16[] static_dtree;
    internal static StaticTree static_l_desc;
    internal static StaticTree static_d_desc;
    internal static StaticTree static_bl_desc;
    internal Int16[] static_tree;
    internal Int32[] extra_bits;
    internal int extra_base;
    internal int elems;
    internal int max_length;
    internal StaticTree(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static StaticTree();
}
internal class System.util.zlib.Tree : object {
    private static int MAX_BITS;
    private static int BL_CODES;
    private static int D_CODES;
    private static int LITERALS;
    private static int LENGTH_CODES;
    private static int L_CODES;
    private static int HEAP_SIZE;
    internal static int MAX_BL_BITS;
    internal static int END_BLOCK;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    internal static int Buf_size;
    internal static int DIST_CODE_LEN;
    internal static Int32[] extra_lbits;
    internal static Int32[] extra_dbits;
    internal static Int32[] extra_blbits;
    internal static Byte[] bl_order;
    internal static Byte[] _dist_code;
    internal static Byte[] _length_code;
    internal static Int32[] base_length;
    internal static Int32[] base_dist;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree stat_desc;
    private static Tree();
    internal static int d_code(int dist);
    internal void gen_bitlen(Deflate s);
    internal void build_tree(Deflate s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
public class System.util.zlib.ZDeflaterOutputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream outp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZDeflaterOutputStream(Stream outp);
    public ZDeflaterOutputStream(Stream outp, int level);
    public ZDeflaterOutputStream(Stream outp, int level, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public void Finish();
    public void End();
    public virtual void Close();
}
public class System.util.zlib.ZInflaterInputStream : Stream {
    private static int BUFSIZE;
    protected ZStream z;
    protected int flushLevel;
    protected Byte[] buf;
    private Byte[] buf1;
    protected Stream inp;
    private bool nomoreinput;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZInflaterInputStream(Stream inp);
    public ZInflaterInputStream(Stream inp, bool nowrap);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void WriteByte(byte b);
    public virtual void Close();
    public virtual int ReadByte();
}
public class System.util.zlib.ZStream : object {
    private static int MAX_WBITS;
    private static int DEF_WBITS;
    private static int Z_NO_FLUSH;
    private static int Z_PARTIAL_FLUSH;
    private static int Z_SYNC_FLUSH;
    private static int Z_FULL_FLUSH;
    private static int Z_FINISH;
    private static int MAX_MEM_LEVEL;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    public Byte[] next_in;
    public int next_in_index;
    public int avail_in;
    public long total_in;
    public Byte[] next_out;
    public int next_out_index;
    public int avail_out;
    public long total_out;
    public string msg;
    internal Deflate dstate;
    internal Inflate istate;
    internal int data_type;
    public long adler;
    internal Adler32 _adler;
    public int inflateInit();
    public int inflateInit(bool nowrap);
    public int inflateInit(int w);
    public int inflateInit(int w, bool nowrap);
    public int inflate(int f);
    public int inflateEnd();
    public int inflateSync();
    public int inflateSetDictionary(Byte[] dictionary, int dictLength);
    public int deflateInit(int level);
    public int deflateInit(int level, bool nowrap);
    public int deflateInit(int level, int bits);
    public int deflateInit(int level, int bits, bool nowrap);
    public int deflate(int flush);
    public int deflateEnd();
    public int deflateParams(int level, int strategy);
    public int deflateSetDictionary(Byte[] dictionary, int dictLength);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
    public void free();
}
